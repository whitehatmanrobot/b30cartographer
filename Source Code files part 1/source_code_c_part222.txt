ateBstrArrays(NumberWdmInstances,
									WdmRelPaths,
									CimRelPaths,
									WdmInstanceNames,
									PnPDeviceIds,
								    FriendlyName,
								    DeviceDesc);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				pWdmEnumInstances->Reset();
				i = 0;
				do
				{
					hr = pWdmEnumInstances->Next(WBEM_INFINITE,
												 1,
												 &pWdmInstance,
												 &Count);

					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1) &&
						(i < NumberWdmInstances))
					{
						//
						// Lets get the instance name and then lookup the pnp
						// id for it
						//
						hr = WmiGetProperty(pWdmInstance,
											L"InstanceName",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							//
							// Remember wdm instnace name
							//
							WmipDebugPrint(("CDMPROV: Wdm InstanceName is %ws\n",
											v.bstrVal));
							WdmInstanceNames->Set(i, v.bstrVal);
							hr = FindCimClassByWdmInstanceName(pWdmServices,
								                               pCimServices,
								                               CimClassName,
								                               v.bstrVal,
								                               &bstr1,
								                               &bstr2);
							
							PnPDeviceIds->Set(i, bstr1);
							CimRelPaths->Set(i, bstr2);
							
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// Remember Wdm class relative path
								//
								WmipDebugPrint(("CDMPROV: Found CimRelPath %ws for Wdm class %ws\n",
												CimRelPaths->Get(i), WdmClassName))
								hr = WmiGetProperty(pWdmInstance,
									                L"__RELPATH",
													CIM_STRING,
													&v);
								if (hr == WBEM_S_NO_ERROR)
								{
									WdmRelPaths->Set(i, v.bstrVal);

									//
									// Now try to get FriendlyName and
									// DeviceDesc for the instance
									//
									hr = GetDeviceProperties(pCtx,
										                     pWdmServices,
										                     WdmInstanceNames->Get(i),
                                                             &f,
                                                             &d);
									
									if (hr == WBEM_S_NO_ERROR)
									{
										if (f != NULL)
										{
											FriendlyName->Set(i, f);
										}

										if (d != NULL)
										{
											DeviceDesc->Set(i, d);
										}
									}
									
									i++;
										                    
								}
							} else {
								//
								// We did not find a CIM class
								// to match our Wdm instance
								// names, so we decrement our
								// relpath count and continue
								// searching
								(*RelPathCount)--;
								if (*RelPathCount == 0)
								{
									hr = WBEM_E_NOT_FOUND;
								} else {
									hr = WBEM_S_NO_ERROR;
								}
							}
						}
						pWdmInstance->Release();
					} else {
						if (hr == WBEM_S_FALSE)
						{
							hr = WBEM_S_NO_ERROR;
						}
						break;
					}
				} while (hr == WBEM_S_NO_ERROR);				
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;							
			}
		}
		pWdmEnumInstances->Release();
	}
	
	return(hr);
}

HRESULT FindRelPathByProperty(
    IN IWbemContext *pCtx,
	IN IWbemServices *pServices,
    IN BSTR ClassName,
    IN BSTR PropertyName,
    IN VARIANT *ValueToMatch,
    IN CIMTYPE CIMTypeToMatch,
    OUT VARIANT *RelPath
    )
{
	WCHAR PropertyValue[MAX_PATH];
	PWCHAR pv;
	HRESULT hr;
	IWbemClassObject *pInstance;
	
	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(ValueToMatch != NULL);
	WmipAssert(RelPath != NULL);

	pv = PropertyValue;
	
	switch (ValueToMatch->vt)
	{
		
        case VT_I1:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->cVal);
            break;
        }
                            
        case VT_UI1:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->bVal);
            break;
        }
                            
        case VT_I2:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->iVal);
            break;
        }
                                                        
        case VT_UI2:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->uiVal);
            break;
        }
		

        case VT_UI4:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->ulVal);
            break;
        }
            
        case VT_I4:
        {
            wsprintfW(PropertyValue, L"%d", ValueToMatch->lVal);
            break;
        }

		case VT_BOOL:
		{
			pv = (ValueToMatch->boolVal == VARIANT_TRUE) ?
					                   L"TRUE":
				                       L"FALSE";
			break;
		}

		case VT_BSTR:
		{
			pv = ValueToMatch->bstrVal;
			break;
		}
		
		default:
		{
			WmipDebugPrint(("WMIMAP: Unable to map WDM to CIM for CIMTYPE/VT %d/%d\n",
							CIMTypeToMatch, ValueToMatch->vt));
			return(WBEM_E_FAILED);
		}
	}

	hr = GetInstanceOfClass(pCtx,
							pServices,
							ClassName,
							PropertyName,
							pv,
							NULL,
							&pInstance);
	
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetProperty(pInstance,
							L"__RELPATH",
							CIM_REFERENCE,
							RelPath);
		
		pInstance->Release();
	}
	
	return(hr);
}
    

HRESULT MapWdmClassToCimClassViaProperty(
    IN IWbemContext *pCtx,
	IN IWbemServices *pWdmServices,
	IN IWbemServices *pCimServices,
	IN BSTR WdmShadowClassName,
	IN BSTR WdmMappingClassName,
    IN OPTIONAL BSTR WdmMappingProperty,
	IN BSTR CimMappingClassName,
    IN OPTIONAL BSTR CimMappingProperty,
    OUT CBstrArray *WdmInstanceNames,
    OUT CBstrArray *WdmRelPaths,
    OUT CBstrArray *CimRelPaths,
    OUT int *RelPathCount
	)
{

	HRESULT hr;
	IEnumWbemClassObject *pWdmEnumInstances;
	int NumberWdmInstances;
    CBstrArray PnPDeviceIds, FriendlyName, DeviceDesc;
	CIMTYPE WdmCimType;
	VARIANT WdmProperty, WdmInstanceName;
	VARIANT CimRelPath, WdmRelPath;
	int i;
	IWbemClassObject *pWdmInstance;
	ULONG Count;
	
	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(WdmShadowClassName != NULL);
	WmipAssert(WdmMappingClassName != NULL);
	WmipAssert(WdmMappingProperty != NULL);
	WmipAssert(CimMappingClassName != NULL);
	WmipAssert(CimMappingProperty != NULL);

	//
	// We need to do a mapping from a WDM class to a CIM class. This is
	// done via a common property value within the CIM and WDM mapping
	// classes. If the WDM mapping and shadow classes are different
	// then it is assumed that they both report the same instance names
	//


	//
	// First thing is to enumerate all instances of the WDM mapping
	// class.
	//
	hr = pWdmServices->CreateInstanceEnum(WdmMappingClassName,
										  WBEM_FLAG_USE_AMENDED_QUALIFIERS |
										  WBEM_FLAG_SHALLOW,
										  NULL,
										  &pWdmEnumInstances);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = GetEnumCount(pWdmEnumInstances,
						  &NumberWdmInstances);

		if (hr == WBEM_S_NO_ERROR)
		{
			hr = AllocateBstrArrays(NumberWdmInstances,
									WdmRelPaths,
									CimRelPaths,
									WdmInstanceNames,
									&PnPDeviceIds,
								    &FriendlyName,
								    &DeviceDesc);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				pWdmEnumInstances->Reset();
				i = 0;
				*RelPathCount = 0;
				do
				{
					VariantInit(&CimRelPath);
					VariantInit(&WdmRelPath);
					VariantInit(&WdmInstanceName);

					hr = pWdmEnumInstances->Next(WBEM_INFINITE,
												 1,
												 &pWdmInstance,
												 &Count);

					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1) &&
						(i < NumberWdmInstances))
					{
						//
						// For each instance we try to find an instance
						// of a CIM class whose property matches that
						// of the WDM property. So first lets get the
						// WDM property
						//
						hr = pWdmInstance->Get(WdmMappingProperty,
											   0,
											   &WdmProperty,
											   &WdmCimType,
											   NULL);
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = FindRelPathByProperty(pCtx,
								                       pCimServices,
								                       CimMappingClassName,
								                       CimMappingProperty,
								                       &WdmProperty,
								                       WdmCimType,
								                       &CimRelPath);
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// We found a mapping to a CIM class so
								// get the instance name of the mapping
								// class
								//
								hr = WmiGetProperty(pWdmInstance,
									                L"InstanceName",
									                CIM_STRING,
									                &WdmInstanceName);
								
								if (hr == WBEM_S_NO_ERROR)
								{
									//
									// Now finally we can get the
									// shadow class instance by means
									// of the instance name
									//
									hr = FindRelPathByProperty(pCtx,
										                       pWdmServices,
										                       WdmShadowClassName,
															   L"InstanceName",
										                       &WdmInstanceName,
										                       CIM_STRING,
										                       &WdmRelPath);
									if (hr == WBEM_S_NO_ERROR)
									{									
										CimRelPaths->Set(i, CimRelPath.bstrVal);
										VariantInit(&CimRelPath);
										WdmRelPaths->Set(i, WdmRelPath.bstrVal);
										VariantInit(&WdmRelPath);
										WdmInstanceNames->Set(i, WdmInstanceName.bstrVal);
										VariantInit(&WdmInstanceName);
										i++;
										(*RelPathCount)++;
									}
								}
								
							}
							VariantClear(&WdmProperty);
						}
						pWdmInstance->Release();											
					} else {
						if (hr == WBEM_S_FALSE)
						{
							hr = WBEM_S_NO_ERROR;
						}
						break;
					}

					VariantClear(&CimRelPath);
					VariantClear(&WdmRelPath);
					VariantClear(&WdmInstanceName);
					
				} while (hr == WBEM_S_NO_ERROR);				
			}
		}
		
		pWdmEnumInstances->Release();
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\tests\wmisecur\wmisecur.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wmisecur.c

Abstract:

    Wmi security tool

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <aclapi.h>

#include "wmium.h"

#include "wmiumkm.h"

#define SE_WMIGUID_OBJECT 11
#define WMI_SECURITY_REGSTR "SYSTEM\\CurrentControlSet\\Control\\WMI\\Security"

#define WmipAllocEvent() CreateEvent(NULL, FALSE, FALSE, NULL)
#define WmipFreeEvent(EventHandle) CloseHandle(EventHandle)
HANDLE WmipKMHandle;
ULONG PrintSecurityString(LPSTR Guid);

ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written 
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    if (WmipKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        WmipKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL | 
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (WmipKMHandle == (HANDLE)-1)
        {
            WmipKMHandle = NULL;
            return(GetLastError());
        }
    }
        
    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    do 
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);
              
        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }
        
        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);
    
    WmipFreeEvent(Overlapped.hEvent);
    return(Status);
}

#ifdef SET_SECURITY_BY_HANDLE    
ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    ULONG ReturnSize;
    ULONG Status;
    
    WmiOpenGuidBlock.Guid = *Guid;
    WmiOpenGuidBlock.DesiredAccess = DesiredAccess;
                          
    Status = WmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                  (PVOID)&WmiOpenGuidBlock,
                                  sizeof(WMIOPENGUIDBLOCK),
                                  sizeof(WMIOPENGUIDBLOCK),
                                  &ReturnSize);
                              
    if (Status == ERROR_SUCCESS)
    {
          *Handle = WmiOpenGuidBlock.Handle;
    } else {
        *Handle = NULL;
    }
    return(Status);                      
}
#endif

ULONG SetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Dacl,
    PACL Sacl
    )
{
    HANDLE Handle;
    ULONG Status;
#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                WRITE_DAC | WRITE_OWNER,
                                &Handle);
                
    if (Status == ERROR_SUCCESS)
    {
        Status = SetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        CloseHandle(Handle);
    }
    
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = SetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        RpcStringFree(&GuidName);
    }
#endif
    return(Status);
}

ULONG GetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID *OwnerSid,
    PSID *GroupSid,
    PACL *Dacl,
    PACL *Sacl,
    PSECURITY_DESCRIPTOR *Sd
    )
{
    HANDLE Handle;
    ULONG Status;

#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                READ_CONTROL,
                                &Handle);
            
    if (Status == ERROR_SUCCESS)
    {
        Status = GetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
        CloseHandle(Handle);
    }
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = GetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
                             
        RpcStringFree(&GuidName);

    }
#endif
    
    return(Status);
}



//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


ULONG RemoveWmiSD(
    LPGUID Guid
    )
{
    CHAR GuidName[35];
    HKEY RegistryKey;
    ULONG Status;
    
    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                            "System\\CurrentControlSet\\Control\\Wmi\\Security",
                            &RegistryKey);
    if (Status != ERROR_SUCCESS)
    {
        printf("RegOpenKey returned %d\n", Status);
        return(Status);
    }
        
    if (Guid != NULL)
    {
        wsprintf(GuidName, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2,
                     Guid->Data3,
                     Guid->Data4[0], Guid->Data4[1],
                     Guid->Data4[2], Guid->Data4[3],
                     Guid->Data4[4], Guid->Data4[5],
                     Guid->Data4[6], Guid->Data4[7]);
    } else {
        strcpy(GuidName, "00000000-0000-0000-0000000000000000");
    }
    
    RegDeleteValue(RegistryKey,
                   GuidName);
               
    RegCloseKey(RegistryKey);
    
    return(ERROR_SUCCESS);
}

void Usage(
    void
    )
{
    printf("wmisecur <guid> [owner | group | dacl | adacl] [parameters]\n");
    printf("    wmisecur <guid> owner <account name>\n");
    printf("        sets owner of guid to be <account name>\n\n");
    printf("    wmisecur <guid> group <account name>\n");
    printf("        sets group of guid to be <account name>\n\n");
    printf("    wmisecur <guid> dacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        resets dacl to assign <right1>, <right2>, ... to <account name>\n\n");
    printf("    wmisecur <guid> adacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        appends ace to dacl,<right1>, <right2>, ... assigned to <account name>\n\n");
    printf("    wmisecur <guid> query\n");
    printf("        queries and prints the security string\n\n");
    printf("    Rights: WMIGUID_QUERY\n");
    printf("            WMIGUID_SET\n");
    printf("            WMIGUID_NOTIFICATION\n");
    printf("            WMIGUID_READ_DESCRIPTION\n");
    printf("            WMIGUID_EXECUTE\n");
    printf("            TRACELOG_CREATE_REALTIME\n");
    printf("            TRACELOG_CREATE_ONDISK\n");
    printf("            TRACELOG_GUID_ENABLE\n");
    printf("            TRACELOG_ACCESS_KERNEL_LOGGER\n");
    printf("            TRACELOG_CREATE_INPROC\n");
    printf("            TRACELOG_ACCESS_REALTIME\n");
    printf("            READ_CONTROL\n");
    printf("            WRITE_DAC\n");
    printf("            WRITE_OWNER\n");
    printf("            DELETE\n");
    printf("            SYNCHRONIZE\n");
    printf("            ALL (all wmi specific rights)\n");
    printf("            ALLRIGHTS (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL)\n");
}

typedef enum
{
    SetOwner,
    SetGroup,
    ResetDacl,
    AppendDacl,
    CopyDacl,
    QueryGuid
} OPERATION;

typedef enum
{
    Allow,
    Deny
} ALLOWORDENY;


ULONG SetOwnerOrGroup(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid
    )
{
    ULONG Status;
    
    if (Operation == SetOwner)
    {        
        Status = SetWmiGuidSecurityInfo(Guid,
                                        OWNER_SECURITY_INFORMATION,
                                        Sid,
                                        NULL,
                                        NULL,
                                        NULL);
    } else {
        Status = SetWmiGuidSecurityInfo(Guid,
                                        GROUP_SECURITY_INFORMATION,
                                        NULL,
                                        Sid,
                                        NULL,
                                        NULL);
    }
    return(Status);                                   
}
    
ULONG ResetOrAppendDacl(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid,
    ALLOWORDENY AllowOrDeny,
    ULONG Rights
    )
{
    ULONG Status;
    PSECURITY_DESCRIPTOR OldSD;
    PACL OldDacl, NewDacl;
    UCHAR NewDaclBuffer[512];
    
    NewDacl = (PACL)NewDaclBuffer;
    if ((Operation == AppendDacl) || (Operation == CopyDacl))
    {
        Status = GetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &OldDacl,
                                        NULL,
                                        &OldSD);
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
        
        memcpy(NewDacl, OldDacl, OldDacl->AclSize);
        LocalFree(OldSD);
        NewDacl->AclSize = sizeof(NewDaclBuffer);
    } else {
        RtlCreateAcl(NewDacl,
                     sizeof(NewDaclBuffer),
                     ACL_REVISION);
            
    }

    if (Operation != CopyDacl)
    {
        if (AllowOrDeny == Deny)
        {
            if (! AddAccessDeniedAce(NewDacl, 
                                 ACL_REVISION,
                                 Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        } else {
            if (! AddAccessAllowedAce(NewDacl, 
                                     ACL_REVISION,
                                     Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        }
    }
    
      Status = SetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        NewDacl,
                                        NULL);
    
    
    return(Status);
}

BOOLEAN RightNameToDWord(
    PCHAR RightName,
    PDWORD RightDWord
    )
{
    *RightDWord = 0;
    if (_stricmp(RightName, "WMIGUID_QUERY") == 0)
    {
        *RightDWord = WMIGUID_QUERY;
    } else if (_stricmp(RightName, "WMIGUID_SET") == 0) {
        *RightDWord = WMIGUID_SET;
    } else if (_stricmp(RightName, "WMIGUID_NOTIFICATION") == 0) {
        *RightDWord = WMIGUID_NOTIFICATION;
    } else if (_stricmp(RightName, "WMIGUID_READ_DESCRIPTION") == 0) {
        *RightDWord = WMIGUID_READ_DESCRIPTION;
    } else if (_stricmp(RightName, "WMIGUID_EXECUTE") == 0) {
        *RightDWord = WMIGUID_EXECUTE;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_REALTIME") == 0) {
        *RightDWord = TRACELOG_CREATE_REALTIME;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_ONDISK") == 0) {
        *RightDWord = TRACELOG_CREATE_ONDISK;
    } else if (_stricmp(RightName, "TRACELOG_GUID_ENABLE") == 0) {
        *RightDWord = TRACELOG_GUID_ENABLE;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_KERNEL_LOGGER") == 0) {
        *RightDWord = TRACELOG_ACCESS_KERNEL_LOGGER;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_INPROC") == 0) {
        *RightDWord = TRACELOG_CREATE_INPROC;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_REALTIME") == 0) {
        *RightDWord = TRACELOG_ACCESS_REALTIME;
    } else if (_stricmp(RightName, "READ_CONTROL") == 0) {
        *RightDWord = READ_CONTROL;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "WRITE_OWNER") == 0) {
        *RightDWord = WRITE_OWNER;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "DELETE") == 0) {
        *RightDWord = DELETE;
    } else if (_stricmp(RightName, "SYNCHRONIZE") == 0) {
        *RightDWord = SYNCHRONIZE;
    } else if (_stricmp(RightName, "ALL") == 0) {
        *RightDWord = WMIGUID_ALL_ACCESS;
    } else if (_stricmp(RightName, "ALLRIGHTS") == 0) {
        *RightDWord = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;
    } else {
        return(FALSE);
    }
    
    return(TRUE);
}


int __cdecl main(int argc, char *argv[])
{
    int i;
    ALLOWORDENY AllowOrDeny;
    OPERATION Operation;
    DWORD Rights;
    DWORD NewRight;
    PSID Sid;
    UCHAR SidBuffer[512];
    ULONG SidLength;
    GUID Guid;    
    CHAR ReferencedDomain[512];
    SID_NAME_USE SidNameUse;
    ULONG ReferencedDomainSize;
    ULONG Status;
    
    if (argc < 2)
    {
        Usage();
        return(0);
    }
    
    
    if (_stricmp(argv[2], "owner") == 0)
    {
        Operation = SetOwner;
    } else if (_stricmp(argv[2], "group") == 0) {
        Operation = SetGroup;
    } else if (_stricmp(argv[2], "dacl") == 0) {
        Operation = ResetDacl;
    }  else if (_stricmp(argv[2], "adacl") == 0) {
        Operation = AppendDacl;
    }  else if (_stricmp(argv[2], "copy") == 0) {
        Operation = CopyDacl;
    }  else if (_stricmp(argv[2], "query") == 0) {
        Operation = QueryGuid;
    } else {
        Usage();
        return(0);
    }
    
    //
    // Parse the guid parameter
    if (! wUUIDFromString(argv[1], &Guid))
    {
        printf("Bad guid %s\n", argv[1]);
        return(0);
    }
    
    if (Operation == QueryGuid)
    {
        if (PrintSecurityString(argv[1]))
            printf("Cannot find security set for given guid\n");
        return 0;
    }
    if (Operation == CopyDacl)
    {
        Status = ResetOrAppendDacl(Operation, &Guid, NULL, Allow, 0);
        printf("Status is %d\n", Status);
        return(Status);
    }
    
    if (_stricmp(argv[3], "LocalSystem") == 0)
    {
        //
		// This is a special SID we need to build by hand
		//
			
        //
        // Create SID for LocalSystem dynamically
		//
        Sid = (PSID)malloc(RtlLengthRequiredSid( 1 ));
        if (Sid != NULL)
        {
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
            RtlInitializeSid( Sid, &NtAuthority, 1);
            *(RtlSubAuthoritySid( Sid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
        } else {
            printf("Not enougfh memory for local system sid\n");
			return(ERROR_NOT_ENOUGH_MEMORY);
        }
        
    } else {    
        //
        // Parse the account name parameter
        Sid = (PSID)SidBuffer;
        SidLength = sizeof(SidBuffer);
        ReferencedDomainSize = sizeof(ReferencedDomain);
        if (! LookupAccountName(NULL,
                            argv[3],
                            Sid,
                            &SidLength,
                            ReferencedDomain,
                            &ReferencedDomainSize,
                            &SidNameUse))
        {
            printf("Error %d looking up account %s\n", GetLastError(), argv[3]);
            return(0);
        }
    }
                                    
    
    if ((Operation == SetOwner) ||
        (Operation == SetGroup))
    
    {
        Status = SetOwnerOrGroup(Operation, &Guid, Sid);
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1]);
        }
    } else {
        if (argc < 4)
        {
            Usage();
            return(0);
        }
        
        if (_stricmp(argv[4], "allow") == 0)
        {
            AllowOrDeny = Allow;
        } else if (_stricmp(argv[4], "deny") == 0) {
            AllowOrDeny = Deny;
        } else {
            Usage();
            return(0);
        }
        
        Rights = 0;
        for (i = 5; i < argc; i++)
        {
            if (! RightNameToDWord(argv[i], &NewRight))
            {
                printf("Invalid right %s\n", argv[i]);
                return(0);
            }
            Rights |= NewRight;
        }
        Status = ResetOrAppendDacl(Operation, &Guid, Sid, AllowOrDeny, Rights);
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1]);
        }
    }
}

ULONG
PrintSecurityString(LPSTR GuidStr)
{
    ULONG status;
    HKEY hKey;
    UCHAR buffer[1024];
    ULONG size, i;

    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WMI_SECURITY_REGSTR,
                0L,
                KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS)
        return status;
    size = 1024;
    status = RegQueryValueEx(
                hKey,
                GuidStr,
                NULL,
                NULL,
                buffer,
                &size);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return status;
    }
    printf("\nHKLM,\"%s\",\"%s\",0x00030003,\\\n",
        WMI_SECURITY_REGSTR, GuidStr);
    for (i=0; i<size; i++) {
        if ((i%16) == 0) {
            if (i>0)
                printf(",\\\n");
            printf("        ");
            printf("%02x", buffer[i]);
        }
        else
            printf(",%02x", buffer[i]);
    }
    printf("\n");
    RegCloseKey(hKey);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wbemlib\useful.cpp ===
//***************************************************************************
//
//  Useful.CPP
//
//  Module: CDM Provider
//
//  Purpose: Useful classes
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <wbemprov.h>

#include "debug.h"
#include "useful.h"
#include "wbemmisc.h"

void FreeTheBSTRArray(
    BSTR *Array,
	ULONG Size
    )
/*+++

Routine Description:

	This routine will free the contents of an array of BSTR and then
	the array itself
        
Arguments:

	Array is the array to be freed

	Size is the number of elements in the array
Return Value:

    HRESULT

---*/
{
	ULONG i;

	if (Array != NULL)
	{
		for (i = 0; i < Size; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}
}

CBstrArray::CBstrArray()
{
	Array = NULL;
	ListSize = 0xffffffff;
}

CBstrArray::~CBstrArray()
{
	ULONG i;
	
	if (Array != NULL)
	{
		for (i = 0; i < ListSize; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}

	ListSize = 0xffffffff;
}

HRESULT CBstrArray::Initialize(
    ULONG ListCount
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	ULONG AllocSize;
	
	if (ListCount != 0)
	{
		AllocSize = ListCount * sizeof(BSTR *);
		Array = (BSTR *)WmipAlloc(AllocSize);
		if (Array != NULL)
		{
			memset(Array, 0, AllocSize);
			ListSize = ListCount;
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = ListCount;
	}
	return(hr);
}

BOOLEAN CBstrArray::IsInitialized(
    )
{
	return( (Array != NULL) || (ListSize == 0) );
}

BSTR CBstrArray::Get(
    ULONG Index
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	return(Array[Index]);
}

void CBstrArray::Set(
    ULONG Index,
    BSTR s				 
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	Array[Index] = s;
}

ULONG CBstrArray::GetListSize(
    )
{
	WmipAssert(IsInitialized());

	return(ListSize);
}


CWbemObjectList::CWbemObjectList()
{
	//
	// Constructor, init internal values
	//
	List = NULL;
	RelPaths = NULL;
	ListSize = 0xffffffff;
}

CWbemObjectList::~CWbemObjectList()
{
	ULONG i;
	
	//
	// Destructor, free memory held by this class
	//
	
	if (List != NULL)
	{
		for (i = 0; i < ListSize; i++)
		{
			if (List[i] != NULL)
			{
				List[i]->Release();
			}
		}
		WmipFree(List);
	}
	List = NULL;

	if (RelPaths != NULL)
	{
		FreeTheBSTRArray(RelPaths, ListSize);
		RelPaths = NULL;
	}
	
	ListSize = 0xffffffff;
}

HRESULT CWbemObjectList::Initialize(
    ULONG NumberPointers
    )
{
	HRESULT hr;
	ULONG AllocSize;

	//
	// Initialize class by allocating internal list array
	//

	WmipAssert(List == NULL);

	if (NumberPointers != 0)
	{
		AllocSize = NumberPointers * sizeof(IWbemClassObject *);
		List = (IWbemClassObject **)WmipAlloc(AllocSize);
		if (List != NULL)
		{
			memset(List, 0, AllocSize);
			AllocSize = NumberPointers * sizeof(BSTR);
			
			RelPaths = (BSTR *)WmipAlloc(AllocSize);
			if (RelPaths != NULL)
			{
				memset(RelPaths, 0, AllocSize);
				ListSize = NumberPointers;
				hr = WBEM_S_NO_ERROR;
			} else {
				WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList RelPaths\n"));
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		} else {
			WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList\n"));
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = NumberPointers;
		hr = WBEM_S_NO_ERROR;
	}
	
	return(hr);
}

ULONG CWbemObjectList::GetListSize(
    void
	)
{
	//
	// Accessor for list size
	//

	WmipAssert(IsInitialized());
	
	return(ListSize);
}

IWbemClassObject *CWbemObjectList::Get(
    ULONG Index
    )
{	IWbemClassObject *Pointer;
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	Pointer = List[Index];
	
	return(Pointer);
}


HRESULT CWbemObjectList::Set(
    IN ULONG Index,
	IN IWbemClassObject *Pointer
    )
{
	HRESULT hr;
	VARIANT v;

	WmipAssert(Pointer != NULL);
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());
	
	hr = WmiGetProperty(Pointer,
						L"__RelPath",
						CIM_REFERENCE,
						&v);
	if (hr == WBEM_S_NO_ERROR)
	{
		RelPaths[Index] = v.bstrVal;
		List[Index] = Pointer;		
	}
	return(hr);
}

BSTR /* NOFREE */ CWbemObjectList::GetRelPath(
    IN ULONG Index
	)
{
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	return(RelPaths[Index]);
}

BOOLEAN CWbemObjectList::IsInitialized(
    )
{
	return((ListSize == 0) ||
		   ((List != NULL) && (RelPaths != NULL)));
}


CValueMapping::CValueMapping(
)
{
	VariantInit(&Values);
	ValueMap = NULL;
}

CValueMapping::~CValueMapping(
)
{
	if (ValueMap != NULL)
	{
		WmipFree(ValueMap);
	}

	VariantClear(&Values);
}



HRESULT CValueMapping::EstablishByName(
    IWbemServices *pServices,
    PWCHAR ClassName,
    PWCHAR PropertyName
    )
{
	HRESULT hr;
	PWCHAR Names[2];
	VARTYPE Types[2];
	VARIANT v[2];
	VARTYPE IsValueMapArray, IsValuesArray;
	
	Names[0] = L"ValueMap";
	Types[0] = VT_BSTR;

	Names[1] = L"Values";
	Types[1] = VT_BSTR;
	hr = WmiGetQualifierListByName(pServices,
								   ClassName,
								   PropertyName,
								   2,
								   Names,
								   Types,
								   v);

	if (hr == WBEM_S_NO_ERROR)
	{
		IsValueMapArray = v[0].vt & VT_ARRAY;
		IsValuesArray = v[1].vt & VT_ARRAY;
		if (IsValueMapArray == IsValuesArray)
		{
			if (IsValueMapArray)
			{
				//
				// Qualifiers specified as arrays so we can just
				// set them up
				//
				hr = EstablishByArrays(&v[1],
									   &v[0]);
			} else {
				//
				// Qualifiers specified as scalars
				//
				hr = EstablishByScalars(v[1].bstrVal,
										v[0].bstrVal);
			}
		} else {
			//
			// Both must be an array or a scalar
			//
			hr = WBEM_E_FAILED;
		}

		VariantClear(&v[0]);
		VariantClear(&v[1]);
	}

	return(hr);
}

HRESULT CValueMapping::EstablishByScalars(
    BSTR vValues,
	BSTR vValueMap
	)
{
	HRESULT hr;
	PULONG Number;
	LONG Index;
	SAFEARRAYBOUND Bound;

	//
	// First, establish the ValueMap values
	//
	ValueMap = (PULONG64)WmipAlloc(sizeof(ULONG64));
	if (ValueMap != NULL)
	{
		*ValueMap = _wtoi(vValueMap);
		ValueMapElements = 1;
		
		//
		// Now build a safearray to store the Values element
		//
		ValuesLBound = 0;
		Bound.lLbound = ValuesLBound;
		Bound.cElements = 1;
		Values.parray = SafeArrayCreate(VT_BSTR,
										1,
										&Bound);
		if (Values.parray != NULL)
		{
			Values.vt = VT_BSTR | VT_ARRAY;
			Index = 0;
			hr = SafeArrayPutElement(Values.parray,
									 &Index,
									 vValues);
			if (hr != WBEM_S_NO_ERROR)
			{
				VariantClear(&Values);
			}
		}
		
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	
	
	return(hr);
}

HRESULT CValueMapping::EstablishByArrays(
    VARIANT *vValues,
	VARIANT *vValueMap
    )
{
	HRESULT hr;
	BSTR s;
	LONG ValueMapLBound, ValueMapUBound;
	LONG ValuesUBound, ValuesElements;
	LONG Index;
	LONG i;
	
	//
	// Get the array sizes and ensure that they match
	//
	hr = WmiGetArraySize(vValueMap->parray,
						 &ValueMapLBound,
						 &ValueMapUBound,
						 &ValueMapElements);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetArraySize(vValues->parray,
							 &ValuesLBound,
							 &ValuesUBound,
							 &ValuesElements);

		if (hr == WBEM_S_NO_ERROR)
		{
			if ((ValuesLBound == ValueMapLBound) &&
				(ValuesUBound == ValueMapUBound) &&
				(ValuesElements == ValueMapElements))
			{
				//
				// The ValueMap is balance with the values so parse the
				// valuemaps from strings to ulongs
				//
				ValueMap = (PULONG64)WmipAlloc(ValueMapElements * sizeof(ULONG64));
				if (ValueMap != NULL)
				{
					for (i = 0; i < ValueMapElements; i++)
					{
						Index = i + ValueMapLBound;
						hr = SafeArrayGetElement(vValueMap->parray,
												 &Index,
												 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							ValueMap[i] = _wtoi(s);
							SysFreeString(s);
						}
					}

					//
					// And assign Values to our class
					//
					Values = *vValues;
					VariantInit(vValues);
				} else {
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}					
		}
	}

	return(hr);
}

HRESULT CValueMapping::MapToString(
    IN ULONG64 Number,
    OUT BSTR *String
    )
{
	LONG i;
	WCHAR ss[MAX_PATH];
	LONG Index;
	HRESULT hr;

	//
	// Loop over all values and try to find a match
	//
	for (i = 0, hr = WBEM_E_FAILED;
		 (i < ValueMapElements) && (hr != WBEM_S_NO_ERROR);
		 i++)
	{
		if (Number == ValueMap[i])
		{
			//
			// We found something to map the value to
			//
			Index = i + ValuesLBound;
			hr = SafeArrayGetElement(Values.parray,
									 &Index,
									 String);
		}
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		//
		// There was no match so we just leave the result as a number
		//
		wsprintfW(ss, L"%d", Number);
		*String = SysAllocString(ss);
		if (*String == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	
	return(hr);
}

HRESULT CValueMapping::MapToNumber(
    IN BSTR String,
    OUT PULONG64 Number
    )
{
	LONG i;
	BSTR s;
	LONG Index;
	HRESULT hr, hr2;

	for (i = 0, hr = WBEM_E_FAILED;
		 (i < ValueMapElements) && (hr != WBEM_S_NO_ERROR);
		 i++)
	{
		Index = i + ValuesLBound;
		hr2 = SafeArrayGetElement(Values.parray,
								 &Index,
								 &s);
		
		if (hr2 == WBEM_S_NO_ERROR)
		{
			if (_wcsicmp(s, String) == 0)
			{
				*Number = ValueMap[i];
				hr = WBEM_S_NO_ERROR;
			}
			SysFreeString(s);
		}
	}

	//
	// There was no match so we don't really have anything to map to
	//	
	
	return(hr);
}

HRESULT CValueMapping::MapVariantToNumber(
    VARIANT *v,
    CIMTYPE NewType
    )
{
	HRESULT hr;
	VARTYPE BaseType, IsArray;
	ULONG64 Number;
	VARTYPE NewVarType;
	WCHAR ss[MAX_PATH];
	
	BaseType = v->vt & ~VT_ARRAY;
	IsArray = v->vt & VT_ARRAY;
	
	WmipAssert(BaseType == VT_BSTR);
	
	if (IsArray == VT_ARRAY)
	{
		//
		// The variant is an array so we need to map each element in an
		// array
		//
		SAFEARRAYBOUND Bounds;
		SAFEARRAY *Array;
		ULONG Value;
		LONG UBound, LBound, Elements, Index;
		BSTR s;
		LONG i;

		hr = WmiGetArraySize(v->parray,
							 &LBound,
							 &UBound,
							 &Elements);
		if (hr == WBEM_S_NO_ERROR)
		{
			if ((NewType == (CIM_SINT64 | CIM_FLAG_ARRAY)) ||
		        (NewType == (CIM_UINT64 | CIM_FLAG_ARRAY)))
			{
				//
				// If we are mapping to a 64bit number we need to make
				// it into a string so setup as an safearray of strings
				//
				NewVarType = VT_BSTR | VT_ARRAY;
			} else {
				NewVarType = (VARTYPE)NewType;
			}
			
			Bounds.lLbound = LBound;
			Bounds.cElements = Elements;
			Array = SafeArrayCreate(NewVarType,
									1,
									&Bounds);
			
			if (Array != NULL)
			{
				for (i = 0;
					 (i < Elements) && (hr == WBEM_S_NO_ERROR);
					 i++)
				{
					Index = i + LBound;
					hr = SafeArrayGetElement(v->parray,
											 &Index,
											 &s);
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = MapToNumber(s,
										 &Number);
						SysFreeString(s);
						
						if (hr == WBEM_S_NO_ERROR)
						{
							if (NewVarType == (VT_BSTR | VT_ARRAY))
							{
								//
								// Mapping to a 64bit number so convert
								// to string first
								//
								wsprintfW(ss, L"%d", Number);
								s = SysAllocString(ss);
								if (s != NULL)
								{
									hr = SafeArrayPutElement(Array,
										                     &Index,
										                     s);
									SysFreeString(s);
								} else {
									hr = WBEM_E_OUT_OF_MEMORY;
								}
							} else {
								hr = SafeArrayPutElement(Array,
														 &Index,
														 &Number);
							}
						}
					}
				}
				
				if (hr == WBEM_S_NO_ERROR)
				{
					VariantClear(v);
					v->vt = NewType | VT_ARRAY;
					v->parray = Array;
				} else {
					SafeArrayDestroy(Array);
				}
			}
		}

	} else {
		//
		// The variant is a scalar so we just need to map one thing
		//
		hr = MapToNumber(v->bstrVal,
						 &Number);
		if (hr == WBEM_S_NO_ERROR)
		{
			VariantClear(v);
			WmiSetNumberInVariant(v,
						          NewType,
           						  Number);
		}
	}
	return(hr);
}

HRESULT CValueMapping::MapVariantToString(
    VARIANT *v,
    CIMTYPE OldType
    )
{
	VARTYPE BaseType, IsArray;
	ULONG64 Number;
	BSTR s;
	HRESULT hr;
	LONG i;

	BaseType = v->vt & ~VT_ARRAY;
	IsArray = v->vt & VT_ARRAY;
	
	if (IsArray == VT_ARRAY)
	{
		//
		// The variant is an array so we need to map each element in an
		// array
		//
		SAFEARRAYBOUND Bounds;
		SAFEARRAY *Array;
		ULONG Value;
		LONG UBound, LBound, Elements, Index;

		hr = WmiGetArraySize(v->parray,
							 &LBound,
							 &UBound,
							 &Elements);
		if (hr == WBEM_S_NO_ERROR)
		{
			Bounds.lLbound = LBound;
			Bounds.cElements = Elements;
			Array = SafeArrayCreate(VT_BSTR,
									1,
									&Bounds);
			
			if (Array != NULL)
			{
				for (i = 0;
					 (i < Elements) && (hr == WBEM_S_NO_ERROR);
					 i++)
				{
					Index = i + LBound;

					if (BaseType == VT_BSTR)
					{
						//
						// If base type is a string then we assume that
						// we've got a 64bit number which is encoded as
						// a string. So we need to fish out the string
						// and convert it to a ULONG64
						//
						WmipAssert((OldType == (CIM_SINT64 | CIM_FLAG_ARRAY)) ||
								   (OldType == (CIM_UINT64 | CIM_FLAG_ARRAY)));
						
						hr = SafeArrayGetElement(v->parray,
												 &Index,
												 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							Number = _wtoi(s);
							SysFreeString(s);
						}
					} else {
						//
						// Otherwise the number is acutally encoded as
						// a number so fish out the number
						//
						Number = 0;
						hr = SafeArrayGetElement(v->parray,
												 &Index,
												 &Number);
					}
					
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = MapToString(Number,
										 &s);
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = SafeArrayPutElement(Array,
								                     &Index,
												     s);
							SysFreeString(s);
						}
					}
				}
				
				if (hr == WBEM_S_NO_ERROR)
				{
					VariantClear(v);
					v->vt = VT_BSTR | VT_ARRAY;
					v->parray = Array;
				} else {
					SafeArrayDestroy(Array);
				}
			}
		}

	} else {
		//
		// The variant is a scalar so we just need to map one thing
		//
        WmiGetNumberFromVariant(v,
								 OldType,
								 &Number);
		 
		hr = MapToString(Number,
						 &s);
		if (hr == WBEM_S_NO_ERROR)
		{
			VariantClear(v);
			v->vt = VT_BSTR;
			v->bstrVal = s;
		}
	}
	return(hr);
}

#ifndef HEAP_DEBUG
PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	return(LocalAlloc(LPTR, Size));
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	LocalFree(Ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wbemlib\wbemmisc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wbemmisc.cpp
//
//  Abstract:    Misc routines useful for interfacing with WBEM
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <windows.h>
#include <wbemidl.h>
#include <wbemtime.h>

#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "debug.h"
#include "useful.h"
#include "wbemmisc.h"


HRESULT GetMethodInParamInstance(
    IN IWbemServices *pServices,
	IN PWCHAR ClassName,
    IN BSTR MethodName,
    OUT IWbemClassObject **ppInParamInstance
	)
/*+++

Routine Description:

    This routine will return an instance object for a methods in
    parameter. WBEM requires that we go through this dance to get an
    instance object.
        
Arguments:

    pServices

    ClassName is the class containing the method

    MethodName is the name of the method

    *ppInParamInstance returns the instance object to fill with in
        parameters

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemClassObject *pInParamClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(MethodName != NULL);
	WmipAssert(ppInParamInstance != NULL);
	
	hr = pServices->GetObject(ClassName,
								 0,
								 NULL,
								 &pClass,
								 NULL);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = pClass->GetMethod(MethodName,
									  0,
									  &pInParamClass,
									  NULL);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = pInParamClass->SpawnInstance(0,
											  ppInParamInstance);
			pInParamClass->Release();
		}
		pClass->Release();
	}
	
    return(hr);			
}


HRESULT WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PWCHAR QualifierName,
    IN VARTYPE Type,
    OUT /* FREE */ VARIANT *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific qualifier
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    QualifierName is the name of the qualifier
        
    Type is the type of qualifier expected
        
    *Value returns with the value of the qualifier. Caller must call
		VariantClear

Return Value:

	HRESULT

---*/
{
    BSTR s;
    HRESULT hr;

    WmipAssert(pIWbemQualifierSet != NULL);
    WmipAssert(QualifierName != NULL);
    WmipAssert(Value != NULL);
    
    s = SysAllocString(QualifierName);
    if (s != NULL)
    {
        hr = pIWbemQualifierSet->Get(s,
                                0,
                                Value,
                                NULL);
                
        if ((Value->vt & ~CIM_FLAG_ARRAY) != Type)
        {
            hr = WBEM_E_FAILED;
			VariantClear(Value);
        }
        
        SysFreeString(s);
    } else {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return(hr);
}

HRESULT GetListOfQualifiers(
    IN IWbemQualifierSet *pQualifiers,
    IN ULONG Count,
    IN PWCHAR *Names,
    IN VARTYPE *Types,
    OUT VARIANT /* FREE */ *Values,
    IN BOOLEAN AbortOnError
    )
{
	HRESULT hr;
	ULONG i,j;

	WmipAssert(pQualifiers != NULL);
	WmipAssert(Names != NULL);
	WmipAssert(Types != NULL);
	WmipAssert(Values != NULL);

	for (i = 0, hr = WBEM_S_NO_ERROR; (i < Count) && (hr == WBEM_S_NO_ERROR); i++)
	{
		hr = WmiGetQualifier(pQualifiers,
							 Names[i],
							 Types[i],
							 &Values[i]);

		if (hr != WBEM_S_NO_ERROR)
		{
			if (AbortOnError)
			{
				for (j = 0; j < i; j++)
				{
					VariantClear(&Values[j]);
				}
				break;
			} else {
				VariantInit(&Values[i]);
				hr = WBEM_S_NO_ERROR;
			}
		}
	}
	return(hr);
}

HRESULT WmiGetQualifierListByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN ULONG QualifierCount,
    IN PWCHAR *QualifierNames,
    IN VARTYPE *Types,
    OUT VARIANT /* FREE */ *Values
    )
/*+++

Routine Description:

    This routine will return the values for a list of qualifiers. If
    all qualifiers cannot be returned then none are.
        
Arguments:

	pServices is the IWbemServices pointer

	ClassName is the name of the class with qualifiers

	PropertyName is the name of the property with qualfiers. If NULL
		then class qualifiers are returned

	QualifierCount is the count of qualifers to get

	QualifierNames is an array contaiing names of qualifiers to get

	Types is an array of expected value types for the qualifiers

	Values is an array of variants that return with the qualifer values

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemQualifierSet *pQualifiers;
	ULONG i, j;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(QualifierNames != NULL);
	WmipAssert(Types != NULL);
	WmipAssert(Values != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName,
							  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							  NULL,
							  &pClass,
							  NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		if (PropertyName == NULL)
		{
			hr = pClass->GetQualifierSet(&pQualifiers);
		} else {
			hr = pClass->GetPropertyQualifierSet(PropertyName,
				                                 &pQualifiers);
		}
		
		if (hr == WBEM_S_NO_ERROR)
		{
			for (i = 0; (i < QualifierCount) && (hr == WBEM_S_NO_ERROR); i++)
			{
				hr = WmiGetQualifier(pQualifiers,
									 QualifierNames[i],
									 Types[i],
									 &Values[i]);
			}

			if (hr != WBEM_S_NO_ERROR)
			{
				for (j = 0; j < i; j++)
				{
					VariantClear(&Values[j]);
				}
			}
			
			pQualifiers->Release();
		}
		pClass->Release();
	}
	
	return(hr);
}



HRESULT WmiGetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
    HRESULT hr;
	CIMTYPE CimType;

    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);
    
	hr = pIWbemClassObject->Get(PropertyName,
                                0,
                                Value,
								&CimType,
                                NULL);

	//
	// Treat a NULL value for a property as an error
	//
	if (Value->vt == VT_NULL)
	{
		hr = WBEM_E_ILLEGAL_NULL;
		WmipDebugPrint(("CDMPROV: Property %ws is NULL\n",
						PropertyName));
	}
	
	//
	// Treat CIM_REFERENCE and CIM_STRING as interchangable
	//
	if ((ExpectedCimType == CIM_REFERENCE) &&
        (CimType == CIM_STRING))
	{
		ExpectedCimType = CIM_STRING;
	}
	
	if ((ExpectedCimType == CIM_STRING) &&
        (CimType == CIM_REFERENCE))
	{
		ExpectedCimType = CIM_REFERENCE;
	}
	
	if ((hr == WBEM_S_NO_ERROR) && (ExpectedCimType != CimType))
	{
		WmipDebugPrint(("CDMPROV: Property %ws was expected as %d but was got as %d\n",
						PropertyName,
						ExpectedCimType,
						CimType));
		WmipAssert(FALSE);
		hr = WBEM_E_FAILED;
		VariantClear(Value);
	}
        

    return(hr);
}


HRESULT WmiGetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,						   
    IN PWCHAR *PropertyNames,
    IN CIMTYPE *ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyNames is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	ULONG i,j;
	HRESULT hr;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(ExpectedCimType != NULL);
	WmipAssert(Value != NULL);

	
	for (i = 0, hr = WBEM_S_NO_ERROR;
		 (i < PropertyCount) && (hr == WBEM_S_NO_ERROR);
		 i++)
	{
		hr = WmiGetProperty(pIWbemClassObject,
							PropertyNames[i],
							ExpectedCimType[i],
							&Value[i]);
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		for (j = 0; j < i; j++)
		{
			VariantClear(&Value[i]);
		}
	}
	return(hr);
}

HRESULT WmiGetPropertyByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property within a
    class
        
Arguments:

	pServices is the IWbemServices for the namespace containing your
		class
	
    ClassName is the name of the class whose property you are
		interested in
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(Value != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName, 0, NULL, &pClass, NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetProperty(pClass,
							PropertyName,
							ExpectedCimType,
							Value);

		pClass->Release();
	}
	
	return(hr);
}


HRESULT WmiSetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN VARIANT *Value
    )
/*+++

Routine Description:

    This routine will set the value of a property to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyName is the name of the property being set

	Value is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	
    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);

	hr = pIWbemClassObject->Put(PropertyName,
						   0,
						   Value,
						   0);

	if (hr == WBEM_E_TYPE_MISMATCH)
	{
		WmipDebugPrint(("CDMPROV: Put %ws has wrong type %d\n",
						PropertyName, Value->vt));
		WmipAssert(FALSE);
	}
	
	return(hr);
}

HRESULT WmiSetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,
    IN PWCHAR *PropertyNames,
    IN VARIANT *Values
    )
/*+++

Routine Description:

    This routine will set the values of multiple properties to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyCount is the number of properties to set

	PropertyNames is the names of the property being set

	Values is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	ULONG i;
	HRESULT hr = WBEM_S_NO_ERROR;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(Values != NULL);

	for (i = 0; (i < PropertyCount) && (hr == WBEM_S_NO_ERROR); i++)
	{		
		hr = WmiSetProperty(pIWbemClassObject,
							PropertyNames[i],
							&Values[i]);
	}
	
	return(hr);
}


PWCHAR AddSlashesToStringW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\. It needs to
    do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;

	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one
    //
    while (*Namespace != 0)
    {
        if (*Namespace == L'\\')
        {
            *SlashedNamespace++ = L'\\';
        }
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

PWCHAR AddSlashesToStringExW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\ and " into
    \".  It needs to do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;
    
	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one. We also need to add a \ before any ".
    //
    while (*Namespace != 0)
    {
        if ((*Namespace == L'\\') || (*Namespace == L'"'))
        {
            *SlashedNamespace++ = L'\\';
        }
		
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

HRESULT WmiConnectToWbem(
    IN PWCHAR Namespace,
    OUT IWbemServices **ppIWbemServices
    )
/*+++

Routine Description:

    This routine will establishes a connection to a WBEM namespace on
    the local machine.

Arguments:

	Namespace is the namespace to which to connect

	*ppIWbemServices returns with a IWbemServices * for the namespace

Return Value:

	HRESULT

---*/
{
    IWbemLocator *pIWbemLocator;
    DWORD hr;
    BSTR s;

	WmipAssert(Namespace != NULL);
    WmipAssert(ppIWbemServices != NULL);
    
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pIWbemLocator);
    if (hr == S_OK)
    {
        s = SysAllocString(Namespace);
        if (s != NULL)
        {
			*ppIWbemServices = NULL;
			hr = pIWbemLocator->ConnectServer(s,
                            NULL,                           // Userid
                            NULL,                           // PW
                            NULL,                           // Locale
                            0,                              // flags
                            NULL,                           // Authority
                            NULL,                           // Context
                            ppIWbemServices
                           );
                       
			SysFreeString(s);
                             
		} else {
		    *ppIWbemServices = NULL;
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		
        pIWbemLocator->Release();
    }
    
    return(hr);
}

HRESULT CreateInst(
	IN IWbemContext  *pCtx,
    IN IWbemServices * pNamespace,
    IN WCHAR * pwcClassName,
	OUT /* FREE */ IWbemClassObject ** pNewInst
)
/*+++

Routine Description:

    This routine will create a new instance for the specified class

Arguments:

	pNamespace is the IWbemServices * to the namespace in which the
		class lives

	*pNewinst returns with the new instance of the class

	pwcClassName has the name of the class whose instance is created

	pCtx is the context to use in creating the instance

Return Value:

	HRESULT

---*/
{   
    HRESULT hr;
    IWbemClassObject * pClass;
	
    hr = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if (hr != S_OK)
	{
        return WBEM_E_FAILED;
	}
	
    hr = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();

	WmipDebugPrint(("CDMProv:: Created %ws as %p\n",
					pwcClassName, *pNewInst));

    return(hr);	
}

/* FREE */ BSTR GetCurrentDateTime(
    void
    )
{
	SYSTEMTIME SystemTime;
	WBEMTime WbemTime;

	GetSystemTime(&SystemTime);
	WbemTime = SystemTime;
	return(WbemTime.GetBSTR());
}


HRESULT WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
)
/*+++

Routine Description:

    This routine will information about the size and bounds of a single
    dimensional safe array.
        
Arguments:

    Array is the safe array
        
    *LBound returns with the lower bound of the array

    *UBound returns with the upper bound of the array
        
    *NumberElements returns with the number of elements in the array

Return Value:

    TRUE if successful else FALSE

---*/
{
    HRESULT hr;

    WmipAssert(Array != NULL);
    WmipAssert(LBound != NULL);
    WmipAssert(UBound != NULL);
    WmipAssert(NumberElements != NULL);
    
    //
    // Only single dim arrays are supported
    //
    WmipAssert(SafeArrayGetDim(Array) == 1);
    
    hr = SafeArrayGetLBound(Array, 1, LBound);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = SafeArrayGetUBound(Array, 1, UBound);
        *NumberElements = (*UBound - *LBound) + 1;
    }
    return(hr);
}

BOOLEAN IsUlongAndStringEqual(
    IN ULONG Number,
    IN PWCHAR String
    )
/*+++

Routine Description:

    This routine will convert the passed string to an integer and
    compare it to the passed integer value
        
Arguments:

	Number

	String

Return Value:

    TRUE if equal else FALSE

---*/
{
	ULONG SNumber;

	SNumber = _wtoi(String);
	return ( (Number == SNumber) ? TRUE : FALSE );
}

HRESULT LookupValueMap(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,					   
	IN ULONG Value,
    OUT /* FREE */ BSTR *MappedValue
	)
/*+++

Routine Description:

    This routine will lookup the string value corresponding to an
    integer valuemap
        
Arguments:

	pServices is the pointer to the namespace in which the class is
		locaed

	ClassName is the name of the class

	PropertyName is the name of the property

	Value is the value of the property and is used to look up the
		string that corresponsds to it

	*MappedValue returns a string that contains the string which the
		value maps to
		
Return Value:

    HRESULT

---*/
{
	PWCHAR Names[2];
	VARIANT QualifierValues[2];
	VARTYPE Types[2];
	HRESULT hr;
	BSTR s;
	LONG ValuesLBound, ValuesUBound, ValuesElements;
	LONG ValueMapLBound, ValueMapUBound, ValueMapElements;
	LONG i, Index;


	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(MappedValue != NULL);
	
	//
	// Get the Values and ValueMap qualifiers so we can do the mapping
	//
	Names[0] = L"Values";
	Types[0] = VT_BSTR;
	
	Names[1] = L"ValueMap";
	Types[1] = VT_BSTR;
	
	hr = WmiGetQualifierListByName(pServices,
								   ClassName,
								   PropertyName,
								   2,
								   Names,
								   Types,
								   QualifierValues);
	if (hr == WBEM_S_NO_ERROR)
	{
		//
		// Now do a sanity check to make sure the values and valuemaps
		// have the same number of elements
		//

		if (QualifierValues[0].vt == QualifierValues[1].vt)
		{
			//
			// Values and ValueMap both agree that they are both
			// scalars or both arrays and are both strings
			//
			if (QualifierValues[0].vt & VT_ARRAY)
			{
				//
				// We have an array of thing to check for mapping.
				// First lets make sure that the arrays have identical
				// dimensions
				//
				hr = WmiGetArraySize(QualifierValues[0].parray,
									 &ValuesLBound,
									 &ValuesUBound,
									 &ValuesElements);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = WmiGetArraySize(QualifierValues[1].parray,
									 &ValueMapLBound,
									 &ValueMapUBound,
									 &ValueMapElements);

					if (hr == WBEM_S_NO_ERROR)
					{
						if ((ValuesLBound == ValueMapLBound) &&
						    (ValuesUBound == ValueMapUBound) &&
						    (ValuesElements == ValueMapElements))
						{
							for (i = 0; i < ValueMapElements; i++)
							{
								Index = i + ValueMapLBound;
								hr = SafeArrayGetElement(QualifierValues[1].parray,
														 &Index,
														 &s);
								if (hr == WBEM_S_NO_ERROR)
								{
									if (IsUlongAndStringEqual(Value,
															  s))
									{
										hr = SafeArrayGetElement(QualifierValues[0].parray,
																&Index,
																MappedValue);
										//
										// Make sure loop will
										// terminate
										i = ValueMapElements;
									}
									SysFreeString(s);
								}
							}
						} else {
							hr = WBEM_E_NOT_FOUND;
						}
					}
				}
				
			} else {
				//
				// We have scalars so this should make a fairly simple
				// mapping
				//
				if (IsUlongAndStringEqual(Value,
										  QualifierValues[1].bstrVal))
				{
					*MappedValue = SysAllocString(QualifierValues[0].bstrVal);
					if (*MappedValue == NULL)
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				} else {
					hr = WBEM_E_NOT_FOUND;
				}
			}
		} else {
			hr = WBEM_E_NOT_FOUND;
		}
		
		VariantClear(&QualifierValues[0]);
		VariantClear(&QualifierValues[1]);
	}
	
	return(hr);
}


HRESULT GetInstanceOfClass(
    IWbemContext *pCtx,
    IWbemServices *pServices,
    PWCHAR ClassName,
    PWCHAR PropertyName,
    PWCHAR PropertyValue,
    IEnumWbemClassObject **pEnum,
    IWbemClassObject **pInstance
    )
{
	BSTR sWQL, sQuery;
	WCHAR Query[2*MAX_PATH];
	IEnumWbemClassObject *pEnumInstances;
	WCHAR s[MAX_PATH];
	HRESULT hr;
	ULONG Count;
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		//
		// First get PnP id from Instance name from the MSWmi_PnPDeviceId
		// class (select * from MSWMI_PnPDeviceId where InstanceName =
		// "<WdmInstanceName>"
		//
		if (PropertyName != NULL)
		{
			wsprintfW(Query,
					L"select * from %ws where %ws = \"%ws\"",
					ClassName,
					PropertyName,
					AddSlashesToStringW(s, PropertyValue));
		} else {
			wsprintfW(Query,
					L"select * from %ws",
					ClassName);

		}
		
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = pServices->ExecQuery(sWQL,
									sQuery,
									WBEM_FLAG_FORWARD_ONLY |
									WBEM_FLAG_ENSURE_LOCATABLE,
									pCtx,
									&pEnumInstances);

			if (hr == WBEM_S_NO_ERROR)
			{
				if (pEnum == NULL)
				{
					hr = pEnumInstances->Next(WBEM_INFINITE,
												  1,
												  pInstance,
												  &Count);
					pEnumInstances->Release();
				} else {
					*pEnum = pEnumInstances;
				}
			}
			SysFreeString(sQuery);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}


VARTYPE WmiVarTypeForCimType(
    CIMTYPE CimType
    )
{
    VARTYPE vt;
    
    //
    // Most things match their CIM types, except those below
    vt = (VARTYPE)CimType;
    
    switch(CimType)
    {
        case CIM_UINT32:                        
        case CIM_UINT8:
        case CIM_SINT8:
        {
            vt = VT_I4;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            vt = VT_I2;
            break;
        }
                                                                            
        {
            vt = VT_I4;
            break;
        }
                            
        case CIM_STRING:
        case CIM_DATETIME:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            vt = VT_BSTR;
            break;
        }
        
        case CIM_OBJECT:
        {
            vt = VT_UNKNOWN;
            break;
        }
        
        case CIM_BOOLEAN:
        {
            vt = VT_BOOL;
            break;
        }
        
        
    }
    return(vt); 
}


void WmiGetNumberFromVariant(
    VARIANT *v,
    CIMTYPE VType,
    ULONG64 *Number
    )
{
	if ((VType == CIM_SINT64) || (VType == CIM_UINT64))
	{
		WmipAssert(v->vt == VT_BSTR);
		*Number = _wtoi(v->bstrVal);
	} else {
		*Number = 0;
		switch (v->vt)
		{
			case VT_UI1:
			{
				*Number = (ULONG64)v->bVal;
				break;
			}

			case VT_I1:
			{
				*Number = (ULONG64)v->cVal;
				break;
			}

			case VT_I2:
			{
				*Number = (ULONG64)v->iVal;
				break;
			}

			case VT_UI2:
			{
				*Number = (ULONG64)v->uiVal;
				break;
			}

			case VT_UI4:
			{
				*Number = (ULONG64)v->ulVal;
				break;
			}

			case VT_I4:
			{
				*Number = (ULONG64)v->lVal;
				break;
			}
			
			default:
			{
				WmipAssert(FALSE);
				*Number = (ULONG64)v->lVal;
				break;
			}
		}
	}
}

HRESULT WmiSetNumberInVariant(
    VARIANT *v,
    CIMTYPE VType,
    ULONG64 Number
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	
	switch (VType)
	{
        case CIM_UINT8:
        case CIM_SINT8:
        case CIM_UINT32:
        case CIM_SINT32:
        {
            v->vt = VT_I4;
			v->lVal = (LONG)Number;
            break;
        }
                        
        case CIM_CHAR16:
        case CIM_UINT16:
        {
            v->vt = VT_I2;
			v->iVal = (SHORT)Number;
            break;
        }

        case CIM_SINT64:
        case CIM_UINT64:
        {
			WCHAR ss[MAX_PATH];
			BSTR s;
			
            v->vt = VT_BSTR;
			wsprintfW(ss, L"%d", Number);
			s = SysAllocString(ss);
			if (s != NULL)
			{
				v->bstrVal = s;
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			
            break;
        }

		default:
		{
			WmipAssert(FALSE);
			break;
		}
		
	}
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\trace.net\etwapi.cs ===
//---------------------------------------------------------------------------
// File: EtwTrace
//
// A Managed wrapper for Event Tracing for Windows
//
// Author: Melur Raghuraman 
// Date:   01 Oct 2001
//---------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;

namespace Microsoft.Win32.Diagnostics
{
    [System.CLSCompliant(false)]
    [StructLayout(LayoutKind.Explicit, Size=16)]
    internal struct MofField
    {
        [FieldOffset(0)]
        internal unsafe void * DataPointer;
        [FieldOffset(8)]
        internal uint   DataLength;
        [FieldOffset(12)]
        internal uint  DataType;
    }

    [System.CLSCompliant(false)]
    [StructLayout(LayoutKind.Explicit, Size=208)]   // Full Size 192
    internal struct BaseEvent
    {
        [FieldOffset(0)]
        internal uint BufferSize;
        [FieldOffset(4)]
        internal uint ProviderId;
        [FieldOffset(8)]
        internal ulong HistoricalContext;
        [FieldOffset(16)]
        internal Int64 TimeStamp;
        [FieldOffset(24)]
        internal System.Guid  Guid;
        [FieldOffset(40)]
        internal uint ClientContext;
        [FieldOffset(44)]
        internal uint Flags;
        //
        // We have allocated enough space for 10 MOF_FIELD structures 
        // at the bottom. That is 1 argument descriptor, 1 FormatString and 8 arguments. 
        //
        [FieldOffset(48)]
        internal MofField UserData;
    }

    [System.CLSCompliant(false)]
    [StructLayout(LayoutKind.Explicit, Size=8)] 
    internal struct TraceGuidRegistration
    {
        [FieldOffset(0)]
        internal unsafe System.Guid *Guid;
        [FieldOffset(4)]
        internal unsafe void*       RegHandle;
    }


    [System.CLSCompliant(false)]
    [System.Security.SuppressUnmanagedCodeSecurity]
    public sealed class EtwTrace
    {
        // Ensure class cannot be instantiated by making the constructor private
        private EtwTrace() {}
        // Enumerations
        //
        public sealed class RequestCodes
        {
            // Ensure class cannot be instantiated
            private RequestCodes() {}
            public const uint GetAllData = 0;			// Never Used
            public const uint GetSingleInstance = 1;	// Never Used
            public const uint SetSingleInstance = 2;	// Never Used
            public const uint SetSingleItem = 3;		// Never Used
            public const uint EnableEvents = 4;			// Enable Tracing
            public const uint DisableEvents = 5;		// Disable Tracing
            public const uint EnableCollection = 6;		// Never Used
            public const uint DisableCollection = 7;	// Never Used
            public const uint RegInfo = 8;				// Registration Information
            public const uint ExecuteMethod = 9;		// Never Used
        }
        //
        // Flags used by ETW Trace Message
        // Note that the order or value of these flags should NOT be changed as they are processed
        // in this order.
        //
        public sealed class TraceMessageCodes
        {
            // Ensure class cannot be instantiated
            private TraceMessageCodes() {}
            public const uint TRACE_MESSAGE_SEQUENCE                = 1;        // Message should include a sequence number
            public const uint TRACE_MESSAGE_GUID                    = 2;        // Message includes a GUID
            public const uint TRACE_MESSAGE_COMPONENTID             = 4;        // Message has no GUID, Component ID instead
            public const uint TRACE_MESSAGE_TIMESTAMP		        = 8;        // Message includes a timestamp
            public const uint TRACE_MESSAGE_PERFORMANCE_TIMESTAMP   = 16;       // Timestamp is the Performance Counter not the system clock
            public const uint TRACE_MESSAGE_SYSTEMINFO	            = 32;       // Message includes system information TID,PID
            public const uint TRACE_MESSAGE_FLAG_MASK               = 0xFFFF;   // Only the lower 16 bits of flags are placed in the message
            // those above 16 bits are reserved for local processing
            public const uint TRACE_MESSAGE_MAXIMUM_SIZE            = 8*1024;   // the maximum size allowed for a single trace message
            // longer messages will return ERROR_BUFFER_OVERFLOW
        }

        // Structures

        [StructLayout(LayoutKind.Sequential)]
        public struct CSTRACE_GUID_REGISTRATION
        {
            public unsafe System.Guid *Guid;
            public uint           RegHandle;
        }

        // Function Signatures

        public unsafe delegate  uint EtwProc(uint requestCode, System.IntPtr requestContext, System.IntPtr bufferSize, byte* buffer);
        [DllImport("advapi32", ExactSpelling=true, EntryPoint="GetTraceEnableFlags", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        internal static extern int GetTraceEnableFlags(ulong traceHandle);

        [DllImport("advapi32", ExactSpelling=true, EntryPoint="GetTraceEnableLevel", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        internal static extern char GetTraceEnableLevel(ulong traceHandle);

        [DllImport("advapi32", ExactSpelling=true, EntryPoint="RegisterTraceGuidsW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        internal static extern unsafe uint RegisterTraceGuids([In]EtwProc cbFunc, [In]void* context, [In] ref System.Guid controlGuid, [In] uint guidCount, ref TraceGuidRegistration guidReg, [In]string mofImagePath, [In] string mofResourceName, [Out] out ulong regHandle);

        [DllImport("advapi32", ExactSpelling=true, EntryPoint="UnregisterTraceGuids", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        internal static extern int UnregisterTraceGuids(ulong regHandle);

        [DllImport("advapi32", ExactSpelling=true, EntryPoint="TraceEvent", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        internal static extern unsafe uint TraceEvent(ulong traceHandle, char *header);

		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wbemlib\debug.cpp ===
//***************************************************************************
//
//  debug.CPP
//
//  Module: CDM Provider
//
//  Purpose: Debugging routines
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#ifdef HEAP_DEBUG
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <stdio.h>

#include "debug.h"


void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}

#ifdef HEAP_DEBUG
PVOID MyHeap;

PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	PVOID p;
	
	if (MyHeap == NULL)
	{
        MyHeap = RtlCreateHeap(HEAP_GROWABLE |
							   HEAP_GENERATE_EXCEPTIONS |
							   HEAP_TAIL_CHECKING_ENABLED |
							   HEAP_FREE_CHECKING_ENABLED,
                                        NULL,
                                        0,
                                        0,
                                        NULL,
                                        NULL);
		if (MyHeap == NULL)
		{
			WmipDebugPrint(("CDMPROV: Could not create debug heap\n"));
			return(NULL);
		}
	}
	
	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	
	p = RtlAllocateHeap(MyHeap,
						   0,
						   Size);

	return(p);
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	WmipAssert(MyHeap != NULL);

	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	RtlFreeHeap(MyHeap,
				0,
				Ptr);
}

void * __cdecl ::operator new(size_t Size)
{
	return(WmipAlloc(Size));
}

void __cdecl ::operator delete(void *Ptr)
{
	WmipFree(Ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wmisecur\si.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.cpp
//
//  This file contains the implementation of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#include "si.h"

#include <wmistr.h>

CSecurityInformation::CSecurityInformation()
: m_cRef(1), m_pszObjectName(NULL)   
{

}

CSecurityInformation::~CSecurityInformation()
{
}

STDMETHODIMP
CSecurityInformation::Initialize(LPTSTR pszObject,
								LPGUID Guid)
{
    m_pszObjectName = pszObject;
	m_guid = *Guid;


    return(S_OK);
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSecurityInformation::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CSecurityInformation::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CSecurityInformation::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

ULONG DiscpAnsiToUnicodeSize(
    IN LPCSTR AnsiString,
    OUT ULONG *UnicodeSizeInChar
    )
/*++

Routine Description:

    This routine will return the length needed to represent the ANSI
    string as unicode

Arguments:

    AnsiString is the ansi string whose unicode length is returned

    *UnicodeSizeInChar is number of chars needed to represent ansi
        string as unicode

Return Value:

    ERROR_SUCCESS or error code

--*/
{
        *UnicodeSizeInChar = MultiByteToWideChar(CP_ACP,
                                            0,
                                            AnsiString,
                                            -1,
                                            NULL,
                                            0);

    return((*UnicodeSizeInChar == 0) ? GetLastError() : ERROR_SUCCESS);
}


ULONG DiscpAnsiToUnicode(
    IN LPSTR pszA,
    OUT LPWSTR *ppszW,
    IN ULONG MaxLen
    )
/*++

Routine Description:

    Convert Ansi string into its Unicode equivalent

Arguments:

    pszA is ansi string to convert

    *ppszW on entry has pointer to buffer to write converted string or
        NULL is converted string is to be dynamically allocated
    
Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG cbUnicodeUsed;
    ULONG Status;
    BOOLEAN AllocMemory;
	PWCHAR u;

    //
    // If input is null then just return the same.
    //
    if (pszA == NULL)
    {
        *ppszW = NULL;
        Status = ERROR_SUCCESS;
    } else {
        if (*ppszW == NULL)
        {
            Status = DiscpAnsiToUnicodeSize(pszA, &MaxLen);
            if (Status == ERROR_SUCCESS)
            {
                *ppszW = (PWCHAR)LocalAlloc(LPTR, MaxLen * sizeof(WCHAR));
                if (*ppszW == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    AllocMemory = TRUE;
                }
            }
        } else {
            Status = ERROR_SUCCESS;
            AllocMemory = FALSE;
        }   

        if (Status == ERROR_SUCCESS)
        {
            //
            // Convert to Unicode
            //
            cbUnicodeUsed = MultiByteToWideChar(CP_ACP,
                                                0,
                                                pszA,
                                                -1,
                                                *ppszW,
                                                MaxLen);

            if (0 == cbUnicodeUsed)
            {
                Status = GetLastError();
                if (AllocMemory)
                {
                    LocalFree(*ppszW);
                }
            }
        }
    }

    return(Status);

}

STDMETHODIMP
CSecurityInformation::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
	PWCHAR u;
	
    pObjectInfo->dwFlags = SI_EDIT_PERMS | SI_ADVANCED | SI_EDIT_AUDITS;
    pObjectInfo->hInstance = NULL;
    pObjectInfo->pszServerName = NULL;
	u = NULL;
	DiscpAnsiToUnicode(m_pszObjectName,
					   &u,
					   0);
    pObjectInfo->pszObjectName = u;

    return(S_OK);
}

STDMETHODIMP
CSecurityInformation::GetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD,
                                  BOOL fDefault)
{
    HRESULT hr = S_OK;

    *ppSD = NULL;

    hr = ReadObjectSecurity(m_pszObjectName, si, ppSD);

    return(hr);
}

STDMETHODIMP
CSecurityInformation::SetSecurity(SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;

	hr = WriteObjectSecurity(m_pszObjectName, si, pSD);

    return(hr);
}

STDMETHODIMP
CSecurityInformation::PropertySheetPageCallback(HWND hwnd,
                                                UINT uMsg,
                                                SI_PAGE_TYPE uPage)
{
    return S_OK;
}


STDMETHODIMP
CSecurityInformation::ReadObjectSecurity(LPCTSTR pszObject,
                                         SECURITY_INFORMATION si,
                                         PSECURITY_DESCRIPTOR *ppSD)
{
    DWORD dwErr;

    dwErr = GetWmiGuidSecurityInfo(&m_guid,
                                 si,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 ppSD);

    return(HRESULT_FROM_WIN32(dwErr));
}


STDMETHODIMP
CSecurityInformation::WriteObjectSecurity(LPCTSTR pszObject,
                                          SECURITY_INFORMATION si,
                                          PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwErr;
    SECURITY_DESCRIPTOR_CONTROL wSDControl = 0;
    DWORD dwRevision;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    BOOL bDefaulted;
    BOOL bPresent;

    //
    // Get pointers to various security descriptor parts for
    // calling SetNamedSecurityInfo
    //
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    GetSecurityDescriptorOwner(pSD, &psidOwner, &bDefaulted);
    GetSecurityDescriptorGroup(pSD, &psidGroup, &bDefaulted);
    GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    GetSecurityDescriptorSacl(pSD, &bPresent, &pSacl, &bDefaulted);

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_DACL_PROTECTED)
            si |= PROTECTED_DACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    if (si & SACL_SECURITY_INFORMATION)
    {
        if (wSDControl & SE_SACL_PROTECTED)
            si |= PROTECTED_SACL_SECURITY_INFORMATION;
        else
            si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }

    dwErr = SetWmiGuidSecurityInfo(&m_guid,
                                 si,
                                 psidOwner,
                                 psidGroup,
                                 pDacl,
                                 pSacl);
    return(HRESULT_FROM_WIN32(dwErr));
}

GUID GuidNull = {0, 0, 0, 0, 0, 0x0, 0, 0, 0, 0, 0};

	
SI_ACCESS SIAccess[] =
{
	{
	&GuidNull,
	WMIGUID_QUERY,
	L"Query",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},

	{
	&GuidNull,
	WMIGUID_SET,
	L"Set",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},

	{
	&GuidNull,
	WMIGUID_EXECUTE,
	L"Execute Method",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},

	{
	&GuidNull,
	WMIGUID_NOTIFICATION,
	L"Receive Notification",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},

	{
	&GuidNull,
	SYNCHRONIZE,
	L"Synchronize",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	  	  
	{
		&GuidNull,
		TRACELOG_CREATE_REALTIME,
		L"TRACELOG_CREATE_REALTIME",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
			&GuidNull,
			TRACELOG_CREATE_ONDISK,
			L"TRACELOG_CREATE_ONDISK",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
				&GuidNull,
				TRACELOG_GUID_ENABLE,
				L"TRACELOG_GUID_ENABLE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
					&GuidNull,
					TRACELOG_ACCESS_KERNEL_LOGGER,
					L"TRACELOG_ACCESS_KERNEL_LOGGER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
						&GuidNull,
						TRACELOG_CREATE_INPROC,
						L"TRACELOG_CREATE_INPROC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
							&GuidNull,
							TRACELOG_ACCESS_REALTIME,
							L"TRACELOG_ACCESS_REALTIME",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
								&GuidNull,
								TRACELOG_REGISTER_GUIDS,
								L"TRACELOG_REGISTER_GUIDS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
								&GuidNull,
								WRITE_DAC,
								L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	
	{
								&GuidNull,
								DELETE,
								L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
	},
	

	
};

#define SIAccessCount ( sizeof(SIAccess) / sizeof(SI_ACCESS) )

STDMETHODIMP
CSecurityInformation::GetAccessRights(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
	*ppAccess = SIAccess;
	*pcAccesses = SIAccessCount;
	*piDefaultAccess = 0;
	return(S_OK);
}

GENERIC_MAPPING GenericMapping =
{
								// GENERIC_READ <--> WMIGUID_QUERY
        WMIGUID_QUERY,
								// GENERIC_WRUTE <--> WMIGUID_SET
        WMIGUID_SET,
								// GENERIC_EXECUTE <--> WMIGUID_EXECUTE
        WMIGUID_EXECUTE,
								// GENERIC_ALL <--> WMIGUID_ALL_ACCESS
		WMIGUID_ALL_ACCESS 
};

STDMETHODIMP
CSecurityInformation::MapGeneric(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask)
{
	MapGenericMask(pmask, &GenericMapping);
	return(S_OK);
}

STDMETHODIMP
CSecurityInformation::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
	*ppInheritTypes = NULL;
	*pcInheritTypes = 0;
	return(S_OK);
}


void EditGuidSecurity(
    LPTSTR GuidString,
    LPGUID Guid
    )
{
	CSecurityInformation *pSec;

	pSec = new CSecurityInformation();

	pSec->Initialize(GuidString,
					 Guid);

	EditSecurity(NULL,
				 pSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    Common macros shared between cgen, whnt32, and whbase.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

SOURCES_USED=..\sources.inc

W32_SB=1

MAJORCOMP=windows

# BASE_INC_PATH must be before PROJECT_ROOT\win32\client as each dir has a
# vdm.h in it, and we want the one from BASE_INC_PATH.
INCLUDES=$(INCLUDES);..\inc;$(BASE_INC_PATH);$(PROJECT_ROOT)\win32\inc;$(PROJECT_ROOT)\win32\client
INCLUDES=$(INCLUDES);$(PROJECT_ROOT)\win32\winnls;$(PROJECT_ROOT)\ntdll\wow6432;$(WINDOWS_INC_PATH)
INCLUDES=$(INCLUDES);$(TERMSRV_INC_PATH);$(SDKTOOLS_INC_PATH);$(PROJECT_ROOT)\ntos\inc;$(DS_INC_PATH);

C_DEFINES=$(C_DEFINES) -D_USER32_ -DUNICODE -DUSE_MIRRORING

UMTYPE=windows

NTTARGETFILE0=thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wmisecur\si.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       si.h
//
//  This file contains the definition of the CSecurityInformation
//  base class.
//
//--------------------------------------------------------------------------

#include <aclui.h>

#ifndef _SI_H_
#define _SI_H_


class CSecurityInformation : public ISecurityInformation
{
protected:
    ULONG           m_cRef;
	LPTSTR          m_pszObjectName;
	GUID            m_guid;

public:
    CSecurityInformation();
    virtual ~CSecurityInformation();

    STDMETHOD(Initialize)(LPTSTR pszObject,
								LPGUID Guid);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

protected:
    STDMETHOD(ReadObjectSecurity)(LPCTSTR pszObject,
                                  SECURITY_INFORMATION si,
                                  PSECURITY_DESCRIPTOR *ppSD);
    STDMETHOD(WriteObjectSecurity)(LPCTSTR pszObject,
                                   SECURITY_INFORMATION si,
                                   PSECURITY_DESCRIPTOR pSD);

};

extern "C" void EditGuidSecurity(
    LPTSTR GuidString,
    LPGUID Guid
    );

extern "C" ULONG SetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Dacl,
    PACL Sacl
    );

extern "C" ULONG GetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID *OwnerSid,
    PSID *GroupSid,
    PACL *Dacl,
    PACL *Sacl,
    PSECURITY_DESCRIPTOR *Sd
    );

#endif  /* _SI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cgen\winbld.c ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file is used to verify that winincs.c can be successfully compiled
// by the x86 C compiler.  Do do that, we must undefine __in and __out
#define __in
#define __out
#pragma warning(disable:4049)
#include "winincs.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\wmisecur\wmisecur.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wmisecur.c

Abstract:

    Wmi security tool

Author:

    16-Jan-1997 AlanWar

Revision History:
    5-20-2002 DamianH: Added new parameter so that the SD is printed
    in SDDL format (querysddl). Fix ChangePrivs so that the privilege
    is actually disabled.

--*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <aclapi.h>

#include <sddl.h> // For ConvertSecurityDescriptorToStringSecurityDescriptor
#include <tchar.h> // For TCHAR

#include "wmium.h"

#include "wmiumkm.h"

void EditGuidSecurity(
    LPTSTR GuidString,
    LPGUID Guid
    );


#define SE_WMIGUID_OBJECT 11
#define WMI_SECURITY_REGSTR "SYSTEM\\CurrentControlSet\\Control\\WMI\\Security"

#define WmipAllocEvent() CreateEvent(NULL, FALSE, FALSE, NULL)
#define WmipFreeEvent(EventHandle) CloseHandle(EventHandle)
HANDLE WmipKMHandle;
ULONG PrintSecurityString(LPSTR Guid, BOOL fPrintSDDL);


ULONG ChangePrivs(
    BOOLEAN Enable
    )
{
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    PBYTE               pbOldPriv;
	BYTE				OldPriv[2048];
    ULONG               cbNeeded;
    LUID                LuidPrivilege;
	ULONG Status;


	if (OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token))
	{

		cbNeeded = 0;

		//
		// Initialize the privilege adjustment structure
		//

		LookupPrivilegeValue( NULL, SE_SECURITY_NAME, &LuidPrivilege );
		NewPrivileges = (PTOKEN_PRIVILEGES)malloc( sizeof(TOKEN_PRIVILEGES) +
						                           sizeof(LUID_AND_ATTRIBUTES)
													);
		if (NewPrivileges != NULL)
		{
			NewPrivileges->PrivilegeCount = 1;
			NewPrivileges->Privileges[0].Luid = LuidPrivilege;
			NewPrivileges->Privileges[0].Attributes = Enable ?
              SE_PRIVILEGE_ENABLED : 0;

			//
			// Enable the privilege
			//

			pbOldPriv = OldPriv;
			if (AdjustTokenPrivileges( Token,
										 FALSE,
										 NewPrivileges,
										 sizeof( OldPriv ),
										 (PTOKEN_PRIVILEGES)pbOldPriv,
										 &cbNeeded
									   ))
			{
				CloseHandle(Token);
				if (OpenProcessToken( GetCurrentProcess(),
								   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
								   &Token))
				{
					printf("token is %p\n", Token);
				}
				Status = ERROR_SUCCESS;
			} else {
                Status = GetLastError();
                free( NewPrivileges );
                NewPrivileges = NULL;				
			}
		} else {
			Status = ERROR_NOT_ENOUGH_MEMORY;
		}

		CloseHandle( Token );
		
	} else {
		Status = GetLastError();
	}
	return(Status);
}

ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written 
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    if (WmipKMHandle == NULL)
    {
        //
        // If device is not open for then open it now. The
        // handle is closed in the process detach dll callout (DlllMain)
        WmipKMHandle = CreateFile(WMIDataDeviceName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL | 
                                      FILE_FLAG_OVERLAPPED,
                                      NULL);
        if (WmipKMHandle == (HANDLE)-1)
        {
            WmipKMHandle = NULL;
            return(GetLastError());
        }
    }
        
    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    do 
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);
              
        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }
        
        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);
    
    WmipFreeEvent(Overlapped.hEvent);
    return(Status);
}

#ifdef SET_SECURITY_BY_HANDLE    
ULONG WmipOpenKernelGuid(
    LPGUID Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle
    )
{
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    ULONG ReturnSize;
    ULONG Status;
    
    WmiOpenGuidBlock.Guid = *Guid;
    WmiOpenGuidBlock.DesiredAccess = DesiredAccess;
                          
    Status = WmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                  (PVOID)&WmiOpenGuidBlock,
                                  sizeof(WMIOPENGUIDBLOCK),
                                  sizeof(WMIOPENGUIDBLOCK),
                                  &ReturnSize);
                              
    if (Status == ERROR_SUCCESS)
    {
          *Handle = WmiOpenGuidBlock.Handle;
    } else {
        *Handle = NULL;
    }
    return(Status);                      
}
#endif

ULONG SetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Dacl,
    PACL Sacl
    )
{
    HANDLE Handle;
    ULONG Status;
#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                WRITE_DAC | WRITE_OWNER,
                                &Handle);
                
    if (Status == ERROR_SUCCESS)
    {
        Status = SetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        CloseHandle(Handle);
    }
    
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = SetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl);
        RpcStringFree(&GuidName);
    }
#endif
    return(Status);
}

ULONG GetWmiGuidSecurityInfo(
    LPGUID Guid,
    SECURITY_INFORMATION SecurityInformation,
    PSID *OwnerSid,
    PSID *GroupSid,
    PACL *Dacl,
    PACL *Sacl,
    PSECURITY_DESCRIPTOR *Sd
    )
{
    HANDLE Handle;
    ULONG Status;

#ifdef SET_SECURITY_BY_HANDLE    
    Status = WmipOpenKernelGuid(Guid,
                                READ_CONTROL,
                                &Handle);
            
    if (Status == ERROR_SUCCESS)
    {
        Status = GetSecurityInfo(Handle,
                                 SE_KERNEL_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
        CloseHandle(Handle);
    }
#else
    PCHAR GuidName;

    Status = UuidToString(Guid,
                          &GuidName);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = GetNamedSecurityInfo(GuidName,
                                 SE_WMIGUID_OBJECT,
                                 SecurityInformation,
                                 OwnerSid,
                                 GroupSid,
                                 Dacl,
                                 Sacl,
                                 Sd);
                             
        RpcStringFree(&GuidName);

    }
#endif
    
    return(Status);
}



//
// The routines below were blantenly stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. They are copied here
// so that WMI doesn't need to load in ole32 only to convert a guid string
// into its binary representation.
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


ULONG RemoveWmiSD(
    LPGUID Guid
    )
{
    CHAR GuidName[MAX_PATH];
    HKEY RegistryKey;
    ULONG Status;
    
    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                            "System\\CurrentControlSet\\Control\\Wmi\\Security",
                            &RegistryKey);
    if (Status != ERROR_SUCCESS)
    {
        printf("RegOpenKey returned %d\n", Status);
        return(Status);
    }
        
    if (Guid != NULL)
    {
        wsprintf(GuidName, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2,
                     Guid->Data3,
                     Guid->Data4[0], Guid->Data4[1],
                     Guid->Data4[2], Guid->Data4[3],
                     Guid->Data4[4], Guid->Data4[5],
                     Guid->Data4[6], Guid->Data4[7]);
    } else {
        strcpy(GuidName, "00000000-0000-0000-0000000000000000");
    }
    
    RegDeleteValue(RegistryKey,
                   GuidName);
               
    RegCloseKey(RegistryKey);
    
    return(ERROR_SUCCESS);
}

void Usage(
    void
    )
{
    printf("wmisecur <guid> [query | querysddl | edit | owner | group | dacl | adacl] [parameters]\n");
    printf("    wmisecur <guid> query\n");
    printf("        queries and prints the security string appropriate for inclusion in INF file\n\n");
    printf("    wmisecur <guid> querysddl\n");
    printf("        queries and prints the security string as SDDL\n\n");
    printf("    wmisecur <guid> querysddl\n");
    printf("        queries and prints the security descriptor in SDDL format\n\n");
	printf("    wmisecur <guid> edit\n");
	printf("        opens a security descriptor property sheet for editing the DACL of the guid\n\n");
    printf("    wmisecur <guid> owner <account name>\n");
    printf("        sets owner of guid to be <account name>\n\n");
    printf("    wmisecur <guid> group <account name>\n");
    printf("        sets group of guid to be <account name>\n\n");
    printf("    wmisecur <guid> dacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        resets dacl to assign <right1>, <right2>, ... to <account name>\n\n");
    printf("    wmisecur <guid> adacl <account name> [allow | deny] <right1> <right2> ....\n");
    printf("        appends ace to dacl,<right1>, <right2>, ... assigned to <account name>\n\n");
    printf("    Rights: WMIGUID_QUERY\n");
    printf("            WMIGUID_SET\n");
    printf("            WMIGUID_NOTIFICATION\n");
    printf("            WMIGUID_READ_DESCRIPTION\n");
    printf("            WMIGUID_EXECUTE\n");
    printf("            TRACELOG_CREATE_REALTIME\n");
    printf("            TRACELOG_CREATE_ONDISK\n");
    printf("            TRACELOG_GUID_ENABLE\n");
    printf("            TRACELOG_ACCESS_KERNEL_LOGGER\n");
    printf("            TRACELOG_CREATE_INPROC\n");
    printf("            TRACELOG_ACCESS_REALTIME\n");
    printf("            READ_CONTROL\n");
    printf("            WRITE_DAC\n");
    printf("            WRITE_OWNER\n");
    printf("            DELETE\n");
    printf("            SYNCHRONIZE\n");
    printf("            ALL (all wmi specific rights)\n");
    printf("            ALLRIGHTS (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL)\n");
	printf("  Examples:\n");
	printf("      wmisecur 78ebc105-4cf9-11d2-ba4a-00a0c9062910 edit\n\n");
	printf("      wmisecur 78ebc105-4cf9-11d2-ba4a-00a0c9062910 query\n");
}

typedef enum
{
    SetOwner,
    SetGroup,
    ResetDacl,
    AppendDacl,
    CopyDacl,
    QueryGuid,
	EditGuid,
	ResetSACL,
	CopySACL,
	AppendSACL,
    QueryGuidSDDL
} OPERATION;

typedef enum
{
    Allow,
    Deny
} ALLOWORDENY;


ULONG SetOwnerOrGroup(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid
    )
{
    ULONG Status;
    
    if (Operation == SetOwner)
    {        
        Status = SetWmiGuidSecurityInfo(Guid,
                                        OWNER_SECURITY_INFORMATION,
                                        Sid,
                                        NULL,
                                        NULL,
                                        NULL);
    } else {
        Status = SetWmiGuidSecurityInfo(Guid,
                                        GROUP_SECURITY_INFORMATION,
                                        NULL,
                                        Sid,
                                        NULL,
                                        NULL);
    }
    return(Status);                                   
}
    
ULONG ResetOrAppendDacl(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid,
    ALLOWORDENY AllowOrDeny,
    ULONG Rights
    )
{
    ULONG Status;
    PSECURITY_DESCRIPTOR OldSD;
    PACL OldDacl, NewDacl;
    UCHAR NewDaclBuffer[512];
    
    NewDacl = (PACL)NewDaclBuffer;
    if ((Operation == AppendDacl) || (Operation == CopyDacl))
    {
        Status = GetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &OldDacl,
                                        NULL,
                                        &OldSD);
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
        
        memcpy(NewDacl, OldDacl, OldDacl->AclSize);
        LocalFree(OldSD);
        NewDacl->AclSize = sizeof(NewDaclBuffer);
    } else {
        RtlCreateAcl(NewDacl,
                     sizeof(NewDaclBuffer),
                     ACL_REVISION);
            
    }

    if (Operation != CopyDacl)
    {
        if (AllowOrDeny == Deny)
        {
            if (! AddAccessDeniedAce(NewDacl, 
                                 ACL_REVISION,
                                 Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        } else {
            if (! AddAccessAllowedAce(NewDacl, 
                                     ACL_REVISION,
                                     Rights,
                                     Sid))
            {
                return(GetLastError());
            }
        }
    }
    
      Status = SetWmiGuidSecurityInfo(Guid,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        NewDacl,
                                        NULL);
    
    
    return(Status);
}

ULONG ResetOrAppendSacl(
    OPERATION Operation,
    LPGUID Guid,
    PSID Sid,
    ALLOWORDENY AllowOrDeny,
    ULONG Rights
    )
{
    ULONG Status;
    PSECURITY_DESCRIPTOR OldSD;
    PACL OldDacl, NewDacl;
    UCHAR NewDaclBuffer[512];
    
	Status = ChangePrivs(TRUE);
	if (Status == ERROR_SUCCESS)
	{
		NewDacl = (PACL)NewDaclBuffer;
		if ((Operation == AppendSACL) || (Operation == CopySACL))
		{
			Status = GetWmiGuidSecurityInfo(Guid,
											SACL_SECURITY_INFORMATION,
											NULL,
											NULL,
											NULL,
											&OldDacl,
											&OldSD);
			if (Status != ERROR_SUCCESS)
			{
				return(Status);
			}

			memcpy(NewDacl, OldDacl, OldDacl->AclSize);
			LocalFree(OldSD);
			NewDacl->AclSize = sizeof(NewDaclBuffer);
		} else {
			RtlCreateAcl(NewDacl,
						 sizeof(NewDaclBuffer),
						 ACL_REVISION);

		}

		if (Operation != CopySACL)
		{
			if (AllowOrDeny == Deny)
			{
				if (! AddAccessDeniedAce(NewDacl, 
									 ACL_REVISION,
									 Rights,
										 Sid))
				{
					return(GetLastError());
				}
			} else {
				if (! AddAccessAllowedAce(NewDacl, 
										 ACL_REVISION,
										 Rights,
										 Sid))
				{
					return(GetLastError());
				}
			}
		}

		Status = SetWmiGuidSecurityInfo(Guid,
										SACL_SECURITY_INFORMATION,
										NULL,
										NULL,
										NULL,
										NewDacl);
		ChangePrivs(FALSE);
	}
    
    
    return(Status);
}

BOOLEAN RightNameToDWord(
    PCHAR RightName,
    PDWORD RightDWord
    )
{
    *RightDWord = 0;
    if (_stricmp(RightName, "WMIGUID_QUERY") == 0)
    {
        *RightDWord = WMIGUID_QUERY;
    } else if (_stricmp(RightName, "WMIGUID_SET") == 0) {
        *RightDWord = WMIGUID_SET;
    } else if (_stricmp(RightName, "WMIGUID_NOTIFICATION") == 0) {
        *RightDWord = WMIGUID_NOTIFICATION;
    } else if (_stricmp(RightName, "WMIGUID_READ_DESCRIPTION") == 0) {
        *RightDWord = WMIGUID_READ_DESCRIPTION;
    } else if (_stricmp(RightName, "WMIGUID_EXECUTE") == 0) {
        *RightDWord = WMIGUID_EXECUTE;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_REALTIME") == 0) {
        *RightDWord = TRACELOG_CREATE_REALTIME;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_ONDISK") == 0) {
        *RightDWord = TRACELOG_CREATE_ONDISK;
    } else if (_stricmp(RightName, "TRACELOG_GUID_ENABLE") == 0) {
        *RightDWord = TRACELOG_GUID_ENABLE;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_KERNEL_LOGGER") == 0) {
        *RightDWord = TRACELOG_ACCESS_KERNEL_LOGGER;
    } else if (_stricmp(RightName, "TRACELOG_CREATE_INPROC") == 0) {
        *RightDWord = TRACELOG_CREATE_INPROC;
    } else if (_stricmp(RightName, "TRACELOG_ACCESS_REALTIME") == 0) {
        *RightDWord = TRACELOG_ACCESS_REALTIME;
    } else if (_stricmp(RightName, "READ_CONTROL") == 0) {
        *RightDWord = READ_CONTROL;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "WRITE_OWNER") == 0) {
        *RightDWord = WRITE_OWNER;
    } else if (_stricmp(RightName, "WRITE_DAC") == 0) {
        *RightDWord = WRITE_DAC;
    } else if (_stricmp(RightName, "DELETE") == 0) {
        *RightDWord = DELETE;
    } else if (_stricmp(RightName, "SYNCHRONIZE") == 0) {
        *RightDWord = SYNCHRONIZE;
    } else if (_stricmp(RightName, "ALL") == 0) {
        *RightDWord = WMIGUID_ALL_ACCESS;
    } else if (_stricmp(RightName, "ALLRIGHTS") == 0) {
        *RightDWord = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;
    } else {
        return(FALSE);
    }
    
    return(TRUE);
}


int __cdecl main(int argc, char *argv[])
{
    int i;
    ALLOWORDENY AllowOrDeny;
    OPERATION Operation;
    DWORD Rights;
    DWORD NewRight;
    PSID Sid;
    UCHAR SidBuffer[512];
    ULONG SidLength;
    GUID Guid;    
    CHAR ReferencedDomain[512];
    SID_NAME_USE SidNameUse;
    ULONG ReferencedDomainSize;
    ULONG Status;
    
    if (argc <= 2)
    {
        Usage();
        return(0);
    }
    
    
    if (_stricmp(argv[2], "owner") == 0)
    {
        Operation = SetOwner;
    } else if (_stricmp(argv[2], "group") == 0) {
        Operation = SetGroup;
    } else if (_stricmp(argv[2], "dacl") == 0) {
        Operation = ResetDacl;
    }  else if (_stricmp(argv[2], "adacl") == 0) {
        Operation = AppendDacl;
    }  else if (_stricmp(argv[2], "copy") == 0) {
        Operation = CopyDacl;
    }  else if (_stricmp(argv[2], "query") == 0) {
        Operation = QueryGuid;
    }  else if (_stricmp(argv[2], "edit") == 0) {
        Operation = EditGuid;
    }  else if (_stricmp(argv[2], "sacl") == 0) {
        Operation = ResetSACL;
    }  else if (_stricmp(argv[2], "asacl") == 0) {
        Operation = AppendSACL;
    }  else if (_stricmp(argv[2], "csacl") == 0) {
        Operation = CopySACL;
    }  else if (_stricmp(argv[2], "querysddl") == 0) {
        Operation = QueryGuidSDDL;
    } else {
        Usage();
        return(0);
    }
    
    //
    // Parse the guid parameter
    if (! wUUIDFromString(argv[1], &Guid))
    {
        printf("Bad guid %s\n", argv[1]);
        return(0);
    }

	if (Operation == EditGuid)
	{
		Status = ChangePrivs(TRUE);
		if (Status == ERROR_SUCCESS)
		{
			EditGuidSecurity(argv[1], &Guid);
		}
		ChangePrivs(FALSE);
		return(0);
	}
	
    if (Operation == QueryGuid)
    {
        if (PrintSecurityString(argv[1],FALSE))
            printf("Cannot find security set for given guid\n");
        return 0;
    }

    if (Operation == QueryGuidSDDL)
    {
      DWORD dwErr=ERROR_SUCCESS;
      
      dwErr=PrintSecurityString(argv[1],TRUE);
      
      if (ERROR_SUCCESS!=dwErr) {
        printf("Cannot find security set for given guid (error: 0x%08X )\n",
               dwErr);
      }
      
      return 0;
    }
	

    if (Operation == CopyDacl)
    {
        Status = ResetOrAppendDacl(Operation, &Guid, NULL, Allow, 0);
        printf("Status is %d\n", Status);
        return(Status);
    }
    
    if (Operation == CopySACL)
    {
        Status = ResetOrAppendSacl(Operation, &Guid, NULL, Allow, 0);
        printf("Status is %d\n", Status);
        return(Status);
    }
    
    if (_stricmp(argv[3], "LocalSystem") == 0)
    {
        //
		// This is a special SID we need to build by hand
		//
			
        //
        // Create SID for LocalSystem dynamically
		//
        Sid = (PSID)malloc(RtlLengthRequiredSid( 1 ));
        if (Sid != NULL)
        {
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
            RtlInitializeSid( Sid, &NtAuthority, 1);
            *(RtlSubAuthoritySid( Sid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;
        } else {
            printf("Not enougfh memory for local system sid\n");
			return(ERROR_NOT_ENOUGH_MEMORY);
        }
        
    } else {    
        //
        // Parse the account name parameter
        Sid = (PSID)SidBuffer;
        SidLength = sizeof(SidBuffer);
        ReferencedDomainSize = sizeof(ReferencedDomain);
        if (! LookupAccountName(NULL,
                            argv[3],
                            Sid,
                            &SidLength,
                            ReferencedDomain,
                            &ReferencedDomainSize,
                            &SidNameUse))
        {
            printf("Error %d looking up account %s\n", GetLastError(), argv[3]);
            return(0);
        }
    }
                                    
    
    if ((Operation == SetOwner) ||
        (Operation == SetGroup))
    
    {
        Status = SetOwnerOrGroup(Operation, &Guid, Sid);
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1],FALSE);
        }
    } else {
        if (argc < 4)
        {
            Usage();
            return(0);
        }
        
        if (_stricmp(argv[4], "allow") == 0)
        {
            AllowOrDeny = Allow;
        } else if (_stricmp(argv[4], "deny") == 0) {
            AllowOrDeny = Deny;
        } else {
            Usage();
            return(0);
        }
        
        Rights = 0;
        for (i = 5; i < argc; i++)
        {
            if (! RightNameToDWord(argv[i], &NewRight))
            {
                printf("Invalid right %s\n", argv[i]);
                return(0);
            }
            Rights |= NewRight;
        }

		if ((Operation == AppendDacl) || (Operation == ResetDacl))
		{
			Status = ResetOrAppendDacl(Operation, &Guid, Sid, AllowOrDeny, Rights);
		} else {
			Status = ResetOrAppendSacl(Operation, &Guid, Sid, AllowOrDeny, Rights);
		}
        printf("Status is %d\n", Status);
        if (Status == 0) {
            PrintSecurityString(argv[1],FALSE);
        }
    }
}

ULONG
PrintSecurityString(LPSTR GuidStr, BOOL fPrintSDDL)
{
    ULONG status;
    HKEY hKey;
    UCHAR buffer[1024]={0};
    ULONG size, i;
    LPTSTR pszSD=NULL;

    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WMI_SECURITY_REGSTR,
                0L,
                KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS)
        return status;
    size = 1024;
    status = RegQueryValueEx(
                hKey,
                GuidStr,
                NULL,
                NULL,
                buffer,
                &size);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return status;
    }

    printf("\nHKLM,\"%s\",\"%s\",0x00030003,\\\n",
        WMI_SECURITY_REGSTR, GuidStr);
    if (!fPrintSDDL) {
      for (i=0; i<size; i++) {
        if ((i%16) == 0) {
          if (i>0)
            printf(",\\\n");
          printf("        ");
          printf("%02x", buffer[i]);
        }
        else
          printf(",%02x", buffer[i]);
      }
      printf("\n");
    }
    else {
      if (ConvertSecurityDescriptorToStringSecurityDescriptor(
           (PSECURITY_DESCRIPTOR)buffer,
           SDDL_REVISION_1,
           OWNER_SECURITY_INFORMATION |
           GROUP_SECURITY_INFORMATION |
           DACL_SECURITY_INFORMATION |
           SACL_SECURITY_INFORMATION,
           &pszSD,
           NULL)) {
        _tprintf(_T("SD: %s"),
                 pszSD);
        LocalFree(pszSD);
      }
      else {
        _tprintf(_T("ConvertSecurityDescriptorToStringSecurityDescriptor failed (%d)"),
                 GetLastError());
        return GetLastError();
      }
    }
    
    RegCloseKey(hKey);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cgen\winincs.cpp ===
#include "cgenhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wmi\trace.net\traceevent.cs ===
//---------------------------------------------------------------------------
// File: TraceEvent
//
// A Managed wrapper for Event Tracing for Windows
//
// Author: Melur Raghuraman 
// Extended By: Baskar Sridharan (7 June 2002). 
// Date:   10 Oct 2001
//---------------------------------------------------------------------------
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Reflection;



namespace Microsoft.Win32.Diagnostics
{
    //
    // TODO: Cover all possible EventTypes
    //
    [System.CLSCompliant(false)]
    public sealed class EventType
    {
        // Ensure class cannot be instantiated
        private EventType() {}
        public const uint Info = 0x00;		// Information or Point Event
        public const uint StartEvent = 0x01;		// Start of an activity
        public const uint EndEvent = 0x02;		// End of an activity
        public const uint DcStart = 0x03;	// Event at Start of Data Collection
        public const uint DcEnd = 0x04;		// Event at End of Data Collection
        public const uint Extension = 0x05;	// Extension Event
        public const uint Reply = 0x06;		// Request-Reply Event
        public const uint Dequeue = 0x07;	// Enqueue-Dequeue Event
        public const uint Checkpoint = 0x08;// Checkpoint Event
        public const uint Reserved = 0x09;	// Reserved Event
        public const uint Message = 0xFF;	// Debug Message Event Type

        // new Event Types beyond Win32 types
        public const uint Connect = 0x10;	// Connect Event Type
        public const uint Disconnect = 0x11;// Disconnect Event Type


        // Open-Close, Connect-Disconnect, Request-Response
        // Send-Receive, Start-End, Enqueue-Dequeue, Lock-Unlock
        // Enter-Leave, Parent-child, Read-Write, Create-Delete
        // new-dispose, alloc-free, client-server, 

        // Checkpoint/Marker, 
    }

	
	[System.CLSCompliant(false)]
	internal struct TypeNumberMap
	{			
		internal const byte NULL_NO=0;
		internal const byte OBJECT_NO = 1;
		internal const byte STRING_NO = 2;
		internal const byte SBYTE_NO = 3;
		internal const byte BYTE_NO = 4;
		internal const byte INT16_NO = 5;
		internal const byte UINT16_NO = 6;
		internal const byte INT32_NO = 7;
		internal const byte UINT32_NO = 8;
		internal const byte INT64_NO = 9;
		internal const byte UINT64_NO = 10;
		internal const byte CHAR_NO = 11;
		internal const byte SINGLE_NO = 12;
		internal const byte DOUBLE_NO = 13;
		internal const byte BOOLEAN_NO = 14;
		internal const byte DECIMAL_NO = 15;
		
	}

	
    //
    // TODO: Check with Debug Level constants in NT and System.Diagnostics
    //
	
	public enum TraceFlags: int
	{
		Error=1, Warning=2, Info=4, Info1=8, Info2=16, Info3=32, Info4=64, Info5=128, Info6=256, Info7=512, Info8=1024,
		Performance=2048, Performance1=4096, Performance2=8192, Performance3=16384, Performance4=32768, Performance5=65536,
		Performance6=131072, Performance7=262144, Performance8=524288
	}
	[Guid("189456B1-2B4C-473f-A249-3856DD93F9D3")]
    [System.CLSCompliant(false)]
	public interface ITraceMessageDecoder
	{
		 unsafe int DecodeTraceMessage(byte* message, char* buffer, int bufferSize, ref int dataSize);
	}

    [System.CLSCompliant(false)]
	[Guid("748004CA-4959-409a-887C-6546438CF48E")]
    public  class TraceProvider : ITraceMessageDecoder
    {
        static private EtwTrace.EtwProc etwProc;  // Trace Callback function 
        private ulong  registrationHandle;        // Trace Registration Handle
        private ulong  traceHandle;               // Trace Logger Handle from callback

        private uint   level;                     // Tracing Level 
        private uint   flags;                     // Trace Enable Flags
        private bool   enabled;                   // Enabled flag from Trace callback
		private const byte noOfBytesPerArg = 3;
        private string defaultString = "Foo";
		private string defaultFmtStr = "Default Format String";
		private Hashtable messageFormatTable = new Hashtable();
		string applicationName= "CSharp Software Tracing App";
		//Default GUID used by Trace Message Strings.
        private Guid MessageGuid = new Guid("{b4955bf0-3af1-4740-b475-99055d3fe9aa}");

		
		public TraceProvider()
		{
			//Such a default constructor is required for COM Interop
		}
        public  TraceProvider(string applicationName, Guid controlGuid)
        {
            Level = 0;
            flags = 0;
            IsEnabled= false;
            traceHandle = 0;
            registrationHandle = 0;
			this.applicationName = applicationName; //Currently, we don't use this variable
            //
            // Register the controlGuid with ETW
            //			
            Register(controlGuid);
        }

		
        public TraceProvider(ulong traceHandle)
        {
            this.traceHandle = traceHandle;
        }

        ~TraceProvider()
        {
            //
            // Unregister from ETW using the registrationHandle saved from
            // the register call.
            //
            EtwTrace.UnregisterTraceGuids(registrationHandle);
            GC.KeepAlive(etwProc);
        }

		public uint Flags
		{
			get{
				return flags;
			}	
			
		}
		

		internal uint Level
		{
			get
			{
				return level;
			}
			// set should not be public
			set
			{
				level = value;
			}
		}

		public bool IsEnabled
		{
			get
			{
				return enabled;
			}
			set
			{
				enabled = value;
			}
		}
        

        //
        // This callback function is called by ETW to enable or disable Tracing dynamically
        //
        public unsafe uint MyCallback(uint requestCode, System.IntPtr context, System.IntPtr bufferSize, byte* byteBuffer)
        {
            try
            {
                BaseEvent* buffer = (BaseEvent *)byteBuffer;
                switch(requestCode) 
                {
                    case EtwTrace.RequestCodes.EnableEvents: 
                        traceHandle = buffer->HistoricalContext;
                        //traceHandle = EtwTrace.GetTraceLoggerHandle((BaseEvent *)buffer);
                        flags = (uint)EtwTrace.GetTraceEnableFlags((ulong)buffer->HistoricalContext);
                        Level = (uint)EtwTrace.GetTraceEnableLevel((ulong)buffer->HistoricalContext);
                        IsEnabled = true;
                        break;
                    case EtwTrace.RequestCodes.DisableEvents:                     
                        IsEnabled = false;
                        traceHandle = 0;
                        Level = 0 ;
                        flags = 0 ;
                        break;
                    default:
                        IsEnabled = false;
                        traceHandle = 0;                    
                        break;
                }
                return 0;
            }
            catch(Exception e)
            {
                Console.WriteLine("Exception caught - '{0}'", e.Message);
                return 0;//TODO: Shouldn't we be returning a different value here ?
            }
        }
        //
        // Registers a Dynamically Generated GUID automatically with an inbuilt callback
        //
        private unsafe uint Register(Guid controlGuid)
        {
            uint status;
            TraceGuidRegistration guidReg = new TraceGuidRegistration();
            Guid dummyGuid = new Guid("{b4955bf0-3af1-4740-b475-99055d3fe9aa}");
        
            etwProc = new EtwTrace.EtwProc(MyCallback);


            guidReg.Guid =  &dummyGuid;
            guidReg.RegHandle = null;

            status = EtwTrace.RegisterTraceGuids(etwProc, null, ref controlGuid, 1, ref guidReg, null, null,  out registrationHandle);

            if (status != 0) 
            {
                Console.WriteLine("Register() call Failed with Status {0}", status);
            }
            return status;
        } 

        public unsafe uint TraceEvent(Guid eventGuid, uint evtype)
        {
            BaseEvent ev;      // Takes up 192 bytes on the stack
            ev.ClientContext = 0;
            ev.Guid = eventGuid;
            ev.ProviderId = evtype;
            ev.BufferSize = 48; // sizeof(EVENT_TRACE_HEADER)

            return EtwTrace.TraceEvent(traceHandle, (char*)&ev);
        }

		

               //
        // This is the 1 object overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0)
        {
			return TraceEvent(eventGuid, evtype, data0, null, null, null, null, null, null, null, null);
		}


        //
        // This is the 2 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, null, null, null, null, null, null, null);
		}

        //
        // This is the 3 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, data2, null, null, null, null, null, null);
		}


        //
        // This is the 4 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, data2, data3, null, null, null, null, null);
		}

        //
        // This is the 5 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3, object data4)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, data2, data3, data4, null, null, null, null);
		}

        //
        // This is the 6 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3, object data4, object data5)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, data2, data3, data4, data5, null, null, null);
		}

        //
        // This is the 7 argument overload
        //
        public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3, object data4, object data5, object data6)
        {
			return TraceEvent(eventGuid, evtype, data0, data1, data2, data3, data4, data5, data6, null, null);
		}

        //
        // This is the 8 argument overload
        //
		public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3, object data4, object data5, object data6, object data7)
		{
			return TraceEvent(eventGuid, evtype, data0, data1, data2, data3, data4, data5, data6, data7, null);
		}

		public unsafe uint TraceEvent(Guid eventGuid, uint evtype, object data0, object data1, object data2, object data3, object data4, object data5, object data6, object data7, object data8)
		{
			uint status = 0; 
			BaseEvent ev;      // Takes up 192 bytes on the stack
			char* buffer = stackalloc  char[128];
			uint offset = 0;
			char* ptr = buffer;
			string s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8;
			int stringMask = 0;
			uint argCount=0;

			s0 = s1 = s2 = s3 = s4 = s5 = s6 = s7 = s8 = defaultString;

			ev.Flags = 0x00120000; // define Constants
			ev.Guid = eventGuid;
			ev.ProviderId = evtype;
			MofField *be = null;
			if (data0 != null)
			{
				argCount++;
				be = &(&ev.UserData)[0];
				if ((s0 = ProcessOneObject(data0, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000001;
				}
			}
			if (data1 != null)
			{
				argCount++;
				be = &(&ev.UserData)[1];
				ptr = buffer + offset;
				if ((s1 = ProcessOneObject(data1, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000002;
				}
			}
			if (data2 != null)
			{
				argCount++;
				be = &(&ev.UserData)[2];
				ptr = buffer + offset;
				if ((s2 = ProcessOneObject(data2, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000004;
				}
			}
			if (data3 != null)
			{
				argCount++;
				be = &(&ev.UserData)[3];
				ptr = buffer + offset;
				if ((s3 = ProcessOneObject(data3, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000008;
				}
			}
			if (data4 != null)
			{
				argCount++;
				be = &(&ev.UserData)[4];
				ptr = buffer + offset;
				if ((s4 = ProcessOneObject(data4, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000010;
				}
			}
			if (data5 != null)
			{
				argCount++;
				be = &(&ev.UserData)[5];
				ptr = buffer + offset;
				if ((s5 = ProcessOneObject(data5, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000020;
				}
			}
			if (data6 != null)
			{
				argCount++;
				be = &(&ev.UserData)[6];
				ptr = buffer + offset;
				if ((s6 = ProcessOneObject(data6, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000040;
				}
			}
			if (data7 != null)
			{
				argCount++;
				be = &(&ev.UserData)[7];
				ptr = buffer + offset;
				if ((s7 = ProcessOneObject(data7, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000080;
				}
			}
			if (data8 != null)
			{
				argCount++;
				be = &(&ev.UserData)[8];
				ptr = buffer + offset;
				if ((s8 = ProcessOneObject(data8, be, ptr, ref offset)) != null) 
				{
					stringMask |= 0x00000100;
				}
			}

			//
			// Now pin all the strings and use the stringMask to pass them over through
			// mofField. 
			//

			fixed (char*  vptr0 = s0, vptr1 = s1, vptr2 = s2, vptr3 = s3, vptr4 = s4, vptr5 = s5, vptr6 = s6, vptr7 = s7, vptr8 = s8 )
			{
				if ((stringMask & 0x00000001) != 0)
				{
					(&ev.UserData)[0].DataLength = (uint) s0.Length * 2;
					(&ev.UserData)[0].DataPointer = (void*)vptr0;
					
				}
				if ((stringMask & 0x00000002)!= 0)
				{
					(&ev.UserData)[1].DataLength = (uint) s1.Length * 2;
					(&ev.UserData)[1].DataPointer = (void*)vptr1;
					
				}
				if ((stringMask & 0x00000004)!= 0)
				{
					(&ev.UserData)[2].DataLength = (uint) s2.Length * 2;
					(&ev.UserData)[2].DataPointer = (void*)vptr2;
					
				}
				if ((stringMask & 0x00000008)!= 0)
				{
					(&ev.UserData)[3].DataLength = (uint) s3.Length * 2;
					(&ev.UserData)[3].DataPointer = (void*)vptr3;
					
				}
				if ((stringMask & 0x00000010)!= 0)
				{
					(&ev.UserData)[4].DataLength = (uint) s4.Length * 2;
					(&ev.UserData)[4].DataPointer = (void*)vptr4;
					
				}
				if ((stringMask & 0x00000020)!= 0)
				{
					(&ev.UserData)[5].DataLength = (uint) s5.Length * 2;
					(&ev.UserData)[5].DataPointer = (void*)vptr5;
					
				}
				if ((stringMask & 0x00000040)!= 0)
				{
					(&ev.UserData)[6].DataLength = (uint) s6.Length * 2;
					(&ev.UserData)[6].DataPointer = (void*)vptr6;
					
				}
				if ((stringMask & 0x00000080)!= 0)
				{
					(&ev.UserData)[7].DataLength = (uint) s7.Length * 2;
					(&ev.UserData)[7].DataPointer = (void*)vptr7;
					
				}
				if ((stringMask & 0x00000100)!= 0)
				{
					(&ev.UserData)[8].DataLength = (uint) s8.Length * 2;
					(&ev.UserData)[8].DataPointer = (void*)vptr8;
					
				}
				ev.BufferSize = 48 + argCount * 16;
				status = EtwTrace.TraceEvent(traceHandle, (char*)&ev);
			}
			return status;
		}

		private unsafe string ProcessOneObject(object data, MofField * mofField, char* ptr, ref uint offSet)
		{
			return EncodeObject(data, mofField, ptr, ref offSet, (byte *)null);
		}
		//TODO[1]: Need to accomodate Win64 alignment issues. Code that might cause problems
		// have been tagged with "WIN64 Changes".
		private unsafe string EncodeObject(object data, MofField * mofField, char* ptr, ref uint offSet, byte* ptrArgInfo)
		{
			if (data == null)
			{
				*ptrArgInfo = (byte)0; //NULL type, WIN64 Changes
				*(ushort *)(ptrArgInfo+1) = (ushort)0;				
				mofField->DataLength = 0;				
				mofField->DataPointer=(void *)null; //WIN64 Changes (?)
				return null;
			}
			string sRet = data as string;						
			if (sRet != null)
			{
				*ptrArgInfo = (byte)2; //WIN64 Changes
				*(ushort *)(ptrArgInfo+1) = (ushort)(sRet.Length<65535?sRet.Length:65535); //WIN64 Changes				
				return sRet;
			}
			if (data is sbyte)
			{

				mofField->DataLength = sizeof(sbyte);
				*ptrArgInfo = (byte)3; //WIN64 Changes
				sbyte* sbyteptr = (sbyte*)ptr;
				*sbyteptr = (sbyte) data; //WIN64 Changes
				mofField->DataPointer = (void *) sbyteptr;				
				offSet += sizeof(sbyte);
			}
			else if (data is byte)
			{
				mofField->DataLength = sizeof(byte);
				*ptrArgInfo = (byte)4; //WIN64 Changes
				byte* byteptr = (byte*)ptr;
				*byteptr = (byte) data; //WIN64 Changes
				mofField->DataPointer = (void *) byteptr;				
				offSet += sizeof(byte);
			}
			else if (data is short)
			{
				mofField->DataLength = sizeof(short);
				*ptrArgInfo = (byte)5; //WIN64 Changes
				short* shortptr = (short*)ptr;
				*shortptr = (short) data; //WIN64 Changes
				mofField->DataPointer = (void *) shortptr;				
				offSet += sizeof(short);
			}
			else if (data is ushort)
			{
				mofField->DataLength = sizeof(ushort);
				*ptrArgInfo = (byte)6; //WIN64 Changes
				ushort* ushortptr = (ushort*)ptr;
				*ushortptr = (ushort) data; //WIN64 Changes
				mofField->DataPointer = (void *) ushortptr;				
				offSet += sizeof(ushort);
			}

			else if (data is int)
			{
				mofField->DataLength = sizeof(int);
				*ptrArgInfo = (byte)7; //WIN64 Changes
				int* intptr = (int*)ptr;
				*intptr = (int) data; //WIN64 Changes
				mofField->DataPointer = (void *) intptr;	
				offSet += sizeof(int);
			}
			else if (data is uint ) 
			{
				mofField->DataLength = sizeof(uint);
				*ptrArgInfo = (byte)8; //WIN64 Changes
				uint* uintptr = (uint*)ptr;
				*uintptr = (uint) data; //WIN64 Changes
				mofField->DataPointer = (void *) uintptr;				
				offSet += sizeof(uint);
			}
			else if (data is long ) 
			{
				mofField->DataLength = sizeof(long);
				*ptrArgInfo = (byte)9; //WIN64 Changes
				long* longptr = (long*)ptr;
				*longptr = (long) data; //WIN64 Changes
				mofField->DataPointer = (void *) longptr;				
				offSet += sizeof(long);
			}
			else if (data is ulong ) 
			{
				mofField->DataLength = sizeof(ulong);
				*ptrArgInfo = (byte)10; //WIN64 Changes
				ulong* ulongptr = (ulong*)ptr;
				*ulongptr = (ulong) data; //WIN64 Changes
				mofField->DataPointer = (void *) ulongptr;						
				offSet += sizeof(ulong);
			}
			else if (data is char)
			{
				mofField->DataLength = sizeof(char);
				*ptrArgInfo = (byte)11; //WIN64 Changes
				char* charptr = (char*)ptr;
				*charptr = (char) data; //WIN64 Changes
				mofField->DataPointer = (void *) charptr;				
				offSet += sizeof(char);
			}
			else if (data is float)
			{
				mofField->DataLength = sizeof(float);
				*ptrArgInfo = (byte)12; //WIN64 Changes
				float* floatptr = (float*)ptr;
				*floatptr = (float) data; //WIN64 Changes
				mofField->DataPointer = (void *) floatptr;				
				offSet += sizeof(float);
			}
			else if (data is double)
			{
				mofField->DataLength = sizeof(double);
				*ptrArgInfo = (byte)13; //WIN64 Changes
				double* doubleptr = (double*)ptr;
				*doubleptr = (double) data; //WIN64 Changes
				mofField->DataPointer = (void *) doubleptr;				
				offSet += sizeof(double);
			}
			else if (data is bool)
			{
				mofField->DataLength = sizeof(bool);
				*ptrArgInfo = (byte)14; //WIN64 Changes
				bool* boolptr = (bool*)ptr;
				*boolptr = (bool) data; //WIN64 Changes
				mofField->DataPointer = (void *) boolptr;				
				offSet += sizeof(bool);
			}
			else if (data is decimal)
			{
				mofField->DataLength = (uint)sizeof(decimal); 
				*ptrArgInfo = (byte)15; //WIN64 Changes
				decimal* decimalptr = (decimal*)ptr;
				*decimalptr = (decimal) data; //WIN64 Changes
				mofField->DataPointer = (void *) decimalptr;				
				offSet += (uint)sizeof(decimal);
			}
			else 
			{						
				//To our eyes, everything else is a just a string
				sRet = data.ToString();																
				*ptrArgInfo = (byte)2; //WIN64 Changes
				*(ushort *)(ptrArgInfo+1) = (ushort)(sRet.Length<65535?sRet.Length:65535); //WIN64 Changes
				return sRet;	
			}
			*(ushort *)(ptrArgInfo+1) = (ushort)(mofField->DataLength); //WIN64 Changes (?)
			return sRet;

		}


		private unsafe uint EncodeTraceMessage(Guid eventGuid, uint evtype, byte nargs,  object formatstring, object data2, object data3, object data4, object data5, object data6, object data7, object data8, object data9)
		{
			uint status = 0; 
			BaseEvent ev;      // Takes up 208 bytes on the stack
			char* buffer = stackalloc  char[144+(1+9*noOfBytesPerArg)/sizeof(char)];//28 characters would be 56 bytes!!!. We are allocating more space than we require.			
			//Header structure: 
			//1 byte for number of args
			//3 byte for format string type information,
			//3 bytes each for the type information for a maximum of 8 arguments
			byte *header = (byte *)(buffer+144);				
			uint offset = 0;
			char* ptr = buffer;
			string s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8, s9;
			int stringMask = 0;
			uint argCount=0;			
			byte *ptrHeader = header;			
			s1 = s2 = s3 = s4 = s5 = s6 = s7 = s8 = s9 = defaultString;

			ev.Flags = 0x00120000; // define Constants
			ev.Guid = eventGuid;
			//IMP: evtype MUST  be the same as the one specified in the typeve field for CSharp in default.tmf
			ev.ProviderId = evtype;
			MofField *be = null;	
			if (header != null)
			{				
				be = &(&ev.UserData)[0];				
				header[0] = (byte)nargs; //WIN64 Changes (?)
				be->DataPointer = (void *)header;
				be->DataLength = (uint)(1+nargs*noOfBytesPerArg);
			}
			
			if (formatstring == null)
				formatstring = defaultFmtStr;				
			if (formatstring != null)
			{
				//data1 would, in most cases, be the format string
				argCount++;
				be = &(&ev.UserData)[1];
				ptr = buffer + offset;							
				if ((s1 = EncodeObject(formatstring, be, ptr, ref offset, ++header)) != null) 
				{
					stringMask |= 0x00000002;
				}				
			}
			
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[2];
				ptr = buffer + offset;
				if ((s2 = EncodeObject(data2, be, ptr, ref offset, header+1*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000004;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[3];
				ptr = buffer + offset;
				if ((s3 = EncodeObject(data3, be, ptr, ref offset, header+2*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000008;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[4];
				ptr = buffer + offset;
				if ((s4 = EncodeObject(data4, be, ptr, ref offset, header+3*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000010;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[5];
				ptr = buffer + offset;
				if ((s5 = EncodeObject(data5, be, ptr, ref offset, header+4*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000020;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[6];
				ptr = buffer + offset;
				if ((s6 = EncodeObject(data6, be, ptr, ref offset,header+5*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000040;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[7];
				ptr = buffer + offset;
				if ((s7 = EncodeObject(data7, be, ptr, ref offset,header+6*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000080;
				}
			
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[8];
				ptr = buffer + offset;
				if ((s8 = EncodeObject(data8, be, ptr, ref offset,header+7*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000100;
				}
			}
			if (argCount <= nargs)
			{
				argCount++;
				be = &(&ev.UserData)[9];
				ptr = buffer + offset;
				if ((s9 = EncodeObject(data9, be, ptr, ref offset, header+8*noOfBytesPerArg)) != null) 
				{
					stringMask |= 0x00000200;
				}
			}
			
			//
			// Now pin all the strings and use the stringMask to pass them over through
			// mofField. 
			//

			fixed (char*  vptr1 = s1, vptr2 = s2, vptr3 = s3, vptr4 = s4, vptr5 = s5, vptr6 = s6, vptr7 = s7, vptr8 = s8, vptr9 = s9 )
			{
				
				if ((stringMask & 0x00000002)!= 0)
				{
					
					(&ev.UserData)[1].DataLength = (uint) (s1.Length<65535/2?s1.Length*2:65535);//s1.Length*2;										

					(&ev.UserData)[1].DataPointer = (void*)(vptr1);
				}
				if ((stringMask & 0x00000004)!= 0)
				{
					(&ev.UserData)[2].DataLength = (uint) (s2.Length<65535/2?s2.Length*2:65535);//s2.Length * 2;

					(&ev.UserData)[2].DataPointer = (void*)(vptr2);
				}
				if ((stringMask & 0x00000008)!= 0)
				{
					(&ev.UserData)[3].DataLength = (uint) (s3.Length<65535/2?s3.Length*2:65535);//s3.Length * 2;
					(&ev.UserData)[3].DataPointer = (void*)(vptr3);
				}
				if ((stringMask & 0x00000010)!= 0)
				{
					(&ev.UserData)[4].DataLength = (uint) (s4.Length<65535/2?s4.Length*2:65535);//s4.Length * 2;
					(&ev.UserData)[4].DataPointer = (void*)(vptr4);
				}
				if ((stringMask & 0x00000020)!= 0)
				{
					(&ev.UserData)[5].DataLength = (uint) (s5.Length<65535/2?s5.Length*2:65535);//s5.Length * 2;
					(&ev.UserData)[5].DataPointer = (void*)(vptr5);
				}
				if ((stringMask & 0x00000040)!= 0)
				{
					(&ev.UserData)[6].DataLength = (uint) (s6.Length<65535/2?s6.Length*2:65535);//s6.Length * 2;
					(&ev.UserData)[6].DataPointer = (void*)(vptr6);
				}
				if ((stringMask & 0x00000080)!= 0)
				{
					(&ev.UserData)[7].DataLength = (uint) (s7.Length<65535/2?s7.Length*2:65535);//s7.Length * 2;
					(&ev.UserData)[7].DataPointer = (void*)(vptr7);
				}
				if ((stringMask & 0x00000100)!= 0)
				{
					(&ev.UserData)[8].DataLength = (uint) (s8.Length<65535/2?s8.Length*2:65535);//s8.Length * 2;
					(&ev.UserData)[8].DataPointer = (void*)(vptr8);
				}
				if ((stringMask & 0x00000200)!= 0)
				{
					(&ev.UserData)[9].DataLength = (uint) (s9.Length<65535/2?s9.Length*2:65535);//s9.Length * 2;
					(&ev.UserData)[9].DataPointer = (void*)(vptr9);					
				}
				ev.BufferSize = 48 + (argCount+1) * 16;//the extra mof field is for the header
				status = EtwTrace.TraceEvent(traceHandle, (char*)&ev);
			}
			return status;
		}
		public unsafe int DecodeTraceMessage(byte* message, char* buffer, int bufferSize /* in chars */, ref int dataSize /*Note: This is # of *chars* and not bytes*/)
		{
			if (buffer == null || message == null || bufferSize <= 0)
				return 0; //TODO[1]: Do we need a more detailed error code ?
            try
            {
                int i=0;
                byte nargs = *message;
                ushort lenFmtStr = *(ushort *)(message+2);			
                char* pcFmtStr = (char *)(message+1+nargs*noOfBytesPerArg);//start of the format string
                byte* argData = message+1+nargs*noOfBytesPerArg+lenFmtStr*2; //start of the argument data					
                object[] argObject = new object[nargs];			
                byte argType;
                ushort argLen;
                String formatString = new String(pcFmtStr,0,lenFmtStr);	
                //Excluding the format string
                for(i = 0; i < nargs-1; i++)
                {				
                    argType = *(message+1+(i+1)*noOfBytesPerArg);
                    argLen = *(ushort *)(message+1+(i+1)*noOfBytesPerArg+1); //WIN64 Changes (?)				
                    switch(argType)
                    {
                        case TypeNumberMap.NULL_NO:
                            argObject[i] = null;
                            break;
                        case TypeNumberMap.STRING_NO:
                        {						
                            String s;
                            if (argLen == 0)
                                s = "";
                            else s = new String((char *)argData,0,argLen);
                            argObject[i] = s;								
                            argLen *= 2; //adjust the length
                            break;
                        }
                        case TypeNumberMap.SBYTE_NO:
                        {
                            sbyte sb = *(sbyte *)argData; //WIN64 Changes
                            argObject[i] = sb;						
                            break;
                        }
                        case TypeNumberMap.BYTE_NO:
                        {
                            byte b = *argData; //WIN64 Changes
                            argObject[i] = b;						
                            break;
                        }
                        case TypeNumberMap.INT16_NO:
                        {
                            short s = *(short *)argData; //WIN64 Changes
                            argObject[i] = s;						
                            break;
                        }
                        case TypeNumberMap.UINT16_NO:
                        {
                            ushort us = *(ushort *)argData; //WIN64 Changes
                            argObject[i] = us;						
                            break;
                        }
                        case TypeNumberMap.INT32_NO:
                        {
                            int id = *(int *)argData; //WIN64 Changes
                            argObject[i] = id;						
                            break;
                        }
                        case TypeNumberMap.UINT32_NO:
                        {
                            uint uid = *(uint *)argData; //WIN64 Changes
                            argObject[i] = uid;						
                            break;
                        }
                        case TypeNumberMap.INT64_NO:
                        {
                            long l = *(long *)argData; //WIN64 Changes
                            argObject[i] = l;						
                            break;
                        }
                        case TypeNumberMap.UINT64_NO:
                        {
                            ulong ul = *(ulong *)argData; //WIN64 Changes
                            argObject[i] = ul;						
                            break;
                        }
                        case TypeNumberMap.CHAR_NO:
                        {
                            char c = *(char *)argData; //WIN64 Changes
                            argObject[i] = c;					
                            break;
                        }
                        case TypeNumberMap.SINGLE_NO:
                        {
                            float f = *(float *)argData; //WIN64 Changes
                            argObject[i] = f;						
                            break;
                        }
                        case TypeNumberMap.DOUBLE_NO:
                        {
                            double d = *(double *)argData; //WIN64 Changes
                            argObject[i] = d;						
                            break;
                        }
                        case TypeNumberMap.BOOLEAN_NO:
                        {
                            bool b = *(bool *)argData; //WIN64 Changes
                            argObject[i] = b;						
                            break;
                        }
                        case TypeNumberMap.DECIMAL_NO:
                        {
                            decimal d = *(decimal *)argData; //WIN64 Changes
                            argObject[i] = d;						
                            break;
                        }
					
                    }	
                    argData += argLen;
				
                }			
                string fStr = String.Format(formatString,argObject);	
                if (fStr.Length==0)//empty string
                    fStr="Format string was empty!";										
                int arrLen = fStr.Length*2;
                dataSize = arrLen+1;
                fixed(char* carray = fStr.ToCharArray())
                {								
					
                    if (arrLen+1 <= bufferSize)
                    {
                        for(i = 0; i < arrLen; i++)
                            buffer[i] = carray[i]; //WIN64 Changes (?)
                        //add null terminator
                        buffer[i+1] = (char)0x00; //WIN64 Changes (?)
					
                        return 1;
                    }
                    else
                    {
                        //TODO[1]: Do we need to copy as many characters as we can ? 
                        //Not sure if it is useful to do so because the caller may have to come back
                        //with the right buffer size to get all the data. So why copy part of the data twice ?
                        return 0;
                    }
                }	
            }
            catch(Exception e)
            {
                Console.WriteLine("Exception caught: {0}", e.Message);
                return -1;
            }
		}

		
        // ========================================================================
        // The following are the Message String Wrappers for Software Tracing Messages
        // using Flags.
        // There are entried for Format string and zero through 8 arguments.
        // These are kept small so they will be inlined
        // ========================================================================
        // Just the format string
        public unsafe void TraceMessage(uint traceFlags, object format )
        {			
            if ((traceFlags&Flags) != 0) 
            {				
                EncodeTraceMessage(MessageGuid, (int)14,1, format, null, null, null, null, null, null, null, null);
            }           
        }
        // Just one argument
        public unsafe void TraceMessage(uint traceFlags, object format, object data1 )
        {
            if ((traceFlags&Flags) != 0) 
            {	
				
                EncodeTraceMessage(MessageGuid, (int)14, 2, format, data1, null, null, null, null, null, null,null);
            }
            
        }
        // Just two arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2 )
        {
			
            if ((traceFlags&Flags) != 0) 
            {
				
                EncodeTraceMessage(MessageGuid, (int)14, 3, format, data1, data2, null, null, null, null, null, null);
            }            
        }
        // Just three arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3 )
        {			
            if ((traceFlags&Flags) != 0) 
            {				
                EncodeTraceMessage(MessageGuid, (int)14, 4, format, data1, data2, data3, null, null, null, null, null);
            }            
        }
        // Just four arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3, object data4 )
        {
            if ((traceFlags&Flags) != 0) 
            {				
                EncodeTraceMessage(MessageGuid, (int)14, 5, format, data1, data2, data3, data4, null, null, null, null);
            }            
        }
        // Just five arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3, object data4, object data5 )
        {
			
            if ((traceFlags&Flags) != 0) 
            {										
                EncodeTraceMessage(MessageGuid, (int)14, 6, format, data1, data2, data3, data4, data5, null, null, null);
            }            
        }
        // Just six arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3, object data4, object data5, object data6 )
        {
			
            if ((traceFlags&Flags) != 0) 
            {								
                EncodeTraceMessage(MessageGuid, (int)14, 7, format, data1, data2, data3, data4, data5, data6, null, null);
            }            
        }
        // Just seven arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3, object data4, object data5, object data6, object data7 )
        {
			
            if ((traceFlags&Flags) != 0) 
            {
								
                EncodeTraceMessage(MessageGuid, (int)14, 8, format, data1, data2, data3, data4, data5, data6, data7, null);
            }
            
        }
        // Just eight arguments
        public unsafe void TraceMessage(uint traceFlags, object format, object data1, object data2, object data3, object data4, object data5, object data6, object data7, object data8 )
        {
			
            if ((traceFlags&Flags) != 0) 
            {						
                EncodeTraceMessage(MessageGuid, (int)14, 9, format, data1, data2, data3, data4, data5, data6, data7, data8);
            }            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cgen\cgenhdr.h ===
// Copyright (c) 1998-1999 Microsoft Corporation

#ifdef SORTPP_PASS
#define BUILD_WOW6432 1
#define USE_LPC6432 1
#endif

#if !defined(LANGPACK)
#define LANGPACK
#endif

#define ETW_WOW6432

#include <stddef.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntexapi.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#include <vdm.h>
#include <ntwmi.h>

#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <basedll.h>
#include <nls.h>
#include <sxstypes.h>
#include <ahcache.h>

#ifdef SORTPP_PASS
//Restore IN, OUT
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#define IN __in_wow64
#define OUT __out_wow64
#endif

#include <ntwow64.h>    // from base\ntdll\wow6432
#include <ntwow64b.h>   // from base\win32\client
#include <ntwow64n.h>   // from base\win32\winnls

#undef NtGetTickCount   // a macro in sdkinc\ntexapi.h

ULONG
NTAPI
NtGetTickCount(
    VOID
    );

VOID Wow64Teb32(TEB * Teb);

#define SECURITY_WIN32
#include <sspi.h>   // from sdk\inc, defines SECURITY_STRING
#include <secpkg.h> // from sdk\inc, defines PSecurityUserData
#include <secint.h> // from sdk\inc
#if 0
#include <aup.h>    // from ds\security\base\lsa\inc
#include <spmlpc.h> // from ds\security\base\lsa\inc
#endif
#include <secext.h> // from sdk\inc, defines SEC_WINNT_AUTH_IDENTITY_EX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cgen\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

WHNT32TABSRC=..\..\ntos\ke\services.tab
WHNT32TAB=..\whnt32\$(O)\whnt32.tab
NT32TAB=..\whnt32\$(O)\kesvc.tab

#
# bash the 64-bit-targetted C compiler so it preprocesses using the
# 32-bit defines as we want 32-bit type information
#
!if $(IA64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_IA64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_IA64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DIA64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_IA64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_IA64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DIA64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!elseif $(AMD64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_AMD64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_AMD64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DAMD64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_AMD64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_AMD64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DAMD64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!else
!error no target cpu.
!endif

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
SORTPP_FLAGS=$(SORTPP_FLAGS) -l
!else
SORTPP_FLAGS=$(SORTPP_FLAGS)
!endif

PPMFILE=$(O)\winincs.ppm
NT32HDR=$(O)\nt32.h

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) $(WOW64_COMPILER_FLAGS) -DIN=__in_wow64 -DOUT=__out_wow64

$(WHNT32TAB): $(WHNT32TABSRC)
    @echo Creating $(WHNT32TAB) from $(WHNT32TABSRC)
    copy $(WHNT32TABSRC)+..\..\ntdll\wow6432\ntwow64.tab $(O)\whnt32.tmp
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $(O)\whnt32.tmp > $(WHNT32TAB)
    del $(O)\whnt32.tmp

$(NT32TAB): $(WHNT32TABSRC)
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $(WHNT32TABSRC) > $(NT32TAB)

$(O)\winincs.pp: winincs.cpp cgenhdr.h
    $(CXX_COMPILER_NAME) /C @<<$(O)\cl.rsp /E /FC winincs.cpp >$(O)\winincs2.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP
    idlclean.exe $(O)\winincs2.pp $(O)\winincs2.cpp
    $(CXX_COMPILER_NAME) @<<cl.rsp /E /FC $(O)\winincs2.cpp >$(O)\winincs.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP

$(PPMFILE): $(O)\winincs.pp
   sortpp.exe $(SORTPP_FLAGS) -m$(PPMFILE) $(O)\winincs.pp

$(NT32HDR): $(PPMFILE)
   gennt32t.exe $(PPMFILE) >$(NT32HDR)

thunks: $(WHNT32TAB) $(NT32HDR) $(PPMFILE) $(NT32TAB)

cleanfiles:
    -del $(O)\winincs.pp
    -del $(O)\winincs2.pp
    -del $(WHNT32TAB)
    -del $(NT32TAB)
    -del $(PPMFILE)
    -del $(NT32HDR)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\context\amd6432.h ===
#ifndef __AMD64_WOW64EXTS32__
#define __AMD64_WOW64EXTS32__

#define _CROSS_PLATFORM_
#define WOW64EXTS_386

#if !defined(_X86_)
    #error This file can only be included for x86 build
#else

/* include headers as if the platform were amd64, 
   because we need 64-bit stuff for context conversion */

//
// Fix build that only get defined on AMD64, but in this case we take 64bit header and compile 32bit code
//


#undef _X86_
#define _AMD64_




#include <nt.h>

__int64 UnsignedMultiplyHigh (__int64 Multiplier,  IN __int64 Multiplicand);
#define DR7_ACTIVE 0x55
struct _TEB *
NtCurrentTeb(void);

#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _AMD64_
#define _X86_




/* 32-bit stuff for context conversion are defined here */
#include <wow64.h>
#include <wow64cpu.h>
#include <vdmdbg.h>
#include <amd64cpu.h>


/* these are defined in nti386.h, since we only included ntamd64.h (in nt.h), 
   we have to define these. */
#define SIZE_OF_FX_REGISTERS        128

typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT_WX86;

#endif

#endif __AMD64_WOW64EXTS32__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\context\context.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module converts an amd64 context record to an X86 context record
    and vice versa.

Author:

    13-Dec-2001   Samer Arafeh  (samera)

Revision History:

--*/


#define _WOW64CPUAPI_

#ifdef _X86_
#include "amd6432.h"
#else

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"

#endif

#include "cpup.h"

//
// Legacy FP definitions
//

#define NUMBER_LEGACY_FP_REGISTERS 8
#define FP_LEGACY_REGISTER_SIZE    10


ASSERTNAME;

VOID
Wow64CtxFromAmd64(
    IN ULONG X86ContextFlags,
    IN PCONTEXT ContextAmd64,
    IN OUT PCONTEXT32 ContextX86
    )
/*++

Routine Description:

    This function builds an x86 context from the native amd64 context.

Arguments:

    X86ContextFlags - Specifies which ia32 context to copy

    ContextAmd64 - Supplies an the amd64 context buffer that is the source
                  for the copy into the ia32 context area

    ContextX86 - This is an X86 context which will receive the context
                 information from the amd64 context record passed in above

Return Value:

    None.  

--*/

{
    ULONG FpReg;

    //
    // Validate context flags
    //

    if (X86ContextFlags & CONTEXT_AMD64) {
        LOGPRINT((ERRORLOG, "Wow64CtxFromAmd64: Request with amd64 context flags (0x%x) FAILED\n", X86ContextFlags));
        ASSERT((X86ContextFlags & CONTEXT_AMD64) == 0);
    }

    if ((X86ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        
        //
        // Control registers
        //

        ContextX86->Ebp    = (ULONG) ContextAmd64->Rbp;
        ContextX86->SegCs  = (KGDT64_R3_CMCODE | RPL_MASK);
        ContextX86->Eip    = (ULONG) ContextAmd64->Rip;
        ContextX86->SegSs  = (KGDT64_R3_DATA | RPL_MASK);
        ContextX86->Esp    = (ULONG) ContextAmd64->Rsp;
        ContextX86->EFlags = ContextAmd64->EFlags;
    }

    if ((X86ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
        
        //
        // Integer state
        //

        ContextX86->Edi = (ULONG)ContextAmd64->Rdi;
        ContextX86->Esi = (ULONG)ContextAmd64->Rsi;
        ContextX86->Ebx = (ULONG)ContextAmd64->Rbx;
        ContextX86->Edx = (ULONG)ContextAmd64->Rdx;
        ContextX86->Ecx = (ULONG)ContextAmd64->Rcx;
        ContextX86->Eax = (ULONG)ContextAmd64->Rax;
    }

    if ((X86ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        
        //
        // Segment registers...
        //

        ContextX86->SegGs = (KGDT64_R3_DATA | RPL_MASK);
        ContextX86->SegEs = (KGDT64_R3_DATA | RPL_MASK);
        ContextX86->SegDs = (KGDT64_R3_DATA | RPL_MASK);
        ContextX86->SegFs = (KGDT64_R3_CMTEB | RPL_MASK);
    }

    if ((X86ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {

        PFXSAVE_FORMAT_WX86 FxSaveArea = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;
        
        LOGPRINT((TRACELOG, "Wow64CtxFromAmd64: Request to convert extended fp registers\n"));
        
        //
        // Initialize the FxSave part of the context.
        //

        RtlZeroMemory (FxSaveArea,
                       sizeof (ContextX86->ExtendedRegisters));
        //
        // Copy over control/status registers
        //
        
        FxSaveArea->ControlWord = ContextAmd64->FltSave.ControlWord;
        FxSaveArea->StatusWord = ContextAmd64->FltSave.StatusWord;
        FxSaveArea->TagWord = ContextAmd64->FltSave.TagWord;
        FxSaveArea->ErrorOpcode = ContextAmd64->FltSave.ErrorOpcode;
        FxSaveArea->ErrorOffset = ContextAmd64->FltSave.ErrorOffset;
        FxSaveArea->ErrorSelector = ContextAmd64->FltSave.ErrorSelector;
        FxSaveArea->DataOffset = ContextAmd64->FltSave.DataOffset;
        FxSaveArea->DataSelector = ContextAmd64->FltSave.DataSelector;
        FxSaveArea->MXCsr = ContextAmd64->MxCsr;

        //
        // Copy over the legacy FP registers (ST0-ST7)
        //

        RtlCopyMemory (FxSaveArea->RegisterArea,
                       ContextAmd64->FltSave.FloatRegisters,
                       sizeof (FxSaveArea->RegisterArea));

        //
        // Copy over XMM0 - XMM7
        //

        RtlCopyMemory (FxSaveArea->Reserved3,
                       &ContextAmd64->Xmm0,
                       sizeof (FxSaveArea->Reserved3));
    }

    if ((X86ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

        LOGPRINT((TRACELOG, "Wow64CtxFromAmd64: Request to convert fp registers\n"));

        //
        // Floating point (legacy) ST0 - ST7
        //

        RtlCopyMemory (&ContextX86->FloatSave,
                       &ContextAmd64->FltSave,
                       sizeof (ContextX86->FloatSave));
    }

    if ((X86ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {

        LOGPRINT((TRACELOG, "Wow64CtxFromAmd64: Request to convert debug registers\n"));

        //
        // Debug registers DR0 - DR7
        //

        if ((ContextAmd64->Dr7 & DR7_ACTIVE) != 0) {
            
            ContextX86->Dr0 = (ULONG)ContextAmd64->Dr0;
            ContextX86->Dr1 = (ULONG)ContextAmd64->Dr1;
            ContextX86->Dr2 = (ULONG)ContextAmd64->Dr2;
            ContextX86->Dr3 = (ULONG)ContextAmd64->Dr3;
            ContextX86->Dr6 = (ULONG)ContextAmd64->Dr6;
            ContextX86->Dr7 = (ULONG)ContextAmd64->Dr7;
        } else {

            ContextX86->Dr0 = 0;
            ContextX86->Dr1 = 0;
            ContextX86->Dr2 = 0;
            ContextX86->Dr3 = 0;
            ContextX86->Dr6 = 0;
            ContextX86->Dr7 = 0;
        }
    }

    ContextX86->ContextFlags = X86ContextFlags;

}

VOID
Wow64CtxToAmd64(
    IN ULONG X86ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextAmd64
    )
/*++

Routine Description:

    This function builds a native Amd64 context from an x86 context record.
Arguments:

    X86ContextFlags - Specifies which c86 context to copy

    ContextX86 - Supplies an the X86 context buffer that is the source
                  for the copy into the amd64 context area

    ContextAmd64 - This is an amd64 context which will receive the context
                 information from the x86 context record passed in above

Return Value:

    None.

--*/

{    
    BOOLEAN CmMode = (ContextAmd64->SegCs == (KGDT64_R3_CMCODE | RPL_MASK));

    //
    // Validate context flags
    //

    if (X86ContextFlags & CONTEXT_AMD64) {
        
        LOGPRINT((ERRORLOG, "Wow64CtxToAmd64: Request with amd64 context flags (0x%x) FAILED\n", X86ContextFlags));
        ASSERT((X86ContextFlags & CONTEXT_AMD64) == 0);
    }

    //
    // if we are running in longmode, then only set the registers that won't be changed
    // by 64-bit code.
    //

    if (CmMode != TRUE) {

        X86ContextFlags = (X86ContextFlags & ~(CONTEXT32_CONTROL | CONTEXT32_INTEGER | CONTEXT32_SEGMENTS));
        X86ContextFlags = (X86ContextFlags | CONTEXT_i386);

    }

    if ((X86ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        
        LOGPRINT((TRACELOG, "Wow64CtxToAmd64: Request to convert control registers\n"));

        //
        // Control registers
        //

        ContextAmd64->SegCs = (KGDT64_R3_CMCODE | RPL_MASK);
        ContextAmd64->SegSs = (KGDT64_R3_DATA | RPL_MASK);

        ContextAmd64->Rip = ContextX86->Eip;
        ContextAmd64->Rbp = ContextX86->Ebp;
        ContextAmd64->Rsp = ContextX86->Esp;
        ContextAmd64->EFlags = ContextX86->EFlags;
    }

    if ((X86ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
         
        LOGPRINT((TRACELOG, "Wow64CtxToAmd64: Request to convert integer registers\n"));

        //
        // Integer registers...
        //

        ContextAmd64->Rdi = ContextX86->Edi;
        ContextAmd64->Rsi = ContextX86->Esi;
        ContextAmd64->Rbx = ContextX86->Ebx;
        ContextAmd64->Rdx = ContextX86->Edx;
        ContextAmd64->Rcx = ContextX86->Ecx;
        ContextAmd64->Rax = ContextX86->Eax;
    }

    if ((X86ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        
        LOGPRINT((TRACELOG, "Wow64CtxToAmd64: Request to convert segment registers\n"));

        //
        // Segment registers : are never touched, and are used from the native
        // context.
        //

    }

    if ((X86ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {

        PFXSAVE_FORMAT_WX86 FxSaveArea = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxToAmd64: Request to convert extended fp registers\n"));
        
        
        //
        // Control and status registers
        //
        
        ContextAmd64->FltSave.ControlWord = FxSaveArea->ControlWord;
        ContextAmd64->FltSave.StatusWord = FxSaveArea->StatusWord;
        ContextAmd64->FltSave.TagWord = FxSaveArea->TagWord;
        ContextAmd64->FltSave.ErrorOpcode = FxSaveArea->ErrorOpcode;
        ContextAmd64->FltSave.ErrorOffset = FxSaveArea->ErrorOffset;
        ContextAmd64->FltSave.ErrorSelector = (USHORT)FxSaveArea->ErrorSelector;
        ContextAmd64->FltSave.DataOffset = FxSaveArea->DataOffset;
        ContextAmd64->FltSave.DataSelector = (USHORT)FxSaveArea->DataSelector;
        ContextAmd64->MxCsr = FxSaveArea->MXCsr;

        //
        // Legacy FP registers (ST0-ST7)
        //

        RtlCopyMemory (ContextAmd64->FltSave.FloatRegisters,
                       FxSaveArea->RegisterArea,
                       sizeof (ContextAmd64->FltSave.FloatRegisters));

        //
        // Extended floating point registers (XMM0-XMM7)
        //

        RtlCopyMemory (&ContextAmd64->Xmm0,
                       FxSaveArea->Reserved3,
                       sizeof (FxSaveArea->Reserved3));

    }

    if ((X86ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

        LOGPRINT((TRACELOG, "Wow64CtxToAmd64: Request to convert fp registers\n"));

        //
        // Floating point (legacy) registers (ST0-ST7)
        //

        RtlCopyMemory (&ContextAmd64->FltSave,
                       &ContextX86->FloatSave,
                       sizeof (ContextAmd64->FltSave));

    }

    if ((X86ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {

        //
        // Debug registers (Dr0-Dr7)
        //

        ContextAmd64->Dr0 = ContextX86->Dr0;
        ContextAmd64->Dr1 = ContextX86->Dr1;
        ContextAmd64->Dr2 = ContextX86->Dr2;
        ContextAmd64->Dr3 = ContextX86->Dr3;
        ContextAmd64->Dr6 = ContextX86->Dr6;
        ContextAmd64->Dr7 = ContextX86->Dr7;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\cpu\amd64\simulate.asm ===
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   simulate.asm
;
; Abstract:
;
;   This module implements the system service (thunk) transition code
;   to/from 32/64 bit modes. On switch from 32-bit to 64-bit mode
;   the following registers are saved:
;
;       - Non Volatile Registers (ebp, ebx, esi , edi, eflags)
;       - 32-bit esp is saved
;       - 64-bit rsp is loaded
;
;   * The followings are NOT saved:
;       - SSE2 FP (legacy registers) ST0-ST7
;       - Debug registers
;       - extended FP (XMM0-XMM7)
; 
;
;   However, on transition from 64-bit to 32-bit mode (compatibility mode), the following
;   registers are restored:
;       - Non Volatile registers (ebp, esi, edi, eflags)
;       - Volatile Ineteger registers (eax, ecx, edx)
;       - 32-bit esp is loaded
;       - 64-bit rsp is saved
;
;
; Author:
;
;   Samer Arafeh (samera) 18-Dec-2001
;
; Envirnoment:
;
;   User mode.
;
;--

include ksamd64.inc
include w64amd64.inc

        altentry CpupReturnFromSimulatedCode
        altentry CpupSwitchToCmModeInstruction
        
        subttl  "CpupRunSimulatedCode"


;++
;
; VOID
; CpupRunSimulatedCode (
;     VOID
;     )
;
; Routine Description:
;
;     This routine is entered to switch the processor to 32-bit mode (compatibility mode). It
;     prepares all the registers, switches the stack and processor mode.
;
;     32-bit code returns to an entry within this function, CpupReturnFromSimulatedCode.
;
; Arguments:
;   
;    None.
;
; Return Value:
;
;    None.
;
;--

Wow64CpuFrame struct
        Mframe  db MachineFrameLength dup (?)   ; machine frame to switch to compatibility mode segment
Wow64CpuFrame ends

        NESTED_ENTRY CpupRunSimulatedCode, _TEXT$00

;
; save non-volatile registers
;        
        push_reg rbx                            ; save rbx
        push_reg rsi                            ; save rsi
        push_reg rdi                            ; save rdi
        push_reg rbp                            ; save rbp
        

        alloc_stack (sizeof Wow64CpuFrame)      ; allocate stack for switching mode
        
        END_PROLOGUE
        

;
; reload x86 context registers
;
        
        mov     r8, gs:[TeSelf]                 ; save 64-bit teb address
        mov     r9, TeDeallocationStack+8+8[r8] ; get cpu ptr
        
;
; check if we need to reload the volatile state
;
        and     dword ptr TrFlags[r9], TR_RESTORE_VOLATILE ; test if we need to load the volatile state
        jz      short LoadVolatileDone                 ; if z, no
        
;
; load xmm0 to xmm5 registers, rcx and rdx
;                
        
        mov     rax, r9                         ; get cpu ptr
        movdqa  xmm0, (ExReg+XmmReg0+0*16)[rax] ; load xmm0
        movdqa  xmm1, (ExReg+XmmReg0+1*16)[rax] ; load xmm1
        movdqa  xmm2, (ExReg+XmmReg0+2*16)[rax] ; load xmm2
        movdqa  xmm3, (ExReg+XmmReg0+3*16)[rax] ; load xmm3
        movdqa  xmm4, (ExReg+XmmReg0+4*16)[rax] ; load xmm4
        movdqa  xmm5, (ExReg+XmmReg0+5*16)[rax] ; load xmm5
        mov     ecx, dword ptr EcxCpu[r9]       ; load ecx
        mov     edx, dword ptr EdxCpu[r9]       ; load edx
        
        and     dword ptr TrFlags[r9], not TR_RESTORE_VOLATILE ; turn off restoring volatile state

LoadVolatileDone:

;
; r8 - 64-bit teb
; r9 - pointer to the cpu
;
        
        mov     edi, dword ptr EdiCpu[r9]       ; restore edi
        mov     esi, dword ptr EsiCpu[r9]       ; restore esi
        mov     ebx, dword ptr EbxCpu[r9]       ; restore ebx
        mov     ebp, dword ptr EbpCpu[r9]       ; restore ebp
                               
;
; lets reload esp, destination eip and eflags for switching to compatibility mode
;        
        
        mov     word ptr MfSegSs[rsp], KGDT64_R3_DATA or RPL_MASK ; store ss selector into machine frame
        mov     eax, dword ptr EspCpu[r9]       ; load esp from cpu
        mov     MfRsp[rsp], rax                 ; store cm esp into machine frame
        mov     eax, dword ptr EFlagsCpu[r9]    ; load eflags from cpu
        mov     MfEFlags[rsp], eax              ; store cm eflags into machine frame
        mov     word ptr MfSegCs[rsp], KGDT64_R3_CMCODE or RPL_MASK ; store cm code selector into machine frame
        mov     eax, dword ptr EipCpu[r9]       ; load eip from cpu
        mov     MfRip[rsp], eax                 ; store target eip into machine frame
        
        mov     eax, dword ptr EaxCpu[r9]       ; load eax from cpu
        
        mov     TeDeallocationStack+8[r8], rsp  ; store native rsp
        
        ALTERNATE_ENTRY CpupSwitchToCmModeInstruction
;
; switch to compatibility mode, and jmp to the destination eip
;

        iretq                                   ; return to compatibility mode
        
        ALTERNATE_ENTRY CpupReturnFromSimulatedCode
;
; this is where we return from 32-bit code when a system call is executed.
; let's save non volatile registers inside the cpu.
;        

        mov     r8, gs:[TeSelf]                 ; save 64-bit teb address
        mov     r9, TeDeallocationStack+8+8[r8] ; get cpu ptr

;
; r8 - 64-bit teb
; r9 - pointer to the cpu
;

        
;
; save x86 context
;
        mov     EsiCpu[r9], esi                 ; save esi
        mov     EdiCpu[r9], edi                 ; save edi
        mov     EbxCpu[r9], ebx                 ; save ebx
        mov     EbpCpu[r9], ebp                 ; save ebp
        
;
; lets save edx and eax as they are used in the system call service
;
        mov     EaxCpu[r9], eax                 ; save eax
        mov     EdxCpu[r9], edx                 ; save edx

;
; save esp, destination eip
;
        mov     esi, dword ptr [esp]            ; get return address
        mov     dword ptr EipCpu[r9], esi       ; save eip
        add     esp, 4                          ; skip over return address
        mov     dword ptr EspCpu[r9], esp       ; save esp
        mov     rsp, TeDeallocationStack+8[r8]  ; restore native rsp
        and     qword ptr TeDeallocationStack+8[r8], 0 ; indicate we are running on 64-bit rsp
       
;
; restore 64-bit non-volatile registers
;
        
        add     rsp, sizeof Wow64CpuFrame       ; deallocate stack
        pop     rbp                             ; restore rbp
        pop     rdi                             ; restore rdi
        pop     rsi                             ; restore rsi
        pop     rbx                             ; restore rbx
;
; return to caller
;
        ret

        NESTED_END CpupRunSimulatedCode, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\context\suspend.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext for
    AMD64.

Author:

    12-Dec-2001  Samer Arafeh (samera)

Revision History:

--*/

#define _WOW64CPUAPI_


#ifdef _X86_
#include "amd6432.h"
#else
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"
#endif

#include "cpup.h"

#include <stdio.h>
#include <stdarg.h>


ASSERTNAME;


ULONG_PTR ia32ShowContext = 0;

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...)
{
    va_list ArgList;
    int BytesWritten;
    CHAR Buffer[ 512 ];

    if ((ia32ShowContext & Flags) || (Flags == ERRORLOG))
    {
        va_start(ArgList, Format);
        BytesWritten = _vsnprintf(Buffer,
                                  sizeof(Buffer) - 1,
                                  Format,
                                  ArgList);
        if (BytesWritten > 0)
        {
            DbgPrint(Buffer);
        }
        va_end(ArgList);
    }
    
    return;
}


VOID
CpupPrintContext(
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    )
/*++

Routine Description:

    Print out the ia32 context based on the passed in cpu context

Arguments:

    str - String to print out as a header
    cpu - Pointer to the per-thread wow64 ia32 context.

Return Value:

    none

--*/

{

    DbgPrint(str);
    DbgPrint("Context addr(0x%p): EIP=0x%08x\n", &(cpu->Context), cpu->Context.Eip);
    DbgPrint("Context EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\n",
                        cpu->Context.Eax,
                        cpu->Context.Ebx,
                        cpu->Context.Ecx,
                        cpu->Context.Edx);

    DbgPrint("Context ESP=0x%08x, EBP=0x%08x, ESI=0x%08x, EDI=0x%08x\n",
                        cpu->Context.Esp,
                        cpu->Context.Ebp,
                        cpu->Context.Esi,
                        cpu->Context.Edi);

    try {

        //
        // The stack may not yet be fully formed, so don't
        // let a missing stack cause the process to abort
        //

        DbgPrint("Context stack=0x%08x 0x%08x 0x%08x 0x%08x\n",
                        *((PULONG) cpu->Context.Esp),
                        *(((PULONG) cpu->Context.Esp) + 1),
                        *(((PULONG) cpu->Context.Esp) + 2),
                        *(((PULONG) cpu->Context.Esp) + 3));

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {

        //
        // Got an access violation, so don't print any of the stack
        //

        DbgPrint("Context stack: Can't get stack contents\n");
    }

    DbgPrint("Context EFLAGS=0x%08x\n", cpu->Context.EFlags);
}

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU.    

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine setup the arguments for the remoted  SuspendThread call.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {

            RtlCopyMemory (Destination,
                           Source,
                           Size);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }

    } else {
        
        NtStatus = NtReadVirtualMemory (ProcessHandle,
                                        Source,
                                        Destination,
                                        Size,
                                        NULL);
    }

    return NtStatus;
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {

            RtlCopyMemory (Target,
                           Source,
                           Size);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }

    } else {
    
        NtStatus = NtWriteVirtualMemory (ProcessHandle,
                                         Target,
                                         Source,
                                         Size,
                                         NULL);
    }

    return NtStatus;
}

NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN PCONTEXT ContextAmd64 OPTIONAL,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Retrevies the context record of the specified CPU. This routine updates
    only the registers that are saved on transition to 64-bit mode, and SHOULD
    be kept in sync with the thunk-transition code.

Arguments:

    cpu     - CPU to retreive the context record for.
    ContextAmd64 - Full native context.
    Context - IN/OUT pointer to CONTEXT32 to fill in.  Context->ContextFlags
              should be used to determine how much of the context to copy.

Return Value:

    NTSTATUS

--*/

{


    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;
    
    
    try {
        
        ContextFlags = Context->ContextFlags;
        
        //
        // Get the initial 32-bit context.
        //

        //
        // Caller will fillup Context with the native context and pass ContextAmd64 as NULL.
        //
        
        if (ARGUMENT_PRESENT (ContextAmd64)) {
            
            Wow64CtxFromAmd64 (ContextFlags, 
                               ContextAmd64, 
                               Context);

            //
            // If the thread is running 32-bit code at the time of retreiving the context,
            // the direct conversion is enough.
            //

            if (ContextAmd64->SegCs == (KGDT64_R3_CMCODE | RPL_MASK)) {
                return NtStatus;
            }
        }
        
        if (ContextFlags & CONTEXT_AMD64) {
            
            LOGPRINT((ERRORLOG, "CpuGetContext: Request for amd64 context (0x%x) being FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_AMD64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
            
            //
            // control registers
            //

            Context->Ebp = cpu->Context.Ebp;
            Context->Eip = cpu->Context.Eip;
            Context->SegCs = (KGDT64_R3_CMCODE | RPL_MASK);
            Context->EFlags = SANITIZE_X86EFLAGS (cpu->Context.EFlags);
            Context->Esp = cpu->Context.Esp;
            Context->SegSs = (KGDT64_R3_DATA | RPL_MASK);
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
            
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //

            Context->Edi = cpu->Context.Edi;
            Context->Esi = cpu->Context.Esi;
            Context->Ebx = cpu->Context.Ebx;
            Context->Edx = cpu->Context.Edx;
            Context->Ecx = cpu->Context.Ecx;
            Context->Eax = cpu->Context.Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
            
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //

            Context->SegDs = (KGDT64_R3_DATA | RPL_MASK);
            Context->SegEs = (KGDT64_R3_DATA | RPL_MASK);
            Context->SegFs = (KGDT64_R3_CMTEB | RPL_MASK);
            Context->SegGs = (KGDT64_R3_DATA | RPL_MASK);
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {
            
            //
            // floating point (legacy) registers (ST0-ST7)
            //

            //
            // This must have already been done.
            //
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
            
            //
            // Debug registers (Dr0-Dr7)
            //

            //
            // This must have already been done
            //
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {
            
            //
            // extended floating point registers (XMM0-XMM7)
            //            
        }
    
    } except (EXCEPTION_EXECUTE_HANDLER) {
        
        NtStatus = GetExceptionCode ();
    }

    if (ia32ShowContext & LOG_CONTEXT_GETSET) {
        
        CpupPrintContext ("Getting ia32 context: ", cpu);
    }

    return NtStatus;
}

NTSTATUS
CpupGetContext(
    IN PCONTEXT ContextAmd64,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently executing thread. 

Arguments:

    ContextAmd64 - Full native context
    Context  - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return GetContextRecord (cpu, ContextAmd64, Context);
}


NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;

    //
    // Get the whole native context
    //

    ContextEM.ContextFlags = (CONTEXT_FULL | 
                              CONTEXT_DEBUG_REGISTERS | 
                              CONTEXT_SEGMENTS);

    NtStatus = NtGetContextThread (ThreadHandle,
                                   &ContextEM);

    if (!NT_SUCCESS(NtStatus)) {
        
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    //
    // If we are running 64-bit code, then get the context off the 64-bit
    // thread stack, which was spilled by the transition code...
    //

    if (ContextEM.SegCs != (KGDT64_R3_CMCODE | RPL_MASK)) {

        LOGPRINT((TRACELOG, "Getting context while thread is executing 64-bit instructions\n"));

        NtStatus = CpupReadBuffer( ProcessHandle,
                                   ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                   &CpuRemoteContext,
                                   sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = CpupReadBuffer (ProcessHandle,
                                       CpuRemoteContext,
                                       &CpuContext,
                                       sizeof(CpuContext));

            if (!NT_SUCCESS(NtStatus)) {
                
                LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context %lx - %lx\n", 
                          CpuRemoteContext, NtStatus));
            }
        } else {
            
            LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));
        }
    }

    //
    // Get the actual context context for the caller
    //

    if (NT_SUCCESS (NtStatus)) {

        NtStatus = GetContextRecord (&CpuContext, &ContextEM, Context);
    }

    return NtStatus;
}



WOW64CPUAPI
NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at 
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    return CpupGetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}


NTSTATUS
SetContextRecord(
    IN OUT PCPUCONTEXT cpu,
    IN OUT PCONTEXT ContextAmd64 OPTIONAL,
    IN PCONTEXT32 Context,
    OUT PBOOLEAN UpdateNativeContext
    )
/*++

Routine Description:

    Update the CPU's register set for the specified CPU. This routine updates
    only the registers that are saved on transition to 64-bit mode, and SHOULD
    be kept in sync with the thunk-transition code.

Arguments:

    cpu     - CPU to update its registers
    
    Context - Pointer to CONTEXT32 to use.  Context->ContextFlags
              should be used to determine how much of the context to update.
              
    ContextAmd64 - Full native context, and will hold the updated 32-bit context.
    
    UpdateNativeContext - Updated on return to indicate if a NtSetContextThread call is required.    

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;
    ULONG NewContextFlags = 0;
    BOOLEAN CmMode;

    try {
        
        *UpdateNativeContext = FALSE;

        ContextFlags = Context->ContextFlags;
        
        if (ContextFlags & CONTEXT_AMD64) {
            
            LOGPRINT((ERRORLOG, "CpuSetContext: Request with amd64 context (0x%x) FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_AMD64) == 0);
        }

        //
        // Caller might pass NativeContext == NULL if they already know what to do.
        //

        if (ARGUMENT_PRESENT (ContextAmd64)) {

            CmMode = (ContextAmd64->SegCs == (KGDT64_R3_CMCODE | RPL_MASK));

            Wow64CtxToAmd64 (ContextFlags,
                            Context,
                            ContextAmd64);
            
            //
            // If we are running 32-bit code
            //

            if (CmMode == TRUE) {
                *UpdateNativeContext = TRUE;
                return NtStatus;
            }

            NewContextFlags = 0;
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
            
            //
            // Control registers
            //

            cpu->Context.Ebp = Context->Ebp;
            cpu->Context.Eip = Context->Eip;
            cpu->Context.SegCs = (KGDT64_R3_CMCODE | RPL_MASK);
            cpu->Context.EFlags = SANITIZE_X86EFLAGS (Context->EFlags);
            cpu->Context.Esp = Context->Esp;
            cpu->Context.SegSs = Context->SegSs;
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {

            //
            // Integer registers
            //

            cpu->Context.Edi = Context->Edi;
            cpu->Context.Esi = Context->Esi;
            cpu->Context.Ebx = Context->Ebx;
            cpu->Context.Edx = Context->Edx;
            cpu->Context.Ecx = Context->Ecx;
            cpu->Context.Eax = Context->Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
            
            //
            // Segment registers
            //

            //
            // shouldn't be touched
            //
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

            //
            // floating point registers
            //

            NewContextFlags |= CONTEXT_FLOATING_POINT;
        
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
            
            //
            // debug registers (Dr0-Dr7)
            //

            NewContextFlags |= CONTEXT_DEBUG_REGISTERS;
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {
            
            //
            // extended floating point registers (ST0-ST7)
            //
            
            NewContextFlags |= CONTEXT_FLOATING_POINT;

            //
            // Save the extended registers so that the trap frame may restore them.
            // The system will ALWAYS scrub XMM0-XMM5 on return from system calls.
            //

            RtlCopyMemory (cpu->Context.ExtendedRegisters,
                           Context->ExtendedRegisters,
                           sizeof (Context->ExtendedRegisters));
        }

        //
        // Whatever they passed in before, it's an X86 context now...
        //

        cpu->Context.ContextFlags = ContextFlags;
    
    } except (EXCEPTION_EXECUTE_HANDLER) {
        
          NtStatus = GetExceptionCode();
    }


    if (ia32ShowContext & LOG_CONTEXT_GETSET) {
        
        CpupPrintContext("Setting ia32 context: ", cpu);
    }

    if (NewContextFlags != 0) {
        
        if (ARGUMENT_PRESENT (ContextAmd64)) {
            
            ContextAmd64->ContextFlags = NewContextFlags;
            *UpdateNativeContext = TRUE;
        }
    }

    return NtStatus;
}


NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;
    BOOLEAN CmMode;
    BOOLEAN UpdateNativeContext;
     
    
    //
    // Get the whole native context
    //

    ContextEM.ContextFlags = (CONTEXT_FULL |
                              CONTEXT_DEBUG_REGISTERS |
                              CONTEXT_SEGMENTS);
    
    NtStatus = NtGetContextThread (ThreadHandle,
                                   &ContextEM);

    if (!NT_SUCCESS(NtStatus)) {
        
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));

        return NtStatus;
    }
    
        
    CmMode = (ContextEM.SegCs == (KGDT64_R3_CMCODE | RPL_MASK));

    //
    // If we are running 64-bit code, make sure to update the cpu context off the 
    // 64-bit thread stack...
    //

    if (CmMode == FALSE) {

        LOGPRINT((TRACELOG, "Setting context while thread is executing 64-bit instructions\n"));
        
        NtStatus = CpupReadBuffer (ProcessHandle,
                                   ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                   &CpuRemoteContext,
                                   sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus)) {
            
            NtStatus = CpupReadBuffer (ProcessHandle,
                                       CpuRemoteContext,
                                       &CpuContext,
                                       sizeof(CpuContext));
        } else {
            
            LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));
        }
    }

    //
    // We are ready to set the context now
    //

    if (NT_SUCCESS (NtStatus)) {

        NtStatus = SetContextRecord (&CpuContext,
                                     &ContextEM,
                                     Context,
                                     &UpdateNativeContext);

        if (NT_SUCCESS (NtStatus)) {
            
            if (CmMode == FALSE) {
                
                //
                // If the call is coming thru Wow64, then restore the volatile XMMI and integer registers on the next
                // tranisition to compatibility mode
                //

                if (ThreadHandle == NtCurrentThread ()) {
                    if (((Context->ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) ||
                        ((Context->ContextFlags & CONTEXT32_INTEGER) == CONTEXT32_INTEGER)) {

                        CpuContext.TrapFrameFlags = TRAP_FRAME_RESTORE_VOLATILE;
                    }
                }

                NtStatus = CpupWriteBuffer(ProcessHandle,
                                           CpuRemoteContext,
                                           &CpuContext,
                                           sizeof(CpuContext));

                if (!NT_SUCCESS (NtStatus)) {

                    LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't write remote context %lx - %lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }

            //
            // Set the context ultimately. This shouldn't change except the FP and debug
            // state if the thread is executing in 64-bit (long) mode.
            //

            if ((NT_SUCCESS (NtStatus)) &&
                (UpdateNativeContext == TRUE)) {
                
                NtStatus = NtSetContextThread (ThreadHandle, &ContextEM);
            }
        
        } else {
            
            LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't update native context %lx - %lx\n", 
                      &ContextEM, NtStatus));
        }
    }

    return NtStatus;
}


WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, then it is 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    return CpupSetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\cpu\makefile.inc ===
#
# Build the Amd64 CPU constant definitions.
#
# Author : Samer Arafeh (samera)
# Date   : 01-20-2002
#


WOW64_INC_PATH=$(BASEP_WOW64_DIR)\inc
PUBLICINCS=



PRIVATEINCS= $(WOW64_INC_PATH)\wx86nt.h  \
             $(BASEP_WOW64_DIR)\cpu\amd64\inc\amd64cpu.h

$(O)\geninc.cxx:                \
    $(TARGET_DIRECTORY)\geninc.m4 \

    set PASS0ONLY=
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) -DWOW64_INC_PATH=$(WOW64_INC_PATH) < $(TARGET_DIRECTORY)\geninc.m4              \
                            > $@


$(TARGET_DIRECTORY)\w64$(TARGET_DIRECTORY).$(ASM_INCLUDE_SUFFIX):			     \
		       $(O)\geninc.cxx                                       \
		       $(PUBLICINCS)					     \
		       $(PRIVATEINCS)					     \
		       $(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
    if not exist $(O) mkdir $(O)
    nmake $(O)\geninc.obj USE_MSVCRT=1 NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx $(O)\geninc.obj -s$(ASM_INCLUDE_SUFFIX) -o$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\cpu\cpumain.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:

    This module contains the platform specific entry points for the AMD64
    WOW64 cpu.

Author:

    Samer Arafeh (samera) 18-Dec-2001

Environment:

    User mode.

--*/

#define _WOW64CPUAPI_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"
#include "cpup.h"


//
// These are to help recover the 64-bit context when an exception happens in
// the 64-bit land and there is no debugger attached initially
//

EXCEPTION_RECORD RecoverException64;
CONTEXT RecoverContext64;

ASSERTNAME;

//
// Logging facility
//

extern ULONG_PTR ia32ShowContext;


//
// Assember implementations
//

VOID 
CpupRunSimulatedCode (
    VOID
    );

VOID
CpupReturnFromSimulatedCode (
    VOID
    );

VOID CpupSwitchToCmModeInstruction (
    VOID
    );


//
// Will hold instructions to perform a far jmp to ReturnFromSimulatedCode.
// will also reload the CS selector with the proper value.
//

UCHAR X86SwitchTo64BitMode [7];


WOW64CPUAPI
NTSTATUS
CpuProcessInit (
    IN PWSTR pImageName,
    IN PSIZE_T pCpuThreadSize
    )

/*++

Routine Description:

    Per-process CPU initialization code

Arguments:

    pImageName       - IN pointer to the name of the image
    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/

{

    PVOID pv;
    NTSTATUS NtStatus;
    SIZE_T Size;
    ULONG OldProtect;
    UNALIGNED ULONG *Address;
    UCHAR *pch;

#if 0
    LOGPRINT((ERRORLOG, "AMD64-Wow64Cpu : Init CpuProcessInit() - 32-bit jump address = %lx\n", *pCpuThreadSize));
#endif

    //
    // Indicate that this is Microsoft CPU
    //

    Wow64GetSharedInfo()->CpuFlags = 'sm';

    //
    // Per-Thread CPU structure size. Align it on a 16-byte boundary.
    //

    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16;


    LOGPRINT((TRACELOG, "CpuProcessInit() - sizeof(CPUCONTEXT) is %d, total size is %d\n", sizeof(CPUCONTEXT), *pCpuThreadSize));

    //
    // Construct the transition code to switch the processor
    // to longmode
    //

    X86SwitchTo64BitMode [0] = 0xea;
    Address = (UNALIGNED ULONG *)&X86SwitchTo64BitMode[1];
    *Address = PtrToUlong (CpupReturnFromSimulatedCode);
    X86SwitchTo64BitMode [5] = (KGDT64_R3_CODE | RPL_MASK);
    X86SwitchTo64BitMode [6] = 0x00;

    pv = (PVOID)X86SwitchTo64BitMode;
    Size = sizeof (X86SwitchTo64BitMode);

    NtStatus = NtProtectVirtualMemory (NtCurrentProcess(),
                                       &pv,
                                       &Size,
                                       PAGE_EXECUTE_READWRITE,
                                       &OldProtect);

    if (!NT_SUCCESS(NtStatus)) {
        
        LOGPRINT((ERRORLOG, "CpuProcessInit() - Error protecting memory 32-64 %lx\n", NtStatus));
        return NtStatus;
    }

#if 0
    LOGPRINT((ERRORLOG, "AMD64-Wow64Cpu : CpuProcessInit() - SUCCESS\n"));
#endif

    return NtStatus;
}


WOW64CPUAPI
NTSTATUS
CpuProcessTerm(
    HANDLE ProcessHandle
    )

/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    ProcessHandle - Called only for the current process. 
                    NULL - Indicates the first call to prepare for termination. 
                    NtCurrentProcess() - Indicates the actual that will terminate everything.

Return Value:

    NTSTATUS.

--*/

{
    return STATUS_SUCCESS;
}

WOW64CPUAPI
NTSTATUS
CpuThreadInit (
    PVOID pPerThreadData
    )

/*++

Routine Description:

    Per-thread termination code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/

{
    PCPUCONTEXT cpu;
    PTEB32 Teb32;


#if 0
    LOGPRINT((ERRORLOG, "AMD64-Wow64Cpu : Init CpuThradInit() - %p\n", pPerThreadData));
#endif
    
    //
    // Get the 32-bit Teb
    //

    Teb32 = NtCurrentTeb32();

    //
    // Align the CPUCONTEXT structure on a 16-byte boundary
    //

    cpu = (PCPUCONTEXT) ((((UINT_PTR) pPerThreadData) + 15) & ~0xfi64);

    //
    // This entry is used by the ISA transition routine. It is assumed
    // that the first entry in the cpu structure is the ia32 context record
    //

    Wow64TlsSetValue(WOW64_TLS_CPURESERVED, cpu);

    //
    // Initialize the 32-to-64 function pointer.
    //

    Teb32->WOW32Reserved = PtrToUlong (X86SwitchTo64BitMode);

    //
    // Initialize the remaining nonzero CPU fields
    // (Based on ntos\ke\i386\thredini.c and ntos\rtl\i386\context.c)
    //
    cpu->Context.SegCs = KGDT64_R3_CMCODE | RPL_MASK;
    cpu->Context.SegDs = KGDT64_R3_DATA | RPL_MASK;
    cpu->Context.SegEs = KGDT64_R3_DATA | RPL_MASK;
    cpu->Context.SegSs = KGDT64_R3_DATA | RPL_MASK;
    cpu->Context.SegFs = KGDT64_R3_CMTEB | RPL_MASK;

    //
    // Enable EFlags.IF
    //
    cpu->Context.EFlags = 0x202; 

    //
    // Set 32-bit esp
    // 

    cpu->Context.Esp = (ULONG) Teb32->NtTib.StackBase - sizeof(ULONG);
    
#if 0
    LOGPRINT((ERRORLOG, "AMD64-Wow64Cpu : CpuThradInit() - SUCCESS\n"));
#endif

    return STATUS_SUCCESS;
}

WOW64CPUAPI
NTSTATUS
CpuThreadTerm (
    VOID
    )

/*++

Routine Description:

    This routine is called at thread termination.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS.

--*/

{

    return STATUS_SUCCESS;
}

WOW64CPUAPI
VOID
CpuSimulate (
    VOID
    )

/*++

Routine Description:

    This routine starts the execution of 32-bit code. The 32-bit context
    is assumed to have been previously initialized.

Arguments:

    None.

Return Value:

    None - this function never returns.

--*/

{

    DECLARE_CPU;

    //
    // Loop continuously starting 32-bit execution, responding to system
    // calls, and restarting 32-bit execution.
    //

#if 0
    LOGPRINT((ERRORLOG, "AMD64-Wow64Cpu : CpuSimulate() - About to start simulation. Cpu=%p\n", cpu));
#endif

    while (1) {
        
        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext ("Before Simulate: ", cpu);
        }

        //
        // Lets reload the 32-bit context, switch the processor
        // state to compatibility mode and jump to the destination
        // eip (stored in the context)
        // 
        //

        CpupRunSimulatedCode ();

        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext ("After Simulate: ", cpu);
        }


        //
        // Let Wow64 performs the native system service
        //

        cpu->Context.Eax = Wow64SystemService (cpu->Context.Eax,
                                               &cpu->Context);
    }

    return;
}

WOW64CPUAPI
VOID
CpuResetToConsistentState (
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    When an exception happens, wow64 calls this routine to give the CPU
    a chance to recover the 32-bit context when the exception happened.
    
    CpuResetToConsistentState will :
    1- Retrieve and clear the WOW64_TLS_STACKPTR value
    2- If the exception happened on the 64-bit stack, then do nothing.
    3- If the exception happened on the 32-bit stack, then :
            a- Store the excepting 32-bit Eip into WOW64_TLS_EXCEPTIONADDR
            b- Change the excepting address to be CpupReturnFromSimulatedCode
            c- Change Sp to be the 64-bit Rsp
            d- Reset the code segment selector to the 64-bit long mode one
    
Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/

{

    PVOID StackPtr64;
    PVOID CpuSimulationFlag;
    PMACHINE_FRAME MachineFrame;
    CONTEXT32 FaultingContext;
    DECLARE_CPU;

    
    //
    // Save the last exception and context records.
    //
    memcpy (&RecoverException64,
            ExceptionPointers->ExceptionRecord,
            sizeof (RecoverException64));

    memcpy (&RecoverContext64,
            ExceptionPointers->ContextRecord,
            sizeof (RecoverContext64));
    
    //
    // Check to see if the exception happened on the 64-bit stack
    //

    StackPtr64 = Wow64TlsGetValue (WOW64_TLS_STACKPTR64);

    LOGPRINT((TRACELOG, "CpuResetToConsistantState (%p)\n", ExceptionPointers));

    //
    // First, clear out the WOW64_TLS_STACKPTR64 so subsequent
    // exceptions won't adjust native sp.
    //

    Wow64TlsSetValue(WOW64_TLS_STACKPTR64, 0);

    //
    // Check if the exception happened during executing 32-bit code
    //

    if (ExceptionPointers->ContextRecord->SegCs == (KGDT64_R3_CMCODE | RPL_MASK)) {


        MachineFrame = (PMACHINE_FRAME)((PCHAR)ExceptionPointers->ExceptionRecord + EXCEPTION_RECORD_LENGTH);
        

        //
        // Reload the full state of thread at the time of the exception
        // and store it inside the CPU
        //
        
        Wow64CtxFromAmd64 (CONTEXT32_FULLFLOAT,
                           ExceptionPointers->ContextRecord,
                           &cpu->Context);

        //
        // Store the actual exception address for now...
        //

        Wow64TlsSetValue (WOW64_TLS_EXCEPTIONADDR, 
                          (PVOID)ExceptionPointers->ContextRecord->Rip);

        //
        // Lets lie about the exception as if it was a native 64-bit exception.
        // To acheive this, we do the followings:
        //
        //  - Change the excpetion and context faulting RIP to CpupReturnFromSimulatedCode
        //  - Reload Context.SegCs with the native selector value
        //  - Reload Context.Rsp with the native RSP value
        //  - Reload MachineFrame values
        //

        ExceptionPointers->ContextRecord->Rsp = (ULONGLONG)StackPtr64;
        ExceptionPointers->ContextRecord->Rip = (ULONGLONG) CpupReturnFromSimulatedCode;
        ExceptionPointers->ContextRecord->SegCs = (KGDT64_R3_CODE | RPL_MASK);


        MachineFrame->Rip = ExceptionPointers->ContextRecord->Rip;
        MachineFrame->Rsp = ExceptionPointers->ContextRecord->Rsp;
        MachineFrame->SegCs = (KGDT64_R3_CODE | RPL_MASK);
        MachineFrame->SegSs = (KGDT64_R3_DATA | RPL_MASK);



        //
        // Let's make the exception record's address point to the faked location inside wow64cpu as well.
        //
        
        ExceptionPointers->ExceptionRecord->ExceptionAddress = (PVOID) ExceptionPointers->ContextRecord->Rip;
        
        //
        // We should never be putting in a null value here
        //

        WOWASSERT (ExceptionPointers->ContextRecord->Rsp);
    } else {

        //
        // If this is a RaiseException call from 32-bit code, then fake the exception
        // address for now so that the exception dispatcher would do its job the right
        // way. Then, in the wow64 exeption handler, I'd restore the exception address
        // before dispatching the excpetion to the 32-bit world.
        //

        CpuSimulationFlag = Wow64TlsGetValue (WOW64_TLS_INCPUSIMULATION);

        if (CpuSimulationFlag == NULL) {
            
            Wow64TlsSetValue (WOW64_TLS_EXCEPTIONADDR, 
                              (PVOID)ExceptionPointers->ExceptionRecord->ExceptionAddress);
            ExceptionPointers->ExceptionRecord->ExceptionAddress = (PVOID) ExceptionPointers->ContextRecord->Rip;
        }
    }

    return;
}

WOW64CPUAPI
ULONG
CpuGetStackPointer (
    VOID
    )

/*++

Routine Description:

    This routine returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    The current value of the 32-bit stack pointer is returned.

--*/

{

    DECLARE_CPU;

    return cpu->Context.Esp;
}

WOW64CPUAPI
VOID
CpuSetStackPointer (
    IN ULONG Value
    )
/*++

Routine Description:

    This routine sets the 32-bit stack pointer value.

Arguments:

    Value - Supplies the 32-bit stack pointer value.

Return Value:

    None.

--*/

{

    DECLARE_CPU;

    cpu->Context.Esp = Value;

    return;
}

WOW64CPUAPI
VOID
CpuResetFloatingPoint(
    VOID
    )
/*++

Routine Description:

    Modifies the floating point state to reset it to a non-error state

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}

WOW64CPUAPI
VOID
CpuSetInstructionPointer (
    IN ULONG Value
    )

/*++

Routine Description:

    This routine sets the 32-bit instruction pointer value.

Arguments:

    Value - Supplies the 32-bit instruction pointer value.

Return Value:

    None.

--*/

{

    DECLARE_CPU;

    cpu->Context.Eip = Value;

    return;
}

WOW64CPUAPI
VOID
CpuNotifyDllLoad (
    IN LPWSTR DllName,
    IN PVOID DllBase,
    IN ULONG DllSize
    )

/*++

Routine Description:

    This routine is called when the application successfully loads a DLL.

Arguments:

    DllName - Supplies a pointer to the name of the DLL.

    DllBase - Supplies the base address of the DLL.

    DllSize - Supplies the size of the DLL.

Return Value:

    None.

--*/

{

#if defined(DBG)

    LPWSTR tmpStr;

    //
    // Log name of DLL, its base address, and size.
    //

    tmpStr = DllName;
    try {
        if ((tmpStr == NULL) || (*tmpStr == L'\0')) {
            tmpStr = L"<Unknown>";
        }

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ? 1 : 0) {
        tmpStr = L"<Unknown>";
    }

    LOGPRINT((TRACELOG, "CpuNotifyDllLoad(\"%ws\", 0x%p, %d) called\n", tmpStr, DllBase, DllSize));

#endif

    return;
}

WOW64CPUAPI
VOID
CpuNotifyDllUnload (
    IN PVOID DllBase
    )

/*++

Routine Description:

    This routine get called when the application unloads a DLL.

Arguments:

    DllBase - Supplies the base address of the DLL.

Return Value:

    None.

--*/

{

    LOGPRINT((TRACELOG, "CpuNotifyDllUnLoad(%p) called\n", DllBase));

    return;
}
  
WOW64CPUAPI
VOID
CpuFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN ULONG Length,
    IN WOW64_FLUSH_REASON Reason
    )

/*++

Routine Description:

    This routine flushes the specified range of addreses from the instruction
    cache.

Arguments:

    ProcessHandle - Handle of process to flush instruction cache for
    
    BaseAddress - Supplies the starting address of the range to flush.

    Length - Supplies number of bytes to flush.

    Reason - Reason for the flush request

Return Value:

    None.

--*/

{
    //
    // Only flush the cache if we have a good reason. The hardware
    // doesn't care about alloc/free/protect flushes since it handles
    // self modifying code already. Thus, only flush if someone has
    // specifically asked for a flush...
    //

    if (WOW64_FLUSH_FORCE == Reason) {
        
        NtFlushInstructionCache (ProcessHandle, 
                                 BaseAddress, 
                                 Length);
    }

    return;
}

WOW64CPUAPI
BOOLEAN
CpuProcessDebugEvent(
    IN LPDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    This routine is called whenever a debug event needs to be processed. This would indicate
    that the current thread is acting as a debugger. This function gives CPU simulators
    a chance to decide whether this debug event should be dispatched to 32-bit code or not.

Arguments:

    DebugEvent  - Debug event to process

Return Value:

    BOOLEAN. This function returns TRUE if it processed the debug event, and doesn't
    wish to dispatch it to 32-bit code. Otherwise, it would return FALSE, and it
    would dispatch the debug event to 32-bit code.

--*/

{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\dbgexts\w64cpuex.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.cpp

Abstract:

    Debugger extension DLL for debugging the AMD64 CPU

Author:

    08-Jan-2002  Samer Arafeh  (samera)

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <dbgeng.h>
#include <ntosp.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include "wow64.h"
#include "wow64cpu.h"
#include "amd64cpu.h"

// Safe release and NULL.

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define CONTEXT_OFFSET FIELD_OFFSET(TEB64, TlsSlots[WOW64_TLS_CPURESERVED])


CPUCONTEXT            LocalCpuContext;
PWOW64GETCPUDATA      CpuGetData;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

WOW64CPUDBGAPI VOID
CpuDbgInitEngapi(
    PWOW64GETCPUDATA lpGetData
    )
{
    CpuGetData = lpGetData;
}


HRESULT
EngGetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to fill                 

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;
    
    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);
  
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    
    if (!NT_SUCCESS( GetContextRecord(&CpuContext, NULL, Context)))  
        return E_FAIL;
   
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PDEBUG_CLIENT Client,
    PVOID CpuData
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }
    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULL;
    hr = EngGetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

HRESULT
EngSetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to set

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);

    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
 
    if (!NT_SUCCESS(SetContextRecord(&CpuContext, NULL, Context, NULL)))
        return E_FAIL;

    hr = g_ExtData->WriteVirtual(CpuRemoteContext,
                                 &CpuContext,
                                 sizeof(CpuContext),
                                 NULL);
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    PDEBUG_CLIENT Client
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    NTSTATUS Status;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }

    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULL;
    hr = EngSetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        ExtOut("CpuDbgSetRemoteContext:  Error %x writing CPU context\n", hr);
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(GetContextRecord(&LocalCpuContext, NULL, Context));
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(SetContextRecord(&LocalCpuContext, NULL, Context, NULL));
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCacheWithHandle(
    HANDLE Process,
    PVOID Addr,
    DWORD Length
    )
{
    
    NtFlushInstructionCache((HANDLE)Process, Addr, Length);
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PDEBUG_CLIENT Client,
    PVOID Addr,
    DWORD Length
    )
{
    HRESULT hr;
    ULONG64 Process;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return;
    }
    hr = g_ExtSystem->GetCurrentProcessHandle(&Process);
    if (FAILED(hr)) {
        ExtOut("CpuDbgFlushInstructionCache: failed to get Process Handle!\n");
        return;
    }
    CpuDbgFlushInstructionCacheWithHandle((HANDLE)Process, Addr, Length);
    ExtRelease();
}


VOID SetEax(ULONG ul) {
    LocalCpuContext.Context.Eax = ul;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.Context.Ebx = ul;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.Context.Ecx = ul;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.Context.Edx = ul;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.Context.Esi = ul;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.Context.Edi = ul;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.Context.Ebp = ul;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.Context.Esp = ul;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.Context.Eip = ul;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.Context.EFlags = ul;
}

ULONG GetEax(VOID) {
    return LocalCpuContext.Context.Eax;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.Context.Ebx;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.Context.Ecx;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.Context.Edx;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.Context.Esi;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.Context.Edi;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.Context.Ebp;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.Context.Esp;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.Context.Eip;
}
ULONG GetEfl(VOID) {
    return LocalCpuContext.Context.EFlags;
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "Eax", SetEax, GetEax },
    { "Ebx", SetEbx, GetEbx },
    { "Ecx", SetEcx, GetEcx },
    { "Edx", SetEdx, GetEdx },
    { "Esi", SetEsi, GetEsi },
    { "Edi", SetEdi, GetEdi },
    { "Ebp", SetEbp, GetEbp },
    { "Esp", SetEsp, GetEsp },
    { "Eip", SetEip, GetEip },
    { "Efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\bintrans\wowia32x\btgeneric.h ===
/*
 *    INTEL CORPORATION PROPRIETARY INFORMATION
 *
 *    This software is supplied under the terms of a license
 *    agreement or nondisclosure agreement with Intel Corporation
 *    and may not be copied or disclosed except in accordance with
 *    the terms of that agreement.
 *    Copyright (c) 1991-2002  Intel Corporation.
 *
 */

#ifndef BTGENERIC_H
#define BTGENERIC_H

#ifndef NODEBUG
#define OVERRIDE_TIA 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MEM_READ    0x1
#define MEM_WRITE   0x2
#define MEM_EXECUTE 0x4
#define IS_MEM_ACCESSIBLE(permission) ((permission) != 0)

#define R13_FREE (-0x1)
#define R13_USED (-0x2)

#define BLOCK 0x0
#define CHECK 0x1

#define ACCESS_LOCK_OBJECT_SIZE 24


// Defines for initial memory allocation for either code or data.

#define INITIAL_DATA_ALLOC	((void *)0x1)
#define INITIAL_CODE_ALLOC	((void *)0x2)

/* IA32 interrupts */

#define IA32_DIVIDE_ERR_INTR	  0
#define IA32_DEBUG_INTR			  1
#define IA32_BREAKPOINT_INTR	  3
#define	IA32_OVERFLOW_INTR		  4
#define IA32_BOUND_INTR			  5
#define IA32_INV_OPCODE_INTR	  6
#define IA32_DEV_NA_INTR		  7
#define IA32_DOUBLE_FAULT_INTR	  8
#define IA32_INV_TSS_INTR		 10
#define IA32_NO_SEG_INTR		 11
#define IA32_STK_SEG_FAULT_INTR	 12
#define IA32_GEN_PROT_FAULT_INTR 13
#define IA32_PAGE_FAULT_INTR     14
#define IA32_MATH_FAULT_INTR	 16
#define IA32_ALIGN_CHECK_INTR	 17
#define IA32_MACHINE_CHECK_INTR	 18
#define IA32_SIMD_INTR	         19


//BT exception codes used to communicate exception information between BTGeneric and BTLib:
//code range 0-255 is reserved for IA32 interrupt vector numbers. The vector numbers are 
//used to specify software interrupts (INTn) only; the CPU-detected exceptions should be 
//encoded with a corresponding BT_EXCEPT_* value.
//BT_NO_EXCEPT is a special code indicating either false exception or 
//external interrupt (suspention)
//BT_EXCEPT_UNKNOWN code used to specify all exceptions unknown to IA-32 Execution Layer
//All values in the BtExceptionCode enumerator should be in the range 
//[0, BT_MAX_EXCEPTION_CODE]; other values are reserved for internal use.
enum BtExceptionCode {
    BT_MAX_INTERRUPT_NUMBER = 0xFF,
    BT_NO_EXCEPT,
    BT_EXCEPT_UNKNOWN,
    BT_EXCEPT_ACCESS_VIOLATION,
    BT_EXCEPT_DATATYPE_MISALIGNMENT,
    BT_EXCEPT_ARRAY_BOUNDS_EXCEEDED,
    BT_EXCEPT_FLT_DENORMAL_OPERAND,
    BT_EXCEPT_FLT_DIVIDE_BY_ZERO,
    BT_EXCEPT_FLT_INEXACT_RESULT,
    BT_EXCEPT_FLT_INVALID_OPERATION,
    BT_EXCEPT_FLT_OVERFLOW,
    BT_EXCEPT_FLT_UNDERFLOW,
    BT_EXCEPT_FLT_STACK_CHECK,
    BT_EXCEPT_INT_DIVIDE_BY_ZERO,
    BT_EXCEPT_INT_OVERFLOW,
    BT_EXCEPT_PRIV_INSTRUCTION,
    BT_EXCEPT_ILLEGAL_INSTRUCTION,
    BT_EXCEPT_FLOAT_MULTIPLE_FAULTS,
    BT_EXCEPT_FLOAT_MULTIPLE_TRAPS,
    BT_EXCEPT_STACK_OVERFLOW,
    BT_EXCEPT_GUARD_PAGE,
    BT_EXCEPT_BREAKPOINT,
    BT_EXCEPT_SINGLE_STEP

};
#define BT_MAX_EXCEPTION_CODE 0xFFF

typedef U32  BT_EXCEPTION_CODE;

//Structure that represents interruption context in addition to thread CONTEXT_64
typedef struct BtExceptionRecord {
    BT_EXCEPTION_CODE ExceptionCode;//BT exception code
    U64 Ia64IIPA;                   //Interruption Instruction Previous Address. 0 if unknown
    U64 Ia64ISR;                    //Interruption Status Register. UNKNOWN_ISR_VALUE if unknown
} BT_EXCEPTION_RECORD;

#define UNKNOWN_ISR_VALUE ((U64)(-1))

//BT status codes used to communicate error information between BTGeneric and BTLib:
enum BtStatusCode {
    BT_STATUS_SUCCESS = 0,
    BT_STATUS_UNSUCCESSFUL,
    BT_STATUS_NO_MEMORY,
    BT_STATUS_ACCESS_VIOLATION
};
typedef U32  BT_STATUS_CODE;

//BtgFlushIA32InstructionCache reason codes
enum BtFlushReason {
    BT_FLUSH_FORCE = 0, //code modification
    BT_FLUSH_FREE,      //memory release
    BT_FLUSH_ALLOC,     //memory allocation
    BT_FLUSH_PROTECT    //permission change
}; 
typedef U32  BT_FLUSH_REASON;

//BT object handle (process, etc.)
typedef void * BT_HANDLE;

#define BTGENERIC_VERSION       0
#define BTGENERIC_API_STRING    256
#define SIZE_OF_STRING          128
#define NO_OF_APIS              42

// a pointer to plabel. 
// This type will be used to define the API_Table

typedef void(*PLABEL_PTR_TYPE)();

typedef struct API_TABLE_ELEMENT_TYPE {
    PLABEL_PTR_TYPE PLabelPtr;       // ptr to the function's plabel
/*    WCHAR APIName[SIZE_OF_STRING];   // API name string*/
} API_TABLE_ELEMENT_TYPE;

// this should be updated if API_TABLE_TYPE changes!!
#define API_TABLE_START_OFFSET ((sizeof(U32) * 4) + SIZE_OF_STRING)

typedef struct APITableType {
    U32    VersionNumber;      // version number info
    U32    SizeOfString;       // size of string in version & APIName;
    U32    NoOfAPIs;           // no. of elements in APITable
    U32    TableStartOffset;   // offset of APITable from the beginning of the struct
    WCHAR  VersionString[SIZE_OF_STRING];  
    API_TABLE_ELEMENT_TYPE APITable[NO_OF_APIS];
} API_TABLE_TYPE;

// BTGeneric APIs indexes
 
#define  IDX_BTGENERIC_START                                    0
#define  IDX_BTGENERIC_THREAD_INIT                              1
#define  IDX_BTGENERIC_RUN                                      2
//#define  IDX_BTGENERIC_RUN_EXIT                                 3
#define  IDX_BTGENERIC_THREAD_TERMINATED                        4
#define  IDX_BTGENERIC_THREAD_ABORTED                           5
#define  IDX_BTGENERIC_PROCESS_TERM                             6
//#define  IDX_BTGENERIC_PROCESS_ABORTED                          7
#define  IDX_BTGENERIC_IA32_CONTEXT_SET                         8
#define  IDX_BTGENERIC_IA32_CONTEXT_GET                         9
#define  IDX_BTGENERIC_IA32_CONTEXT_SET_REMOTE                 10
#define  IDX_BTGENERIC_IA32_CONTEXT_GET_REMOTE                 11
#define  IDX_BTGENERIC_IA32_CANONIZE_CONTEXT                   12
#define  IDX_BTGENERIC_CANONIZE_SUSPEND_CONTEXT_REMOTE         13
#define  IDX_BTGENERIC_REPORT_LOAD                             14
#define  IDX_BTGENERIC_REPORT_UNLOAD                           15
#define  IDX_BTGENERIC_NOTIFY_CHANGE_PERMISSION_REQUEST        16
#define  IDX_BTGENERIC_FLUSH_IA32_INSTRUCTION_CACHE            17
#define  IDX_BTGENERIC_DEBUG_SETTINGS                          18
#define  IDX_BTGENERIC_CHECK_SUSPEND_CONTEXT                   19
#define  IDX_BTGENERIC_EXCEPTION_DEBUG_PRINT                   20
#define  IDX_BTGENERIC_NOTIFY_EXIT                             21
#define  IDX_BTGENERIC_CANONIZE_SUSPEND_CONTEXT                22
#define  IDX_BTGENERIC_NOTIFY_PREPARE_EXIT                     23
#define	 IDX_BTGENERIC_FREEZE                                  24
#define	 IDX_BTGENERIC_UNFREEZE                                25
#define	 IDX_BTGENERIC_CHANGE_THREAD_IDENTITY                  26
#ifdef OVERRIDE_TIA
#define  IDX_BTGENERIC_USE_OVERRIDE_TIA                        27
#endif // OVERRIDE_TIA

// BTlib APIs indexes

#define IDX_BTLIB_GET_THREAD_ID                                 0
#define IDX_BTLIB_IA32_REENTER                                  1
#define IDX_BTLIB_IA32_LCALL                                    2
#define IDX_BTLIB_IA32_INTERRUPT                                3
#define IDX_BTLIB_IA32_JMP_IA64                                 4
#define IDX_BTLIB_LOCK_SIGNALS                                  5
#define IDX_BTLIB_UNLOCK_SIGNALS                                6
#define IDX_BTLIB_MEMORY_ALLOC                                  7
#define IDX_BTLIB_MEMORY_FREE                                   8
#define IDX_BTLIB_MEMORY_PAGE_SIZE                              9
#define IDX_BTLIB_MEMORY_CHANGE_PERMISSIONS                    10
#define IDX_BTLIB_MEMORY_QUERY_PERMISSIONS                     11
#define IDX_BTLIB_MEMORY_READ_REMOTE                           12
#define IDX_BTLIB_MEMORY_WRITE_REMOTE                          13
//#define IDX_BTLIB_ATOMIC_MISALIGNED_LOAD                       14
//#define IDX_BTLIB_ATOMIC_MISALIGNED_STORE                      15
#define IDX_BTLIB_SUSPEND_THREAD                               16
#define IDX_BTLIB_RESUME_THREAD                                17
#define IDX_BTLIB_INIT_ACCESS_LOCK                             18
#define IDX_BTLIB_LOCK_ACCESS                                  19
#define IDX_BTLIB_UNLOCK_ACCESS                                20
#define IDX_BTLIB_INVALIDATE_ACCESS_LOCK                       21
#define IDX_BTLIB_QUERY_JMPBUF_SIZE                            22
#define IDX_BTLIB_SETJMP                                       23
#define IDX_BTLIB_LONGJMP                                      24
#define IDX_BTLIB_DEBUG_PRINT                                  25
#define IDX_BTLIB_ABORT                                        26

#define IDX_BTLIB_VTUNE_CODE_CREATED                           27
#define IDX_BTLIB_VTUNE_CODE_DELETED                           28
#define IDX_BTLIB_VTUNE_ENTERING_DYNAMIC_CODE                  29
#define IDX_BTLIB_VTUNE_EXITING_DYNAMIC_CODE                   30
#define IDX_BTLIB_VTUNE_CODE_TO_TIA_DMP_FILE                   31

#define IDX_BTLIB_SSCPERFGETCOUNTER64                          32
#define IDX_BTLIB_SSCPERFSETCOUNTER64                          33
#define IDX_BTLIB_SSCPERFSENDEVENT                             34
#define IDX_BTLIB_SSCPERFEVENTHANDLE                           35
#define IDX_BTLIB_SSCPERFCOUNTERHANDLE                         36

#define IDX_BTLIB_YIELD_THREAD_EXECUTION                       37

#define IDX_BTLIB_FLUSH_IA64_INSTRUCTION_CACHE                 38
#define IDX_BTLIB_PSEUDO_OPEN_FILE                             39
#define IDX_BTLIB_PSEUDO_CLOSE_FILE                            40
#define IDX_BTLIB_PSEUDO_WRITE_FILE                            41


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#define CONTEXT_IA32    0x00010000    // any IA32 context

#define CONTEXT32_CONTROL         (CONTEXT_IA32 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT32_INTEGER         (CONTEXT_IA32 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT32_SEGMENTS        (CONTEXT_IA32 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT32_FLOATING_POINT  (CONTEXT_IA32 | 0x00000008L) // 387 state
#define CONTEXT32_DEBUG_REGISTERS (CONTEXT_IA32 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT32_EXTENDED_REGISTERS  (CONTEXT_IA32 | 0x00000020L) // cpu specific extensions

#define CONTEXT32_FULL (CONTEXT32_CONTROL | CONTEXT32_INTEGER |\
                      CONTEXT32_SEGMENTS)

#define MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _FLOATING_SAVE_AREA32 {
    U32   ControlWord;
    U32   StatusWord;
    U32   TagWord;
    U32   ErrorOffset;
    U32   ErrorSelector;
    U32   DataOffset;
    U32   DataSelector;
    U8    RegisterArea[SIZE_OF_80387_REGISTERS];
    U32   Cr0NpxState;
} FLOATING_SAVE_AREA32;

typedef struct _CONTEXT32 {


    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    U32 ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    U32   Dr0;
    U32   Dr1;
    U32   Dr2;
    U32   Dr3;
    U32   Dr6;
    U32   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA32 FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    U32   SegGs;
    U32   SegFs;
    U32   SegEs;
    U32   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    U32   Edi;
    U32   Esi;
    U32   Ebx;
    U32   Edx;
    U32   Ecx;
    U32   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    U32   Ebp;
    U32   Eip;
    U32   SegCs;              // MUST BE SANITIZED
    U32   EFlags;             // MUST BE SANITIZED
    U32   Esp;
    U32   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    U8    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} BTGENERIC_IA32_CONTEXT;

#define CONTEXT_IA64                    0x00080000

#define CONTEXT_LOWER_FLOATING_POINT    (CONTEXT_IA64 | 0x00000002L)
#define CONTEXT_HIGHER_FLOATING_POINT   (CONTEXT_IA64 | 0x00000004L)
#define CONTEXT_DEBUG                   (CONTEXT_IA64 | 0x00000010L)
#define CONTEXT_IA32_CONTROL            (CONTEXT_IA64 | 0x00000020L)  // Includes StIPSR

#if (! defined CONTEXT_INTEGER) || ( ! defined CONTEXT_INTEGER ) || ( ! defined CONTEXT_FLOATING_POINT ) || ( ! defined CONTEXT_FULL )
#define CONTEXT_CONTROL                 (CONTEXT_IA64 | 0x00000001L)
#define CONTEXT_INTEGER                 (CONTEXT_IA64 | 0x00000008L)
#define CONTEXT_FLOATING_POINT          (CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT)
#define CONTEXT_FULL                    (CONTEXT_CONTROL | CONTEXT_FLOATING_POINT | CONTEXT_INTEGER | CONTEXT_IA32_CONTROL)
#endif

typedef struct _CONTEXT64 {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    U32 ContextFlags;
    U32 Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

    // Please contact INTEL to get IA64-specific information
    // @@BEGIN_DDKSPLIT
    U64 DbI0;         // Intel-IA64-Filler
    U64 DbI1;         // Intel-IA64-Filler
    U64 DbI2;         // Intel-IA64-Filler
    U64 DbI3;         // Intel-IA64-Filler
    U64 DbI4;         // Intel-IA64-Filler
    U64 DbI5;         // Intel-IA64-Filler
    U64 DbI6;         // Intel-IA64-Filler
    U64 DbI7;         // Intel-IA64-Filler

    U64 DbD0;         // Intel-IA64-Filler
    U64 DbD1;         // Intel-IA64-Filler
    U64 DbD2;         // Intel-IA64-Filler
    U64 DbD3;         // Intel-IA64-Filler
    U64 DbD4;         // Intel-IA64-Filler
    U64 DbD5;         // Intel-IA64-Filler
    U64 DbD6;         // Intel-IA64-Filler
    U64 DbD7;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //

    FLOAT128 FltS0;         // Intel-IA64-Filler
    FLOAT128 FltS1;         // Intel-IA64-Filler
    FLOAT128 FltS2;         // Intel-IA64-Filler
    FLOAT128 FltS3;         // Intel-IA64-Filler
    FLOAT128 FltT0;         // Intel-IA64-Filler
    FLOAT128 FltT1;         // Intel-IA64-Filler
    FLOAT128 FltT2;         // Intel-IA64-Filler
    FLOAT128 FltT3;         // Intel-IA64-Filler
    FLOAT128 FltT4;         // Intel-IA64-Filler
    FLOAT128 FltT5;         // Intel-IA64-Filler
    FLOAT128 FltT6;         // Intel-IA64-Filler
    FLOAT128 FltT7;         // Intel-IA64-Filler
    FLOAT128 FltT8;         // Intel-IA64-Filler
    FLOAT128 FltT9;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //

    FLOAT128 FltS4;         // Intel-IA64-Filler
    FLOAT128 FltS5;         // Intel-IA64-Filler
    FLOAT128 FltS6;         // Intel-IA64-Filler
    FLOAT128 FltS7;         // Intel-IA64-Filler
    FLOAT128 FltS8;         // Intel-IA64-Filler
    FLOAT128 FltS9;         // Intel-IA64-Filler
    FLOAT128 FltS10;        // Intel-IA64-Filler
    FLOAT128 FltS11;        // Intel-IA64-Filler
    FLOAT128 FltS12;        // Intel-IA64-Filler
    FLOAT128 FltS13;        // Intel-IA64-Filler
    FLOAT128 FltS14;        // Intel-IA64-Filler
    FLOAT128 FltS15;        // Intel-IA64-Filler
    FLOAT128 FltS16;        // Intel-IA64-Filler
    FLOAT128 FltS17;        // Intel-IA64-Filler
    FLOAT128 FltS18;        // Intel-IA64-Filler
    FLOAT128 FltS19;        // Intel-IA64-Filler

    FLOAT128 FltF32;        // Intel-IA64-Filler
    FLOAT128 FltF33;        // Intel-IA64-Filler
    FLOAT128 FltF34;        // Intel-IA64-Filler
    FLOAT128 FltF35;        // Intel-IA64-Filler
    FLOAT128 FltF36;        // Intel-IA64-Filler
    FLOAT128 FltF37;        // Intel-IA64-Filler
    FLOAT128 FltF38;        // Intel-IA64-Filler
    FLOAT128 FltF39;        // Intel-IA64-Filler

    FLOAT128 FltF40;        // Intel-IA64-Filler
    FLOAT128 FltF41;        // Intel-IA64-Filler
    FLOAT128 FltF42;        // Intel-IA64-Filler
    FLOAT128 FltF43;        // Intel-IA64-Filler
    FLOAT128 FltF44;        // Intel-IA64-Filler
    FLOAT128 FltF45;        // Intel-IA64-Filler
    FLOAT128 FltF46;        // Intel-IA64-Filler
    FLOAT128 FltF47;        // Intel-IA64-Filler
    FLOAT128 FltF48;        // Intel-IA64-Filler
    FLOAT128 FltF49;        // Intel-IA64-Filler

    FLOAT128 FltF50;        // Intel-IA64-Filler
    FLOAT128 FltF51;        // Intel-IA64-Filler
    FLOAT128 FltF52;        // Intel-IA64-Filler
    FLOAT128 FltF53;        // Intel-IA64-Filler
    FLOAT128 FltF54;        // Intel-IA64-Filler
    FLOAT128 FltF55;        // Intel-IA64-Filler
    FLOAT128 FltF56;        // Intel-IA64-Filler
    FLOAT128 FltF57;        // Intel-IA64-Filler
    FLOAT128 FltF58;        // Intel-IA64-Filler
    FLOAT128 FltF59;        // Intel-IA64-Filler

    FLOAT128 FltF60;        // Intel-IA64-Filler
    FLOAT128 FltF61;        // Intel-IA64-Filler
    FLOAT128 FltF62;        // Intel-IA64-Filler
    FLOAT128 FltF63;        // Intel-IA64-Filler
    FLOAT128 FltF64;        // Intel-IA64-Filler
    FLOAT128 FltF65;        // Intel-IA64-Filler
    FLOAT128 FltF66;        // Intel-IA64-Filler
    FLOAT128 FltF67;        // Intel-IA64-Filler
    FLOAT128 FltF68;        // Intel-IA64-Filler
    FLOAT128 FltF69;        // Intel-IA64-Filler

    FLOAT128 FltF70;        // Intel-IA64-Filler
    FLOAT128 FltF71;        // Intel-IA64-Filler
    FLOAT128 FltF72;        // Intel-IA64-Filler
    FLOAT128 FltF73;        // Intel-IA64-Filler
    FLOAT128 FltF74;        // Intel-IA64-Filler
    FLOAT128 FltF75;        // Intel-IA64-Filler
    FLOAT128 FltF76;        // Intel-IA64-Filler
    FLOAT128 FltF77;        // Intel-IA64-Filler
    FLOAT128 FltF78;        // Intel-IA64-Filler
    FLOAT128 FltF79;        // Intel-IA64-Filler

    FLOAT128 FltF80;        // Intel-IA64-Filler
    FLOAT128 FltF81;        // Intel-IA64-Filler
    FLOAT128 FltF82;        // Intel-IA64-Filler
    FLOAT128 FltF83;        // Intel-IA64-Filler
    FLOAT128 FltF84;        // Intel-IA64-Filler
    FLOAT128 FltF85;        // Intel-IA64-Filler
    FLOAT128 FltF86;        // Intel-IA64-Filler
    FLOAT128 FltF87;        // Intel-IA64-Filler
    FLOAT128 FltF88;        // Intel-IA64-Filler
    FLOAT128 FltF89;        // Intel-IA64-Filler

    FLOAT128 FltF90;        // Intel-IA64-Filler
    FLOAT128 FltF91;        // Intel-IA64-Filler
    FLOAT128 FltF92;        // Intel-IA64-Filler
    FLOAT128 FltF93;        // Intel-IA64-Filler
    FLOAT128 FltF94;        // Intel-IA64-Filler
    FLOAT128 FltF95;        // Intel-IA64-Filler
    FLOAT128 FltF96;        // Intel-IA64-Filler
    FLOAT128 FltF97;        // Intel-IA64-Filler
    FLOAT128 FltF98;        // Intel-IA64-Filler
    FLOAT128 FltF99;        // Intel-IA64-Filler

    FLOAT128 FltF100;       // Intel-IA64-Filler
    FLOAT128 FltF101;       // Intel-IA64-Filler
    FLOAT128 FltF102;       // Intel-IA64-Filler
    FLOAT128 FltF103;       // Intel-IA64-Filler
    FLOAT128 FltF104;       // Intel-IA64-Filler
    FLOAT128 FltF105;       // Intel-IA64-Filler
    FLOAT128 FltF106;       // Intel-IA64-Filler
    FLOAT128 FltF107;       // Intel-IA64-Filler
    FLOAT128 FltF108;       // Intel-IA64-Filler
    FLOAT128 FltF109;       // Intel-IA64-Filler

    FLOAT128 FltF110;       // Intel-IA64-Filler
    FLOAT128 FltF111;       // Intel-IA64-Filler
    FLOAT128 FltF112;       // Intel-IA64-Filler
    FLOAT128 FltF113;       // Intel-IA64-Filler
    FLOAT128 FltF114;       // Intel-IA64-Filler
    FLOAT128 FltF115;       // Intel-IA64-Filler
    FLOAT128 FltF116;       // Intel-IA64-Filler
    FLOAT128 FltF117;       // Intel-IA64-Filler
    FLOAT128 FltF118;       // Intel-IA64-Filler
    FLOAT128 FltF119;       // Intel-IA64-Filler

    FLOAT128 FltF120;       // Intel-IA64-Filler
    FLOAT128 FltF121;       // Intel-IA64-Filler
    FLOAT128 FltF122;       // Intel-IA64-Filler
    FLOAT128 FltF123;       // Intel-IA64-Filler
    FLOAT128 FltF124;       // Intel-IA64-Filler
    FLOAT128 FltF125;       // Intel-IA64-Filler
    FLOAT128 FltF126;       // Intel-IA64-Filler
    FLOAT128 FltF127;       // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //

    U64 StFPSR;       // Intel-IA64-Filler ; FP status

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //

    U64 IntGp;        // Intel-IA64-Filler ; r1, volatile
    U64 IntT0;        // Intel-IA64-Filler ; r2-r3, volatile
    U64 IntT1;        // Intel-IA64-Filler ;
    U64 IntS0;        // Intel-IA64-Filler ; r4-r7, preserved
    U64 IntS1;        // Intel-IA64-Filler
    U64 IntS2;        // Intel-IA64-Filler
    U64 IntS3;        // Intel-IA64-Filler
    U64 IntV0;        // Intel-IA64-Filler ; r8, volatile
    U64 IntT2;        // Intel-IA64-Filler ; r9-r11, volatile
    U64 IntT3;        // Intel-IA64-Filler
    U64 IntT4;        // Intel-IA64-Filler
    U64 IntSp;        // Intel-IA64-Filler ; stack pointer (r12), special
    U64 IntTeb;       // Intel-IA64-Filler ; teb (r13), special
    U64 IntT5;        // Intel-IA64-Filler ; r14-r31, volatile
    U64 IntT6;        // Intel-IA64-Filler
    U64 IntT7;        // Intel-IA64-Filler
    U64 IntT8;        // Intel-IA64-Filler
    U64 IntT9;        // Intel-IA64-Filler
    U64 IntT10;       // Intel-IA64-Filler
    U64 IntT11;       // Intel-IA64-Filler
    U64 IntT12;       // Intel-IA64-Filler
    U64 IntT13;       // Intel-IA64-Filler
    U64 IntT14;       // Intel-IA64-Filler
    U64 IntT15;       // Intel-IA64-Filler
    U64 IntT16;       // Intel-IA64-Filler
    U64 IntT17;       // Intel-IA64-Filler
    U64 IntT18;       // Intel-IA64-Filler
    U64 IntT19;       // Intel-IA64-Filler
    U64 IntT20;       // Intel-IA64-Filler
    U64 IntT21;       // Intel-IA64-Filler
    U64 IntT22;       // Intel-IA64-Filler

    U64 IntNats;      // Intel-IA64-Filler ; Nat bits for r1-r31
                            // Intel-IA64-Filler ; r1-r31 in bits 1 thru 31.
    U64 Preds;        // Intel-IA64-Filler ; predicates, preserved

    U64 BrRp;         // Intel-IA64-Filler ; return pointer, b0, preserved
    U64 BrS0;         // Intel-IA64-Filler ; b1-b5, preserved
    U64 BrS1;         // Intel-IA64-Filler
    U64 BrS2;         // Intel-IA64-Filler
    U64 BrS3;         // Intel-IA64-Filler
    U64 BrS4;         // Intel-IA64-Filler
    U64 BrT0;         // Intel-IA64-Filler ; b6-b7, volatile
    U64 BrT1;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers
    U64 ApUNAT;       // Intel-IA64-Filler ; User Nat collection register, preserved
    U64 ApLC;         // Intel-IA64-Filler ; Loop counter register, preserved
    U64 ApEC;         // Intel-IA64-Filler ; Epilog counter register, preserved
    U64 ApCCV;        // Intel-IA64-Filler ; CMPXCHG value register, volatile
    U64 ApDCR;        // Intel-IA64-Filler ; Default control register (TBD)

    // Register stack info
    U64 RsPFS;        // Intel-IA64-Filler ; Previous function state, preserved
    U64 RsBSP;        // Intel-IA64-Filler ; Backing store pointer, preserved
    U64 RsBSPSTORE;   // Intel-IA64-Filler
    U64 RsRSC;        // Intel-IA64-Filler ; RSE configuration, volatile
    U64 RsRNAT;       // Intel-IA64-Filler ; RSE Nat collection register, preserved

    // Trap Status Information
    U64 StIPSR;       // Intel-IA64-Filler ; Interruption Processor Status
    U64 StIIP;        // Intel-IA64-Filler ; Interruption IP
    U64 StIFS;        // Intel-IA64-Filler ; Interruption Function State

    // iA32 related control registers
    U64 StFCR;        // Intel-IA64-Filler ; copy of Ar21
    U64 Eflag;        // Intel-IA64-Filler ; Eflag copy of Ar24
    U64 SegCSD;       // Intel-IA64-Filler ; iA32 CSDescriptor (Ar25)
    U64 SegSSD;       // Intel-IA64-Filler ; iA32 SSDescriptor (Ar26)
    U64 Cflag;        // Intel-IA64-Filler ; Cr0+Cr4 copy of Ar27
    U64 StFSR;        // Intel-IA64-Filler ; x86 FP status (copy of AR28)
    U64 StFIR;        // Intel-IA64-Filler ; x86 FP status (copy of AR29)
    U64 StFDR;        // Intel-IA64-Filler ; x86 FP status (copy of AR30)

    U64 UNUSEDPACK;   // Intel-IA64-Filler ; added to pack StFDR to 16-bytes
    // @@END_DDKSPLIT

} BTGENERIC_IA64_CONTEXT;

// Vtune stuff

typedef enum {
    VTUNE_CALL_ID_CREATED=1,
    VTUNE_CALL_ID_DELETED,
    VTUNE_CALL_ID_FLUSH,
    VTUNE_CALL_ID_ENTER,
    VTUNE_CALL_ID_EXIT,
    VTUNE_CALL_ID_EVENT,
	VTUNE_BTGENERIC_LOADED
} VTUNE_CALL_ID_TYPE;

typedef enum {
    VTUNE_COLD_BLOCK=1,
    VTUNE_HOT_BLOCK,
    VTUNE_HOT_LOOP_BLOCK,
    VTUNE_COLD_WRITABLE_BLOCK
} VTUNE_BLOCK_CATEGORY_TYPE;

typedef struct  {
    U64 name;                           // length is smaller then 256 chars   
    VTUNE_BLOCK_CATEGORY_TYPE type;    // Vtune++ should be aware of this type, for breakdown
    U64 start;                          // index, i.e. guaranteed not to repeat
    U64 size;                           // in bytes
    U32 IA32start;                      // IA32 address
    U64 traversal;                      // An ID  
    //char *assembly;                   // if needed
    U64 reserved;                       // unused
} VTUNE_BLOCK_TYPE;

typedef enum
{
    ESTIMATED_TIME,
    CODE_SIZE,
    INST_COUNT
} VTUNE_EVENT_TYPE;

// BtgCanonizeSuspendContext return values 
enum BtThreadSuspendState
{
    SUSPEND_STATE_CONSISTENT, // thread suspended in a consistent IA32 state; 
                              // no changes in IA64Context

    SUSPEND_STATE_CANONIZED,  // IA32 thread state canonized; 
                              // there are changes in IA64Context

    SUSPEND_STATE_READY_FOR_CANONIZATION, // target thread is ready to canonize IA32 state by itself.
                                          // IA64Context has been changed so that resumed thread
                                          // will cannonize IA32 state and exit simulation

    BAD_SUSPEND_STATE,         // recoverable error: 
                               // thread can not be suspended in the current state

    SUSPEND_STATE_INACCESIBLE  // fatal error: thread can not be suspended
    
};
typedef U32 BT_THREAD_SUSPEND_STATE;

// BTGeneric's APIs

#if (BTGENERIC)

extern BT_STATUS_CODE BtgStart(IN API_TABLE_TYPE * BTLlibApiTable,void * BTGenericLoadAddress, void * BTGenericEndAddress, int glstPoffset, U32 * BTGenericTlsSizeP, U32 * BTGenericContextOffsetP);
extern BT_STATUS_CODE BtgThreadInit(BTGENERIC_LOCAL_STORAGE * glstMemory, U32 ia32StackPointer, BT_U64 FS_offset /*, BT_U64 GS_offset */);
extern void BtgRun(void);
extern void BtgThreadTerminated(void);
extern void BtgThreadAborted(U64 threadId);
extern void BtgProcessTerm(void);
extern BT_STATUS_CODE BtgIA32ContextSet(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA32_CONTEXT * context);
extern BT_STATUS_CODE BtgIA32ContextGet(BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA32_CONTEXT * context);
extern BT_STATUS_CODE BtgIA32ContextSetRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA32_CONTEXT * context);
extern BT_STATUS_CODE BtgIA32ContextGetRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA32_CONTEXT * context);
extern BT_EXCEPTION_CODE BtgIA32CanonizeContext(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA64_CONTEXT * ia64context, const BT_EXCEPTION_RECORD * exceptionRecordP);
extern void BtgReportLoad(U64 * location,U32 size,U8 * name);
extern void BtgReportUnload(U64 * location,U32 size,U8 * name);
extern void BtgNotifyChangePermissionRequest(void  * startPage, U32 numPages, U64 permissions);
extern void BtgFlushIA32InstructionCache(void * address, U32 size, BT_FLUSH_REASON reason);
extern BT_STATUS_CODE BtgDebugSettings(int argc, char *argv[]);
extern void BtgExceptionDebugPrint (void);
extern void BtgNotifyExit (void);
extern BT_THREAD_SUSPEND_STATE BtgCanonizeSuspendContext(BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA64_CONTEXT * ia64context, U64 prevSuspendCount);
extern BT_THREAD_SUSPEND_STATE BtgCanonizeSuspendContextRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA64_CONTEXT * ia64context, U64 prevSuspendCount);
extern BT_THREAD_SUSPEND_STATE BtgCheckSuspendContext(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA64_CONTEXT * ia64context);
extern void BtgNotifyPrepareExit (void);
extern void BtgFreeze(void);
extern void BtgUnfreeze(void);
extern BT_STATUS_CODE BtgChangeThreadIdentity(void);
#ifdef OVERRIDE_TIA
extern void BtgUseOverrideTIA(unsigned int OvrTiaSize, unsigned char * OvrTiaBuffer);
#endif // OVERRIDE_TIA

#else // BTLib

extern PLABEL_PTR_TYPE BtlPlaceHolderTable[NO_OF_APIS];
#define BTGENERIC(APIName) (*(BtlPlaceHolderTable[IDX_BTGENERIC_##APIName]))
#define BTGENERIC_(TYPE,APIName) (*(TYPE (*)())(BtlPlaceHolderTable[IDX_BTGENERIC_##APIName]))

//extern BT_STATUS_CODE BtgStart(API_TABLE_TYPE * BTLibAPITable,void * BTGenericAddress, void * BTGenericEnd, int glstOffset, U32 * BTGenericTlsSizeP, U32 * BTGenericContextOffsetP);
#define BTGENERIC_START(BTLibAPITable, BTGenericAddress, BTGenericEnd, glstOffset, BTGenericTlsSizeP, BTGenericContextOffsetP) \
        BTGENERIC_(BT_STATUS_CODE, START)((API_TABLE_TYPE *)(BTLibAPITable), (void *)(BTGenericAddress), (void *)(BTGenericEnd), (S32)(glstOffset), (U32 *)(BTGenericTlsSizeP), (U32 *)(BTGenericContextOffsetP))
//extern BT_STATUS_CODE BtgThreadInit(BTGENERIC_LOCAL_STORAGE * glstMemory, U32 ia32StackPointer, U64 FS_offset, U64 GS_offset);
#define BTGENERIC_THREAD_INIT(glstMemory,ia32StackPointer, FS_offset /*, GS_offset */)                                      \
        BTGENERIC_(BT_STATUS_CODE, THREAD_INIT)((void *)(glstMemory), (U32)(ia32StackPointer), (U64) FS_offset /*, (U64) GS_offset */) 
//extern void BtgRun(void);
#define BTGENERIC_RUN()                                                                         \
        BTGENERIC(RUN)()
//extern void BtgThreadTerminated(void);
#define BTGENERIC_THREAD_TERMINATED()                                                           \
        BTGENERIC(THREAD_TERMINATED)()
//extern void BtgThreadAborted(U64 threadId);
#define BTGENERIC_THREAD_ABORTED(threadId)                                                      \
        BTGENERIC(THREAD_ABORTED)((U64)(threadId))
//extern void BtgProcessTerm(void);
#define BTGENERIC_PROCESS_TERM()                                                                \
        BTGENERIC(PROCESS_TERM)()
//extern BT_STATUS_CODE BtgIA32ContextSet(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA32_CONTEXT * context);
#define BTGENERIC_IA32_CONTEXT_SET(glstMemory, context)                                                     \
        BTGENERIC_(BT_STATUS_CODE, IA32_CONTEXT_SET)((void *)(glstMemory), (const BTGENERIC_IA32_CONTEXT *)(context))
//extern BT_STATUS_CODE BtgIA32ContextGet(BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA32_CONTEXT * context);
#define BTGENERIC_IA32_CONTEXT_GET(glstMemory, context)                                                     \
        BTGENERIC_(BT_STATUS_CODE, IA32_CONTEXT_GET)((void *)(glstMemory), (BTGENERIC_IA32_CONTEXT *)(context))
//extern BT_STATUS_CODE BtgIA32ContextSetRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA32_CONTEXT * context);
#define BTGENERIC_IA32_CONTEXT_SET_REMOTE(processHandle, glstMemory, context)                                   \
        BTGENERIC_(BT_STATUS_CODE, IA32_CONTEXT_SET_REMOTE)((BT_HANDLE)(processHandle), (void *)(glstMemory), (const BTGENERIC_IA32_CONTEXT *)(context))
//extern BT_STATUS_CODE BtgIA32ContextGetRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA32_CONTEXT * context);
#define BTGENERIC_IA32_CONTEXT_GET_REMOTE(processHandle, glstMemory, context)                                   \
        BTGENERIC_(BT_STATUS_CODE, IA32_CONTEXT_GET_REMOTE)((BT_HANDLE)(processHandle), (void *)(glstMemory), (BTGENERIC_IA32_CONTEXT *)(context))
//extern BT_EXCEPTION_CODE BtgIA32CanonizeContext(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA64_CONTEXT * ia64context, const BT_EXCEPTION_RECORD * exceptionRecordP);
#define BTGENERIC_IA32_CANONIZE_CONTEXT(glstMemory, ia64context, exceptionRecordP)                               \
        BTGENERIC_(BT_EXCEPTION_CODE, IA32_CANONIZE_CONTEXT)((void *)glstMemory, (const BTGENERIC_IA64_CONTEXT *)(ia64context), (const BT_EXCEPTION_RECORD *)(exceptionRecordP))
//extern void BtgReportLoad(U64 * location,U32 size,U8 * name);
#define BTGENERIC_REPORT_LOAD(location, size, name)                                             \
        BTGENERIC(REPORT_LOAD)((U64 *)(location),(U32)(size),(U8 *)(name))
//extern void BtgReportUnload(U64 * location,U32 size,U8 * name);
#define BTGENERIC_REPORT_UNLOAD(location, size, name)                                           \
        BTGENERIC(REPORT_UNLOAD)((U64 *)(location),(U32)(size),(U8 *)(name))
//extern void BtgNotifyChangePermissionRequest(void * startPage, U32 numPages, U64 permissions);
#define BTGENERIC_NOTIFY_CHANGE_PERMISSION_REQUEST(pageStart, numPages, permissions)           \
        BTGENERIC(NOTIFY_CHANGE_PERMISSION_REQUEST)((void *)(pageStart), (U32)(numPages), (U64)(permissions))
//extern void BtgFlushIA32InstructionCache(void * address, U32 size, BT_FLUSH_REASON reason);
#define BTGENERIC_FLUSH_IA32_INSTRUCTION_CACHE(address, size, reason)                                   \
        BTGENERIC(FLUSH_IA32_INSTRUCTION_CACHE)((void *)(address), (U32)(size), (BT_FLUSH_REASON)reason)
//extern BT_STATUS_CODE BtgDebugSettings(int argc, char *argv[])
#define BTGENERIC_DEBUG_SETTINGS(argc, argv)                                                    \
        BTGENERIC_(BT_STATUS_CODE, DEBUG_SETTINGS)((int)(argc), (char **)(argv))
//extern void BtgExceptionDebugPrint (void);
#define BTGENERIC_EXCEPTION_DEBUG_PRINT()                                                       \
        BTGENERIC(EXCEPTION_DEBUG_PRINT)()
//extern void BtgNotifyExit (void);
#define BTGENERIC_NOTIFY_EXIT()                                                                  \
        BTGENERIC(NOTIFY_EXIT)()
//extern BT_THREAD_SUSPEND_STATE BtgCanonizeSuspendContext(BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA64_CONTEXT * ia64context, U64 prevSuspendCount);
#define BTGENERIC_CANONIZE_SUSPEND_CONTEXT(glstMemory, ia64context, prevSuspendCount)   \
        BTGENERIC_(BT_THREAD_SUSPEND_STATE,CANONIZE_SUSPEND_CONTEXT)((void *)(glstMemory), (BTGENERIC_IA64_CONTEXT *)(ia64context), (U64)prevSuspendCount)
//extern BT_THREAD_SUSPEND_STATE BtgCanonizeSuspendContextRemote(BT_HANDLE processHandle, BTGENERIC_LOCAL_STORAGE * glstMemory, BTGENERIC_IA64_CONTEXT * ia64context, U64 prevSuspendCount);
#define BTGENERIC_CANONIZE_SUSPEND_CONTEXT_REMOTE(processHandle, glstMemory, ia64context, prevSuspendCount)  \
        BTGENERIC_(BT_THREAD_SUSPEND_STATE,CANONIZE_SUSPEND_CONTEXT_REMOTE)((BT_HANDLE)(processHandle), (void *)(glstMemory), (BTGENERIC_IA64_CONTEXT *)(ia64context), (U64)prevSuspendCount)
//extern BT_THREAD_SUSPEND_STATE BtgCheckSuspendContext(BTGENERIC_LOCAL_STORAGE * glstMemory, const BTGENERIC_IA64_CONTEXT * ia64context);
#define BTGENERIC_CHECK_SUSPEND_CONTEXT(glstMemory, ia64context)   \
        BTGENERIC_(BT_THREAD_SUSPEND_STATE, CHECK_SUSPEND_CONTEXT)((void *)(glstMemory), (const BTGENERIC_IA64_CONTEXT *)(ia64context))
//extern void BtgNotifyPrepareExit (void);
#define BTGENERIC_NOTIFY_PREPARE_EXIT()                                                                  \
        BTGENERIC(NOTIFY_PREPARE_EXIT)()
//extern void BtgFreezeBtrans(void);
#define BTGENERIC_FREEZE()	\
		BTGENERIC(FREEZE)()
//extern void BtgUnfreezeBtrans(void);
#define BTGENERIC_UNFREEZE()	\
		BTGENERIC(UNFREEZE)()
//extern BT_STATUS_CODE BtgChangeThreadIdentity(void);
#define BTGENERIC_CHANGE_THREAD_IDENTITY() \
		BTGENERIC_(BT_STATUS_CODE, CHANGE_THREAD_IDENTITY)()
#endif

#ifdef OVERRIDE_TIA
//extern void BtgUseOverrideTIA(unsigned int OvrTiaSize, unsigned char * OvrTiaBuffer);
#define BTGENERIC_USE_OVERRIDE_TIA(OvrTiaSize, OvrTiaBuffer)                                                                  \
        BTGENERIC(USE_OVERRIDE_TIA)((unsigned int)(OvrTiaSize), (unsigned char *)(OvrTiaBuffer))
#endif // OVERRIDE_TIA
// BTLib's APIs

#if (BTGENERIC)

extern PLABEL_PTR_TYPE BtgPlaceholderTable[NO_OF_APIS];
#define BTLIB(APIName) (*(BtgPlaceholderTable[IDX_BTLIB_##APIName]))
#define BTLIB_(TYPE,APIName) (*(TYPE (*)())(BtgPlaceholderTable[IDX_BTLIB_##APIName]))

//extern U64 BtlGetThreadId(void);
#define BTLIB_GET_THREAD_ID()                                                                   \
        BTLIB_(U64,GET_THREAD_ID)()
//extern void BtlIA32Reenter(IN OUT BTGENERIC_IA32_CONTEXT * ia32context);
#define BTLIB_IA32_REENTER(ia32context)                                                         \
        BTLIB(IA32_REENTER)((BTGENERIC_IA32_CONTEXT *)(ia32context))
//extern void BtlIA32LCall (IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN U32 returnAddress, IN U32 targetAddress);
#define BTLIB_IA32_LCALL(ia32context, returnAddress, targetAddress)                                                           \
        BTLIB(IA32_LCALL)((BTGENERIC_IA32_CONTEXT *)(ia32context), (U32)(returnAddress), (U32)(targetAddress))
//extern void BtlIA32JmpIA64 (IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN U32 returnAddress, IN U32 targetAddress);
#define BTLIB_IA32_JMP_IA64(ia32context, returnAddress, targetAddress)                            \
        BTLIB(IA32_JMP_IA64)((BTGENERIC_IA32_CONTEXT *)(ia32context), (U32)(returnAddress), (U32)(targetAddress))
//extern void BtlIA32Interrupt(IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN BT_EXCEPTION_CODE exceptionCode, IN U32 returnAddress);
#define BTLIB_IA32_INTERRUPT(ia32context, exceptionCode, returnAddress)                                          \
        BTLIB(IA32_INTERRUPT)((BTGENERIC_IA32_CONTEXT *)(ia32context), (BT_EXCEPTION_CODE)(exceptionCode), (U32)(returnAddress))
//extern void BtlLockSignals(void);
#define BTLIB_LOCK_SIGNALS()                                                                    \
        BTLIB(LOCK_SIGNALS)()
//extern void BtlUnlockSignals(void);
#define BTLIB_UNLOCK_SIGNALS()                                                                  \
        BTLIB(UNLOCK_SIGNALS)()
//extern void * BtlMemoryAlloc(void * startAddress,U32 size, U64 prot);
#define BTLIB_MEMORY_ALLOC(startAddress,size,prot)                                              \
        BTLIB_(void *,MEMORY_ALLOC)((void *)(startAddress),(U32)(size), (U64)(prot))
//extern BT_STATUS_CODE BtlMemoryFree(void * startAddress,U32 size);
#define BTLIB_MEMORY_FREE(startAddress,size)                                                    \
        BTLIB_(BT_STATUS_CODE, MEMORY_FREE)((void *)(startAddress),(U32)(size))
//extern U32 BtlMemoryPageSize(void);
#define BTLIB_MEMORY_PAGE_SIZE()                                                                \
        BTLIB_(U32,MEMORY_PAGE_SIZE)()
//extern U64 BtlMemoryChangePermissions(void * startAddress, U32 size, U64 prot);
#define BTLIB_MEMORY_CHANGE_PERMISSIONS(startAddress, size, prot)                               \
        BTLIB_(U64,MEMORY_CHANGE_PERMISSIONS)((void *)(startAddress), (U32)(size), (U64)(prot))
//extern U64 BtlMemoryQueryPermissions(void * address, void ** pRegionStart, U32 * pRegionSize);
#define BTLIB_MEMORY_QUERY_PERMISSIONS(address, pRegionStart, pRegionSize)                                                 \
        BTLIB_(U64,MEMORY_QUERY_PERMISSIONS)((void *)(address), (void **)(pRegionStart), (U32 *)(pRegionSize))
//extern BT_STATUS_CODE BtlMemoryReadRemote(BT_HANDLE processHandle, void * baseAddress, void * buffer, U32 requestedSize);
#define BTLIB_MEMORY_READ_REMOTE(processHandle, baseAddress, buffer, requestedSize)                 \
        BTLIB_(BT_STATUS_CODE,MEMORY_READ_REMOTE)((BT_HANDLE)(processHandle), (void *)(baseAddress), (void *)buffer, (U32)(requestedSize))
//extern BT_STATUS_CODE BtlMemoryWriteRemote(BT_HANDLE processHandle, void * baseAddress, const void * buffer, U32 requestedSize);
#define BTLIB_MEMORY_WRITE_REMOTE(processHandle, baseAddress, buffer, requestedSize)                \
        BTLIB_(BT_STATUS_CODE,MEMORY_WRITE_REMOTE)((BT_HANDLE)(processHandle), (void *)(baseAddress), (const void *)buffer, (U32)(requestedSize))
//extern BT_STATUS_CODE BtlSuspendThread(U64 ThreadId, U32 TryCounter);
#define BTLIB_SUSPEND_THREAD(ThreadId, TryCounter)                                        \
        BTLIB_(BT_STATUS_CODE, SUSPEND_THREAD)((U64)(ThreadId), (U32)(TryCounter))
//extern BT_STATUS_CODE BtlResumeThread(U64 ThreadId);
#define BTLIB_RESUME_THREAD(ThreadId)                                                     \
        BTLIB_(BT_STATUS_CODE, RESUME_THREAD)((U64)(ThreadId))
//extern BT_STATUS_CODE BtlInitAccessLock(void * lock);
#define BTLIB_INIT_ACCESS_LOCK(lock)                                                            \
        BTLIB_(BT_STATUS_CODE,INIT_ACCESS_LOCK)((void *)(lock))
//extern BT_STATUS_CODE BtlLockAccess(void * lock, U64 flag);
#define BTLIB_LOCK_ACCESS(lock,flag)                                                            \
        BTLIB_(BT_STATUS_CODE,LOCK_ACCESS)((void *)(lock),(U64)(flag))
//extern void BtlUnlockAccess(void * lock);
#define BTLIB_UNLOCK_ACCESS(lock)                                                               \
        BTLIB(UNLOCK_ACCESS)((void *)(lock))
//extern void BtlInvalidateAccessLock(void * lock);
#define BTLIB_INVALIDATE_ACCESS_LOCK(lock)                                                      \
        BTLIB(INVALIDATE_ACCESS_LOCK)((void *)(lock))
//extern U32 BtlQueryJmpbufSize(void);
#define BTLIB_QUERY_JMPBUF_SIZE()                                                               \
        BTLIB_(U32,QUERY_JMPBUF_SIZE)()
////extern U32 BtlSetjmp(void * jmpbufAddress);
//#define BTLIB_SETJMP(jmpbufAddress) BTLIB_(U32,SETJMP)((void *)(jmpbufAddress))
////extern void BtlLongjmp(void * jmpbufAddress,U32 value);
//#define BTLIB_LONGJMP(jmpbufAddress, value) BTLIB(LONGJMP)((void *)(jmpbufAddress),(U32)(value))
//extern void BtlDebugPrint(U8 * buffer);
#define BTLIB_DEBUG_PRINT(buffer)                                                               \
        BTLIB(DEBUG_PRINT)((U8 *)(buffer))
//extern void BtlAbort(void);
#define BTLIB_ABORT()                                                                           \
        BTLIB(ABORT)()

//extern void BtlVtuneCodeCreated(VTUNE_BLOCK_TYPE *block);
#define BTLIB_VTUNE_CODE_CREATED(block)                                                         \
        BTLIB(VTUNE_CODE_CREATED)((VTUNE_BLOCK_TYPE *)(block))
//extern void BtlVtuneCodeDeleted(U64 block_start);
#define BTLIB_VTUNE_CODE_DELETED(blockStart)                                                    \
        BTLIB(VTUNE_CODE_DELETED)((U64)(blockStart))
//extern void BtlVtuneEnteringDynamicCode(void); 
#define BTLIB_VTUNE_ENTERING_DYNAMIC_CODE()                                                     \
        BTLIB(VTUNE_ENTERING_DYNAMIC_CODE)()
//extern void BtlVtuneExitingDynamicCode(void);  
#define BTLIB_VTUNE_EXITING_DYNAMIC_CODE()                                                      \
        BTLIB(VTUNE_EXITING_DYNAMIC_CODE)()
//extern void BtlVtuneCodeToTIADmpFile (U64 * em_code, U64 em_size);
#define BTLIB_VTUNE_CODE_TO_TIA_DMP_FILE(emCode, emSize)                                        \
        BTLIB(VTUNE_CODE_TO_TIA_DMP_FILE)((U64 *)(emCode),(U64)(emSize))

//extern U64 BtlSscPerfGetCounter64(U32 Handle);
#define BTLIB_SSCPERFGETCOUNTER64(Handle)                                                       \
        BTLIB_(U64,SSCPERFGETCOUNTER64)((U32)(Handle))
//extern U32 BtlSscPerfSetCounter64(U32 Handle, U64 Value);
#define BTLIB_SSCPERFSETCOUNTER64(Handle, Value)                                                \
        BTLIB_(U32,SSCPERFSETCOUNTER64)((U32)(Handle),(U64)(Value))
//extern U32 BtlSscPerfSendEvent(U32 Handle);
#define BTLIB_SSCPERFSENDEVENT(Handle)                                                          \
        BTLIB_(U32,SSCPERFSENDEVENT)((U32)(Handle))
//extern U64 BtlSscPerfEventHandle(U64 EventName);
#define BTLIB_SSCPERFEVENTHANDLE(EventName)                                                     \
        BTLIB_(U64,SSCPERFEVENTHANDLE)((U64)(EventName))
//extern U64 BtlSscPerfCounterHandle(U64 DataItemName);
#define BTLIB_SSCPERFCOUNTERHANDLE(DataItemName)                                                \
        BTLIB_(U64,SSCPERFCOUNTERHANDLE)((U64)(DataItemName))

//extern void BtlYieldThreadExecution(void);
#define BTLIB_YIELD_THREAD_EXECUTION()                                                          \
        BTLIB(YIELD_THREAD_EXECUTION)()
#define BTLIB_FLUSH_IA64_INSTRUCTION_CACHE(Address,Length)                                           \
        BTLIB(FLUSH_IA64_INSTRUCTION_CACHE)((U64)(Address),(U32)(Length))

#else // BTLib

#define BTLIB_GET_THREAD_ID                 BtlGetThreadId
#define BTLIB_IA32_REENTER                  BtlIA32Reenter
#define BTLIB_IA32_LCALL                    BtlIA32LCall
#define BTLIB_IA32_INTERRUPT                BtlIA32Interrupt
#define BTLIB_IA32_JMP_IA64                 BtlIA32JmpIA64
#define BTLIB_LOCK_SIGNALS                  BtlLockSignals
#define BTLIB_UNLOCK_SIGNALS                BtlUnlockSignals
#define BTLIB_MEMORY_ALLOC                  BtlMemoryAlloc
#define BTLIB_MEMORY_FREE                   BtlMemoryFree
#define BTLIB_MEMORY_PAGE_SIZE              BtlMemoryPageSize
#define BTLIB_MEMORY_CHANGE_PERMISSIONS     BtlMemoryChangePermissions
#define BTLIB_MEMORY_QUERY_PERMISSIONS      BtlMemoryQueryPermissions
#define BTLIB_MEMORY_READ_REMOTE            BtlMemoryReadRemote
#define BTLIB_MEMORY_WRITE_REMOTE           BtlMemoryWriteRemote
#define BTLIB_SUSPEND_THREAD                BtlSuspendThread
#define BTLIB_RESUME_THREAD                 BtlResumeThread
#define BTLIB_INIT_ACCESS_LOCK              BtlInitAccessLock
#define BTLIB_LOCK_ACCESS                   BtlLockAccess
#define BTLIB_UNLOCK_ACCESS                 BtlUnlockAccess
#define BTLIB_INVALIDATE_ACCESS_LOCK        BtlInvalidateAccessLock
#define BTLIB_QUERY_JMPBUF_SIZE             BtlQueryJmpbufSize
//#define BTLIB_SETJMP                      BtlSetjmp
//#define BTLIB_LONGJMP                     BtlLongjmp
#define BTLIB_DEBUG_PRINT                   BtlDebugPrint
#define BTLIB_ABORT                         BtlAbort

#define BTLIB_VTUNE_CODE_CREATED            BtlVtuneCodeCreated
#define BTLIB_VTUNE_CODE_DELETED            BtlVtuneCodeDeleted
#define BTLIB_VTUNE_ENTERING_DYNAMIC_CODE   BtlVtuneEnteringDynamicCode
#define BTLIB_VTUNE_EXITING_DYNAMIC_CODE    BtlVtuneExitingDynamicCode
#define BTLIB_VTUNE_CODE_TO_TIA_DMP_FILE    BtlVtuneCodeToTIADmpFile

#define BTLIB_SSCPERFGETCOUNTER64           BtlSscPerfGetCounter64
#define BTLIB_SSCPERFSETCOUNTER64           BtlSscPerfSetCounter64
#define BTLIB_SSCPERFSENDEVENT              BtlSscPerfSendEvent
#define BTLIB_SSCPERFEVENTHANDLE            BtlSscPerfEventHandle
#define BTLIB_SSCPERFCOUNTERHANDLE          BtlSscPerfCounterHandle

#define BTLIB_YIELD_THREAD_EXECUTION        BtlYieldThreadExecution

#define BTLIB_FLUSH_INSTRUCTION_CACHE       BtlFlushIA64InstructionCache

extern U64 BtlGetThreadId(void);
extern void BtlIA32Reenter  (IN OUT BTGENERIC_IA32_CONTEXT * ia32context);
extern void BtlIA32JmpIA64  (IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN U32 returnAddress, IN U32 targetAddress);
extern void BtlIA32LCall    (IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN U32 returnAddress, IN U32 targetAddress);
extern void BtlIA32Interrupt(IN OUT BTGENERIC_IA32_CONTEXT * ia32context, IN BT_EXCEPTION_CODE exceptionCode, IN U32 returnAddress);
extern void BtlLockSignals(void);
extern void BtlUnlockSignals(void);
extern void * BtlMemoryAlloc(IN void * startAddress, IN U32 size, IN U64 prot);
extern BT_STATUS_CODE BtlMemoryFree(IN void * startAddress, IN U32 size);
extern U32 BtlMemoryPageSize(void);
extern U64 BtlMemoryChangePermissions(IN void * start_address, IN U32 size, IN U64 prot);
extern U64 BtlMemoryQueryPermissions(IN void * address, OUT void ** pRegionStart, OUT U32 * pRegionSize);
extern BT_STATUS_CODE BtlMemoryReadRemote(IN BT_HANDLE processHandle, IN void * baseAddress, OUT void * buffer, IN U32 requestedSize);
extern BT_STATUS_CODE BtlMemoryWriteRemote(IN BT_HANDLE processHandle, OUT void * baseAddress, IN const void * buffer, IN U32 requestedSize);
extern BT_STATUS_CODE BtlSuspendThread(IN U64 ThreadId, IN U32 TryCounter);
extern BT_STATUS_CODE BtlResumeThread(IN U64 ThreadId);
extern BT_STATUS_CODE BtlInitAccessLock(OUT void * lock);
extern BT_STATUS_CODE BtlLockAccess(IN OUT void * lock, IN U64 flag);
extern void BtlUnlockAccess(IN OUT void * lock);
extern void BtlInvalidateAccessLock(IN OUT void * lock);
extern U32 BtlQueryJmpbufSize(void);
//extern U32 BtlSetjmp(IN OUT void * jmpbufAddress);
//extern void BtlLongjmp(IN OUT void * jmpbufAddress,U32 value);
extern void BtlDebugPrint(IN U8 * buffer);
extern void BtlAbort(void);

extern void BtlVtuneCodeCreated(IN VTUNE_BLOCK_TYPE *block);
extern void BtlVtuneCodeDeleted(IN U64 blockStart);
extern void BtlVtuneEnteringDynamicCode(void); 
extern void BtlVtuneExitingDynamicCode(void);  
extern void BtlVtuneCodeToTIADmpFile (IN U64 * emCode, IN U64 emSize);

extern U64 BtlSscPerfGetCounter64(IN U32 Handle);
extern U32 BtlSscPerfSetCounter64(IN U32 Handle, IN U64 Value);
extern U32 BtlSscPerfSendEvent(IN U32 Handle);
extern U64 BtlSscPerfEventHandle(IN U64 EventName);
extern U64 BtlSscPerfCounterHandle(IN U64 DataItemName);

extern void BtlYieldThreadExecution(void);

extern void BtlFlushIA64InstructionCache(IN void * Address, IN U32 Length);

#endif

#ifdef __cplusplus
}
#endif

#endif // BTGENERIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\amd64\inc\amd64cpu.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    amd64cpu.h

Abstract:

    This module contains the AMD64 platfrom specific cpu information.

Author:

    Samer Arafeh (samera) 12-Dec-2001

--*/

#ifndef _AMD64CPU_INCLUDE
#define _AMD64CPU_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

//
// 32-bit Cpu context.
//


//
//  Indicate that the XMMI registers needs to be reloaded by the tranision code
//

#define TRAP_FRAME_RESTORE_VOLATILE  0x00000001

#pragma pack(push, 4)

typedef struct _CpuContext {
    
    //
    // Make the extended registers field aligned.
    //

    DWORD Reserved;


    //
    // X86 trap frame when jumping to amd64
    //

    CONTEXT32   Context;

    //
    // Trap flags
    //

    ULONG TrapFrameFlags;

    
} CPUCONTEXT, *PCPUCONTEXT;

#pragma pack(pop)


//
// CPU-internal shared functions. They are also used by the debugger extension.
//

NTSTATUS
GetContextRecord (
    IN PCPUCONTEXT cpu,
    IN PCONTEXT Amd64Context,
    IN OUT PCONTEXT32 Context
    );

NTSTATUS
SetContextRecord(
    IN OUT PCPUCONTEXT cpu,
    IN OUT PCONTEXT ContextAmd64,
    IN PCONTEXT32 Context,
    IN OUT PBOOLEAN UpdateNativeContext
    );

NTSTATUS
CpupGetContextThread (
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context
    );

NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context
    );

//
// Context conversion routines
//

VOID Wow64CtxFromAmd64(
    IN ULONG X86ContextFlags,
    IN PCONTEXT ContextAmd64,
    IN OUT PCONTEXT32 ContextX86);

VOID Wow64CtxToAmd64(
    IN ULONG X86ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextAmd64);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\bintrans\wowia32x\btlib.c ===
/*++

    INTEL CORPORATION PROPRIETARY INFORMATION

    This software is supplied under the terms of a license
    agreement or nondisclosure agreement with Intel Corporation
    and may not be copied or disclosed except in accordance with
    the terms of that agreement.

    Copyright (c) 1991-2002 INTEL CORPORATION

Module Name:

    btlib.c

Abstract:

    The OS dependent part of IA-32 Execution Layer for Windows.
    It is a Windows operating-system-specific component of the dynamic binary translator.
    Its responsibility is to locate and load OS-independent component
    (IA32Exec.bin), to forward Wow64 calls to the OS-independent part
    and to supply OS-dependent services to it when necessary.
    Part of the services in this module are not used for windows,
    and part of them are needed for debugging and/or performance tuning only.
--*/

#define _WOW64BTAPI_

#ifndef NODEBUG
#define OVERRIDE_TIA 1
#endif

#include "btlib.h"

#ifndef IA32EX_G_NAME
#define IA32EX_G_NAME   L"IA32Exec"
#endif

#ifndef IA32EX_G_SUFFIX
#define IA32EX_G_SUFFIX L"bin"
#endif

#define WOW64BT_IMPL  __declspec(dllexport)

extern VOID Wow64LogPrint(UCHAR LogLevel, char *format, ...);
#define LF_TRACE 2
#define LF_ERROR 1

/*
 * File location enumerator
 */
#define F_NOT_FOUND    0
#define F_CURRENT_DIR  1
#define F_BTLIB        2
#define F_HKLM         3
#define F_HKCU         4


/*
 * Initial memory allocation addresses for code and data
 */

#define INITIAL_CODE_ADDRESS    ((void *)0x44000000)
#define INITIAL_DATA_ADDRESS    ((void *)0x40000000)


ASSERTNAME;

// Persistent variables

U32 BtlpInfoOffset;                 // Offset of the wowIA32X.dll-specific info in Wow64Cpu TLS
U32 BtlpGenericIA32ContextOffset;   // Offset of the IA32 context in IA32Exec.bin's TLS

PLABEL_PTR_TYPE BtlpPlaceHolderTable[NO_OF_APIS];
WCHAR           ImageName[128], LogDirName[128];

// Interface for debug printing

HANDLE BtlpWow64LogFile = INVALID_HANDLE_VALUE;
DWORD BtlpLogOffset = 0;
#ifndef NODEBUG
WCHAR  BtlpLogFileFullPath[1024];
BOOL   BtlpLogFilePerThread = FALSE;
#endif

// Temporary workaround for IA32 debugging support. 
//To be removed after fixing FlushIC(ProcessHandle).
BOOL BeingDebugged; //copy of the PEB->BeingDebugged; can be overriden by the
                    //debug_btrans switch

//Critical section interface
#define  BtlpInitializeCriticalSection(pCS) RtlInitializeCriticalSection (pCS)
#define  BtlpDeleteCriticalSection(pCS) RtlDeleteCriticalSection (pCS)
__inline void BtlpEnterCriticalSection(PRTL_CRITICAL_SECTION pCS)
{
    BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
    RtlEnterCriticalSection(pCS);
}
__inline void BtlpLeaveCriticalSection(PRTL_CRITICAL_SECTION pCS)
{
    RtlLeaveCriticalSection(pCS);
    BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();
}

//Report failure in NT service
//    msg     - error message text
//    status  - error status
#define BTLP_REPORT_NT_FAILURE(msg, status) \
    DBCODE((status != STATUS_SUCCESS), BtlpPrintf("\n%s : NT FAILURE STATUS = 0x%X\n" , msg, status))

VOID BtlDebugPrint (
    U8 * buffer
    )
/*++

Routine Description:

    Debug print of the buffer.
    The text is printed into the debugging log file,
    or through Wow64 debugging facility, if the file is not available

Arguments:

    buffer       - IN Text to be printed

Return Value:

    None.

--*/
{
    extern U64 BtAtomicInc(U64 * pCounter);
    extern U64 BtAtomicDec(U64 * pCounter);

    HANDLE hTarget = INVALID_HANDLE_VALUE;
    static U64 InLogging = 0; //counter of concurrent entrances to the function

    if (BtAtomicInc(&InLogging)) {
        //Some thread is printing at this moment. Exit if BTLIB_BLOCKED_LOG_DISABLED
        if (BTL_THREAD_INITIALIZED() && BTLIB_BLOCKED_LOG_DISABLED()) {
            return;
        }
    }

#ifndef NODEBUG
    if ( BtlpLogFilePerThread ) {
        if (BTL_THREAD_INITIALIZED()) {
            hTarget = BTLIB_LOG_FILE();
        }
    }
    else 
#endif
    {
        hTarget = BtlpWow64LogFile;
    }
    
    if ( hTarget != INVALID_HANDLE_VALUE ) {
        NTSTATUS          ret;
        IO_STATUS_BLOCK   IoStatusBlock;
        size_t            size;
        LARGE_INTEGER offset;

        //Disable suspension during blocked (synchronized) file access
        BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
        Wow64LogPrint(LF_TRACE, "%s", buffer);
        BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();
        size = strlen(buffer);
        offset.HighPart = 0;

#ifndef NODEBUG
        if ( BtlpLogFilePerThread ) {
            offset.LowPart = BTLIB_INFO_PTR()->LogOffset;
            BTLIB_INFO_PTR()->LogOffset += size;
        } else 
#endif
        {
        //Following two lines should be replaced with atomic operation:
        //offset.LowPart = InterlockedExchangeAdd(&BtlpLogOffset, size);
        offset.LowPart = BtlpLogOffset;
        BtlpLogOffset += size;
        }
        //Disable suspension during blocked (synchronized) file access
        BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
        ret = NtWriteFile(hTarget, NULL, NULL, NULL, &IoStatusBlock,
                          (void *)buffer, (ULONG)size, &offset, NULL);
        BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();
    } else {
        //Disable suspension during blocked (synchronized) file access
        BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
        Wow64LogPrint(LF_ERROR, "%s", buffer);
        BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();
    }
    BtAtomicDec(&InLogging);
}

int BtlpPrintf (
    IN char * Format,
    ...
    )
/*++

Routine Description:

    Helper function for format printing.

Arguments:

    Format       - IN Format string to be printed
    ...          - IN parameter(s) according to the format string

Return Value:

    Just like in vsprintf.

--*/

{
#define MAX_DEBUG_PRINT_BUF_SZ  4096
    extern U64 DisableFPInterrupt();
    extern void RestoreFPInterrupt(U64 prev_fpsr);
    U64 prev_fpsr;
    va_list ParmList;
    int     res;
    char    PrintBuffer[MAX_DEBUG_PRINT_BUF_SZ];

    prev_fpsr = DisableFPInterrupt();
    va_start(ParmList, Format);
    res = vsprintf(PrintBuffer, Format, ParmList);
    BtlDebugPrint (PrintBuffer);
    RestoreFPInterrupt(prev_fpsr);
    return res;
}

VOID __cdecl _assert (
    VOID *expr,
    VOID *file_name,
    unsigned line_no
    )
/*++

Routine Description:

    Helper assert function (in order to print assert message our way)

Arguments:

    expr      - IN failing expression string
    file_name - IN name of the source file
    line_no   - IN number of the source line

Return Value:

    None.

--*/
{
    BtlpPrintf ("wowIA32X.dll: Assertion failed %s/%d: %s\n", (const char *)file_name, line_no, (char *)expr);
    BTLIB_ABORT ();
}

VOID BtlAbort(
    VOID
    )
/*++

Routine Description:

    Abort function (in order to avoid using run-time library in WINNT)

Arguments:

    None.

Return Value:

    None.

--*/
{

    BtlpPrintf ("Execution aborted, TEB=%p\n", BT_CURRENT_TEB());
    // Cause failure
    ((VOID (*)()) 0) ();
}

VOID BtlInitializeTables(
    IN API_TABLE_TYPE * BTGenericTable
    )
/*++

Routine Description:

    Initialize placeholder table with plabels of IA32Exec.bin functions

Arguments:

    BTGenericTable  - IN pointer to IA32Exec.bin API table.

Return Value:

    None.

--*/
{
    unsigned int i;
    
    // initialize wowIA32X.dll placeholder table
    for(i=0; i < BTGenericTable->NoOfAPIs; i++) {
        BtlPlaceHolderTable[i] = BTGenericTable->APITable[i].PLabelPtr;
    }

}


// VTUNE support

HANDLE        BtlpVtuneTIADmpFileHandle = INVALID_HANDLE_VALUE;
LARGE_INTEGER BtlpVtuneOffset = { 0, 0 };

static VOID BtlpVtuneOpenTIADmpFile (
    VOID
    )
/*++

Routine Description:

    Open file fot VTUNE analysis

Arguments:

    None.

Return Value:

    None.

--*/
{
    int                   i;
    UNICODE_STRING        tiaFileName;
    LARGE_INTEGER         AllocSz = { 0, 0 };
    OBJECT_ATTRIBUTES     ObjectAttributes;
    NTSTATUS              ret;
    WCHAR                 CurDirBuf[512];
    WCHAR                 CurrentDir[1024];
    IO_STATUS_BLOCK       IoStatusBlock;

    
    //swprintf(CurDirBuf, L"\\DosDevices\\%s\\tia.dmp", CurrentDir);
    

    if (0==LogDirName[0] && 0==LogDirName[1]) {
        RtlGetCurrentDirectory_U(512, CurrentDir);
        swprintf(CurDirBuf, L"\\DosDevices\\%s\\%s.tia.dmp", CurrentDir, ImageName);
    }
    else {
        swprintf(CurDirBuf, L"\\DosDevices\\%s\\%s.tia.dmp", LogDirName, ImageName);
    }
    RtlInitUnicodeString(&tiaFileName, CurDirBuf);

    InitializeObjectAttributes(&ObjectAttributes, &tiaFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ret = NtCreateFile (&BtlpVtuneTIADmpFileHandle, 
                        FILE_GENERIC_WRITE,
                        &ObjectAttributes, 
                        &IoStatusBlock, 
                        &AllocSz, 
                        FILE_ATTRIBUTE_NORMAL, 
                        0, 
                        FILE_SUPERSEDE,
                        FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL, 0);
                       
    if ( ret != STATUS_SUCCESS ) {
        BtlpPrintf("Save: NtCreateFile() failed: status = 0x%X\n", ret);
        return;
    }
}



static VOID BtlpVtuneWriteU64 (
    IN U64 value
    )
/*++

Routine Description:

    Write 64 bit unsigned value into VTUNE file

Arguments:

    value   - IN 64bit unsigned value to be send to VTUNE file.

Return Value:

    None.

--*/
{
    char space = ' ';
    NTSTATUS ret;
    IO_STATUS_BLOCK IoStatusBlock;

    if (BtlpVtuneTIADmpFileHandle == INVALID_HANDLE_VALUE) {
        BtlpVtuneOpenTIADmpFile ();
    }
    //Disable suspension during blocked (synchronized) file access
    BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
    ret = NtWriteFile ( BtlpVtuneTIADmpFileHandle, 
                        NULL, 
                        NULL, 
                        NULL, 
                        &IoStatusBlock, 
                        (VOID *) &value, 
                        sizeof(U64), 
                        &BtlpVtuneOffset, 
                        NULL);
    BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();

    if ( ret != STATUS_SUCCESS ) {
        BtlpPrintf("-1. NtWriteFile() failed: status = 0x%X\n", ret);
    }
    BtlpVtuneOffset.LowPart += sizeof(U64);

    //Disable suspension during blocked (synchronized) file access
    BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
    ret = NtWriteFile ( BtlpVtuneTIADmpFileHandle, 
                        NULL, 
                        NULL, 
                        NULL, 
                        &IoStatusBlock, 
                        (VOID *) &space, 
                        sizeof(space), 
                        &BtlpVtuneOffset, 
                        NULL);
    BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();

    if ( ret != STATUS_SUCCESS ) {
        BtlpPrintf("-1. NtWriteFile() failed: status = 0x%X\n", ret);
    }
    BtlpVtuneOffset.LowPart += sizeof(char);
}

static VOID BtlpVtuneWriteU32 (
    IN U32 value
    )
/*++

Routine Description:

    Write 64 bit unsigned value into VTUNE file

Arguments:

    value   - IN 32bit unsigned value to be send to VTUNE file.

Return Value:

    None.

--*/
{
    U64 valueToWrite;
    char space = ' ';
    NTSTATUS ret;
    IO_STATUS_BLOCK IoStatusBlock;

    if (BtlpVtuneTIADmpFileHandle == INVALID_HANDLE_VALUE) {
        BtlpVtuneOpenTIADmpFile ();
    }
    valueToWrite = value;
    //Disable suspension during blocked (synchronized) file access
    BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
    ret = NtWriteFile ( BtlpVtuneTIADmpFileHandle, 
                        NULL, 
                        NULL, 
                        NULL, 
                        &IoStatusBlock, 
                        (VOID *) &valueToWrite, 
                        sizeof(U64), 
                        &BtlpVtuneOffset, 
                        NULL);
    BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();

    if ( ret != STATUS_SUCCESS ) {
        BtlpPrintf("-1. NtWriteFile() failed: status = 0x%X\n", ret);
    }
    BtlpVtuneOffset.LowPart += sizeof(U64);

    //Disable suspension during blocked (synchronized) file access
    BTL_THREAD_INITIALIZED() && BTLIB_DISABLE_SUSPENSION();
    ret = NtWriteFile ( BtlpVtuneTIADmpFileHandle, 
                        NULL, 
                        NULL, 
                        NULL, 
                        &IoStatusBlock, 
                        (VOID *) &space, 
                        sizeof(space), 
                        &BtlpVtuneOffset, 
                        NULL);
    BTL_THREAD_INITIALIZED() && BTLIB_ENABLE_SUSPENSION();

    if ( ret != STATUS_SUCCESS ) {
        BtlpPrintf("-1. NtWriteFile() failed: status = 0x%X\n", ret);
    }
    BtlpVtuneOffset.LowPart += sizeof(char);
}

VOID BtlVtuneCodeToTIADmpFile (
    IN U64 * emCode,
    IN U64 emSize
    )
/*++

Routine Description:

    Report translated code block to VTUNE file

Arguments:

    emCode  - IN code start pointer
    emSize  - IN code size in bytes

Return Value:

    None.

--*/
{
#if 0
    U64 bundle;

    assert ((emSize % (2*sizeof (U64))) == 0);
    emSize /= (2*sizeof (U64));

    BtlpVtuneWriteU64 (emSize);

    for (; emSize; --emSize) {
        bundle = *emCode++;
        BtlpVtuneWriteU64 (bundle);
        bundle = *emCode++;
        BtlpVtuneWriteU64 (bundle);
    }
#endif
}

VOID BtlVtuneEnteringDynamicCode(
    VOID
    )
/*++

Routine Description:

    Notify VTUNE about entering dynamically generated code (no action for NT)

Arguments:

    None.

Return Value:

    None.

--*/
{
} 

VOID BtlVtuneExitingDynamicCode(
    VOID
    )
/*++

Routine Description:

    Notify VTUNE about leaving dynamically generated code (no action for NT)

Arguments:

    None.

Return Value:

    None.

--*/
{
}

VOID BtlVtuneCodeDeleted(
    IN U64 blockStart
    )
/*++

Routine Description:

    Notify VTUNE about removal of dynamically generated code (no action for NT)

Arguments:

    blockStart  - IN start of the block.

Return Value:

    None.

--*/
{
}

VOID BtlVtuneCodeCreated(
    IN VTUNE_BLOCK_TYPE *block
    )
/*++

Routine Description:

    Notify VTUNE about generation of a code block

Arguments:

    block   - IN VTUNE block descriptor.

Return Value:

    None.

--*/
{
    // keep this order of fields, it's expected on the reader side to be in that order
    BtlpVtuneWriteU32(VTUNE_CALL_ID_CREATED);
    BtlpVtuneWriteU64(block->name);
    BtlpVtuneWriteU32(block->type);  
    BtlpVtuneWriteU64(block->start);
    BtlpVtuneWriteU64(block->size);
    BtlpVtuneWriteU32(block->IA32start);
    BtlpVtuneWriteU64(block->traversal);
    BtlpVtuneWriteU64(block->reserved);
}

// SSC Client support - absent in NT

U64 BtlSscPerfGetCounter64(
    IN U32 Handle
    )
/*++

Routine Description:

    Get SSE client performance counter (Unavailable in NT)

Arguments:

    Handle  - IN SSE client handle

Return Value:

    Counter value.

--*/
{
    return STATUS_SUCCESS;
}

U32 BtlSscPerfSetCounter64(
    IN U32 Handle,
    IN U64 Value
    )
/*++

Routine Description:

    Set SSE client performance counter (Unavailable in NT)

Arguments:

    Handle  - IN SSE client handle
    Value   - IN new counter value

Return Value:

    Status.

--*/
{
    return STATUS_SUCCESS;
}

U32 BtlSscPerfSendEvent(
    IN U32 Handle
    )
/*++

Routine Description:

    Send event to SSE client (Unavailable in NT)

Arguments:

    Handle  - IN SSE client handle

Return Value:

    Status.

--*/
{
    return STATUS_SUCCESS;
}

U64 BtlSscPerfEventHandle(
    IN U64 EventName
    )
/*++

Routine Description:

    Receive event handle from SSE client (Unavailable in NT)

Arguments:

    EventName  - IN handle identification

Return Value:

    SSE client handle.

--*/
{
    return STATUS_SUCCESS;
}

U64 BtlSscPerfCounterHandle(
    IN U64 DataItemName
    )
/*++

Routine Description:

    Receive counter handle from SSE client (Unavailable in NT)

Arguments:

    DataItemName  - IN handle identification

Return Value:

    SSE client handle.

--*/
{
    return STATUS_SUCCESS;
}


// wowIA32X.dll/IA32Exec.bin support

static NTSTATUS BtlpBt2NtExceptCode (
    IN BT_EXCEPTION_CODE BtExceptCode
    )
/*++

Routine Description:

    Convert given BT exception code to NT-specific exception code.

Arguments:

    BtExceptCode     - BT exception code 

Return Value:

    NTSTATUS representing converted BT exception code.

--*/
{
    NTSTATUS ret;
    switch (BtExceptCode) {
        case BT_EXCEPT_ILLEGAL_INSTRUCTION:
            ret = EXCEPTION_ILLEGAL_INSTRUCTION;
            break;
        case BT_EXCEPT_ACCESS_VIOLATION:
            ret = EXCEPTION_ACCESS_VIOLATION;
            break;
        case BT_EXCEPT_DATATYPE_MISALIGNMENT:
            ret = EXCEPTION_DATATYPE_MISALIGNMENT;
            break;
        case BT_EXCEPT_ARRAY_BOUNDS_EXCEEDED:
            ret = EXCEPTION_ARRAY_BOUNDS_EXCEEDED;
            break;
        case BT_EXCEPT_FLT_DENORMAL_OPERAND:
            ret = EXCEPTION_FLT_DENORMAL_OPERAND;
            break;
        case BT_EXCEPT_FLT_DIVIDE_BY_ZERO:
            ret = EXCEPTION_FLT_DIVIDE_BY_ZERO;
            break;
        case BT_EXCEPT_FLT_INEXACT_RESULT:
            ret = EXCEPTION_FLT_INEXACT_RESULT;
            break;
        case BT_EXCEPT_FLT_INVALID_OPERATION:
            ret = EXCEPTION_FLT_INVALID_OPERATION;
            break;
        case BT_EXCEPT_FLT_OVERFLOW:
            ret = EXCEPTION_FLT_OVERFLOW;
            break;
        case BT_EXCEPT_FLT_UNDERFLOW:
            ret = EXCEPTION_FLT_UNDERFLOW;
            break;
        case BT_EXCEPT_FLT_STACK_CHECK:
            ret = EXCEPTION_FLT_STACK_CHECK;
            break;
        case BT_EXCEPT_INT_DIVIDE_BY_ZERO:
            ret = EXCEPTION_INT_DIVIDE_BY_ZERO;
            break;
        case BT_EXCEPT_INT_OVERFLOW:
            ret = EXCEPTION_INT_OVERFLOW;
            break;
        case BT_EXCEPT_PRIV_INSTRUCTION:
            ret = EXCEPTION_PRIV_INSTRUCTION;
            break;
        case BT_EXCEPT_FLOAT_MULTIPLE_FAULTS:
            ret = STATUS_FLOAT_MULTIPLE_FAULTS;
            break;
        case BT_EXCEPT_FLOAT_MULTIPLE_TRAPS:
            ret = STATUS_FLOAT_MULTIPLE_TRAPS;
            break;
        case BT_EXCEPT_STACK_OVERFLOW:
            ret = STATUS_STACK_OVERFLOW;
            break;
        case BT_EXCEPT_GUARD_PAGE:
            ret = STATUS_GUARD_PAGE_VIOLATION;
            break;
        case BT_EXCEPT_BREAKPOINT:
            ret = STATUS_WX86_BREAKPOINT;
            break;
        case BT_EXCEPT_SINGLE_STEP:
            ret = STATUS_WX86_SINGLE_STEP;
            break;
        default:
            DBCODE(TRUE, BtlpPrintf ("\nConverting unknown BT exception 0x%X to EXCEPTION_ACCESS_VIOLATION", BtExceptCode));
            ret = EXCEPTION_ACCESS_VIOLATION;
    }
    return ret;
}

static BT_EXCEPTION_CODE BtlpNt2BtExceptCode (
    IN NTSTATUS NtExceptCode
    )
/*++

Routine Description:

    Convert given NT-specific exception code to BT-generic exception code.

Arguments:

    NtExceptCode     - NT exception code 

Return Value:

    BT_EXCEPTION_CODE representing converted NT exception code.

--*/
{
    BT_EXCEPTION_CODE ret;
    switch (NtExceptCode) {
        case EXCEPTION_ILLEGAL_INSTRUCTION:
            ret = BT_EXCEPT_ILLEGAL_INSTRUCTION;
            break;
        case EXCEPTION_ACCESS_VIOLATION:
            ret = BT_EXCEPT_ACCESS_VIOLATION;
            break;
        case EXCEPTION_DATATYPE_MISALIGNMENT:
            ret = BT_EXCEPT_DATATYPE_MISALIGNMENT;
            break;
        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
            ret = BT_EXCEPT_ARRAY_BOUNDS_EXCEEDED;
            break;
        case EXCEPTION_FLT_DENORMAL_OPERAND:
            ret = BT_EXCEPT_FLT_DENORMAL_OPERAND;
            break;
        case EXCEPTION_FLT_DIVIDE_BY_ZERO:
            ret = BT_EXCEPT_FLT_DIVIDE_BY_ZERO;
            break;
        case EXCEPTION_FLT_INEXACT_RESULT:
            ret = BT_EXCEPT_FLT_INEXACT_RESULT;
            break;
        case EXCEPTION_FLT_INVALID_OPERATION:
            ret = BT_EXCEPT_FLT_INVALID_OPERATION;
            break;
        case EXCEPTION_FLT_OVERFLOW:
            ret = BT_EXCEPT_FLT_OVERFLOW;
            break;
        case EXCEPTION_FLT_UNDERFLOW:
            ret = BT_EXCEPT_FLT_UNDERFLOW;
            break;
        case EXCEPTION_FLT_STACK_CHECK:
            ret = BT_EXCEPT_FLT_STACK_CHECK;
            break;
        case EXCEPTION_INT_DIVIDE_BY_ZERO:
            ret = BT_EXCEPT_INT_DIVIDE_BY_ZERO;
            break;
        case EXCEPTION_INT_OVERFLOW:
            ret = BT_EXCEPT_INT_OVERFLOW;
            break;
        case EXCEPTION_PRIV_INSTRUCTION:
            ret = BT_EXCEPT_PRIV_INSTRUCTION;
            break;
        case STATUS_FLOAT_MULTIPLE_FAULTS:
            ret = BT_EXCEPT_FLOAT_MULTIPLE_FAULTS;
            break;
        case STATUS_FLOAT_MULTIPLE_TRAPS:
            ret = BT_EXCEPT_FLOAT_MULTIPLE_TRAPS;
            break;
        case STATUS_STACK_OVERFLOW:
            ret = BT_EXCEPT_STACK_OVERFLOW;
            break;
        case STATUS_GUARD_PAGE_VIOLATION:
            ret = BT_EXCEPT_GUARD_PAGE;
            break;
        case EXCEPTION_BREAKPOINT:
        case STATUS_WX86_BREAKPOINT:
            ret = BT_EXCEPT_BREAKPOINT;
            break;
        case EXCEPTION_SINGLE_STEP:
        case STATUS_WX86_SINGLE_STEP:
            ret = BT_EXCEPT_SINGLE_STEP;
            break;
        default:
            DBCODE(TRUE, BtlpPrintf ("\nConverting unknown NT exception 0x%X to BT_EXCEPT_UNKNOWN", NtExceptCode));
            ret = BT_EXCEPT_UNKNOWN;
    }
    return ret;
}

static void BtlpNt2BtExceptRecord (
    IN const EXCEPTION_RECORD * NtExceptRecordP,
    OUT BT_EXCEPTION_RECORD * BtExceptRecordP
    )
/*++

Routine Description:

    Convert given NT-specific exception record to BT-generic exception record.
    The NT exception record should represent a real 64-bit exception (fault or trap)
Arguments:

    NtExceptRecordP     - Pointer to NT exception record to be converted
    BtExceptRecordP     - Pointer to BT exception record to be constructed

Return Value:

    None.

--*/
{
    BtExceptRecordP->ExceptionCode = BtlpNt2BtExceptCode(NtExceptRecordP->ExceptionCode);
    if (NtExceptRecordP->NumberParameters >= 5) {
        BtExceptRecordP->Ia64IIPA = NtExceptRecordP->ExceptionInformation[3];
        BtExceptRecordP->Ia64ISR = NtExceptRecordP->ExceptionInformation[4];
    }
    else {
        BtExceptRecordP->Ia64IIPA = 0;
        BtExceptRecordP->Ia64ISR = UNKNOWN_ISR_VALUE;
    }
}

static NTSTATUS BtlpBt2NtStatusCode (
    IN BT_STATUS_CODE BtStatus
    )
/*++

Routine Description:

    Convert given BT staus code to NT-specific status code.

Arguments:

    BtStatus         - BT status code 

Return Value:

    NTSTATUS representing converted BT status code.

--*/
{
    NTSTATUS ret;
    switch (BtStatus) {
        case BT_STATUS_SUCCESS:
            ret = STATUS_SUCCESS;
            break;
        case BT_STATUS_UNSUCCESSFUL:
            ret = STATUS_UNSUCCESSFUL;
            break;
        case BT_STATUS_NO_MEMORY:
            ret = STATUS_NO_MEMORY;
            break;
        case BT_STATUS_ACCESS_VIOLATION:
            ret = STATUS_ACCESS_VIOLATION;
            break;
        default:
            DBCODE(TRUE, BtlpPrintf ("\nConverting unknown status 0x%X to STATUS_UNSUCCESSFUL", BtStatus));
            ret = STATUS_UNSUCCESSFUL;
    }
    return ret;
}

static BT_FLUSH_REASON BtlpWow2BtFlushReason (
    IN WOW64_FLUSH_REASON Wow64FlushReason
    )
/*++

Routine Description:

    Convert given WOW64_FLUSH_REASON code to BT-generic code.

Arguments:

    Wow64FlushReason     - WOW64_FLUSH_REASON code

Return Value:

    BT_FLUSH_REASON code representing converted WOW64_FLUSH_REASON code.

--*/
{
    BT_FLUSH_REASON ret;
    switch (Wow64FlushReason) {
        case WOW64_FLUSH_FORCE:
            ret = BT_FLUSH_FORCE;
            break;
        case WOW64_FLUSH_FREE:
            ret = BT_FLUSH_FREE;
            break;
        case WOW64_FLUSH_ALLOC:
            ret = BT_FLUSH_ALLOC;
            break;
        case WOW64_FLUSH_PROTECT:
            ret = BT_FLUSH_PROTECT;
            break;
        default:
            //BtlpPrintf ("\nConverting unknown WOW64_FLUSH_REASON %d to BT_FLUSH_PROTECT", Wow64FlushReason);
            ret = BT_FLUSH_PROTECT;
    }
    return ret;
}

static SIZE_T BtlpGetMemAllocSize(
    IN  PVOID AllocationBase,
    OUT BOOL * pIsCommited
    )
/*++

Routine Description:

    Calculate size of a region allocated by the NtAllocateVirtualMemory function.

Arguments:

    AllocationBase     - Allocation base address
    pIsCommited        - Pointer to returned boolean flag that indicates is there exist 
                         a commited page in the allocated region
Return Value:

    Size of the allocated region starting from the given base address.

--*/
{
    NTSTATUS status;
    MEMORY_BASIC_INFORMATION memInfo;
    SIZE_T dwRetSize;
    PVOID BaseAddress = AllocationBase;
    *pIsCommited = FALSE;
    //Iterate through all regions with the same allocation base address
    for (;;) {
        status = NtQueryVirtualMemory(NtCurrentProcess(),
                                      BaseAddress,
                                      MemoryBasicInformation,
                                      &memInfo,
                                      sizeof (memInfo),
                                      &dwRetSize);

        if ((status != STATUS_SUCCESS)  || 
            (memInfo.State == MEM_FREE) || 
            (AllocationBase != memInfo.AllocationBase)) {
            break;
        }
        assert(memInfo.RegionSize != 0);
        BaseAddress = (PVOID)((UINT_PTR)(memInfo.BaseAddress) + memInfo.RegionSize);
        *pIsCommited |= (memInfo.State == MEM_COMMIT);
    }
    return ((UINT_PTR)BaseAddress - (UINT_PTR)AllocationBase);
}

// Registry access section

static BOOL BtlpRetrieveHKCUValue (
    IN PWCHAR RegistryEntryName,
    OUT PWCHAR RegistryValueBuf
    )
/*++

Routine Description:

    Retrieve a registry value from HKCU

Arguments:

    RegistryEntryName   - IN Registry Entry Name
    RegistryValueBuf    - OUT Buffer for the result (pointer to WCHAR string)

Return Value:

    Success/failure (TRUE/FALSE)

--*/
{

    WCHAR                       wBuf[256], cmpbuf[128];
    UNICODE_STRING              us_Buffer, us_EnvVarUserName, us_UserName, us_HiveList;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      hHiveList, hCurUser;
    PKEY_FULL_INFORMATION       pkfi1, pkfi2;
    PKEY_VALUE_FULL_INFORMATION pkvfi1, pkvfi2;
    ULONG                       ret_len, i, j, values1, values2;
    NTSTATUS                    ret;
    WCHAR                       UserNameBuf[80];

    // Check the HKEY_CURRENT_USER\Software\Intel\Btrans registry key for the 
    // 'RegistryEntryName' entry.
    //
    // The problem is that the HKEY_CURRENT_USER hive is not directly available if
    // we are limited only to using the NTDLL interface. In fact, only two high-level 
    // keys are available: HKEY_LOCAL_MACHINE and HKEY_USERS. To sidestep this, 
    // the following mechanism is used, based on these two keys' data and process 
    // environment:
    //
    //  The key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\hivelist
    //    contains list of registry entries corresponding to all users, like:
    //
    //    Key                                  Value
    //---------------------------------------------------------------------------------------- 
    //              ..............
    //  \REGISTRY\USER\S-1-5-21-...         ...\Documents And Settings\<username>[...]\NTUSER.DAT
    //  \REGISTRY\USER\S-1-5-21-..._Class   ...\Documents And Settings\<username>[...]\.......
    //
    //    The key fo the value with correct username (without _Class) is actually
    //    a reference to HKEY_CURRENT_USER registry key
    //
    // <username> can be easily obtained from the process environment

    // Environment -> <username>
    memset (UserNameBuf, L' ', sizeof (UserNameBuf)/sizeof (UserNameBuf[0]) - 1);
    UserNameBuf[sizeof (UserNameBuf)/sizeof (UserNameBuf[0]) - 1] = L'\0';
    RtlInitUnicodeString(&us_UserName, UserNameBuf);
    RtlInitUnicodeString(&us_EnvVarUserName, L"USERNAME");
    ret = RtlQueryEnvironmentVariable_U(NULL, &us_EnvVarUserName, &us_UserName);
    if ( ret == STATUS_SUCCESS ) {
        swprintf(cmpbuf, L"\\%s", us_UserName.Buffer);
        DBCODE (FALSE, BtlpPrintf("cmpbuf=%S, wcslen(cmpbuf)=%d\n", cmpbuf, wcslen(cmpbuf)));
    }
    else {
        DBCODE (FALSE, BtlpPrintf("RtlQueryEnvironmentVariable_U failed: status=%X\n", ret));
    } 

    // Go over the entries for HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\hivelist
    swprintf(wBuf, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\hivelist");
    RtlInitUnicodeString(&us_Buffer, wBuf);
    InitializeObjectAttributes(&oa, &us_Buffer, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ret = NtOpenKey(&hHiveList, KEY_READ, &oa);
    DBCODE (FALSE, BtlpPrintf ("NtOpenKey ret=0x%X\n",ret));
    if ( ret == STATUS_SUCCESS ) {
        KEY_FULL_INFORMATION buf[128];
        memset(buf, 0, sizeof(buf));
        ret = NtQueryKey(hHiveList, KeyFullInformation, buf, sizeof(buf), &ret_len);
        DBCODE (FALSE, BtlpPrintf ("NtQueryKey ret=0x%X\n",ret));
        if ( ret == STATUS_SUCCESS ) {
            pkfi1 = (PKEY_FULL_INFORMATION)buf;
            values1 = pkfi1->Values;
            for ( i = 0; i < values1; i++ ) {
                KEY_FULL_INFORMATION bufv[128];
                memset(bufv, 0, sizeof(bufv));
                ret = NtEnumerateValueKey(hHiveList, i, KeyValueFullInformation, bufv, sizeof(bufv), &ret_len);
                DBCODE (FALSE, BtlpPrintf ("NtEnumerateValueKey ret=0x%X\n",ret));
                if ( ret == STATUS_SUCCESS ) {
                    WCHAR * foundp;
                    pkvfi1 = (PKEY_VALUE_FULL_INFORMATION)bufv;
                    DBCODE (FALSE, BtlpPrintf("name=%S data=%S nl=%d, do=%d, dl=%d\n", 
                                              pkvfi1->Name, (WCHAR *)((char *)pkvfi1 + pkvfi1->DataOffset),
                                              pkvfi1->NameLength, pkvfi1->DataOffset, pkvfi1->DataLength);
                                   BtlpPrintf("tail=%S\n", 
                                              (WCHAR *)((char *)pkvfi1 + pkvfi1->DataOffset + pkvfi1->DataLength - 2) - wcslen(cmpbuf) - 1));

                    // DataLength is in number of bytes, not number of WCHARs
                    // DataOffset is offset in bytes from the start of the data structure
                    DBCODE (FALSE, BtlpPrintf("User=%S, Compare cmpbuf=%S, HKEY_CURRENT_USER maps to %S\n", us_UserName.Buffer, cmpbuf, pkvfi1->Name));
                    foundp = wcsstr ((WCHAR *)((char *)pkvfi1 + pkvfi1->DataOffset), cmpbuf);
                    if (foundp
                        && !iswalnum (foundp[wcslen(cmpbuf)])
                        && foundp[wcslen(cmpbuf)] != L'_') {
                        DBCODE (FALSE, BtlpPrintf("User=%S, HKEY_CURRENT_USER maps to %S\n", us_UserName.Buffer, pkvfi1->Name));

                        // Found the entry in Users hive corresponding to the current user.
                        // Use its name to open the registry key HKEY_CURRENT_USER
                        swprintf(wBuf, L"%s\\Software\\Intel\\Btrans", pkvfi1->Name);
                        RtlInitUnicodeString(&us_Buffer, wBuf);
                        InitializeObjectAttributes(&oa, &us_Buffer, OBJ_CASE_INSENSITIVE, NULL, NULL);
                        ret = NtOpenKey(&hCurUser, KEY_READ, &oa);
                        if ( ret == STATUS_SUCCESS ) {
                            KEY_FULL_INFORMATION bufv2[128];
                            memset(bufv2, 0, sizeof(bufv2));
                            ret = NtQueryKey(hCurUser, KeyFullInformation, bufv2, sizeof(bufv2), &ret_len);
                            if ( ret == STATUS_SUCCESS ) {
                                pkfi2 = (PKEY_FULL_INFORMATION)bufv2;
                                values2 = pkfi2->Values;
                                for ( j = 0; j < values2; j++ ) {
                                    KEY_FULL_INFORMATION bufi2[128];
                                    memset(bufi2, 0, sizeof(bufi2));
                                    ret = NtEnumerateValueKey(hCurUser, j, KeyValueFullInformation, bufi2, sizeof(bufi2), &ret_len);
                                    if ( ret == STATUS_SUCCESS ) {
                                        pkvfi2 = (PKEY_VALUE_FULL_INFORMATION)bufi2;
                                        DBCODE (FALSE, BtlpPrintf("name: %S  value: %S\n", pkvfi2->Name, (WCHAR *)((char *)pkvfi2 + pkvfi2->DataOffset)));

                                        // The entry contains the fullpath of the file
                                        if (pkvfi2->Type == REG_SZ
                                            && wcsncmp(RegistryEntryName, pkvfi2->Name, wcslen(RegistryEntryName)) == 0 ) {
                                            DBCODE (FALSE, BtlpPrintf("File in HKEY_CURRENT_USER: %S\n", (WCHAR *)((char *)pkvfi2 + pkvfi2->DataOffset)));
                                            wcscpy(RegistryValueBuf, (WCHAR *)((char *)pkvfi2 + pkvfi2->DataOffset));
                                            NtClose(hCurUser);
                                            NtClose(hHiveList);
                                            return TRUE;
                                        }
                                    }
                                }
                            }
                            NtClose(hCurUser);
                        }
                        break;
                    }
                }
            }
        }
        NtClose(hHiveList);
    }
    return FALSE;
}

static BOOL BtlpRetrieveHKLMValue (
    IN PWCHAR RegistryEntryName,
    OUT PWCHAR RegistryValueBuf
    )
/*++

Routine Description:

    Retrieve a registry value from HKLM

Arguments:

    RegistryEntryName   - IN Registry Entry Name
    RegistryValueBuf    - OUT Buffer for the result (pointer to WCHAR string)

Return Value:

    Success/failure (TRUE/FALSE)

--*/
{

    WCHAR                       wBuf[256], cmpbuf[128];
    UNICODE_STRING              us_Buffer;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      hLocalMachine;
    PKEY_FULL_INFORMATION       pkfi1, pkfi2;
    PKEY_VALUE_FULL_INFORMATION pkvfi1, pkvfi2;
    ULONG                       ret_len, i, j, values1, values2;
    NTSTATUS                    ret;

    // Check the HKEY_LOCAL_MACHINE\Software\Intel\Btrans registry key for the 
    //    'RegistryEntryName' entry.
    swprintf(wBuf, L"\\Registry\\Machine\\Software\\Intel\\Btrans");
    RtlInitUnicodeString(&us_Buffer, wBuf);
    InitializeObjectAttributes(&oa, &us_Buffer, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ret = NtOpenKey(&hLocalMachine, KEY_READ, &oa);
    if ( ret == STATUS_SUCCESS ) {
        KEY_FULL_INFORMATION buf[128];
        memset(buf, 0, sizeof(buf));
        ret = NtQueryKey(hLocalMachine, KeyFullInformation, buf, sizeof(buf), &ret_len);
        if ( ret == STATUS_SUCCESS) {
            pkfi1 = (PKEY_FULL_INFORMATION)buf;
            for ( j = 0; j < pkfi1->Values; j++ ) {
                KEY_FULL_INFORMATION bufv[128];
                memset(bufv, 0, sizeof(bufv));
                ret = NtEnumerateValueKey(hLocalMachine, j, KeyValueFullInformation, bufv, sizeof(bufv), &ret_len);
                if ( ret == STATUS_SUCCESS ) {
                    pkvfi1 = (PKEY_VALUE_FULL_INFORMATION)bufv;
                    if (pkvfi1->Type == REG_SZ
                        && wcsncmp(RegistryEntryName, pkvfi1->Name, wcslen(RegistryEntryName)) == 0 ) {
                        wcscpy(RegistryValueBuf, (WCHAR *)((char *)pkvfi1 + pkvfi1->DataOffset));
                        NtClose(hLocalMachine);
                        return TRUE;
                    } 
                }
            }
        }
        NtClose(hLocalMachine);
    }
    return FALSE;
}

static BOOL BtlpBtlibDirectory (
    OUT PWCHAR ValueBuf
    )
/*++

Routine Description:

    Retrieve the actual directory of the wowIA32X.dll and use it as
    a last resort if no specific registry pointer
    is found for IA32Exec.bin and BTrans.ini files.

Arguments:

    ValueBuf    - OUT Buffer for the result (pointer to WCHAR string)

Return Value:

    Success/failure (TRUE/FALSE)

--*/
{
    PPEB_LDR_DATA LdrP;
    PLDR_DATA_TABLE_ENTRY LdrDtP;
    
    RtlAcquirePebLock();
    LdrP = BT_CURRENT_TEB()->ProcessEnvironmentBlock->Ldr;
    LdrDtP = (PLDR_DATA_TABLE_ENTRY)(LdrP->InLoadOrderModuleList.Flink);
    do {
        // Our own address belongs to the wowIA32X.dll module
        if (   (ULONG_PTR)BtlpBtlibDirectory >= (ULONG_PTR)LdrDtP->DllBase
            && (ULONG_PTR)BtlpBtlibDirectory <  (ULONG_PTR)LdrDtP->DllBase + LdrDtP->SizeOfImage) {
            // Found
            WCHAR * EndPtr;
            wcscpy(ValueBuf, LdrDtP->FullDllName.Buffer);
            // Remove file name at the end (until '\\' inclusively)
            EndPtr = wcsrchr(ValueBuf,L'\\');
            if (EndPtr) {
                *EndPtr = L'\0';
            }
            RtlReleasePebLock();
            return TRUE;
        }
        LdrDtP = (PLDR_DATA_TABLE_ENTRY)(LdrDtP->InLoadOrderLinks.Flink);
    } while (LdrDtP != (PLDR_DATA_TABLE_ENTRY)&(LdrP->InLoadOrderModuleList.Flink));
    RtlReleasePebLock();
    return FALSE;
}

#ifndef RELEASE
static int BtlpIniFileExists(
    IN PWCHAR CurrentDir,
    IN int fBTGenericHandle,
    OUT PHANDLE phIniFile
    )
/*++

Routine Description:

    Locate and open BTrans.ini file

Arguments:

    CurrentDir          - IN current directory
    phIniFile           - OUT Handle of the file

Return Value:

    Success/failure (TRUE/FALSE)

--*/
{

    WCHAR RegEntry[16] = L"SETUP_FILE";
    WCHAR RegistryValueBuf[1024];
    WCHAR IniFileFullPath[1024];
    UNICODE_STRING us_IniFile;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK   IoStatusBlock;
    LARGE_INTEGER AllocSz = { 0, 0 };
    NTSTATUS ret;

    // 1. Check for existence of Btrans.ini file in the current work directory
    swprintf(IniFileFullPath, L"\\DosDevices\\%s\\BTrans.ini", CurrentDir);
    RtlInitUnicodeString(&us_IniFile, IniFileFullPath);
    InitializeObjectAttributes(&oa, &us_IniFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
    ret = NtCreateFile(phIniFile, FILE_GENERIC_READ, &oa, &IoStatusBlock, &AllocSz, 
                     FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, 
                     FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL, 0);
    if ( ret == STATUS_SUCCESS  &&  (*phIniFile) != INVALID_HANDLE_VALUE ) {
        //BtlpPrintf("Setup file in current work directory: %S\n", IniFileFullPath);
        return F_CURRENT_DIR;
    }

#ifndef NODEBUG
    // 2. Check the HKEY_CURRENT_USER\Software\Intel\Btrans registry key for the 
    //    SETUP_FILE entry that should contain the fullpath of the IA-32 Execution Layer setup file
    //    (only if IA32Exec.bin found there as well)
    if (F_HKCU == fBTGenericHandle
        && BtlpRetrieveHKCUValue (RegEntry, RegistryValueBuf)) {
        swprintf(IniFileFullPath, L"\\DosDevices\\%s", RegistryValueBuf);
        RtlInitUnicodeString(&us_IniFile, IniFileFullPath);
        InitializeObjectAttributes(&oa, &us_IniFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
        ret = NtCreateFile(phIniFile, FILE_GENERIC_READ, &oa, &IoStatusBlock, &AllocSz, 
                         FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, 
                         FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                         NULL, 0);
        if ( ret == STATUS_SUCCESS  &&  (*phIniFile) != INVALID_HANDLE_VALUE ) {
            return F_HKCU;
        }
    }
#endif

    // 3. Check the HKEY_LOCAL_MACHINE\Software\Intel\Btrans registry key for the 
    //    SETUP_FILE entry that contains the fullpath of the IA-32 Execution Layer setup file
    //    (only if IA32Exec.bin found there as well)
    if (F_HKLM == fBTGenericHandle
        && BtlpRetrieveHKLMValue (RegEntry, RegistryValueBuf)) {
        swprintf(IniFileFullPath, L"\\DosDevices\\%s", RegistryValueBuf);
        RtlInitUnicodeString(&us_IniFile, IniFileFullPath);
        InitializeObjectAttributes(&oa, &us_IniFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
        ret = NtCreateFile(phIniFile, FILE_GENERIC_READ, &oa, &IoStatusBlock, &AllocSz, 
                         FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, 
                         FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                         NULL, 0);
        if ( ret == STATUS_SUCCESS  &&  (*phIniFile) != INVALID_HANDLE_VALUE ) {
            return F_HKLM;
        }
    }

    // 4. Last resort - directory that wowIA32X.dll was loaded from
    //    (only if IA32Exec.bin found there as well)
    if (F_BTLIB == fBTGenericHandle
        && BtlpBtlibDirectory (RegistryValueBuf)) {
        swprintf(IniFileFullPath, L"\\DosDevices\\%s\\BTrans.ini", RegistryValueBuf);
        RtlInitUnicodeString(&us_IniFile, IniFileFullPath);
        InitializeObjectAttributes(&oa, &us_IniFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
        ret = NtCreateFile(phIniFile, FILE_GENERIC_READ, &oa, &IoStatusBlock, &AllocSz, 
                         FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, 
                         FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                         NULL, 0);
        if ( ret == STATUS_SUCCESS  &&  (*phIniFile) != INVALID_HANDLE_VALUE ) {
            return F_BTLIB;
        }
    }

    *phIniFile = INVALID_HANDLE_VALUE;
    return F_NOT_FOUND;
}
#endif /* RELEASE */

static int BtlpLoadBTGeneric(
    IN PWCHAR CurrentDir,
    OUT PHANDLE phBTGenericLibrary
    )
/*++

Routine Description:

    Locate and load IA32Exec.bin component

Arguments:

    CurrentDir          - IN current directory
    phBTGenericLibrary  - OUT Handle of the IA32Exec.bin

Return Value:

    Success/failure (TRUE/FALSE)

--*/
{
    WCHAR RegistryValueBuf[1024];
    UNICODE_STRING us_BTGenericLibrary;
    WCHAR BTGenericLibraryFullPath[1024];
    NTSTATUS ret;

#ifndef RELEASE
    WCHAR RegEntry[16] = L"GENERIC_FILE";

    // 1. Check for existence of IA32Exec.bin file in the current work directory
    swprintf(BTGenericLibraryFullPath, L"%s\\%s.%s", CurrentDir, IA32EX_G_NAME,
             IA32EX_G_SUFFIX);
    RtlInitUnicodeString(&us_BTGenericLibrary, BTGenericLibraryFullPath);
    ret = LdrLoadDll((PWSTR)NULL, (PULONG)0, &us_BTGenericLibrary, phBTGenericLibrary);
    if ( ret == STATUS_SUCCESS && (*phBTGenericLibrary) != INVALID_HANDLE_VALUE ) {
        //BtlpPrintf("IA32Exec.bin file in current work directory: %S\n", BTGenericLibraryFullPath);
        return F_CURRENT_DIR;
    }

#ifndef NODEBUG
    // 2. Check the HKEY_CURRENT_USER\Software\Intel\Btrans registry key for the 
    //    BTGENERIC_FILE entry that should contain the fullpath of the IA32Exec.bin file
    if (BtlpRetrieveHKCUValue (RegEntry, RegistryValueBuf)) {
        swprintf(BTGenericLibraryFullPath, L"%s", RegistryValueBuf);
        RtlInitUnicodeString(&us_BTGenericLibrary, BTGenericLibraryFullPath);
        ret = LdrLoadDll((PWSTR)NULL, (PULONG)0, &us_BTGenericLibrary, phBTGenericLibrary);
        if ( ret == STATUS_SUCCESS && (*phBTGenericLibrary) != INVALID_HANDLE_VALUE ) {
            return F_HKCU;
        }
    }
#endif

    // 3. Check the HKEY_LOCAL_MACHINE\Software\Intel\Btrans registry key for the 
    //    BTGENERIC_FILE entry that contains the fullpath of the IA32Exec.bin file
    if (BtlpRetrieveHKLMValue (RegEntry, RegistryValueBuf)) {
        swprintf(BTGenericLibraryFullPath, L"%s", RegistryValueBuf);
        RtlInitUnicodeString(&us_BTGenericLibrary, BTGenericLibraryFullPath);
        ret = LdrLoadDll((PWSTR)NULL, (PULONG)0, &us_BTGenericLibrary, phBTGenericLibrary);
        if ( ret == STATUS_SUCCESS && (*phBTGenericLibrary) != INVALID_HANDLE_VALUE ) {
            return F_HKLM;
        }
    }
#endif /* RELEASE */

    // 4. Last resort - directory that wowIA32X.dll was loaded from
    //    This is the only option in RELEASE mode
    if (BtlpBtlibDirectory (RegistryValueBuf)) {
        swprintf(BTGenericLibraryFullPath, L"%s\\%s.%s", RegistryValueBuf, IA32EX_G_NAME,
                 IA32EX_G_SUFFIX);
        RtlInitUnicodeString(&us_BTGenericLibrary, BTGenericLibraryFullPath);
        ret = LdrLoadDll((PWSTR)NULL, (PULONG)0, &us_BTGenericLibrary, phBTGenericLibrary);
        if ( ret == STATUS_SUCCESS && (*phBTGenericLibrary) != INVALID_HANDLE_VALUE ) {
            return F_BTLIB;
        }
    }

    *phBTGenericLibrary = INVALID_HANDLE_VALUE;
    return F_NOT_FOUND;
}

// Extract DOS header from NT executable (NULL if it is not one)
static PIMAGE_DOS_HEADER WINAPI BtlpExtractDosHeader (IN HANDLE hModule) {
    PIMAGE_DOS_HEADER       DosHeaderP;

    DosHeaderP = (PIMAGE_DOS_HEADER) hModule;
    assert (!((ULONG_PTR)DosHeaderP & 0xFFFF));
    if (DosHeaderP->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }
    return DosHeaderP;
}

// Extract NT header from NT executable (abort if not one)
static PIMAGE_NT_HEADERS WINAPI BtlpExtractNTHeader (IN HINSTANCE hModule) {
    PIMAGE_DOS_HEADER       DosHeaderP;
    PIMAGE_NT_HEADERS       NTHeaderP;

    DosHeaderP = BtlpExtractDosHeader ((HANDLE)hModule);
    assert (DosHeaderP != NULL);
    NTHeaderP = (PIMAGE_NT_HEADERS) ((ULONG_PTR)DosHeaderP + DosHeaderP->e_lfanew);
    assert (NTHeaderP->Signature == IMAGE_NT_SIGNATURE);
    assert ((NTHeaderP->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) != 0);
    assert ((NTHeaderP->FileHeader.Characteristics & IMAGE_FILE_32BIT_MACHINE) != 0);
    assert (NTHeaderP->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC);
    assert (NTHeaderP->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64);
    return NTHeaderP;
}

static void BtlpInitIA32Context(
            BTGENERIC_IA32_CONTEXT * IA32ContextP,
            PTEB32 pTEB32
            )
/*++
Routine Description:
    Initialize IA32 thread context 
Arguments:
    IA32ContextP      - Pointer to IA32 context to be initialized
    pTEB32            - Pointer to IA32 TEB of the thread whose context is 
                        to be initialized
Return Value:
    none
--*/
{
    memset(IA32ContextP, 0, sizeof(*IA32ContextP) );
    IA32ContextP->SegCs = CS_INIT_VAL;
    IA32ContextP->SegDs = DS_INIT_VAL;
    IA32ContextP->SegEs = ES_INIT_VAL;
    IA32ContextP->SegFs = FS_INIT_VAL;
    IA32ContextP->SegSs = SS_INIT_VAL;
    
    IA32ContextP->EFlags = EFLAGS_INIT_VAL;
    IA32ContextP->Esp    = (U32)pTEB32->NtTib.StackBase - sizeof(U32);
    
    IA32ContextP->FloatSave.ControlWord  = FPCW_INIT_VAL;
    IA32ContextP->FloatSave.TagWord      = FPTW_INIT_VAL;
    
    *(U32 *)&(IA32ContextP->ExtendedRegisters[24])   = MXCSR_INIT_VAL;
}

__inline NTSTATUS BtlpGetProcessInfo(
    IN HANDLE ProcessHandle,
    PROCESS_BASIC_INFORMATION * pInfo
    )
/*++
Routine Description:
    Given a process handle, return basic process information
Arguments:
    ProcessHandle     - Process handle
    pInfo             - Buffer to receive PROCESS_BASIC_INFORMATION
Return Value:
    NTSTATUS.
--*/
{
    NTSTATUS status;

    status = NtQueryInformationProcess(
        ProcessHandle,
        ProcessBasicInformation,
        pInfo,
        sizeof(*pInfo),
        0);
    BTLP_REPORT_NT_FAILURE("NtQueryInformationProcess", status);
    return status;
}

__inline NTSTATUS BtlpGetProcessUniqueIdByHandle(
    IN  HANDLE ProcessHandle,
    OUT U64 * ProcessIdP
    )
/*++
Routine Description:
    Given a process handle, return unique (throughout the system) ID of the process
Arguments:
    ProcessHandle     - Process handle
    ProcessIdP        - Pointer to a variable that receives unique process ID 
Return Value:
    NTSTATUS.
--*/
{
    NTSTATUS status;
    PROCESS_BASIC_INFORMATION info;

    status = BtlpGetProcessInfo(ProcessHandle,&info);
    if (status == STATUS_SUCCESS) {
        *ProcessIdP = (U64)(info.UniqueProcessId);
    }
    return status;
}

__inline NTSTATUS BtlpGetThreadUniqueIdByHandle(
    IN HANDLE ThreadHandle,
    OUT U64 * ThreadIdP
    )
/*++
Routine Description:
    Given a thread handle, return unique (throughout the system) ID of the thread
Arguments:
    ThreadHandle     - Thread handle
    ThreadIdP        - Pointer to a variable that receives unique thread ID 
Return Value:
    NTSTATUS.
--*/
{
    NTSTATUS status;
    THREAD_BASIC_INFORMATION info;

    status = NtQueryInformationThread(
        ThreadHandle,
        ThreadBasicInformation,
        &info,
        sizeof(info),
        0);
    if (status == STATUS_SUCCESS) {
        *ThreadIdP = (U64)(info.ClientId.UniqueThread);
    }
    return status;
}

__inline BOOL BtlpIsCurrentProcess(
    IN HANDLE ProcessHandle
    )
/*++

Routine Description:
    Check to see if a process handle represents the current process
Arguments:
    ProcessHandle     - Process handle
Return Value:
    TRUE if ProcessHandle represents the current process, FALSE - otherwise.
--*/
{
    U64 ProcessId;
    return ((ProcessHandle == NtCurrentProcess()) || 
            ((BtlpGetProcessUniqueIdByHandle(ProcessHandle, &ProcessId) == STATUS_SUCCESS) &&
            (BT_CURRENT_PROC_UID() == ProcessId)));
}


__inline PVOID BtlpGetTlsPtr(
    IN HANDLE ProcessHandle,
    IN PTEB   pTEB,
    IN BOOL   IsLocal
    )
/*++
Routine Description:
    Read BT_TLS pointer of a local or remote thread
Arguments:
    ProcessHandle   - Process handle
    pTEB            - TEB of a local/remote thread
    IsLocal         - TRUE for local thread
Return Value:
    BT_TLS pointer. NULL if access failed.
--*/
{
    NTSTATUS status;
    PVOID GlstP;
    if (IsLocal) {
        GlstP = BT_TLS_OF(pTEB);
    }
    else {
        status = NtReadVirtualMemory(ProcessHandle,
                                     (VOID * )((UINT_PTR)pTEB + BT_TLS_OFFSET),
                                     &GlstP,
                                     sizeof(GlstP),
                                     NULL);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtReadVirtualMemory", status);
            GlstP = NULL;
        }
    }
    return GlstP;
}

__inline NTSTATUS BtlpInitSharedInfo() 
/*++
Routine Description:
    Initialize thread shared info 
Arguments:
    None
Return Value:
    NTSTATUS
--*/
{

    BTLIB_INIT_SUSPENSION_PERMISSION();
    BTLIB_INIT_SUSPEND_REQUEST();
    BTLIB_SET_CONSISTENT_EXCEPT_STATE();
    BTLIB_SET_SIGNATURE();
    return STATUS_SUCCESS;
}

static NTSTATUS BtlpReadSharedInfo(
    IN  HANDLE ProcessHandle,
    IN  PVOID  pTLS,
    IN  BOOL   IsLocal,
    OUT BTLIB_SHARED_INFO_TYPE * SharedInfoP
    )
/*++
Routine Description:
    Read shared wowIA32X.dll info of a local or remote thread. The function 
    fails if wowIA32X.dll signature does not match.
Arguments:
    ProcessHandle   - Process handle
    pTLS            - pointer to BT_TLS of a local/remote thread
    IsLocal         - TRUE for local thread
    SharedInfoP     - buffer to read shared wowIA32X.dll info to
Return Value:
    NTSTATUS
--*/
{
    NTSTATUS status;

    if (IsLocal) {
        *SharedInfoP = *((BTLIB_SHARED_INFO_TYPE *)BTLIB_MEMBER_PTR(pTLS, SharedInfo));
        status = STATUS_SUCCESS;
    }
    else {
        status = NtReadVirtualMemory(ProcessHandle,
                                     BTLIB_MEMBER_PTR(pTLS, SharedInfo),
                                     SharedInfoP,
                                     sizeof(*SharedInfoP),
                                     NULL);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtReadVirtualMemory", status);
        }
        else if (!BTLIB_SI_CHECK_SIGNATURE(SharedInfoP)) {
            DBCODE (TRUE, BtlpPrintf("\nwowIA32X.dll Signature mismatch!!!!\n"));
            status = STATUS_UNSUCCESSFUL;
        }
    }
    return status;
}

static NTSTATUS BtlpWriteSuspendRequest(
    IN  HANDLE ProcessHandle,
    IN  PVOID  pTLS,
    IN  BOOL   IsLocal,
    IN  BTLIB_SUSPEND_REQUEST * SuspendRequestP
    )
/*++
Routine Description:
    Write BTLIB_SUSPEND_REQUEST to a local or remote thread.
Arguments:
    ProcessHandle   - Process handle
    pTLS            - pointer to BT_TLS of a local/remote thread
    IsLocal         - TRUE for local thread
    SharedInfoP     - buffer to write BTLIB_SUSPEND_REQUEST from
Return Value:
    NTSTATUS
--*/
{
    NTSTATUS status;
    if (IsLocal) {
        *((BTLIB_SUSPEND_REQUEST *)BTLIB_MEMBER_PTR(pTLS, SharedInfo.SuspendRequest)) = *SuspendRequestP;
        status = STATUS_SUCCESS;
    }
    else {
        status = NtWriteVirtualMemory(ProcessHandle,
                                     BTLIB_MEMBER_PTR(pTLS, SharedInfo.SuspendRequest),
                                     SuspendRequestP,
                                     sizeof(*SuspendRequestP),
                                     NULL);
        BTLP_REPORT_NT_FAILURE("NtWriteVirtualMemory", status);
    }
    return status;
}

static NTSTATUS BtlpSendSuspensionRequest(
    IN  HANDLE ProcessHandle,
    IN  HANDLE ThreadHandle,
    IN  PVOID  pTLS,
    IN  BOOL   IsLocal,
    IN CONTEXT * ResumeContextP,
    IN OUT PULONG PreviousSuspendCountP
    )
/*++
Routine Description:
    The function is called when the target thread is ready to perform self-canonization
    and exit simulation. 
    The function fills in BTLIB_SUSPEND_REQUEST, resumes target thread and suspends 
    it in a consistent state.
    Caller is responsible for serialization of SUSPEND_REQUESTs.
Arguments:
    ProcessHandle   - target process handle
    ThreadHandle    - target thread handle
    pTLS            - pointer to BT_TLS of a local/remote thread
    IsLocal         - TRUE for local thread
    ResumeContextP  - IA64 context to resume target thread for self-canonization
    PreviousSuspendCountP - IN OUT pointer to thread's previous suspend count. 
Return Value:
    NTSTATUS
--*/
{
    NTSTATUS status;
    BTLIB_SUSPEND_REQUEST SuspendRequest;
    HANDLE ReadyEvent = INVALID_HANDLE_VALUE;
    HANDLE ResumeEvent = INVALID_HANDLE_VALUE;
    HANDLE WaitArray[2];

    //This function call must be serialized
    assert(*PreviousSuspendCountP ==0);

    SuspendRequest.ReadyEvent = INVALID_HANDLE_VALUE;
    SuspendRequest.ResumeEvent = INVALID_HANDLE_VALUE;

    do {
        //Prepare SUSPEND_REQUEST for sending to the target process

        //Create pair of synchronization events in current process and duplicate
        //them to the target process
        status = NtCreateEvent(&ReadyEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtCreateEvent", status);
            break;
        }

        status = NtCreateEvent(&ResumeEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtCreateEvent", status);
            break;
        }

        status = NtDuplicateObject(NtCurrentProcess(),
                                ReadyEvent,
                                ProcessHandle,
                                &(SuspendRequest.ReadyEvent),
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtDuplicateObject", status);
            break;
        }

        status = NtDuplicateObject(NtCurrentProcess(),
                                ResumeEvent,
                                ProcessHandle,
                                &(SuspendRequest.ResumeEvent),
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtDuplicateObject", status);
            break;
        }
        

        // First write SUSPEND_REQUEST to the  the target thread,  
        // tnen set ContextIA64 and resume target thread. 
        // The order is important! The BtlpEnsureSuspensionConsistency function 
        // relies on that.
        SuspendRequest.Active = TRUE;
        status = BtlpWriteSuspendRequest(ProcessHandle, pTLS, IsLocal, &SuspendRequest);
        if (status != STATUS_SUCCESS) {
            //Sending request failed, do not try to remove it.
            SuspendRequest.Active = FALSE;
            break;
        }
        
        status = NtSetContextThread(ThreadHandle, ResumeContextP);
        if (status != STATUS_SUCCESS) {
            //abort request and report failure.
            BTLP_REPORT_NT_FAILURE("NtSetContextThread", status);
            break;
        }

        status = NtResumeThread(ThreadHandle, NULL);
        if (status != STATUS_SUCCESS) {
            //abort request and report failure.
            BTLP_REPORT_NT_FAILURE("NtResumeThread", status);
            break;
        }

        //Wait until remote thread receives request or dies
        WaitArray[0] = ThreadHandle;
        WaitArray[1] = ReadyEvent;

        status = NtWaitForMultipleObjects(2, WaitArray, WaitAny, FALSE, NULL);
        if (status == STATUS_WAIT_0) {
            //the target thread is died along with its event handles. 
            //No need to remove request.
            BTLP_REPORT_NT_FAILURE("NtWaitForMultipleObjects", status);
            SuspendRequest.ReadyEvent = INVALID_HANDLE_VALUE;
            SuspendRequest.ResumeEvent = INVALID_HANDLE_VALUE;
            SuspendRequest.Active = FALSE;
        }

        //Suspend target thread and signal the ResumeEvent event to release
        //target thread after it will be awaken (later on)
        status = NtSuspendThread(ThreadHandle, PreviousSuspendCountP);
        if (status != STATUS_SUCCESS) {
            //remove request and report failure.
            BTLP_REPORT_NT_FAILURE("NtSuspendThread", status);
            break;
        }
        status = NtSetEvent(ResumeEvent, NULL);
        BTLP_REPORT_NT_FAILURE("NtSetEvent", status);


    } while (FALSE);

    //Close local event handles
    if (ReadyEvent != INVALID_HANDLE_VALUE) {
        NtClose(ReadyEvent);
    }
    if (ResumeEvent != INVALID_HANDLE_VALUE) {
        NtClose(ResumeEvent);
    }
    
    //Close remote event handles if needed
    if (status != STATUS_SUCCESS) {
        if (SuspendRequest.ReadyEvent != INVALID_HANDLE_VALUE) {
            NtDuplicateObject(ProcessHandle,
                            SuspendRequest.ReadyEvent,
                            NtCurrentProcess(),
                            &ReadyEvent,
                            EVENT_ALL_ACCESS,
                            FALSE,
                            DUPLICATE_CLOSE_SOURCE);
            NtClose(ReadyEvent);
            SuspendRequest.ReadyEvent = INVALID_HANDLE_VALUE;
        }

        if (SuspendRequest.ResumeEvent != INVALID_HANDLE_VALUE) {
            NtDuplicateObject(ProcessHandle,
                            SuspendRequest.ResumeEvent,
                            NtCurrentProcess(),
                            &ResumeEvent,
                            EVENT_ALL_ACCESS,
                            FALSE,
                            DUPLICATE_CLOSE_SOURCE);
            NtClose(ResumeEvent);
            SuspendRequest.ResumeEvent = INVALID_HANDLE_VALUE;
        }

    }

    //Close SUSPEND_REQUEST
    if (SuspendRequest.Active) {
        SuspendRequest.Active = FALSE;
        BtlpWriteSuspendRequest(ProcessHandle, pTLS, IsLocal, &SuspendRequest);
    }

    return status;
}

static NTSTATUS BtlpReceiveSuspensionRequest()
/*++
Routine Description:
    The function handles active SUSPEND_REQUEST sent to this thread by
    another thread. It notifies request sender about reaching the point
    where suspension is possible and waits for real suspension to be 
    performed by the request's sender.
Arguments:
    none
Return Value:
    NTSTATUS
--*/
{
    NTSTATUS status;
    HANDLE ReadyEvent;
    HANDLE ResumeEvent;

    //local SUSPEND_REQUEST should be active at this point
    assert(BTLIB_INFO_PTR()->SharedInfo.SuspendRequest.Active);

    //Copy events from SUSPEND_REQUEST to local vars. It is important
    //because after suspend/resume the event handles should be closed but 
    //SUSPEND_REQUEST could be rewritten
    ReadyEvent  = BTLIB_INFO_PTR()->SharedInfo.SuspendRequest.ReadyEvent;
    ResumeEvent = BTLIB_INFO_PTR()->SharedInfo.SuspendRequest.ResumeEvent;

    assert ((ReadyEvent != INVALID_HANDLE_VALUE)  && (ResumeEvent != INVALID_HANDLE_VALUE));

    //Release ReadyEvent and wait for ResumeEvent. The thread can be 
    //suspended at this point
    status = NtSignalAndWaitForSingleObject(ReadyEvent, ResumeEvent, FALSE, NULL);

    //Close local event handles
    NtClose(ReadyEvent);
    NtClose(ResumeEvent);

    return status;
}

// Wow64CPU forwarded APIs implementations:
// Note that all names are defined with PTAPI() macro which adds either BTCpu or Cpu prefix,
// depending on the mode we build the DLL.
// In release mode all names will be BTCpu only.

WOW64BT_IMPL NTSTATUS BTAPI(ProcessInit)(
    PWSTR pImageName,
    PSIZE_T pCpuThreadDataSize)
/*++

Routine Description:

    Per-process initialization code
    Locates, reads and parses parameters file BTrans.ini
    Locates, load and initializes IA32Exec.bin component


Arguments:

    pImageName       - IN the name of the image. The memory for this
                       is freed after the call, so if the callee wants
                       to keep the name around, they need to allocate space
                       and copy it. DON'T SAVE THE POINTER!

    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/
{

    char * argv[128] = { NULL };
    int    argc = 1;
    static WCHAR  CurrentDir[1024];
    HANDLE BTGenericHandle;
    int    fBTGenericFound;
#ifdef OVERRIDE_TIA
    HANDLE              BtlpOverrideTiaFile = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       as = { 0, 0 }, offst = { 0, 0 };
#endif /* OVERRIDE_TIA */

    {
        // Temporary workaround for IA32 debugging support. 
        //To be removed after fixing FlushIC(ProcessHandle) by MS.
        NTSTATUS status;
        PROCESS_BASIC_INFORMATION info;
        //Check to see if current process is being debugged
        status = BtlpGetProcessInfo(NtCurrentProcess(), &info);
        BeingDebugged = ((status == STATUS_SUCCESS) && 
                        (info.PebBaseAddress->BeingDebugged));
    }

    RtlGetCurrentDirectory_U(512, CurrentDir);

    // Load IA32Exec.bin ...
    fBTGenericFound = BtlpLoadBTGeneric(CurrentDir, &BTGenericHandle);
    if (F_NOT_FOUND == fBTGenericFound) {
        return STATUS_NOT_FOUND;
    }

#ifndef RELEASE
    // Load parameters file
    {
        UNICODE_STRING        IniFileName, LogFileName;
        HANDLE IniFileHandle = INVALID_HANDLE_VALUE;
        OBJECT_ATTRIBUTES     ObjectAttributes;
        IO_STATUS_BLOCK       IoStatusBlock;
        LARGE_INTEGER         AllocSz = { 0, 0 }, Offset = { 0, 0 };
        char                  IniBuffer[8192] = "";
        char                  IniArgs[8192], * IniArgsP = IniArgs;
        WCHAR                 LogFileFullPath[1024], LogName[64];

        if (wcslen (pImageName) >= sizeof (ImageName) / sizeof (ImageName[0])) {
            swprintf (ImageName, L"%s", "dummyImage");
        }
        else {
            swprintf (ImageName, L"%s", pImageName);
        }

        // Locate and scan INI file, extract parameters
        if (F_NOT_FOUND != BtlpIniFileExists(CurrentDir, fBTGenericFound, &IniFileHandle)) { 
            int ret;
            ret = NtReadFile(IniFileHandle, NULL, NULL, NULL, &IoStatusBlock, (VOID *)IniBuffer, 8192, &Offset, NULL);
            if ( ret == STATUS_END_OF_FILE  ||  ret == STATUS_SUCCESS ) {
                char * CurrentChar;
                static char logparm[] = "log";
                static char logdirparm[] = "logdir";
#ifdef OVERRIDE_TIA
                static char ovrtiaparm[] = "override_tia=";
#endif
#ifndef NODEBUG
                static char PerthreadParm[] = "logfile_per_thread";
#endif
                static char DebugBtransParm[] = "debug_btrans";

                // Close file  (assuming everything has been read in one piece)
                NtClose(IniFileHandle);
                LogDirName[0] = '\0';
                LogDirName[1] = '\0';

                // Mark end of the text
                CurrentChar = IniBuffer;
                CurrentChar[IoStatusBlock.Information] = '\0';

                // Scan until end of file
                while ( *CurrentChar != '\0' ) {
                    char *EndOfLineChar;
                    // Locate and handle end of line
                    if (EndOfLineChar = strchr(CurrentChar+1, '\n')) {
                        // Remove \r before, if one present
                        if (*(EndOfLineChar-1) == '\r') {
                            *(EndOfLineChar-1) = '\0';
                        }
                        // Replace \n by \0
                            *EndOfLineChar++ = '\0';
                        }

#ifndef NODEBUG
                    if (_strnicmp(CurrentChar, PerthreadParm, sizeof (PerthreadParm) - 1) == 0) {
                        CurrentChar += (sizeof (PerthreadParm) - 1);
                        if (BtlpWow64LogFile == INVALID_HANDLE_VALUE) {
                            BtlpLogFilePerThread = TRUE;
                            swprintf(BtlpLogFileFullPath, L"\\DosDevices\\%s\\%s", CurrentDir, pImageName);
                        }
                    }  else  
#endif
                    if (_strnicmp(CurrentChar, DebugBtransParm, sizeof (DebugBtransParm) - 1) == 0) {
                        CurrentChar += (sizeof (DebugBtransParm) - 1);
                        //ignore application debugging when debugging IA-32 Execution layer
                        BeingDebugged = FALSE;
                    }
                    else if ( _strnicmp(CurrentChar, logdirparm, sizeof (logdirparm) - 1) == 0 ) {
                        WCHAR *pl;
                        CurrentChar += (sizeof (logdirparm) - 1);
                        // log directory specified
                        if (*CurrentChar == '='  &&  *(CurrentChar+1) != '\0') {
                            // Name present as well
                            CurrentChar++;
                            pl = LogDirName;
                            while ( (WCHAR)*CurrentChar != (WCHAR)'\0' ) {
                                *pl = (WCHAR)*CurrentChar;
                                pl++;
                                CurrentChar++;
                            }
                            *pl = (WCHAR)'\0';
                        }
                        else {
                            BtlpPrintf("logdir specified without =<dirname>, IGNORED\n");
                        }
                    }
                    // Process and skip "log" parameter
                    else if ( _strnicmp(CurrentChar, logparm, sizeof (logparm) - 1) == 0 ) {
                        WCHAR *pl;

                        CurrentChar += (sizeof (logparm) - 1);

                        // log required - prepare log file name
                        if (*CurrentChar == '='  &&  *(CurrentChar+1) != '\0') {
                            // Name present as well
                            CurrentChar++;
                            pl = LogName;
                            while ( (WCHAR)*CurrentChar != (WCHAR)'\0') {
                                *pl++ = (WCHAR)*CurrentChar++;
                            }
                            *pl = (WCHAR)'\0';
                        }
                        else {
                            // No name - use ImageName.log
                            swprintf(LogName, L"%s.log", pImageName);
                        }

                        // Create log file
                        if (0==LogDirName[0] && 0==LogDirName[1]) {
                            swprintf(LogFileFullPath, L"\\DosDevices\\%s\\%s", CurrentDir, LogName);
                        }
                        else {
                            swprintf(LogFileFullPath, L"\\DosDevices\\%s\\%s", LogDirName, LogName);
                        }
                        
                        RtlInitUnicodeString(&LogFileName, LogFileFullPath);
                        InitializeObjectAttributes(&ObjectAttributes, &LogFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);
                        ret = NtCreateFile(&BtlpWow64LogFile, FILE_GENERIC_WRITE,
                                           &ObjectAttributes, &IoStatusBlock, 
                                           &AllocSz, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_SUPERSEDE,
                                           FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                                           NULL, 0);
                        if ( ret != STATUS_SUCCESS ) {
                            BtlpWow64LogFile = INVALID_HANDLE_VALUE;
                            // BtlpPrintf("Can't create LOG file %S: status=%X\n", LogFileFullPath, ret);
                        }
#ifndef NODEBUG                        
                        BtlpLogFilePerThread = FALSE;
#endif
                    }
#ifdef OVERRIDE_TIA
                    // Process and skip "override_tia=..." parameter
                    else if ( _strnicmp(CurrentChar, ovrtiaparm, sizeof(ovrtiaparm) - 1) == 0 ) {
                        WCHAR *             pl;
                        WCHAR               OvrTiaFileName[64], OvrTiaFileFullPath[1024];
                        UNICODE_STRING      OvrTiaFile;

                        CurrentChar += (sizeof(ovrtiaparm) - 1);
                        if ( *CurrentChar == '\0') {
                            BtlpPrintf("Name of override TIA file not specfied\n");
                            continue;
                        }
                        // prepare override TIA file name
                        pl = OvrTiaFileName;
                        while ( (WCHAR)*CurrentChar != (WCHAR)'\0') {
                            *pl++ = (WCHAR)*CurrentChar++;
                        }
                        *pl = (WCHAR)'\0';

                        // Open override TIA file; so far - only in current dir
                        swprintf(OvrTiaFileFullPath, L"\\DosDevices\\%s\\%s", CurrentDir, OvrTiaFileName);
                        
                        RtlInitUnicodeString(&OvrTiaFile, OvrTiaFileFullPath);
                        InitializeObjectAttributes(&oa, &OvrTiaFile, OBJ_CASE_INSENSITIVE, NULL, NULL);
                        //Do not use synchronized access as it blocks forever in case of thread suspension
                        ret = NtCreateFile(&BtlpOverrideTiaFile, FILE_GENERIC_READ, &oa, &iosb, &as,
                                           FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                           FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
                        if ( ret != STATUS_SUCCESS ) {
                            BtlpOverrideTiaFile = INVALID_HANDLE_VALUE;
                            DBCODE(TRUE, BtlpPrintf("Can't open override TIA file %S: status=%X\n", OvrTiaFileFullPath, ret));
                        } else {
                            DBCODE(TRUE, BtlpPrintf("Override TIA will be loaded from file %S\n", OvrTiaFileFullPath));
                        }
                    }
#endif /* OVERRIDE_TIA */
                    else if ( *CurrentChar != '\0' && *CurrentChar != ';' ) {
                        // Add next control directive to the pseudo-argv array
                        argv[argc] = IniArgsP;
                        *IniArgsP++ = '-';
                        strcpy(IniArgsP, CurrentChar);
                        IniArgsP += (strlen (IniArgsP) + 1);
                        argc++;                   // We assume there are no extra chars, spaces, etc!!!!
                    }
                    
                    // Next parameter
                    if (EndOfLineChar) {
                        CurrentChar = EndOfLineChar;
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                BtlpPrintf("Can't read INI file: status=%X\n", ret);
            }
        }
        else {
            DBCODE (TRUE, BtlpPrintf("Can't open INI file\n"));
        }
    }
#endif /* RELEASE */

    DBCODE(TRUE, BtlpPrintf("\nCpuProcessInit: Unique ProcessId = 0x%I64X\n", BT_CURRENT_PROC_UID()));

    // Locate, load and initialize IA32Exec.bin component
    {
        BT_STATUS_CODE BtStatus;
        NTSTATUS status;
        static char APITableName[] = "BtgAPITable";
        static ANSI_STRING APITableString = { sizeof (APITableName) - 1,
                                              sizeof (APITableName) - 1,
                                              APITableName };
        PVOID BtransAPITableStart;

        //DBCODE (TRUE, BtlpPrintf ("\nLOADED: HANDLE=%p\n", BTGenericHandle));
        assert (F_NOT_FOUND != fBTGenericFound);
        assert (INVALID_HANDLE_VALUE != BTGenericHandle);

        // Locate IA32Exec.bin API table
        status = LdrGetProcedureAddress(BTGenericHandle, &APITableString, 0, &BtransAPITableStart);
        if (status != STATUS_SUCCESS) {
            return status;
        }
        //DBCODE (TRUE, BtlpPrintf ("\nTABLE AT: %p, status=%X\n", BtransAPITableStart, status));

        //  Perform the API table initialization
        BtlInitializeTables(BtransAPITableStart);

        // initialize IA32Exec.bin placeholder table
        {
            extern PLABEL_PTR_TYPE __imp_setjmp;
            extern PLABEL_PTR_TYPE __imp_longjmp;
            BtlAPITable.APITable[IDX_BTLIB_SETJMP].PLabelPtr  = __imp_setjmp;
            BtlAPITable.APITable[IDX_BTLIB_LONGJMP].PLabelPtr = __imp_longjmp;
//            DBCODE (FALSE, BtlpPrintf ("SETJMP: %p [%p %p] = %p [%p %p]",
//                                       BtlAPITable.APITable[IDX_BTLIB_SETJMP].PLabelPtr,
//                                       ((VOID **)(BtlAPITable.APITable[IDX_BTLIB_SETJMP].PLabelPtr))[0],
//                                       ((VOID **)(BtlAPITable.APITable[IDX_BTLIB_SETJMP].PLabelPtr))[1],
//                                       __imp_setjmp,
//                                       ((VOID **)__imp_setjmp)[0],
//                                       ((VOID **)__imp_setjmp)[1]);
//                          BtlpPrintf ("LONGJMP: %p [%p %p] = %p [%p %p]",
//                                      BtlAPITable.APITable[IDX_BTLIB_LONGJMP].PLabelPtr,
//                                      ((VOID **)(BtlAPITable.APITable[IDX_BTLIB_LONGJMP].PLabelPtr))[0],
//                                      ((VOID **)(BtlAPITable.APITable[IDX_BTLIB_LONGJMP].PLabelPtr))[1],
//                                      __imp_longjmp,
//                                      ((VOID **)__imp_longjmp)[0],
//                                      ((VOID **)__imp_longjmp)[1]));
        }

        BtStatus = BTGENERIC_START(&BtlAPITable,
                        (ULONG_PTR)BTGenericHandle,
                        (ULONG_PTR)BTGenericHandle + BtlpExtractNTHeader(BTGenericHandle)->OptionalHeader.SizeOfImage,
                        BT_TLS_OFFSET,
                        &BtlpInfoOffset,
                        &BtlpGenericIA32ContextOffset);
        if (BtStatus != BT_STATUS_SUCCESS) {
            return (BtlpBt2NtStatusCode(BtStatus));
        }
        //DBCODE(TRUE, BtlpPrintf ("BTGENERIC_START returned size 0x%X\n", BtlpInfoOffset));
        //DBCODE(TRUE, BtlpPrintf ("IA32Exec.bin will supply IA32 context on offset 0x%X\n", BtlpGenericIA32ContextOffset));
        BtlpInfoOffset = (BtlpInfoOffset + BTLIB_INFO_ALIGNMENT - 1)&~((U32)(BTLIB_INFO_ALIGNMENT - 1));
        //DBCODE(TRUE, BtlpPrintf ("Offset 0x%X\n", BtlpInfoOffset));
        * pCpuThreadDataSize = BtlpInfoOffset + BTLIB_INFO_SIZE;
        //DBCODE(TRUE, BtlpPrintf ("ProcessInit reports 0x%I64X\n",* pCpuThreadDataSize));

#ifdef OVERRIDE_TIA
        if ( BtlpOverrideTiaFile != INVALID_HANDLE_VALUE ) {
            unsigned char   OvrTiaBuffer[0xffff], 
                          * OverrideTIAData = (unsigned char *)NULL;
            int             ret;

            ret = NtReadFile(BtlpOverrideTiaFile, NULL, NULL, NULL, &iosb, (VOID *)OvrTiaBuffer, 0xffff, &offst, NULL);
            if ( ret == STATUS_SUCCESS  ||  ret == STATUS_END_OF_FILE ) {
                // File size is in iosb.Information
                unsigned int OvrTiaSize = (unsigned int)iosb.Information;

                DBCODE(TRUE, BtlpPrintf("Override TIA loaded successfully\n"));             
                OverrideTIAData = (unsigned char *)BtlMemoryAlloc(NULL, OvrTiaSize, MEM_READ|MEM_WRITE);
                
                assert(OverrideTIAData != (unsigned char *)NULL);
                memcpy(OverrideTIAData, OvrTiaBuffer, OvrTiaSize);
                BTGENERIC_USE_OVERRIDE_TIA(OvrTiaSize, OverrideTIAData);
                NtClose(BtlpOverrideTiaFile);
            } else {
                DBCODE(TRUE, BtlpPrintf("Override TIA data couldn't be loaded - read error!\n"));
            }
        }
#endif /* OVERRIDE_TIA */

        BtStatus = BTGENERIC_DEBUG_SETTINGS(argc, argv);
        if (BtStatus != BT_STATUS_SUCCESS) {
            return (BtlpBt2NtStatusCode(BtStatus));
        }
    }
    return STATUS_SUCCESS;
}

WOW64BT_IMPL NTSTATUS BTAPI(ProcessTerm)(
    HANDLE hProcess
    )
/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    Process ID or 0.

Return Value:

    NTSTATUS.

--*/
{
    // NtTerminateProcess called
    DBCODE (FALSE, BtlpPrintf ("\nCalled NtTerminateProcess (Handle=0x%X, Code=0x%X)\n",
                               ((U32 *)UlongToPtr((BTLIB_CONTEXT_IA32_PTR()->Esp)))[1],
                               ((U32 *)UlongToPtr((BTLIB_CONTEXT_IA32_PTR()->Esp)))[2]));
    // Consider which call is it
    switch (((U32 *)UlongToPtr((BTLIB_CONTEXT_IA32_PTR()->Esp)))[1]) {
      case 0: // Prepare to terminate
        BTGENERIC_NOTIFY_PREPARE_EXIT ();
        break;
      case NtCurrentProcess(): // Actually terminate
        BTGENERIC_NOTIFY_EXIT ();
        if ( BtlpWow64LogFile != INVALID_HANDLE_VALUE) {
            NtClose(BtlpWow64LogFile);
        }
        break;
      default:
        assert (!"Should not get to here!");
    }
    return STATUS_SUCCESS;
}

// IA32 JMPE instruction encoding
#pragma code_seg(".text")
static struct JMPECode {
    U32 Align4;
    U8  Align2[2];
    U8  OpCode[2];
    U32 CodeAddress;
    U32 GPAddress;
} __declspec(allocate(".text")) const BtlpWow64JMPECode = {
    0,
    {0, 0},
    {0x0f, 0xb8},   // 0F B8
    0,              // "code address"
    0               // "GP address"
};
#define WOW64_JMPE       ((VOID *)&(BtlpWow64JMPECode.OpCode))     // start of JMPE instruction

WOW64BT_IMPL NTSTATUS BTAPI(ThreadInit)(
    PVOID pPerThreadData
    )
/*++

Routine Description:

    Per-thread initialization code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/
{
    BT_STATUS_CODE BtStatus;
    NTSTATUS status;
    PTEB   pTEB;
    PTEB32 pTEB32;
    HANDLE ThreadHandle;

    {
        // Scan the workarea pages from top to bottom, so that higher addresses
        // are accessed first. This enables correct handling of the IA64 stack
        // guard page (workarea is actually allocated from IA64 stack).
        char * ByteP = (char *)pPerThreadData + BtlpInfoOffset + BTLIB_INFO_SIZE;
        *--ByteP = 0;
        while (((ULONG_PTR)ByteP -= BtlMemoryPageSize ()) >= (ULONG_PTR)pPerThreadData) {
            *ByteP = 0;
        }
        *(char *)pPerThreadData = 0;
    }
    pTEB = BT_CURRENT_TEB();
    pTEB32 = BT_TEB32_OF(pTEB);
    pTEB32->WOW32Reserved = (ULONG) ((UINT_PTR) WOW64_JMPE); // Below 4G always!

    BTLIB_INIT_BLOCKED_LOG_FLAG();

#ifndef NODEBUG
    if ( BtlpLogFilePerThread ) {
        HANDLE hTemp;
        WCHAR  LogFileFullName[1024];
        int               ret;
        static int        SeqNum = 0;
        UNICODE_STRING    LogFileName;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK   IoStatusBlock;
        LARGE_INTEGER     AllocSz = { 0, 0 };

        // Eric: Incrementing SeqNum should be replace with an atomatic operation in the future.
        swprintf(LogFileFullName, L"%s.%x.log", BtlpLogFileFullPath, SeqNum++);
        RtlInitUnicodeString(&LogFileName, LogFileFullName);
        InitializeObjectAttributes(&ObjectAttributes, &LogFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);
        ret = NtCreateFile(&hTemp, FILE_GENERIC_WRITE,
                           &ObjectAttributes, &IoStatusBlock, 
                           &AllocSz, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_SUPERSEDE,
                           FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL, 0);
        if ( ret != STATUS_SUCCESS ) {
            BTLIB_SET_LOG_FILE(INVALID_HANDLE_VALUE);
            BtlpPrintf("Can't create LOG file %S: status=%X\n", LogFileFullName, ret);
        } else {
            BTLIB_SET_LOG_FILE(hTemp);
        }
        BTLIB_SET_LOG_OFFSET(0);
    }
#endif
    status = NtDuplicateObject(NtCurrentProcess(),
                               NtCurrentThread(),
                               NtCurrentProcess(),
                               &ThreadHandle,
                               ( THREAD_GET_CONTEXT
                               | THREAD_SET_CONTEXT
                               | THREAD_QUERY_INFORMATION
                               | THREAD_SET_INFORMATION
                               | THREAD_SUSPEND_RESUME),
                               0,
                               DUPLICATE_SAME_ATTRIBUTES
                              );
    if (status == STATUS_SUCCESS) {
        BTLIB_SET_EXTERNAL_HANDLE(ThreadHandle);

        DBCODE(TRUE, BtlpPrintf("\nCpuThreadInit: TEB=%p GLST=%p\n", pTEB, BT_TLS_OF(pTEB)));

        BtStatus = BTGENERIC_THREAD_INIT(pPerThreadData, 0 , pTEB32);
        if (BtStatus != BT_STATUS_SUCCESS) {
            DBCODE(TRUE, BtlpPrintf("\nCpuThreadInit: Failed to initialize, BtStatus=%d\n", BtStatus));
            DBCODE(BtlpLogFilePerThread,  NtClose(BTLIB_LOG_FILE()));
            NtClose(BTLIB_EXTERNAL_HANDLE());
            NtTerminateThread(NtCurrentThread(),BtlpBt2NtStatusCode(BtStatus));
            return BtlpBt2NtStatusCode(BtStatus);
        }
    }
    else {
        BTLP_REPORT_NT_FAILURE("NtDuplicateObject", status);
        DBCODE(BtlpLogFilePerThread,  NtClose(BTLIB_LOG_FILE()));
        NtTerminateThread(NtCurrentThread(), status);
        return status;
    }

    // Initialize thread context
    BtlpInitIA32Context(BTLIB_CONTEXT_IA32_PTR(), pTEB32);

    //if everithing is Ok, initialize shared info and sign it with BTL_SIGNATURE
    status = BtlpInitSharedInfo();
    return status;
}

WOW64BT_IMPL NTSTATUS BTAPI(ThreadTerm)(
    VOID
    )
/*++

Routine Description:

    Per-thread termination code.  Note that this routine may not be called,
    especially if the thread is terminated abnormally.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    DBCODE(TRUE, BtlpPrintf("\nCpuThreadTerm: TEB=%p GLST=%p)\n", BT_CURRENT_TEB(), BT_CURRENT_TLS()));

    BTGENERIC_THREAD_TERMINATED ();
    DBCODE(BtlpLogFilePerThread,  NtClose(BTLIB_LOG_FILE()));
    NtClose(BTLIB_EXTERNAL_HANDLE());
    return STATUS_SUCCESS;
}

WOW64BT_IMPL VOID BTAPI(NotifyDllLoad)(
    LPWSTR DllName,
    PVOID DllBase,
    ULONG DllSize
    )
/*++

Routine Description:

    This routine get notified when application successfully load a dll.

Arguments:

    DllName - Name of the Dll the application has loaded.
    DllBase - BaseAddress of the dll.
    DllSize - size of the Dll.

Return Value:

    None.

--*/
{
    DBCODE (TRUE, BtlpPrintf ("\nModule %S loaded, base=0x%p, length=0x%08X\n", DllName, DllBase, DllSize));
    BTGENERIC_REPORT_LOAD(DllBase, DllSize, DllName);
}

WOW64BT_IMPL VOID BTAPI(NotifyDllUnload)(
    PVOID DllBase
    )
/*++

Routine Description:

    This routine get notified when application unload a dll.

Arguments:

    DllBase - BaseAddress of the dll.

Return Value:

    None.

--*/
{
    DBCODE (TRUE, BtlpPrintf ("\nModule unloaded, base=0x%p", DllBase));
    BTGENERIC_REPORT_UNLOAD(DllBase, 0 /* ? */, "UNKNOWN" /* ? */);
}

WOW64BT_IMPL VOID BTAPI(FlushInstructionCache)(
#ifndef BUILD_3604
    IN HANDLE ProcessHandle, 
#endif
    IN PVOID BaseAddress,
    IN ULONG Length,
    IN WOW64_FLUSH_REASON Reason
    )
/*++

Routine Description:

    Notify IA32Exec.bin that the specified range of addresses has become invalid,
    since some external code has altered whole or part of this range

Arguments:

    BaseAddress - start of range to flush
    Length      - number of bytes to flush
    Reason      - reason of the flush 

Return Value:

    None.

--*/
{
    BT_FLUSH_REASON BtFlushReason;
    DBCODE (TRUE,
            BtlpPrintf ("\n CpuFlushInstructionCache(BaseAddress=0x%p, Length=0x%X, Reason=%d)\n",
                        BaseAddress, (DWORD)Length, Reason));
#ifndef BUILD_3604
    if (!BtlpIsCurrentProcess(ProcessHandle)) {
        DBCODE (TRUE, BtlpPrintf ("\nDifferent process' handle=0x%p - rejected for now", ProcessHandle));
        return;
    }
#endif

    BtFlushReason = BtlpWow2BtFlushReason(Reason);

    if ((Reason == WOW64_FLUSH_FREE) && (Length == 0)) {
        //In case of NtFreeVirtualMemory(..., MEM_RELEASE) , the Length parameter is zero.
        //Calculate real region size to be freed.
        SIZE_T RegionSize;
        BOOL IsCommited;
        RegionSize = BtlpGetMemAllocSize(BaseAddress, &IsCommited);
        //Report zero legth for already decommited region - do not need flush in this case
        if (IsCommited) {
            Length = (U32)RegionSize;
            if (RegionSize > (SIZE_T)Length) {
                //region size is too big, return max. U32 value aligned to the page size
                Length = (U32)(-(int)BtlMemoryPageSize());
            }
        }
    }

    BTGENERIC_FLUSH_IA32_INSTRUCTION_CACHE(BaseAddress, Length, BtFlushReason);
}


// Suspension handling
// SUSPENSION SYNCHRONIZATION RULES:
//  a) there are two suspension commands: 
//          BtlSuspendThread - internal IA-32 Execution Layer function to suspend in-process threads
//          CpuSuspendThread - called by WOW64 when simulating the system call.
//  b) WOW64 guarantees that call to CpuSuspendThread is protected by a machine-wide mutex
//  c) IA32Exec.bin guarantees that BtlSuspendThread call is protected by a process-wide mutex and 
//     suspension in the middle of the call is disabled 
//  d) IA32Exec.bin guarantees that target thread can not call to the CpuThreadSuspend function 
//     while the BtlSuspendThread(target_thread) function executes. It can be done by 
//     closing "simulation gates" before call to BtlSuspendThread.
//
// Conclusions: 
//  a) while a thread executes suspension command, it can not be suspended by 
//  another thread.
//  b) there are at most two concurrent suspension function calls for the same target 
//  thread: internal and simulated.


static NTSTATUS BtlpEnsureSuspensionConsistency (
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle, 
    IN PTEB pTEB,
    IN U32 TryCounter,
    IN OUT PULONG PreviousSuspendCountP)
/*++

Routine Description:

    Helper function for consistent suspension of the thread
    Called when the thread is suspended, and it is guaranteed that the thread 
    is not the current one
Arguments:

    ThreadHandle    - IN thread's handle
    ProcessHandle   - IN process' handle
    pTEB            - IN pointer to thread's TEB
    TryCounter      - IN maximum attempts counter (0 means infinity)
    PreviousSuspendCountP - IN OUT pointer to thread's previous suspend count. 
                            The referenced value is updated if the function succeeds

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS status;
    U32 NumAttempts = 1;
    ULONG PrevSuspended = *PreviousSuspendCountP;
    PVOID GlstP;
    BOOL IsLocal;

    
    //Is this a local suspend function?    
    IsLocal = BtlpIsCurrentProcess(ProcessHandle);

    // Temporary workaround for IA32 debugging support. 
    //When debugger calls SuspendThread, the remote thread is blocked 
    //(by kernel???) even after NtResumeThread, so an attempt to establish 
    //a handshake protocol with this thread fails.
    //To be removed after MS fix.
    if (!IsLocal) {
        return STATUS_SUCCESS;
    }

    //Get TLS pointer of the target thread
    GlstP = BtlpGetTlsPtr(ProcessHandle, pTEB, IsLocal);
    if (GlstP == NULL) {
        return STATUS_ACCESS_VIOLATION;
    }

    for (;;) { //While target thread is not suspended in a consistent state
        BT_THREAD_SUSPEND_STATE CanonizeResult;
        CONTEXT  ContextIA64;
        BTLIB_SHARED_INFO_TYPE SharedInfo;

        // First retrieve ContextIA64 and tnen get the shared info of the target thread.
        // The order is important! It guarantees that either: 
        // a) we got ContextIA64 before context change in a concurrent SUSPENSION_REQUEST or
        // b) BTLIB_SI_HAS_SUSPEND_REQUEST(&SharedInfo) == TRUE

        ContextIA64.ContextFlags = CONTEXT_FULL;
        status = NtGetContextThread(ThreadHandle, &ContextIA64);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtGetContextThread", status);
            break;
        }
        status = BtlpReadSharedInfo(ProcessHandle, GlstP, IsLocal, &SharedInfo);
        if (status != STATUS_SUCCESS) {
            break;
        }

        //Check suspension conditions:
        //a)do not suspend thread if SUSPENSION_DISABLED or in the middle of 
        //  another SUSPEND_REQUEST
        //b)ask IA32Exec.bin in all other cases
        if (BTLIB_SI_SUSPENSION_DISABLED(&SharedInfo) || 
           (BTLIB_SI_HAS_SUSPEND_REQUEST(&SharedInfo))) {
            // suspension is currently impossible. Resume and try again
            ;
        }
        else {
            //(BTLIB_SI_HAS_SUSPEND_REQUEST(&SharedInfo) == FALSE, so....
            //Although real value of the BTLIB_SI_HAS_SUSPEND_REQUEST can be changed
            //by a concurrent SUSPENSION_REQUEST, ContextIA64 has been taken before
            //start of the SUSPENSION_REQUEST. If this is a case 
            //(there is a concurrent SUSPENSION_REQUEST), we will come up with 
            //( PrevSuspended > 0) && (CanonizeResult == BAD_SUSPEND_STATE).
            //It means that we will wait for completion of the SUSPENSION_REQUEST, 
            //which is Ok.

            // ask IA32Exec.bin to canonize context.Notice, if PrevSuspended>0, IA32Exec.bin
            // only checks possibility of canonization but does not cahange thing
            // in the thread context
            CanonizeResult = (IsLocal ? 
                BTGENERIC_CANONIZE_SUSPEND_CONTEXT(GlstP, &ContextIA64, PrevSuspended) :
                BTGENERIC_CANONIZE_SUSPEND_CONTEXT_REMOTE(ProcessHandle, GlstP, &ContextIA64, PrevSuspended));

            // Analyze canonization result
            if (CanonizeResult == SUSPEND_STATE_CONSISTENT) {
                status = STATUS_SUCCESS; //confirm suspension
                break;
            }
            else if (CanonizeResult == SUSPEND_STATE_CANONIZED) {
                //BTGENERIC_CANONIZE_SUSPEND_CONTEXT guarantees that
                //(CanonizeResult == SUSPEND_STATE_CANONIZED) -> ( PrevSuspended == 0)
                assert( PrevSuspended == 0); 
                //record updated IA64 state
                status = NtSetContextThread(ThreadHandle, &ContextIA64);
                BTLP_REPORT_NT_FAILURE("NtSetContextThread", status);
                break;
            }
            else if (CanonizeResult == SUSPEND_STATE_READY_FOR_CANONIZATION) {
                //target thread is ready to canonize itself and exit simulation;
                //lets send SUSPEND_REQUEST that will suspend the target thread
                //just on the simulation exit 

                //BTGENERIC_CANONIZE_SUSPEND_CONTEXT guarantees that
                //(CanonizeResult == SUSPEND_STATE_READY_FOR_CANONIZATION) -> ( PrevSuspended == 0)
                assert( PrevSuspended == 0); 
                //the (PrevSuspended == 0) && !(BTLIB_SI_HAS_SUSPEND_REQUEST) 
                //condition guarantees serialization of SUSPEND_REQUESTs 
                //targeted to the same thread.
                status = BtlpSendSuspensionRequest(ProcessHandle, 
                                                   ThreadHandle, 
                                                   GlstP, 
                                                   IsLocal, 
                                                   &ContextIA64,
                                                   &PrevSuspended);
                break;
            }
            else if (CanonizeResult == SUSPEND_STATE_INACCESIBLE) {
                //fatal error
                status = STATUS_UNSUCCESSFUL;
                break;
            }
            else {
                assert(CanonizeResult == BAD_SUSPEND_STATE);
                // suspension is currently impossible. Resume and try again
            }
        }
        if ((TryCounter != 0) && (NumAttempts >= TryCounter)) {
            // TryCounter reached
            status = STATUS_UNSUCCESSFUL; //reject suspension
            break;
        }

        //Next attempt
        status = NtResumeThread(ThreadHandle, NULL);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtResumeThread", status);
            break;
        }
        
        DBCODE(TRUE, BtlpPrintf ("\n%s BtlpEnsureSuspensionConsistency: canonization failed, yield... ,"
            "Target TEB = %p Caller TEB = %p  PreviousSuspendCount=0x%I64X NumAttempts = %d\n",
            (IsLocal ? "Local" : "Remote"), pTEB, BT_CURRENT_TEB(), PrevSuspended, NumAttempts));

        NtYieldExecution (); 
        /*
        {
            LARGE_INTEGER DelayInterval = { -10000*1000, -1 }; // negative: 1000ms * 10000
            NtDelayExecution (FALSE, &DelayInterval);
        }
        */
        // Stop the thread again
        status = NtSuspendThread(ThreadHandle, &PrevSuspended);
        // While the thread executes this function, it can not be suspended in a consistent
        // state. It is guaranteed by the SUSPENSION SYNCHRONIZATION RULES(see  above).
        // It means that target thread, which is now in a non-consistent state,
        // can not be in unintentionally "frozen" by a third thread.
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtSuspendThread", status);
            break;
        }
        ++NumAttempts;
    }

    if (status == STATUS_SUCCESS) {
        *PreviousSuspendCountP = PrevSuspended;
    }
    return status;
}

WOW64BT_IMPL NTSTATUS BTAPI(SuspendThread)(
    HANDLE ThreadHandle,
    HANDLE ProcessHandle,
    PTEB pTEB,
    PULONG PreviousSuspendCountP)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's
    not known if the target thread is in a consistent IA32 state.
    It attempts to produce consistent IA32 state, and if unsuccessful, tries to
    temporarily resume and then suspend the target thread again.
    In wow64 call to this function is protected by a machine-wide mutex

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process
    pTEB                  - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;

    //Do no block logging while the target thread is suspended in a non-consistent state 
    //Probably it is suspended in the middle of a logging
    BTLIB_DISABLE_BLOCKED_LOG();

    DBCODE(TRUE, BtlpPrintf ("\n%s CpuSuspendThread started: "
        "Target TEB = %p Caller TEB = %p PreviousSuspendCount = 0x%lX\n",
        (BtlpIsCurrentProcess(ProcessHandle) ? "Local" : "Remote"),
        pTEB, BT_CURRENT_TEB(), *PreviousSuspendCountP));

    status = BtlpEnsureSuspensionConsistency (
        ThreadHandle, 
        ProcessHandle, 
        pTEB, 
        0, // INFINITE
        PreviousSuspendCountP);

    DBCODE(TRUE, BtlpPrintf ("\n%s CpuSuspendThread %s: "
        "Target TEB = %p Caller TEB = %p PreviousSuspendCount = 0x%lX\n",
        (BtlpIsCurrentProcess(ProcessHandle) ? "Local" : "Remote"),
        ((status == STATUS_SUCCESS) ? "completed successfully" : "failed"),
        pTEB, BT_CURRENT_TEB(), *PreviousSuspendCountP));

    BTLIB_ENABLE_BLOCKED_LOG();

    return status;
}

BT_STATUS_CODE BtlSuspendThread(
    IN U64 ThreadId,
    IN U32 TryCounter
    )
/*++

Routine Description:

    Suspend IA-32 Execution Layer thread for internal needs. 
    Caller of the BtlSuspendThread function must guarantee that target 
    thread can not call to the suspension function (CpuThreadSuspend or BtlSuspendThread) 
    while this function executes.

Arguments:

    ThreadId    - IN Thread ID
    TryCounter  - IN Maximum number of attempts to suspend thread or 0 (INFINITY)

Return Value:

    BT_STATUS_CODE

--*/
{
    NTSTATUS status;
    HANDLE ThreadHandle;
    ULONG    PreviousSuspendCount;

    DBCODE(TRUE, BtlpPrintf ("\nBtlSuspendThread started: Target TEB = %p Caller TEB = %p TryCounter=%d\n",
        (PTEB)ThreadId, BT_CURRENT_TEB(), TryCounter));

    // Remember, we use TEB address as a thread ID
    assert (ThreadId != (U64)BT_CURRENT_TEB());

    ThreadHandle = BTLIB_EXTERNAL_HANDLE_OF((PTEB)ThreadId);
    
    //Do no block logging while the target thread is suspended in a non-consistent state 
    //Probably it is suspended in the middle of a logging
    BTLIB_DISABLE_BLOCKED_LOG();

    status = NtSuspendThread(ThreadHandle, &PreviousSuspendCount);

    if (status == STATUS_SUCCESS) {
        status = BtlpEnsureSuspensionConsistency (
            ThreadHandle, 
            NtCurrentProcess(), 
            (PTEB)ThreadId, 
            TryCounter, 
            &PreviousSuspendCount);

        if (status != STATUS_SUCCESS) {
            NtResumeThread(ThreadHandle, NULL);
        }
    }

    BTLIB_ENABLE_BLOCKED_LOG();

    DBCODE (TRUE, BtlpPrintf ("\nBtlSuspendThread %s :  Target TEB = %p Caller TEB = %p PreviousSuspendCount = 0x%lX\n",
                              ((status == STATUS_SUCCESS) ? "completed successfully" : "failed"),
                              (PTEB)ThreadId, BT_CURRENT_TEB(), PreviousSuspendCount));

    return ((status == STATUS_SUCCESS) ? BT_STATUS_SUCCESS : BT_STATUS_UNSUCCESSFUL);
}

BT_STATUS_CODE BtlResumeThread(
    IN U64 ThreadId
    )
/*++

Routine Description:

    Resume IA-32 Execution Layer thread suspended for internal needs

Arguments:

    ThreadId    - IN Thread ID

Return Value:

    BT_STATUS_CODE

--*/
{
    NTSTATUS status;
    HANDLE ThreadHandle;
    ULONG  PreviousSuspendCount;

    DBCODE (TRUE, BtlpPrintf ("\nBtlResumeThread started: Target TEB = %p Caller TEB = %p\n",
                              (PTEB)ThreadId, BT_CURRENT_TEB()));

    // Remember, we use TEB address as a thread ID
    assert (ThreadId != (U64)BT_CURRENT_TEB());

    ThreadHandle = BTLIB_EXTERNAL_HANDLE_OF((PTEB)ThreadId);
    status = NtResumeThread(ThreadHandle, &PreviousSuspendCount);

    DBCODE (TRUE, BtlpPrintf ("\nBtlResumeThread %s :  Target TEB = %p Caller TEB = %p PreviousSuspendCount = 0x%lX\n",
                              ((status == STATUS_SUCCESS) ? "completed successfully" : "failed"),
                              (PTEB)ThreadId, BT_CURRENT_TEB(), PreviousSuspendCount));

    return ((status == STATUS_SUCCESS) ? BT_STATUS_SUCCESS : BT_STATUS_UNSUCCESSFUL);
}


// Exceptions handling

WOW64BT_IMPL VOID  BTAPI(ResetToConsistentState)(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    After an exception occurs, WOW64 calls this routine to give the CPU
    a chance to clean itself up and recover the CONTEXT32 at the time of
    the fault.
    The function also has to fill in BTLIB_SIM_EXIT_INFO to be eventually
    analyzed/handled by the exception filter/handler of the BTGENERIC_RUN
    function.

    CpuResetToConsistantState() needs to:

    0) Check if the exception was from ia32 or ia64

    If exception was ia64, do nothing and return
    If exception was ia32, needs to:
    1) Needs to copy  CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
    2) reset the CONTEXT struction to be a valid ia64 state for unwinding
        this includes:
    2a) reset CONTEXT ip to a valid ia64 ip (usually
         the destination of the jmpe)
    2b) reset CONTEXT sp to a valid ia64 sp (TLS
         entry WOW64_TLS_STACKPTR64)
    2c) reset CONTEXT gp to a valid ia64 gp 
    2d) reset CONTEXT teb to a valid ia64 teb 
    2e) reset CONTEXT psr.is  (so exception handler runs as ia64 code)


Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/
{
    BT_EXCEPTION_RECORD BtExceptRecord;
    BT_EXCEPTION_CODE BtExceptCode;

    DBCODE (TRUE,
        BtlpPrintf ("\n CpuResetToConsistentState (pExceptionPointers=0x%016I64X) started\n", pExceptionPointers);
        BtlpPrintf ("\n CpuResetToConsistentState: TEB=0x%I64X", BT_CURRENT_TEB());
        BtlpPrintf ("\n CpuResetToConsistentState: TEB32=0x%I64X", BT_CURRENT_TEB32());

        BtlpPrintf ("\n CpuResetToConsistentState: ExceptionCode=0x%X",       pExceptionPointers->ExceptionRecord->ExceptionCode);
        BtlpPrintf ("\n CpuResetToConsistentState: ExceptionAddress=0x%I64X", pExceptionPointers->ExceptionRecord->ExceptionAddress);
        BtlpPrintf ("\n CpuResetToConsistentState: ExceptionFlags=0x%X",      pExceptionPointers->ExceptionRecord->ExceptionFlags);
        BtlpPrintf ("\n CpuResetToConsistentState: NumberParameters=0x%X",    pExceptionPointers->ExceptionRecord->NumberParameters);
        {
            unsigned int    n;
            for (n = 0; n < pExceptionPointers->ExceptionRecord->NumberParameters; ++n) {
                BtlpPrintf ("\n CpuResetToConsistentState: ExceptionInformation[%d]=0x%I64X",
                           n, pExceptionPointers->ExceptionRecord->ExceptionInformation[n]);
            }
        }

        BtlpPrintf ("\n\n CpuResetToConsistentState: ContextFlags: 0x%X",  pExceptionPointers->ContextRecord->ContextFlags);
        BtlpPrintf ("\n CpuResetToConsistentState: StIIP =0x%I64X", pExceptionPointers->ContextRecord->StIIP);
        BtlpPrintf ("\n CpuResetToConsistentState: StIPSR=0x%I64X", pExceptionPointers->ContextRecord->StIPSR);
        BtlpPrintf ("\n CpuResetToConsistentState: IntSp =0x%I64X", pExceptionPointers->ContextRecord->IntSp);

        BtlpPrintf ("\n *** BRET=0x%016I64X", pExceptionPointers->ContextRecord->BrRp);
        BtlpPrintf ("\n *** GP=0x%016I64X", pExceptionPointers->ContextRecord->IntGp);
        BtlpPrintf ("\n *** SP=0x%016I64X", pExceptionPointers->ContextRecord->IntSp);
        BtlpPrintf ("\n *** PREDS=0x%016I64X", pExceptionPointers->ContextRecord->Preds);
        BtlpPrintf ("\n *** AR.PFS=0x%016I64X", pExceptionPointers->ContextRecord->RsPFS);
        BtlpPrintf ("\n *** AR.BSP=0x%016I64X", pExceptionPointers->ContextRecord->RsBSP);
        BtlpPrintf ("\n *** AR.BSPSTORE=0x%016I64X", pExceptionPointers->ContextRecord->RsBSPSTORE);
        BtlpPrintf ("\n *** AR.RSC=0x%016I64X", pExceptionPointers->ContextRecord->RsRSC);
    );

    //Reconstruct consistent IA32 state
    BtlpNt2BtExceptRecord (pExceptionPointers->ExceptionRecord, &BtExceptRecord);
    BtExceptCode = BTGENERIC_IA32_CANONIZE_CONTEXT(BT_CURRENT_TLS(),
                                    pExceptionPointers->ContextRecord, 
                                    &BtExceptRecord);
    //BtExceptCode determines appearance of the exception in the simulated application: 
    //BT_NO_EXCEPT - ignore exception, otherwise raise exception with the returned code

    //Fill in BTLIB_SIM_EXIT_INFO to be eventually analyzed/handled by the exception 
    //filter/handler of the BTGENERIC_RUN function.
    if (BTLIB_INSIDE_CPU_SIMULATION()) {
        // Exception occured during code simulation in the BTGENERIC_RUN function
        if (BtExceptCode == BtExceptRecord.ExceptionCode) {
            //IA32Exec.bin decided to raise exception as is. 
            if (BeingDebugged) {
                // External debugger receives exception event before it is
                // locally processed by the CpuResetToConsistentState function.
                // In this case, BTLib silences current exception and re-raises an exact 
                // copy of this exception just after state canonization.

                // Copy IA64 exception record to be used to re-raise the exception
                BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_IA64_EXCEPTION_CODE;
                BTLIB_SIM_EXIT_INFO_PTR()->u.IA64Exception.ExceptionRecord = 
                    *(pExceptionPointers->ExceptionRecord);
                /*
                BTLIB_SIM_EXIT_INFO_PTR()->u.IA64Exception.ExceptionContext = 
                    *(pExceptionPointers->ContextRecord);
                */
             }
            else {
                //Mark the exception as unhandled and pass it to higher-level exception handler
                BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_UNHANDLED_EXCEPTION_CODE;
            }
        }
        else if (BtExceptCode == BT_NO_EXCEPT) {
            //IA32Exec.bin decided to ignore exception. Restart code simulation.
            BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_RESTART_CODE;
        }
        else {
            //IA32Exec.bin changed exception code, so wowIA32X.dll silences current exception
            //and re-raises the new one. 
            BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_EXCEPTION_CODE;
            BTLIB_SIM_EXIT_INFO_PTR()->u.ExceptionRecord.ExceptionCode = BtExceptCode;
            BTLIB_SIM_EXIT_INFO_PTR()->u.ExceptionRecord.ReturnAddr = BTLIB_CONTEXT_IA32_PTR()->Eip;
        }
    }
    
    // Dump debug info for serious errors
    DBCODE ((pExceptionPointers->ExceptionRecord->ExceptionCode & 0x80000000),
            BTGENERIC_EXCEPTION_DEBUG_PRINT ());

    BT_CURRENT_TEB()->TlsSlots[4] = (VOID *)((UINT_PTR) BTLIB_CONTEXT_IA32_PTR()->Eip);

    DBCODE (TRUE, BtlpPrintf ("\n CpuResetToConsistentState (pExceptionPointers=0x%p) completed\n", pExceptionPointers));

}

WOW64BT_IMPL VOID   BTAPI(ResetFloatingPoint)(
    VOID
    )
/*++

Routine Description:

    This function is called by the wow layer when a floating point exception
    is taken just before returning back to ia32 mode. It is used to reset
    the fp state to a non error condition if needed before running
    the ia32 exception handler.
    For IA-32 Execution Layer, this function is nop, because all handling of FP exceptions
    have already been done in CpuSimulate/CpuResetToConsistentState.

Arguments:

    None

Return Value:

    None.

--*/
{
}



int BtlpMajorFilterException(
    IN LPEXCEPTION_POINTERS pEP
    )
/*++

Routine Description:

    Exception filter for IA64 exceptions occured in the BTGENERIC_RUN function while
    simulating the IA32 code.
    The filter decides whether to handle the exception or to continue unwinding.
    Called after the ResetToConsistentState function reconstructed IA32 state and filled
    in BTLIB_SIM_EXIT_INFO.

Arguments:

    pEP                     - IN  Exception pointers structure

Return Value:

    Decision: EXCEPTION_EXECUTE_HANDLER or EXCEPTION_CONTINUE_SEARCH.

--*/
{

    assert(BTLIB_INSIDE_CPU_SIMULATION());
    //BTLIB_SIM_EXIT_INFO has been filled in by the ResetToConsistentState function.
    //The SIM_EXIT_UNHANDLED_EXCEPTION_CODE code stands for BT-unhandled exception,
    //that should be passed to higher-level handlers.

    DBCODE (TRUE, BtlpPrintf ("\n BtlpMajorFilterException: Exception code = 0x%lx", pEP->ExceptionRecord->ExceptionCode));
    DBCODE (TRUE, BtlpPrintf ("\n BtlpMajorFilterException: Exception address = 0x%p\n", pEP->ExceptionRecord->ExceptionAddress));
    DBCODE (TRUE, BtlpPrintf ("\n BtlpMajorFilterException: %s exception\n", 
        ((BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_UNHANDLED_EXCEPTION_CODE) ? 
        "Unhandled" : "BT-handled")));

    return  ((BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_UNHANDLED_EXCEPTION_CODE) ? 
               EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER);
}

// System service exception filter

int BtlpSystemServiceFilterException(
    IN LPEXCEPTION_POINTERS pEP
    ) 
/*++

Routine Description:

    Exception filter for exceptions during Wow64 NT system services

Arguments:

    pEP     - IN Exception pointers structure

Return Value:

    Decision: EXCEPTION_CONTINUE_SEARCH always.

--*/
{
    DBCODE (TRUE, BtlpPrintf ("\n BtlpSystemServiceFilterException: Exception code = 0x%lx", pEP->ExceptionRecord->ExceptionCode));
    DBCODE (TRUE, BtlpPrintf ("\n BtlpSystemServiceFilterException: Exception address = 0x%p\n", pEP->ExceptionRecord->ExceptionAddress));
    DBCODE (TRUE, BtlpPrintf ("\n BtlpSystemServiceFilterException: Excepted system service = 0x%X, called from Eip=0x%X with ESP=0x%X\n",
                                BTLIB_CONTEXT_IA32_PTR()->Eax, BTLIB_CONTEXT_IA32_PTR()->Eip, BTLIB_CONTEXT_IA32_PTR()->Esp));
                           
    return EXCEPTION_CONTINUE_SEARCH;
}

__inline VOID BtlpExitSimulation(
    VOID
    )
/*++

Routine Description:
    Exit 32-bit code simulation by performing longjmp to the current 
    setjmp addr stored in TLS 

Arguments:

    None.

Return Value:

    Never returns.

--*/
{
    longjmp (BTLIB_SIM_JMPBUF(), 1); 
}

VOID BtlpMajorExceptionHandler (
    VOID
    )
/*++

Routine Description:

    Exception handler for IA64 exceptions occured in the BTGENERIC_RUN function while
    simulating the IA32 code.
    Called after the filter decides to handle the IA64 exception.

Arguments:

    BtExceptRecordP     - IN Pointer to BT exception record

Return Value:

    None.

--*/
{
    assert(BTLIB_INSIDE_CPU_SIMULATION());
    //BTLIB_SIM_EXIT_INFO has been filled in by the ResetToConsistentState function. 
    //Just exit simulation to process BTLIB_SIM_EXIT_INFO
    assert((BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_EXCEPTION_CODE) ||
          (BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_RESTART_CODE) ||
          (BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_IA64_EXCEPTION_CODE));
    DBCODE (TRUE, BtlpPrintf ("\n BtlpMajorExceptionHandler: %s exception\n", 
        ((BTLIB_SIM_EXIT_INFO_PTR()->ExitCode == SIM_EXIT_RESTART_CODE)? "Ignore" : "Raise")));
    BtlpExitSimulation();
}

// IA32 simulation API

static VOID BtlpSimulate(
    VOID
    )
/*++

Routine Description:
    Simulate 32-bit code using the current 32-bit context. On return,
    BTLIB_EXIT_INFO is filled in with an appropriate simulation
    exit code and data.

Arguments:

    None.

Return Value:

    None.
    The function does not return normally, but rather longjmps to the current setjmp addr 
    stored in TLS .
--*/
{
        assert(BTLIB_INSIDE_CPU_SIMULATION());
        BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_RESTART_CODE;
        _try {
            BTGENERIC_RUN (); 
        } _except (BtlpMajorFilterException(GetExceptionInformation())) {
            BtlpMajorExceptionHandler ();
        }
}


VOID BtlIA32LCall (
    IN OUT BTGENERIC_IA32_CONTEXT * ia32context, 
    IN U32 returnAddress, 
    IN U32 targetAddress
    )
/*++

Routine Description:

    Exit IA32 code simulation to "execute" LCALL instruction (should not happen in NT)

Arguments:

    ia32context   - IA32 context. ia32context->Eip points to the LCALL instruction.
    returnAddress - return address of the LCALL instruction.
    targetAddress - target address of the LCALL instruction.

Return Value:

    Never returns.

--*/
{
    assert(BTLIB_INSIDE_CPU_SIMULATION());
    assert (ia32context == BTLIB_CONTEXT_IA32_PTR());
    //Fill in BTLIB_EXIT_INFO
    BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_LCALL_CODE;
    //Currently LcallRecord is not used
    BtlpExitSimulation();
}

static VOID BtlpRaiseException (
    IN BT_EXCEPTION_CODE BtExceptCode,
    IN U32 ReturnAddr
    )
/*++

Routine Description:

    This routine either simulates an x86 software interrupt, or generates a 
    CPU exception depending on a specified exception code.
    Exception code in the range 0-255 stands for software interrupt number. 
    All other BT-exception codes are converted to the corresponding OS-specific 
    exception code.

Arguments:

    BtExceptCode    - BT exception/interrupt code 
    ReturnAddr      - address of the instruction to be executed after return from 
                      exception handler

Return Value:

    None.

--*/
{
    U32 ExceptionAddr;

    //WOW64 and native Win32 provide different values for context32.Eip and 
    //ExceptionRecord.ExceptionAddress in exception handler. Current implementation 
    //resembles WOW64 behavior: 
    //context32.Eip = ExceptionRecord.ExceptionAddress = ReturnAddr
    ExceptionAddr = ReturnAddr;

    BTLIB_CONTEXT_IA32_PTR()->Eip = ExceptionAddr;
    BT_CURRENT_TEB()->TlsSlots[4] = UlongToPtr(ExceptionAddr);

    if (BtExceptCode > BT_MAX_INTERRUPT_NUMBER) {
        //fill in EXCEPTION_RECORD and simulate exception
        EXCEPTION_RECORD ExceptionRecord;

        ExceptionRecord.ExceptionCode = BtlpBt2NtExceptCode(BtExceptCode);
        ExceptionRecord.ExceptionAddress = UlongToPtr(ExceptionAddr);
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionRecord = NULL;
        if (ExceptionRecord.ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
            //set exception information for the case of inaccessable IA32 code
            ExceptionRecord.NumberParameters = 2;
            ExceptionRecord.ExceptionInformation[0] = 0;
            ExceptionRecord.ExceptionInformation[1] = ExceptionAddr;
        }
        else {
            ExceptionRecord.NumberParameters = 0;
        }
        DBCODE (TRUE, BtlpPrintf ("\nWow64RaiseException simulates exception 0x%X at IP=0x%X ESP=0x%X\n",
                                  ExceptionRecord.ExceptionCode, 
                                  BTLIB_CONTEXT_IA32_PTR()->Eip, 
                                  BTLIB_CONTEXT_IA32_PTR()->Esp));
        Wow64RaiseException (-1, &ExceptionRecord);
    }
    else {
        //simulate software interrupt
        DBCODE (TRUE, BtlpPrintf ("\nWow64RaiseException simulates interrupt %d at IP=0x%X ESP=0x%X\n",
                                  BtExceptCode, 
                                  BTLIB_CONTEXT_IA32_PTR()->Eip, 
                                  BTLIB_CONTEXT_IA32_PTR()->Esp));
        Wow64RaiseException (BtExceptCode, NULL);
    }

    DBCODE (TRUE, BtlpPrintf ("\nReturned from Wow64RaiseException IP=0x%X ESP=0x%X",
                              BTLIB_CONTEXT_IA32_PTR()->Eip, 
                              BTLIB_CONTEXT_IA32_PTR()->Esp));
}


VOID BtlIA32Interrupt(
    IN OUT BTGENERIC_IA32_CONTEXT * ia32context, 
    IN BT_EXCEPTION_CODE exceptionCode, 
    IN U32 returnAddress
    )
/*++

Routine Description:

    Exit IA32 code simulation to raise exception/interrupt

Arguments:

    ia32context   - IA32 context. The ia32context->Eip  register points to the next 
                    instruction to be simulated
    exceptionCode - exception/interrupt code
    returnAddress - address of the instruction to be executed after return from 
                    exception handler


Return Value:

    Never returns.

Note: 
    For CPU faults: ia32context.Eip = returnAddress = fault inst. Eip
    For CPU traps: ia32context.Eip = returnAddress = next Eip to execute
    For software interrupts : ia32context.Eip points 
    to instruction caused interruption (not yet executed ) and returnAddress is the 
    next Eip. 
--*/
{

    assert(BTLIB_INSIDE_CPU_SIMULATION());
    assert (ia32context == BTLIB_CONTEXT_IA32_PTR());
    //Fill in BTLIB_EXIT_INFO
    BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_EXCEPTION_CODE;
    BTLIB_SIM_EXIT_INFO_PTR()->u.ExceptionRecord.ExceptionCode = exceptionCode;
    BTLIB_SIM_EXIT_INFO_PTR()->u.ExceptionRecord.ReturnAddr = returnAddress;
    BtlpExitSimulation();
}

VOID BtlIA32JmpIA64(
    IN OUT BTGENERIC_IA32_CONTEXT * ia32context, 
    IN U32 returnAddress, 
    IN U32 targetAddress
    )
/*++

Routine Description:

    Exit IA32 code simulation to "execute" JMPE instruction.
    In Wow64, JMPE instruction indicates call to system service. The only JMPE,
    that can be reached during code simulation, is WOW64-provided JMPE,
    since no other JMPE instructions should ever appear in IA32 applications

Arguments:

    ia32context   - IA32 context. ia32context->Eip points to the JMPE instruction.
    returnAddress - Address of the next to JMPE instruction. In Wow64 it points to 
                    global pointer value
    targetAddress - target address of the JMPE instruction.

Return Value:

    Never returns.

--*/
{
    assert(BTLIB_INSIDE_CPU_SIMULATION());
    assert (ia32context == BTLIB_CONTEXT_IA32_PTR());
    // Only WOW64-provided JMPE is acceptable
    if (((VOID *)((UINT_PTR) ia32context->Eip)) != WOW64_JMPE) {
        BtlpPrintf ("\nJMPE instruction detected in Wow64 application at 0x%X", ia32context->Eip);
        BtlpPrintf ("\nWow64 JMPE is at 0x%p",  WOW64_JMPE);
        BTLIB_ABORT ();
    }
    //Fill in BTLIB_EXIT_INFO
    BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_JMPE_CODE;
    //Currently JmpeRecord is not used
    BtlpExitSimulation();
}

VOID BtlIA32Reenter(
    IN OUT BTGENERIC_IA32_CONTEXT * ia32context
    )
/*++

Routine Description:

    Exit and resume IA32 code simulation.
    Called when IA32 thread has been suspended and then resumed, etc..

Arguments:

    ia32context   - IA32 context to resume code execution with

Return Value:

    Never returns.

--*/
{
    assert(BTLIB_INSIDE_CPU_SIMULATION());
    assert (ia32context == BTLIB_CONTEXT_IA32_PTR());
    BTLIB_SIM_EXIT_INFO_PTR()->ExitCode = SIM_EXIT_RESTART_CODE;
    BtlpExitSimulation();
}


WOW64BT_IMPL VOID BTAPI(Simulate)(
    VOID
    )
/*++

Routine Description:

    RUn 32-bit code.  The CONTEXT32 has already been set up to go.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
    DBCODE (FALSE, BtlpPrintf ("\nCpuSimulate: TEB=%p, EFLAGS=0x%X", BT_CURRENT_TEB(), BTLIB_CONTEXT_IA32_PTR()->EFlags));
    for (;;) {
    
        BTLIB_CPU_SIM_DATA CpuSimData;
        
        BTLIB_ENTER_CPU_SIMULATION(&CpuSimData);
        // If exception happens during code simulation, the IA32 context pointed by 
        // BTLIB_CONTEXT_IA32_PTR() may not correspond to the real exception context
        BTLIB_CLEAR_CONSISTENT_EXCEPT_STATE(); 

        if (setjmp(CpuSimData.Jmpbuf) == 0) {
            BtlpSimulate(); // This function fills in BTLIB_SIM_EXIT_INFO and returns with longjmp
        }

        BTLIB_SET_CONSISTENT_EXCEPT_STATE();
        BTLIB_LEAVE_CPU_SIMULATION();

        //allow thread suspension at this point
        if (BTLIB_HAS_SUSPEND_REQUEST()) {
            BtlpReceiveSuspensionRequest();
        }
        //Take an action as specified in the BTLIB_SIM_EXIT_INFO
        switch (CpuSimData.ExitData.ExitCode) {

          case SIM_EXIT_JMPE_CODE:
            // Call to system service
            DBCODE (FALSE, BtlpPrintf ("\nArrived to JMPE: CONTEXT=%p", BTLIB_CONTEXT_IA32_PTR()));
            DBCODE (FALSE, BtlpPrintf ("\nArrived with: IP=0x%X", BTLIB_CONTEXT_IA32_PTR()->Eip));
            DBCODE (FALSE, BtlpPrintf ("\nArrived with: ESP=0x%X", BTLIB_CONTEXT_IA32_PTR()->Esp));

            // Simulate RET instruction - pop return address
            BTLIB_CONTEXT_IA32_PTR()->Eip = (*((U32 *)((UINT_PTR) BTLIB_CONTEXT_IA32_PTR()->Esp)));
            BTLIB_CONTEXT_IA32_PTR()->Esp += sizeof (U32);
            DBCODE (FALSE, BtlpPrintf ("\n Intend to return with: IP=0x%X ESP=0x%X", BTLIB_CONTEXT_IA32_PTR()->Eip, BTLIB_CONTEXT_IA32_PTR()->Esp));
            DBCODE (FALSE, BtlpPrintf ("\n System Service 0x%X Context32=0x%p\n", BTLIB_CONTEXT_IA32_PTR()->Eax, BTLIB_CONTEXT_IA32_PTR()));
            _try {
                BTLIB_CONTEXT_IA32_PTR()->Eax = Wow64SystemService (BTLIB_CONTEXT_IA32_PTR()->Eax, BTLIB_CONTEXT_IA32_PTR());
            } _except (BtlpSystemServiceFilterException(GetExceptionInformation())) {
                BtlpPrintf ("\nShould never get to here - system service\n");
            }
            DBCODE (FALSE, BtlpPrintf ("\n Returned from System Service: Result=0x%X", BTLIB_CONTEXT_IA32_PTR()->Eax));
            break;

          case SIM_EXIT_RESTART_CODE:
            // Restart code simulation
            DBCODE (TRUE, BtlpPrintf ("\n Resuming thread simulation: TEB=%p EIP=0x%X ESP=0x%X ",
                                      BT_CURRENT_TEB(), BTLIB_CONTEXT_IA32_PTR()->Eip, BTLIB_CONTEXT_IA32_PTR()->Esp));
            break;

          case SIM_EXIT_LCALL_CODE:
            // Simulate LCALL
            BtlpPrintf ("\n No LCALLs support in NT. Raise exception.");
            BtlpRaiseException(IA32_GEN_PROT_FAULT_INTR, BTLIB_CONTEXT_IA32_PTR()->Eip);
            break;

          case SIM_EXIT_EXCEPTION_CODE:
            // Raise IA32 exception/interrupt
            BtlpRaiseException(CpuSimData.ExitData.u.ExceptionRecord.ExceptionCode, 
                               CpuSimData.ExitData.u.ExceptionRecord.ReturnAddr);
            break;

          case SIM_EXIT_IA64_EXCEPTION_CODE:
            // Raise IA64 exception
            RtlRaiseException(&CpuSimData.ExitData.u.IA64Exception.ExceptionRecord);
            break;

          default:
            BtlpPrintf ("\n Illegal simulation exit code %d. Aborting...", CpuSimData.ExitData.ExitCode);
            BTLIB_ABORT();
            break;
        }
    }
}

// IA32 context manipulation


WOW64BT_IMPL NTSTATUS  BTAPI(GetContext)(
    HANDLE ThreadHandle,
    HANDLE ProcessHandle,
    PTEB pTEB,
    BTGENERIC_IA32_CONTEXT * Context
    )
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    pTEB           - Pointer to the target's thread TEB
    Context        - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    BT_STATUS_CODE BtStatus;
    PVOID GlstP;
    BOOL IsLocal;

    if (pTEB == NULL) {
        pTEB = BT_CURRENT_TEB();
        IsLocal = TRUE;
    } 
    else {
        IsLocal = BtlpIsCurrentProcess(ProcessHandle);
    }

    DBCODE(FALSE, BtlpPrintf ("\n%s CpuGetContext: "
        "Target TEB = %p Caller TEB = %p \n",
        (IsLocal ? "Local" : "Remote"), pTEB, BT_CURRENT_TEB()));

    GlstP = BtlpGetTlsPtr(ProcessHandle, pTEB, IsLocal);
    if (GlstP == NULL) {
        BtStatus = BT_STATUS_ACCESS_VIOLATION;
    }
    else {
        BtStatus = (IsLocal ? BTGENERIC_IA32_CONTEXT_GET(GlstP, Context) :
                              BTGENERIC_IA32_CONTEXT_GET_REMOTE(ProcessHandle, GlstP, Context));
    }
    if (BtStatus != BT_STATUS_SUCCESS) {
        return (BtlpBt2NtStatusCode(BtStatus));
    }

    return STATUS_SUCCESS;
}

WOW64BT_IMPL NTSTATUS  BTAPI(SetContext)(
    HANDLE ThreadHandle,
    HANDLE ProcessHandle,
    PTEB pTEB,
    BTGENERIC_IA32_CONTEXT * Context
    )
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, then it is
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    pTEB           - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    BT_STATUS_CODE BtStatus;
    PVOID GlstP;
    BOOL IsLocal;

    if (pTEB == NULL) {
        pTEB = BT_CURRENT_TEB();
        IsLocal = TRUE;
    } 
    else {
        IsLocal = BtlpIsCurrentProcess(ProcessHandle);
    }

    DBCODE(FALSE, BtlpPrintf ("\n%s CpuSetContext: "
        "Target TEB = %p Caller TEB = %p \n",
        (IsLocal ? "Local" : "Remote"), pTEB, BT_CURRENT_TEB()));

    GlstP = BtlpGetTlsPtr(ProcessHandle, pTEB, IsLocal);
    if (GlstP == NULL) {
        BtStatus = BT_STATUS_ACCESS_VIOLATION;
    }
    else {
        BtStatus = (IsLocal ? BTGENERIC_IA32_CONTEXT_SET(GlstP, Context) :
                              BTGENERIC_IA32_CONTEXT_SET_REMOTE(ProcessHandle, GlstP, Context));
    }
    if (BtStatus != BT_STATUS_SUCCESS) {
        return (BtlpBt2NtStatusCode(BtStatus));
    }

    return STATUS_SUCCESS;
}

WOW64BT_IMPL ULONG BTAPI(GetStackPointer)(
    VOID
    )
/*++

Routine Description:

    Returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    Value of 32-bit stack pointer.

--*/
{
    DBCODE (FALSE, BtlpPrintf ("\nBTAPICpuGetStackPointer reports ESP=0x%X TEB=%p\n", BTLIB_CONTEXT_IA32_PTR()->Esp, BT_CURRENT_TEB()));
    return BTLIB_CONTEXT_IA32_PTR()->Esp;
}

WOW64BT_IMPL VOID  BTAPI(SetStackPointer)(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit stack pointer value.

Arguments:

    Value   - new value to use for 32-bit stack pointer.

Return Value:

    None.

--*/
{
    BTLIB_CONTEXT_IA32_PTR()->Esp = Value;
    DBCODE (FALSE, BtlpPrintf ("\nBTCpuSetStackPointer set ESP=0x%X TEB=%p\n", BTLIB_CONTEXT_IA32_PTR()->Esp, BT_CURRENT_TEB()));
}

WOW64BT_IMPL VOID  BTAPI(SetInstructionPointer)(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit instruction pointer value.

Arguments:

    Value   - new value to use for 32-bit instruction pointer.

Return Value:

    None.

--*/
{
    BTLIB_CONTEXT_IA32_PTR()->Eip = Value;
    DBCODE (FALSE, BtlpPrintf ("\nBTCpuSetInstructionPointer set EIP=0x%X TEB=%p\n", BTLIB_CONTEXT_IA32_PTR()->Eip, BT_CURRENT_TEB()));
}

WOW64BT_IMPL BOOLEAN  BTAPI(ProcessDebugEvent)(
    IN LPDEBUG_EVENT DebugEventP
    )
/*++

Routine Description:

    This routine is called whenever a debug event needs to be processed.
    This would indicate that the current thread is acting as a debugger. 
    This function gives CPU simulator (IA-32 Execution Layer) a chance to decide whether 
    this debug event should be dispatched to 32-bit code or not.    

    IA-32 Execution Layer uses this callback to ignore false 64-bit exceptions and 
    re-raise real first-chance exceptions that came to debugger before
    restoring consistent state of the debuggee.
Arguments:

    DebugEventP  - Pointer to debug event to be processed

Return Value:

    This function returns TRUE if it processed the debug event,
    and doesn't wish to dispatch it to 32-bit code. Otherwise, it would 
    return FALSE, and it would dispatch the debug event to 32-bit code.


--*/
{
    BOOLEAN retval = FALSE;

    DBCODE (TRUE, BtlpPrintf ("\nBTCpuProcessDebugEvent: DebugEventCode = %d", DebugEventP->dwDebugEventCode));

    if ((DebugEventP->dwDebugEventCode == EXCEPTION_DEBUG_EVENT) &&
        DebugEventP->u.Exception.dwFirstChance) {

        NTSTATUS status;
        BOOL IsLocal;
        HANDLE ProcessHandle;
        HANDLE ThreadHandle;
        CLIENT_ID Id;
        static OBJECT_ATTRIBUTES Attributes = {sizeof(OBJECT_ATTRIBUTES), 0, 0, 0, 0, 0};

        DBCODE (TRUE, BtlpPrintf ("\nBTCpuProcessDebugEvent: dwFirstChance= %d, ExceptionCode = 0x%x", 
                                    DebugEventP->u.Exception.dwFirstChance,
                                    DebugEventP->u.Exception.ExceptionRecord.ExceptionCode));

        //Open handles of the thread&process being debugged
        Id.UniqueProcess = UlongToHandle(DebugEventP->dwProcessId);
        Id.UniqueThread  = UlongToHandle(DebugEventP->dwThreadId);
        
        status = NtOpenProcess(&ProcessHandle, 
                               PROCESS_VM_READ | PROCESS_VM_WRITE, 
                               &Attributes,
                               &Id);
        if (status != STATUS_SUCCESS) {
            BTLP_REPORT_NT_FAILURE("NtOpenProcess", status);
        }
        else {
            status = NtOpenThread(&ThreadHandle, 
                                  THREAD_QUERY_INFORMATION, 
                                  &Attributes,
                                  &Id);
            if (status != STATUS_SUCCESS) {
                BTLP_REPORT_NT_FAILURE("NtOpenThread", status);
            }
            else {
                PVOID GlstP;
                BTLIB_SHARED_INFO_TYPE SharedInfo;
                THREAD_BASIC_INFORMATION ThreadInfo;

                //Retreive TEB of the thread being debugged
                status = NtQueryInformationThread(
                    ThreadHandle,
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof(ThreadInfo),
                    0);
                if (status != STATUS_SUCCESS) {
                    BTLP_REPORT_NT_FAILURE("NtQueryInformationThread", status);
                }
                else {
                    //Is this a local notification?    
                    IsLocal = (DebugEventP->dwProcessId == BT_CURRENT_PROC_UID());

                    //Get TLS pointer of the thread being debugged
                    GlstP = BtlpGetTlsPtr(ProcessHandle, ThreadInfo.TebBaseAddress, IsLocal);
                    if (GlstP != NULL) {
                        //Check to see if the exception context is consistent
                        //If it is not, ignore current exception
                        status = BtlpReadSharedInfo(ProcessHandle, GlstP, IsLocal, &SharedInfo);
                        if (status == STATUS_SUCCESS) {
                            if (!BTLIB_SI_EXCEPT_STATE_CONSISTENT(&SharedInfo)) {
                                retval = TRUE;
                            }
                        }
                    }
                }

                NtClose(ThreadHandle);
            }

            NtClose(ProcessHandle);
        }
    }

    return retval;
}




// wowIA32X.dll APIs implementation (called by IA32Exec.bin):

U64 BtlGetThreadId(
                   VOID
                   ) {
/*++

Routine Description:

    Reports thread handle/id to be recorded in IA32Exec.bin.
    Will be passed to other wowIA32X.dll APIs.

Arguments:

    None.

Return Value:

    Handle/Id.

--*/
    return (U64)(BT_CURRENT_TEB()); // We will use TEB address as a thread ID
}

VOID BtlLockSignals(
    VOID
    )
/*++

Routine Description:

    "Do not interrupt until furhter notice" (not used in NT).

Arguments:

    None.

Return Value:

    None.

--*/
{
    // No actions in NT
}
VOID BtlUnlockSignals(
    VOID
    )
/*++

Routine Description:

    "Can be interrupted" (not used in NT).

Arguments:

    None.

Return Value:

    None.

--*/
{
    // No actions in NT
}

static U64 BtlpConvertPermissionsToBTLib (
    IN DWORD flProtect
    )
/*++

Routine Description:

    Convert mempory permissions from NT-specific to wowIA32X.dll/IA32Exec.bin.

Arguments:

    flProtect   - IN NT-specific permissions.

Return Value:

    wowIA32X.dll/IA32Exec.bin permissions

--*/
{
    U64 Permissions = 0;

    //Assuming that the system does not differentiate between read-only 
    //access and execute access
    if (flProtect & ( PAGE_READONLY
                    | PAGE_READWRITE
                    | PAGE_WRITECOPY
                    | PAGE_EXECUTE
                    | PAGE_EXECUTE_READ
                    | PAGE_EXECUTE_READWRITE
                    | PAGE_EXECUTE_WRITECOPY )) {
        Permissions |= (MEM_READ | MEM_EXECUTE);
    }

    if (flProtect & ( PAGE_READWRITE
                    | PAGE_WRITECOPY
                    | PAGE_EXECUTE_READWRITE
                    | PAGE_EXECUTE_WRITECOPY )) {
        Permissions |= MEM_WRITE;
    }

    return Permissions;
}

static DWORD BtlpConvertPermissionsFromBTLib (
    IN U64 Permissions
    )
/*++

Routine Description:

    Convert mempory permissions from wowIA32X.dll/IA32Exec.bin to NT-specific.

Arguments:

    Permissions - IN wowIA32X.dll/IA32Exec.bin permissions.

Return Value:

    NT-specific permissions

--*/
{
    if (Permissions & MEM_READ) {
        if (Permissions & MEM_WRITE) {
            if (Permissions & MEM_EXECUTE) {
                return PAGE_EXECUTE_READWRITE;
            }
            else {
                return PAGE_READWRITE;
            }
        }
        else {
            if (Permissions & MEM_EXECUTE) {
                return PAGE_EXECUTE_READ;
            }
            else {
                return PAGE_READONLY;
            }
        }
    }
    else {
        return PAGE_NOACCESS;
    }
}

VOID * BtlMemoryAlloc(
    IN VOID * startAddress,
    IN U32 size,
    IN U64 prot
    )
/*++

Routine Description:

    Allocate memory.

Arguments:

    startAddress    - IN suggested address or NULL, if any address will fit
    size            - IN requested memory size
    prot            - IN wowIA32X.dll/IA32Exec.bin permissions.

Return Value:

    Memory address of the allocated block

--*/
{
    NTSTATUS status;
    LPVOID lpAddress;
    SIZE_T dwSize = size;
    DWORD permissions = BtlpConvertPermissionsFromBTLib (prot);
    HANDLE processHandle = NtCurrentProcess();

    if (startAddress == INITIAL_DATA_ALLOC) {
        lpAddress = INITIAL_DATA_ADDRESS;
    } else {
        if (startAddress == INITIAL_CODE_ALLOC) {
            lpAddress = INITIAL_CODE_ADDRESS;
        } else {
            lpAddress = startAddress;
        }
    }

    status = NtAllocateVirtualMemory(processHandle,
                                     &lpAddress,
                                     0,
                                     &dwSize,
                                     MEM_RESERVE | MEM_COMMIT,
                                     permissions
                                     );
    if (status != STATUS_SUCCESS) {
        lpAddress = 0;
        if (startAddress != 0) {
            dwSize = size;
            status = NtAllocateVirtualMemory(processHandle,
                                             &lpAddress,
                                             0,
                                             &dwSize,
                                             MEM_RESERVE | MEM_COMMIT,
                                             permissions
                                             );
        }
    }
    return lpAddress;
}

BT_STATUS_CODE BtlMemoryFree(
    IN VOID * startAddress,
    IN U32 size
    )
/*++

Routine Description:

    Free memory.

Arguments:

    startAddress    - IN address of the area allocated by BtlMemoryAlloc
    size            - IN memory area size

Return Value:

    BT_STATUS_CODE    

--*/
{
    NTSTATUS status;
    LPVOID lpAddress = startAddress;
    SIZE_T dwSize = size;
    status = NtFreeVirtualMemory(NtCurrentProcess (),
                                 &lpAddress,
                                 &dwSize,
                                 MEM_DECOMMIT
                                 );
    if (status == STATUS_SUCCESS) {
        lpAddress = startAddress;
        dwSize = 0; // No size for release!
        status = NtFreeVirtualMemory(NtCurrentProcess (),
                                     &lpAddress,
                                     &dwSize,
                                     MEM_RELEASE
                                     );
    }
    return ((status == STATUS_SUCCESS) ? BT_STATUS_SUCCESS : BT_STATUS_UNSUCCESSFUL);
}

U32 BtlMemoryPageSize(
    VOID
    )
/*++

Routine Description:

    Report memory page size.

Arguments:

    None.

Return Value:

    Page size in bytes

--*/
{
    //It appears that NT-64 supports 4Kb page size for 32-bit system calls 
    //(VirtualAlloc, GetSystemInfo, etc.) and at the same time reports 8Kb page size to 
    //IA-32 Execution Layer. This inconsistency has been fixed by enforcing 4Kb page size in IA-32 Execution Layer. 

    #define MAX_IA32_APP_PAGE_SIZE 0x1000
    static U32 sysPageSize = 0;

    if (sysPageSize == 0) {
        SYSTEM_BASIC_INFORMATION sysinfo; 
        SIZE_T ReturnLength = 0;
        NTSTATUS status;

        status = NtQuerySystemInformation (SystemBasicInformation,
                                           &sysinfo,
                                           sizeof(sysinfo),
                                           (ULONG *)&ReturnLength
                                          );
        assert (status == STATUS_SUCCESS);
        assert (ReturnLength == sizeof(sysinfo));
        sysPageSize = ((sysinfo.PageSize < MAX_IA32_APP_PAGE_SIZE) ?  (U32)sysinfo.PageSize : MAX_IA32_APP_PAGE_SIZE);
    }
    return sysPageSize;
}

U64 BtlMemoryChangePermissions(
    IN VOID * startAddress,
    IN U32 size,
    IN U64 prot
    )
/*++

Routine Description:

    Change memory area permissions.

Arguments:

    startAddress    - IN memory address
    size            - IN memory size
    prot            - IN wowIA32X.dll/IA32Exec.bin permissions.

Return Value:

    Former permissions value

--*/
{
    NTSTATUS status;
    LPVOID RegionAddress = startAddress;
    SIZE_T RegionSize = size;
    ULONG flOldProtection;
    status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &RegionAddress,
                                    &RegionSize, 
                                    BtlpConvertPermissionsFromBTLib (prot),
                                    &flOldProtection
                                   );
    return ((status == STATUS_SUCCESS) ? BtlpConvertPermissionsToBTLib (flOldProtection) : 0);
}

U64 BtlMemoryQueryPermissions(
    IN VOID *   address,
    OUT VOID ** pRegionStart,
    OUT U32 *   pRegionSize
    )
/*++

Routine Description:

    Provide information about a memory region that contains a specified address
    and shares the same access permissions for all pages inside the region.

Arguments:

    address         - IN  memory address to be queried
    pRegionStart    - OUT pointer to the returned starting address of the region
    pRegionSize     - OUT pointer to the returned size of the region in bytes

Return Value:

    wowIA32X.dll/IA32Exec.bin access permission value shared by all pages in the region

--*/
{

    extern int BtQueryRead(VOID * Address);
    NTSTATUS status;
    MEMORY_BASIC_INFORMATION memInfo;
    SIZE_T dwRetSize;
    U64 permissions;

    status = NtQueryVirtualMemory(NtCurrentProcess(),
                                  address,
                                  MemoryBasicInformation,
                                  &memInfo,
                                  sizeof (memInfo),
                                  &dwRetSize
                                 );
    if (status == STATUS_SUCCESS) {

        *pRegionStart = memInfo.BaseAddress;
        *pRegionSize = (U32)(memInfo.RegionSize);
        if (memInfo.RegionSize > (SIZE_T)(*pRegionSize)) {
            //region size is too big, return max. U32 value aligned to the page size
            *pRegionSize = (U32)(-(int)BtlMemoryPageSize());
        }

        if (memInfo.State == MEM_COMMIT) {

            permissions = BtlpConvertPermissionsToBTLib(memInfo.Protect);

            //Check an assumption that executable page is readable 
            if ((memInfo.Protect & PAGE_EXECUTE) && !BtQueryRead(address)) {
                //Executable page is not readable - clear MEM_READ permission in order 
                //to prevent any attempt by IA32Exec.bin to read this memory
                permissions &= (~((U64)MEM_READ));
                BtlpPrintf("\nAddress %p in IA-32 process is located"
                           " in executable but unreadable page.\n",
                           address);
            }
        }
        else {
            permissions = 0;
        }

        // Temporary workaround for IA32 debugging support. 
        //To be removed after fixing FlushIC(ProcessHandle) by MS.
        if (BeingDebugged && (permissions & MEM_EXECUTE)) {
            permissions |= MEM_WRITE; //Code in the BeingDebugged process can be
                                      //modified remotely without any notification
        }
    }
    else {
        // error in NtQueryVirtualMemory cosidered as a query of inaccessible memory
        permissions = 0;
        *pRegionStart = (VOID *)((ULONG_PTR)address & ~((ULONG_PTR)BtlMemoryPageSize() - 1));
        *pRegionSize = BtlMemoryPageSize();
    }
    return permissions;
}

BT_STATUS_CODE BtlMemoryReadRemote(
    IN BT_HANDLE ProcessHandle,
    IN VOID * BaseAddress,
    OUT VOID * Buffer,
    IN U32 RequestedSize
    )
/*++

Routine Description:

    Read virtual memory of another process

Arguments:

    ProcessHandle   - IN Process handle
    BaseAddress     - IN Memory region start
    Buffer          - OUT Buffer to read data
    RequestedSize   - IN Memory region size

Return Value:

    BT_STATUS   

--*/
{
    NTSTATUS status;
    status = NtReadVirtualMemory((HANDLE)ProcessHandle,
                                 (PVOID)BaseAddress,
                                 (PVOID)Buffer,
                                 (SIZE_T)RequestedSize,
                                 NULL);
    if (status != STATUS_SUCCESS) {
        BTLP_REPORT_NT_FAILURE("NtReadVirtualMemory", status);
        return BT_STATUS_ACCESS_VIOLATION;
    }
    return BT_STATUS_SUCCESS;
}

BT_STATUS_CODE BtlMemoryWriteRemote(
    IN BT_HANDLE ProcessHandle,
    IN VOID * BaseAddress,
    IN const VOID * Buffer,
    IN U32 RequestedSize
    )
/*++

Routine Description:

    Write virtual memory of another process

Arguments:

    ProcessHandle   - IN Process handle
    BaseAddress     - IN Memory region start
    Buffer          - IN Buffer to write data from
    RequestedSize   - IN Memory region size

Return Value:

    BT_STATUS   

--*/
{
    NTSTATUS status;
    status = NtWriteVirtualMemory((HANDLE)ProcessHandle,
                                 (PVOID)BaseAddress,
                                 (PVOID)Buffer,
                                 (SIZE_T)RequestedSize,
                                 NULL);
    if (status != STATUS_SUCCESS) {
        BTLP_REPORT_NT_FAILURE("NtWriteVirtualMemory", status);
        return BT_STATUS_ACCESS_VIOLATION;
    }
    return BT_STATUS_SUCCESS;
}


// Locking support (critical sections in NT)

BT_STATUS_CODE BtlInitAccessLock(
    IN OUT VOID * lock
    )
/*++

Routine Description:

    Initialize lock (critical section)

Arguments:

    lock    - IN Pointer to the lock

Return Value:

    BT_STATUS_CODE.

--*/
{
    NTSTATUS status;
    status = RtlInitializeCriticalSection ((PRTL_CRITICAL_SECTION) lock);
    return ((status == STATUS_SUCCESS) ? BT_STATUS_SUCCESS : BT_STATUS_UNSUCCESSFUL);
}

BT_STATUS_CODE BtlLockAccess(
                  IN OUT VOID * lock,
                  IN U64 flag
                  )
/*++

Routine Description:

    Access lock (enter or try to enter critical section)

Arguments:

    lock    - IN Pointer to the lock
    flag    - IN access flag (BLOCK - unconditional, otherwise - if available)

Return Value:

    BT_STATUS_CODE

--*/
{
    if (flag == BLOCK) {
        NTSTATUS status;
        status = RtlEnterCriticalSection ((PRTL_CRITICAL_SECTION) lock);
        return ((status == STATUS_SUCCESS) ? BT_STATUS_SUCCESS : BT_STATUS_UNSUCCESSFUL);
    }
    else if (RtlTryEnterCriticalSection((PRTL_CRITICAL_SECTION) lock)) {
        return BT_STATUS_SUCCESS;
    }
    else {
        return BT_STATUS_UNSUCCESSFUL;
    }
}

VOID BtlUnlockAccess(
    IN OUT VOID * lock
    )
/*++

Routine Description:

    Release lock (critical section)

Arguments:

    lock    - IN Pointer to the lock

Return Value:

    None.

--*/
{
    NTSTATUS status;
    status = RtlLeaveCriticalSection ((PRTL_CRITICAL_SECTION) lock);
    BTLP_REPORT_NT_FAILURE("RtlLeaveCriticalSection", status);
}

VOID BtlInvalidateAccessLock(
    IN OUT VOID * lock
    )
/*++

Routine Description:

    Delete lock (critical section)

Arguments:

    lock    - IN Pointer to the lock

Return Value:

    None.

--*/
{
    NTSTATUS status;
    status = RtlDeleteCriticalSection ((PRTL_CRITICAL_SECTION) lock);
    BTLP_REPORT_NT_FAILURE("RtlDeleteCriticalSection", status);
}

// Longjmp support.
// Setjmp and longjmp must be supplied directly,
// otherwise setjmp does not work!
// Need only JMP buffer size

U32 BtlQueryJmpbufSize(
    VOID
    )
/*++

Routine Description:

    Report longjmp buffer size

Arguments:

    None

Return Value:

    Buffer size in bytes.

--*/
{
    return sizeof (_JBTYPE) * _JBLEN;
}

VOID BtlYieldThreadExecution(
    VOID
    ) 
/*++

Routine Description:

    Relinquish the remainder of the current thread's time slice 
    to any other thread that is ready to run

Arguments:

    None

Return Value:

    None

--*/
{
    NtYieldExecution();
}

VOID BtlFlushIA64InstructionCache(
                                  IN VOID * Address,
                                  IN U32 Length
                                  )
/*++

Routine Description:

    Notify kernel about a modification in IA64 code made within the given region

Arguments:

    Address - IN Pointer to start of the region
    Length  - IN Size of the region

Return Value:

    None

--*/
{
    NtFlushInstructionCache (NtCurrentProcess (), Address, (SIZE_T)Length);
}
#ifndef NODEBUG
//support Profiling debug mode
#define PROF_GEN
#endif

#ifdef PROF_GEN
// Define the method needed by IA-32 execution Layer profiling. They are
// 1. PGOFileOpen  : Open a file for writing the profiling data
// 2. PGOFileClose : Close the file opened by PGOFileOpen
// 3. PGOFileWrite : Write profiling data

// Global handle use for containing the file handle openned by PGOFileOpen.
// This handle is defined as global instead of thread specific because PGOFileXXX operation 
// is called only once per process.
HANDLE g_PGOFileHandle;

// The file offset associated with g_PGOFileHandle
LARGE_INTEGER g_PGOFileOffset;

// Function BtlPGOFileOpen
// Open a file for writing profiling data
// This is just a pseudo-function for C's fopen
// It output an (void *) type because the caller need to cast it into (FILE *) type.
VOID BtlPGOFileOpen(const char * filename,const char * mode,void ** pFileHandle)
{
UNICODE_STRING        pgoFileName;
LARGE_INTEGER         AllocSz = { 0, 0 };
OBJECT_ATTRIBUTES     ObjectAttributes;
NTSTATUS              ret;
WCHAR                 CurDirBuf[512],strInputFileName[64];
WCHAR                 CurrentDir[1024];
IO_STATUS_BLOCK       IoStatusBlock;
int i;

    DBCODE (TRUE,BtlpPrintf("PGO:fopen called: filename=%s, mode=%s\n",filename,mode));
    RtlGetCurrentDirectory_U(512, CurrentDir);
        for (i=0;filename[i] != '\0' && i<sizeof(strInputFileName)/sizeof(WCHAR)-1;i++) 
            strInputFileName[i]=(WCHAR)filename[i];
        strInputFileName[i]=(WCHAR)0;
        swprintf(CurDirBuf, L"\\DosDevices\\%s\\%s.%s", CurrentDir, ImageName, strInputFileName);
        RtlInitUnicodeString(&pgoFileName, CurDirBuf);
        InitializeObjectAttributes(&ObjectAttributes, &pgoFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (mode[0] == 'r' || mode[0] == 'R') {
        //Read mode
        ret = NtCreateFile (&g_PGOFileHandle, 
                        GENERIC_READ,
                        &ObjectAttributes, 
                        &IoStatusBlock, 
                        &AllocSz, 
                        FILE_ATTRIBUTE_NORMAL, 
                        0, 
                        FILE_OPEN,//Use FILE_OPEN, if file doesn't exist, return fail
                        FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS,
                        NULL, 0);
                       
        if ( ret != STATUS_SUCCESS ) {
            g_PGOFileHandle=NULL;
            *pFileHandle=NULL;
            return;
        }
        else {
            g_PGOFileOffset.LowPart=0;
            g_PGOFileOffset.HighPart=0;
            *pFileHandle=&g_PGOFileHandle;
            return;
        }
    }
    else if (mode[0] == 'w' || mode[0] == 'W') {
        // Write mode
        ret = NtCreateFile (&g_PGOFileHandle, 
                        FILE_GENERIC_WRITE,//GENERIC_WRITE,
                        &ObjectAttributes, 
                        &IoStatusBlock, 
                        &AllocSz, 
                        FILE_ATTRIBUTE_NORMAL, 
                        0, 
                        FILE_SUPERSEDE,
                        FILE_NON_DIRECTORY_FILE|FILE_RANDOM_ACCESS|FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL, 0);
                       
        if ( ret != STATUS_SUCCESS ) {
            DBCODE (TRUE,BtlpPrintf("Open profile file for write fail, status: %#X\n",ret));        
            BTLIB_ABORT();
            pFileHandle=NULL;
            return;
        }
        g_PGOFileOffset.LowPart=0;
        g_PGOFileOffset.HighPart=0;
        *pFileHandle=&g_PGOFileHandle;
        
        return;
    }
    else {
        *pFileHandle=NULL;
        return;
    }

}

// Function BtlPGOFileClose
// A pseudo function for C's fclose
VOID BtlPGOFileClose(void * stream)
{
    DBCODE (TRUE,BtlpPrintf("PGO:fclose called\n"));
    assert(g_PGOFileHandle);
    NtClose(g_PGOFileHandle);
    g_PGOFileHandle=NULL;
    g_PGOFileOffset.LowPart=0;
    g_PGOFileOffset.HighPart=0;
}

// Function BtlPGOFileWrite
// A pseudo function for C's fwrite
VOID BtlPGOFileWrite(const void *buffer, size_t size, void *stream)
{
    DBCODE (FALSE,BtlpPrintf("PGO:fwrite called\n"));
    assert(g_PGOFileHandle);
    assert(stream == &g_PGOFileHandle);
    // Write
    {
    NTSTATUS          ret;
    IO_STATUS_BLOCK   IoStatusBlock;
    LARGE_INTEGER offset;
        offset=g_PGOFileOffset;
        g_PGOFileOffset.LowPart+=size;
        ret = NtWriteFile(g_PGOFileHandle, NULL, NULL, NULL, &IoStatusBlock,
                    (void *)buffer, (ULONG)size, &offset, NULL);
        if ( ret != STATUS_SUCCESS ) {
            DBCODE (TRUE,BtlpPrintf("Writing profile file fail, status: %x\n",ret));        
            BTLIB_ABORT();
        }
    }
}
#else
// Define dummy function
VOID BtlPGOFileOpen(void) {}
VOID BtlPGOFileClose(void) {}
VOID BtlPGOFileWrite(void) {}
#endif

// BtlAPITable
API_TABLE_TYPE BtlAPITable={
    BTGENERIC_VERSION,         
    BTGENERIC_API_STRING,
    NO_OF_APIS,
    API_TABLE_START_OFFSET,
    {L"BTLib First Test Version (API 0.1)"},
    {
#define BTLIB_RECORD(NAME) { (PLABEL_PTR_TYPE)Btl##NAME }
        BTLIB_RECORD(GetThreadId),
        BTLIB_RECORD(IA32Reenter),
        BTLIB_RECORD(IA32LCall),
        BTLIB_RECORD(IA32Interrupt),
        BTLIB_RECORD(IA32JmpIA64),
        BTLIB_RECORD(LockSignals),
        BTLIB_RECORD(UnlockSignals),
        BTLIB_RECORD(MemoryAlloc),
        BTLIB_RECORD(MemoryFree),
        BTLIB_RECORD(MemoryPageSize),
        BTLIB_RECORD(MemoryChangePermissions),
        BTLIB_RECORD(MemoryQueryPermissions),
        BTLIB_RECORD(MemoryReadRemote),
        BTLIB_RECORD(MemoryWriteRemote),
        { (PLABEL_PTR_TYPE)NULL},//BTLIB_RECORD(Atomic_Misaligned_Load),
        { (PLABEL_PTR_TYPE)NULL},//BTLIB_RECORD(Atomic_Misaligned_Store),
        BTLIB_RECORD(SuspendThread),
        BTLIB_RECORD(ResumeThread),
        BTLIB_RECORD(InitAccessLock),
        BTLIB_RECORD(LockAccess),
        BTLIB_RECORD(UnlockAccess),
        BTLIB_RECORD(InvalidateAccessLock),
        BTLIB_RECORD(QueryJmpbufSize),
        { (PLABEL_PTR_TYPE)NULL},//BTLIB_RECORD(Setjmp),
        { (PLABEL_PTR_TYPE)NULL},//BTLIB_RECORD(Longjmp),
        BTLIB_RECORD(DebugPrint),
        BTLIB_RECORD(Abort),
        BTLIB_RECORD(VtuneCodeCreated),
        BTLIB_RECORD(VtuneCodeDeleted),
        BTLIB_RECORD(VtuneEnteringDynamicCode),
        BTLIB_RECORD(VtuneExitingDynamicCode),
        BTLIB_RECORD(VtuneCodeToTIADmpFile),
        BTLIB_RECORD(SscPerfGetCounter64),
        BTLIB_RECORD(SscPerfSetCounter64),
        BTLIB_RECORD(SscPerfSendEvent),
        BTLIB_RECORD(SscPerfEventHandle),
        BTLIB_RECORD(SscPerfCounterHandle),
        BTLIB_RECORD(YieldThreadExecution),
        BTLIB_RECORD(FlushIA64InstructionCache),
        BTLIB_RECORD(PGOFileOpen),  // Indexed by IDX_BTLIB_PSEUDO_OPEN_FILE
        BTLIB_RECORD(PGOFileClose), // Indexed by IDX_BTLIB_PSEUDO_CLOSE_FILE
        BTLIB_RECORD(PGOFileWrite)  // Indexed by IDX_BTLIB_PSEUDO_WRITE_FILE
    }
};

// wowIA32X.dll placeholder table for IA32Exec.bin plabel pointers

PLABEL_PTR_TYPE BtlPlaceHolderTable[NO_OF_APIS];

// WINNT DLL initializer/terminator
BOOL APIENTRY DllMain(HANDLE hModule, 
                      DWORD ul_reason_for_call, 
                      LPVOID lpReserved )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\bintrans\wowia32x\btlib.h ===
/*++
                                                                                
    INTEL CORPORATION PROPRIETARY INFORMATION

    This software is supplied under the terms of a license
    agreement or nondisclosure agreement with Intel Corporation
    and may not be copied or disclosed except in accordance with
    the terms of that agreement.

    Copyright (c) 1991-2002 INTEL CORPORATION

Module Name:

    BTLib.h

Abstract:
    
    Windows-specific definitions used by wowIA32X.dll
    
--*/

#ifndef BTLIB_H
#define BTLIB_H

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WOW64BTAPI_)
#define WOW64BTAPI  DECLSPEC_IMPORT
#else
#define WOW64BTAPI
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#if defined(BT_NT_BUILD)
#include <wow64t.h>
#endif
#include <stddef.h>
#include <setjmp.h>        // jmp_buf
#include <assert.h>
#include <tstr.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// 
// BTGENERIC_IA32_CONTEXT and BTGENERIC_IA64_CONTEXT and the api table types
// are shared between  wowIA32X.dll and IA32Exec.bin. 
// This h file specifies the structs using U## types
// which should be defined properly for the wowIA32X.dll library compiler:
//
// U8       8bit unsigned type
// U32      32bit unsigned type
// S32      32bit signed type
// U64      64bit unsigned type
// WCHAR    wide-character type
//

#define U8  unsigned char
#define U32 unsigned int
#define S32 int
#define U64 unsigned __int64

#include "BTGeneric.h"

#ifndef NODEBUG
#define DBCODE(switch, expr)     do{if(switch){expr;}}while(0)
#else
#define DBCODE(switch, expr)     // nothing
#endif // DEBUG

#ifdef COEXIST // IVE coexistance mode
#define BTAPI(NAME)  BTCpu##NAME
#else
#define BTAPI(NAME)  Cpu##NAME
#endif

// NT64 OS specifics

#define BT_CURRENT_TEB()             NtCurrentTeb()
#define BT_TEB32_OF(pTEB)            (PTEB32)((pTEB)->NtTib.ExceptionList)
#define BT_CURRENT_TEB32()           BT_TEB32_OF(BT_CURRENT_TEB())
#define BT_TLS_OF(pTEB)              (void *)((pTEB)->TlsSlots[1])
#define BT_CURRENT_TLS()             BT_TLS_OF(BT_CURRENT_TEB())
#define BT_TLS_OFFSET                offsetof (TEB, TlsSlots[1])
#define BTL_THREAD_INITIALIZED()     (BT_CURRENT_TLS() != 0)
//Get unique (throughout the system) ID of the current process
#define BT_CURRENT_PROC_UID() ((U64)(BT_CURRENT_TEB()->ClientId.UniqueProcess))
//Get unique (throughout the system) ID of the current thread
#define BT_CURRENT_THREAD_UID() ((U64)(BT_CURRENT_TEB()->ClientId.UniqueThread))

//Current wowIA32X.dll signature. Used to check BTLIB_INFO_TYPE compatibility from a remote process
#define BTL_SIGNATURE               0x42544C4942012E02 /*1.2*/

//STRUCTURE: BTLIB_SHARED_INFO_TYPE
//Part of the wowIA32X.dll-thread local storage accessible by remote process
//when suspended.
//LOCAL THREAD ACCESS: a)initialization, b)reading, c)changing SuspendDisabledCounter
//EXTERNAL THREAD ACCESS: a)reading, b)setting SuspendRequest
//DO NOT use conditional compilation (#ifdef) inside this structure - remote
//process suppose the same structure if BTL_SIGNATURE matches. 
//Any change to the structure must be accompanied by changing BTL_SIGNATURE.

typedef struct {
    BOOL Active;
    HANDLE ReadyEvent;  //meaningfull iff Active == TRUE  
    HANDLE ResumeEvent; //meaningfull iff Active == TRUE  
} BTLIB_SUSPEND_REQUEST;

typedef struct {
    U64     BtlSignature;
    S32     SuspendDisabledCounter;
    BTLIB_SUSPEND_REQUEST SuspendRequest;
    BOOL    ConsistentExceptionState; //TRUE if 32-bit thread state, provided by the 
                                      //CpuGetContext function, corresponds to current 
                                      //exception context.  
} BTLIB_SHARED_INFO_TYPE;

#define BTLIB_SI_SET_SIGNATURE(pBtSi)       ((pBtSi)->BtlSignature = BTL_SIGNATURE)
#define BTLIB_SI_CHECK_SIGNATURE(pBtSi)     ((pBtSi)->BtlSignature == BTL_SIGNATURE)

#define BTLIB_SI_SUSPENSION_DISABLED(pBtSi)         ((pBtSi)->SuspendDisabledCounter)
#define BTLIB_SI_INIT_SUSPENSION_PERMISSION(pBtSi)  ((pBtSi)->SuspendDisabledCounter = 0)
#define BTLIB_SI_DISABLE_SUSPENSION(pBtSi)          (((pBtSi)->SuspendDisabledCounter)++)
#define BTLIB_SI_ENABLE_SUSPENSION(pBtSi)           (((pBtSi)->SuspendDisabledCounter)--)

#define BTLIB_SI_HAS_SUSPEND_REQUEST(pBtSi)      ((pBtSi)->SuspendRequest.Active)
#define BTLIB_SI_INIT_SUSPEND_REQUEST(pBtSi)    ((pBtSi)->SuspendRequest.Active = FALSE)

#define BTLIB_SI_EXCEPT_STATE_CONSISTENT(pBtSi)       ((pBtSi)->ConsistentExceptionState)
#define BTLIB_SI_SET_CONSISTENT_EXCEPT_STATE(pBtSi)   ((pBtSi)->ConsistentExceptionState = TRUE)
#define BTLIB_SI_CLEAR_CONSISTENT_EXCEPT_STATE(pBtSi) ((pBtSi)->ConsistentExceptionState = FALSE)

// Simulation exit codes
enum BtSimExitCode {
    SIM_EXIT_EXCEPTION_CODE = 1,        //raise IA32 exception
    SIM_EXIT_UNHANDLED_EXCEPTION_CODE,  //pass BT-unhandled exception to 
                                        //higher-level exception handler
    SIM_EXIT_JMPE_CODE,                 //simulate sys.call
    SIM_EXIT_LCALL_CODE,                //simulate LCALL
    SIM_EXIT_RESTART_CODE,               //restart code simulation
    SIM_EXIT_IA64_EXCEPTION_CODE        //raise IA64 exception
};

typedef U32 BT_SIM_EXIT_CODE;

//STRUCTURE: BT_SIM_EXIT_INFO
//Represents simulation exit code and code-dependent data defining the cause of the exit
typedef struct {
    BT_SIM_EXIT_CODE ExitCode;
    union {

        //ExitCode == SIM_EXIT_EXCEPTION_CODE
        struct {
            BT_EXCEPTION_CODE ExceptionCode;
            U32 ReturnAddr;
        } ExceptionRecord;

        //ExitCode == SIM_EXIT_JMPE_CODE        
        struct {
            U32 TargetAddr;  //Currently unused
            U32 ReturnAddr;  //Currently unused
        } JmpeRecord;

       //ExitCode == SIM_EXIT_LCALL_CODE
        struct {
            U32 TargetAddr;  //Currently unused
            U32 ReturnAddr;  //Currently unused
        } LcallRecord;

       //ExitCode == SIM_EXIT_IA64_EXCEPTION_CODE
        struct {
            CONTEXT  ExceptionContext; //Currently unused
            EXCEPTION_RECORD ExceptionRecord;
        } IA64Exception;

    } u;
} BT_SIM_EXIT_INFO;

//STRUCTURE: BTLIB_CPU_SIM_DATA
//This structure keeps externally accessible data allocated by the CpuSimulate function for
//the current code simulation session. External access to this data is only possible
//if BTLIB_INSIDE_CPU_SIMULATION() = TRUE.
typedef struct {
    _JBTYPE Jmpbuf[_JBLEN];           //Current longjmp/setjmp buffer
    BT_SIM_EXIT_INFO ExitData;        //Exit info of the current simulation session
} BTLIB_CPU_SIM_DATA;

//STRUCTURE:	BTLIB_INFO_TYPE
//wowIA32X.dll-thread local storage
//DO NOT use conditional compilation (#ifdef) inside this structure - remote
//process suppose the same structure if BTL_SIGNATURE matches. 
//Any change to the structure must be accompanied by changing BTL_SIGNATURE.
typedef struct {
    BTLIB_CPU_SIM_DATA * CpuSimDataPtr;
    BTLIB_SHARED_INFO_TYPE SharedInfo;
    HANDLE ExternalHandle;
    HANDLE LogFile; /* Used in !NODEBUG only */
    DWORD  LogOffset; /* Used in !NODEBUG only */
    S32    NonBlockedLog; /* Flag that enables (zero)/disables (non-zero) blocked access to log file*/  
} BTLIB_INFO_TYPE;

#define BTLIB_INFO_SIZE sizeof(BTLIB_INFO_TYPE)
#define BTLIB_INFO_ALIGNMENT 32

extern  U32 BtlpInfoOffset;
extern  U32 BtlpGenericIA32ContextOffset;
#define BTLIB_INFO_PTR_OF(pTEB)             ((BTLIB_INFO_TYPE *)((ULONG_PTR)BT_TLS_OF(pTEB) + BtlpInfoOffset))
#define BTLIB_INFO_PTR()                    BTLIB_INFO_PTR_OF(BT_CURRENT_TEB())
#define BTLIB_CONTEXT_IA32_PTR()            ((BTGENERIC_IA32_CONTEXT *)((ULONG_PTR)BT_TLS_OF(BT_CURRENT_TEB()) + BtlpGenericIA32ContextOffset))
#define BTLIB_MEMBER_OFFSET(member)         (offsetof(BTLIB_INFO_TYPE, member) + BtlpInfoOffset)   
#define BTLIB_MEMBER_PTR(pTLS, member)      ((PVOID)((ULONG_PTR)pTLS + BTLIB_MEMBER_OFFSET(member)))

#define BTLIB_INSIDE_CPU_SIMULATION()       (BTLIB_INFO_PTR()->CpuSimDataPtr != 0)
#define BTLIB_ENTER_CPU_SIMULATION(CpuSimDataP)   (BTLIB_INFO_PTR()->CpuSimDataPtr = (CpuSimDataP))
#define BTLIB_LEAVE_CPU_SIMULATION()        (BTLIB_INFO_PTR()->CpuSimDataPtr = 0)
#define BTLIB_SIM_EXIT_INFO_PTR()           (&(BTLIB_INFO_PTR()->CpuSimDataPtr->ExitData))
#define BTLIB_SIM_JMPBUF()                  (BTLIB_INFO_PTR()->CpuSimDataPtr->Jmpbuf)
#define BTLIB_EXTERNAL_HANDLE_OF(pTEB)      (BTLIB_INFO_PTR_OF(pTEB)->ExternalHandle)
#define BTLIB_EXTERNAL_HANDLE()             BTLIB_EXTERNAL_HANDLE_OF(BT_CURRENT_TEB())
#define BTLIB_SET_EXTERNAL_HANDLE(h)        (BTLIB_INFO_PTR()->ExternalHandle = (h))
#define BTLIB_LOG_FILE_OF(pTEB)             (BTLIB_INFO_PTR_OF(pTEB)->LogFile)
#define BTLIB_LOG_FILE()                    BTLIB_LOG_FILE_OF(BT_CURRENT_TEB())
#define BTLIB_SET_LOG_FILE(h)               (BTLIB_INFO_PTR()->LogFile = (h))
#define BTLIB_LOG_OFFSET_OF(pTEB)           (BTLIB_INFO_PTR_OF(pTEB)->LogOffset)
#define BTLIB_LOG_OFFSET()                  BTLIB_LOG_OFFSET_OF(BT_CURRENT_TEB())
#define BTLIB_SET_LOG_OFFSET(n)             (BTLIB_INFO_PTR()->LogOffset = (n))
#define BTLIB_BLOCKED_LOG_DISABLED()        (BTLIB_INFO_PTR()->NonBlockedLog)
#define BTLIB_DISABLE_BLOCKED_LOG()         (BTLIB_INFO_PTR()->NonBlockedLog++)
#define BTLIB_ENABLE_BLOCKED_LOG()          (BTLIB_INFO_PTR()->NonBlockedLog--)
#define BTLIB_INIT_BLOCKED_LOG_FLAG()       (BTLIB_INFO_PTR()->NonBlockedLog = 0)

#define BTLIB_SET_SIGNATURE()               BTLIB_SI_SET_SIGNATURE(&(BTLIB_INFO_PTR()->SharedInfo))
#define BTLIB_INIT_SUSPENSION_PERMISSION()  BTLIB_SI_INIT_SUSPENSION_PERMISSION(&(BTLIB_INFO_PTR()->SharedInfo))
#define BTLIB_DISABLE_SUSPENSION()          BTLIB_SI_DISABLE_SUSPENSION(&(BTLIB_INFO_PTR()->SharedInfo))   
#define BTLIB_ENABLE_SUSPENSION()           BTLIB_SI_ENABLE_SUSPENSION(&(BTLIB_INFO_PTR()->SharedInfo))   

#define BTLIB_HAS_SUSPEND_REQUEST()         BTLIB_SI_HAS_SUSPEND_REQUEST(&(BTLIB_INFO_PTR()->SharedInfo))
#define BTLIB_INIT_SUSPEND_REQUEST()        BTLIB_SI_INIT_SUSPEND_REQUEST(&(BTLIB_INFO_PTR()->SharedInfo))

#define BTLIB_SET_CONSISTENT_EXCEPT_STATE()   BTLIB_SI_SET_CONSISTENT_EXCEPT_STATE(&(BTLIB_INFO_PTR()->SharedInfo))
#define BTLIB_CLEAR_CONSISTENT_EXCEPT_STATE() BTLIB_SI_CLEAR_CONSISTENT_EXCEPT_STATE(&(BTLIB_INFO_PTR()->SharedInfo))
#define BTLIB_EXCEPT_STATE_CONSISTENT()       BTLIB_SI_EXCEPT_STATE_CONSISTENT(&(BTLIB_INFO_PTR()->SharedInfo))

// NT WOW64 specifics

#define TYPE32(x)   ULONG
#define TYPE64(x)   ULONGLONG

//CpuFlushInstructionCache reason codes
typedef enum {
WOW64_FLUSH_FORCE,
WOW64_FLUSH_FREE,
WOW64_FLUSH_ALLOC,
WOW64_FLUSH_PROTECT
} WOW64_FLUSH_REASON; 

// Wow64 services
NTSTATUS Wow64RaiseException (DWORD InterruptNumber, PEXCEPTION_RECORD ExceptionRecord);
LONG Wow64SystemService (int Code, BTGENERIC_IA32_CONTEXT * ContextIA32);


//
//  GDT selectors - These defines are R0 selector numbers, which means
//                  they happen to match the byte offset relative to
//                  the base of the GDT.
//

#define KGDT_NULL       0
#define KGDT_R0_CODE    8
#define KGDT_R0_DATA    16
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_TSS        40
#define KGDT_R0_PCR     48
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64
#define KGDT_LDT        72
#define KGDT_DF_TSS     80
#define KGDT_NMI_TSS    88

// Initial values of the IA32 thread context registers. 
// Any value not listed below is initialized to zero 

// The value of the segment register is the OR composition of GDT offset = GDT index*8 and
// RPL = 0-3 (should never change)
#define CS_INIT_VAL  (KGDT_R3_CODE | 3);
#define DS_INIT_VAL  (KGDT_R3_DATA | 3);
#define ES_INIT_VAL  (KGDT_R3_DATA | 3);
#define FS_INIT_VAL  (KGDT_R3_TEB  | 3);
#define SS_INIT_VAL  (KGDT_R3_DATA | 3);

#define EFLAGS_INIT_VAL 0x202
#define FPCW_INIT_VAL   0x27f
#define FPTW_INIT_VAL   0xffff
#define MXCSR_INIT_VAL  0x1f80
 
#if !defined(BT_NT_BUILD)
typedef struct _CLIENT_ID32 {
    TYPE32(HANDLE) UniqueProcess;
    TYPE32(HANDLE) UniqueThread;
} CLIENT_ID32;
typedef CLIENT_ID32 *PCLIENT_ID32;
#define WIN32_CLIENT_INFO_LENGTH 62

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    TYPE32(ULONG)     Offset;
    TYPE32(ULONG_PTR) HDC;
    TYPE32(ULONG)     Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32,*PGDI_TEB_BATCH32;

typedef struct _Wx86ThreadState32 {
    TYPE32(PULONG)  CallBx86Eip;
    TYPE32(PVOID)   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD32, *PWX86THREAD32;

typedef struct _TEB32 {
    NT_TIB32 NtTib;
    TYPE32(PVOID)  EnvironmentPointer;
    CLIENT_ID32 ClientId;
    TYPE32(PVOID) ActiveRpcHandle;
    TYPE32(PVOID) ThreadLocalStoragePointer;
    TYPE32(PPEB) ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    TYPE32(PVOID) CsrClientThread;
    TYPE32(PVOID) Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    TYPE32(PVOID) WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
    TYPE32(PVOID) SystemReserved1[54];      // Used by FP emulator
    NTSTATUS ExceptionCode;         // for RaiseUserException
    UCHAR SpareBytes1[44];
    GDI_TEB_BATCH32 GdiTebBatch;      // Gdi batching
    CLIENT_ID32 RealClientId;
    TYPE32(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    TYPE32(PVOID) GdiThreadLocalInfo;
    TYPE32(ULONG_PTR) Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH]; // User32 Client Info
    TYPE32(PVOID) glDispatchTable[233];     // OpenGL
    ULONG glReserved1[29];          // OpenGL
    TYPE32(PVOID) glReserved2;              // OpenGL
    TYPE32(PVOID) glSectionInfo;            // OpenGL
    TYPE32(PVOID) glSection;                // OpenGL
    TYPE32(PVOID) glTable;                  // OpenGL
    TYPE32(PVOID) glCurrentRC;              // OpenGL
    TYPE32(PVOID) glContext;                // OpenGL
    ULONG LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    TYPE32(PVOID) DeallocationStack;
    TYPE32(PVOID) TlsSlots[TLS_MINIMUM_AVAILABLE];
    LIST_ENTRY32 TlsLinks;
    TYPE32(PVOID) Vdm;
    TYPE32(PVOID) ReservedForNtRpc;
    TYPE32(PVOID) DbgSsReserved[2];
    ULONG HardErrorsAreDisabled;
    TYPE32(PVOID) Instrumentation[16];
    TYPE32(PVOID) WinSockData;              // WinSock
    ULONG GdiBatchCount;
    ULONG Spare2;
    ULONG Spare3;
    TYPE32(PVOID) ReservedForPerf;
    TYPE32(PVOID) ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WX86THREAD32 Wx86Thread;
    TYPE32(PVOID *) TlsExpansionSlots;
} TEB32;
typedef TEB32 *PTEB32;
#endif

// wowIA32X.dll-specific globals

// BtlAPITable

extern API_TABLE_TYPE BtlAPITable;

// wowIA32X.dll placeholder table for IA32Exec.bin plabel pointers

extern PLABEL_PTR_TYPE BtlpPlaceHolderTable[NO_OF_APIS];

#ifdef __cplusplus
}
#endif

#endif  // BTLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\bintrans\wowia32x\ia64\btlibs.s ===
///*
// *    INTEL CORPORATION PROPRIETARY INFORMATION
// *
// *    This software is supplied under the terms of a license
// *    agreement or nondisclosure agreement with Intel Corporation
// *    and may not be copied or disclosed except in accordance with
// *    the terms of that agreement.
// *    Copyright (c) 1991-2002  Intel Corporation.
// *
// */
 
 .radix  C
	
.text

.global DisableFPInterrupt#
.type DisableFPInterrupt#, @function
.proc DisableFPInterrupt#
.align 32
DisableFPInterrupt:
    mov   ret0 = ar.fpsr
    mov   ret1 = ar.fpsr
    ;;
    or    ret1 = 0x3f, ret1
    ;;
    mov  ar.fpsr = ret1 
    br.ret.sptk b0
.endp DisableFPInterrupt#

.global RestoreFPInterrupt#
.type RestoreFPInterrupt#, @function
.proc RestoreFPInterrupt#
.align 32
RestoreFPInterrupt:
    .regstk 1, 0, 0, 0     // no need to alloc
    mov  ar.fpsr = in0
    br.ret.sptk b0
.endp RestoreFPInterrupt#

.global BtAtomicInc#
.type BtAtomicInc#, @function
.proc BtAtomicInc#
.align 32
BtAtomicInc:
    .regstk 1, 0, 0, 0     // no need to alloc
    fetchadd8.acq  ret0 = [in0], 1 
    br.ret.sptk b0
.endp BtAtomicInc#

.global BtAtomicDec#
.type BtAtomicDec#, @function
.proc BtAtomicDec#
.align 32
BtAtomicDec:
    .regstk 1, 0, 0, 0     // no need to alloc
    fetchadd8.rel  ret0 = [in0], -1 
    br.ret.sptk b0
.endp BtAtomicDec#

//extern int BtQueryRead(VOID * Address);

.global BtQueryRead#
.type BtQueryRead#, @function
.proc BtQueryRead#
.align 32
BtQueryRead:
    .regstk 1, 0, 0, 0     // no need to alloc
    probe.r ret0 = in0, 3; // ret0 <-- input is readable at ring 3 ? 1 : 0
    br.ret.sptk.few b0;;

.endp BtQueryRead#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\context\context.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    context.c

Abstract:

    Context conversion routines for ia64 hardware to ia32 context records

Author:

    03-Feb-2000 Charles Spriakis - Intel (v-cspira)

Revision History:

--*/


#define _WOW64CPUAPI_

#ifdef _X86_
#include "ia6432.h"
#else

#define _NTDDK_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"

#include <kxia64.h>

#endif

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//
#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_


//
// Used to mask the MxCSR from the FSR and FCR registers
//
#define WOW64_MXCSR_CONTROL_MASK    0xffC0
#define WOW64_MXCSR_STATUS_MASK     0x3f

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...);

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr);

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1);


ASSERTNAME;


VOID
Wow64CtxFromIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT ContextIa64,
    IN OUT PCONTEXT32 ContextX86
    )
/*++

Routine Description:

    This function copies the context from an ia64 context record into
    the context of an ia32 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextIa64 - Supplies an the ia64 context buffer that is the source
                  for the copy into the ia32 context area

    ContextX86 - This is an X86 context which will receive the context
                 information from the ia64 context record passed in above

Return Value:

    None.  

--*/
{
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxFromIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextX86->Ebp    = (ULONG)ContextIa64->IntTeb;
        ContextX86->SegCs  = KGDT_R3_CODE|3;
        ContextX86->Eip    = (ULONG)ContextIa64->StIIP;
        ContextX86->SegSs  = KGDT_R3_DATA|3;
        ContextX86->Esp    = (ULONG)ContextIa64->IntSp;
        ContextX86->EFlags = (ULONG)ContextIa64->Eflag;
    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
        ContextX86->Edi = (ULONG)ContextIa64->IntT6;
        ContextX86->Esi = (ULONG)ContextIa64->IntT5;
        ContextX86->Ebx = (ULONG)ContextIa64->IntT4;
        ContextX86->Edx = (ULONG)ContextIa64->IntT3;
        ContextX86->Ecx = (ULONG)ContextIa64->IntT2;
        ContextX86->Eax = (ULONG)ContextIa64->IntV0;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        //
        ContextX86->SegGs = 0;
        ContextX86->SegEs = KGDT_R3_DATA|3;
        ContextX86->SegDs = KGDT_R3_DATA|3;
        ContextX86->SegSs = KGDT_R3_DATA|3;
        ContextX86->SegFs = KGDT_R3_TEB|3;
        ContextX86->SegCs = KGDT_R3_CODE|3;
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {

        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert extended fp registers\n"));

        xmmi->ControlWord   = (USHORT)(ContextIa64->StFCR & 0xffff);
        xmmi->StatusWord    = (USHORT)(ContextIa64->StFSR & 0xffff);
        xmmi->TagWord       = (USHORT)(ContextIa64->StFSR >> 16) & 0xffff;
        xmmi->ErrorOpcode   = (USHORT)(ContextIa64->StFIR >> 48);
        xmmi->ErrorOffset   = (ULONG) (ContextIa64->StFIR & 0xffffffff);
        xmmi->ErrorSelector = (ULONG) (ContextIa64->StFIR >> 32);
        xmmi->DataOffset    = (ULONG) (ContextIa64->StFDR & 0xffffffff);
        xmmi->DataSelector  = (ULONG) (ContextIa64->StFDR >> 32);

        // MXCsr has both control and status in it
        xmmi->MXCsr         = (ULONG) (((ContextIa64->StFCR >> 32) & WOW64_MXCSR_CONTROL_MASK) |
                                    ((ContextIa64->StFSR >> 32) & WOW64_MXCSR_STATUS_MASK));

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) xmmi->RegisterArea,
                               NUMBER_OF_387REGS);

        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, (PFLOAT128) xmmi->RegisterArea);

        //
        // Finally copy the xmmi registers
        //
        Wow64CopyXMMIFromIa64Byte16(&(ContextIa64->FltS4),
                                    xmmi->Reserved3,
                                    NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert fp registers\n"));

        //
        // Copy over the floating point status/control stuff
        //
        ContextX86->FloatSave.ControlWord   = (ULONG)(ContextIa64->StFCR & 0xffff);
        ContextX86->FloatSave.StatusWord    = (ULONG)(ContextIa64->StFSR & 0xffff);
        ContextX86->FloatSave.TagWord       = (ULONG)(ContextIa64->StFSR >> 16) & 0xffff;
        ContextX86->FloatSave.ErrorOffset   = (ULONG)(ContextIa64->StFIR & 0xffffffff);
        ContextX86->FloatSave.ErrorSelector = (ULONG)(ContextIa64->StFIR >> 32);
        ContextX86->FloatSave.DataOffset    = (ULONG)(ContextIa64->StFDR & 0xffffffff);
        ContextX86->FloatSave.DataSelector  = (ULONG)(ContextIa64->StFDR >> 32);

        //
        // Copy over the FP registers into temporary space
        // Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert from spill/fill format to 80-bit double extended format
        //
        Wow64CopyIa64FromSpill((PFLOAT128) &(ContextIa64->FltT2),
                               (PFLOAT128) tmpFloat,
                               NUMBER_OF_387REGS);
        //
        // Rotate the registers appropriately
        //
        Wow64RotateFpTop(ContextIa64->StFSR, tmpFloat);

        //
        // And put them in the older FNSAVE format (packed 10 byte values)
        //
        Wow64CopyFpFromIa64Byte16(tmpFloat,
                                  ContextX86->FloatSave.RegisterArea,
                                  NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        // Ia64 -> X86
        BOOL Valid = TRUE;

        LOGPRINT((TRACELOG, "Wow64CtxFromIa64: Request to convert debug registers\n"));

#if 0 // XXX olegk - enable after clarifying problems with exceptions

        Valid &= MapDbgSlotIa64ToX86(0, ContextIa64->StIPSR, ContextIa64->DbD0, ContextIa64->DbD1, ContextIa64->DbI0, ContextIa64->DbI1, &ContextX86->Dr7, &ContextX86->Dr0);
        Valid &= MapDbgSlotIa64ToX86(1, ContextIa64->StIPSR, ContextIa64->DbD2, ContextIa64->DbD3, ContextIa64->DbI2, ContextIa64->DbI3, &ContextX86->Dr7, &ContextX86->Dr1);
        Valid &= MapDbgSlotIa64ToX86(2, ContextIa64->StIPSR, ContextIa64->DbD4, ContextIa64->DbD5, ContextIa64->DbI4, ContextIa64->DbI5, &ContextX86->Dr7, &ContextX86->Dr2);
        Valid &= MapDbgSlotIa64ToX86(3, ContextIa64->StIPSR, ContextIa64->DbD6, ContextIa64->DbD7, ContextIa64->DbI6, ContextIa64->DbI7, &ContextX86->Dr7, &ContextX86->Dr3);

        if (!Valid) {
            LOGPRINT((ERRORLOG, "Wasn't able to map IA64 debug registers consistently!\n"));
        }
#endif // XXX olegk
    }

    ContextX86->ContextFlags = Ia32ContextFlags;
}

VOID
Wow64CtxToIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextIa64
    )
/*++

Routine Description:

    This function copies the context from an ia32 context record into
    the context of an ia64 record (based on the hardware iVE register
    mappings). This function is ment to be easily usabale by various
    get/set context routines (such as those exported by wow64cpu.dll).

Arguments:

    Ia32ContextFlags - Specifies which ia32 context to copy

    ContextX86 - Supplies an the X86 context buffer that is the source
                  for the copy into the ia64 context area

    ContextIa64 - This is an ia64 context which will receive the context
                 information from the x86 context record passed in above

Return Value:

    None.

--*/
{
    FLOAT128 tmpFloat[NUMBER_OF_387REGS];

    if (Ia32ContextFlags & CONTEXT_IA64) {
        LOGPRINT((ERRORLOG, "Wow64CtxToIa64: Request with ia64 context flags (0x%x) FAILED\n", Ia32ContextFlags));
        ASSERT((Ia32ContextFlags & CONTEXT_IA64) == 0);
    }

    if ((Ia32ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) {
        //
        // And the control stuff
        //
        ContextIa64->IntTeb = ContextX86->Ebp;
        ContextIa64->StIIP = ContextX86->Eip;
        ContextIa64->IntSp = ContextX86->Esp;
        ContextIa64->Eflag = ContextX86->EFlags;

        //
        // The segments (cs and ds) are a constant, so reset them.
        // gr17 has LDT and TSS, so might as well reset
        // all of them while we're at it...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT8 = ((KGDT_LDT|3) << 32) 
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_CODE|3);

    }

    if ((Ia32ContextFlags & CONTEXT32_INTEGER) == CONTEXT32_INTEGER) {
        //
        // Now for the integer state...
        //
        ContextIa64->IntT6 = ContextX86->Edi;
        ContextIa64->IntT5 = ContextX86->Esi;
        ContextIa64->IntT4 = ContextX86->Ebx;
        ContextIa64->IntT3 = ContextX86->Edx;
        ContextIa64->IntT2 = ContextX86->Ecx;
        ContextIa64->IntV0 = ContextX86->Eax;
    }

    if ((Ia32ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) {
        //
        // These are constants (and constants are used on ia32->ia64
        // transition, not saved values) so make our life easy...
        // These values are forced in during a transition (see simulate.s)
        // so there is no point to trying to get cute and actually
        // pass in the values from the X86 context record
        //
        ContextIa64->IntT7 =  ((KGDT_R3_TEB|3) << 32)
                           | ((KGDT_R3_DATA|3) << 16)
                           | (KGDT_R3_DATA|3);
    }

    if ((Ia32ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) {
        PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) ContextX86->ExtendedRegisters;

        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert extended fp registers\n"));

        //
        // And copy over the floating point status/control stuff
        //
        ContextIa64->StFCR = (xmmi->ControlWord & 0xffff) |
                             (((ULONGLONG) xmmi->MXCsr & WOW64_MXCSR_CONTROL_MASK) << 32);

        ContextIa64->StFSR =  (xmmi->StatusWord & 0xffff) | 
                             ((xmmi->TagWord & 0xffff) << 16) | 
                             (((ULONGLONG) xmmi->MXCsr & WOW64_MXCSR_STATUS_MASK) << 32);

        ContextIa64->StFIR = (xmmi->ErrorOffset & 0xffffffff) | 
                             (xmmi->ErrorSelector << 32);

        ContextIa64->StFDR = (xmmi->DataOffset & 0xffffffff) | 
                             (xmmi->DataSelector << 32);

        //
        // Don't touch the original ia32 context. Make a copy.
        //
        memcpy(tmpFloat, xmmi->RegisterArea, 
               NUMBER_OF_387REGS * sizeof(FLOAT128));

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Copy over the FP registers.  Even though this is the new
        // FXSAVE format with 16-bytes for each register, need to
        // convert to spill/fill format from 80-bit double extended format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);

        //
        // Copy over the xmmi registers and convert them into a format
        // that spill/fill can use
        //
        Wow64CopyXMMIToIa64Byte16(xmmi->Reserved3, 
                                  &(ContextIa64->FltS4), 
                                  NUMBER_OF_XMMI_REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert fp registers\n"));

        //
        // Copy over the floating point status/control stuff
        // Leave the MXCSR stuff alone
        //
        ContextIa64->StFCR = (ContextIa64->StFCR & 0xffffffffffffe040i64) | 
                             (ContextX86->FloatSave.ControlWord & 0xffff);

        ContextIa64->StFSR = (ContextIa64->StFSR & 0xffffffff00000000i64) | 
                             (ContextX86->FloatSave.StatusWord & 0xffff) | 
                             ((ContextX86->FloatSave.TagWord & 0xffff) << 16);

        ContextIa64->StFIR = (ContextX86->FloatSave.ErrorOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.ErrorSelector << 32);

        ContextIa64->StFDR = (ContextX86->FloatSave.DataOffset & 0xffffffff) | 
                             (ContextX86->FloatSave.DataSelector << 32);


        //
        // Copy over the FP registers from packed 10-byte format
        // to 16-byte format
        //
        Wow64CopyFpToIa64Byte16(ContextX86->FloatSave.RegisterArea,
                                tmpFloat,
                                NUMBER_OF_387REGS);

        // 
        // Rotate registers back since st0 is not necessarily f8
        //
        {
            ULONGLONG RotateFSR = (NUMBER_OF_387REGS - 
                                   ((ContextIa64->StFSR >> 11) & 0x7)) << 11;
            Wow64RotateFpTop(RotateFSR, tmpFloat);
        }

        //
        // Now convert from 80 bit extended format to fill/spill format
        //
        Wow64CopyIa64ToFill((PFLOAT128) tmpFloat,
                            (PFLOAT128) &(ContextIa64->FltT2),
                            NUMBER_OF_387REGS);
    }

    if ((Ia32ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) {
        LOGPRINT((TRACELOG, "Wow64CtxToIa64: Request to convert debug registers\n"));

#if 0 // XXX olegk - enable after clarifying exception problems
        //ContextIa64->ContextFlags |= CONTEXT_DEBUG;

        // X86 -> Ia64
        MapDbgSlotX86ToIa64(0, ContextX86->Dr7, ContextX86->Dr0, &ContextIa64->StIPSR, &ContextIa64->DbD0, &ContextIa64->DbD1, &ContextIa64->DbI0, &ContextIa64->DbI1);
        MapDbgSlotX86ToIa64(1, ContextX86->Dr7, ContextX86->Dr1, &ContextIa64->StIPSR, &ContextIa64->DbD2, &ContextIa64->DbD3, &ContextIa64->DbI2, &ContextIa64->DbI3);
        MapDbgSlotX86ToIa64(2, ContextX86->Dr7, ContextX86->Dr2, &ContextIa64->StIPSR, &ContextIa64->DbD4, &ContextIa64->DbD5, &ContextIa64->DbI4, &ContextIa64->DbI5);
        MapDbgSlotX86ToIa64(3, ContextX86->Dr7, ContextX86->Dr3, &ContextIa64->StIPSR, &ContextIa64->DbD6, &ContextIa64->DbD7, &ContextIa64->DbI6, &ContextIa64->DbI7);
#endif // XXX olegk
    }
}

//
// The ia64 world uses ldfe, stfe to read/write the fp registers. These
// instructions ld/st 16 bytes at a time. Thus, the fp registers are
// packed in 16byte chunks. Alas, the ia32 world uses 10bytes per fp register
// and packs those together (as part of fnstore). So... Need to convert between
// the ia64 packed values and the ia32 packed values. Hence these
// two routines and their weird sounding names.
//

//
// This allows the compiler to be more efficient in copying 10 bytes
// without over copying...
//
#pragma pack(push, 2)
typedef struct _ia32fpbytes {
    ULONG significand_low;
    ULONG significand_high;
    USHORT exponent;
} IA32FPBYTES, *PIA32FPBYTES;
#pragma pack(pop)

VOID
Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;

    from = (PIA32FPBYTES) Byte16Fp;
    to = (PIA32FPBYTES) Byte10Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 16);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 10);
    }
}

VOID
Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    PIA32FPBYTES from, to;  // UNALIGNED

    from = (PIA32FPBYTES) Byte10Fp;
    to = (PIA32FPBYTES) Byte16Fp;

    for (i = 0; i < NumRegs; i++) {
        *to = *from;
        from = (PIA32FPBYTES) (((UINT_PTR) from) + 10);
        to = (PIA32FPBYTES) (((UINT_PTR) to) + 16);
    }
}

//
// Alas, nothing is easy. The ia32 xmmi instructions use 16 bytes and pack
// them as nice 16 byte structs. Unfortunately, ia64 handles it as 2 8-byte
// values (using just the mantissa part). So, another conversion is required
//
VOID
Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs)
{
    ULONG i;
    UNALIGNED ULONGLONG *from;
    ULONGLONG *to;

    from = (PULONGLONG) ByteXMMI;
    to = (PULONGLONG) Byte16Fp;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        *to++ = 0x1003e;        // Force the exponent part
                                // (see ia64 eas, ia32 FP section - 6.2.7
                                // for where this magic number comes from)
    }
}

VOID
Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs)
{
    ULONG i;
    ULONGLONG *from;
    UNALIGNED ULONGLONG *to;

    from = (PULONGLONG) Byte16Fp;
    to = (PULONGLONG) ByteXMMI;

    //
    // although we have NumRegs xmmi registers, each register is 16 bytes
    // wide. This code does things in 8-byte chunks, so total
    // number of times to do things is 2 * NumRegs...
    //
    NumRegs *= 2;

    for (i = 0; i < NumRegs; i++) {
        *to++ = *from++;        // Copy over the mantissa part
        from++;                 // Skip over the exponent part
    }
}

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave)
/*++

Routine Description:

    On transition from ia64 mode to ia32 (and back), the f8-f15 registers
    contain the st[0] to st[7] fp stack values. Alas, these values don't
    map one-one, so the FSR.top bits are used to determine which ia64
    register has the top of stack. We then need to rotate these registers
    since ia32 context is expecting st[0] to be the first fp register (as
    if FSR.top is zero). This routine only works on full 16-byte ia32
    saved fp data (such as from ExtendedRegisters - the FXSAVE format).
    Other routines can convert this into the older FNSAVE format.

Arguments:

    Ia64_FSR - The ia64 FSR register. Has the FSR.top needed for this routine

    ia32FxSave - The ia32 fp stack (in FXSAVE format). Each ia32 fp register
                 uses 16 bytes.

Return Value:

    None.  

--*/
{
    ULONG top = (ULONG) ((Ia64_FSR >> 11) & 0x7);

    if (top) {
        FLOAT128 tmpFloat[NUMBER_OF_387REGS];
        ULONG i;
        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            tmpFloat[i] = ia32FxSave[i];
        }

        for (i = 0; i < NUMBER_OF_387REGS; i++) {
            ia32FxSave[i] = tmpFloat[(i + top) % NUMBER_OF_387REGS];
        }
    }
}

//
// And now for the final yuck... The ia64 context for floating point
// is saved/loaded using spill/fill instructions. This format is different
// than the 10-byte fp format so we need a conversion routine from spill/fill
// to/from 10byte fp
//

VOID
Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 spill/fill format
    into the ia64 80-bit format. The exponent needs to be adjusted
    according to the EAS (5-12) regarding Memory to Floating-Point
    Register Data Translation (in the IA-64 floating point chapter).
    Conversion to 80-bit format is performed correctly for values 
    that could have been supported representations in the IA-32 stack 
    double-extended floating-point format (80-bit format): normal 
    numbers that fit in the 80-bit format, NaNs (QNaNs or SNaNs - 
    not quietized), infinity, zero, and double-extended denormals. 

Arguments:

    SpillArea - The ia64 area that has the spill format for fp

    ia64Fp - The location which will get the ia64 fp in 80-bit
             double-extended format

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((SpillArea->HighPart >> 17) & 0x01);
        ULONG64 Significand = SpillArea->LowPart; 
        ULONG64 Exponent = SpillArea->HighPart & 0x1ffff; 

        //
        // Convert from 17-bit exponent of 82-bit format to
        // 15-bit exponent of 80-bit format. This method is the
        // same method the hardware follows (keep the bottom 14 bits
        // and the msb bit, dropping bits [15:14] from the 82-bit format)
        // See ia64 Vol 1 Figure 5-9 near page 5-12...
        //
        ia64Fp->HighPart = (Exponent & 0x3fff) |          // Lower 14 bits
                           ((Exponent & 0x10000) >> 2) |  // and msb of exp
                           (Sign << 15);                  // then the sign

        ia64Fp->LowPart = Significand;

        ia64Fp++;
        SpillArea++;
    }
}

VOID
Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs)
/*++

Routine Description:

    This function copies fp values from the ia64 80-bit format
    into the fill/spill format used by the os for save/restore
    of the ia64 context. The only magic here is putting back some
    values that get truncated when converting from spill/fill to 
    80-bits. The exponent needs to be adjusted according to the
    EAS (5-12) regarding Memory to Floating Point Register Data
    Translation in the ia64 floating point chapter

Arguments:

    ia64Fp - The ia64 fp in 80-bit double-extended format

    FillArea - The ia64 area that will get the fill format for fp
                  for the copy into the ia64 context area

    NumRegs - Number of registers to convert

Return Value:

    None.

--*/
{
    ULONG i;

    for (i = 0; i < NumRegs; i++) {
        ULONG64 Sign = ((ia64Fp->HighPart >> 15) & 0x01);
        ULONG64 Significand = ia64Fp->LowPart; 
        ULONG64 Exponent = ia64Fp->HighPart & 0x7fff;

        if (Exponent) 
        {
            if (Exponent == 0x7fff) // Infinity
            {
                Exponent = 0x1ffff;
            }
            else 
            {
                ULONGLONG Rebias = 0xffff-0x3fff;
                Exponent += Rebias;
            }
        }

        FillArea->LowPart = Significand;
        FillArea->HighPart = (Sign << 17) | (Exponent & 0x1ffff);

        ia64Fp++;
        FillArea++;
    }
}

//
// Debug registers conversion
//

// XXX olegk - uncrease to 4 in future 
// (and then remove appropriate check at MapDbgSlotIa64ToX86)
#define IA64_REG_MAX_DATA_BREAKPOINTS 2

// Debug register flags.
#define IA64_DBR_RDWR           0xC000000000000000ui64
#define IA64_DBR_RD             0x8000000000000000ui64
#define IA64_DBR_WR             0x4000000000000000ui64
#define IA64_DBR_EXEC           0x8000000000000000ui64
#define IA64_DBG_MASK_MASK      0x00FFFFFFFFFFFFFFui64
#define IA64_DBG_REG_PLM_USER   0x0800000000000000ui64
#define IA64_DBG_REG_PLM_ALL    0x0F00000000000000ui64

#define X86_DR7_LOCAL_EXACT_ENABLE 0x100

ULONG 
MapDbgSlotIa64ToX86_GetSize(ULONG64 Db1, BOOL* Valid)
{
    ULONG64 Size = (~Db1 & IA64_DBG_MASK_MASK);
    if (Size > 3)
    {
        *Valid = FALSE;
    }
    return (ULONG)Size;
}

void 
MapDbgSlotIa64ToX86_InvalidateAddr(ULONG64 Db, BOOL* Valid)
{
    if (Db != (ULONG64)(ULONG)Db) 
    {
        *Valid = FALSE;
    }
}

ULONG
MapDbgSlotIa64ToX86_ExecTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize;

    if (!(Db1 >> 63)) 
    {
        *Valid = FALSE;
    }

    TypeSize = (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
   
    return TypeSize;
}

ULONG
MapDbgSlotIa64ToX86_DataTypeSize(
    UINT     Slot,
    ULONG64  Db,
    ULONG64  Db1,
    BOOL* Valid)
{
    ULONG TypeSize = (ULONG)(Db1 >> 62);

    if ((TypeSize != 1) && (TypeSize != 3))
    {
        *Valid = FALSE;
    }

    TypeSize |= (MapDbgSlotIa64ToX86_GetSize(Db1, Valid) << 2); 
    MapDbgSlotIa64ToX86_InvalidateAddr(Db, Valid);
    
    return TypeSize;
}

BOOL
MapDbgSlotIa64ToX86(
    UINT    Slot,
    ULONG64 Ipsr,
    ULONG64 DbD,
    ULONG64 DbD1,
    ULONG64 DbI,
    ULONG64 DbI1,
    ULONG*  Dr7,
    ULONG*  Dr)
{
    BOOL DataValid = TRUE, ExecValid = TRUE, Valid = TRUE;
    ULONG DataTypeSize, ExecTypeSize;

    // XXX olegk - remove this after IA64_REG_MAX_DATA_BREAKPOINTS will be changed to 4
    if (Slot >= IA64_REG_MAX_DATA_BREAKPOINTS) 
    {
        return TRUE;
    }

    DataTypeSize = MapDbgSlotIa64ToX86_DataTypeSize(Slot, DbD, DbD1, &DataValid);
    ExecTypeSize = MapDbgSlotIa64ToX86_ExecTypeSize(Slot, DbI, DbI1, &ExecValid);
    
    if (DataValid)
    {
        if (!ExecValid)
        {
            *Dr = (ULONG)DbD;
            *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                     (1 << Slot * 2) |
                     (DataTypeSize << (16 + Slot * 4)));
            return !DbI && !DbI1;
        }
    }
    else if (ExecValid)
    {
        *Dr = (ULONG)DbI;
        *Dr7 |= (X86_DR7_LOCAL_EXACT_ENABLE |
                 (1 << Slot * 2) |
                 (ExecTypeSize << (16 + Slot * 4)));
        return !DbD && !DbD1;
    }
    
    *Dr7 &= ~(X86_DR7_LOCAL_EXACT_ENABLE |  
              (0xf << (16 + Slot * 4)) | 
              (1 << Slot * 2));

    if (!DbD && !DbD1 && !DbI && !DbI1)
    {
        *Dr = 0;
        return TRUE;
    }
     
    *Dr = ~(ULONG)0;

    return FALSE;
}

void
MapDbgSlotX86ToIa64(
    UINT     Slot,
    ULONG    Dr7,
    ULONG    Dr,
    ULONG64* Ipsr,
    ULONG64* DbD,
    ULONG64* DbD1,
    ULONG64* DbI,
    ULONG64* DbI1)
{
    UINT TypeSize;
    ULONG64 Control;

    if (!(Dr7 & (1 << Slot * 2)))
    {
        return;
    }

    if (Dr == ~(ULONG)0) 
    {
        return;
    }

    TypeSize = Dr7 >> (16 + Slot * 4);

    Control = (IA64_DBG_REG_PLM_USER | IA64_DBG_MASK_MASK) & 
              ~(ULONG64)(TypeSize >> 2);

    switch (TypeSize & 0x3) 
    {
    case 0x0: // Exec
        *DbI1 = Control | IA64_DBR_EXEC;        
        *DbI = Dr;
        break;
    case 0x1: // Write
        *DbD1 = Control | IA64_DBR_WR;
        *DbD = Dr;
        break;
    case 0x3: // Read/Write
        *DbD1 = Control | IA64_DBR_RD | IA64_DBR_WR;
        *DbD = Dr;
        break;
    default:
        return;
    }
    *Ipsr |= (1i64 << PSR_DB); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\context\ia6432.h ===
#ifndef __IA64_WOW64EXTS32__
#define __IA64_WOW64EXTS32__

#define _CROSS_PLATFORM_
#define WOW64EXTS_386

#if !defined(_X86_)
    #error This file can only be included for x86 build
#else

/* include headers as if the platform were ia64, 
   because we need 64-bit stuff for context conversion */

#undef _X86_
#define _IA64_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#undef _IA64_
#define _X86_
#include <kxia64.h>

/* 32-bit stuff for context conversion are defined here */
#include <wow64.h>
#include <wow64cpu.h>
#include <vdmdbg.h>
#include <ia64cpu.h>



/* these are defined in nti386.h, since we only included ntia64.h (in nt.h), 
   we have to define these. */
#define SIZE_OF_FX_REGISTERS        128

typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT_WX86;

#endif

#endif __IA64_WOW64EXTS32__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\context\suspend.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext.

Author:

    16-Dec-1999  SamerA

Revision History:

--*/

#define _WOW64CPUAPI_

#ifdef _X86_
#include "ia6432.h"
#else
#define _NTDDK_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"
#endif

#include "cpup.h"

#include <stdio.h>
#include <stdarg.h>


ASSERTNAME;

ULONG_PTR ia32ShowContext = 0;

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...)
{
    va_list ArgList;
    int BytesWritten;
    CHAR Buffer[ 512 ];

    if ((ia32ShowContext & Flags) || (Flags == ERRORLOG))
    {
        va_start(ArgList, Format);
        BytesWritten = _vsnprintf(Buffer,
                                  sizeof(Buffer) - 1,
                                  Format,
                                  ArgList);
        if (BytesWritten > 0)
        {
            DbgPrint(Buffer);
        }
        va_end(ArgList);
    }
    
    return;
}


VOID
CpupPrintContext(
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    )
/*++

Routine Description:

    Print out the ia32 context based on the passed in cpu context

Arguments:

    str - String to print out as a header
    cpu - Pointer to the per-thread wow64 ia32 context.

Return Value:

    none

--*/
{
    DbgPrint(str);
    DbgPrint("Context addr(0x%p): EIP=0x%08x\n", &(cpu->Context), cpu->Context.Eip);
    DbgPrint("Context EAX=0x%08x, EBX=0x%08x, ECX=0x%08x, EDX=0x%08x\n",
                        cpu->Context.Eax,
                        cpu->Context.Ebx,
                        cpu->Context.Ecx,
                        cpu->Context.Edx);
    DbgPrint("Context ESP=0x%08x, EBP=0x%08x, ESI=0x%08x, EDI=0x%08x\n",
                        cpu->Context.Esp,
                        cpu->Context.Ebp,
                        cpu->Context.Esi,
                        cpu->Context.Edi);
    try {
        //
        // The stack may not yet be fully formed, so don't
        // let a missing stack cause the process to abort
        //
        DbgPrint("Context stack=0x%08x 0x%08x 0x%08x 0x%08x\n",
                        *((PULONG) cpu->Context.Esp),
                        *(((PULONG) cpu->Context.Esp) + 1),
                        *(((PULONG) cpu->Context.Esp) + 2),
                        *(((PULONG) cpu->Context.Esp) + 3));
    }
    except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
        //
        // Got an access violation, so don't print any of the stack
        //
        DbgPrint("Context stack: Can't get stack contents\n");
    }

    DbgPrint("Context EFLAGS=0x%08x\n", cpu->Context.EFlags);
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine setup the arguments for the remoted  SuspendThread call.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {

            RtlCopyMemory (Destination,
                           Source,
                           Size);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }

    } else {
        
        NtStatus = NtReadVirtualMemory (ProcessHandle,
                                        Source,
                                        Destination,
                                        Size,
                                        NULL);
    }

    return NtStatus;
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {

            RtlCopyMemory (Target,
                           Source,
                           Size);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }

    } else {
    
        NtStatus = NtWriteVirtualMemory (ProcessHandle,
                                         Target,
                                         Source,
                                         Size,
                                         NULL);
    }

    return NtStatus;
}

NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    Retrevies the context record of the specified CPU

Arguments:

    cpu     - CPU to retreive the context record for.
    Context - IN/OUT pointer to CONTEXT32 to fill in.  Context->ContextFlags
              should be used to determine how much of the context to copy.

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;
    

    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64)
        {
            LOGPRINT((ERRORLOG, "CpuGetContext: Request for ia64 context (0x%x) being FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            Context->Ebp = cpu->Context.Ebp;
            Context->Eip = cpu->Context.Eip;
            Context->SegCs = KGDT_R3_CODE|3;   // Force reality
            Context->EFlags = SANITIZE_X86EFLAGS(cpu->Context.EFlags);
            Context->Esp = cpu->Context.Esp;
            Context->SegSs = KGDT_R3_DATA|3;   // Force reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            Context->Edi = cpu->Context.Edi;
            Context->Esi = cpu->Context.Esi;
            Context->Ebx = cpu->Context.Ebx;
            Context->Edx = cpu->Context.Edx;
            Context->Ecx = cpu->Context.Ecx;
            Context->Eax = cpu->Context.Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            Context->SegDs = KGDT_R3_DATA|3;
            Context->SegEs = KGDT_R3_DATA|3;
            Context->SegFs = KGDT_R3_TEB|3;
            Context->SegGs = 0;
        }

        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            //
            // Point to the destination area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(Context->ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuGetContext: Request to get Katmai registers(0x%x)\n", ContextFlags));
            
            RtlCopyMemory(xmmi, &(cpu->Context.ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
            //
            // For performance reasons, the PCPU context has the
            // fp registers un-rotated. So we need to rotate them 
            // to get them into the standard FXSAVE format
            //
            Wow64RotateFpTop(xmmi->StatusWord, (PFLOAT128) &(xmmi->RegisterArea[0]));
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats are
            // in the ExtendedRegister area. So grab the values requested
            // from that area
            //

            //
            // Point to the source area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            //
            // Need space to rotate the registers
            //
            FLOAT128 tmpFloat[NUMBER_OF_387REGS];

            LOGPRINT((TRACELOG, "CpuGetContext: Request to get float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            Context->FloatSave.ControlWord = xmmi->ControlWord;
            Context->FloatSave.StatusWord = xmmi->StatusWord;
            Context->FloatSave.TagWord = xmmi->TagWord;
            Context->FloatSave.ErrorOffset = xmmi->ErrorOffset;
            Context->FloatSave.ErrorSelector = xmmi->ErrorSelector;
            Context->FloatSave.DataOffset = xmmi->DataOffset;
            Context->FloatSave.DataSelector = xmmi->DataSelector;

            //
            // Don't touch the original PCPU context. Make a copy.
            //
            RtlCopyMemory(tmpFloat, xmmi->RegisterArea,
                   NUMBER_OF_387REGS * sizeof(FLOAT128));

            //
            // For performance reasons, the PCPU context leaves the
            // fp registers un-rotated. So we need to rotate them now
            // to make it follow the proper FSAVE fotmat
            //
            Wow64RotateFpTop(xmmi->StatusWord, tmpFloat);

            //
            // Now get the packed 10-byte fp data registers
            //
            Wow64CopyFpFromIa64Byte16(tmpFloat,
                                      &(Context->FloatSave.RegisterArea[0]),
                                      NUMBER_OF_387REGS);
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS) 
        {
            LOGPRINT((TRACELOG, "CpuGetContext: Request to get debug registers(0x%x)\n", ContextFlags));
            Context->Dr0 = cpu->Context.Dr0;
            Context->Dr1 = cpu->Context.Dr1;
            Context->Dr2 = cpu->Context.Dr2;
            Context->Dr3 = cpu->Context.Dr3;
            Context->Dr6 = cpu->Context.Dr6;
            Context->Dr7 = cpu->Context.Dr7;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Getting ia32 context: ", cpu);
    }

    return NtStatus;
}

NTSTATUS
CpupGetContext(
    IN OUT PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return GetContextRecord(cpu, Context);
}


NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    ContextEM.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxFromIa64(Context->ContextFlags, &ContextEM, Context);
                    
        LOGPRINT((TRACELOG, "Getting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Getting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = GetContextRecord(&CpuContext, Context);
            }
            else
            {
                LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context %lx - %lx\n", 
                          CpuRemoteContext, NtStatus));

            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupGetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));
        }
    }

    return NtStatus;
}



NTSTATUS
SetContextRecord(
    IN OUT PCPUCONTEXT cpu,
    IN PCONTEXT32 Context
    )
/*++

Routine Description:

    Update the CPU's register set for the specified CPU.

Arguments:

    cpu     - CPU to update its registers
    Context - IN pointer to CONTEXT32 to use.  Context->ContextFlags
              should be used to determine how much of the context to update.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    
    try 
    {
        ContextFlags = Context->ContextFlags;
        if (ContextFlags & CONTEXT_IA64) 
        {
            LOGPRINT((ERRORLOG, "CpuSetContext: Request with ia64 context (0x%x) FAILED\n", ContextFlags));
            ASSERT((ContextFlags & CONTEXT_IA64) == 0);
        }

        if ((ContextFlags & CONTEXT32_CONTROL) == CONTEXT32_CONTROL) 
        {
            //
            // i386 control registers are:
            // ebp, eip, cs, eflag, esp and ss
            //
            cpu->Context.Ebp = Context->Ebp;
            cpu->Context.Eip = Context->Eip;
            cpu->Context.SegCs = KGDT_R3_CODE|3;   // Force Reality
            cpu->Context.EFlags = SANITIZE_X86EFLAGS(Context->EFlags);
            cpu->Context.Esp = Context->Esp;
            cpu->Context.SegSs = KGDT_R3_DATA|3;   // Force Reality
        }

        if ((ContextFlags & CONTEXT32_INTEGER)  == CONTEXT32_INTEGER)
        {
            //
            // i386 integer registers are:
            // edi, esi, ebx, edx, ecx, eax
            //
            cpu->Context.Edi = Context->Edi;
            cpu->Context.Esi = Context->Esi;
            cpu->Context.Ebx = Context->Ebx;
            cpu->Context.Edx = Context->Edx;
            cpu->Context.Ecx = Context->Ecx;
            cpu->Context.Eax = Context->Eax;
        }

        if ((ContextFlags & CONTEXT32_SEGMENTS) == CONTEXT32_SEGMENTS) 
        {
            //
            // i386 segment registers are:
            // ds, es, fs, gs
            // And since they are a constant, force them to be the right values
            //
            cpu->Context.SegDs = KGDT_R3_DATA|3;
            cpu->Context.SegEs = KGDT_R3_DATA|3;
            cpu->Context.SegFs = KGDT_R3_TEB|3;
            cpu->Context.SegGs = 0;
        }

        //
        // To follow the way ia32 does get/set context, you need to make sure
        // that the older FP context is saved second. That way if both
        // old and new context is passed in, the old takes precedence
        // This happens, for example, when handling an FP exception... The
        // exception handler says both context is available, and older programs
        // only clean up the older FP area...
        //
        if ((ContextFlags & CONTEXT32_EXTENDED_REGISTERS) == CONTEXT32_EXTENDED_REGISTERS) 
        {
            //
            // Point to the destination
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuSetContext: Request to set Katmai registers(0x%x)\n", ContextFlags));

            RtlCopyMemory(xmmi, &(Context->ExtendedRegisters[0]),
                          MAXIMUM_SUPPORTED_EXTENSION);
            //
            // For performance reasons, the PCPU context leaves the
            // fp registers un-rotated. So we need to rotate them back
            // now into the optimized format used for isa transisions
            //
            {
                ULONGLONG RotateFSR = (NUMBER_OF_387REGS -
                                       ((xmmi->StatusWord >> 11) & 0x7)) << 11;
                Wow64RotateFpTop(RotateFSR, (PFLOAT128) &(xmmi->RegisterArea[0])
);
            }
        }

        if ((ContextFlags & CONTEXT32_FLOATING_POINT) == CONTEXT32_FLOATING_POINT) 
        {
            //
            // For the ISA transition routine, these floats need to be
            // in the ExtendedRegister area. So put the values requested
            // into that area
            //
            PFXSAVE_FORMAT_WX86 xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

            LOGPRINT((TRACELOG, "CpuSetContext: Request to set float registers(0x%x)\n", ContextFlags));

            //
            // Start by grabbing the status/control portion
            //
            xmmi->ControlWord = (USHORT) (Context->FloatSave.ControlWord & 0xFFFF);
            xmmi->StatusWord = (USHORT) (Context->FloatSave.StatusWord & 0xFFFF);
            xmmi->TagWord = (USHORT) (Context->FloatSave.TagWord & 0xFFFF);
            xmmi->ErrorOffset = Context->FloatSave.ErrorOffset;
            xmmi->ErrorSelector = Context->FloatSave.ErrorSelector;
            xmmi->DataOffset = Context->FloatSave.DataOffset;
            xmmi->DataSelector = Context->FloatSave.DataSelector;

            //
            // Now get the packed 10-byte fp data registers and convert
            // them into the 16-byte format used by FXSAVE (and the
            // ISA transition routine)
            //
            Wow64CopyFpToIa64Byte16(&(Context->FloatSave.RegisterArea[0]),
                                    &(xmmi->RegisterArea[0]),
                                    NUMBER_OF_387REGS);

            //
            // For performance reasons, the PCPU context leaves the
            // fp registers un-rotated. So we need to rotate them back
            // now into the optimized format used for isa transisions
            //
            {
                ULONGLONG RotateFSR = (NUMBER_OF_387REGS -
                                       ((xmmi->StatusWord >> 11) & 0x7)) << 11;
                Wow64RotateFpTop(RotateFSR, (PFLOAT128) &(xmmi->RegisterArea[0]));
            }
        }

        if ((ContextFlags & CONTEXT32_DEBUG_REGISTERS) == CONTEXT32_DEBUG_REGISTERS)
        {
            LOGPRINT((TRACELOG, "CpuSetContext: Request to set debug registers(0x%x)\n", ContextFlags));
            cpu->Context.Dr0 = Context->Dr0;
            cpu->Context.Dr1 = Context->Dr1;
            cpu->Context.Dr2 = Context->Dr2;
            cpu->Context.Dr3 = Context->Dr3;
            cpu->Context.Dr6 = Context->Dr6;
            cpu->Context.Dr7 = Context->Dr7;
        }

        //
        // Whatever they passed in before, it's an X86 context now...
        //
        cpu->Context.ContextFlags = ContextFlags;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }


    if (ia32ShowContext & LOG_CONTEXT_GETSET) 
    {
        CpupPrintContext("Setting ia32 context: ", cpu);
    }

    return NtStatus;
}

NTSTATUS
CpupSetContext(
    IN PCONTEXT32 Context
    )
/*++

Routine Description:

    This routine sets the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return SetContextRecord(cpu, Context);
}



NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CONTEXT ContextEM;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;
    NtStatus = NtGetContextThread(ThreadHandle,
                                  &ContextEM);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupGetContextThread: NtGetContextThread (%lx) failed - %lx\n", 
                  ThreadHandle, NtStatus));

        return NtStatus;
    }

    if (ContextEM.StIPSR & (1i64 << PSR_IS))
    {
        Wow64CtxToIa64(Context->ContextFlags, Context, &ContextEM);
        NtStatus = NtSetContextThread(ThreadHandle, &ContextEM);
        LOGPRINT((TRACELOG, "Setting context while thread is executing 32-bit instructions - %lx\n", NtStatus));
    }
    else
    {
        LOGPRINT((TRACELOG, "Setting context while thread is executing 64-bit instructions\n"));
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                                  &CpuRemoteContext,
                                  sizeof(CpuRemoteContext));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupReadBuffer(ProcessHandle,
                                      CpuRemoteContext,
                                      &CpuContext,
                                      sizeof(CpuContext));

            if (NT_SUCCESS(NtStatus))
            {    
                NtStatus = SetContextRecord(&CpuContext, Context);

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = CpupWriteBuffer(ProcessHandle,
                                               CpuRemoteContext,
                                               &CpuContext,
                                               sizeof(CpuContext));
                }
                else
                {
                    LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context %lx - %lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpupSetContextThread: Couldn't read CPU context address - %lx\n", 
                      NtStatus));

        }
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\cpu\common.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Platform independent functions for the WOW64 cpu component.

Author:

    05-June-1998 BarryBo

--*/

#define _WOW64CPUAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64.h"
#include "wow64cpu.h"

ASSERTNAME;

//
// Define the length of the history buffer. A length of zero means no
// history is being kept.
//

#if defined(WOW64_HISTORY)

ULONG HistoryLength;

#endif

NTSTATUS
CpupReadRegistryDword (
    IN HANDLE RegistryHandle,
    IN PWSTR ValueName,
    OUT PDWORD RegistryDword)
/*++

Routine Description:

    Check the registry for the given registry value name and if it
    exists, copy the DWORD associated into the variable supplied by the caller

Arguments:

    RegistryHandle - Contains an open handle to a registry key
    ValueName      - The name of the registry value to look up
    RegistryDword  - If the lookup was successful, this gets the DWORD value
                     that was associated with the registry name. If the
                     lookup was unsuccessful, this value is unchanged.

Return Value:

    NTSTATUS - Result of the NT Quesry Value Key.

--*/

{

    NTSTATUS st;

    UNICODE_STRING KeyName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR Buffer[100];
    ULONG ResultLength;

    RtlInitUnicodeString(&KeyName, ValueName);
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    st = NtQueryValueKey(RegistryHandle,
                                 &KeyName,
                                 KeyValuePartialInformation,
                                 KeyValueInformation,
                                 sizeof(Buffer),
                                 &ResultLength);

    if (NT_SUCCESS(st) && (KeyValueInformation->Type == REG_DWORD)) {

        //
        // We found a valid registry value name and it is holding a DWORD
        // so grab the associated value and pass it back to the caller
        //

        *RegistryDword = *(DWORD *)(KeyValueInformation->Data);
    }

    return st;
}

#if defined(WOW64_HISTORY)

VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    )

/*++

Routine Description:

    Checks if the registry if service history should be enabled. A missing
    key means disable.

Arguments:

    pImageName - the name of the image. DO NOT SAVE THIS POINTER. The contents
                 are freed up by wow64.dll when we return from the call

    pHistoryLength - size of history buffer. If history is not enabled,
                 returns zero

Return Value:

    None

--*/

{

    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;

    NTSTATUS st;

    DWORD EnableHistory = FALSE;        // assume disabled
    HANDLE hKey = NULL;                 // non-null means we have an open key

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey(%ws) called.\n", pImageName));

    //
    // Initialize the size of the histry buffer assuming no history buffer
    //

    *pHistoryLength = 0;

    //
    // Check in the HKLM area...
    //

    RtlInitUnicodeString(&KeyName, CPUHISTORY_MACHINE_SUBKEY);
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);

    if (NT_SUCCESS(st)) {

        //
        // Have subkey path, now look for specific values
        // First the program name, then the generic enable/disable key
        // as the program name key takes priority if it exists
        //

        st = CpupReadRegistryDword(hKey, pImageName, &EnableHistory);
        if (STATUS_OBJECT_NAME_NOT_FOUND == st) {

            //
            // No image name was found, so see
            // if the generic enable was in the registry
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_ENABLE, &EnableHistory);

            //
            // If there is a problem with the generic enable, then that means
            // history is not enabled. No need to check the status returned.
            //
        }

        //
        // If we have a history buffer request, then find out the size
        // of the buffer
        //

        if (EnableHistory) {
            
            //
            // pHistoryLength is a pointer to a ULONG so make
            // sure we can stuff a DWORD into it via the 
            // CpupReadRegistryDword() function
            //

            WOWASSERT(sizeof(ULONG) == sizeof(DWORD));

            //
            // Now get the size of the history area
            //

            st = CpupReadRegistryDword(hKey, CPUHISTORY_SIZE, pHistoryLength);

            //
            // If there is a problem with the size entry, then that means
            // we should use the minimum size which we check for anyway
            // below. Thus, no need to check the returned status.
            //
            // And a reality check
            //
            // Make sure we have at least a minimum number of entries for the
            // history buffer if it is enabled
            //

            if (*pHistoryLength < CPUHISTORY_MIN_SIZE) {
                *pHistoryLength = CPUHISTORY_MIN_SIZE;
            }
        }
    }

    if (hKey) {
        NtClose(hKey);
    }

    LOGPRINT((TRACELOG, "CpupCheckHistoryKey() Enabled: %d, Length: %d.\n", EnableHistory, *pHistoryLength));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\cpu\cpumain.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:

    Main entrypoints for IA64 wow64cpu.dll using the iVE for emulation

Author:

    05-June-1998 BarryBo

Revision History:

    9-Aug-1999 [askhalid] added CpuNotifyDllLoad and CpuNotifyDllUnload

--*/

#define _WOW64CPUAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>
#include <kxia64.h>
#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"
#include "ia64bt.h"
#include "stdio.h"

#include "cpup.h"

ASSERTNAME;


extern ULONG_PTR ia32ShowContext;

BINTRANS BtFuncs;

//
// These are to help recover the 64-bit context when an exception happens in
// the 64-bit land and there is no debugger attached initially
//
EXCEPTION_RECORD RecoverException64;
CONTEXT RecoverContext64;

#define DECLARE_CPU         \
    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED)

// Declarations for things in *\simulate.s
extern VOID RunSimulatedCode(PULONGLONG pGdtDescriptor);
extern VOID ReturnFromSimulatedCode(VOID);

// 6 bytes is enough for JMPE+absolute32
UCHAR IA32ReturnFromSimulatedCode[6];

VOID
InitializeGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    );

VOID
InitializeXDescriptor (
    OUT PKXDESCRIPTOR Descriptor,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    );


VOID
CpupCheckHistoryKey (
    IN PWSTR pImageName,
    OUT PULONG pHistoryLength
    );

VOID
BTCheckRegistry(
    IN PWSTR pImageName
    )
/*++

Routine Description:

    Check if the registry says to use the binary translation dll. If the
    binary translation code is to be used, this function will fill in the
    BtFuncs structure.  That structure will either have all entry points
    filled in, or it will all be NULL. This is required as the regular
    CPU code will call based on NULL or non-NULL for each entry.

Arguments:

    pImageName - the name of the image. DO NOT SAVE THIS POINTER. The contents
                 are freed up by wow64.dll when we return from the call

Return Value:

    None.

--*/
{
    ULONGLONG CpuId3;
    BOOLEAN MontecitoProcessor = FALSE;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;
    PWCHAR BTransDllPath;
    WCHAR BTransDllPathBuffer [MAX_PATH];

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR Buffer[400];
    ULONG ResultLength;

    NTSTATUS st;

    HANDLE hKey = NULL;                 // non-null means we have an open key
    PVOID DllBase = NULL;               // non-null means we have a dll loaded

    ULONG clearBtFuncs = TRUE;          // Assume we need to clear func array
    ULONG tryDll = FALSE;               // Assume no dll available
    
    LOGPRINT((TRACELOG, "BTCheckRegistry(%ws) called.\n", pImageName));

    LOGPRINT((TRACELOG, "&(BtImportList[0]) is %p, &BtFuncs is %p\n", &(BtImportList[0]), &BtFuncs));
    LOGPRINT((TRACELOG, "sizeof(BtImportList) is %d, sizeof(BtFuncs) is %d\n", sizeof(BtImportList), sizeof(BtFuncs)));

    //
    // BtImportList has pointers to strings for entry points
    // BtFuncs has pointers to pointers for the actual entry point
    // Thus, they should be the same size (since they both
    // contain pointers)
    //
    ASSERT(sizeof(BtImportList) == sizeof(BtFuncs));

    if (sizeof(BtImportList) != sizeof(BtFuncs)) {
        //
        // Oops, something wrong with structures in ia64bt.h
        // Don't try and call the binary translator
        //
        LOGPRINT((ERRORLOG, "BTCheckRegistry exit due to struct size mismatch.\n"));
        goto cleanup;
    }

    //
    // check if we are running on Montecito or later processors, where
    // there is no hardware emulation of the x86 instruction set.
    //

    CpuId3 = __getReg (CV_IA64_CPUID3);

    CpuId3 = (CpuId3 >> 24);
    CpuId3 = CpuId3 & 0x00ffUI64;

    if ((CpuId3 != 0x0007UI64) && (CpuId3 != 0x001fUI64)) {
        MontecitoProcessor = TRUE;
    }

    //
    // Check in the HKLM area, save checking HKCU first for another time
    //
    RtlInitUnicodeString(&KeyName, BTKEY_MACHINE_SUBKEY);
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);

    if (NT_SUCCESS(st)) {
        
        if (MontecitoProcessor == FALSE) {
        
            //
            // Have subkey path, now look for specific values
            // First the program name, then the generic enable/disable key
            // the program name key takes priority if it exists
            //

            RtlInitUnicodeString(&KeyName, pImageName);
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
            st = NtQueryValueKey(hKey,
                                 &KeyName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                sizeof(Buffer),
                                &ResultLength);
            
            if (NT_SUCCESS(st)) {
                //
                // Found something, so either yes/no. Don't check generic enable
                //
            
                if (KeyValueInformation->Type == REG_DWORD &&
                    *(DWORD *)(KeyValueInformation->Data)) {
                    // Is enabled, so fall through to the Path check
                    LOGPRINT((TRACELOG, "BTCheckRegistry found process key\n"));
                }
                else {
                    // Is not enabled, so we are done
                    LOGPRINT((TRACELOG, "BTCheckRegistry exit due to PROCESS name entry is disabled in registry\n"));
                    goto cleanup;
                }
            }
            else {
                
                //
                // No program name, so now search for the generic enable
                //

                RtlInitUnicodeString(&KeyName, BTKEY_ENABLE);
                KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
                st = NtQueryValueKey(hKey,                                 
                                     &KeyName,
                                    KeyValuePartialInformation,
                                    KeyValueInformation,
                                    sizeof(Buffer),
                                    &ResultLength);

                if (NT_SUCCESS(st) &&
                    KeyValueInformation->Type == REG_DWORD &&
                    *(DWORD *)(KeyValueInformation->Data)) {
                    
                    // Generic enable so fall though to the path check
                    LOGPRINT((TRACELOG, "BTCheckRegistry found generic enable key\n"));
                }
                else {
                    LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing or disabled ENABLE entry in registry\n"));
                    goto cleanup;
                }
            }
        }

        //
        // Found an enable key, now get the dll name/path
        //

        RtlInitUnicodeString(&KeyName, BTKEY_PATH);
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        st = NtQueryValueKey(hKey,
                             &KeyName,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(Buffer),
                             &ResultLength);
        
        if (NT_SUCCESS(st) && (KeyValueInformation->Type == REG_SZ)) {
            
            //
            // Ok, we have a path, lets try and open the dll
            // We are done with the registry for now...
            //
            
            LOGPRINT((TRACELOG, "BTCheckRegistry found path key (%p)\n", &(KeyValueInformation->Data)));
            BTransDllPath = (PWCHAR) &(KeyValueInformation->Data);
            tryDll = TRUE;
        }
        else {
            LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing or invalid PATH entry in registry\n"));
        }
    }
    else {
        
        LOGPRINT((TRACELOG, "BTCheckRegistry exit due to no registry subkeys\n"));
        hKey = NULL;

        //
        // If the registry key is not there yet, load the dll from NtSystemRoot\System32
        //

        if ((st == STATUS_OBJECT_NAME_NOT_FOUND) &&
            (MontecitoProcessor == TRUE)) {
            
            if (_snwprintf (BTransDllPathBuffer, 
                            ((sizeof (BTransDllPathBuffer) - sizeof (UNICODE_NULL))/ sizeof (WCHAR)),
                            L"%ws\\system32\\wowIA32X.dll",
                            USER_SHARED_DATA->NtSystemRoot) > 0) {
                
                BTransDllPath = BTransDllPathBuffer;
                tryDll = TRUE;
            }
        }
    }

    if (tryDll) {
        UNICODE_STRING DllName;
        ANSI_STRING ProcName;
        INT i, NumImports;

        PVOID *pFuncWalk;
        PUCHAR pImportWalk;

        //
        // path should be in KeyValueInformation (data area) which should still
        // be available from above, open the dll and grab the exports
        // if there is anything that goes wrong here, close it
        // up and assume no binary translator
        //
        
        RtlInitUnicodeString(&DllName, BTransDllPath);
        st = LdrLoadDll(NULL, NULL, &DllName, &DllBase);

        if (NT_SUCCESS(st)) {

            NumImports = sizeof(BtImportList) / sizeof(CHAR *);
            pFuncWalk = (PVOID *) &BtFuncs;

            for (i = 0; i < NumImports; i++) {
                //
                // Get the entry points
                //
                pImportWalk = BtImportList[i];
                RtlInitAnsiString(&ProcName, pImportWalk);
                st = LdrGetProcedureAddress(DllBase,
                                                  &ProcName,
                                                  0,
                                                  pFuncWalk);
        
                if (!NT_SUCCESS(st) || !(*pFuncWalk)) {
                    LOGPRINT((TRACELOG, "BTCheckRegistry exit due to missing entry point (%p <%s>) in bintrans dll\n", pImportWalk, pImportWalk));
                    goto cleanup;
                }
                pFuncWalk++;
            }

            //
            // Made it through the for loop, so I guess this means we have
            // an entry for each one
            //
            clearBtFuncs = FALSE;
        }
        else {
            LOGPRINT((TRACELOG, "BTCheckRegistry exit due to can't load bintrans dll\n"));
        }
    }

cleanup:
    if (hKey) {
        NtClose(hKey);
    }

    if (clearBtFuncs) {
        //
        // Make sure the wow64cpu procedures don't try to use a partial
        // binary translation dll. All or nothing - give them nothing...
        //
        RtlZeroMemory(&BtFuncs, sizeof(BtFuncs));

        if (tryDll && DllBase) {
            // Unload the dll since we are not using it
        }
    }
}


WOW64CPUAPI
NTSTATUS
CpuProcessInit(
    PWSTR   pImageName,
    PSIZE_T pCpuThreadSize
    )
/*++

Routine Description:

    Per-process initialization code

Arguments:

    pImageName       - IN pointer to the name of the image
    pCpuThreadSize   - OUT ptr to number of bytes of memory the CPU
                       wants allocated for each thread.

Return Value:

    NTSTATUS.

--*/
{
    PVOID pv;
    NTSTATUS Status;
    SIZE_T Size;
    ULONG OldProtect;

    
    //
    // Indicate that this is Microsoft CPU
    //
    Wow64GetSharedInfo()->CpuFlags = 'sm';

    //
    // On process init, see if we should be calling the bintrans code
    // do this by checking for a specific registry key
    //

    // do registry check
    // need to pass the image name for a per-process check
    BTCheckRegistry(pImageName);

    if (BtFuncs.BtProcessInit) {
        Status = (BtFuncs.BtProcessInit)(pImageName, pCpuThreadSize);
        if (NT_SUCCESS(Status)) {
            return Status;
        }
        else {
            //
            // The binary translator failed, let the iVE try
            // and make sure we don't call the binary translator again
            //
            LOGPRINT((TRACELOG, "CpuProcessInit(): BtProcessInit returned 0x%x. Trying the iVE.\n", Status));

            RtlZeroMemory(&BtFuncs, sizeof(BtFuncs));
        }
    }

#if defined(WOW64_HISTORY)
    //
    // See if we are keeping a history of the service calls
    // for this process. A length of 0 means no history.
    //
    CpupCheckHistoryKey(pImageName, &HistoryLength);

    
    //
    // Allow us to make sure the cpu thread data is 16-byte aligned
    //
    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16 + (HistoryLength * sizeof(WOW64SERVICE_BUF));

#else

    *pCpuThreadSize = sizeof(CPUCONTEXT) + 16;

#endif

    LOGPRINT((TRACELOG, "CpuProcessInit() sizeof(CPUCONTEXT) is %d, total size is %d\n", sizeof(CPUCONTEXT), *pCpuThreadSize));


    IA32ReturnFromSimulatedCode[0] = 0x0f;    // JMPE relative (1st byte)
    IA32ReturnFromSimulatedCode[1] = 0xb8;    // JMPE          (2nd byte)
    *(PULONG)&IA32ReturnFromSimulatedCode[2] =
        (ULONG)(((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->EntryPoint);

    pv = (PVOID)IA32ReturnFromSimulatedCode;
    Size = sizeof(IA32ReturnFromSimulatedCode);
    Status = NtProtectVirtualMemory(NtCurrentProcess(),
                                    &pv,
                                    &Size,
                                    PAGE_EXECUTE_READWRITE,
                                    &OldProtect);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuProcessTerm(
    HANDLE ProcessHandle
    )
/*++

Routine Description:

    Per-process termination code.  Note that this routine may not be called,
    especially if the process is terminated by another process.

Arguments:

    ProcessHandle - The handle of the process being terminated

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtProcessTerm) {
        return (BtFuncs.BtProcessTerm)(ProcessHandle);
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuThreadInit(
    PVOID pPerThreadData
    )
/*++

Routine Description:

    Per-thread termination code.

Arguments:

    pPerThreadData  - Pointer to zero-filled per-thread data with the
                      size returned from CpuProcessInit.

Return Value:

    NTSTATUS.

--*/
{
    PUCHAR Gdt;
    PCPUCONTEXT cpu;
    PTEB32 Teb32 = NtCurrentTeb32();
    PFXSAVE_FORMAT_WX86 xmmi;

    if (BtFuncs.BtThreadInit) {
        return (BtFuncs.BtThreadInit)(pPerThreadData);
    }

    //
    // The ExtendedRegisters array is used to save/restore the floating
    // pointer registers between ia32 and ia64. Alas, this structure
    // has an offset of 0x0c in the ia32 CONTEXT record. There are
    // two ways to clean this up. (1) Put padding in the CPUCONTEXT of
    // wow64. (2) Just put the CPUCONTEXT structure on a 0x04 aligned boundary
    // The choice made was to go with (1) and add padding to the
    // CPUCONTEXT structure. Don't forget to pack(4) that puppy...
    //
    cpu = (PCPUCONTEXT) ((((UINT_PTR) pPerThreadData) + 15) & ~0xfi64);

    // For the ISA transition routine, floats are saved in the
    // ExtendedRegisters area. Make it easy to access.
    //
    xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);


    //
    // This entry is used by the ISA transition routine. It is assumed
    // that the first entry in the cpu structure is the ia32 context record
    //
    Wow64TlsSetValue(WOW64_TLS_CPURESERVED, cpu);

    //
    // This tls entry is used by the transition routine. The transition
    // routine only works with the FXSAVE format. This points to that
    // structure in the x86 context.
    //
    Wow64TlsSetValue(WOW64_TLS_EXTENDED_FLOAT, xmmi);

#if defined(WOW64_HISTORY)
    //
    // Init the pointer to the service history area
    //
    if (HistoryLength) {
        Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, &(cpu->Wow64Service[0]));
    } 
#endif

    //
    // When we have the iVE, we have hardware to do unaligned
    // accesses. So, enable the hardware... (psr.ac is a per-thread resource)
    //
    __rum (1i64 << PSR_AC);

    //
    // Initialize the 32-to-64 function pointer.
    //
    Teb32->WOW32Reserved = PtrToUlong(IA32ReturnFromSimulatedCode);

    //
    // Initialize the remaining nonzero CPU fields
    // (Based on ntos\ke\i386\thredini.c and ntos\rtl\i386\context.c)
    //
    cpu->Context.SegCs=KGDT_R3_CODE|3;
    cpu->Context.SegDs=KGDT_R3_DATA|3;
    cpu->Context.SegEs=KGDT_R3_DATA|3;
    cpu->Context.SegSs=KGDT_R3_DATA|3;
    cpu->Context.SegFs=KGDT_R3_TEB|3;
    cpu->Context.EFlags=0x202;    // IF and intel-reserved set, all others clear
    cpu->Context.Esp=(ULONG)Teb32->NtTib.StackBase-sizeof(ULONG);

    //
    // The ISA transition routine only uses the extended FXSAVE area
    // These values come from ...\ke\i386\thredini.c to match the i386
    // initial values
    //
    xmmi->ControlWord = 0x27f;
    xmmi->MXCsr = 0x1f80;
    xmmi->TagWord = 0xffff;

    //
    // The ISA transisiton code assumes that Context structure is
    // 4 bytes after the pointer saved in TLS[1] (TLS_CPURESERVED)
    // This is done to make the alignment of the ExtendedRegisters[] array
    // in the CONTEXT32 structure be aligned on a 16-byte boundary.
    //
    WOWASSERT(((UINT_PTR) &(cpu->Context)) == (((UINT_PTR) cpu) + 4));
    
    //
    // Make sure this value is 16-byte aligned
    //
    WOWASSERT(((FIELD_OFFSET(CPUCONTEXT, Context) + FIELD_OFFSET(CONTEXT32, ExtendedRegisters)) & 0x0f) == 0);

    //
    // Make sure these values are 8-byte aligned
    //
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, Gdt) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, GdtDescriptor) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, LdtDescriptor) & 0x07) == 0);
    WOWASSERT((FIELD_OFFSET(CPUCONTEXT, FsDescriptor) & 0x07) == 0);
    

    //
    // Initialize each required Gdt entry
    //

    Gdt = (PUCHAR) &cpu->Gdt;
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_CODE), 0,
        (ULONG)-1, TYPE_CODE_USER, DPL_USER, GRAN_PAGE);
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_DATA), 0,
        (ULONG)-1, TYPE_DATA_USER, DPL_USER, GRAN_PAGE);

    //
    // Set user TEB descriptor
    //
    InitializeGdtEntry((PKGDTENTRY)(Gdt + KGDT_R3_TEB), PtrToUlong(Teb32),
        sizeof(TEB32)-1, TYPE_DATA_USER, DPL_USER, GRAN_BYTE);

    //
    // The FS descriptor for ISA transitions. This needs to be in
    // unscrambled format
    //
    InitializeXDescriptor((PKXDESCRIPTOR)&(cpu->FsDescriptor), PtrToUlong(Teb32),
        sizeof(TEB32)-1, TYPE_DATA_USER, DPL_USER, GRAN_BYTE);

    //
    // Setup ISA transition GdtDescriptor - needs to be unscrambled
    // But according to the seamless EAS, only the base and limit
    // are actually used...
    //
    InitializeXDescriptor((PKXDESCRIPTOR)&(cpu->GdtDescriptor), PtrToUlong(Gdt),
        GDT_TABLE_SIZE-1, TYPE_LDT, DPL_USER, GRAN_BYTE);

    return STATUS_SUCCESS;
}


WOW64CPUAPI
NTSTATUS
CpuThreadTerm(
    VOID
    )
/*++

Routine Description:

    Per-thread termination code.  Note that this routine may not be called,
    especially if the thread is terminated abnormally.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtThreadTerm) {
        return (BtFuncs.BtThreadTerm)();
    }

    return STATUS_SUCCESS;
}


WOW64CPUAPI
VOID
CpuSimulate(
    VOID
    )
/*++

Routine Description:

    Call 32-bit code.  The CONTEXT32 has already been set up to go.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSimulate) {
        (BtFuncs.BtSimulate)();
        return;
    }

    while (1) {
        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("Before Simulate: ", cpu);
        }


        //
        // The low level ISA transition code now uses the
        // ExtendedRegister (FXSAVE) format for saving/restoring
        // of ia64 registers.  Thus there is no longer a need
        // to copy the packed-10 byte formats any longer.
        //
        // NOTE: The Get/Set routines (in suspend.c) copy to/from
        // the extended registers when doing old FP get/set. This keeps
        // the older stuff and the extended registers in sync. If code
        // bypasses the standard get/set context routines, there will
        // be a problem with floating point.
        //

        //
        // Call into 32-bit code.  This returns when a system service thunk
        // gets called.
        // cpu->Context is a passed on the side via TLS_CPURESERVED
        // It is passed on the side because it needs
        // to be preserved across ia32 transition. The TLS registers
        // are preserved, but little else is.
        //
        
        RunSimulatedCode(&cpu->GdtDescriptor);

        if (ia32ShowContext & LOG_CONTEXT_SYS) {
            CpupPrintContext("After Simulate: ", cpu);
        }

#if defined(WOW64_HISTORY)
        if (HistoryLength) {
            PWOW64SERVICE_BUF SrvPtr = (PWOW64SERVICE_BUF) Wow64TlsGetValue(WOW64_TLS_LASTWOWCALL);

            // We defined that we are always pointing to the last one, so
            // increment in preparation for the next entry
            SrvPtr++;

            if (SrvPtr > &(cpu->Wow64Service[HistoryLength - 1])) {
                SrvPtr = &(cpu->Wow64Service[0]);
            }

            SrvPtr->Api = cpu->Context.Eax;
            try {
                SrvPtr->RetAddr = *(((PULONG)cpu->Context.Esp) + 0);
                SrvPtr->Arg0 = *(((PULONG)cpu->Context.Esp) + 1);
                SrvPtr->Arg1 = *(((PULONG)cpu->Context.Esp) + 2);
                SrvPtr->Arg2 = *(((PULONG)cpu->Context.Esp) + 3);
                SrvPtr->Arg3 = *(((PULONG)cpu->Context.Esp) + 4);
            }
            except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
                // Do nothing, leave the values alone
                LOGPRINT((TRACELOG, "CpuSimulate() saw excpetion while copying stack info to trace area\n"));
            }

            Wow64TlsSetValue(WOW64_TLS_LASTWOWCALL, SrvPtr);
        }
#endif      // defined(WOW64_HISTORY)

            

        //
        // Have WOW64 call the thunk
        //
        cpu->Context.Eax = Wow64SystemService(cpu->Context.Eax,
                                              &cpu->Context);
        //
        // Re-simulate.  Any/all of the 32-bit CONTEXT may have changed
        // as a result of the system service call, so assume nothing.
        //
    }
}

WOW64CPUAPI
VOID
CpuResetToConsistentState(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    After an exception occurs, WOW64 calls this routine to give the CPU
    a chance to clean itself up and recover the CONTEXT32 at the time of
    the fault.

    CpuResetToConsistantState() needs to:

    0) Check if the exception was from ia32 or ia64

    If exception was ia64, do nothing and return
    If exception was ia32, needs to:
    1) Needs to copy  CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
    2) reset the CONTEXT struction to be a valid ia64 state for unwinding
        this includes:
    2a) reset CONTEXT ip to a valid ia64 ip (usually
         the destination of the jmpe)
    2b) reset CONTEXT sp to a valid ia64 sp (TLS
         entry WOW64_TLS_STACKPTR64)
    2c) reset CONTEXT gp to a valid ia64 gp 
    2d) reset CONTEXT teb to a valid ia64 teb 
    2e) reset CONTEXT psr.is  (so exception handler runs as ia64 code)


Arguments:

    pExceptionPointers  - 64-bit exception information

Return Value:

    None.

--*/
{
    DECLARE_CPU;
    PVOID StackPtr64 = Wow64TlsGetValue(WOW64_TLS_STACKPTR64);

    LOGPRINT((TRACELOG, "CpuResetToConsistantState(%p)\n", pExceptionPointers));

    if (BtFuncs.BtReset) {
        (BtFuncs.BtReset)(pExceptionPointers);
        return;
    }

    //
    // Save the last exception and context records.
    //
    memcpy (&RecoverException64,
            pExceptionPointers->ExceptionRecord,
            sizeof (RecoverException64));

    memcpy (&RecoverContext64,
            pExceptionPointers->ContextRecord,
            sizeof (RecoverContext64));

    //
    // First, clear out the WOW64_TLS_STACKPTR64 so subsequent
    // exceptions won't adjust native sp.
    //
    Wow64TlsSetValue(WOW64_TLS_STACKPTR64, 0);

    //
    // Now decide if we were running as ia32 or ia64...
    //

    if (pExceptionPointers->ContextRecord->StIPSR & (1i64 << PSR_IS)) {
        CONTEXT32 tmpCtx;

        //
        // Grovel the IA64 pExceptionPointers->ContextRecord and
        // stuff the ia32 context back into the cpu->Context.
        // For performance reasons, the PCPU context doesn't
        // follow the FXSAVE format (isa transition requirement). So
        // since the Wow64CtxFromIa64() returns a vaild ia32 context
        // need to use the SetContextRecord() routine to convert from
        // the valid ia32 context to the context used internally...
        //
        Wow64CtxFromIa64(CONTEXT32_FULLFLOAT,
                         pExceptionPointers->ContextRecord,
                         &tmpCtx);
        SetContextRecord(cpu, &tmpCtx);
        
        //
        // Now set things up so we can let the ia64 exception handler do the
        // right thing
        //

        //
        // Hang onto the actual exception address (used when we
        // pass control back to the ia32 exception handler)
        //
        Wow64TlsSetValue(WOW64_TLS_EXCEPTIONADDR, (PVOID) pExceptionPointers->ContextRecord->StIIP);

        //
        // Let the ia64 exception handler think the exception happened
        // in the CpuSimulate transition code. We do this by setting
        // the exception ip to the address pointed to by the jmpe (and the
        // corresponding GP), setting the stack to the same as it was at the
        // time of the br.ia and making sure any other ia64 "saved" registers
        // are replaced (such as the TEB)
        //
        pExceptionPointers->ContextRecord->IntSp = (ULONGLONG)StackPtr64;

         pExceptionPointers->ContextRecord->StIIP= (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->EntryPoint);
        pExceptionPointers->ContextRecord->IntGp = (((PPLABEL_DESCRIPTOR)ReturnFromSimulatedCode)->GlobalPointer);

        pExceptionPointers->ContextRecord->IntTeb = (ULONGLONG) NtCurrentTeb();

        //
        // Don't forget to make the next run be an ia64 run...
        // So clear the psr.is bit (for ia64 code) and the psr.ri bit
        // (so instructions start at the first bundle).
        //
        pExceptionPointers->ContextRecord->StIPSR &= ~(1i64 << PSR_IS);
        pExceptionPointers->ContextRecord->StIPSR &= ~(3i64 << PSR_RI);

        //
        // Now that we've cleaned up the context record, let's
        // clean up the exception record too.
        //
        pExceptionPointers->ExceptionRecord->ExceptionAddress = (PVOID) pExceptionPointers->ContextRecord->StIIP;
        
        //
        // We should never be putting in a null value here
        //
        WOWASSERT(pExceptionPointers->ContextRecord->IntSp);
    }
}


WOW64CPUAPI
ULONG
CpuGetStackPointer(
    VOID
    )
/*++

Routine Description:

    Returns the current 32-bit stack pointer value.

Arguments:

    None.

Return Value:

    Value of 32-bit stack pointer.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtGetStack) {
        return (BtFuncs.BtGetStack)();
    }


    return cpu->Context.Esp;
}


WOW64CPUAPI
VOID
CpuSetStackPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit stack pointer value.

Arguments:

    Value   - new value to use for 32-bit stack pointer.

Return Value:

    None.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSetStack) {
        (BtFuncs.BtSetStack)(Value);
        return;
    }

    cpu->Context.Esp = Value;
}


WOW64CPUAPI
VOID
CpuResetFloatingPoint(
    VOID
    )
/*++

Routine Description:

    Modifies the floating point state to reset it to a non-error state

Arguments:

    None.

Return Value:

    None.

--*/
{
    DECLARE_CPU;
    PFXSAVE_FORMAT_WX86 xmmi;

    if (BtFuncs.BtResetFP) {
        (BtFuncs.BtResetFP)();
        return;
    }

    xmmi = (PFXSAVE_FORMAT_WX86) &(cpu->Context.ExtendedRegisters[0]);

    //
    // The jmpe instruction takes a fault if the fsr.es bit is set
    // regardless whether the fcr is set or not. We need to make sure
    // the excpetion handling code in ia32trap.c doesn't think this 
    // is an actual ia32 exception. We can do this by either
    // reseting the fcr (so the code sees no unmasked exceptions and
    // realizes it is a spurious fp exception) or we need to clear
    // the fsr.es bit manually
    //
    //
    // The problem with masking out just the ES bit, is that we end up
    // in an inconsistent state (fcr says exceptions, fsr error bits
    // say excpetion except for es bit. Next time anyone reads the fsr
    // register (either ia32, context switch, or debugger), we will
    // get es set back to 1 and start taking exceptions again...
    //
    // So only viable choice is to reset the fcr...
    //

    cpu->Context.FloatSave.ControlWord = xmmi->ControlWord = 0x37f;

}

WOW64CPUAPI
VOID
CpuSetInstructionPointer(
    ULONG Value
    )
/*++

Routine Description:

    Modifies the current 32-bit instruction pointer value.

Arguments:

    Value   - new value to use for 32-bit instruction pointer.

Return Value:

    None.

--*/
{
    DECLARE_CPU;

    if (BtFuncs.BtSetEip) {
        (BtFuncs.BtSetEip)(Value);
        return;
    }

    cpu->Context.Eip = Value;
}


VOID
InitializeGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    )

/*++

Routine Description:

    This function initializes a GDT entry.  Base, Limit, Type (code,
    data), and Dpl (0 or 3) are set according to parameters.  All other
    fields of the entry are set to match standard system values.

Arguments:

    GdtEntry - GDT descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in pages.  Note that 0 is 1 page
            while 0xffffff is 1 megapage = 4 gigabytes.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

    Dpl - User (3) or System (0)

    Granularity - 0 for byte, 1 for page

Return Value:

    Pointer to the GDT entry.

--*/

{
    GdtEntry->LimitLow = (USHORT)(Limit & 0xffff);
    GdtEntry->BaseLow = (USHORT)(Base & 0xffff);
    GdtEntry->HighWord.Bytes.BaseMid = (UCHAR)((Base & 0xff0000) >> 16);
    GdtEntry->HighWord.Bits.Type = Type;
    GdtEntry->HighWord.Bits.Dpl = Dpl;
    GdtEntry->HighWord.Bits.Pres = 1;
    GdtEntry->HighWord.Bits.LimitHi = (Limit & 0xf0000) >> 16;
    GdtEntry->HighWord.Bits.Sys = 0;
    GdtEntry->HighWord.Bits.Reserved_0 = 0;
    GdtEntry->HighWord.Bits.Default_Big = 1;
    GdtEntry->HighWord.Bits.Granularity = Granularity;
    GdtEntry->HighWord.Bytes.BaseHi = (UCHAR)((Base & 0xff000000) >> 24);
}


VOID
InitializeXDescriptor (
    OUT PKXDESCRIPTOR Descriptor,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type,
    IN USHORT Dpl,
    IN USHORT Granularity
    )

/*++

Routine Description:

    This function initializes a unscrambled Descriptor.
    Base, Limit, Type (code, data), and Dpl (0 or 3) are set according
    to parameters.  All other fields of the entry are set to match
    standard system values.
    The Descriptor will be initialized to 0 first, and then setup as requested

Arguments:

    Descriptor - descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in pages.  Note that 0 is 1 page
            while 0xffffff is 1 megapage = 4 gigabytes.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

    Dpl - User (3) or System (0)

    Granularity - 0 for byte, 1 for page

Return Value:

    Pointer to the Descriptor

--*/

{
    Descriptor->Words.DescriptorWords = 0;

    Descriptor->Words.Bits.Base = Base;
    Descriptor->Words.Bits.Limit = Limit;
    Descriptor->Words.Bits.Type = Type;
    Descriptor->Words.Bits.Dpl = Dpl;
    Descriptor->Words.Bits.Pres = 1;
    Descriptor->Words.Bits.Default_Big = 1;
    Descriptor->Words.Bits.Granularity = Granularity;
}

WOW64CPUAPI
VOID
CpuNotifyDllLoad(
    LPWSTR DllName,
    PVOID DllBase,
    ULONG DllSize
    )
/*++

Routine Description:

    This routine get notified when application successfully load a dll.

Arguments:

    DllName - Name of the Dll the application has loaded.
    DllBase - BaseAddress of the dll.
    DllSize - size of the Dll.

Return Value:

    None.

--*/
{

#if defined(DBG)
    LPWSTR tmpStr;
#endif

    if (BtFuncs.BtDllLoad) {
        (BtFuncs.BtDllLoad)(DllName, DllBase, DllSize);
        return;
    }

    //
    // this is a no-op for the IA64 CPU
    //

#if defined(DBG)

    tmpStr = DllName;

    try {
        //
        // See if we got passed in a legit name
        //
        if ((tmpStr == NULL) || (*tmpStr == L'\0')) {
            tmpStr = L"<Unknown>";
        }
    }
    except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION)?1:0) {
        tmpStr = L"<Unknown>";
    }

    LOGPRINT((TRACELOG, "CpuNotifyDllLoad(\"%ws\", 0x%p, %d) called\n", tmpStr, DllBase, DllSize));
#endif

}

WOW64CPUAPI
VOID
CpuNotifyDllUnload(
    PVOID DllBase
    )
/*++

Routine Description:

    This routine get notified when application unload a dll.

Arguments:

    DllBase - BaseAddress of the dll.

Return Value:

    None.

--*/
{
    if (BtFuncs.BtDllUnload) {
        (BtFuncs.BtDllUnload)(DllBase);
        return;
    }
    //
    // this is a no-op for the IA64 CPU
    //
    LOGPRINT((TRACELOG, "CpuNotifyDllUnLoad(%p) called\n", DllBase));
}
  
WOW64CPUAPI
VOID
CpuFlushInstructionCache (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN ULONG Length,
    IN WOW64_FLUSH_REASON Reason
    )
/*++

Routine Description:

    The CPU needs to flush its cache around the specified address, since
    some external code has altered the specified range of addresses.

Arguments:

    BaseAddress - start of range to flush
    Length      - number of bytes to flush
    Reason      - Reason for the flush request

Return Value:

    None.

--*/
{
    
    if (BtFuncs.BtFlush) {
        (BtFuncs.BtFlush)(ProcessHandle, BaseAddress, Length, Reason);
        return;
    }

    /*
    ** Only flush the cache if we have a good reason. The hardware
    ** doesn't care about alloc/free/protect flushes since it handles
    ** self modifying code already. Thus, only flush if someone has
    ** specifically asked for a flush...
    */
    if (WOW64_FLUSH_FORCE == Reason) {
        NtFlushInstructionCache(ProcessHandle, BaseAddress, Length);
    }
}

WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread.
    When entered, if the target thread isn't the currently executing thread, then it is 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtSetContext) {
        return (BtFuncs.BtSetContext)(ThreadHandle, ProcessHandle, Teb, Context);
    }

    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupSetContext(Context);
    }
    
    return CpupSetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}

WOW64CPUAPI
NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread.
    When entered, it is guaranteed that the target thread is suspended at 
    a proper CPU state.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtGetContext) {
        return (BtFuncs.BtGetContext)(ThreadHandle, ProcessHandle, Teb, Context);
    }

    if (NtCurrentThread() == ThreadHandle)
    {
        return CpupGetContext(Context);
    }

    return CpupGetContextThread(ThreadHandle,
                                ProcessHandle,
                                Teb,
                                Context);
}

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU.    

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    if (BtFuncs.BtSuspend) {
        return (BtFuncs.BtSuspend)(ThreadHandle, ProcessHandle, Teb, PreviousSuspendCount);
    }

    return STATUS_SUCCESS;
}

WOW64CPUAPI
BOOLEAN
CpuProcessDebugEvent(
    IN LPDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    This routine is called whenever a debug event needs to be processed. This would indicate
    that the current thread is acting as a debugger. This function gives CPU simulators
    a chance to decide whether this debug event should be dispatched to 32-bit code or not.    

Arguments:

    DebugEvent  - Debug event to process

Return Value:

    BOOLEAN. This function returns TRUE if it processed the debug event, and doesn't
    wish to dispatch it to 32-bit code. Otherwise, it would return FALSE, and it 
    would dispatch the debug event to 32-bit code.

--*/

{
    if (BtFuncs.BtProcessDebugEvent) {
        return (BtFuncs.BtProcessDebugEvent) (DebugEvent);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\inc\ia64bt.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ia64bt.h

Abstract:
    
    Header for calling IA32 Execution layer if it exists
    
Author:

    22-Aug-2000 v-cspira (charles spirakis)

--*/

#ifndef _BINTRANS_INCLUDE
#define _BINTRANS_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif


//
// Create the typedefs for the functions we can import from the IA32 Execution
// layer. These functions are duplicates of the wow64cpu export list for both
// what they do and the parameters they take. Any changes to the wow64cpu
// list should also update these typedefs
//

//
// Cache manipulation functions and Dll notification
//
typedef VOID (*PFNCPUFLUSHINSTRUCTIONCACHE)( HANDLE ProcessHandle, PVOID BaseAddress, ULONG Length, WOW64_FLUSH_REASON Reason );
typedef VOID (*PFNCPUNOTIFYDLLLOAD)( LPWSTR DllName, PVOID DllBase, ULONG DllSize );
typedef VOID (*PFNCPUNOTIFYDLLUNLOAD)( PVOID DllBase  );

//
// Init and term APIs
//
typedef NTSTATUS (*PFNCPUPROCESSINIT)(PWSTR pImageName, PSIZE_T pCpuThreadDataSize);
typedef NTSTATUS (*PFNCPUPROCESSTERM)(HANDLE ProcessHandle);
typedef NTSTATUS (*PFNCPUTHREADINIT)(PVOID pPerThreadData);
typedef NTSTATUS (*PFNCPUTHREADTERM)(VOID);


//
// Execution
//
typedef VOID (*PFNCPUSIMULATE)(VOID);

//
// Exception handling, context manipulation
//
typedef VOID  (*PFNCPURESETTOCONSISTENTSTATE)(PEXCEPTION_POINTERS pExecptionPointers);
typedef ULONG (*PFNCPUGETSTACKPOINTER)(VOID);
typedef VOID  (*PFNCPUSETSTACKPOINTER)(ULONG Value);
typedef VOID  (*PFNCPUSETINSTRUCTIONPOINTER)(ULONG Value);
typedef VOID  (*PFNCPUSETFLOATINGPOINT)(VOID);

typedef NTSTATUS (*PFNCPUSUSPENDTHREAD)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, OUT PULONG PreviousSuspendCount OPTIONAL);

typedef NTSTATUS (*PFNCPUGETCONTEXT)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, OUT PCONTEXT32 Context);

typedef NTSTATUS (*PFNCPUSETCONTEXT)( IN HANDLE ThreadHandle, IN HANDLE ProcessHandle, IN PTEB Teb, PCONTEXT32 Context);

typedef BOOLEAN (*PFNCPUPROCESSDEBUGEVENT)(IN LPDEBUG_EVENT DebugEvent);


//
// Need the entry point names as well
// This is what needs to be exported from the binary translation dll
// The LdrGetProcedureAddress() uses Ansi, so these are ansi too
//
// NOTE: the order of these strings must match the order
// of the corresponding functions in the _bintrans structure below
//
PUCHAR BtImportList[] = {
    "BTCpuProcessInit",
    "BTCpuProcessTerm",
    "BTCpuThreadInit",
    "BTCpuThreadTerm",
    "BTCpuSimulate",
    "BTCpuGetStackPointer",
    "BTCpuSetStackPointer",
    "BTCpuSetInstructionPointer",
    "BTCpuResetFloatingPoint",
    "BTCpuSuspendThread",
    "BTCpuGetContext",
    "BTCpuSetContext",
    "BTCpuResetToConsistentState",
    "BTCpuFlushInstructionCache",
    "BTCpuNotifyDllLoad",
    "BTCpuNotifyDllUnload",
    "BTCpuProcessDebugEvent"
};

//
// NOTE: The order of entries in this structure MUST match the
// order of entries listed above. This structure gets cast
// into a PVOID struction to be filled in and we iterate though the
// names above to do it...
//
typedef struct _bintrans {
    PFNCPUPROCESSINIT           BtProcessInit;
    PFNCPUPROCESSTERM           BtProcessTerm;
    PFNCPUTHREADINIT            BtThreadInit;
    PFNCPUTHREADTERM            BtThreadTerm;

    PFNCPUSIMULATE              BtSimulate;

    PFNCPUGETSTACKPOINTER       BtGetStack;
    PFNCPUSETSTACKPOINTER       BtSetStack;
    PFNCPUSETINSTRUCTIONPOINTER BtSetEip;
    PFNCPUSETFLOATINGPOINT      BtResetFP;

    PFNCPUSUSPENDTHREAD         BtSuspend;
    PFNCPUGETCONTEXT            BtGetContext;
    PFNCPUSETCONTEXT            BtSetContext;

    PFNCPURESETTOCONSISTENTSTATE BtReset;

    PFNCPUFLUSHINSTRUCTIONCACHE BtFlush;
    PFNCPUNOTIFYDLLLOAD         BtDllLoad;
    PFNCPUNOTIFYDLLUNLOAD       BtDllUnload;

    PFNCPUPROCESSDEBUGEVENT     BtProcessDebugEvent;

} BINTRANS;


//
// The binary translator is enabled by a key in the registry
// The key is in HKLM, and there are subkeys for enabling (1)
//
// No subkey area and/or no enable key means don't use the binary translator.
//
// The path must be specified and is used to load the dll. Thus, the dll can
// actually have any name as long as the path is right and the export list
// is correct.
//
// Individual apps can be listed here with a DWORD subkey. A
// value of 1 says use btrans, and a value of 0 says don't. No value says
// use the global enable/disable to decide
//
// 
//
#define BTKEY_SUBKEY L"Software\\Microsoft\\Wow64\\IA32Exec"

#define BTKEY_MACHINE_SUBKEY    L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\IA32Exec"
#define BTKEY_ENABLE    L"Enable"
#define BTKEY_PATH      L"Path"


#ifdef __cplusplus
}
#endif

#endif  //_BINTRANS_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\inc\cpup.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cpup.h

Abstract:

    This module contains the private common definitions shared between
    Microsoft CPUs.

Author:

    Samer Arafeh (samera) 12-Dec-2001

--*/

#ifndef _CPUP_INCLUDE
#define _CPUP_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

#if !defined RPL_MASK
#define RPL_MASK        3
#endif

//
// flags used by ia32ShowContext
//

#define LOG_CONTEXT_SYS     1
#define LOG_CONTEXT_GETSET  2

//
// This is to prevent this library from linking to wow64 to use wow64!Wow64LogPrint
//

#if defined(LOGPRINT)
#undef LOGPRINT
#endif
#define LOGPRINT(_x_)   CpupDebugPrint _x_

//
// CPU declaration
//
#define DECLARE_CPU         \
    PCPUCONTEXT cpu = (PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED)

//
// Sanitize x86 eflags
//
#define SANITIZE_X86EFLAGS(efl)  ((efl & 0x003e0dd7L) | (0x202L))


//
// Common functions
//

VOID
CpupDebugPrint(
    IN ULONG_PTR Flags,
    IN PCHAR Format,
    ...);

VOID
CpupPrintContext (
    IN PCHAR str,
    IN PCPUCONTEXT cpu
    );


#ifdef __cplusplus
}
#endif

#endif // _CPUP_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\inc\ia64cpu.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ia64cpu.h

Abstract:

    Structures and types shared between the IA64 CPU and its debugger
    extensions.

Author:

    27-Sept-1999 BarryBo

Revision History:
    9-Aug-1999 [askhalid] added WOW64IsCurrentProcess

--*/

#ifndef _IA64CPU_INCLUDE
#define _IA64CPU_INCLUDE

#ifdef __cplusplus
extern "C" {
#endif

#define GDT_ENTRIES 24
#define GDT_TABLE_SIZE  (GDT_ENTRIES<<3)

// Each 387 register takes 1 ia64 fp register
#define NUMBER_OF_387REGS       8

// Each XMMI register takes 2 ia64 fp registers
#define NUMBER_OF_XMMI_REGS     8

/*
** The order of this structure is very important. The Reserved space at
** the beginnig allows the ExtendedRegisters[] array in the CONTEXT32 structure
** to be aligned properly.
**
** There are constants in the ISA transisiton code that are dependant on
** the offsets in this structure. If you make changes here, you must
** make changes to the cpu\ia64\simulate.s code at the very least
*/
#pragma pack(push, 4)
typedef struct _CpuContext {
    DWORD       Reserved;
    CONTEXT32   Context;

    //
    // Because the sizeof(CONTEXT32) struct above is 4 bytes short of
    // being divisible by 16, the padding allows the following
    // fields to be on 8 byte boundaries. If they are not, we will
    // do misaligned accesses on isa transisitons and we will 
    // see ASSERTS in the cpumain.c code (CpuThreadInit()).
    //

    ULONGLONG   Gdt[GDT_ENTRIES];
    ULONGLONG   GdtDescriptor;
    ULONGLONG   LdtDescriptor;
    ULONGLONG   FsDescriptor;

#if defined(WOW64_HISTORY)

    //
    // This MUST be the last entry in the CPUCONTEXT structure
    // The size is actually allocated based on a registry entry
    // and is appended to the sizeof the CPUCONTEXT structure as reported
    // back in CpuProcessInit()
    //
    WOW64SERVICE_BUF Wow64Service[1];
#endif          // defined WOW64_HISTORY

} CPUCONTEXT, *PCPUCONTEXT;
#pragma pack(pop)


//
// GDT Entry
//

#ifndef WOW64EXTS_386
typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;
#endif

#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

//
// UnScrambled Descriptor format
//
typedef struct _KDESCRIPTOR_UNSCRAM {
    union {
        ULONGLONG  DescriptorWords;
        struct {
            ULONGLONG   Base : 32;
            ULONGLONG   Limit : 20;
            ULONGLONG   Type : 5;
            ULONGLONG   Dpl : 2;
            ULONGLONG   Pres : 1;
            ULONGLONG   Sys : 1;
            ULONGLONG   Reserved_0 : 1;
            ULONGLONG   Default_Big : 1;
            ULONGLONG   Granularity : 1;
         } Bits;
    } Words;
} KXDESCRIPTOR, *PKXDESCRIPTOR;

#define TYPE_CODE_USER                0x1B // 0x11011 = Code, Readable, Accessed
#define TYPE_DATA_USER                0x13 // 0x10011 = Data, ReadWrite, Accessed

#define DESCRIPTOR_EXPAND_DOWN        0x14
#define DESCRIPTOR_DATA_READWRITE     (0x8|0x2) // Data, Read/Write

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04


//
// Now define the API's used to convert IA64 hardware into ia32 context
//
VOID Wow64CtxFromIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT ContextIa64,
    IN OUT PCONTEXT32 ContextX86);

VOID Wow64CtxToIa64(
    IN ULONG Ia32ContextFlags,
    IN PCONTEXT32 ContextX86,
    IN OUT PCONTEXT ContextIa64);

VOID Wow64CopyFpFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID Byte10Fp,
    IN ULONG NumRegs);

VOID Wow64CopyFpToIa64Byte16(
    IN PVOID Byte10Fp,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID Wow64CopyXMMIToIa64Byte16(
    IN PVOID ByteXMMI,
    IN OUT PVOID Byte16Fp,
    IN ULONG NumRegs);

VOID Wow64CopyXMMIFromIa64Byte16(
    IN PVOID Byte16Fp,
    IN OUT PVOID ByteXMMI,
    IN ULONG NumRegs);

VOID
Wow64RotateFpTop(
    IN ULONGLONG Ia64_FSR,
    IN OUT FLOAT128 UNALIGNED *ia32FxSave);

VOID Wow64CopyIa64ToFill(
    IN FLOAT128 UNALIGNED *ia64Fp,
    IN OUT PFLOAT128 FillArea,
    IN ULONG NumRegs);

VOID Wow64CopyIa64FromSpill(
    IN PFLOAT128 SpillArea,
    IN OUT FLOAT128 UNALIGNED *ia64Fp,
    IN ULONG NumRegs);

// The following ptototypes are to be used only by the cpu debugger extension
NTSTATUS
GetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );
NTSTATUS
SetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT32 Context
    );
NTSTATUS
CpupGetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context);
NTSTATUS
CpupSetContextThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT32 Context);
NTSTATUS
CpupSetContext(
    IN PCONTEXT32 Context
    );
NTSTATUS
CpupGetContext(
    IN OUT PCONTEXT32 Context
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\cpu\ia64\simulate.s ===
//++
//
// Copyright (c) 1998  Microsoft Corporation
//
// Module Name:
//
//    simulate.s
//
// Abstract:
//
//    This module implements calls from 64-bit code to 32-bit.
//    Much of this was lifted from the IA64 port of Wx86 on IA64 NT4.
//    (Thanks Charles!)
//
// Author:
//
//    Barry Bond (barrybo)  5-June-98
//
// Environment:
//
//    User-mode.
//
// Revision History:
//
//--

#include "ksia64.h"

// See cpumain.c CpuThreadInit if you change this!!!
#define OFFSET_FloatScratch 944

        .file       "simulate.s"
         
//++
//
//RunSimulatedCode
//
// Routine Description:
//
//     Run simulation of 32-bit code.  Returns when the simulated code makes
//     an API call.
//
// Arguments:
//
//     in0 = pGdtDescriptor   - start of descriptors to use for the call
//
// Return Value:
//
//     None.  pContext updated.
//
//--

        NESTED_ENTRY(RunSimulatedCode)
        NESTED_SETUP(1, 9, 0, 0)
        //
        // Reminder - NESTED_ENTRY and NESTED_SETUP use loc0 and loc1
        // to save away the ar.pfs and ar.rp...
        //

        //
        // For SEH, need to do a call, so save things
        //
        // Register cleanup is handled via the alternate entry point
        // (on return from ia32 execution)
        //
        // The assembler automatically creates SEH info for most mov's that 
        // are done in the prologue
        //

        mov     loc5 = pr
        mov     loc2 = ar.lc
        mov     loc4 = ar.fpsr
        mov     loc6 = teb
        mov     loc7 = gp

        //
        // Force the assembler to view this as a variable sized frame
        //
        .vframe loc3
        mov     loc3 = sp
        ;;

        //
        // And we need to save the float registers f16-f31 as well
        // Toss them on the memory stack...
        //
        // Done this way in the hopes the assembler will be able to
        // create the appropriate SEH for fp spills relative to the memory
        // stack...
        //

        //
        // Create space for the spill of the floating point registers
        // Saving 16 fp registers (each taking 16 bytes), plus the required
        // extra 16 bytes for a standard procedure call
        //
        adds    sp = -((16 * 16) + 16), sp
        ;;
        add     r31 = 16, sp            // Skip over the proc call dead space
        add     r30 = 32, sp
        ;;

        stf.spill [r31] = f16, 32       // Everything stays 16-byte aligned
        stf.spill [r30] = f17, 32
        ;;

        stf.spill [r31] = f18, 32
        stf.spill [r30] = f19, 32
        ;;

        stf.spill [r31] = f20, 32
        stf.spill [r30] = f21, 32
        ;;

        stf.spill [r31] = f22, 32
        stf.spill [r30] = f23, 32
        ;;

        stf.spill [r31] = f24, 32
        stf.spill [r30] = f25, 32
        ;;

        stf.spill [r31] = f26, 32
        stf.spill [r30] = f27, 32
        ;;

        stf.spill [r31] = f28, 32
        stf.spill [r30] = f29, 32
        ;;

        stf.spill [r31] = f30, 32
        stf.spill [r30] = f31
        ;;

        //
        // At this point r31 should equal the original sp...
        // Where's that assembly ASSERT() when you need it?
        //

        PROLOGUE_END

        //
        // r23 is not used during setup of the iVE, so pass the GDT info
        // via that register. It will be trashed by iVE execution,but
        // we don't need it again after we setup the ia32 registers
        //
        // The ia32 context is pointerd to by TLS[1] and the floating
        // point scratch area is pointed to by TLS[6]
        //
        // Ideally we would use preserved registers for these two arguments
        // and pass them in to this routine to be saved (avoiding sideband args)
        // Not only would it be better coding style, but it would be faster
        // too. Alas, exception handling and preserved registers is not
        // well understood by me yet, so do it this way and go for
        // performance later on...
        //
        mov     r23 = in0
        ;;

        br.call.sptk b0 = ProcessUserIA
        ;;

        mov     ar.fpsr = loc4
        mov     ar.lc = loc2
        mov     teb = loc6
        mov     gp = loc7
        mov     pr = loc5, -1

        //
        // sp should be OK based on ProcessUserIA doing a save/restore
        // of sp in the TLS area
        //
        add     r31 = 16, sp           // Prepare for refilling of preserved fp
        add     r30 = 32, sp
        ;;

        ldf.fill f16 = [r31], 32      // Skip over saves done by r30...
        ldf.fill f17 = [r30], 32      // Skip over saves done by r31
        ;;

        ldf.fill f18 = [r31], 32
        ldf.fill f19 = [r30], 32
        ;;

        ldf.fill f20 = [r31], 32
        ldf.fill f21 = [r30], 32
        ;;

        ldf.fill f22 = [r31], 32
        ldf.fill f23 = [r30], 32
        ;;

        ldf.fill f24 = [r31], 32
        ldf.fill f25 = [r30], 32
        ;;

        ldf.fill f26 = [r31], 32
        ldf.fill f27 = [r30], 32
        ;;

        ldf.fill f28 = [r31], 32
        ldf.fill f29 = [r30], 32
        ;;

        ldf.fill f30 = [r31], 32
        ldf.fill f31 = [r30]
        ;;

        // Once again, r31 should equal the old sp at this point...

        // The safe way of making sure we put the stack back where it belongs
        mov sp = loc3

        //
        // r8 (return register) is pointing to address after jmpe instruction
        //
        NESTED_RETURN
        NESTED_EXIT(RunSimulatedCode)

//++
//
//ProcessUserIA
//
// Routine Description:
//
//     Make the mode transitions to and from IA32.
//     an API call.
//
// Arguments:
//
//     TLS[1] = pContext    - 32-bit CONTEXT to use for the call
//     TLS[6] = FXSAVE area - Location of fp registers to load/store
//                            ideally we would use s0 for these two
//     r23 = pGdtDescriptor - address of GDT descriptor (others follow it in memory)
//
// Return Value:
//
//     None.  pContext updated.
//
// Notes:
//
//     RunSimulatedCode has preserved all EM registers that will be
//     destroyed by the br.ia.
//
//--
        LEAF_ENTRY(ProcessUserIA)
        LEAF_SETUP(0,96,0,0)
        PROLOGUE_END

        // Address of TLS[1]
        add  r19 = TeDeallocationStack + 8 + (1 * 8), teb

        // Address of TLS[6]
        add  r22 = TeDeallocationStack + 8 + (6 * 8), teb
        ;;

        // Get the contents of TLS[0] - pointer to CPUCONTEXT
        ld8  r19 = [r19]

        // Get the contents of TLS[6] - pointer to ExtendedRegisters[0]
        ld8  r22 = [r22]

        //
        // Load iA state for iVE. Since working with flat 32 in NT,
        // much of the state is a constant
        //
        movl r16 = (_FsSelector << 32) | (_DataSelector << 16) | _DataSelector
        movl r17 = (_LdtSelector << 32) | (_DataSelector << 16) | _CodeSelector
        ;;

        //
        //  load up descriptor registers
        //
        ld8    r31   = [r23], 8     // load GDT Descriptor registers
        movl   r28   = USER_CODE_DESCRIPTOR
        ;;
        ld8    r30   = [r23], 8     // LDT Descriptor is 8 bytes after
        mov    ar25 = r28
        ;;
        ld8    r28    = [r23]       // FS Descriptor is 8 bytes after

        //
        // The CSD is considered a scratch register so we need
	// to reload it each time we transition into ia32. Since the value is a constant
	// we don't need to save it on the transition back to ia64.
	// The SSD is in an AR register that is preserved
        // so dont need to reload them...
        // SSD and CSD are in ar26 and ar25 respectively
        
        mov r24    =   rSSD         // ES Descriptor
        mov r27    =   rSSD         // DS Descriptor
        mov r29    =   rSSD         // GS Descriptor
        ;;


        //
        // Now fill in the regular registers based on the context passed in
        // including ESP and EIP
        //
        // Given Merced can only send out 2 memory ops on the bus at one time,
        // and we're doing three or four ops per stop bit, 
        // this code is not optimized for speed...
        //
        add r23 = 160, r19              // Edi is 160 bytes into CPUCONTEXT
                                        // (with 4 byte padding before CONTEST32) 
        add r32 = 160, r22              // Location of XMMI (low) in FXSAVE
        add r33 = 168, r22              // Location of XMMI (high) in FXSAVE
        add r34 = 32, r22               // Location of st[0] in FXSAVE format
                                        // And r22 points to the fp control
        ;;

        ld2 r39 = [r22], 2              // Get Control Word (fcw)
        ld4 r15 = [r23], 4              // Start copying the int registers (edi)
        ;;

        ld2 r40 = [r22], 2              // Get Status Word (fsw)
        ld4 r14 = [r23], 4              // esi
        ld8 r35 = [r32], 16             // Get low mantissa
        ld8 r36 = [r33], 16             // Get high mantissa
        ;;

        ld2 r41 = [r22], 4              // Tag Word (ftw) (and jump over fop)
        ld4 r11 = [r23], 4              // ebx
        ldfe f8 = [r34], 16             // Load the 387 registers - st[0]
        setf.sig f16 = r35              // low is on the even regs
        setf.sig f17 = r36              // high is on the odd regs
        ld8 r37 = [r32], 16
        ld8 r38 = [r33], 16
        ;;

        ld8 r20 = [r22], 8              // Get all of fir
        ld4 r10 = [r23], 4              // edx
        ldfe f9 = [r34], 16             // Now st[1]
        setf.sig f18 = r37
        setf.sig f19 = r38
        ld8 r35 = [r32], 16
        ld8 r36 = [r33], 16
        ;;

        ld8 r3 = [r22], 8               // Get all of fdr
        dep r44 = r41, r40, 16, 16      // Put tag in the second 16 bits
        mov ia32fir = r20               // Put fir in the proper place
        ld4 r9 = [r23], 4               // ecx
        ldfe f10 = [r34], 16            // Now st[2]
        setf.sig f20 = r35
        setf.sig f21 = r36
        ld8 r37 = [r32], 16
        ld8 r38 = [r33], 16
        ;;

        ld2 r42 = [r22]                 // Get MXCSR
        mov ia32fdr = r3                // Put fdr in the proper place
        ld4 r8 = [r23], 4               // eax
        ldfe f11 = [r34], 16            // Now st[3]
        setf.sig f22 = r37              // low side of xmmi
        setf.sig f23 = r38              // high side of xmmi
        ld8 r35 = [r32], 16             // Get even mantissa
        ld8 r36 = [r33], 16             // Get odd mantissa

        //
        // Get the address of TEB64 TLS entry 0
        // so we can save the ia64 stack pointer
        // Note: teb is r13 which is also rBP... Make sure
        // we do this math before trashing r13!
        //
        add  r19 = TeDeallocationStack+8 + (0 * 8), teb
        ;;

        dep r47 = r42, r44, 32, 6       // Put the MXCSR status in fsw
        extr.u r45 = r42, 7, 9          // Get the bits for the control word
        ld4 r13 = [r23], 4              // ebp *NOTE* trahes ia64 teb pointer
        ldfe f12 = [r34], 16            // Now st[4]
        setf.sig f24 = r35              // low side of xmmi
        setf.sig f25 = r36              // high side of xmmi
        ld8 r37 = [r32], 16             // Get even mantissa
        ld8 r38 = [r33], 16             // Get odd mantissa
        ;;

        dep r46 = r45, r39, 39, 9       // Put in the MXCSR control word
        mov ia32fsr = r47               // And store status and tag and mscxr
        ld4 r2 = [r23], 8               // Get the EIP and skip to the EFlags
        ldfe f13 = [r34], 16            // Now st[5]
        setf.sig f26 = r37              // low side of xmmi
        setf.sig f27 = r38              // high side of xmmi
        ld8 r35 = [r32], 16             // Get even mantissa
        ld8 r36 = [r33], 16             // Get odd mantissa
        ;;

        mov ia32fcr = r46               // Put fcw in the proper place
        mov r18 = sp                    // Hang onto the ia64 stack pointer
        ld4 r3 = [r23], 4               // Get Eflags
        ldfe f14 = [r34], 16            // Now st[6]
        setf.sig f28 = r35              // low side of xmmi
        setf.sig f29 = r36              // high side of xmmi
        ld8 r37 = [r32], 16             // Get even mantissa
        ld8 r38 = [r33], 16             // Get odd mantissa
        ;;

        ld4 sp = [r23]                  // esp
        ldfe f15 = [r34]                // Now st[7]
        setf.sig f30 = r37              // low side of xmmi
        setf.sig f31 = r38              // high side of xmmi

        //
        // Put the eflags value in the right register
        //
        mov ia32eflag = r3
        ;;

        //
        // The eas says we should flushrs one cycle before the br.ia... So...
        //
        flushrs
    	
        //
        // Get the branch address (saved in r2 above)
        //
        mov b7 = r2

        //
        // Store the old sp into the tls. This is used as a flag for the
        // exception handler to indicate we are running on the ia32 stack
        // and will be force-fed into the dispatch for CpuReset() call...
        //
        st8 [r19] = r18
        ;;

        br.ia.sptk   b7
        ;;
    	
        //
        // The jmpe from IA code needs to get back here to
        // properly uncover the stack.  
        //
        .align 16

        ALTERNATE_ENTRY(ReturnFromSimulatedCode)

        mov r20 = kteb
        ;;

        // Address of TLS[1]
        add  r19 = TeDeallocationStack + 8 + (1 * 8), r20

        // Address of TLS[6]
        add  r22 = TeDeallocationStack + 8 + (6 * 8), r20
        ;;

        // Get the contents of TLS[1] - the pointer to the CPUCONTEXT structure
        ld8  r19 = [r19]

        // Get the contents of TLS[6] - pointer to ExtendedRegisters[0]
        ld8  r22 = [r22]
        ;;

        //
        // Do we need to preserve any of the ia32 floating point registers?
        // Depends on the ia32 software convention... Are floats saved
        // across calls?
        //
        mov r3 = ia32eflag              // get eflags
        add r23 = 160, r19              // Edi is 160 bytes in (see above)
        add r18 = 32, r22               // st[0] is 32 bytes into FXSAVE area
                                        // r16/r17 are descriptors. We don't
                                        // save them, so use them
        add r16 = 160, r22              // Get the the XMMI even regs
        add r17 = 168, r22              // Get the the XMMI odd regs 
                                        // And r22 points to the fp control
        ;;

        mov r19 = ia32fsr               // Get fsr (and tag)
        mov r20 = ia32fcr               // Get fcr
        mov r2 = ia32fir                // Get the fir
        ;;

        st2 [r22] = r20, 2              // Save the control register
        extr.u r21 = r19, 16, 16        // Get the tag bits
        st4 [r23] = r15, 4              // So start copying back edi
        extr.u r24 = r19, 32, 6         // r24 isn't saved. Get mxcsr status
        extr.u r25 = r20, 39, 9         // r25 isn't saved. Get mxcsr control
        ;;

        st2 [r22] = r19, 2              // Save the fsr
        mov r20 = ia32fdr               // Get the fdr
        shl r15 = r25, 7                // Create space for the mxcsr status
        st4 [r23] = r14, 4              // esi

        getf.sig r28 = f16              // r28 isn't saved. get xmmi low
        getf.sig r29 = f17              // r29 isn't saved. get xmmi high
        ;;

        st2 [r22] = r21, 4              // Save the tag
        st4 [r23] = r11, 4              // ebx
        dep r25 = r24, r15, 0, 7        // Create mxcsr word

        stfe [r18] = f8, 16             // and save the fp registers
        st8 [r16] = r28, 16             // and save the xmmi low
        st8 [r17] = r29, 16             // and save the xmmi high
        getf.sig r30 = f18              // r30 isn't saved. get xmmi low
        getf.sig r31 = f19              // r31 isn't saved. get xmmi high
        ;;

        st8 [r22] = r2, 8               // Save fir
        st4 [r23] = r10, 4              // edx

        stfe [r18] = f9, 16
        st8 [r16] = r30, 16             // and save the xmmi low
        st8 [r17] = r31, 16             // and save the xmmi high
        getf.sig r28 = f20              // get xmmi low
        getf.sig r29 = f21              // get xmmi high
        ;;

        //
        // Get the return address from the ia32 stack and hang onto it
        // Add 4 to ESP while we're at it so the ia32 stack is pointing
        // after the return address
        //
        ld4 r2 = [rEsp], 4
        st4 [r23] = r9, 4               // ecx
        st8 [r22] = r20, 8              // Save fdr

        stfe [r18] = f10, 16
        st8 [r16] = r28, 16             // and save the xmmi low
        st8 [r17] = r29, 16             // and save the xmmi high
        getf.sig r30 = f22              // get xmmi low
        getf.sig r31 = f23              // get xmmi high
        ;;

        st4 [r23] = r8, 4               // eax
        st4 [r22] = r25                 // Save away the mxcsr

        stfe [r18] = f11, 16
        st8 [r16] = r30, 16             // and save the xmmi low
        st8 [r17] = r31, 16             // and save the xmmi high
        getf.sig r28 = f24              // get xmmi low
        getf.sig r29 = f25              // get xmmi high
        ;;

        st4 [r23] = r13, 4              // ebp

        stfe [r18] = f12, 16
        st8 [r16] = r28, 16             // and save the xmmi low
        st8 [r17] = r29, 16             // and save the xmmi high
        getf.sig r30 = f26              // get xmmi low
        getf.sig r31 = f27              // get xmmi high
        ;;

        mov teb = kteb                  // The teb is r13 which is also ebp
        st4 [r23] = r2, 8               // Store return addr as new EIP

        stfe [r18] = f13, 16
        st8 [r16] = r30, 16             // and save the xmmi low
        st8 [r17] = r31, 16             // and save the xmmi high
        getf.sig r28 = f28              // get xmmi low
        getf.sig r29 = f29              // get xmmi high
        ;;

        // Address of TLS[0]
        add  r19 = TeDeallocationStack+8 + (0 * 8), teb
        st4 [r23] = r3, 4               // Store the eflags

        stfe [r18] = f14, 16
        st8 [r16] = r28, 16             // and save the xmmi low
        st8 [r17] = r29, 16             // and save the xmmi high
        getf.sig r30 = f30              // get xmmi low
        getf.sig r31 = f31              // get xmmi high
        ;;

        ld8 r20 = [r19]                 // Get the old stack
        st4 [r23] = rEsp

        stfe [r18] = f15
        st8 [r16] = r30                 // and save the xmmi low
        st8 [r17] = r31                 // and save the xmmi high

        //
        // Make the return value from this function be the address
        // after the jmpe
        //
        mov r8 = r1
        ;;

        //
        // Put back the saved stack value
        //
        mov sp = r20

        //
        // And set the flag that says we don't need to swap stacks in
        // case of an exception
        //
        st8 [r19] = r0
        ;;

        LEAF_RETURN
        LEAF_EXIT(ProcessUserIA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\cpu\ia64\dbgexts\w64cpuex.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.cpp

Abstract:

    Debugger extension DLL for debugging the CPU

Author:

    27-Sept-1999 BarryBo

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <dbgeng.h>
#include <ntosp.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include "wow64.h"
#include "wow64cpu.h"
#include "ia64cpu.h"

// Safe release and NULL.

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define CONTEXT_OFFSET FIELD_OFFSET(TEB64, TlsSlots[WOW64_TLS_CPURESERVED])


CPUCONTEXT            LocalCpuContext;
PWOW64GETCPUDATA      CpuGetData;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

WOW64CPUDBGAPI VOID
CpuDbgInitEngapi(
    PWOW64GETCPUDATA lpGetData
    )
{
    CpuGetData = lpGetData;
}


HRESULT
EngGetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine extract the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the current thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to fill                 

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    CONTEXT ContextEM;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL;
    
    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);
  
    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    
    NtStatus = GetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PDEBUG_CLIENT Client,
    PVOID CpuData
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }
    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULLFLOAT;
    hr = EngGetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

HRESULT
EngSetContextThread(
    IN OUT PCONTEXT32 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    Context        - Context record to set

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    NTSTATUS NtStatus;
    CONTEXT ContextEM;
    ULONG64 CpuRemoteContext;
    ULONG64 Teb;
    CPUCONTEXT CpuContext;

    ContextEM.ContextFlags = CONTEXT_FULL;
    
    hr = g_ExtAdvanced->SetThreadContext(&ContextEM, sizeof(ContextEM));
    
    hr = g_ExtSystem->GetCurrentThreadTeb(&Teb);
    if (FAILED(hr)) {
        return hr;
    }

    hr = g_ExtData->ReadVirtual(Teb + CONTEXT_OFFSET,
                                &CpuRemoteContext,
                                sizeof(CpuRemoteContext),
                                NULL);

    if (FAILED(hr)) {
        return hr;
    }
    hr = g_ExtData->ReadVirtual(CpuRemoteContext,
                                &CpuContext,
                                sizeof(CpuContext),
                                NULL);
    if (FAILED(hr)) {
        return hr;
    }
    NtStatus = SetContextRecord(&CpuContext, Context);
    if (!NT_SUCCESS(NtStatus)) {
        return E_FAIL;
    }
    hr = g_ExtData->WriteVirtual(CpuRemoteContext,
                                 &CpuContext,
                                 sizeof(CpuContext),
                                 NULL);
    return hr;
}


WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    PDEBUG_CLIENT Client
    )
{
    BOOL bRet = FALSE;
    HRESULT hr;
    NTSTATUS Status;
    CONTEXT Context;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return FALSE;
    }

    LocalCpuContext.Context.ContextFlags = CONTEXT32_FULLFLOAT;
    hr = EngSetContextThread(&LocalCpuContext.Context);
    if (FAILED(hr)) {
        ExtOut("CpuDbgSetRemoteContext:  Error %x writing CPU context\n", hr);
        goto Done;
    }

    bRet = TRUE;
Done:
    ExtRelease();
    return bRet;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(GetContextRecord(&LocalCpuContext,
                                       Context));
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PDEBUG_CLIENT Client,
    PCONTEXT32 Context
    )
{
    return NT_SUCCESS(SetContextRecord(&LocalCpuContext,
                                       Context));
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCacheWithHandle(
    HANDLE Process,
    PVOID Addr,
    DWORD Length
    )
{
    
    NtFlushInstructionCache((HANDLE)Process, Addr, Length);
}


WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PDEBUG_CLIENT Client,
    PVOID Addr,
    DWORD Length
    )
{
    HRESULT hr;
    ULONG64 Process;

    hr = ExtQuery(Client);
    if (FAILED(hr)) {
        return;
    }
    hr = g_ExtSystem->GetCurrentProcessHandle(&Process);
    if (FAILED(hr)) {
        ExtOut("CpuDbgFlushInstructionCache: failed to get Process Handle!\n");
        return;
    }
    CpuDbgFlushInstructionCacheWithHandle((HANDLE)Process, Addr, Length);
    ExtRelease();
}


VOID SetEax(ULONG ul) {
    LocalCpuContext.Context.Eax = ul;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.Context.Ebx = ul;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.Context.Ecx = ul;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.Context.Edx = ul;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.Context.Esi = ul;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.Context.Edi = ul;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.Context.Ebp = ul;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.Context.Esp = ul;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.Context.Eip = ul;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.Context.EFlags = ul;
}

ULONG GetEax(VOID) {
    return LocalCpuContext.Context.Eax;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.Context.Ebx;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.Context.Ecx;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.Context.Edx;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.Context.Esi;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.Context.Edi;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.Context.Ebp;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.Context.Esp;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.Context.Eip;
}
ULONG GetEfl(VOID) {
    return LocalCpuContext.Context.EFlags;
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "Eax", SetEax, GetEax },
    { "Ebx", SetEbx, GetEbx },
    { "Ecx", SetEcx, GetEcx },
    { "Edx", SetEdx, GetEdx },
    { "Esi", SetEsi, GetEsi },
    { "Edi", SetEdi, GetEdi },
    { "Ebp", SetEbp, GetEbp },
    { "Esp", SetEsp, GetEsp },
    { "Eip", SetEip, GetEip },
    { "Efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\filever.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgeng.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64.h>
#include <wow64exts.h>
#include "filever.h"


// filever help function

VOID
PrintFileType(DWORD lBinaryType)
{
    LPCTSTR szFmtFileType = "   - ";

    if(lBinaryType < (sizeof(szType) / sizeof(szType[0])))
        szFmtFileType = szType[lBinaryType];
    ExtOut("%s", szFmtFileType);
}

VOID
PrintFileAttributes(DWORD dwAttr)
{
    DWORD   dwT;
    static const FileAttr attrs[] =
       {{FILE_ATTRIBUTE_DIRECTORY, 'd'},
        {FILE_ATTRIBUTE_READONLY,  'r'},
        {FILE_ATTRIBUTE_ARCHIVE,   'a'},
        {FILE_ATTRIBUTE_HIDDEN,    'h'},
        {FILE_ATTRIBUTE_SYSTEM,    's'} };
    TCHAR   szAttr[(sizeof(attrs) / sizeof(attrs[0])) + 1];

    for(dwT = 0; dwT < (sizeof(attrs) / sizeof(attrs[0])); dwT++)
        szAttr[dwT] = (dwAttr & attrs[dwT].dwAttr) ? attrs[dwT].ch : '-';
    szAttr[dwT] = 0;

    ExtOut("%s ", szAttr);
}

VOID
PrintFileSizeAndDate(WIN32_FIND_DATA *pfd)
{
    FILETIME    ft;
    SYSTEMTIME  st = {0};
    TCHAR       szSize[15];

    szSize[0] = 0;
    if(FileTimeToLocalFileTime(&pfd->ftLastWriteTime, &ft) &&
        FileTimeToSystemTime(&ft, &st))
    {
        TCHAR       szVal[15];
        NUMBERFMT   numfmt = {0, 0, 3, "", ",", 0};

        wsprintf(szVal, "%ld", pfd->nFileSizeLow); //$ SPEED
        GetNumberFormat(GetUserDefaultLCID(), 0, szVal, &numfmt, szSize, 15);
    }

    ExtOut(" %10s %02d-%02d-%02d", szSize, st.wMonth, st.wDay, st.wYear);
}

VOID
PrintFileVersion(VS_FIXEDFILEINFO *vs, DWORD dwLang)
{
    INT                 iType;
    TCHAR               szBuffer[100];

    dwLang = LOWORD(dwLang);

    szBuffer[0] = 0;
    for(iType = 0; iType < sizeof(ttFType) / sizeof(TypeTag); iType++)
    {
        if(vs->dwFileType == ttFType[iType].dwTypeMask)
        {
            ExtOut("%3.3s ", ttFType[iType].szTypeStr);
            break;
        }
    }
    if(iType == (sizeof(ttFType) / sizeof(TypeTag)))
        ExtOut("  - ");

    for(iType = 0; iType < sizeof(ltLang) / sizeof(LangTag); iType++)
    {
        if(dwLang == ltLang[iType].wLangId)
        {
            ExtOut("%3.3s ", ltLang[iType].szKey);
            break;
        }
    }
    if(iType == (sizeof(ltLang) / sizeof(LangTag)))
        ExtOut("  - ");

    wsprintf(szBuffer, "%u.%u.%u.%u %s",
             HIWORD(vs->dwFileVersionMS),
             LOWORD(vs->dwFileVersionMS),
             HIWORD(vs->dwFileVersionLS),
             LOWORD(vs->dwFileVersionLS),
             vs->dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp");
    
    ExtOut(" %18.18s", szBuffer);
}


DWORD
MyGetBinaryType(PSTR szFileName)
{
    HANDLE              hFile;
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    DWORD               lFileType = SCS_UNKOWN;

    if((hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
            goto err;

    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL))
        goto err;

    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
        goto err;
    lFileType = SCS_DOS_BINARY;

    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == -1)
        goto err;
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL))
        goto err;
    if((img_nt_hdrs.Signature & 0xffff) == IMAGE_OS2_SIGNATURE)
    {
        pimg_os2_hdr = (PIMAGE_OS2_HEADER)&img_nt_hdrs;
        switch(pimg_os2_hdr->ne_exetyp)
        {
        case NE_OS2:
            lFileType = SCS_OS216_BINARY;
            break;
        case NE_DEV386:
        case NE_WINDOWS:
            lFileType = SCS_WOW_BINARY;
            break;
        case NE_DOS4:
        case NE_UNKNOWN:
        default:
            // lFileType = SCS_DOS_BINARY;
            break;
        }
    }
    else if(img_nt_hdrs.Signature == IMAGE_NT_SIGNATURE)
    {
        switch(img_nt_hdrs.OptionalHeader.Subsystem)
        {
        case IMAGE_SUBSYSTEM_OS2_CUI:
            lFileType = SCS_OS216_BINARY;
            break;
        case IMAGE_SUBSYSTEM_POSIX_CUI:
            lFileType = SCS_POSIX_BINARY;
            break;
        case IMAGE_SUBSYSTEM_NATIVE:
        case IMAGE_SUBSYSTEM_WINDOWS_GUI:
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:
        default:
            switch(img_nt_hdrs.FileHeader.Machine)
            {
            case IMAGE_FILE_MACHINE_I386:
                lFileType = SCS_32BIT_BINARY_INTEL;
                break;
            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
                lFileType = SCS_32BIT_BINARY_MIPS;
                break;
            case IMAGE_FILE_MACHINE_ALPHA:
                lFileType = SCS_32BIT_BINARY_ALPHA;
                break;
            case IMAGE_FILE_MACHINE_ALPHA64:
                lFileType = SCS_32BIT_BINARY_AXP64;
                break;
            case IMAGE_FILE_MACHINE_IA64:
                lFileType = SCS_32BIT_BINARY_IA64;
                break;
            case IMAGE_FILE_MACHINE_POWERPC:
                lFileType = SCS_32BIT_BINARY_PPC;
                break;
            default:
            case IMAGE_FILE_MACHINE_UNKNOWN:
                lFileType = SCS_32BIT_BINARY;
                break;
            }
            break;
        }
    }

err:
    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return lFileType;
}

VOID
PrintFixedFileInfo(LPSTR FileName, LPVOID lpvData, BOOL Verbose)
{
    VS_FIXEDFILEINFO    *pvs;
    LPVOID              lpInfo;
    TCHAR               key[80];
    DWORD               dwLength, Btype;
    DWORD               *pdwTranslation;
    UINT                i, iType, cch, uLen;
    DWORD               dwDefLang = 0x409;
    HANDLE              hf;
    WIN32_FIND_DATA     fd;


        
    if (!VerQueryValue(lpvData, "\\", (LPVOID*)&pvs, &uLen) || pvs == NULL) {
        ExtOut("VerQueryValue failed!\n");
        return;
    }

    if(!VerQueryValue(lpvData, "\\VarFileInfo\\Translation", (PVOID*)&pdwTranslation, &uLen))
    {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    hf = FindFirstFile(FileName, &fd);
    if (hf == INVALID_HANDLE_VALUE) {
	ExtOut("FindFirstFile %s failed, gle %d\n", FileName, GetLastError());
	return;
    }
    PrintFileAttributes(fd.dwFileAttributes);
    Btype = MyGetBinaryType(FileName);
    PrintFileType(Btype);
    PrintFileVersion(pvs ,*pdwTranslation);
    PrintFileSizeAndDate(&fd);
    ExtOut("\n");
    
    if (!Verbose) {
        return;
    }

    while(uLen)
    {
        // Language
        ExtOut("\tLanguage\t0x%04x", LOWORD(*pdwTranslation));
        if(VerLanguageName(LOWORD(*pdwTranslation), key, sizeof(key) / sizeof(TCHAR))) {
            ExtOut(" (%s)", key);
        }
        ExtOut("\n");

        // CharSet
        ExtOut("\tCharSet\t\t0x%04x", HIWORD(*pdwTranslation));
        for(iType = 0; iType < sizeof(ltCharSet)/sizeof(CharSetTag); iType++)
        {
            if(HIWORD(*pdwTranslation) == ltCharSet[iType].wCharSetId)
            ExtOut(" %s", ltCharSet[iType].szDesc);
        }
        ExtOut("\n");

    tryagain:
        wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
            LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

        lstrcat(key, "OleSelfRegister");
        ExtOut("\t%s\t%s\n", "OleSelfRegister",
            VerQueryValue(lpvData, key, &lpInfo, &cch) ? "Enabled" : "Disabled");

        for(i = 0; i < (sizeof(VersionKeys) / sizeof(VersionKeys[0])); i++)
        {
            wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
                LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));
            lstrcat(key, VersionKeys[i]);

            if(VerQueryValue(lpvData, key, &lpInfo, &cch))
            {
                lstrcpy(key, VersionKeys[i]);
                key[15] = 0;
                ExtOut("\t%s\t%s\n", key, lpInfo);
            }
        }

        // if the Lang is neutral, go try again with the default lang
        // (this seems to work with msspell32.dll)
        if(LOWORD(*pdwTranslation) == 0)
        {
            pdwTranslation = &dwDefLang;
            goto tryagain;
        }

        uLen -= sizeof(DWORD);
        pdwTranslation++;
        ExtOut("\n");
    }


    ExtOut("\tVS_FIXEDFILEINFO:\n");
    ExtOut("\tSignature:\t%08.8lx\n", pvs->dwSignature);
    ExtOut("\tStruc Ver:\t%08.8lx\n", pvs->dwStrucVersion);
    ExtOut("\tFileVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwFileVersionMS, pvs->dwFileVersionLS,
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS));
    ExtOut("\tProdVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwProductVersionMS, pvs->dwProductVersionLS,
        HIWORD(pvs->dwProductVersionMS), LOWORD(pvs->dwProductVersionMS),
        HIWORD(pvs->dwProductVersionLS), LOWORD(pvs->dwProductVersionLS));

    ExtOut("\tFlagMask:\t%08.8lx\n", pvs->dwFileFlagsMask);
    ExtOut("\tFlags:\t\t%08.8lx", pvs->dwFileFlags);
    PrintFlagsMap(ttFileFlags, pvs->dwFileFlags);

    ExtOut("\n\tOS:\t\t%08.8lx", pvs->dwFileOS);
    PrintFlagsVal(ttFileOsHi, pvs->dwFileOS & 0xffff000);
    PrintFlagsVal(ttFileOsLo, LOWORD(pvs->dwFileOS));

    ExtOut("\n\tFileType:\t%08.8lx", pvs->dwFileType);
    PrintFlagsVal(ttFType, pvs->dwFileType);

    ExtOut("\n\tSubType:\t%08.8lx", pvs->dwFileSubtype);
    if(pvs->dwFileType == VFT_FONT)
    {
        PrintFlagsVal(ttFTypeFont, pvs->dwFileSubtype);
    }
    else if(pvs->dwFileType == VFT_DRV)
    {
        PrintFlagsVal(ttFTypeDrv, pvs->dwFileSubtype);
    }
    ExtOut("\n\tFileDate:\t%08.8lx:%08.8lx\n", pvs->dwFileDateMS, pvs->dwFileDateLS);
}

HRESULT
FindFullImage32Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    )
{
    PPEB32 peb32;
    PLIST_ENTRY32 LdrHead32, LdrNext32;
    PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
    LDR_DATA_TABLE_ENTRY32 LdrEntryData32;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    SIZE_T Length;
    ULONG TempPtr32;
    UNICODE_STRING TempCopy;

    HRESULT Status = E_FAIL;
    
    Status=GetPeb32Addr((ULONG64*)&peb32);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    Status = g_ExtData->ReadVirtual((ULONG64)&(peb32->Ldr),
                                    &TempPtr32,
                                    sizeof(ULONG),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    LdrHead32 = &((PPEB_LDR_DATA32)TempPtr32)->InLoadOrderModuleList;

    Status = g_ExtData->ReadVirtual((ULONG64)&(LdrHead32->Flink),
                                    &TempPtr32,
                                    sizeof(ULONG),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrNext32 = (PLIST_ENTRY32)TempPtr32;

    while( LdrNext32 != LdrHead32) {
        LdrEntry32 = CONTAINING_RECORD(LdrNext32,LDR_DATA_TABLE_ENTRY32,InLoadOrderLinks);
        Status = g_ExtData->ReadVirtual((ULONG64)LdrEntry32,
                                        &LdrEntryData32,
                                        sizeof(LdrEntryData32),
                                        NULL);
        if (FAILED(Status)) {
            break;
        }
    
        if ((ULONG64)LdrEntryData32.DllBase == DllBase) {
            RtlZeroMemory(&LdrEntryData, sizeof(LDR_DATA_TABLE_ENTRY));
            
            UStr32ToUStr(&LdrEntryData.FullDllName, &LdrEntryData32.FullDllName);
            
            Length = LdrEntryData.FullDllName.MaximumLength;
            if (Length > NameBufferSize) {
                Status = STATUS_NO_MEMORY;
                break;
            }

            TempCopy = LdrEntryData.FullDllName;
            TempCopy.Buffer = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (TempCopy.Buffer == NULL) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            
            Status = g_ExtData->ReadVirtual((ULONG64)LdrEntryData.FullDllName.Buffer,
                                            TempCopy.Buffer,
                                            (ULONG)Length,
                                            NULL);
            if (FAILED(Status)) {
                RtlFreeUnicodeString(&TempCopy);
                break;
            }


            wcstombs(NameBuffer, TempCopy.Buffer, NameBufferSize );
            break;
        }
        
        LdrNext32 = (PLIST_ENTRY32)LdrEntryData32.InLoadOrderLinks.Flink;
        Status = E_FAIL;

    }

QUIT:
    return Status;

}

HRESULT
FindFullImage64Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    )
{
    PPEB64 peb64;
    PLIST_ENTRY LdrHead64, LdrNext64;
    PLDR_DATA_TABLE_ENTRY LdrEntry64;
    LDR_DATA_TABLE_ENTRY LdrEntryData64;
    
    SIZE_T Length;
    ULONG64 TempPtr64;
    HRESULT Status =E_FAIL;
    
    Status=GetPeb64Addr((ULONG64*)&peb64);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    Status = g_ExtData->ReadVirtual((ULONG64)&peb64->Ldr,
                                    &TempPtr64,
                                    sizeof(TempPtr64),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrHead64 = &((PPEB_LDR_DATA)TempPtr64)->InLoadOrderModuleList;
    
    Status = g_ExtData->ReadVirtual((ULONG64)&LdrHead64->Flink,
                                    &TempPtr64,
                                    sizeof(TempPtr64),
                                    NULL);
    if (FAILED(Status)) {
        goto QUIT;
    }
    
    LdrNext64 = (PLIST_ENTRY)TempPtr64;

    while( LdrNext64 != LdrHead64) {
        LdrEntry64 = CONTAINING_RECORD(LdrNext64,LDR_DATA_TABLE_ENTRY,InLoadOrderLinks);
        Status = g_ExtData->ReadVirtual((ULONG64)LdrEntry64,
                                        &LdrEntryData64,
                                        sizeof(LdrEntryData64),
                                        NULL);
        if (FAILED(Status)) {
            break;
        }
    
        if ((ULONG64)LdrEntryData64.DllBase == DllBase) {
            
            Length = LdrEntryData64.FullDllName.MaximumLength;
            if (Length > NameBufferSize) {
                Status= STATUS_NO_MEMORY;
                break;
            } 

	    Status = g_ExtData->ReadVirtual((ULONG64)LdrEntryData64.FullDllName.Buffer,
					    NameBuffer,
                                            (ULONG)Length,
                                            NULL);
	    break;
        }
        
        LdrNext64 = (PLIST_ENTRY)LdrEntryData64.InLoadOrderLinks.Flink;
        Status = E_FAIL;

    }
QUIT:    
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\filever.h ===
#ifndef __WOW64_EXTS_FILEVER_H__
#define __WOW64_EXTS_FILEVER_H__

/*
VOID PrintFileType(DWORD lBinaryType);
VOID PrintFileAttributes(DWORD dwAttr);
VOID PrintFileSizeAndDate(WIN32_FIND_DATA *pfd);
VOID PrintFileVersion(LPTSTR szFileName);

BOOL FListFiles(LPTSTR szDir, LPTSTR szPat);
DWORD MyGetBinaryType(LPTSTR szFileName);
VOID __cdecl PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...);
*/

#define FA_DIR(_x)    ((_x) & FILE_ATTRIBUTE_DIRECTORY)

// filever cmd line flags
#define FSTR_RECURSE    0x0001
#define FSTR_VERBOSE    0x0002
#define FSTR_EXESONLY   0x0004
#define FSTR_SHORTNAME  0x0008
#define FSTR_BAREFORMAT 0x0010
#define FSTR_PRINTDIR   0x0020
#define FSTR_NOATTRS    0x0040
#define FSTR_NODATETIME 0x0080
#ifdef DEBUG
#define FSTR_DEBUG      0x8000
#endif


// used by filever
#define PrintFlagsMap(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) & _structname[iType].dwTypeMask) \
            ExtOut(" %s", _structname[iType].szFullStr); \
    }

#define PrintFlagsVal(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) == _structname[iType].dwTypeMask) \
        { \
            ExtOut(" %s", _structname[iType].szFullStr); \
            break; \
        } \
    }


// PrintFileAttr struct
typedef struct _FileAttr
{
    DWORD dwAttr;
    TCHAR ch;
} FileAttr;

// MyGetBinaryType exe type defines
#define NE_UNKNOWN  0x0     /* Unknown (any "new-format" OS) */
#define NE_OS2      0x1     /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS  0x2     /* Microsoft Windows */
#define NE_DOS4     0x3     /* Microsoft MS-DOS 4.x */
#define NE_DEV386   0x4     /* Microsoft Windows 386 */

// MyGetBinaryType return values
enum {
    // SCS_32BIT_BINARY,
    // SCS_DOS_BINARY,
    // SCS_WOW_BINARY,
    // SCS_PIF_BINARY,
    // SCS_POSIX_BINARY,
    // SCS_OS216_BINARY,
    SCS_32BIT_BINARY_INTEL = SCS_OS216_BINARY + 1,
    SCS_32BIT_BINARY_MIPS,
    SCS_32BIT_BINARY_ALPHA,
    SCS_32BIT_BINARY_PPC,
    SCS_32BIT_BINARY_AXP64,
    SCS_32BIT_BINARY_IA64
};
#define SCS_UNKOWN      (DWORD)-1

static const TCHAR   *szType[] = {
    "W32    ",
    "DOS    ",
    "W16    ",
    "PIF    ",
    "PSX    ",
    "OS2    ",
    "W32i   ",
    "W32m   ",
    "W32a   ",
    "W32p   ",
    "W32a64 ",
    "W32i64 ",
};

CONST static TCHAR *VersionKeys[] =
{
    TEXT("CompanyName"),
    TEXT("FileDescription"),
    TEXT("InternalName"),
    TEXT("OriginalFilename"),
    TEXT("ProductName"),
    TEXT("ProductVersion"),
    TEXT("FileVersion"),
    TEXT("LegalCopyright"),
    TEXT("LegalTrademarks"),
    TEXT("PrivateBuild"),
    TEXT("SpecialBuild"),
    TEXT("Comments")
};

// languages map
typedef struct _LangTag {
	WORD		wLangId;
	LPSTR		szName;
	LPSTR		szDesc;
	LPSTR		szKey;
} LangTag;

CONST static LangTag ltLang[] =
{
	{0x0406,"Danish","Danish","DAN"},
	{0x0413,"Dutch","Dutch (Standard)","NLD"},
	{0x0813,"Dutch","Belgian (Flemish)","NLB"},
	{0x0409,"English","American","ENU"},
	{0x0809,"English","British","ENG"},
	{0x0c09,"English","Australian","ENA"},
	{0x1009,"English","Canadian","ENC"},
	{0x1409,"English","New Zealand","ENZ"},
	{0x1809,"English","Ireland","ENI"},
	{0x040b,"Finnish","Finnish","FIN"},
	{0x040c,"French","French (Standard)","FRA"},
	{0x080c,"French","Belgian","FRB"},
	{0x0c0c,"French","Canadian","FRC"},
	{0x100c,"French","Swiss","FRS"},
	{0x0407,"German","German (Standard)","DEU"},
	{0x0807,"German","Swiss","DES"},
	{0x0c07,"German","Austrian","DEA"},
	{0x040f,"Icelandic","Icelandic","ISL"},
	{0x0410,"Italian","Italian (Standard)","ITA"},
	{0x0810,"Italian","Swiss","ITS"},
	{0x0414,"Norwegian","Norwegian (Bokmal)","NOR"},
	{0x0814,"Norwegian","Norwegian (Nynorsk)","NON"},
	{0x0416,"Portuguese","Portuguese (Brazilian)","PTB"},
	{0x0816,"Portuguese","Portuguese (Portugal)","PTG"},
	{0x041D,"Swedish","Swedish","SVE"},
	{0x040a,"Spanish","Spanish (Standard/Traditional)","ESP"},
	{0x080a,"Spanish","Mexican","ESM"},
	{0x0c0a,"Spanish","Spanish (Spain)","ESN"},
	{0x041f,"Turkish","TRK","TRK"},
	{0x0415,"Polish","PLK","PLK"},
	{0x0405,"Czech","CSY","CSY"},
	{0x041b,"Slovak","SKY","SKY"},
	{0x040e,"Hungarian","HUN","HUN"},
	{0x0419,"Russian","RUS","RUS"},
	{0x0408,"Greek","ELL","ELL"},
	{0x0804,"Chinese","CHS","CHS"},
	{0x0404,"Taiwan","CHT","CHT"},
	{0x0411,"Japan","JPN","JPN"},
	{0x0412,"Korea","KOR","KOR"}
};

// languages map
typedef struct _CharSetTag {
	WORD		wCharSetId;
	LPSTR		szDesc;
} CharSetTag;

CONST static CharSetTag ltCharSet[] =
{
	{0, "7-bit ASCII"},
	{932, "Windows, Japan (Shift  JIS X-0208)"},
	{949, "Windows, Korea (Shift  KSC 5601)"},
	{950, "Windows, Taiwan (GB5)"},
	{1200, "Unicode"},
	{1250, "Windows, Latin-2 (Eastern European)"},
	{1251, "Windows, Cyrillic"},
	{1252, "Windows, Multilingual"},
	{1253, "Windows, Greek"},
	{1254, "Windows, Turkish"},
	{1255, "Windows, Hebrew"},
	{1256, "Windows, Arabic"}
};

typedef struct  _ffTypeTag {
    DWORD   dwTypeMask;
    LPSTR   szTypeStr;
    LPSTR   szFullStr;
} TypeTag;

// file flags map

TypeTag  ttFileFlags[]= {
    { VS_FF_DEBUG,       "D",   "debug"},
    { VS_FF_PRERELEASE,  "P",   "prerelease"},
    { VS_FF_PATCHED,     "A",   "patched"},
    { VS_FF_PRIVATEBUILD,"I",   "private"},
    { VS_FF_INFOINFERRED,"F",   "infoInferred"},
    { VS_FF_SPECIALBUILD,"S",   "special"}
};

// file OS map

TypeTag ttFileOsHi[] = {
    { VOS_DOS,          "DOS",  "MS-DOS"},
    { VOS_OS216,        "O16",  "OS2/16"},
    { VOS_OS232,        "O32",  "OS2/32"},
    { VOS_NT,           "NT",   "NT"},
};

TypeTag ttFileOsLo[] = {
    { VOS__WINDOWS16,   "Win16","Win16"},
    { VOS__PM16,        "PM16", "PM16"},
    { VOS__PM32,        "PM32", "PM32"},
    { VOS__WINDOWS32,   "Win32","Win32"}
};

// type map
TypeTag  ttFType[] = {
    { VFT_APP,          "APP",  "App"},
    { VFT_DLL,          "DLL",  "Dll"},
    { VFT_DRV,          "DRV",  "Driver"},
    { VFT_FONT,         "FNT",  "Font"},
    { VFT_VXD,          "VXD",  "VXD"},
    { VFT_STATIC_LIB,   "LIB",  "lib"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
TypeTag ttFTypeDrv[] = {
	{ VFT2_DRV_PRINTER, "", "PrinterDrv"},
	{ VFT2_DRV_KEYBOARD, "", "KeyBoardDrv"},
	{ VFT2_DRV_LANGUAGE, "", "LangDrv"},
	{ VFT2_DRV_DISPLAY, "", "DisplayDrv"},
	{ VFT2_DRV_MOUSE, "", "MouseDrv"},
	{ VFT2_DRV_NETWORK, "", "NetworkDrv"},
	{ VFT2_DRV_SYSTEM, "", "SystemDrv"},
	{ VFT2_DRV_INSTALLABLE, "", "InstallableDrv"},
	{ VFT2_DRV_SOUND, "", "SoundDrv"},
	{ VFT2_DRV_COMM, "", "CommDrv"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
TypeTag ttFTypeFont[] = {
	{ VFT2_FONT_RASTER, "", "Raster"},
	{ VFT2_FONT_VECTOR, "", "Vectore"},
	{ VFT2_FONT_TRUETYPE, "", "Truetype"}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\log.cpp ===
/*++                 

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    log.c

Abstract:
    
    This module contains debugger extensions to control logging in a Wow64
    process.

Author:

    07-Oct-1999   SamerA

Revision History:
    
    3-Jul-2000  t-tcheng    switch to new debugger engine 
    
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>

#if defined _X86_
#define WOW64EXTS_386
#endif 

#include <wow64.h>
#include "wow64exts.h"

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>

#include <cathelper.h>
#include <apimap.c>

typedef struct _LogFlagName
{
    UINT_PTR Value;
    PSZ Name;
    PSZ Description;
} LogFlagName, *PLogFlagName;
 
LogFlagName LogFlags[] = 
{
    {LF_ERROR,       "LF_ERROR"       , "Log error messages"},
    {LF_TRACE,       "LF_TRACE"       , "Log trace messages"},
    {LF_NTBASE_NAME, "LF_NTBASE_NAME" , "Log NT base API names"},
    {LF_NTBASE_FULL, "LF_NTBASE_FULL" , "Log NT base API names and parameters"},
    {LF_WIN32_NAME,  "LF_WIN32_NAME"  , "Log WIN32 API names"},
    {LF_WIN32_FULL,  "LF_WIN32_FULL"  , "Log WIN32 API names and parameters"},
    {LF_NTCON_NAME,  "LF_NTCON_NAME"  , "Log Console API names"},
    {LF_NTCON_FULL,  "LF_NTCON_FULL"  , "Log Console API names and parameters"},
    {LF_BASE_NAME,   "LF_BASE_NAME"   , "Log Base/NLS API names"},
    {LF_BASE_FULL,   "LF_BASE_FULL"   , "Log Base/NLS API names and parameters"},
    {LF_CATLOG,      "LF_CATLOG"      , "API category logging extensions"},
    {LF_EXCEPTION,   "LF_EXCEPTION"   , "Log exceptions that happen while reading parameters off the 32-bit stack"},
    {LF_CONSOLE,     "LF_CONSOLE"     , "Log to console debugger window"},
};



VOID
LogFlagsHelp(
    VOID)
{
    ULONG i=0;

    ExtOut("Usage:!lf <flags>\n");
    ExtOut("Valid logging flags are :\n");
    while (i < (sizeof(LogFlags) / sizeof(LogFlagName)))
    {
        ExtOut("%-16s - 0x%-8lx : %s\n",
                      LogFlags[i].Name,
                      LogFlags[i].Value,
                      LogFlags[i].Description);
        i++;
    }
}



VOID 
LogToFileHelp(
    VOID)
{
    ExtOut("Usage:!l2f <filename>\n");

    return;
}



DECLARE_ENGAPI(lf)
/*++

Routine Description:

    This routine sets/dumps the wow64 logging flags.
    
    Called as :
    
    !lf <optional flags>

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    NTSTATUS NtStatus;
    UINT_PTR Flags;
    ULONG_PTR Ptr;
    ULONG NewFlags, i=0;
    HANDLE Process;
    INIT_ENGAPI;

    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);
    Status = TryGetExpr("wow64log!wow64logflags", &Ptr);
    if ((FAILED(Status)) || (!Ptr))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    Status = g_ExtData->ReadVirtual((ULONG64)Ptr, &Flags, sizeof(UINT_PTR), NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't read Wow64log!Wow64LogFlags - %lx\n", Status);
        EXIT_ENGAPI;
    }



    //
    // Read expression and set the value
    //
    if (ArgumentString && *ArgumentString) 
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogFlagsHelp();
            EXIT_ENGAPI;
        }

        sscanf( ArgumentString, "%lx", &NewFlags );

        if (!NewFlags) 
        {
            // Make sure it's a valid input
            while (*ArgumentString) 
            {
                if (!((*ArgumentString >= '0') &&  (*ArgumentString <= '9') ||
                      (*ArgumentString >= 'a') &&  (*ArgumentString <= 'f') ||
                      (*ArgumentString >= 'A') &&  (*ArgumentString <= 'F')))
                {
                    EXIT_ENGAPI;
                }
                ArgumentString++;
            }
        }

        Flags = NewFlags;
        Status = g_ExtData->WriteVirtual((ULONG64)Ptr, &Flags, sizeof(ULONG_PTR), NULL);
        if (FAILED(Status)) 
        {
            ExtOut("Couldn't write log flags [%lx] - %lx\n", Ptr, Status);
        }
    }
    else
    {
        ExtOut("Wow64 Log Flags = %I64x:\n", Flags);
        if (!Flags) 
        {
            ExtOut("No Flags\n");
        }
        else
        {
            while (i < (sizeof(LogFlags) / sizeof(LogFlagName)))
            {
                if (Flags & LogFlags[i].Value)
                {
                    ExtOut("%s\n", LogFlags[i].Name);
                }
                i++;
            }
        }
    }

    EXIT_ENGAPI;
}



DECLARE_ENGAPI(l2f)
/*++

Routine Description:

    This routine enable wow64 logging to file.
    
    Called as :
    
    !l2f <optional filename>

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    HANDLE LogFileHandle, TargetHandle;
    ULONG_PTR Ptr;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS NtStatus;
    WCHAR FileName_U[ MAX_PATH ];
    POBJECT_NAME_INFORMATION ObjectNameInfo = (POBJECT_NAME_INFORMATION) FileName_U;
    HANDLE Process;
    INIT_ENGAPI;

    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);

    //
    // check if the target process has already opened a logfile
    //
    Status = TryGetExpr("wow64log!wow64logfilehandle", &Ptr);
    if ((FAILED(Status)) || (!Ptr)) 
    {
        ExtOut("Wow64log.dll isn't loaded. To enable Wow64 file-logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        EXIT_ENGAPI;
    }

    Status = g_ExtData->ReadVirtual((ULONG64)Ptr, 
                                   &LogFileHandle, 
                                   sizeof(HANDLE), 
                                   NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't retreive Wow64LogFileHandle - %lx\n", Status);
        EXIT_ENGAPI;
    }


    //
    // Create the file
    //
    if ((ArgumentString) &&
        (*ArgumentString) &&
        (LogFileHandle == INVALID_HANDLE_VALUE))
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogToFileHelp();
            EXIT_ENGAPI;
        }


        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 ArgumentString,
                                 -1,
                                 FileName_U,
                                 sizeof(FileName_U)/sizeof(WCHAR)))
        {
            ExtOut("Couldn't convert %s to unicode\n", ArgumentString);
            EXIT_ENGAPI;
        }


        if(!RtlDosPathNameToNtPathName_U(FileName_U, &NtFileName,NULL,NULL)) 
        {
            ExtOut("Couldn't convert %s to NT style pathname\n", ArgumentString);
            EXIT_ENGAPI;
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &NtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Open a new file (truncate to zero if exists)
        //
        NtStatus = NtCreateFile(&LogFileHandle,
                                SYNCHRONIZE | GENERIC_WRITE,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,
                                0,
                                FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OVERWRITE_IF,
                                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,
                                0);

        RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

        if(!NT_SUCCESS(NtStatus)) 
        {
            ExtOut("Couldn't create %s - %lx\n", ArgumentString, NtStatus);
            EXIT_ENGAPI;
        }

        //
        // Let's duplicate the file handle into the debuggee
        //
        if (!DuplicateHandle(GetCurrentProcess(),
                             LogFileHandle,
                             Process,
                             &TargetHandle,
                             0,
                             FALSE,
                             DUPLICATE_SAME_ACCESS))
        {
            ExtOut("Couldn't duplicate handle into debuggee - GetLastError=%lx\n", GetLastError());
            EXIT_ENGAPI;
        }

        CloseHandle(LogFileHandle);

        Status = g_ExtData->WriteVirtual((ULONG64)Ptr, &TargetHandle, sizeof(HANDLE), NULL);
        if (FAILED(Status)) 
        {
            ExtOut("Couldn't write logfile handle - %lx\n", Status);
        }
    }
    else
    {
        LogToFileHelp();

        if (LogFileHandle != INVALID_HANDLE_VALUE)
        {
            if (DuplicateHandle(Process, 
                                LogFileHandle,
                                GetCurrentProcess(), 
                                &TargetHandle,
                                0, 
                                FALSE,
                                DUPLICATE_SAME_ACCESS))
            {
                NtStatus = NtQueryObject(TargetHandle,
                                         ObjectNameInformation,
                                         ObjectNameInfo,
                                         sizeof(FileName_U),
                                         NULL);

                CloseHandle(TargetHandle);
                if (NT_SUCCESS(NtStatus))
                {
                    ExtOut("Log file name : %ws\n",
                                  ObjectNameInfo->Name.Buffer ? ObjectNameInfo->Name.Buffer : L"None");
                }
                else
                {
                    ExtOut("Couldn't retreive log file name - %lx\n", NtStatus);
                }
            }
        }

    }

    EXIT_ENGAPI;
}


VOID 
LogCategoriesHelp(
    VOID)
{
    ExtOut("Log Categories:\n");
    ExtOut("    !wow64lc                      List all Categories\n");
    ExtOut("    !wow64lc [e|d] *              Enable/Disable all categories\n");
    ExtOut("    !wow64lc [e|d] #              Enable/Disable category #\n");
    ExtOut("    !wow64lc c #                  List APIs in category #\n");
    ExtOut("    !wow64lc a # [e|ef|d] *       Enable/EnableFailOnly/Disable all APIs within category #\n");
    ExtOut("    !wow64lc a # [e|ef|d] #       Enable/EnableFailOnly/Disable API # within category #\n");
    ExtOut("    !wow64lc n [e|ef|d|l] substr  Enable/EnableFailOnly/Disable/List APIs containing substr in their name\n");

    return;
}

VOID
ParsePatternString(
    char*   patternString,
    char**  token1,
    char**  token2,
    BOOL*   leadWC,
    BOOL*   trailWC)
/*++

Routine Description:

    This routine parses the pattern match string argument to support wild card matching
    
    cases supported:
        wild card with no token -                           '*'
        leading wild card with single token                 '*XXX'
        leading and trailing wild cards with single token   '*XXX*'
        single token with trailing wild card                'XXX*'
        two tokens with embedded wild card                  'XXX*YYY'
    
Arguments:

    patternString   - the pattern match string to be parsed
    token1          - the first token parsed from the string
    token2          - the second token
    leadWC          - TRUE if leading wild card found
    trailWC         - TRUE if trailing wild card found
    
Return Value:

--*/
{
    char    seps[] = "*";

    // look for leading wild card
    if( '*' == *patternString )
    {
        *leadWC = TRUE;
    } else
    {
        *leadWC = FALSE;
    }

    // check for trailing wild card
    if( '*' == patternString[strlen(patternString)-1] )
    {
        *trailWC = TRUE;
    } else
    {
        *trailWC = FALSE;
    }

    // read the first token
    *token1 = strtok( patternString, seps );

    if( NULL != *token1 )
    {
        // read the second token
        *token2 = strtok( NULL, seps );
    } else
    {
        *token2 = NULL;
    }
}

BOOL
StringMatchWithWildcard(
    char*   testString,
    char*   token1,
    char*   token2,
    BOOL    leadWC,
    BOOL    trailWC)
/*++

Routine Description:

    This routine determines whether the string spec is a match with testString.
    
    cases supported:
        wild card with no token -                           '*'
        leading wild card with single token                 '*XXX'
        leading and trailing wild cards with single token   '*XXX*'
        single token with trailing wild card                'XXX*'
        two tokens with embedded wild card                  'XXX*YYY'
    
Arguments:

    testString  - the string to evaluate
    token1      - the first token to check
    token2      - the second token
    leadWC      - TRUE if leading wild card
    trailWC     - TRUE if trailing wild card
    
Return Value:

    TRUE - Match, FALSE - No Match
    
--*/
{
    if( TRUE == leadWC )
    {
        if( NULL == token1 )
        {
            // wildcard with no token case - match all
            return TRUE;
        }

        if( TRUE == trailWC )
        {
            // leading and trailing wild cards and token - match if token is in test string
            if( NULL != strstr( testString, token1 ) )
            {
                return TRUE;
            }

        } else
        {
            // leading wild card and token - match if end of test string matches token1
            if( 0 == strcmp( &(testString[strlen(testString)-strlen(token1)]), token1 ) )
            {
                return TRUE;
            }
        }

    } else
    {
        if( NULL == token1 )
        {
            return FALSE;
        }

        // check token1
        if( 0 != strncmp( testString, token1, strlen(token1) ) )
        {
            return FALSE;
        }

        if( NULL == token2 )
        {
            // match leading token with trailing wild card
            if( TRUE == trailWC )
            {
                return TRUE;
            } else
            {
                // single token no wild card - exact match only
                if( 0 == strcmp( testString, token1 ) )
                {
                    return TRUE;
                }
            }

        } else
        {
            // leading and trailing tokens - match if end of test string matches token2
            if( 0 == strcmp( &(testString[strlen(testString)-strlen(token2)]), token2 ) )
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}




DECLARE_ENGAPI(wow64lc)
/*++

Routine Description:

    This routine lists all of the API catgories
    
    Called as :
    
    !w64lc

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    NTSTATUS NtStatus;
    UINT_PTR Flags;
    ULONG CatNumber;
    ULONG TargetCatNumber;
    ULONG ApiNumber;
    ULONG TargetApiNumber;
    HANDLE Process;

    ULONG_PTR Ptr;
    ULONG_PTR FlagPtr;
    ULONG_PTR MapPtr;
    API_CATEGORY ApiCategory;
    API_CATEGORY_MAPPING ApiMapping;
    ULONG EnDis = 0;
    BOOL WildCard = FALSE;
    BOOL ApiMod = FALSE;

    char CategoryName[MAX_PATH];
    char ApiName[MAX_PATH];
    INIT_ENGAPI;

    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);
    Status = TryGetExpr("wow64log!Wow64ApiCategories", (PULONG_PTR)&Ptr);
    if ((FAILED(Status)) || (!Ptr))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    // attempt to access wow64logflags
    Status = TryGetExpr("wow64log!wow64logflags", &FlagPtr);
    if ((FAILED(Status)) || (!FlagPtr))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    // read the current flags
    Status = g_ExtData->ReadVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't read Wow64log!Wow64LogFlags - %lx\n", Status);
        EXIT_ENGAPI;
    }

    //
    // Parse the command line
    //
    if (ArgumentString && *ArgumentString) 
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogCategoriesHelp();
            EXIT_ENGAPI;
        }

        switch( *ArgumentString )
        {
            case 'n':
            case 'N':
                {
                    PAPI_CATEGORY CurrentPtr = (PAPI_CATEGORY)Ptr;
                    PAPI_CATEGORY_MAPPING CurrentMapPtr;
                    char    seps[] = " \t\n";
                    char*   token;
                    char*   token1;
                    char*   token2;
                    BOOL    leadWC;
                    BOOL    trailWC;

                    ArgumentString++;

                    // read the enable/disable/list parameter
                    token = strtok( ArgumentString, seps );
                    if( !token )
                    {
                        LogCategoriesHelp();
                        EXIT_ENGAPI;
                    }

                    switch(*token)
                    {
                        case 'e':
                        case 'E':
                            if( (*(token+1) == 'f') ||
                                (*(token+1) == 'F') )
                            {
                                EnDis = APIFLAG_ENABLED | APIFLAG_LOGONFAIL;
                            } else
                            {
                                EnDis = APIFLAG_ENABLED;
                            }
                            ApiMod = TRUE;
                            break;

                        case 'd':
                        case 'D':
                            EnDis = 0;
                            ApiMod = TRUE;
                            break;

                        case 'l':
                        case 'L':
                            ApiMod = FALSE;
                            break;

                        default:
                            LogCategoriesHelp();
                            EXIT_ENGAPI;
                            break;
                    }

                    // read the API substr parameter
                    token = strtok( NULL, seps );
                    if( !token )
                    {
                        LogCategoriesHelp();
                        EXIT_ENGAPI;
                    }

                    // parse the substr parameter
                    ParsePatternString( token, &token1, &token2, &leadWC, &trailWC );

                    // get the category mappings...
                    Status = TryGetExpr("wow64log!Wow64ApiCategoryMappings", (PULONG_PTR)&MapPtr);
                    if ((FAILED(Status)) || (!MapPtr))
                    {
                        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
                        ExtOut("Only LF_ERROR is enabled\n");
                        EXIT_ENGAPI;
                    }

                    CurrentMapPtr = (PAPI_CATEGORY_MAPPING)MapPtr;

                    do
                    {
                        // read in a category mapping
                        Status = g_ExtData->ReadVirtual((ULONG64)CurrentMapPtr, &ApiMapping, sizeof(API_CATEGORY_MAPPING), NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        if( ApiMapping.ApiName == NULL )
                            break;

                        // read the api name
                        Status = g_ExtData->ReadVirtual((ULONG64)(ApiMapping.ApiName), ApiName, MAX_PATH, NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        //make sure that we have a null terminated api name
                        ApiName[MAX_PATH-1] = 0;

                        // check to see if the api name contains that substring
                        if( TRUE == StringMatchWithWildcard(ApiName, token1, token2, leadWC, trailWC) )
                        {
                            if( TRUE == ApiMod )
                            {
                                // make sure that the category is enabled if we are enabling the API
                                if( 0 != (EnDis & APIFLAG_ENABLED) )
                                {
                                    // read in the corresponding category
                                    Status = g_ExtData->ReadVirtual((ULONG64)(&(CurrentPtr[ApiMapping.ApiCategoryIndex])), &ApiCategory, sizeof(API_CATEGORY), NULL);
                                    if (FAILED(Status)) 
                                    {
                                        ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                                        EXIT_ENGAPI;
                                    }

                                    // set the category enable bit if needed
                                    if( ApiCategory.CategoryFlags == 0 )
                                    {
                                        ApiCategory.CategoryFlags = CATFLAG_ENABLED;

                                        // write the category back
                                        Status = g_ExtData->WriteVirtual((ULONG64)(&(CurrentPtr[ApiMapping.ApiCategoryIndex])), &ApiCategory, sizeof(API_CATEGORY), NULL);
                                        if (FAILED(Status)) 
                                        {
                                            ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                            EXIT_ENGAPI;
                                        }
                                    }

                                    // enable the flag bits if needed
                                    switch( ApiCategory.TableNumber )
                                    {
                                        case WHNT32_INDEX:
                                            if( 0 == (Flags & (LF_NTBASE_NAME | LF_NTBASE_FULL | LF_CATLOG)) )
                                            {
                                                Flags |= (LF_NTBASE_NAME | LF_NTBASE_FULL | LF_CATLOG);

                                                // write the flags back
                                                Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                if (FAILED(Status)) 
                                                {
                                                    ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                    EXIT_ENGAPI;
                                                }
                                            }
                                            break;

                                        case WHCON_INDEX:
                                            if( 0 == (Flags & (LF_NTCON_NAME | LF_NTCON_FULL | LF_CATLOG)) )
                                            {
                                                Flags |= (LF_NTCON_NAME | LF_NTCON_FULL | LF_CATLOG);

                                                // write the flags back
                                                Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                if (FAILED(Status)) 
                                                {
                                                    ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                    EXIT_ENGAPI;
                                                }
                                            }
                                            break;

                                        case WHWIN32_INDEX:
                                            if( 0 == (Flags & (LF_WIN32_NAME | LF_WIN32_FULL | LF_CATLOG)) )
                                            {
                                                Flags |= (LF_WIN32_NAME | LF_WIN32_FULL | LF_CATLOG);

                                                // write the flags back
                                                Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                if (FAILED(Status)) 
                                                {
                                                    ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                    EXIT_ENGAPI;
                                                }
                                            }
                                            break;

                                        case WHBASE_INDEX:
                                            if( 0 == (Flags & (LF_BASE_NAME | LF_BASE_FULL | LF_CATLOG)) )
                                            {
                                                Flags |= (LF_BASE_NAME | LF_BASE_FULL | LF_CATLOG);

                                                // write the flags back
                                                Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                if (FAILED(Status)) 
                                                {
                                                    ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                    EXIT_ENGAPI;
                                                }
                                            }
                                            break;

                                        default:
                                            break;
                                    }

                                }
                                
                                // set the api enable/disable flag
                                ApiMapping.ApiFlags = EnDis;

                                // write the mapping back
                                Status = g_ExtData->WriteVirtual((ULONG64)CurrentMapPtr, &ApiMapping, sizeof(API_CATEGORY_MAPPING), NULL);
                                if (FAILED(Status)) 
                                {
                                    ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                    EXIT_ENGAPI;
                                }
                            }

                            ExtOut(" %-32s %-10s %-10s\n",
                                   ApiName,
                                   (ApiMapping.ApiFlags & APIFLAG_ENABLED) ? "ENABLED" : "DISABLED",
                                   (ApiMapping.ApiFlags & APIFLAG_LOGONFAIL) ? "FAILONLY" : "");
                        }

                        CurrentMapPtr++;

                    } while (1);


                }
                break;

            case 'a':
            case 'A':
            case 'c':
            case 'C':
                {
                    PAPI_CATEGORY_MAPPING CurrentMapPtr;
                    PAPI_CATEGORY CurrentPtr = (PAPI_CATEGORY)Ptr;
                    char    seps[] = " \t\n";
                    char*   token;

                    if( (*ArgumentString == 'a') ||
                        (*ArgumentString == 'A') )
                    {
                        ApiMod = TRUE;
                    }


                    Status = TryGetExpr("wow64log!Wow64ApiCategoryMappings", (PULONG_PTR)&MapPtr);
                    if ((FAILED(Status)) || (!MapPtr))
                    {
                        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
                        ExtOut("Only LF_ERROR is enabled\n");
                        EXIT_ENGAPI;
                    }

                    CurrentMapPtr = (PAPI_CATEGORY_MAPPING)MapPtr;

                    CatNumber = 1;
                    ApiNumber = 1;

                    ArgumentString++;

                    // read category number
                    token = strtok( ArgumentString, seps );
                    if( !token )
                    {
                        LogCategoriesHelp();
                        EXIT_ENGAPI;
                    }
                    sscanf( token, "%ld", &TargetCatNumber );

                    if( TRUE == ApiMod )
                    {
                        // read enable/disable character
                        token = strtok( NULL, seps );
                        if( !token )
                        {
                            LogCategoriesHelp();
                            EXIT_ENGAPI;
                        }
                        
                        if( (*token == 'e') ||
                            (*token == 'E') )
                        {
                            if( (*(token+1) == 'f') ||
                                (*(token+1) == 'F') )
                            {
                                EnDis = APIFLAG_ENABLED | APIFLAG_LOGONFAIL;
                            } else
                            {
                                EnDis = APIFLAG_ENABLED;
                            }
                        } else
                        {
                            EnDis = 0;
                        }

                        // read api number
                        token = strtok( NULL, seps );
                        if( !token )
                        {
                            LogCategoriesHelp();
                            EXIT_ENGAPI;
                        }
                        if( *token == '*' )
                        {
                            WildCard = TRUE;
                        } else
                        {
                            WildCard = FALSE;
                            sscanf( token, "%ld", &TargetApiNumber );
                        }
                    } else
                    {
                        WildCard = FALSE;
                        TargetApiNumber = 0;
                    }

                    do
                    {
                        // read in a category
                        Status = g_ExtData->ReadVirtual((ULONG64)CurrentPtr, &ApiCategory, sizeof(API_CATEGORY), NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        if( ApiCategory.CategoryName == NULL )
                            break;

                        // read the category name
                        Status = g_ExtData->ReadVirtual((ULONG64)(ApiCategory.CategoryName), CategoryName, MAX_PATH, NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        CategoryName[MAX_PATH-1] = 0;
                      
                        if( CatNumber == TargetCatNumber )
                            break;

                        CurrentPtr++;
                        CatNumber++;

                    } while (1);

                    if( (ApiCategory.CategoryName != NULL) &&
                        (CatNumber == TargetCatNumber) )
                    {
                        ExtOut("%-32s\n",CategoryName);                        

                        do
                        {
                            // read in a mapping
                            Status = g_ExtData->ReadVirtual((ULONG64)CurrentMapPtr, &ApiMapping, sizeof(API_CATEGORY_MAPPING), NULL);
                            if (FAILED(Status)) 
                            {
                                ExtOut("Couldn't read Wow64log!Wow64ApiCategoryMappings - %lx\n", Status);
                                EXIT_ENGAPI;
                            }

                            if( ApiMapping.ApiName == NULL )
                                break;

                            if( (ApiMapping.ApiCategoryIndex+1) == TargetCatNumber )
                            {
                                // read the api name
                                Status = g_ExtData->ReadVirtual((ULONG64)(ApiMapping.ApiName), ApiName, MAX_PATH, NULL);
                                if (FAILED(Status)) 
                                {
                                    ExtOut("Couldn't read Wow64log!Wow64ApiCategoryMapings - %lx\n", Status);
                                    EXIT_ENGAPI;
                                }

                                ApiName[MAX_PATH-1] = 0;

                                if( (WildCard == TRUE) ||
                                    (TargetApiNumber == ApiNumber) )
                                {
                                    // set the api enable/disable flag
                                    ApiMapping.ApiFlags = EnDis;

                                    // if we are enabling, make sure the category and flag bits are set accordingly
                                    if( EnDis == APIFLAG_ENABLED )
                                    {
                                        // enable the category if needed
                                        if( ApiCategory.CategoryFlags == 0 )
                                        {
                                            ApiCategory.CategoryFlags = CATFLAG_ENABLED;

                                            // write the category back
                                            Status = g_ExtData->WriteVirtual((ULONG64)CurrentPtr, &ApiCategory, sizeof(API_CATEGORY), NULL);
                                            if (FAILED(Status)) 
                                            {
                                                ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                EXIT_ENGAPI;
                                            }
                                        }

                                        // enable the flag bits if needed
                                        switch( ApiCategory.TableNumber )
                                        {
                                            case WHNT32_INDEX:
                                                if( 0 == (Flags & (LF_NTBASE_NAME | LF_NTBASE_FULL | LF_CATLOG)) )
                                                {
                                                    Flags |= (LF_NTBASE_NAME | LF_NTBASE_FULL | LF_CATLOG);

                                                    // write the flags back
                                                    Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                    if (FAILED(Status)) 
                                                    {
                                                        ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                        EXIT_ENGAPI;
                                                    }
                                                }
                                                break;

                                            case WHCON_INDEX:
                                                if( 0 == (Flags & (LF_NTCON_NAME | LF_NTCON_FULL | LF_CATLOG)) )
                                                {
                                                    Flags |= (LF_NTCON_NAME | LF_NTCON_FULL | LF_CATLOG);

                                                    // write the flags back
                                                    Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                    if (FAILED(Status)) 
                                                    {
                                                        ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                        EXIT_ENGAPI;
                                                    }
                                                }
                                                break;

                                            case WHWIN32_INDEX:
                                                if( 0 == (Flags & (LF_WIN32_NAME | LF_WIN32_FULL | LF_CATLOG)) )
                                                {
                                                    Flags |= (LF_WIN32_NAME | LF_WIN32_FULL | LF_CATLOG);

                                                    // write the flags back
                                                    Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                    if (FAILED(Status)) 
                                                    {
                                                        ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                        EXIT_ENGAPI;
                                                    }
                                                }
                                                break;

                                            case WHBASE_INDEX:
                                                if( 0 == (Flags & (LF_BASE_NAME | LF_BASE_FULL | LF_CATLOG)) )
                                                {
                                                    Flags |= (LF_BASE_NAME | LF_BASE_FULL | LF_CATLOG);

                                                    // write the flags back
                                                    Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                                                    if (FAILED(Status)) 
                                                    {
                                                        ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                                        EXIT_ENGAPI;
                                                    }
                                                }
                                                break;

                                            default:
                                                break;
                                        }
                                    }

                                    // write the mapping back
                                    Status = g_ExtData->WriteVirtual((ULONG64)CurrentMapPtr, &ApiMapping, sizeof(API_CATEGORY_MAPPING), NULL);
                                    if (FAILED(Status)) 
                                    {
                                        ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                                        EXIT_ENGAPI;
                                    }

                                    ExtOut("%3d %-32s %-10s %-10s\n",
                                           ApiNumber,
                                           ApiName,
                                           (ApiMapping.ApiFlags & APIFLAG_ENABLED) ? "ENABLED" : "DISABLED",
                                           (ApiMapping.ApiFlags & APIFLAG_LOGONFAIL) ? "FAILONLY" : "");

                                    if( FALSE == WildCard )
                                    {
                                        EXIT_ENGAPI;
                                    }

                                }
                                
                                if( FALSE == ApiMod )
                                {
                                    ExtOut("%3d %-32s %-10s %-10s\n",
                                           ApiNumber,
                                           ApiName,
                                           (ApiMapping.ApiFlags & APIFLAG_ENABLED) ? "ENABLED" : "DISABLED",
                                           (ApiMapping.ApiFlags & APIFLAG_LOGONFAIL) ? "FAILONLY" : "");
                                }

                                ApiNumber++;
                            }

                            CurrentMapPtr++;

                        } while (1);
                    }
                }

                break;

            case 'e':
            case 'E':
            case 'd':
            case 'D':
                {
                    PAPI_CATEGORY CurrentPtr = (PAPI_CATEGORY)Ptr;

                    if( (*ArgumentString == 'e') ||
                        (*ArgumentString == 'E') )
                    {
                        EnDis = CATFLAG_ENABLED;
                    } else
                    {
                        EnDis = 0;
                    }

                    ArgumentString++;
                    CatNumber = 1;

                    if(strstr(ArgumentString, " *") ||
                       strstr(ArgumentString, "*"))
                    {
                        WildCard = TRUE;
                        TargetCatNumber = 0;
                    } else
                    {
                        sscanf( ArgumentString, "%ld", &TargetCatNumber );
                    }

                    // disable catlog if wildcard category disable
                    if( (TRUE == WildCard) && (0 == EnDis) )
                    {
                        Flags &= ~LF_CATLOG;

                        // write the flags back
                        Status = g_ExtData->WriteVirtual((ULONG64)FlagPtr, &Flags, sizeof(UINT_PTR), NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }
                    }

                    do
                    {
                        // read in a category
                        Status = g_ExtData->ReadVirtual((ULONG64)CurrentPtr, &ApiCategory, sizeof(API_CATEGORY), NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        if( ApiCategory.CategoryName == NULL )
                            break;

                        // read the category name
                        Status = g_ExtData->ReadVirtual((ULONG64)(ApiCategory.CategoryName), CategoryName, MAX_PATH, NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }

                        CategoryName[MAX_PATH-1] = 0;

                        // set the category flag
                        if( (WildCard == TRUE) ||
                            (CatNumber == TargetCatNumber) )
                        {
                            ApiCategory.CategoryFlags = EnDis;
                            
                            ExtOut("%3d %-32s %-s\n",
                                   CatNumber,
                                   CategoryName,
                                   (ApiCategory.CategoryFlags & CATFLAG_ENABLED) ? "ENABLED" : "DISABLED");
                        }

                        // write the category back
                        Status = g_ExtData->WriteVirtual((ULONG64)CurrentPtr, &ApiCategory, sizeof(API_CATEGORY), NULL);
                        if (FAILED(Status)) 
                        {
                            ExtOut("Couldn't write Wow64log!Wow64ApiCategories - %lx\n", Status);
                            EXIT_ENGAPI;
                        }
                        
                        if( CatNumber == TargetCatNumber )
                            break;

                        CurrentPtr++;
                        CatNumber++;

                    } while (1);
                }

                break;

            default:
                {
                    ExtOut("ILLEGAL PARAM\n");
                    LogCategoriesHelp();
                    EXIT_ENGAPI;
                }

                break;
        }

    } else
    {
        // list all categories
        PAPI_CATEGORY CurrentPtr = (PAPI_CATEGORY)Ptr;
        CatNumber = 1;

        do
        {
            // read in a category
            Status = g_ExtData->ReadVirtual((ULONG64)CurrentPtr, &ApiCategory, sizeof(API_CATEGORY), NULL);
            if (FAILED(Status)) 
            {
                ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                EXIT_ENGAPI;
            }

            if( ApiCategory.CategoryName == NULL )
                break;

            // read the category name
            Status = g_ExtData->ReadVirtual((ULONG64)(ApiCategory.CategoryName), CategoryName, MAX_PATH, NULL);
            if (FAILED(Status)) 
            {
                ExtOut("Couldn't read Wow64log!Wow64ApiCategories - %lx\n", Status);
                EXIT_ENGAPI;
            }

            CategoryName[MAX_PATH-1] = 0;

            ExtOut("%3d %-32s %-s\n",
                   CatNumber++,
                   CategoryName,
                   (ApiCategory.CategoryFlags & CATFLAG_ENABLED) ? "ENABLED" : "DISABLED");

            CurrentPtr++;


        } while (1);
    }
    
    EXIT_ENGAPI;
}

VOID 
LogOutputHelp(
    VOID)
{
    ExtOut("Log Output:\n");
    ExtOut("    !wow64lo [e|d] [c|f] <filename>    Enable/Disable [e|d] output to Console/File [c|f]\n");

    return;
}


DECLARE_ENGAPI(wow64lo)
/*++

Routine Description:

    This routine lists all of the API catgories
    
    Called as :
    
    !w64lo

Arguments:

    none
    
Return Value:

    none
    
--*/
{
    HANDLE      Process;
    UINT_PTR    Flags;
    ULONG_PTR   Ptr;
    ULONG_PTR   PtrFile;
    HANDLE      LogFileHandle,TargetHandle;
    BOOL        Enable;
    BOOL        Console;
    WCHAR       FileName_U[ MAX_PATH ];
    UNICODE_STRING      NtFileName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS    NtStatus;

    char        arg1[MAX_PATH];
    char        arg2[MAX_PATH];
    char        arg3[MAX_PATH];
    INIT_ENGAPI;

    // get process handle
    Status = g_ExtSystem->GetCurrentProcessHandle((PULONG64)&Process);

    // attempt to access wow64logflags
    Status = TryGetExpr("wow64log!wow64logflags", &Ptr);
    if ((FAILED(Status)) || (!Ptr))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    // read the current flags
    Status = g_ExtData->ReadVirtual((ULONG64)Ptr, &Flags, sizeof(UINT_PTR), NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't read Wow64log!Wow64LogFlags - %lx\n", Status);
        EXIT_ENGAPI;
    }

    // attempt to access wow64logfilehandle
    Status = TryGetExpr("wow64log!wow64logfilehandle", &PtrFile);
    if ((FAILED(Status)) || (!PtrFile))
    {
        ExtOut("Wow64log.dll isn't loaded. To enable full Wow64 logging, copy wow64log.dll to your system32 dir and restart the app.\n");
        ExtOut("Only LF_ERROR is enabled\n");
        EXIT_ENGAPI;
    }

    // read the current file handle
    Status = g_ExtData->ReadVirtual((ULONG64)PtrFile, &LogFileHandle, sizeof(HANDLE), NULL);
    if (FAILED(Status)) 
    {
        ExtOut("Couldn't retreive Wow64LogFileHandle - %lx\n", Status);
        EXIT_ENGAPI;
    }

    Enable = FALSE;
    Console = FALSE;

    //
    // Parse the command line
    //
    if (ArgumentString && *ArgumentString) 
    {
        if (strstr(ArgumentString, "-?") ||
            strstr(ArgumentString, "help")) 
        {
            LogOutputHelp();
            EXIT_ENGAPI;
        }

        sscanf( ArgumentString, "%s %s %s\n", arg1, arg2, arg3);

        if( (*arg1 == 'e') ||
            (*arg1 == 'E') )
        {
            Enable = TRUE;

        } else if( (*arg1 != 'd') &&
                   (*arg1 != 'D') )
        {
            LogOutputHelp();
            EXIT_ENGAPI;
                }

        if( (*arg2 == 'c') ||
            (*arg2 == 'C') )
        {
            Console = TRUE;

        } else if( (*arg2 != 'f') &&
                   (*arg2 != 'F') )
        {
            LogOutputHelp();
            EXIT_ENGAPI;
            }

        if( TRUE == Console )
        {
            if( TRUE == Enable )
            {
                Flags |= LF_CONSOLE;
            } else
            {
                Flags &= ~LF_CONSOLE;
        }

            // write updated flags
            Status = g_ExtData->WriteVirtual((ULONG64)Ptr, &Flags, sizeof(ULONG_PTR), NULL);
            if (FAILED(Status)) 
            {
                ExtOut("Couldn't write log flags [%lx] - %lx\n", Ptr, Status);
    }

            ExtOut("Console logging output %s\n", Enable ? "ENABLED" : "DISABLED");

        } else
        {
            if( TRUE == Enable )
            {
                if( LogFileHandle != INVALID_HANDLE_VALUE )
                {
                    ExtOut("Logging to file already ENABLED.  Disable and re-enable to change log files\n");
                    EXIT_ENGAPI;
                }

                if( *arg3 )
                {
                    if (!MultiByteToWideChar(CP_ACP,
                                             0,
                                             arg3,
                                             -1,
                                             FileName_U,
                                             sizeof(FileName_U)/sizeof(WCHAR)))
                    {
                        ExtOut("Couldn't convert %s to unicode\n", arg3);
                        EXIT_ENGAPI;
                    }

                    if(!RtlDosPathNameToNtPathName_U(FileName_U, &NtFileName,NULL,NULL)) 
                    {
                        ExtOut("Couldn't convert %s to NT style pathname\n", arg3);
                        EXIT_ENGAPI;
                    }

                    InitializeObjectAttributes(&ObjectAttributes,
                                               &NtFileName,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);

                    //
                    // Open a new file (truncate to zero if exists)
                    //
                    NtStatus = NtCreateFile(&LogFileHandle,
                                            SYNCHRONIZE | GENERIC_WRITE,
                                            &ObjectAttributes,
                                            &IoStatusBlock,
                                            NULL,
                                            0,
                                            FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                            FILE_OVERWRITE_IF,
                                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                                            NULL,
                                            0);

                    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);

                    if(!NT_SUCCESS(NtStatus)) 
                    {
                        ExtOut("Couldn't create %s - %lx\n", arg3, NtStatus);
                        EXIT_ENGAPI;
                    }

                    //
                    // Let's duplicate the file handle into the debuggee
                    //
                    if (!DuplicateHandle(GetCurrentProcess(),
                                         LogFileHandle,
                                         Process,
                                         &TargetHandle,
                                         0,
                                         FALSE,
                                         DUPLICATE_SAME_ACCESS))
                    {
                        ExtOut("Couldn't duplicate handle into debuggee - GetLastError=%lx\n", GetLastError());
                        EXIT_ENGAPI;
                    }

                    CloseHandle(LogFileHandle);

                    Status = g_ExtData->WriteVirtual((ULONG64)PtrFile, &TargetHandle, sizeof(HANDLE), NULL);
                    if (FAILED(Status)) 
                    {
                        ExtOut("Couldn't write logfile handle - %lx\n", Status);
                    }

                } else
                {
                    LogOutputHelp();
                    EXIT_ENGAPI;
                }
            } else
            {
                if( LogFileHandle != INVALID_HANDLE_VALUE )
                {
                    TargetHandle = INVALID_HANDLE_VALUE;
                    
                    Status = g_ExtData->WriteVirtual((ULONG64)PtrFile, &TargetHandle, sizeof(HANDLE), NULL);
                    if (FAILED(Status)) 
                    {
                        ExtOut("Couldn't write logfile handle - %lx\n", Status);
                    }

                    CloseHandle(LogFileHandle);
                }
            }

            ExtOut("File logging output %s\n", Enable ? "ENABLED" : "DISABLED");
        }

        EXIT_ENGAPI;
    } else
    {
        ExtOut("Console logging output is %s\n", (LF_CONSOLE==(Flags&LF_CONSOLE)) ? "ENABLED" : "DISABLED");
        ExtOut("File logging output is %s\n", (INVALID_HANDLE_VALUE==LogFileHandle) ? "DISABLED" : "ENABLED");
       
        EXIT_ENGAPI;
    }

    LogOutputHelp();
    EXIT_ENGAPI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\wow64exts.h ===
#ifndef __WOW64_EXTS_HH__
#define __WOW64_EXTS_HH__


/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64exts.h

Abstract:
    
    header file for Debugger extensions for wow64.

Author:

    ATM Shafiqul Khalid   [ASKHALID]      3-Aug-1998

Revision History:

    Tim Cheng   [t-tcheng]                3-Jul-2000
--*/

//
//  functions shared between  C and  C++ codes.
//

#ifdef __cplusplus
extern "C" {
#endif

/* Masks for bits 0 - 32. */
#define BIT0         0x1
#define BIT1         0x2
#define BIT2         0x4
#define BIT3         0x8
#define BIT4        0x10
#define BIT5        0x20
#define BIT6        0x40
#define BIT7        0x80
#define BIT8       0x100
#define BIT9       0x200
#define BIT10      0x400
#define BIT11      0x800
#define BIT12     0x1000
#define BIT13     0x2000
#define BIT14     0x4000
#define BIT15     0x8000
#define BIT16    0x10000
#define BIT17    0x20000
#define BIT18    0x40000
#define BIT19    0x80000
#define BIT20   0x100000
#define BIT21   0x200000
#define BIT22   0x400000
#define BIT23   0x800000
#define BIT24  0x1000000
#define BIT25  0x2000000
#define BIT26  0x4000000
#define BIT27  0x8000000
#define BIT28 0x10000000
#define BIT29 0x20000000
#define BIT30 0x40000000
#define BIT31 0x80000000

#define MAX_BUFFER_SIZE 1000

#define WOW64EXTS_FLUSH_CACHE       0
#define WOW64EXTS_GET_CONTEXT       1
#define WOW64EXTS_SET_CONTEXT       2
#define WOW64EXTS_FLUSH_CACHE_WITH_HANDLE   3

#define NUMBER_OF_387REGS       8
#define NUMBER_OF_XMMI_REGS     8
#define SIZE_OF_FX_REGISTERS        128

#define MACHINE_TYPE32 IMAGE_FILE_MACHINE_I386
#if defined(_AMD64_)
#    define STRING_SWITCHED_64MODE "Switched to AMD64 mode.\n"
#    define STRING_SWITCHED_32MODE "Switched to x86 mode.\n"
#    define MACHINE_TYPE64 IMAGE_FILE_MACHINE_AMD64

#elif  defined(_IA64_)
#    define STRING_SWITCHED_64MODE "Switched to IA64 mode.\n"
#    define STRING_SWITCHED_32MODE "Switched to IA32 mode.\n"
#    define MACHINE_TYPE64 IMAGE_FILE_MACHINE_IA64
#else
#    define STRING_SWITCHED_64MODE "Switched to 64 mode.\n"
#    define STRING_SWITCHED_32MODE "Switched to 32 mode.\n"
#    define MACHINE_TYPE64 IMAGE_FILE_MACHINE_I386   //possibly target platform is x86
#endif


typedef BOOL (*W64CPUGETREMOTE)(PDEBUG_CLIENT, PVOID);
typedef BOOL (*W64CPUSETREMOTE)(PDEBUG_CLIENT);
typedef BOOL (*W64CPUGETLOCAL)(PDEBUG_CLIENT, PCONTEXT32);
typedef BOOL (*W64CPUSETLOCAL)(PDEBUG_CLIENT, PCONTEXT32);
typedef BOOL (*W64CPUFLUSHCACHE)(PDEBUG_CLIENT, PVOID, DWORD);
typedef BOOL (*W64CPUFLUSHCACHEWH)(HANDLE, PVOID, DWORD);

extern W64CPUGETREMOTE  g_pfnCpuDbgGetRemoteContext;

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


//
// New-style dbgeng APIs use DECLARE_ENGAPI/INIT_ENGAPI macros
//
#define DECLARE_ENGAPI(name) \
HRESULT CALLBACK name(PDEBUG_CLIENT Client, PCSTR Args)

#define INIT_ENGAPI \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) { \
        return Status;                         \
    }                                          \
    ArgumentString = (LPSTR)Args;

#define EXIT_ENGAPI {ExtRelease();  return Status;}

#define DEFINE_FORWARD_ENGAPI(name, forward) \
DECLARE_ENGAPI(name)                         \
{                                            \
   INIT_ENGAPI;                              \
   forward;                                  \
   EXIT_ENGAPI;                              \
}                                            


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)


// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern LPSTR ArgumentString;

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);


HRESULT
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    );


ULONG_PTR 
GETEXPRESSION(char *);

HRESULT
GetPeb64Addr(OUT ULONG64* Peb64);

HRESULT
GetPeb32Addr(OUT ULONG64* Peb32);
             
HRESULT
FindFullImage32Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    );

HRESULT
FindFullImage64Name(
    ULONG64 DllBase,
    PSTR NameBuffer,
    ULONG NameBufferSize
    );

VOID 
PrintFixedFileInfo(
    LPSTR  FileName,
    LPVOID lpvData,
    BOOL   Verbose
    );

#ifdef __cplusplus
}
#endif

#endif //__WOW64_EXTS_HH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\thnkhlpr.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    thnkhlpr.h

Abstract:
    
    Header for thunk helper functions.
    
Author:

    19-Jul-1998 BarryBo

Revision History:

--*/

// Determines if a pointer points to a item or is a special value. 
// If it is a special value it should be copied without dereferencing.
#define WOW64_ISPTR(a) ((void *)a != NULL)

//
//  Helper thunk functions called by all the thunks to thunk common types.
//

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
     OUT NT32SIZE_T *dst,
     IN PSIZE_T src 
     );

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
     OUT PSIZE_T dst,
     IN NT32SIZE_T *src
     );

#define Wow64ThunkSIZE_T32TO64(src) \
     (SIZE_T)(src)

#define Wow64ThunkSIZE_T64TO32(src) \
     (NT32SIZE_T)min((src), 0xFFFFFFFF)

#define Wow64ShallowThunkUnicodeString32TO64(dst, src) \
     ((PUNICODE_STRING)(dst))->Length = ((NT32UNICODE_STRING *)(src))->Length; \
     ((PUNICODE_STRING)(dst))->MaximumLength = ((NT32UNICODE_STRING *)(src))->MaximumLength; \
     ((PUNICODE_STRING)(dst))->Buffer = (PWSTR)((NT32UNICODE_STRING *)(src))->Buffer;

#define Wow64ShallowThunkUnicodeString64TO32(dst, src) \
     ((NT32UNICODE_STRING *)(dst))->Length = ((PUNICODE_STRING)(src))->Length; \
     ((NT32UNICODE_STRING *)(dst))->MaximumLength = ((PUNICODE_STRING)(src))->MaximumLength; \
     ((NT32UNICODE_STRING *)(dst))->Buffer = (NT32PWSTR)((PUNICODE_STRING)(src))->Buffer;

#define Wow64ShallowThunkAllocUnicodeString32TO64(src) \
     Wow64ShallowThunkAllocUnicodeString32TO64_FNC((NT32UNICODE_STRING *)(src))

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    );

#define Wow64ShallowThunkAllocSecurityDescriptor32TO64(src) \
    Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC((NT32SECURITY_DESCRIPTOR *)(src))

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    );

#define Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(src) \
    Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC((NT32SECURITY_TOKEN_PROXY_DATA *)(src))

PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    );

#define Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src, dst) \
    Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC((NT32SECURITY_QUALITY_OF_SERVICE *)(src), dst) 

NTSTATUS
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src,
    IN OUT PSECURITY_QUALITY_OF_SERVICE *dst
    );

#define Wow64ShallowThunkAllocObjectAttributes32TO64(src, dst) \
    Wow64ShallowThunkAllocObjectAttributes32TO64_FNC((NT32OBJECT_ATTRIBUTES *)(src), dst) 

NTSTATUS
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src,
    IN OUT POBJECT_ATTRIBUTES *dst
    );


ULONG 
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    );

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    );

VOID WriteReturnLengthSilent(PULONG ReturnLength, ULONG Length);
VOID WriteReturnLengthStatus(PULONG ReturnLength, NTSTATUS *pStatus, ULONG Length);

VOID
Wow64RedirectFileName(
    IN OUT WCHAR *Name,
    IN OUT ULONG *Length
    );

BOOLEAN
Wow64IsModule32bitHelper(
    HANDLE ProcessHandle,
    IN ULONG64 DllBase);

BOOLEAN
Wow64IsModule32bit(
    IN PCLIENT_ID ClientId,
    IN ULONG64 DllBase);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\cathelper.h ===
/*++
                                                                                
Copyright (c) 2001 Microsoft Corporation

Module Name:

    cathelper.h

Abstract:
    
    Private header for wow64log.dll
    
Author:

    03-May-2001   KenCoope

Revision History:

--*/

#ifndef _CATHELPER_INCLUDE
#define _CATHELPER_INCLUDE

//
// Max API Cetegory Mappings
//
#define MAX_API_MAPPINGS    2048


//
// Api Category structure
//
typedef struct _ApiCategory
{
    char *CategoryName;
    ULONG CategoryFlags;
    ULONG TableNumber;
} API_CATEGORY, *PAPI_CATEGORY;

//
// Api Category Flags
//
#define CATFLAG_ENABLED     0x0001
#define CATFLAG_LOGONFAIL   0x0002

//
// Enum of current Api Categories
//
typedef enum
{
    APICAT_EXECUTIVE,
    APICAT_IO,
    APICAT_KERNEL,
    APICAT_LPC,
    APICAT_MEMORY,
    APICAT_OBJECT,
    APICAT_PNP,
    APICAT_POWER,
    APICAT_PROCESS,
    APICAT_REGISTRY,
    APICAT_SECURITY,
    APICAT_XCEPT,
    APICAT_NTWOW64,
    APICAT_BASEWOW64,
    APICAT_UNCLASS_WHNT32,
    APICAT_UNCLASS_WHCON,
    APICAT_UNCLASS_WHWIN32,
    APICAT_UNCLASS_WHBASE,
};

//
// Api Category Mapping structure
//
typedef struct _ApiCategoryMapping
{
    char *ApiName;
    ULONG ApiCategoryIndex;
    ULONG ApiFlags;
} API_CATEGORY_MAPPING, *PAPI_CATEGORY_MAPPING;

//
// Api Flags
//
#define APIFLAG_ENABLED     0x0001
#define APIFLAG_LOGONFAIL   0x0002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\wow64exts.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64exts.cpp

Abstract:

    Debugger extensions for wow64.

Author:

    29-Oct-1998 mzoran

Revision History:

    3-Aug-1999 askhalid   Added disassembler support. Output routine is exposed to outside.
    1-Jul-2000 t-tcheng   Switch to new debugger engine 
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dbgeng.h>
#include <stdio.h>
#include <stdlib.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64t.h>
#include <wow64.h>
#include <wow64warn.h>
#include "wow64exts.h"

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

#pragma warning(disable : 4003) //disable not enough arguments for macro.

LPSTR ArgumentString;

#define TRUNK32(z) (ULONG)PtrToUlong((PVOID)z)
#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

W64CPUGETREMOTE  g_pfnCpuDbgGetRemoteContext = NULL;
W64CPUSETREMOTE  g_pfnCpuDbgSetRemoteContext = NULL;
W64CPUGETLOCAL   g_pfnCpuDbgGetLocalContext = NULL;
W64CPUSETLOCAL   g_pfnCpuDbgSetLocalContext = NULL;
W64CPUFLUSHCACHE   g_pfnCpuDbgFlushInstructionCache = NULL;
W64CPUFLUSHCACHEWH g_pfnCpuDbgFlushInstructionCacheWithHandle = NULL;

HMODULE 
LoadCpuExtensionDll (
    IN PCHAR ModuleName,
    IN OUT PCHAR FileName)
{
    HMODULE CpuExtDll = NULL;
    IDebugClient *DebugClient;
    PDEBUG_CONTROL2 DebugControl;
    HRESULT Hr;
    ULONG TargetMachine;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) == S_OK)
    {
        //
        // Get the architecture type.
        //

        if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
        {
            if ((Hr = DebugControl->GetActualProcessorType(
                                         &TargetMachine)) == S_OK)
            {
                switch (TargetMachine)
                {
                case IMAGE_FILE_MACHINE_IA64:
                    strcpy(FileName, "\\w64cpuex.dll");
                    break;

                case IMAGE_FILE_MACHINE_AMD64:
                    strcpy(FileName, "\\wamd64cpuex.dll");
                    break;

                default:
                    DbgPrint("Architecture %lx is not supported by Wow64.\n", TargetMachine);
                    Hr = E_FAIL;
                    break;
                }
                DebugControl->Release();
            }
        }

        DebugClient->Release();
    }

    if (Hr == S_OK)
    {
        CpuExtDll = LoadLibraryA(ModuleName);
    }

    return CpuExtDll;
}

BOOL
ProcessAttach(
     HINSTANCE DLL,
     DWORD Reason,
     LPVOID Reserved
     )
{

  CHAR szModule[MAX_BUFFER_SIZE+1];
  CHAR *filename;
  HMODULE CpuExtDll = NULL;


  DisableThreadLibraryCalls(DLL);

  if (GetModuleFileNameA(DLL, szModule,  MAX_BUFFER_SIZE)) {

      filename = strrchr(szModule, '\\');
      if (filename && !_strnicmp(filename, "\\wow64exts.dll", 40)) {

          CpuExtDll = LoadCpuExtensionDll (szModule, filename);

          if (CpuExtDll) {
              g_pfnCpuDbgGetRemoteContext = (W64CPUGETREMOTE)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgGetRemoteContext");
              g_pfnCpuDbgGetLocalContext  = (W64CPUGETLOCAL)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgGetLocalContext");
              g_pfnCpuDbgSetRemoteContext = (W64CPUSETREMOTE)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgSetRemoteContext");
              g_pfnCpuDbgSetLocalContext  = (W64CPUSETLOCAL)
                                            GetProcAddress(CpuExtDll,
                                                           "CpuDbgSetLocalContext");
              g_pfnCpuDbgFlushInstructionCache = 
                  (W64CPUFLUSHCACHE)GetProcAddress(CpuExtDll,
                                              "CpuDbgFlushInstructionCache");
              g_pfnCpuDbgFlushInstructionCacheWithHandle = 
                  (W64CPUFLUSHCACHEWH)GetProcAddress(CpuExtDll,
                                          "CpuDbgFlushInstructionCacheWithHandle");
          }
      }
  }
  return (CpuExtDll && 
          g_pfnCpuDbgFlushInstructionCacheWithHandle &&
          g_pfnCpuDbgFlushInstructionCache &&
          g_pfnCpuDbgSetLocalContext &&
          g_pfnCpuDbgSetRemoteContext &&
          g_pfnCpuDbgGetLocalContext &&
          g_pfnCpuDbgGetRemoteContext);
  
  
}


BOOL
WINAPI
DllMain(
  HINSTANCE DLL,       // handle to DLL module
  DWORD Reason,        // reason for calling function
  LPVOID Reserved      // reserved
  )
{
  switch(Reason) {
  case DLL_PROCESS_ATTACH:
     return ProcessAttach(DLL, Reason, Reserved);
  default:
     return TRUE;
  }
}

HRESULT
GetPeb64Addr(OUT ULONG64 * Peb64
             )
{
    return g_ExtSystem->GetCurrentProcessPeb(Peb64);
}


HRESULT
GetTeb64Addr(OUT ULONG64 * Teb64
             )
{
    return g_ExtSystem->GetCurrentThreadTeb(Teb64);
}

HRESULT
GetTeb32Addr(OUT ULONG64 * Teb32
             )
{

   HRESULT Status;
   ULONG64    Teb64;
   
   Status = g_ExtSystem->GetCurrentThreadTeb(&Teb64);
   if (FAILED(Status)) {
       ExtOut("GetTeb32Addr failed!\n");
       return Status;
   }
   
   *Teb32 = 0;
   return  g_ExtData->ReadVirtual((ULONG64)Teb64+OFFSET(TEB,NtTib.ExceptionList),
                                   Teb32,
                                   sizeof(ULONG),
                                   NULL);
}

HRESULT
GetPeb32Addr(OUT ULONG64 * Peb32
             )
{

   HRESULT Status;
   ULONG64    Teb32;
   

   Status = GetTeb32Addr(&Teb32);
   if (FAILED(Status)) {
       ExtOut("GetTeb32Addr failed!\n");
       return Status;
   }
   
   *Peb32 = 0;
   Status = g_ExtData->ReadVirtual((ULONG64)Teb32+OFFSET(TEB32,ProcessEnvironmentBlock),
                                   Peb32,
                                   sizeof(ULONG),
                                   NULL);
   return Status;

}

//
// This macro gets used four times to defined the following functions.
// HRESULT GetPeb64(OUT PPEB Peb64);
// HRESULT GetPeb32(OUT PPEB32 Peb32);
// HRESULT GetTeb64(OUT PTEB Teb64);
// HRESULT GetTeb32(OUT PTEB32 Teb32);
//

#define DEFINE_GET_FUNC(name, type)                     \
HRESULT                                                 \
Get##name##(OUT P##type name                           \
            )                                           \
{                                                       \
                                                        \
   HRESULT Status;                                      \
   ULONG64 name##Addr;                                  \
                                                        \
   Status = Get##name##Addr(&##name##Addr);             \
                                                        \
   if (FAILED(Status)) {                                \
      ExtOut("Get "#type" failed!\n");                  \
      return Status;                                    \
                                                        \
   }                                                    \
   return   g_ExtData->ReadVirtual(name##Addr,          \
                                   name##,              \
                                   sizeof(##type##),    \
                                   NULL);               \
                                                        \
                                                        \
}                                                       \

DEFINE_GET_FUNC(Peb64,PEB)
DEFINE_GET_FUNC(Peb32,PEB32)
DEFINE_GET_FUNC(Teb64,TEB)
DEFINE_GET_FUNC(Teb32,TEB32)


VOID
PrintTls(VOID) {

   HRESULT Status;
   TEB Teb;

   Status = GetTeb64(&Teb);

   if (FAILED(Status)) {
      ExtOut("Could not get the teb, error 0x%X\n", Status);
   }

   ExtOut("\n");
   ExtOut("Wow64 TLS slots:\n\n");
   ExtOut("WOW64_TLS_STACKPTR64:       0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_STACKPTR64]);
   ExtOut("WOW64_TLS_CPURESERVED:      0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_CPURESERVED]);
   ExtOut("WOW64_TLS_INCPUSIMULATION:  0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_INCPUSIMULATION]);
   ExtOut("WOW64_TLS_TEMPLIST:         0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_TEMPLIST]);
   ExtOut("WOW64_TLS_EXCEPTIONADDR:    0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_EXCEPTIONADDR]);
   ExtOut("WOW64_TLS_USERCALLBACKDATA: 0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_USERCALLBACKDATA]);
   ExtOut("WOW64_TLS_EXTENDED_FLOAT:   0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_EXTENDED_FLOAT]);
   ExtOut("WOW64_TLS_APCLIST:          0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_APCLIST]);
   ExtOut("WOW64_TLS_FILESYSREDIR:     0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_FILESYSREDIR]);
   ExtOut("WOW64_TLS_LASTWOWCALL:      0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_LASTWOWCALL]);
   ExtOut("WOW64_TLS_WOW64INFO:        0x%16.16I64X\n", Teb.TlsSlots[WOW64_TLS_WOW64INFO]);
   ExtOut("\n");

}

VOID
PrintStructAddress(VOID) {

   HRESULT Status;
   TEB Teb;
   TEB32 Teb32;

   PTEB pTeb;
   PTEB32 pTeb32;
   PPEB pPeb;
   PPEB32 pPeb32;

   ExtOut("\n");
   ExtOut("Address of important WOW64 structures:\n\n");

   Status = GetPeb64Addr((PULONG64)&pPeb);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 64bit PEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("PEB64: 0x%X\n", PtrToUlong(pPeb));
   }

   Status = GetPeb32Addr((PULONG64)&pPeb32);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 32bit PEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("PEB32: 0x%X\n", pPeb32);
   }


   Status = GetTeb64Addr((PULONG64)&pTeb);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 64bit TEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("TEB64: 0x%X\n", PtrToUlong(pTeb));
   }

   Status = GetTeb32Addr((PULONG64)&pTeb32);
   if (FAILED(Status)) {
      ExtOut("Could not get the address of the 32bit TEB, error 0x%X\n", Status);
   }
   else {
      ExtOut("TEB32: 0x%X\n", pTeb32);
   }

   Status = GetTeb64(&Teb);
   if (FAILED(Status)) {
      ExtOut("Could not get information for 64bit stack, error 0x%X\n", Status);
   }
   else {
      ExtOut("STACK64: BASE: 0x%X LIMIT: 0x%X DEALLOC: 0x%X\n",
                    PtrToUlong(Teb.NtTib.StackBase),
                    PtrToUlong(Teb.NtTib.StackLimit),
                    PtrToUlong(Teb.DeallocationStack));
   }

   Status = GetTeb32(&Teb32);
   if (FAILED(Status)) {
      ExtOut("Could not get information for 32bit stack, error 0x%X\n");
   }
   else {
      ExtOut("STACK32: BASE: 0x%X LIMIT: 0x%X DEALLOC: 0x%X\n",
                    Teb32.NtTib.StackBase,
                    Teb32.NtTib.StackLimit,
                    Teb32.DeallocationStack);
   }

   ExtOut("\n");

}

WCHAR GetUStrBuffer[1024];

WCHAR *GetUS(WCHAR *Buffer,
             ULONG Length,
             BOOL Normalize,
             ULONG Base) {

   HRESULT Status;

   RtlZeroMemory(GetUStrBuffer, sizeof(GetUStrBuffer));

   Length = (ULONG)min(Length, sizeof(GetUStrBuffer) - sizeof(UNICODE_NULL));

   if (Normalize) {
      Buffer = (WCHAR *)((PBYTE)Buffer + Base);
   }

   Status = g_ExtData->ReadVirtual((ULONG64)Buffer ,
                                   GetUStrBuffer,
                                   Length,
                                   NULL);

   if (FAILED(Status)) {
      swprintf(GetUStrBuffer, L"Unable to read string, status 0x%X", Status);
   }

   return GetUStrBuffer;

}

#define GETUS(ustr, normalize, base) \
    GetUS((WCHAR*)((ustr).Buffer), (ustr).Length, normalize, PtrToUlong((PVOID)base))



VOID
Help(
    VOID
    )
{

   ExtOut("Wow64 debugger extensions: \n\n");
   ExtOut("help:          Prints this help message.\n");
   ExtOut("k <count>:     Combined 32/64 stack trace(no parameters).\n");
   ExtOut("kb <count>:    Combined 32/64 stack trace(with parameters).\n");
   ExtOut("straddr:       Dumps the address of important wow64 structures.\n");
   ExtOut("tls:           Dumps the WOW64 TLS slots.\n");
   ExtOut("ctx(addr):     Dump an x86 CONTEXT.\n");
   ExtOut("u:             Unassemble x86 code.\n");
   ExtOut("r:             Dump or modify registers.\n");
   ExtOut("bp:            Set x86 breakpoint.\n");
   ExtOut("bc:            Clear x86 breakpoint.\n");
   ExtOut("bl:            List x86 breakpoints.\n");
   ExtOut("be:            Enable x86 breakpoint.\n");
   ExtOut("bd:            Disable x86 breakpoint.\n");
   ExtOut("t <count>:     x86 trace on next 'g'.\n");
   ExtOut("tr <count>:    x86 trace with regs on next 'g'.\n");
   ExtOut("p <count>:     x86 step on next 'g'.\n");
   ExtOut("pr <count>:    x86 step with regs on next 'g'.\n");
   ExtOut("tlog <-r> [count] [file]  "              );
   ExtOut("               single-step 'count' instructions and log to a file.\n");
   ExtOut("lf:            Dump/Set log flags.\n");
   ExtOut("l2f:           Enable logging to file .\n");
   ExtOut("\n");
   ExtOut("New Commands:\n");
   ExtOut("sw:            Switch between 32-bit and 64-bit mode .\n");
   ExtOut("filever [-v] <address>|<pathname>:\n");
   ExtOut("               Dumps file version info.\n");
   ExtOut("\n");
   ExtOut("Tentative Commands:\n");
   ExtOut("bp32           set x86 breakpoint\n");
   ExtOut("bp64           set ia64 breakpoint\n");
   ExtOut("r32            Dump or modify x86 registers (if context available)\n");
   ExtOut("r64            Dump or modify ia64 registers\n");
   ExtOut("k32            Dumps x86 stack trace (if context available)\n");
   ExtOut("k64            Dumps ia64 stack trace\n");
   ExtOut("u32            Unassemble x86 code (if possible)\n");
   ExtOut("u64            Unassemble ia64 code (if possible)\n");
   ExtOut("\n");
   ExtOut("WoW64 Category Logging Commands:\n");
   ExtOut("wow64lc        Lists all logging categories\n");
   ExtOut("wow64lo        Modifies logging output options\n");
   ExtOut("\n");


}





DEFINE_FORWARD_ENGAPI(help, Help())

DEFINE_FORWARD_ENGAPI(tls, PrintTls())
DEFINE_FORWARD_ENGAPI(straddr, PrintStructAddress())



DECLARE_ENGAPI(ctx)
{
    PVOID Address;
    int i;
    ULONG EFlags;
    char *pchCmd;
    CONTEXT32 Context;
    char Buffer[256];

    INIT_ENGAPI;

    //
    // advance to first token, expecting address of context
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    Status = TryGetExpr(pchCmd, (ULONG_PTR *)&Address);
    if (FAILED(Status)) {
        ExtOut("Invalid Expression '%s' Status %x\n", pchCmd, Status);
        EXIT_ENGAPI;
    }


    Status = g_ExtData->ReadVirtual((ULONG64)Address, &Context, sizeof(Context), NULL);
    if (FAILED(Status)) {
        ExtOut("Unable to read Context %x Status %x\n",
                Address,
                Status
                );
        EXIT_ENGAPI;
    }

    //
    // we make the gross assumption that we have enuf space in
    // Buffer to do three lines of output!
    //

    i = sprintf(Buffer,
                "eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n",
                Context.Eax,
                Context.Ebx,
                Context.Ecx,
                Context.Edx,
                Context.Esi,
                Context.Edi
                );


    EFlags = Context.EFlags;

    i += sprintf(Buffer + i,
                 "eip=%08x esp=%08x ebp=%08x iopl=%x "
                 "%s %s %s %s %s %s %s %s\n",
                 Context.Eip,
                 Context.Esp,
                 Context.Ebp,
                 (EFlags & (BIT12 | BIT13)) >> 12,
                 (EFlags & BIT11) ? "ov" : "nv",
                 (EFlags & BIT10) ? "dn" : "up",
                 (EFlags & BIT9) ? "ei" : "di",
                 (EFlags & BIT7) ? "ng" : "pl",
                 (EFlags & BIT6) ? "zr" : "nz",
                 (EFlags & BIT4) ? "ac" : "na",
                 (EFlags & BIT2) ? "po" : "pe",
                 (EFlags & BIT0) ? "cy" : "nc"
                 );

    i += sprintf(Buffer+i,
                "cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x  efl=%08x\n",
                Context.SegCs,
                Context.SegSs,
                Context.SegDs,
                Context.SegEs,
                Context.SegFs,
                Context.SegGs,
                EFlags
                );

    ExtOut(Buffer);
    EXIT_ENGAPI;
}

ULONG_PTR
GETEXPRESSION(char * expr)
{
    HRESULT hr = S_OK;
    DEBUG_VALUE IntVal;
    hr = g_ExtControl->Evaluate((PSTR)expr, 
                                DEBUG_VALUE_INT64,
                                &IntVal, 
                                NULL);
    if (hr == S_OK) {
        return (ULONG_PTR)IntVal.I64;
    } else {
        return (ULONG_PTR)NULL;
    }
}

/*
 * Does a plain old GetExpression under a try-except
 */
HRESULT
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    __try {
        *pValue = GETEXPRESSION(Expression);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    //g_ExcepCallbacks.Uninitialize();
    //g_FnProfCallbacks.Uninitialize();
}


// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


/* 
    Wow64extsfn

Abstract
    
    This export function is called from debugger engine 
    to handle cpu-specific issues -- flushing cpu instruction cache,
    retrieving and setting context when switching between 32-bit
    and 64-bit mode

Arguments:
    ActionCode = WOW64EXTS_FLUSH_CACHE_WITH_HANDLE
        Arg1 - the current process handle
        Arg2 - Starting Address
        Arg3 - Length of bytes to flush
    ( This action is called only when a trace/step breakpoint is inserted,
      there is no debug client, so process handle is needed. )        
        
    
    ActionCode = WOW64EXTS_FLUSH_CACHE
        Arg1 - the current process handle
        Arg2 - Starting Address
        Arg3 - Length of bytes to flush
        
    ActionCode = WOW64EXTS_GET_CONTEXT
        Arg1 - Debug Client 
        Arg2 - retrieved Context 
        
    ActionCode = WOW64EXTS_SET_CONTEXT
        Arg1 - Debug Client 
        Arg2 - Context to set
        
*/

extern "C" 
void CALLBACK 
Wow64extsfn(
    IN ULONG64 ActionCode,
    ULONG64 Arg1,
    ULONG64 Arg2,
    ULONG64 Arg3)

{
    PVOID CpuData = NULL;
    
    if (ActionCode == WOW64EXTS_FLUSH_CACHE_WITH_HANDLE)  {
        (*g_pfnCpuDbgFlushInstructionCacheWithHandle)((HANDLE)Arg1,
                                              (PVOID)Arg2,
                                              (DWORD)Arg3);
        return;
    }

    ExtQuery((PDEBUG_CLIENT)Arg1);

    switch(ActionCode) {
    case WOW64EXTS_FLUSH_CACHE:
        (*g_pfnCpuDbgFlushInstructionCache)((PDEBUG_CLIENT)Arg1,
                                    (PVOID)Arg2,
                                    (DWORD)Arg3);
        break;
    
    case WOW64EXTS_GET_CONTEXT:
        (*g_pfnCpuDbgGetRemoteContext)((PDEBUG_CLIENT)Arg1, 
                               (PVOID)CpuData);
        ((PCONTEXT32)Arg2)->ContextFlags=CONTEXT32_FULLFLOAT;
        (*g_pfnCpuDbgGetLocalContext)((PDEBUG_CLIENT)Arg1, 
                              (PCONTEXT32)Arg2);
        break;
    
    case WOW64EXTS_SET_CONTEXT:
        (*g_pfnCpuDbgSetLocalContext)((PDEBUG_CLIENT)Arg1,
                              (PCONTEXT32)Arg2);
        (*g_pfnCpuDbgSetRemoteContext)((PDEBUG_CLIENT)Arg1);
        break;
    }
    ExtRelease();
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\dbgexts\wow64\wrapper.cpp ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    wrapper.c

Abstract:
    
    wrapper extension commands
    
    1-July-2000    t-tcheng

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgeng.h>

#if defined _X86_
#define WOW64EXTS_386
#endif

#include <wow64.h>
#include <wow64exts.h>

#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <wow64cpu.h>

#define EXTDEFINE32(name, command)                                 \
        DEFINE_FORWARD_ENGAPI(name, ExtExecute(""#command"", MACHINE_TYPE32) )
                                       

#define EXTDEFINE64(name, command)                                 \
        DEFINE_FORWARD_ENGAPI(name, ExtExecute(""#command"", MACHINE_TYPE64) )                               
        

/*
    sw -- switch between 32-bit and 64-bit mode
*/
DECLARE_ENGAPI(sw)
{
    ULONG OldEffectiveProcessorType;
    PVOID CpuData=NULL;
    INIT_ENGAPI;

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("sw: Error 0x%x while GetEffectiveProcessorType.\n", Status);
    }
    if (OldEffectiveProcessorType == MACHINE_TYPE32) {
        Status = g_ExtControl->SetEffectiveProcessorType(MACHINE_TYPE64);
        if (FAILED(Status)) {
            ExtOut("sw: Error 0x%x while SetEffectiveProcessorType.\n", Status);
          
        }
        ExtOut(STRING_SWITCHED_64MODE);
    } else {
        if (!(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
            ExtOut("The current thread doesn't have an x86 context.\n");
            EXIT_ENGAPI;
        }

        Status = g_ExtControl->SetEffectiveProcessorType(MACHINE_TYPE32);
        if (FAILED(Status)) {
            ExtOut("sw: Error 0x%x while SetEffectiveProcessorType.\n", Status);
          
        }
        ExtOut(STRING_SWITCHED_32MODE);
    }

    EXIT_ENGAPI;
}


/*
    k -- Output both 32-bit and 64-bit stack trace
*/

DECLARE_ENGAPI(k)
{
    ULONG OldEffectiveProcessorType, NewMachine;
    PDEBUG_CONTROL savedControl;
    CHAR buffer[MAX_BUFFER_SIZE];    
    PVOID CpuData = NULL;
    INIT_ENGAPI;
    

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while GetEffectiveProcessorType.\n", Status);
        EXIT_ENGAPI;
    }
    
    NewMachine = (OldEffectiveProcessorType == MACHINE_TYPE32)
              ? MACHINE_TYPE64 : MACHINE_TYPE32;
       
    savedControl = g_ExtControl;

    ExtOut("Walking %d-bit Stack... \n", (NewMachine == MACHINE_TYPE32)
                ? 64 : 32);
    
    _snprintf(buffer, MAX_BUFFER_SIZE, "k %s", ArgumentString);

    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while Execute.\n", Status);
        EXIT_ENGAPI;
    }
    
    g_ExtControl = savedControl;

    Status = g_ExtControl->SetEffectiveProcessorType(NewMachine);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while SetEffectiveProcessorType.\n", Status);
        EXIT_ENGAPI;
    }
    
    ExtOut("Walking %d-bit Stack... \n", (NewMachine == MACHINE_TYPE32)
                ? 32 : 64);

    if (NewMachine == MACHINE_TYPE32 && 
       !(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
        ExtOut("No 32-bit context available!\n");
        EXIT_ENGAPI;
    }
    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!k: Error 0x%x while Execute.\n", Status);
        EXIT_ENGAPI;
    }
    g_ExtControl = savedControl;
    g_ExtControl->SetEffectiveProcessorType(OldEffectiveProcessorType);
    EXIT_ENGAPI;
}


void ExtExecute(PCSTR command, ULONG MachineType)
{
    ULONG OldEffectiveProcessorType;
    CHAR buffer[MAX_BUFFER_SIZE];
    PDEBUG_CONTROL savedControl;
    PVOID CpuData = NULL;
    HRESULT Status;

    // save g_ExtControl, because it will be released after calling Execute
    savedControl = g_ExtControl;

    Status = g_ExtControl->GetEffectiveProcessorType(&OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while GetEffectiveProcessorType.\n",command, Status);
        return;
    }
    
    if ((OldEffectiveProcessorType == MACHINE_TYPE64) &&
        (command[0]=='r' || command[0]=='k' || command[0]=='u') &&
        !(*g_pfnCpuDbgGetRemoteContext)(g_ExtClient, (PVOID)CpuData)) {
        
        ExtOut("The current thread doesn't have an x86 context.\n");
        goto EXIT;
    }


    
    Status = g_ExtControl->SetEffectiveProcessorType(MachineType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while SetEffectiveProcessorType.\n",command, Status);
        goto EXIT;
    }
    _snprintf(buffer, MAX_BUFFER_SIZE, "%s %s",command, ArgumentString);
    
    Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while Execute.\n",command, Status);
        goto EXIT;
    }

EXIT:    
    Status = savedControl->SetEffectiveProcessorType(OldEffectiveProcessorType);
    if (FAILED(Status)) {
        ExtOut("!%s: Error 0x%x while SetEffectiveProcessorType.\n",command, Status);
    }
}

EXTDEFINE32(r,r)
EXTDEFINE32(u,u)
EXTDEFINE32(t,t)
EXTDEFINE32(p,p)
EXTDEFINE32(tr,tr)
EXTDEFINE32(pr,pr)
EXTDEFINE32(bp,bp)
EXTDEFINE32(bl,bl)
EXTDEFINE32(be,be)
EXTDEFINE32(bd,bd)
EXTDEFINE32(bc,bc)
EXTDEFINE32(kb,kb)

EXTDEFINE32(r32,r)
EXTDEFINE32(bp32,bp)
EXTDEFINE32(k32,k)

EXTDEFINE64(r64,r)
EXTDEFINE64(bp64,bp)
EXTDEFINE64(k64,k)

DECLARE_ENGAPI(tlog)
{
    char *pchCmd;
    ULONG TraceCount,i;
    char buffer[MAX_BUFFER_SIZE];
    ULONG OldRadix = 0;
    BOOL DumpReg = FALSE;
    PDEBUG_CONTROL savedControl;
    DEBUG_VALUE pdValue;
    INIT_ENGAPI;
    while (*ArgumentString && isspace(*ArgumentString)) {
        ArgumentString++;
    }
    pchCmd = ArgumentString;
    
    if ((*pchCmd == '-' || *pchCmd == '/') && 
       (*(pchCmd+1) == 'r' || *(pchCmd+1) == 'R'))  { 
        pchCmd +=2;
        while (*pchCmd && isspace(*pchCmd)) {
           pchCmd++;
        }
        DumpReg = TRUE;
    }
    
    g_ExtControl->GetRadix(&OldRadix);
    if (FAILED(Status)) {
        ExtOut("!tlog: Error 0x%x while GetRadix.\n", Status);
        goto EXIT;
    }
    
    g_ExtControl->SetRadix(10);
    if (FAILED(Status)) {
        ExtOut("!tlog: Error 0x%x while SetRadix.\n", Status);
        goto EXIT;
    }

    g_ExtControl->Evaluate(pchCmd, DEBUG_VALUE_INT32, &pdValue, NULL);
    if (FAILED(Status)) {
        ExtOut("!tlog Usage: tlog <-r> [count] [file].\n", Status);
        goto EXIT;
    }
    TraceCount = pdValue.I32;

    if (TraceCount ==0) {
        ExtOut("Invalid Trace Count\n", pchCmd, Status);
        goto EXIT;
    }
    
    //
    // skip to the next token
    //
    while (*pchCmd && !isspace(*pchCmd)) {
        pchCmd++;
    }
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    if (DumpReg) {
        savedControl = g_ExtControl;
        if (_snprintf(buffer, MAX_BUFFER_SIZE-sizeof(buffer[0]), ".logopen %s;", pchCmd) > 0) {
            
            Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
            if (FAILED(Status)) {
                ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
                goto EXIT;
            }
            for (i=1; i<=TraceCount; i++) {
                g_ExtControl = savedControl;
                Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,"t;r;",0);
                if (FAILED(Status)) {
                    ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
                    goto EXIT;
                }
            }
            g_ExtControl = savedControl;
            Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,".logclose",0);
            if (FAILED(Status)) {
                ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
                goto EXIT;
            }
        }

    } else {
        if (*pchCmd) {
            _snprintf(buffer, MAX_BUFFER_SIZE, ".logopen %s;t %d;.logclose", pchCmd, (ULONG)TraceCount+1);
        } else {
            sprintf(buffer, "t %d", (ULONG)TraceCount, pchCmd);
        }

        Status = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,buffer,0);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while Execute.\n", Status);
            goto EXIT;
        }
    }
    
EXIT:    
    if (OldRadix) {
        g_ExtControl->SetRadix(OldRadix);
        if (FAILED(Status)) {
            ExtOut("!tlog: Error 0x%x while SetRadix.\n", Status);
        }
    }

    EXIT_ENGAPI;
}



DECLARE_ENGAPI(filever)
{
    char              *pchCmd;
    LPVOID            lpVersionInfo;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    ULONG64           offset, DllBase;
    UINT              uLen;
    char              NameBuffer[256];
    BOOL              Verbose=FALSE;
    
    INIT_ENGAPI;
    
    Status = S_OK;
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }
    
    if ((*pchCmd == '-' || *pchCmd == '/') && 
       (*(pchCmd+1) == 'v' || *(pchCmd+1) == 'V'))  { 
        pchCmd +=2;
        while (*pchCmd && isspace(*pchCmd)) {
           pchCmd++;
        }
        Verbose = TRUE;
    }
    
    offset = GETEXPRESSION(pchCmd);
    if (offset) {
        Status = g_ExtSymbols->GetModuleByOffset(offset, 0, NULL, &DllBase);
        Status = FindFullImage64Name(DllBase, 
                                   NameBuffer,
                                   256);
        if (Status !=S_OK) {
            Status = FindFullImage32Name(DllBase, 
                                         NameBuffer,
                                         256);
            if (Status!=S_OK) {
                ExtOut("GetImageName failed\n");
                goto Cleanup;
            }

        } 
        ExtOut("ImageFile= %s\n", NameBuffer);
        pchCmd = NameBuffer;
        
    }

    FileHandle = CreateFile(pchCmd,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
        
    if (FileHandle == INVALID_HANDLE_VALUE)  {
        ExtOut("Open Image File failed!\n");
        goto Cleanup;
    }

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);
    if (MappingHandle == NULL) {
        goto Cleanup;
    }

    DllBase = (ULONG64)MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );

    if (DllBase == NULL) {
        goto Cleanup;
    }

    
    hinst = (HMODULE)(DllBase | 0x00000001);
    
    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL) {
        goto Cleanup;
    }
    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL) {
        goto Cleanup;
    }

    lpVersionInfo = GlobalAllocPtr(GHND, pVerHead->wTotLen + pVerHead->wTotLen/2);

    if (lpVersionInfo == NULL) {
        goto Cleanup;
    }

    memcpy(lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    
    PrintFixedFileInfo(pchCmd, lpVersionInfo, Verbose);
    
Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase && (!offset))
        UnmapViewOfFile((PVOID)DllBase);
    if (lpVersionInfo)
        GlobalFreePtr(lpVersionInfo);

    EXIT_ENGAPI;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\apimap.c ===
/*++                 

Copyright (c) 2001 Microsoft Corporation

Module Name:

    apimap.c

Abstract:
    
    A table containing API categorization to help in logging.

Author:

    03-May-2001    KenCoope

Revision History:

--*/

//
// API Categories
//
API_CATEGORY Wow64ApiCategories[] =
{
    { "ExecutiveFunctions", 0, WHNT32_INDEX },
    { "IoFunctions", 0, WHNT32_INDEX },
    { "KernelFunctions", 0, WHNT32_INDEX },
    { "LpcFunctions", 0, WHNT32_INDEX },
    { "MemoryFunctions", 0, WHNT32_INDEX },
    { "ObjectFunctions", 0, WHNT32_INDEX },
    { "PnpFunctions", 0, WHNT32_INDEX },
    { "PowerFunctions", 0, WHNT32_INDEX },
    { "ProcessFunctions", 0, WHNT32_INDEX },
    { "RegistryFunctions", 0, WHNT32_INDEX },
    { "SecurityFunctions", 0, WHNT32_INDEX },
    { "ExceptionFunctions", 0, WHNT32_INDEX },
    { "NtWow64CsrFunctions", 0, WHNT32_INDEX },
    { "BaseWow64CsrFunctions", 0, WHBASE_INDEX },
    { "UnclassifiedNtosKrnlFunctions", 0, WHNT32_INDEX },
    { "UnclassifiedConsoleFunctions", 0, WHCON_INDEX },
    { "UnclassifiedWin32Functions", 0, WHWIN32_INDEX },
    { "UnclassifiedBaseFunctions", 0, WHBASE_INDEX },
    
    // null terminating entry
    { NULL, 0 }
};

//
// API Category Mappings
//
ULONG   ApiCategoryMappingNextFree = (ULONG)(-1);

API_CATEGORY_MAPPING Wow64ApiCategoryMappings[MAX_API_MAPPINGS] =
{
    // NT Executive APIs (ntexapi.h)
    { "NtDelayExecution",       APICAT_EXECUTIVE, 0 },
    { "NtQuerySystemEnvironmentValue",   APICAT_EXECUTIVE, 0 },
    { "NtSetSystemEnvironmentValue",     APICAT_EXECUTIVE, 0 },
    { "NtQuerySystemEnvironmentValueEx", APICAT_EXECUTIVE, 0 },
    { "NtSetSystemEnvironmentValueEx",   APICAT_EXECUTIVE, 0 },
    { "NtEnumerateSystemEnvironmentValuesEx",   APICAT_EXECUTIVE, 0 },
    { "NtAddBootEntry",         APICAT_EXECUTIVE, 0 },
    { "NtDeleteBootEntry",      APICAT_EXECUTIVE, 0 },
    { "NtModifyBootEntry",      APICAT_EXECUTIVE, 0 },
    { "NtEnumerateBootEntries", APICAT_EXECUTIVE, 0 },
    { "NtQueryBootEntryOrder",  APICAT_EXECUTIVE, 0 },
    { "NtSetBootEntryOrder",    APICAT_EXECUTIVE, 0 },
    { "NtQueryBootOptions",     APICAT_EXECUTIVE, 0 },
    { "NtSetBootOptions",       APICAT_EXECUTIVE, 0 },
    { "NtTranslateFilePath",    APICAT_EXECUTIVE, 0 },
    { "NtClearEvent",           APICAT_EXECUTIVE, 0 },
    { "NtCreateEvent",          APICAT_EXECUTIVE, 0 },
    { "NtOpenEvent",            APICAT_EXECUTIVE, 0 },
    { "NtPulseEvent",           APICAT_EXECUTIVE, 0 },
    { "NtQueryEvent",           APICAT_EXECUTIVE, 0 },
    { "NtResetEvent",           APICAT_EXECUTIVE, 0 },
    { "NtSetEvent",             APICAT_EXECUTIVE, 0 },
    { "NtSetEventBoostPriority",        APICAT_EXECUTIVE, 0 },
    { "NtCreateEventPair",      APICAT_EXECUTIVE, 0 },
    { "NtOpenEventPair",        APICAT_EXECUTIVE, 0 },
    { "NtWaitLowEventPair",     APICAT_EXECUTIVE, 0 },
    { "NtWaitHighEventPair",    APICAT_EXECUTIVE, 0 },
    { "NtSetLowWaitHighEventPair",      APICAT_EXECUTIVE, 0 },
    { "NtSetHighWaitLowEventPair",      APICAT_EXECUTIVE, 0 },
    { "NtSetLowEventPair",      APICAT_EXECUTIVE, 0 },
    { "NtSetHighEventPair",     APICAT_EXECUTIVE, 0 },
    { "NtCreateMutant",         APICAT_EXECUTIVE, 0 },
    { "NtOpenMutant",           APICAT_EXECUTIVE, 0 },
    { "NtQueryMutant",          APICAT_EXECUTIVE, 0 },
    { "NtReleaseMutant",        APICAT_EXECUTIVE, 0 },
    { "NtCreateSemaphore",      APICAT_EXECUTIVE, 0 },
    { "NtOpenSemaphore",        APICAT_EXECUTIVE, 0 },
    { "NtQuerySemaphore",       APICAT_EXECUTIVE, 0 },
    { "NtReleaseSemaphore",     APICAT_EXECUTIVE, 0 },
    { "NtCreateTimer",          APICAT_EXECUTIVE, 0 },
    { "NtOpenTimer",            APICAT_EXECUTIVE, 0 },
    { "NtCancelTimer",          APICAT_EXECUTIVE, 0 },
    { "NtQueryTimer",           APICAT_EXECUTIVE, 0 },
    { "NtSetTimer",             APICAT_EXECUTIVE, 0 },
    { "NtQuerySystemTime",      APICAT_EXECUTIVE, 0 },
    { "NtSetSystemTime",        APICAT_EXECUTIVE, 0 },
    { "NtQueryTimerResolution", APICAT_EXECUTIVE, 0 },
    { "NtSetTimerResolution",   APICAT_EXECUTIVE, 0 },
    { "NtAllocateLocallyUniqueId",      APICAT_EXECUTIVE, 0 },
    { "NtSetUuidSeed",          APICAT_EXECUTIVE, 0 },
    { "NtAllocateUuids",        APICAT_EXECUTIVE, 0 },
    { "NtCreateProfile",        APICAT_EXECUTIVE, 0 },
    { "NtStartProfile",         APICAT_EXECUTIVE, 0 },
    { "NtStopProfile",          APICAT_EXECUTIVE, 0 },
    { "NtSetIntervalProfile",   APICAT_EXECUTIVE, 0 },
    { "NtQueryIntervalProfile", APICAT_EXECUTIVE, 0 },
    { "NtQueryPerformanceCounter",      APICAT_EXECUTIVE, 0 },
    { "NtCreateKeyedEvent",     APICAT_EXECUTIVE, 0 },
    { "NtOpenKeyedEvent",       APICAT_EXECUTIVE, 0 },
    { "NtReleaseKeyedEvent",    APICAT_EXECUTIVE, 0 },
    { "NtWaitForKeyedEvent",    APICAT_EXECUTIVE, 0 },
//    { "NapClearData",           APICAT_EXECUTIVE, 0 },
//    { "NapRetrieveData",        APICAT_EXECUTIVE, 0 },
//    { "NapGetApiCount",         APICAT_EXECUTIVE, 0 },
//    { "NapPause",               APICAT_EXECUTIVE, 0 },
//    { "NapResume",              APICAT_EXECUTIVE, 0 },
    { "NtQuerySystemInformation",       APICAT_EXECUTIVE, 0 },
    { "NtSetSystemInformation", APICAT_EXECUTIVE, 0 },
    { "NtSystemDebugControl",   APICAT_EXECUTIVE, 0 },
    { "NtRaiseHardError",       APICAT_EXECUTIVE, 0 },
    { "NtGetTickCount",         APICAT_EXECUTIVE, 0 },
    { "NtQueryDefaultLocale",   APICAT_EXECUTIVE, 0 },
    { "NtSetDefaultLocale",     APICAT_EXECUTIVE, 0 },
    { "NtQueryInstallUILanguage",       APICAT_EXECUTIVE, 0 },
    { "NtQueryDefaultUILanguage",       APICAT_EXECUTIVE, 0 },
    { "NtSetDefaultUILanguage", APICAT_EXECUTIVE, 0 },
    { "NtSetDefaultHardErrorPort",      APICAT_EXECUTIVE, 0 },
    { "NtShutdownSystem",       APICAT_EXECUTIVE, 0 },
    { "NtDisplayString",        APICAT_EXECUTIVE, 0 },
    { "NtAddAtom",              APICAT_EXECUTIVE, 0 },
    { "NtFindAtom",             APICAT_EXECUTIVE, 0 },
    { "NtDeleteAtom",           APICAT_EXECUTIVE, 0 },
    { "NtQueryInformationAtom", APICAT_EXECUTIVE, 0 },

    // NT Io APIs (ntioapi.h)
    { "NtCancelIoFile",         APICAT_IO, 0 },
    { "NtCreateNamedPipeFile",  APICAT_IO, 0 },
    { "NtCreateMailslotFile",   APICAT_IO, 0 },
    { "NtDeleteFile",           APICAT_IO, 0 },
    { "NtFlushBuffersFile",     APICAT_IO, 0 },
    { "NtNotifyChangeDirectoryFile",    APICAT_IO, 0 },
    { "NtQueryAttributesFile",  APICAT_IO, 0 },
    { "NtQueryFullAttributesFile",      APICAT_IO, 0 },
    { "NtQueryEaFile",          APICAT_IO, 0 },
    { "NtCreateFile",           APICAT_IO, 0 },
    { "NtDeviceIoControlFile",  APICAT_IO, 0 },
    { "NtFsControlFile",        APICAT_IO, 0 },
    { "NtLockFile",             APICAT_IO, 0 },
    { "NtOpenFile",             APICAT_IO, 0 },
    { "NtQueryDirectoryFile",   APICAT_IO, 0 },
    { "NtQueryInformationFile", APICAT_IO, 0 },
    { "NtQueryQuotaInformationFile",    APICAT_IO, 0 },
    { "NtQueryVolumeInformationFile",   APICAT_IO, 0 },
    { "NtReadFile",             APICAT_IO, 0 },
    { "NtSetInformationFile",   APICAT_IO, 0 },
    { "NtSetQuotaInformationFile",      APICAT_IO, 0 },
    { "NtSetVolumeInformationFile",     APICAT_IO, 0 },
    { "NtWriteFile",            APICAT_IO, 0 },
    { "NtUnlockFile",           APICAT_IO, 0 },
    { "NtReadFile64",           APICAT_IO, 0 },
    { "NtReadFileScatter",      APICAT_IO, 0 },
    { "NtSetEaFile",            APICAT_IO, 0 },
    { "NtWriteFile64",          APICAT_IO, 0 },
    { "NtWriteFileGather",      APICAT_IO, 0 },
    { "NtLoadDriver",           APICAT_IO, 0 },
    { "NtUnloadDriver",         APICAT_IO, 0 },
    { "NtCreateIoCompletion",   APICAT_IO, 0 },
    { "NtOpenIoCompletion",     APICAT_IO, 0 },
    { "NtQueryIoCompletion",    APICAT_IO, 0 },
    { "NtSetIoCompletion",      APICAT_IO, 0 },
    { "NtRemoveIoCompletion",   APICAT_IO, 0 },
    
    // NT Kernel APIs (ntkeapi.h)
    { "NtCallbackReturn",       APICAT_KERNEL, 0 },
    { "NtQueryDebugFilterState",        APICAT_KERNEL, 0 },
    { "NtSetDebugFilterState",  APICAT_KERNEL, 0 },
    { "NtW32Call",              APICAT_KERNEL, 0 },
    { "NtYieldExecution",       APICAT_KERNEL, 0 },

    // NT LPC APIs (ntlpcapi.h)
    { "NtCreatePort",           APICAT_LPC, 0 },
    { "NtCreateWaitablePort",   APICAT_LPC, 0 },
    { "NtConnectPort",          APICAT_LPC, 0 },
    { "NtSecureConnectPort",    APICAT_LPC, 0 },
    { "NtListenPort",           APICAT_LPC, 0 },
    { "NtAcceptConnectPort",    APICAT_LPC, 0 },
    { "NtCompleteConnectPort",  APICAT_LPC, 0 },
    { "NtRequestPort",          APICAT_LPC, 0 },
    { "NtRequestWaitReplyPort", APICAT_LPC, 0 },
    { "NtReplyPort",            APICAT_LPC, 0 },
    { "NtReplyWaitReplyPort",   APICAT_LPC, 0 },
    { "NtReplyWaitReceivePort", APICAT_LPC, 0 },
    { "NtReplyWaitReceivePortEx",       APICAT_LPC, 0 },
    { "NtImpersonateClientOfPort",      APICAT_LPC, 0 },
    { "NtReadRequestData",      APICAT_LPC, 0 },
    { "NtWriteRequestData",     APICAT_LPC, 0 },
    { "NtQueryInformationPort", APICAT_LPC, 0 },

    // NT Memory APIs (ntmmapi.h)
    { "NtCreateSection",        APICAT_MEMORY, 0 },
    { "NtOpenSection",          APICAT_MEMORY, 0 },
    { "NtMapViewOfSection",     APICAT_MEMORY, 0 },
    { "NtUnmapViewOfSection",   APICAT_MEMORY, 0 },
    { "NtExtendSection",        APICAT_MEMORY, 0 },
    { "NtAreMappedFilesTheSame",        APICAT_MEMORY, 0 },
    { "NtAllocateVirtualMemory",        APICAT_MEMORY, 0 },
    { "NtFreeVirtualMemory",    APICAT_MEMORY, 0 },
    { "NtReadVirtualMemory",    APICAT_MEMORY, 0 },
    { "NtWriteVirtualMemory",   APICAT_MEMORY, 0 },
    { "NtFlushVirtualMemory",   APICAT_MEMORY, 0 },
    { "NtLockVirtualMemory",    APICAT_MEMORY, 0 },
    { "NtUnlockVirtualMemory",  APICAT_MEMORY, 0 },
    { "NtProtectVirtualMemory", APICAT_MEMORY, 0 },
    { "NtQueryVirtualMemory",   APICAT_MEMORY, 0 },
    { "NtQuerySection",         APICAT_MEMORY, 0 },
    { "NtMapUserPhysicalPages", APICAT_MEMORY, 0 },
    { "NtMapUserPhysicalPagesScatter",  APICAT_MEMORY, 0 },
    { "NtAllocateUserPhysicalPages",    APICAT_MEMORY, 0 },
    { "NtFreeUserPhysicalPages",        APICAT_MEMORY, 0 },
    { "NtGetWriteWatch",        APICAT_MEMORY, 0 },
    { "NtResetWriteWatch",      APICAT_MEMORY, 0 },
    { "NtCreatePagingFile",     APICAT_MEMORY, 0 },
    { "NtFlushInstructionCache",        APICAT_MEMORY, 0 },
    { "NtFlushWriteBuffer",     APICAT_MEMORY, 0 },

    // NT Object Manager APIs (ntobapi.h)
    { "NtQueryObject",          APICAT_OBJECT, 0 },
    { "NtSetInformationObject", APICAT_OBJECT, 0 },
    { "NtDuplicateObject",      APICAT_OBJECT, 0 },
    { "NtMakeTemporaryObject",  APICAT_OBJECT, 0 },
    { "NtMakePermanentObject",  APICAT_OBJECT, 0 },
    { "NtSignalAndWaitForSingleObject", APICAT_OBJECT, 0 },
    { "NtWaitForSingleObject",  APICAT_OBJECT, 0 },
    { "NtWaitForMultipleObjects",       APICAT_OBJECT, 0 },
    { "NtSetSecurityObject",    APICAT_OBJECT, 0 },
    { "NtQuerySecurityObject",  APICAT_OBJECT, 0 },
    { "NtClose",                APICAT_OBJECT, 0 },
    { "NtCreateDirectoryObject",        APICAT_OBJECT, 0 },
    { "NtOpenDirectoryObject",  APICAT_OBJECT, 0 },
    { "NtQueryDirectoryObject", APICAT_OBJECT, 0 },
    { "NtCreateSymbolicLinkObject",     APICAT_OBJECT, 0 },
    { "NtOpenSymbolicLinkObject",       APICAT_OBJECT, 0 },
    { "NtQuerySymbolicLinkObject",      APICAT_OBJECT, 0 },

    // NT PnP APIs (ntpnpapi.h)
    { "NtGetPlugPlayEvent",     APICAT_PNP, 0 },
    { "NtPlugPlayControl",      APICAT_PNP, 0 },

    // NT Power APIs (ntpoapi.h)
    { "NtPowerInformation",     APICAT_POWER, 0 },
    { "NtSetThreadExecutionState",      APICAT_POWER, 0 },
    { "NtRequestWakeupLatency", APICAT_POWER, 0 },
    { "NtInitiatePowerAction",  APICAT_POWER, 0 },
    { "NtSetSystemPowerState",  APICAT_POWER, 0 },
    { "NtGetDevicePowerState",  APICAT_POWER, 0 },
    { "NtCancelDeviceWakeupRequest",    APICAT_POWER, 0 },
    { "NtIsSystemResumeAutomatic",      APICAT_POWER, 0 },
    { "NtRequestDeviceWakeup",  APICAT_POWER, 0 },

    // NT Process APIs (ntpsapi.h)
    { "NtCreateProcess",        APICAT_PROCESS, 0 },
    { "NtCreateProcessEx",      APICAT_PROCESS, 0 },
    { "NtOpenProcess",          APICAT_PROCESS, 0 },
    { "NtTerminateProcess",     APICAT_PROCESS, 0 },
    { "NtQueryInformationProcess",      APICAT_PROCESS, 0 },
    { "NtSetInformationProcess",        APICAT_PROCESS, 0 },
    { "NtCreateThread",         APICAT_PROCESS, 0 },
    { "NtOpenThread",           APICAT_PROCESS, 0 },
    { "NtTerminateThread",      APICAT_PROCESS, 0 },
    { "NtSuspendThread",        APICAT_PROCESS, 0 },
    { "NtResumeThread",         APICAT_PROCESS, 0 },
    { "NtSuspendProcess",       APICAT_PROCESS, 0 },
    { "NtResumeProcess",        APICAT_PROCESS, 0 },
    { "NtGetContextThread",     APICAT_PROCESS, 0 },
    { "NtSetContextThread",     APICAT_PROCESS, 0 },
    { "NtQueryInformationThread",       APICAT_PROCESS, 0 },
    { "NtSetInformationThread", APICAT_PROCESS, 0 },
    { "NtAlertThread",          APICAT_PROCESS, 0 },
    { "NtAlertResumeThread",    APICAT_PROCESS, 0 },
    { "NtImpersonateThread",    APICAT_PROCESS, 0 },
    { "NtTestAlert",            APICAT_PROCESS, 0 },
    { "NtRegisterThreadTerminatePort",  APICAT_PROCESS, 0 },
    { "NtSetLdtEntries",        APICAT_PROCESS, 0 },
    { "NtQueueApcThread",       APICAT_PROCESS, 0 },
    { "NtCreateJobObject",      APICAT_PROCESS, 0 },
    { "NtOpenJobObject",        APICAT_PROCESS, 0 },
    { "NtAssignProcessToJobObject",     APICAT_PROCESS, 0 },
    { "NtTerminateJobObject",   APICAT_PROCESS, 0 },
    { "NtIsProcessInJob",       APICAT_PROCESS, 0 },
    { "NtCreateJobSet",         APICAT_PROCESS, 0 },
    { "NtQueryInformationJobObject",    APICAT_PROCESS, 0 },
    { "NtSetInformationJobObject",      APICAT_PROCESS, 0 },
    
    // NT Registry APIs (ntregapi.h)
    { "NtCreateKey",            APICAT_REGISTRY, 0 },
    { "NtDeleteKey",            APICAT_REGISTRY, 0 },
    { "NtDeleteValueKey",       APICAT_REGISTRY, 0 },
    { "NtEnumerateKey",         APICAT_REGISTRY, 0 },
    { "NtEnumerateValueKey",    APICAT_REGISTRY, 0 },
    { "NtFlushKey",             APICAT_REGISTRY, 0 },
    { "NtInitializeRegistry",   APICAT_REGISTRY, 0 },
    { "NtNotifyChangeKey",      APICAT_REGISTRY, 0 },
    { "NtNotifyChangeMultipleKeys",     APICAT_REGISTRY, 0 },
    { "NtLoadKey",              APICAT_REGISTRY, 0 },
    { "NtLoadKey2",             APICAT_REGISTRY, 0 },
    { "NtOpenKey",              APICAT_REGISTRY, 0 },
    { "NtQueryKey",             APICAT_REGISTRY, 0 },
    { "NtQueryValueKey",        APICAT_REGISTRY, 0 },
    { "NtQueryMultipleValueKey",APICAT_REGISTRY, 0 },
    { "NtReplaceKey",           APICAT_REGISTRY, 0 },
    { "NtRenameKey",            APICAT_REGISTRY, 0 },
    { "NtCompactKeys",          APICAT_REGISTRY, 0 },
    { "NtCompressKey",          APICAT_REGISTRY, 0 },
    { "NtRestoreKey",           APICAT_REGISTRY, 0 },
    { "NtSaveKey",              APICAT_REGISTRY, 0 },
    { "NtSaveKeyEx",            APICAT_REGISTRY, 0 },
    { "NtSaveMergedKeys",       APICAT_REGISTRY, 0 },
    { "NtSetValueKey",          APICAT_REGISTRY, 0 },
    { "NtUnloadKey",            APICAT_REGISTRY, 0 },
    { "NtUnloadKeyEx",          APICAT_REGISTRY, 0 },
    { "NtSetInformationKey",    APICAT_REGISTRY, 0 },
    { "NtQueryOpenSubKeys",     APICAT_REGISTRY, 0 },
    { "NtLockRegistryKey",      APICAT_REGISTRY, 0 },
    { "NtLockProductActivationKeys",    APICAT_REGISTRY, 0 },
    
    // NT Security APIs (ntseapi.h)
    { "NtAccessCheck",          APICAT_SECURITY, 0 },
    { "NtAccessCheckByType",    APICAT_SECURITY, 0 },
    { "NtAccessCheckByTypeResultList",  APICAT_SECURITY, 0 },
    { "NtCreateToken",          APICAT_SECURITY, 0 },
    { "NtCompareTokens",        APICAT_SECURITY, 0 },
    { "NtOpenThreadToken",      APICAT_SECURITY, 0 },
    { "NtOpenThreadTokenEx",    APICAT_SECURITY, 0 },
    { "NtOpenProcessToken",     APICAT_SECURITY, 0 },
    { "NtOpenProcessTokenEx",   APICAT_SECURITY, 0 },
    { "NtOpenJobObjectToken",   APICAT_SECURITY, 0 },
    { "NtDuplicateToken",       APICAT_SECURITY, 0 },
    { "NtFilterToken",          APICAT_SECURITY, 0 },
    { "NtImpersonateAnonymousToken",    APICAT_SECURITY, 0 },
    { "NtQueryInformationToken",        APICAT_SECURITY, 0 },
    { "NtSetInformationToken",  APICAT_SECURITY, 0 },
    { "NtAdjustPrivilegesToken",        APICAT_SECURITY, 0 },
    { "NtAdjustGroupsToken",    APICAT_SECURITY, 0 },
    { "NtPrivilegeCheck",       APICAT_SECURITY, 0 },
    { "NtAccessCheckAndAuditAlarm",     APICAT_SECURITY, 0 },
    { "NtAccessCheckByTypeAndAuditAlarm",           APICAT_SECURITY, 0 },
    { "NtAccessCheckByTypeResultListAndAuditAlarm", APICAT_SECURITY, 0 },
    { "NtAccessCheckByTypeResultListAndAuditAlarmByHandle", APICAT_SECURITY, 0 },
    { "NtOpenObjectAuditAlarm", APICAT_SECURITY, 0 },
    { "NtPrivilegeObjectAuditAlarm",    APICAT_SECURITY, 0 },
    { "NtCloseObjectAuditAlarm",        APICAT_SECURITY, 0 },
    { "NtDeleteObjectAuditAlarm",       APICAT_SECURITY, 0 },
    { "NtPrivilegedServiceAuditAlarm",  APICAT_SECURITY, 0 },
    
    // NT Exception APIs (ntxcapi.h)
    { "NtContinue",             APICAT_XCEPT, 0 },
    { "NtRaiseException",       APICAT_XCEPT, 0 },

    // NT WOW64 CSR APIs
    { "NtWow64CsrClientConnectToServer",            APICAT_NTWOW64, 0 },
    { "NtWow64CsrNewThread",    APICAT_NTWOW64, 0 },
    { "NtWow64CsrIdentifyAlertableThread",          APICAT_NTWOW64, 0 },
    { "NtWow64CsrClientCallServer",     APICAT_NTWOW64, 0 },
    { "NtWow64CsrAllocateCaptureBuffer",            APICAT_NTWOW64, 0 },
    { "NtWow64CsrFreeCaptureBuffer",    APICAT_NTWOW64, 0 },
    { "NtWow64CsrAllocateMessagePointer",           APICAT_NTWOW64, 0 },
    { "NtWow64CsrCaptureMessageBuffer", APICAT_NTWOW64, 0 },
    { "NtWow64CsrCaptureMessageString", APICAT_NTWOW64, 0 },
    { "NtWow64CsrSetPriorityClass",     APICAT_NTWOW64, 0 },
    { "NtWow64CsrGetProcessId", APICAT_NTWOW64, 0 },
    { "NtWow64DebuggerCall",    APICAT_NTWOW64, 0 },

    // BASE WOW64 CSR APIs
    { "NtWow64CsrBasepSoundSentryNotification",     APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepRefreshIniFileMapping",       APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepDefineDosDevice", APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepGetTempFile",     APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepCreateProcess",   APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepExitProcess",     APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepSetProcessShutdownParam",     APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepGetProcessShutdownParam",     APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepSetTermsrvAppInstallMode",    APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepSetClientTimeZoneInformation",    APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepCreateThread",    APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBaseClientConnectToServer",        APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepNlsSetUserInfo",  APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepNlsSetMultipleUserInfo",      APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepNlsCreateSection",            APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepCreateActCtx",    APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepNlsUpdateCacheCount",         APICAT_BASEWOW64, 0 },
    { "NtWow64CsrBasepNlsGetUserInfo",  APICAT_BASEWOW64, 0 },
    
    // null terminating entry
    { NULL, 0, 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\regremap.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    regredir.h

Abstract:

    This module define the APis to redirect 32bit registry calls. All 32bit wow process must 
    use following set of wowregistry APIs to manipulate registry so that 32-bit and 64-bit registry 
    can co exist in the same system registry.

Author:

    ATM Shafiqul Khalid (askhalid) 15-Oct-1999

Revision History:

--*/

#ifndef _REGREDIR_H_
#define _REGREDIR_H_

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef CCHAR KPROCESSOR_MODE;

//
// Nt level registry API calls
//

#define REG_OPAQUE_ATTRIB_MIRROR 0x00000001    // need to see the 64 bit side
#define REG_OPAQUE_ATTRIB_REAL   0x00000002    // this is real value
#define DONT_CREATE_DEST_KEY     0x00000004    // Suync only if destination key exist
#define SKIP_SPECIAL_CASE        0x00000008    // Skip special case

#define MAX_KEY_BUFF_LEN STATIC_UNICODE_BUFFER_LENGTH*4

 
 

typedef struct {
    DWORD dwSignature;
    DWORD dwAttribute;
} REG_OPAQUE_VALUE;

typedef struct {
    POBJECT_ATTRIBUTES  pObjectAddress;  // pointer to the object that that has been patched using this one
    PUNICODE_STRING     p64bitName;      // pointer to the correct unicode object name
    HANDLE              RootDirectory;   // handle to the root directory in case different handle need to pass
    UNICODE_STRING      PatchedName;      // pointer to the buffer holding patched name
    PVOID               pThis;           // pointer to this object to avoid multiple free
    SIZE_T              Len;           // Length of this memory segment including buffer at the end;
} PATCHED_OBJECT_ATTRIB, *PPATCHED_OBJECT_ATTRIB;

BOOL
IsUnderWow64 ();

BOOL
UpdateKeyTag (
    HKEY hBase,
    DWORD dwAttribute
    );

NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSTATUS
Wow64NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSTATUS
Wow64NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSTATUS
Wow64NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtFlushKey(
    IN HANDLE KeyHandle
    );

NTSTATUS
Wow64NtInitializeRegistry(
    IN USHORT BootCondition
    );

NTSTATUS
Wow64NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );

NTSTATUS
Wow64NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,          
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    );

NTSTATUS
Wow64NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    );

NTSTATUS
Wow64NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    );

NTSTATUS
Wow64NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
Wow64NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSTATUS
Wow64NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    );

NTSTATUS
Wow64NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    );

NTSTATUS
Wow64NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG  Flags
    );

NTSTATUS
Wow64NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    );

NTSTATUS
Wow64NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    );

NTSTATUS
Wow64NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
Wow64NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    );

NTSTATUS
Wow64NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    );

NTSTATUS 
Wow64NtClose(
    IN HANDLE Handle
    );

VOID
DisplayCallParam ( 
    char *strCallLoc, 
    POBJECT_ATTRIBUTES ObjectAttributes 
    );

NTSTATUS
Wow64NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    );

 

BOOL
IsIsnNode (
   PWCHAR wStr,
   PWCHAR *pwStrIsn
   );

NTSTATUS
CreatePathFromInsNode(
   PWCHAR wStr,
   PWCHAR wStrIsn
   );

 

NTSTATUS
OpenIsnNodeByObjectAttributes  (
    POBJECT_ATTRIBUTES ObjectAttributes,
    ACCESS_MASK DesiredAccess,
    PHANDLE phPatchedHandle
    );

int  
Regwcsnicmp(
    const WCHAR * first, 
    const WCHAR * last, 
    size_t count
    );

BOOL
SyncRegCreateKey (
    HANDLE hBase,
    PWCHAR AbsPath, 
    DWORD Flag
    );

BOOL
NtSyncNode (
    HANDLE hBase,
    PWCHAR AbsPath,
    BOOL bForceSync
    );
BOOL
IsOnReflectionList (
    PWCHAR Path
    );
BOOL
NtSyncNodeOpenCreate (
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );
NTSTATUS 
ObjectAttributesToKeyName (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PWCHAR AbsPath,
    DWORD  AbsPathLenIn,
    BOOL *bPatched,
    DWORD *ParentLen
    );

NTSTATUS
Wow64NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

void
CleanupReflector (
    DWORD dwFlag
    );

PWCHAR
wcsistr(
    PWCHAR string1,
    PWCHAR string2
    );

BOOL
Wow64RegIsPossibleShim (
    HANDLE hKey
    );

BOOL 
TagKeyHandleSpecial (
    HANDLE KeyHandle
    );

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // _REGREDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\wow64.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64.h

Abstract:

    Public header for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:
    9-Aug-1999 [askhalid] added WOW64IsCurrentProcess

--*/

#ifndef _WOW64_INCLUDE
#define _WOW64_INCLUDE

//
// Make wow64.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64DLLAPI_)
#define WOW64DLLAPI DECLSPEC_IMPORT
#else
#define WOW64DLLAPI
#endif

// crank down some warnings
#pragma warning(4:4312)   // conversion to type of greater size


// pull in typedefs for TEB32, PEB32, etc.
#include "wow64t.h"

#include <setjmp.h>
#include <windef.h>

// wow64log constatns
#include "wow64log.h"

//wow64 regremaping
#include "regremap.h"

//
// Enable the wow64 history mechanism
// Eventually, this may only be enabled for debug builds, but for
// now, enable all the time
//
#define WOW64_HISTORY

//
// define a datatype corresponding to the 32-bit machine's CONTEXT
//
#include "wx86nt.h"
#define CONTEXT32 CONTEXT_WX86
#define PCONTEXT32 PCONTEXT_WX86
#define CONTEXT32_CONTROL CONTEXT_CONTROL_WX86
#define CONTEXT32_INTEGER CONTEXT_INTEGER_WX86
#define CONTEXT32_SEGMENTS CONTEXT_SEGMENTS_WX86
#define CONTEXT32_FLOATING_POINT CONTEXT_FLOATING_POINT_WX86
#define CONTEXT32_EXTENDED_REGISTERS CONTEXT_EXTENDED_REGISTERS_WX86
#define CONTEXT32_DEBUG_REGISTERS CONTEXT_DEBUG_REGISTERS_WX86
#define CONTEXT32_FULL CONTEXT_FULL_WX86
#define CONTEXT32_FULLFLOAT (CONTEXT_FULL_WX86|CONTEXT32_FLOATING_POINT|CONTEXT32_EXTENDED_REGISTERS)

#if defined(_AXP64_)
// Enable 4k page emulation in software.  IA64 does it in h/w with OS support.
#define SOFTWARE_4K_PAGESIZE 1
#endif

typedef enum _WOW64_API_ERROR_ACTION {
    ApiErrorNTSTATUS,           //Return exception code as return value
    ApiErrorNTSTATUSTebCode,    //Some as above with SetLastError on exception code
    ApiErrorRetval,             //Return a constant parameter
    ApiErrorRetvalTebCode       //Some as above with SetLastError on exception code
} WOW64_API_ERROR_ACTION, *PWOW64_API_ERROR_ACTION;

// This structure describes what action should occure when thunks hit an unhandled exception.
typedef struct _WOW64_SERVICE_ERROR_CASE {
    WOW64_API_ERROR_ACTION ErrorAction;
    LONG ErrorActionParam;
} WOW64_SERVICE_ERROR_CASE, *PWOW64_SERVICE_ERROR_CASE;

// This is an extension of KSERVICE_TABLE_DESCRIPTOR
typedef struct _WOW64SERVICE_TABLE_DESCRIPTOR {
    PULONG_PTR Base;
    PULONG Count;
    ULONG Limit;
#if defined(_IA64_)
    LONG TableBaseGpOffset;
#endif
    PUCHAR Number;
    WOW64_API_ERROR_ACTION DefaultErrorAction;  //Action if ErrorCases is NULL.
    LONG DefaultErrorActionParam;               //Action parameter if ErrorCases is NULL.
    PWOW64_SERVICE_ERROR_CASE ErrorCases;
} WOW64SERVICE_TABLE_DESCRIPTOR, *PWOW64SERVICE_TABLE_DESCRIPTOR;

// Used to log hit counts for APIs.
typedef struct _WOW64SERVICE_PROFILE_TABLE WOW64SERVICE_PROFILE_TABLE;
typedef struct _WOW64SERVICE_PROFILE_TABLE *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64SERVICE_PROFILE_TABLE_ELEMENT {
    PWSTR ApiName;
    SIZE_T HitCount;
    PWOW64SERVICE_PROFILE_TABLE SubTable;
    BOOLEAN ApiEnabled;
} WOW64SERVICE_PROFILE_TABLE_ELEMENT, *PWOW64SERVICE_PROFILE_TABLE_ELEMENT;

typedef struct _WOW64SERVICE_PROFILE_TABLE {
    PWSTR TableName;           //OPTIONAL
    PWSTR FriendlyTableName;   //OPTIONAL
    CONST PWOW64SERVICE_PROFILE_TABLE_ELEMENT ProfileTableElements;
    SIZE_T NumberProfileTableElements;
} WOW64SERVICE_PROFILE_TABLE, *PWOW64SERVICE_PROFILE_TABLE;

typedef struct _WOW64_SYSTEM_INFORMATION {
  SYSTEM_BASIC_INFORMATION BasicInfo;
  SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;
  ULONG_PTR RangeInfo;
} WOW64_SYSTEM_INFORMATION, *PWOW64_SYSTEM_INFORMATION;

//
// Indices for API thunks.
//
#define WHNT32_INDEX        0   // ntoskrnl
#define WHCON_INDEX         1   // console (replaces LPC calls)
#define WHWIN32_INDEX       2   // win32k
#define WHBASE_INDEX        3   // base/nls (replaces LPC calls)
#define MAX_TABLE_INDEX     4


//
// Logging mechanism.  Usage:
//  LOGPRINT((verbosity, format, ...))
//
#define LOGPRINT(args)  Wow64LogPrint args
#define ERRORLOG    LF_ERROR    // Always output to debugger.  Use for *unexpected*
                                // errors only
#define TRACELOG    LF_TRACE    // application trace information
#define INFOLOG     LF_TRACE    // misc. informational log
#define VERBOSELOG  LF_NONE     // practically never output to debugger

#if DBG
#define WOW64DOPROFILE
#endif

void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   );



//
// WOW64 Assertion Mechanism.  Usage:
//  - put an ASSERTNAME macro at the top of each .C file
//  - WOW64ASSERT(expression)
//  - WOW64ASSERTMSG(expression, message)
//
//

VOID
WOW64DLLAPI
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG LINE
    );

#if DBG

#undef ASSERTNAME
#define ASSERTNAME static CONST PSZ szModule = __FILE__;

#define WOWASSERT(exp)                                  \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, NULL, szModule, __LINE__);   \
    }

#define WOWASSERTMSG(exp, msg)                          \
    if (!(exp)) {                                          \
        Wow64Assert( #exp, msg, szModule, __LINE__);    \
    }

#else   // !DBG

#define WOWASSERT(exp)
#define WOWASSERTMSG(exp, msg)

#endif  // !DBG

#define WOWASSERT_PTR32(ptr) WOWASSERT((ULONGLONG)ptr < 0xFFFFFFFF)

WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    );

WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    );


//
// 64-to-32 callback support for usermode APCs
//

// A list of these sits inside WOW64_TLS_APCLIST
typedef struct tagUserApcList {
    struct tagUserApcList *Next;
    jmp_buf     JumpBuffer;
    PCONTEXT32  pContext32;
} USER_APC_ENTRY, *PUSER_APC_ENTRY;

BOOL
WOW64DLLAPI
WOW64IsCurrentProcess (
    HANDLE hProcess
    );

NTSTATUS
Wow64WrapApcProc(
    IN OUT PVOID *pApcProc,
    IN OUT PVOID *pApcContext
    );


typedef struct UserCallbackData {
    jmp_buf JumpBuffer;
    PVOID   PreviousUserCallbackData;
    PVOID   OutputBuffer;
    ULONG   OutputLength;
    NTSTATUS Status;
    PVOID   UserBuffer;
} USERCALLBACKDATA, *PUSERCALLBACKDATA;

ULONG
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    );

NTSTATUS
Wow64NtCallbackReturn(
    PVOID OutputBuffer,
    ULONG OutputLength,
    NTSTATUS Status
    );

NTSTATUS
Wow64SkipOverBreakPoint(
    IN PCLIENT_ID ClientId,
    IN PEXCEPTION_RECORD ExceptionRecord);

NTSTATUS
Wow64GetThreadSelectorEntry(
    IN HANDLE ThreadHandle,
    IN OUT PVOID DescriptorTableEntry,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL);

//
// Thread Local Storage (TLS) support.  TLS slots are statically allocated.
//
#define WOW64_TLS_STACKPTR64        0   // contains 64-bit stack ptr when simulating 32-bit code
#define WOW64_TLS_CPURESERVED       1   // per-thread data for the CPU simulator
#define WOW64_TLS_INCPUSIMULATION   2   // Set when inside the CPU
#define WOW64_TLS_TEMPLIST          3   // List of memory allocated in thunk call.
#define WOW64_TLS_EXCEPTIONADDR     4   // 32-bit exception address (used during exception unwinds)
#define WOW64_TLS_USERCALLBACKDATA  5   // Used by win32k callbacks
#define WOW64_TLS_EXTENDED_FLOAT    6   // Used in ia64 to pass in floating point
#define WOW64_TLS_APCLIST	        7	// List of outstanding usermode APCs
#define WOW64_TLS_FILESYSREDIR	    8	// Used to enable/disable the filesystem redirector
#define WOW64_TLS_LASTWOWCALL	    9	// Pointer to the last wow call struct (Used when wowhistory is enabled)
#define WOW64_TLS_WOW64INFO        10   // Wow64Info address (structure shared between 32-bit and 64-bit code inside Wow64).
#define WOW64_TLS_INITIAL_TEB32    11   // A pointer to the 32-bit initial TEB

// VOID Wow64TlsSetValue(DWORD dwIndex, LPVOID lpTlsValue);
#define Wow64TlsSetValue(dwIndex, lpTlsValue)   \
    NtCurrentTeb()->TlsSlots[dwIndex] = lpTlsValue;

// LPVOID Wow64TlsGetValue(DWORD dwIndex);
#define Wow64TlsGetValue(dwIndex)               \
    (NtCurrentTeb()->TlsSlots[dwIndex])

//
// 32-to-64 thunk routine
//
LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32
    );

//
// Wow64RaiseException
//
WOW64DLLAPI
NTSTATUS
Wow64RaiseException(
    IN DWORD InterruptNumber,
    IN OUT PEXCEPTION_RECORD ExceptionRecord);


//
// Helper routines, called from the thunks
//

#define CHILD_PROCESS_SIGNATURE     0xff00ff0011001100
typedef struct _ChildProcessInfo {
    ULONG_PTR   Signature;
    PPEB32      pPeb32;
    SECTION_IMAGE_INFORMATION ImageInformation;
    ULONG_PTR   TailSignature;
} CHILD_PROCESS_INFO, *PCHILD_PROCESS_INFO;

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    );

NTSTATUS
WOW64DLLAPI
Wow64QueryBasicInformationThread(
    IN HANDLE Thread,
    OUT PTHREAD_BASIC_INFORMATION ThreadInfo
    );

WOW64DLLAPI
NTSTATUS
Wow64NtCreateThread(
   OUT PHANDLE ThreadHandle,
   IN ACCESS_MASK DesiredAccess,
   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
   IN HANDLE ProcessHandle,
   OUT PCLIENT_ID ClientId,
   IN PCONTEXT ThreadContext,
   IN PINITIAL_TEB InitialTeb,
   IN BOOLEAN CreateSuspended
   );

WOW64DLLAPI
NTSTATUS
Wow64NtTerminateThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    );

VOID
Wow64BaseFreeStackAndTerminate(
    IN PVOID OldStack,
    IN ULONG ExitCode
    );

VOID
Wow64BaseSwitchStackThenTerminate (
    IN PVOID StackLimit,
    IN PVOID NewStack,
    IN ULONG ExitCode
    );

NTSTATUS
Wow64NtContinue(
    IN PCONTEXT ContextRecord,  // really a PCONTEXT32
    IN BOOLEAN TestAlert
    );

NTSTATUS
WOW64DLLAPI
Wow64SuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    );

NTSTATUS
WOW64DLLAPI
Wow64GetContextThread(
     IN HANDLE ThreadHandle,
     IN OUT PCONTEXT ThreadContext // really a PCONTEXT32
     );

NTSTATUS
WOW64DLLAPI
Wow64SetContextThread(
     IN HANDLE ThreadHandle,
     IN PCONTEXT ThreadContext // really a PCONTEXT32
     );

NTSTATUS
Wow64KiRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

ULONG
Wow64SetupApcCall(
    IN ULONG NormalRoutine,
    IN PCONTEXT32 NormalContext,
    IN ULONG Arg1,
    IN ULONG Arg2
    );

VOID
ThunkExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   pRecord64,
    OUT PEXCEPTION_RECORD32 pRecord32
    );

BOOLEAN
Wow64NotifyDebugger(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    );

VOID
Wow64SetupExceptionDispatch(
    IN PEXCEPTION_RECORD32 pRecord32,
    IN PCONTEXT32 pContext32
    );

VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    );

NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    );

PWOW64_SYSTEM_INFORMATION
Wow64GetEmulatedSystemInformation(
    VOID
    );

PWOW64_SYSTEM_INFORMATION
Wow64GetRealSystemInformation(
     VOID
     );

VOID
Wow64Shutdown(
     HANDLE ProcessHandle
     );

NTSTATUS
Wow64NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );
NTSTATUS
Wow64NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

BOOL
InitWow64Shim ( );

BOOL
CloseWow64Shim ( );

// Defines the argsize of the emulated machine
#define ARGSIZE 4

VOID
ThunkPeb64ToPeb32(
    IN PPEB Peb64,
    OUT PPEB32 Peb32
    );


extern RTL_CRITICAL_SECTION HandleDataCriticalSection;

#endif  // _WOW64_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\wow64cpu.h ===
/*++
                                                                                
Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64cpu.h

Abstract:
    
    Public header for wow64.dll
    
Author:

    24-May-1998 BarryBo

Revision History:
    8-9-99 [askhalid] added CpuNotifyDllLoad and CpuNotifyDllUnload.

--*/

#ifndef _WOW64CPU_INCLUDE
#define _WOW64CPU_INCLUDE

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Make wow64cpu.dll exports __declspec(dllimport) when this header is included
// by non-wow64cpu components
//
#if !defined(_WOW64CPUAPI_)
#define WOW64CPUAPI DECLSPEC_IMPORT
#else
#define WOW64CPUAPI
#endif

#if !defined(_WOW64CPUDBGAPI_)
#define WOW64CPUDBGAPI DECLSPEC_IMPORT
#else
#define WOW64CPUDBGAPI
#endif


typedef enum {
    WOW64_FLUSH_FORCE,
    WOW64_FLUSH_FREE,
    WOW64_FLUSH_ALLOC,
    WOW64_FLUSH_PROTECT
} WOW64_FLUSH_REASON;

//
// Cache manipulation functions and Dll notification
//
WOW64CPUAPI VOID CpuFlushInstructionCache ( HANDLE ProcessHandle, PVOID BaseAddress, ULONG Length, WOW64_FLUSH_REASON Reason);
WOW64CPUAPI VOID CpuNotifyDllLoad ( LPWSTR DllName, PVOID DllBase, ULONG DllSize );
WOW64CPUAPI VOID CpuNotifyDllUnload ( PVOID DllBase  );


//
// Init and term APIs
//
WOW64CPUAPI NTSTATUS CpuProcessInit(PWSTR pImageName, PSIZE_T pCpuThreadDataSize);
WOW64CPUAPI NTSTATUS CpuProcessTerm(HANDLE ProcessHandle);
WOW64CPUAPI NTSTATUS CpuThreadInit(PVOID pPerThreadData);
WOW64CPUAPI NTSTATUS CpuThreadTerm(VOID);


 

//
// Execution
//
WOW64CPUAPI VOID CpuSimulate(VOID);

//
// Exception handling, context manipulation
//
WOW64CPUAPI VOID  CpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers);
WOW64CPUAPI ULONG CpuGetStackPointer(VOID);
WOW64CPUAPI VOID  CpuSetStackPointer(ULONG Value);
WOW64CPUAPI VOID  CpuSetInstructionPointer(ULONG Value);
WOW64CPUAPI VOID  CpuResetFloatingPoint(VOID);

WOW64CPUAPI
NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL);

WOW64CPUAPI
NTSTATUS
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context);

WOW64CPUAPI
NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context);

WOW64CPUAPI
BOOLEAN
CpuProcessDebugEvent(
    IN LPDEBUG_EVENT DebugEvent);


#if defined(DECLARE_CPU_DEBUGGER_INTERFACE)
//
// APIs required to be exported from a CPU debugger extension DLL.  The
// extension DLL may also export other NTSD extension exports which
// may be called directly from NTSD.  The APIs below are called from
// wow64exts.dll as worker routines to help the common debugging code.
//
// The CPU extension DLL must be named w64cpuex.dll.
//
typedef PVOID (*PWOW64GETCPUDATA)(HANDLE hProcess, HANDLE hThread);

WOW64CPUDBGAPI VOID CpuDbgInitEngapi(PWOW64GETCPUDATA lpGetCpuData);
WOW64CPUDBGAPI BOOL CpuDbgGetRemoteContext(PDEBUG_CLIENT Client, PVOID CpuData);
WOW64CPUDBGAPI BOOL CpuDbgSetRemoteContext(PDEBUG_CLIENT Client);   // push local context back remote
WOW64CPUDBGAPI BOOL CpuDbgGetLocalContext(PDEBUG_CLIENT Client, PCONTEXT32 Context);  // fetch context from the cache
WOW64CPUDBGAPI BOOL CpuDbgSetLocalContext(PDEBUG_CLIENT Client, PCONTEXT32 Context);  // push context to the cache
WOW64CPUDBGAPI VOID CpuDbgFlushInstructionCache(PDEBUG_CLIENT Client, PVOID Addr, DWORD Length);
WOW64CPUDBGAPI VOID CpuDbgFlushInstructionCacheWithHandle(HANDLE Process,PVOID Addr,DWORD Length);

typedef struct tagCpuRegFuncs {
    LPCSTR RegName;
    void (*SetReg)(ULONG);
    ULONG (*GetReg)(VOID);
} CPUREGFUNCS, *PCPUREGFUNCS;

WOW64CPUDBGAPI PCPUREGFUNCS CpuDbgGetRegisterFuncs(void);
#endif  // DECLARE_CPU_DEBUGGER_INTERFACE

#if defined(WOW64_HISTORY)

//
// The service history is enabled via a key in the registry.
//
// The key is in HKLM, and there are subkeys for enabling (1)
//
// No subkey area and/or no enable key means don't use the binary translator.
//
// Individual apps can be listed here with a DWORD subkey. A
// value of 1 says use history, and a value of 0 says don't. No value says
// use the global enable/disable to decide
//
//
//

#define CPUHISTORY_SUBKEY       L"Software\\Microsoft\\Wow64\\ServiceHistory"
#define CPUHISTORY_MACHINE_SUBKEY L"\\Registry\\Machine\\Software\\Microsoft\\Wow64\\ServiceHistory"
#define CPUHISTORY_ENABLE       L"Enable"
#define CPUHISTORY_SIZE         L"Size"
#define CPUHISTORY_MIN_SIZE     5

//
// Args are spelled out this way so the dt command in the debugger will show
// all args
//

typedef struct _Wow64Service_Buf {
    DWORD Api;
    DWORD RetAddr;
    DWORD Arg0;
    DWORD Arg1;
    DWORD Arg2;
    DWORD Arg3;
} WOW64SERVICE_BUF, *PWOW64SERVICE_BUF;

extern ULONG HistoryLength;

#endif

#ifdef __cplusplus
}
#endif

#endif  //_WOW64CPU_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\wow64warn.h ===
/*++
                                                                                
Copyright (c) 1998 Microsoft Corporation

Module Name:

    wow64warn.h

Abstract:
    
    Global warning flags for wow64 project.
    
Author:

    5-Jan-1999 mzoran

Revision History:

--*/

// Make the compiler more struct.
#pragma warning(1:4033)   // function must return a value
#pragma warning(1:4035)   // no return value
// #pragma warning(1:4701)   // local may be used w/o init
#pragma warning(1:4702)   // Unreachable code
#pragma warning(1:4705)   // Statement has no effect
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\wow64log.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wow64.h

Abstract:

    Public header for wow64log.dll

Author:

    3-Oct-1999   SamerA

Revision History:

--*/

#ifndef _WOW64LOG_INCLUDE
#define _WOW64LOG_INCLUDE

//
// Make wow64log.dll exports __declspec(dllimport) when this header is included
// by non-wow64 components
//
#if !defined(_WOW64LOGAPI_)
#define WOW64LOGAPI DECLSPEC_IMPORT
#else
#define WOW64LOGAPI
#endif


#define WOW64LOGOUTPUT(_x_)     Wow64LogMessage _x_


//
// Log flags
//
#define LF_NONE                0x00000000
#define LF_ERROR               0x00000001
#define LF_TRACE               0x00000002
#define LF_NTBASE_NAME         0x00000004
#define LF_NTBASE_FULL         0x00000008
#define LF_WIN32_NAME          0x00000010
#define LF_WIN32_FULL          0x00000020
#define LF_NTCON_NAME          0x00000040
#define LF_NTCON_FULL          0x00000080
#define LF_BASE_NAME           0x00000100
#define LF_BASE_FULL           0x00000200
#define LF_CATLOG              0x20000000
#define LF_EXCEPTION           0x40000000
#define LF_CONSOLE             0x80000000

#define LF_NTBASE_ENABLED(x)   ((x) & (LF_NTBASE_NAME | LF_NTBASE_FULL))
#define LF_WIN32_ENABLED(x)    ((x) & (LF_WIN32_NAME | LF_WIN32_FULL))
#define LF_NTCON_ENABLED(x)    ((x) & (LF_NTCON_NAME | LF_NTCON_FULL))
#define LF_BASE_ENABLED(x)     ((x) & (LF_BASE_NAME | LF_BASE_FULL))
#define LF_CATLOG_ENABLED(x)   ((x) & (LF_CATLOG))


//
// Log a thunked API
//
typedef struct _THUNK_LOG_CONTEXT
{
    PULONG Stack32;
    UINT_PTR TableNumber;
    UINT_PTR ServiceNumber;
    BOOLEAN ServiceReturn;
    ULONG_PTR ReturnResult;
} THUNK_LOG_CONTEXT, *PTHUNK_LOG_CONTEXT;




WOW64LOGAPI
NTSTATUS
Wow64LogInitialize (
    VOID
    );

WOW64LOGAPI
NTSTATUS
Wow64LogSystemService(
    IN PTHUNK_LOG_CONTEXT LogContext);

WOW64LOGAPI
NTSTATUS
Wow64LogMessage(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...);

WOW64LOGAPI
NTSTATUS
Wow64LogMessageArgList(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN va_list ArgList);


WOW64LOGAPI
NTSTATUS
Wow64LogTerminate(
    VOID);

typedef NTSTATUS (*PFNWOW64LOGINITIALIZE)(VOID);
typedef NTSTATUS (*PFNWOW64LOGSYSTEMSERVICE)(IN PTHUNK_LOG_CONTEXT LogContext);
typedef NTSTATUS (*PFNWOW64LOGMESSAGEARGLIST)(IN UINT_PTR Flags,
                                              IN PSZ Format,
                                              IN va_list ArgList);
typedef NTSTATUS (*PFNWOW64LOGTERMINATE)(VOID);


#endif // _WOW64LOG_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\inc\wx86nt.h ===
/*++ BUILD Version: 0002     Increment this if a change has global effects


Module Name:

    wx86nt.h

Abstract:

    defines Nt i386 specific data structures (from nti386)


Revision History:

--*/

#ifndef _WX86NT_
#define _WX86NT_

// Size of Global Descriptor Table
#define  GDT_SIZE  4096    // big enough...
#define  IDT_SIZE  (8*256)

//
// Rename some of the platform dependent datatypes,
// so that we can access the i386 form on risc.
//
#ifndef _X86_
#define _X86_
#endif

#ifndef _FLOATING_SAVE_AREA
#define _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA_WX86
#define FLOATING_SAVE_AREA FLOATING_SAVE_AREA_WX86
#define PFLOATING_SAVE_AREA PFLOATING_SAVE_AREA_WX86
#endif

#define _CONTEXT _CONTEXT_WX86
#define CONTEXT CONTEXT_WX86
#define PCONTEXT PCONTEXT_WX86
#define FXSAVE_FORMAT FXSAVE_FORMAT_WX86
#define PFXSAVE_FORMAT PFXSAVE_FORMAT_WX86


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif



//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

//
// The following flags control the contents of the CONTEXT structure.
//

#if !defined(RC_INVOKED)

#define CONTEXT_i386    0x00010000    // this assumes that i386 and
#define CONTEXT_i486    0x00010000    // i486 have identical context records


#endif

#define MAXIMUM_SUPPORTED_EXTENSION     512

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;



typedef CONTEXT *PCONTEXT;

// begin_ntminiport

#endif //_X86_

//
// Define the size of FP registers in the FXSAVE format
//
#define SIZE_OF_FX_REGISTERS        128

//
// Format of data for fxsave/fxrstor instruction
//

#include "pshpack1.h"

#ifndef WOW64EXTS_386

#ifndef _NTDBG_
typedef struct _FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
    UCHAR   Align16Byte[8];
} FXSAVE_FORMAT, *PFXSAVE_FORMAT;
#endif

#endif 

#include "poppack.h"

#define KGDT_R0_DATA    16
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_TSS        40
#define KGDT_R0_PCR     48
#define KGDT_R3_TEB     56
#define KGDT_VDM_TILE   64
#define KGDT_LDT        72
#define KGDT_DF_TSS     80
#define KGDT_NMI_TSS    88


//
// Stop the renaming so that the risc datatypes
// are accessible by their normal names
//
#undef _FLOATING_SAVE_AREA
#undef FLOATING_SAVE_AREA
#undef PFLOATING_SAVE_AREA
#undef _CONTEXT
#undef CONTEXT
#undef PCONTEXT
#undef FXSAVE_FORMAT
#undef PFXSAVE_FORMAT


//
// set up the i386 CONTEXT bits for the ContextFlags
// warning: this MUST match nti386.h
//
#define CONTEXT_CONTROL_WX86             (CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER_WX86             (CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS_WX86            (CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT_WX86      (CONTEXT_i386 | 0x00000008L) // 387 state
#define CONTEXT_DEBUG_REGISTERS_WX86     (CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS_WX86  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions
#define CONTEXT_FULL_WX86                (CONTEXT_CONTROL_WX86 | CONTEXT_INTEGER_WX86 | CONTEXT_SEGMENTS_WX86)
#undef _X86_

#endif /* _WX86NT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\compilep.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    compilep.h

Abstract:

    This module is the private include file for the compiler.

Author:

    Dave Hastings (daveh) creation-date 09-Jul-1994

Revision History:


--*/

PENTRYPOINT
Compile(
    PENTRYPOINT ContainingEntrypoint,
    PVOID Eip
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\analysis\analysis.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    analysis.c

Abstract:

    This module contains the main file of the analysis
    module.

Author:

    Ori Gershony (t-orig) creation-date 6-July-1995

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <threadst.h>
#include <instr.h>
#include <analysis.h>
#include <decoder.h>
#include <frag.h>
#include <config.h>
#include <compiler.h>

ASSERTNAME;

 

//
// Macro to determine when to stop looking ahead during compilation.
//
#define STOP_DECODING(inst)     (Fragments[inst.Operation].Flags & OPFL_STOP_COMPILE)

//
// Map a REG_ constant (offset into cpu struct) into register bit map
// used by instruction data.
//
const DWORD MapRegNumToRegBits[0x1e] =
    {REGEAX, REGECX, REGEDX, REGEBX, REGESP, REGEBP, REGESI, REGEDI,
     0, 0, 0, 0, 0, 0,
     REGAX, REGCX, REGDX, REGBX, REGSP, REGBP, REGSI, REGDI,
     REGAL, REGCL, REGDL, REGBL, REGAH, REGCH, REGDH, REGBH };


ULONG
LocateEntryPoints(
    PINSTRUCTION InstructionStream,
    ULONG NumberOfInstructions
    )
/*++

Routine Description:

    This function scans the InstructionStream and marks instructions
    which begin entrypoint.  An instruction begins an entrypoint if its
    EntryPoint field has a different value than the previous instruction's
    value.  No instruction will have a NULL pointer.

    Note that in this pass, the EntryPoint field does *not* point to an
    ENTRYPOINT structure... it is only a marker.

Arguments:

    IntelStart -- The intel address of the first instruction in the stream

    IntelStart -- The last byte of the last intel instruction in the stream

Return Value:

    Count of EntryPoints located.
    
--*/
{
    ULONG i, j, intelDest;
    ULONG EntryPointCounter;
    ULONG IntelStart;
    ULONG IntelEnd;

    if (CompilerFlags & COMPFL_SLOW) {
        //
        // The compiler is supposed to generate slowmode code.  Each
        // x86 instruction gets its own ENTRYPOINT
        //
        EntryPointCounter=1;
        for (i=0; i<NumberOfInstructions; i++) {
            //
            // Mark all instructions which don't correspond to 0-byte NOPs
            // following optimized instructions as starting EntryPoints.
            //
            if (InstructionStream[i].Size) {
                EntryPointCounter++;
            }
            InstructionStream[i].EntryPoint = (PENTRYPOINT)EntryPointCounter;
        }

    } else {

        //
        // Find all instructions which need Entrypoints.
        //     Performance is O(n^2) in the worst case, although
        //     it will be typically much closer to O(n)
        //
        //  Instructions which mark the starts of Entrypoints have
        //  their .EntryPoint pointer set to non-NULL.  Instructions which
        //  don't require entrypoints have it set to NULL;
        //

        IntelStart = InstructionStream[0].IntelAddress;
        IntelEnd = IntelStart +
                   InstructionStream[NumberOfInstructions-1].IntelAddress +
                   InstructionStream[NumberOfInstructions-1].Size;

        //
        // The first instruction always gets an entrypoint
        //
        InstructionStream[0].EntryPoint = (PENTRYPOINT)1;

        //
        // Visit each instruction in turn
        //
        for (i=0; i<NumberOfInstructions; i++) {

            if (((i+1) < NumberOfInstructions) &&
                (Fragments[InstructionStream[i].Operation].Flags & OPFL_END_NEXT_EP)) {
                //
                // This instruction marks the end of an Entrypoint.  The next
                // instruction gets a new Entrypoint.
                //
                CPUASSERT(i < CpuInstructionLookahead-1 && i < NumberOfInstructions-1);
                InstructionStream[i+1].EntryPoint = (PENTRYPOINT)1;
            }

            // Now see if it is a direct control transfer instruction with a
            // destination that lies within this instruction stream.  If it is,
            // we want to create an Entry Point at the destination so that the
            // control transfer will be compiled directly to the patched form,
            // and won't have to be patched later.
            //
            if (Fragments[InstructionStream[i].Operation].Flags & OPFL_CTRLTRNS) {
                //
                // The instruction is a direct control-transfer.  If the
                // destination is within the InstructionStream, create an
                // Entrypoint at the destination.
                //

                if (InstructionStream[i].Operand1.Type == OPND_IMM ||
                    InstructionStream[i].Operand1.Type == OPND_NOCODEGEN) {
                    // Get the intel destination from the instruction structure.
                    intelDest = InstructionStream[i].Operand1.Immed;
                } else {
                    CPUASSERT(InstructionStream[i].Operand1.Type == OPND_ADDRREF );
                    // A FAR instruction - Operand1 is a ptr to a SEL:OFFSET pair
                    intelDest = *(UNALIGNED PULONG)(InstructionStream[i].Operand1.Immed);
                }

                // Get the intel destination from the instruction structure.
                // It is always an immediate with direct control transfers.
                
                if ((intelDest >= IntelStart) && (intelDest <= IntelEnd)) {
                    //
                    // Destination of the control-transfer is within the
                    // instructionstream.  Find the destination instruction.
                    //
                    if (intelDest > InstructionStream[i].IntelAddress) {
                        //
                        // The dest. address is at a higher address.
                        //
                        for (j=i+1; j<NumberOfInstructions; ++j) {
                            if (InstructionStream[j].IntelAddress == intelDest) {
                                break;
                            }
                        }
                    } else {
                        //
                        // The dest. address is at a lower address.
                        //
                        for (j=i; j>0; --j) {
                            if (InstructionStream[j].IntelAddress == intelDest) {
                                break;
                            }
                        }
                    }

                    //
                    // An exact match may not be found in the event that the
                    // app is punning (either a real pun or the app is jumping
                    // into the middle of an optimized instruction).  In
                    // either of the cases, defer entrypoint creation until
                    // the branch is actually taken.
                    //
                    if (j >= 0 && j < NumberOfInstructions) {
                        //
                        // Exact match was found.  Create an Entrypoint.
                        //
                        InstructionStream[j].EntryPoint = (PENTRYPOINT)1;
                    }
                }
            }  // if OPFL_CTRLTRNS
        } // for ()

        //
        // Convert the EntryPoint field from NULL/non-NULL to a unique
        // value for each range of instructions.
        //
        EntryPointCounter=1;
        i=0;
        while (i<NumberOfInstructions) {
            //
            // This instruction marks the beginning of a basic block
            //
            InstructionStream[i].EntryPoint = (PENTRYPOINT)EntryPointCounter;
            j=i+1;
            while (j < NumberOfInstructions) {
                if ((j >= NumberOfInstructions) ||
                    (InstructionStream[j].Size && InstructionStream[j].EntryPoint)) {
                    //
                    // Either ran out of instructions, or encountered an instruction
                    // which marks the start of the next basic block.  Note that
                    // 0-byte NOP instructions are not allowed to start basic blocks
                    // as that violates the rules of OPT_ instructions.
                    //
                    break;
                }
                InstructionStream[j].EntryPoint = (PENTRYPOINT)EntryPointCounter;
                j++;
            }
            EntryPointCounter++;
            i = j;
        }
    } // if not COMPFL_SLOW

    //
    // At this point, EntryPointCounter holds the number of EntryPoints
    // plus one, because we started the counter at 1, not 0.  Correct
    // that now.
    //
    EntryPointCounter--;

    return EntryPointCounter;
}


VOID
UpdateRegs(
    PINSTRUCTION pInstr,
    POPERAND Operand
    )
/*++
                                                                
Routine Description:

    Updates the list of registers referenced and/or modified based on the
    Operand.

Arguments:

    pInstr -- the instruction to examine

    Operand -- the operand of the instruction to examine

Return Value:

    return-value - none

--*/
{
    switch (Operand->Type) {
    case OPND_NOCODEGEN:
    case OPND_REGREF:
    if (Operand->Reg != NO_REG) {
        pInstr->RegsSet |= MapRegNumToRegBits[Operand->Reg];
    }
        break;

    case OPND_REGVALUE:
    if (Operand->Reg != NO_REG) {
        pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->Reg];
    }
        break;

    case OPND_ADDRREF:
    case OPND_ADDRVALUE8:
    case OPND_ADDRVALUE16:
    case OPND_ADDRVALUE32:
        if (Operand->Reg != NO_REG) {
            pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->Reg];
        }
        if (Operand->IndexReg != NO_REG) {
            pInstr->RegsNeeded |= MapRegNumToRegBits[Operand->IndexReg];
        }
        break;

    default:
        break;
    }
}


VOID
CacheIntelRegs(
    PINSTRUCTION InstructionStream,
    ULONG numInstr)
/*++
                                                                
Routine Description:

    This function deterimes what x86 registers, if any, can be cached in
    RISC preserved registers.

Arguments:

    InstructionStream -- The instruction stream returned by the decoder

    numInstr -- The length of InstructionStream

Return Value:

    return-value - none

--*/
{
    PINSTRUCTION pInstr;
    BYTE RegUsage[REGCOUNT];
    DWORD RegsToCache;
    int i;
    PENTRYPOINT PrevEntryPoint;

    //
    // Calculate the RegsSet and RegsNeeded for the bottommost instruction
    //
    pInstr = &InstructionStream[numInstr-1];
    pInstr->RegsSet = Fragments[pInstr->Operation].RegsSet;
    PrevEntryPoint = pInstr->EntryPoint;
    UpdateRegs(pInstr, &pInstr->Operand1);
    UpdateRegs(pInstr, &pInstr->Operand2);
    UpdateRegs(pInstr, &pInstr->Operand3);

    //
    // For each 32-bit register used as a parameter to this instruction,
    // set the usage count to 1.
    //
    for (i=0; i<REGCOUNT; ++i) {
        if (pInstr->RegsNeeded & (REGMASK<<(REGSHIFT*i))) {
            RegUsage[i] = 1;
        } else {
            RegUsage[i] = 0;
        }
    }

    //
    // Loop over instruction stream from bottom to top, starting at the
    // second-to-last instruction
    //
    for (pInstr--; pInstr >= InstructionStream; pInstr--) {

        //
        // Calculate the RegsSet and RegsNeeded values for this instruction
        //
        pInstr->RegsSet = Fragments[pInstr->Operation].RegsSet;
        UpdateRegs(pInstr, &pInstr->Operand1);
        UpdateRegs(pInstr, &pInstr->Operand2);
        UpdateRegs(pInstr, &pInstr->Operand3);

        RegsToCache = 0;

        if (PrevEntryPoint != pInstr->EntryPoint) {

            //
            // The current instruction marks the end of an Entrypoint.
            //
            PrevEntryPoint = pInstr->EntryPoint;

            //
            // For all x86 registers which have been read more than once
            // but not modified in the basic block, load them into the
            // cache before executing the first instruction in the basic
            // block.
            //
            for (i=0; i<REGCOUNT; ++i) {
                if (RegUsage[i] > 1) {
                    RegsToCache |= (REGMASK<<(REGSHIFT*i));
                }
            }

            //
            // Reset the RegUsage[] array to indicate no registers are
            // cached.
            //
            RtlZeroMemory(RegUsage, REGCOUNT);

        } else {

            //
            // For each 32-bit x86 register modified by this instruction,
            // update the caching info.
            //
            for (i=0; i<REGCOUNT; ++i) {
                DWORD RegBits = pInstr->RegsSet & (REGMASK<<(REGSHIFT*i));
                if (RegBits) {
                    //
                    // The ith 32-bit x86 register has been modified by this
                    // instruction
                    //
                    if (RegUsage[i] > 1) {
                        //
                        // There is more than one consumer of the modified
                        // value so it is worth caching.
                        //
                        RegsToCache |= RegBits;
                    }

                    //
                    // Since this x86 register was dirtied by this instruction,
                    // it usage count must be reset to 0.
                    //
                    RegUsage[i] = 0;
                }
            }
        }

        //
        // Update the list of x86 registers which can be loaded into
        // cache registers before the next instruction executes.
        //
        pInstr[1].RegsToCache |= RegsToCache;

        //
        // For each 32-bit register used as a parameter to this instruction,
        // bump the usage count.
        //
        for (i=0; i<REGCOUNT; ++i) {
            if (pInstr->RegsNeeded & (REGMASK<<(REGSHIFT*i))) {
                RegUsage[i]++;
            }
        }
    }
}


VOID
OptimizeInstructionStream(
    PINSTRUCTION IS,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    This function performs various optimization on the instruction stream
    retured by the decoder.

Arguments:

    IS -- The instruction stream returned by the decoder

    numInstr -- The length of IS

Return Value:

    return-value - none

--*/
{
    ULONG i;

    CPUASSERTMSG(numInstr, "Cannot optimize 0-length instruction stream");

    //
    // Pass 1: Optimize x86 instruction stream, replacing single x86
    //         instructions with special-case instructions, and replacing
    //         multiple x86 instructions with single special-case OPT_
    //         instructions
    //
    for (i=0; i<numInstr; ++i) {

        switch  (IS[i].Operation) {
        case OP_Push32:
            if (i < numInstr-2
                && IS[i].Operand1.Type == OPND_REGVALUE){

                if (IS[i].Operand1.Reg == GP_EBP) {
                    // OP_OPT_SetupStack --
                    //      push ebp
                    //      mov ebp, esp
                    //      sub esp, x
                    if ((IS[i+1].Operation == OP_Mov32) &&
                        (IS[i+1].Operand1.Type == OPND_REGREF) &&
                        (IS[i+1].Operand1.Reg == GP_EBP) &&
                        (IS[i+1].Operand2.Type == OPND_REGVALUE) &&
                        (IS[i+1].Operand2.Reg == GP_ESP) &&
                        (IS[i+2].Operation == OP_Sub32) &&
                        (IS[i+2].Operand1.Type == OPND_REGREF) &&
                        (IS[i+2].Operand1.Reg == GP_ESP) &&
                        (IS[i+2].Operand2.Type == OPND_IMM)){

                        IS[i].Operation = OP_OPT_SetupStack;
                        IS[i].Operand1.Type = OPND_IMM;
                        IS[i].Operand1.Immed = IS[i+2].Operand2.Immed;
                        IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                        IS[i].Operand2.Type = OPND_NONE;
                        IS[i+1].Operation = OP_Nop;
                        IS[i+1].Operand1.Type = OPND_NONE;
                        IS[i+1].Operand2.Type = OPND_NONE;
                        IS[i+1].Size = 0;
                        IS[i+2].Operation = OP_Nop;
                        IS[i+2].Operand1.Type = OPND_NONE;
                        IS[i+2].Operand2.Type = OPND_NONE;
                        IS[i+2].Size = 0;
                        i+=2;
                        break;
                    }
                } else if (IS[i].Operand1.Reg == GP_EBX) {
                    // OP_OPT_PushEbxEsiEdi --
                    //      push ebx
                    //      push esi
                    //      push edi
                    if ((IS[i+1].Operation == OP_Push32) &&
                        (IS[i+1].Operand1.Type == OPND_REGVALUE) &&
                        (IS[i+1].Operand1.Reg == GP_ESI) &&
                        (IS[i+2].Operation == OP_Push32) &&
                        (IS[i+2].Operand1.Type == OPND_REGVALUE) &&
                        (IS[i+2].Operand1.Reg == GP_EDI)){

                        IS[i].Operation = OP_OPT_PushEbxEsiEdi;
                        IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                        IS[i].Operand1.Type = OPND_NONE;
                        IS[i].Operand2.Type = OPND_NONE;
                        IS[i+1].Operation = OP_Nop;
                        IS[i+1].Operand1.Type = OPND_NONE;
                        IS[i+1].Operand2.Type = OPND_NONE;
                        IS[i+1].Size = 0;
                        IS[i+2].Operation = OP_Nop;
                        IS[i+2].Operand1.Type = OPND_NONE;
                        IS[i+2].Operand2.Type = OPND_NONE;
                        IS[i+2].Size = 0;
                        i+=2;
                        break;
                    }
                }
            }

            //
            // It is not one of the other special PUSH sequences, so see
            // if there are two consecutive PUSHes to merge together.  Note:
            // If the second PUSH references ESP, the two cannot be merged
            // because the value is computed before 4 is subtracted from ESP.
            //  ie. the following is disallowed:
            //        PUSH EAX
            //        PUSH ESP  ; second operand to Push2 would have been
            //                  ; built before the PUSH EAX was executed.
            //
            if (i < numInstr-1 &&
                !IS[i].FsOverride &&
                !IS[i+1].FsOverride &&
                IS[i+1].Operation == OP_Push32 &&
                IS[i+1].Operand1.Reg != GP_ESP &&
                IS[i+1].Operand1.IndexReg != GP_ESP) {

                IS[i].Operation = OP_OPT_Push232;
                IS[i].Operand2 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }

            break;

        case OP_Pop32:
            // OP_OPT_PopEdiEsiEbx
            //      pop edi
            //      pop esi
            //      pop ebx
            if (i < numInstr-2 &&
                (IS[i].Operand1.Type == OPND_REGREF) &&
                (IS[i].Operand1.Reg == GP_EDI) &&
                (IS[i+1].Operation == OP_Pop32) &&
                (IS[i+1].Operand1.Type == OPND_REGREF) &&
                (IS[i+1].Operand1.Reg == GP_ESI) &&
                (IS[i+2].Operation == OP_Pop32) &&
                (IS[i+2].Operand1.Type == OPND_REGREF) &&
                (IS[i+2].Operand1.Reg == GP_EBX)){

                IS[i].Operation = OP_OPT_PopEdiEsiEbx;
                IS[i].Size += IS[i+1].Size + IS[i+2].Size;
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Operand2.Type = OPND_NONE;
                IS[i+1].Size = 0;
                IS[i+2].Operation = OP_Nop;
                IS[i+2].Operand1.Type = OPND_NONE;
                IS[i+2].Operand2.Type = OPND_NONE;
                IS[i+2].Size = 0;
                i+=2;
            } else if (i < numInstr-1 &&
                !IS[i].FsOverride &&
                !IS[i].FsOverride &&
                IS[i].Operand1.Type == OPND_REGREF &&
                IS[i+1].Operation == OP_Pop32 &&
                IS[i+1].Operand1.Type == OPND_REGREF) {

                // Fold the two POPs together.  Both operands are REGREF,
                // so there is no problem with interdependencies between
                // memory touched by the first POP modifying the address
                // of the second POP.  ie. the following is not merged:
                //              POP EAX
                //              POP [EAX]   ; depends on results of first POP
                IS[i].Operation = OP_OPT_Pop232;
                IS[i].Operand2 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Xor32:
        case OP_Sub32:
            if (IS[i].Operand1.Type == OPND_REGREF &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is XOR samereg, samereg  (ie. XOR EAX, EAX),
                //  or SUB samereg, samereg             (ie. SUB ECX, ECX).
                // Emit OP_OPT_ZERO32 samereg
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_ZERO32;
            }
            break;

        case OP_Test8:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest8;
            }
            break;

        case OP_Test16:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest16;
            }
            break;

        case OP_Test32:
            if (IS[i].Operand1.Type == OPND_REGVALUE &&
                IS[i].Operand2.Type == OPND_REGVALUE &&
                IS[i].Operand1.Reg == IS[i].Operand2.Reg) {
                // Instruction is TEST samereg, samereg (ie. TEST EAX, EAX)
                // Emit OP_OPT_FastTest8/16/32
                IS[i].Operand1.Type = OPND_REGVALUE;
                IS[i].Operand2.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FastTest32;
            }
            break;

        case OP_Cmp32:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Sbb32 &&
                IS[i+1].Operand1.Type == OPND_REGREF &&
                IS[i+1].Operand2.Type == OPND_REGVALUE &&
                IS[i+1].Operand1.Reg == IS[i+1].Operand2.Reg) {
                // The two instructions are:
                //     CMP anything1, anything2
                //     SBB samereg, samereg
                // The optimized instruction is:
                //     Operation = either CmpSbb32 or CmpSbbNeg32
                //     Operand1  = &samereg  (passed as REGREF)
                //     Operand2  = anything1 (passed as ADDRVAL32 or REGVAL)
                //     Operand3  = anything2 (passed as ADDRVAL32 or REGVAL)
                IS[i].Operand3 = IS[i].Operand2;
                IS[i].Operand2 = IS[i].Operand1;
                IS[i].Operand1 = IS[i+1].Operand1;
                if (i<numInstr+2 && IS[i+2].Operation == OP_Neg32 &&
                    IS[i+2].Operand1.Type == OPND_REGREF &&
                    IS[i+2].Operand1.Reg == IS[i+1].Operand1.Reg) {
                    // The third instruction is NEG samereg, samereg
                    IS[i].Operation = OP_OPT_CmpSbbNeg32;
                    IS[i+2].Operation = OP_Nop;
                    IS[i+2].Operand1.Type = OPND_NONE;
                    IS[i+2].Operand2.Type = OPND_NONE;
                    IS[i+2].Size = 0;
                } else {
                    IS[i].Operation = OP_OPT_CmpSbb32;
                }
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Operand2.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Cwd16:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Idiv16) {
                IS[i].Operation = OP_OPT_CwdIdiv16;
                IS[i].Operand1 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_Cwd32:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Idiv32) {
                IS[i].Operation = OP_OPT_CwdIdiv32;
                IS[i].Operand1 = IS[i+1].Operand1;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Operand1.Type = OPND_NONE;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_FP_FNSTSW:
            if (i<numInstr+1 && IS[i+1].Operation == OP_Sahf &&
                IS[i].Operand1.Type == OPND_REGREF &&
                IS[i].Operand1.Reg == GP_AX) {

                // Replace FNSTSW AX / SAHF by one instruction
                IS[i].Operation = OP_OPT_FNSTSWAxSahf;
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Size += IS[i+1].Size;
                IS[i+1].Operation = OP_Nop;
                IS[i+1].Size = 0;
                i++;
            }
            break;

        case OP_FP_FSTP_STi:
            if (IS[i].Operand1.Immed == 0) {
                IS[i].Operand1.Type = OPND_NONE;
                IS[i].Operation = OP_OPT_FSTP_ST0;
            }
            break;

        }
    }
}


VOID
OptimizeIntelFlags(
    PINSTRUCTION IS,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    This function analysis x86 flag register usage and switches instructions
    to use NoFlags versions if possible.

Arguments:

    IS -- The instruction stream returned by the decoder

    numInstr -- The length of IS

Return Value:

    return-value - none

--*/
{
    USHORT FlagsNeeded;     // flags required to execute current x86 instr
    USHORT FlagsToGenerate; // flags which current x86 instr must generate
    PFRAGDESCR pFragDesc;   // ptr to Fragments[] array for current instr
    ULONG i;                // instruction index
    BOOL fPassNeeded = TRUE;// TRUE if the outer loop needs to loop once more
    ULONG PassNumber = 0;   // number of times outer loop has looped
    PENTRYPOINT pEPDest;    // Entrypoint for destination of a ctrl transfer
    USHORT KnownFlagsNeeded[MAX_INSTR_COUNT]; // flags needed for each instr

    while (fPassNeeded) {

        //
        // This loop is executed at most two times.  The second pass is only
        // required if there is a control-transfer instruction whose
        // destination is within the Instruction Stream and at a lower
        // Intel address  (ie. a backwards JMP).
        //
        fPassNeeded = FALSE;
        PassNumber++;
        CPUASSERT(PassNumber <= 2);

        //
        // Iterate over all x86 instructions decoded, from bottom to top,
        // propagating flags info up.  Start off by assuming all x86 flags
        // must be up-to-date at the end of the last basic block.
        //
        FlagsNeeded = ALLFLAGS;
        i = numInstr;
        do {
            i--;
            pFragDesc = &Fragments[IS[i].Operation];

            //
            // Calculate what flags will need to be computed by this
            // instruction and ones before this.
            //
            KnownFlagsNeeded[i] = FlagsNeeded | pFragDesc->FlagsNeeded;
            FlagsToGenerate = FlagsNeeded & pFragDesc->FlagsSet;

            //
            // Calculate what flags this instruction will need to have
            // computed before it can be executed.
            //
            FlagsNeeded = (FlagsNeeded & ~FlagsToGenerate) |
                           pFragDesc->FlagsNeeded;

            if (pFragDesc->Flags & OPFL_CTRLTRNS) {
                ULONG IntelDest = IS[i].Operand1.Immed;

                //
                // For control-transfer instructions, FlagsNeeded also includes
                // the flags required for the destination of the transfer.
                //
                if (IS[0].IntelAddress <= IntelDest &&
                    i > 0 && IS[i-1].IntelAddress >= IntelDest) {
                    //
                    // The destination of the control-transfer is at a lower
                    // address in the Instruction Stream.
                    //

                    if (PassNumber == 1) {
                        //
                        // Need to make a second pass over the flags
                        // optimizations in order to determine what flags are
                        // needed for the destination address.
                        //
                        fPassNeeded = TRUE;
                        FlagsNeeded = ALLFLAGS; // assume all flags are needed
                    } else {
                        ULONG j;
                        USHORT NewFlagsNeeded;

                        //
                        // Search for the IntelDest within the Instruction
                        // Stream.  IntelDest may not be found if there is
                        // a pun.
                        //
                        NewFlagsNeeded = ALLFLAGS;  // assume there is a pun
                        for (j=0; j < i; ++j) {
                            if (IS[j].IntelAddress == IntelDest) {
                                NewFlagsNeeded = KnownFlagsNeeded[j];
                                break;
                            }
                        }

                        FlagsNeeded |= NewFlagsNeeded;
                    }
                } else if (IS[i+1].IntelAddress <= IntelDest &&
                           IntelDest <= IS[numInstr-1].IntelAddress) {
                    //
                    // The destination of the control-transfer is at a higher
                    // address in the Instruction Stream.  Pick up the
                    // already-computed FlagsNeeded for the destination.
                    //
                    ULONG j;
                    USHORT NewFlagsNeeded = ALLFLAGS;   // assume a pun

                    for (j=i+1; j < numInstr; ++j) {
                        if (IS[j].IntelAddress == IntelDest) {
                            NewFlagsNeeded = KnownFlagsNeeded[j];
                            break;
                        }
                    }

                    FlagsNeeded |= NewFlagsNeeded;

                } else {
                    //
                    // Destination of the control-transfer is unknown.  Assume
                    // the worst:  all flags are required.
                    //
                    FlagsNeeded = ALLFLAGS;
                }
            }

            if (!(FlagsToGenerate & pFragDesc->FlagsSet) &&
                (pFragDesc->Flags & OPFL_HASNOFLAGS)) {
                //
                // This instruction is not required to generate any flags, and
                // it has a NOFLAGS version.  Update the flags that need to be
                // computed by instructions before this one, and modify the
                // Operation number to point at the NoFlags fragment.
                //
                FlagsToGenerate &= pFragDesc->FlagsSet;
                if (pFragDesc->Flags & OPFL_ALIGN) {
                    IS[i].Operation += 2;
                } else {
                    IS[i].Operation ++;
                }

                if (IS[i].Operation == OP_OPT_ZERONoFlags32) {
                    //
                    // Special-case this to be a "mov [value], zero" so it is
                    // inlined.
                    //
                    IS[i].Operation = OP_Mov32;
                    IS[i].Operand2.Type = OPND_IMM;
                    IS[i].Operand2.Immed = 0;
                }
            }
        } while (i);
    }
}

VOID
DetermineEbpAlignment(
    PINSTRUCTION InstructionStream,
    ULONG numInstr
    )
/*++
                                                                
Routine Description:

    For each instruction in InstructionStream[], sets Instruction->EbpAligned
    based on whether EBP is assumed to be DWORD-aligned or not.  EBP is
    assumed to be DWORD-aligned if a "MOV EBP, ESP" instruction is seen, and
    it is assumed to become unaligned at the first instruction which is
    flagged as modifying EBP.

Arguments:

    InstructionStream -- The instruction stream returned by the decoder

    numInstr -- The length of InstructionStream

Return Value:

    return-value - none

--*/
{
    ULONG i;
    BOOL EbpAligned = FALSE;

    for (i=0; i<numInstr; ++i) {
        if (InstructionStream[i].RegsSet & REGEBP) {
            //
            // This instruction modified EBP
            //
            if (InstructionStream[i].Operation == OP_OPT_SetupStack ||
                InstructionStream[i].Operation == OP_OPT_SetupStackNoFlags ||
                (InstructionStream[i].Operation == OP_Mov32 &&
                 InstructionStream[i].Operand2.Type == OPND_REGVALUE &&
                 InstructionStream[i].Operand2.Reg == GP_ESP)) {
                //
                // The instruction is either "MOV EBP, ESP" or one of the
                // SetupStack fragments (which contains a "MOV EBP, ESP")
                // assume Ebp is aligned from now on.
                //
                EbpAligned = TRUE;
            } else {
                EbpAligned = FALSE;
            }
        }

        InstructionStream[i].EbpAligned = EbpAligned;
    }
}

ULONG
GetInstructionStream(
    PINSTRUCTION InstructionStream,
    PULONG NumberOfInstructions,
    PVOID pIntelInstruction,
    PVOID pLastIntelInstruction
)
/*++
                                                                
Routine Description:

    Returns an instruction stream to the compiler.  The instruction
    stream is terminated either when the buffer is full, or when
    we reach a control transfer instruction.

Arguments:

    InstructionStream -- A pointer to the buffer where the decoded
        instructions are stored.

    NumberOfInstructions -- Upon entry, this variable contains the
        maximal number of instructions the buffer can hold.  When
        returning, it contains the actual number of instructions
        decoded.

    pIntelInstruction -- A pointer to the first real intel instruction
        to be decoded.

    pLastIntelInstruction -- A pointer to the last intel instruction to be
        compiled, 0xffffffff if not used.

Return Value:

    Number of entrypoints required to describe the decoded instruction
    stream.

--*/
{
    ULONG numInstr=0;
    ULONG maxBufferSize;
    ULONG cEntryPoints;

    maxBufferSize = (*NumberOfInstructions);

    //
    // Zero-fill the InstructionStream.  The decoder depends on this.
    //
    RtlZeroMemory(InstructionStream, maxBufferSize*sizeof(INSTRUCTION));

#if DBG
    //
    // Do a little analysis on the address we're about to decode.  If
    // the address is part of a non-x86 image, log that to the debugger.
    // That probably indicates a thunking problem.  If the address is not
    // part of an image, warn that the app is running generated code.
    //
    try {
        USHORT Instr;

        //
        // Try to read the instruction about to be executed.  If we get
        // an access violation, use 0 as the value of the instruction.
        //
        Instr = 0;

        //
        // Ignore BOP instructions - we assume we know what's going on with
        // them.
        //
        if (Instr != 0xc4c4) {

            NTSTATUS st;
            MEMORY_BASIC_INFORMATION mbi;

            st = NtQueryVirtualMemory(NtCurrentProcess(),
                                      pIntelInstruction,
                                      MemoryBasicInformation,
                                      &mbi,
                                      sizeof(mbi),
                                      NULL);
            if (NT_SUCCESS(st)) {
                PIMAGE_NT_HEADERS Headers;

                Headers = RtlImageNtHeader(mbi.AllocationBase);
                if (!Headers || Headers->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) {
                    LOGPRINT((TRACELOG, "CPU Analysis warning:  jumping from Intel to non-intel code at 0x%X\r\n", pIntelInstruction));
                }
            } else {
                // Eip isn't pointing anywhere???
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
#endif  //DBG

    while (numInstr < maxBufferSize) {

        DecodeInstruction ((DWORD) (ULONGLONG)pIntelInstruction, InstructionStream+numInstr);
        if ((STOP_DECODING(InstructionStream[numInstr])) ||
            (pIntelInstruction >= pLastIntelInstruction)) {

            // We reached a control transfer instruction
            numInstr++;
            (*NumberOfInstructions) = numInstr;
            break; // SUCCESS
        }
        pIntelInstruction = (PVOID) ((ULONGLONG)pIntelInstruction + (InstructionStream+numInstr)->Size);

        numInstr++;
    }

    //
    // Optimize x86 code by merging x86 instructions into meta-instructions
    // and cleaning up special x86 idioms.
    //
    if (!(CompilerFlags & COMPFL_SLOW)) {
        OptimizeInstructionStream (InstructionStream, numInstr);
    }

    //
    // Determine where all basic blocks are by filling in the EntryPoint
    // field in each instruction.  This must be done after
    // OptimizeInstructionStream() runs so that EntryPoints don't fall
    // into the middle of meta-instructions.
    //
    cEntryPoints = LocateEntryPoints(InstructionStream, numInstr);

    //
    // Perform optimizations which require knowledge of EntryPoints
    //
    if (numInstr > 2 && !(CompilerFlags & COMPFL_SLOW)) {
        if (!CpuDisableNoFlags) {
            OptimizeIntelFlags(InstructionStream, numInstr);
        }

        if (!CpuDisableRegCache) {
            CacheIntelRegs(InstructionStream, numInstr);
        }

        if (!CpuDisableEbpAlign) {
            DetermineEbpAlignment(InstructionStream, numInstr);
        }
    }

    return cEntryPoints;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\compile.c ===
/*++    

Copyright (c) 1996  Microsoft Corporation

Module Name:

    compile.c

Abstract:

    This module contains code to put the fragments into the translation
    cache.

Author:

    Dave Hastings (daveh) creation-date 27-Jun-1995

Revision History:

    Dave Hastings (daveh) 16-Jan-1996
        Move operand handling into fragment library
        
Notes:
    We don't yet have any code to handle processor errata

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <config.h>
#include <instr.h>
#include <threadst.h>
#include <frag.h>
#include <analysis.h>
#include <entrypt.h>
#include <compilep.h>
#include <compiler.h>
#include <tc.h>
#include <mrsw.h>
#include <stdio.h>
#include <stdlib.h>

ASSERTNAME;

#if _ALPHA_
    #define MAX_RISC_COUNT  32768
#else
    #define MAX_RISC_COUNT  16384
#endif

DWORD TranslationCacheFlags;        // indicates what kind of code is in the TC

#ifdef CODEGEN_PROFILE
DWORD EPSequence;
#endif

//
// This is guaranteed only to be accessed by a single thread at a time.
//
INSTRUCTION InstructionStream[MAX_INSTR_COUNT];
ULONG NumberOfInstructions;


PENTRYPOINT
CreateEntryPoints(
    PENTRYPOINT ContainingEntrypoint,
    PBYTE EntryPointMemory
    )
/*++

Routine Description:

    This function takes the InstructionStream and creates entrypoints
    from the information computed by LocateEntrypoints().

    Entrypoints are then added into the Red/Black tree.

Arguments:

    ContainingEntrypoint -- entrypoint which describes this range of intel
                            code already

    EntryPointMemory -- pre-allocated Entrypoint memory
    
Return Value:

    The Entry Point corresponding to the first instruction
    
--*/
{
    ULONG i, j, intelDest;
    PEPNODE EP;
    PENTRYPOINT EntryPoint;
    PENTRYPOINT PrevEntryPoint;
#ifdef CODEGEN_PROFILE
    ULONG CreateTime;
    
    CreateTime = GetCurrentTime();
    EPSequence++;
#endif

    //
    // Performance is O(n) always.
    //

    i=0;
    PrevEntryPoint = InstructionStream[0].EntryPoint;
    while (i<NumberOfInstructions) {

        //
        // This loop skips from entrypoint to entrypoint.
        //
        CPUASSERT(i == 0 || InstructionStream[i-1].EntryPoint != PrevEntryPoint);

        //
        // Get an entrypoint node from the EntryPointMemory allocated by
        // our caller.
        //
        if (ContainingEntrypoint) {
            EntryPoint = (PENTRYPOINT)EntryPointMemory;
            EntryPointMemory+=sizeof(ENTRYPOINT);
        } else {
            EP = (PEPNODE)EntryPointMemory;
            EntryPoint = &EP->ep;
            EntryPointMemory+=sizeof(EPNODE);
        }

        //
        // Find the next entrypoint and the RISC address of the next
        // instruction which begins an entrypoint.  Each instruction
        // in that range contains a pointer to the containing Entrypoint.
        //
        for (j=i+1; j<NumberOfInstructions; ++j) {
            if (InstructionStream[j].EntryPoint != PrevEntryPoint) {
                PrevEntryPoint = InstructionStream[j].EntryPoint;
                break;
            }
            InstructionStream[j].EntryPoint = EntryPoint;
        }

        //
        // Fill in the Entrypoint structure
        //
#ifdef CODEGEN_PROFILE        
        EntryPoint->SequenceNumber = EPSequence;
        EntryPoint->CreationTime = CreateTime;
#endif
        EntryPoint->intelStart = (PVOID)InstructionStream[i].IntelAddress;
        if (j < NumberOfInstructions) {
            EntryPoint->intelEnd = (PVOID)(InstructionStream[j].IntelAddress-1);
        } else {
            ULONG Prev;

            for (Prev=j-1; InstructionStream[Prev].Size == 0; Prev--)
               ;
            EntryPoint->intelEnd = (PVOID)(InstructionStream[Prev].IntelAddress +
                                           InstructionStream[Prev].Size - 1);
        }
        InstructionStream[i].EntryPoint = EntryPoint;

        if (ContainingEntrypoint) {
            //
            // Link this sub-entrypoint into the containing entrypoint
            //
            EntryPoint->SubEP = ContainingEntrypoint->SubEP;
            ContainingEntrypoint->SubEP = EntryPoint;

        } else {
            INT RetVal;

            //
            // Insert it into the EP tree
            //
            EntryPoint->SubEP = NULL;
            RetVal = insertEntryPoint(EP);
            CPUASSERT(RetVal==1);

        }

        //
        // Advance to the next instruction which contains an
        // Entrypoint.
        //
        i=j;
    }

    if (ContainingEntrypoint) {
        // Indicate that the Entrypoints are present
        EntrypointTimestamp++;
    }

    return InstructionStream[0].EntryPoint;
}


PENTRYPOINT
Compile(
    PENTRYPOINT ContainingEntrypoint,
    PVOID Eip
    )
/*++

Routine Description:

    This function puts together code fragments to execute the Intel
    code stream at Eip.  It gets a stream of pre-decoded instructions
    from the code analysis module.

Arguments:

    ContaingingEntrypoint -- If NULL, there is no entrypoint which already
                             describes the Intel address to be compiled.
                             Otherwise, this entrypoint describes the
                             Intel address.  The caller ensures that the
                             Entrypoint->intelStart != Eip.
    Eip -- Supplies the location to compile from
    
Return Value:

    pointer to the entrypoint for the compiled code
    
--*/
{

    ULONG NativeSize, InstructionSize, IntelSize, OperationSize;
    PCHAR CodeLocation, CurrentCodeLocation;
    ULONG i;
    PENTRYPOINT Entrypoint;
    INT RetVal;
    PVOID StopEip;
    DWORD cEntryPoints;
    PBYTE EntryPointMemory;
    DWORD EPSize;

#if defined(_ALPHA_)
    ULONG ECUSize, ECUOffset;
#endif
#if DBG
    DWORD OldEPTimestamp;
#endif
    DECLARE_CPU;

    if (ContainingEntrypoint) {
        //
        // See if the entrypoint exactly describes the x86 address
        //
        if (ContainingEntrypoint->intelStart == Eip) {
            return ContainingEntrypoint;
        }

        //
        // No need to compile past the end of the current entrypoint
        //
        StopEip = ContainingEntrypoint->intelEnd;

        //
        // Assert that the ContainingEntrypoint is actually an EPNODE.
        //
        CPUASSERTMSG( ((PEPNODE)ContainingEntrypoint)->intelColor == RED ||
                      ((PEPNODE)ContainingEntrypoint)->intelColor == BLACK,
                     "ContainingEntrypoint is not an EPNODE!");
    } else {
        //
        // Find out if there is a compiled block following this one
        //
        Entrypoint = GetNextEPFromIntelAddr(Eip);
        if (Entrypoint == NULL) {
            StopEip = (PVOID)0xffffffff;
        } else {
            StopEip = Entrypoint->intelStart;
        }
    }

    //
    // Get the stream of instructions to compile.
    // If the Trap Flag is set, then compile only one instruction
    //
    if (cpu->flag_tf) {
        NumberOfInstructions = 1;
    } else {
        NumberOfInstructions = CpuInstructionLookahead;
    }
 

    cEntryPoints = GetInstructionStream(InstructionStream,
                                        &NumberOfInstructions,
                                        Eip,
                                        StopEip
                                        );

    //
    // Pre-allocate enough space from the Translation Cache to store
    // the compiled code.
    //
    CodeLocation = AllocateTranslationCache(MAX_RISC_COUNT);

    //
    // Allocate memory for all of the Entrypoints.  This must be done
    // after the Translation Cache allocation, in case that allocation
    // caused a cache flush.
    //
    

    if (ContainingEntrypoint) {
        EPSize = cEntryPoints * sizeof(ENTRYPOINT);
    } else {
        EPSize = cEntryPoints * sizeof(EPNODE);
    }
    EntryPointMemory = (PBYTE)EPAlloc(EPSize);


    if (!EntryPointMemory) {
        //
        // Either failed to commit extra pages of memory to grow Entrypoint
        // memory, or there are so many entrypoints that the the reserved
        // size has been exceeded.  Flush the Translation Cache, which will
        // free up memory, then try the allocation again.
        //
        FlushTranslationCache(0, 0xffffffff);
        EntryPointMemory = (PBYTE)EPAlloc(EPSize);
        if (!EntryPointMemory) {
            //
            // We've tried our hardest, but there simply isn't any
            // memory available.  Time to give up.
            //
            RtlRaiseStatus(STATUS_NO_MEMORY);
        }

        //
        // Now that the cache has been flushed, CodeLocation is invalid.
        // re-allocate from the Translation Cache.  We know that
        // the cache was just flushed, so it is impossible for the cache
        // to flush again, which would invalidate EntryPointMemory.
        //
#if DBG
        OldEPTimestamp = EntrypointTimestamp;
#endif
        CodeLocation = AllocateTranslationCache(MAX_RISC_COUNT);

        CPUASSERTMSG(EntrypointTimestamp == OldEPTimestamp,
                     "Unexpected Translation Cache flush!");
    }

    //
    // Fill in the IntelStart, IntelEnd, and update
    // InstructionStream[]->EntryPoint
    //
    CreateEntryPoints(ContainingEntrypoint, EntryPointMemory);

    //
    // Generate RISC code from the x86 code
    //
    NativeSize = PlaceInstructions(CodeLocation, cEntryPoints);

    //
    // Give back the unused part of the Translation Cache
    //
    FreeUnusedTranslationCache(CodeLocation + NativeSize);
        
    //    
    // Flush the information to the instruction cache
    //
    NtFlushInstructionCache(NtCurrentProcess(), CodeLocation, NativeSize);

    //
    // Update the flags indicating what kind of code is in the TC
    //
    TranslationCacheFlags |= CompilerFlags;



    return (PENTRYPOINT)EntryPointMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\mrsw.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    mrsw.c

Abstract:

    This module implements a multiple reader single write synchronization
    method.
    
Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "wx86nt.h"
#include "cpuassrt.h"
#include "config.h"
#include "mrsw.h"
#include "cpumain.h"
#include "atomic.h"

ASSERTNAME;

MRSWOBJECT MrswEP; // Entrypoint MRSW synchronization object
MRSWOBJECT MrswTC; // Translation cache MRSW synchronization object
MRSWOBJECT MrswIndirTable; // Indirect Control Transfer Table synchronization object

BOOL
MrswInitializeObject(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This routine initializes the fields of Mrsw to their default values,
    and creates the events.

Arguments:

    Mrsw -- Supplies a pointer to an MRSWOBJECT to initialize
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;

    //
    // Initialize the counters
    //
    ZeroMemory(Mrsw, sizeof(MRSWOBJECT));
    
    //
    // Create the ReaderEvent and WriterEvent
    //

    Status = NtCreateEvent(&Mrsw->ReaderEvent,
                           EVENT_ALL_ACCESS,
                           NULL,              // POBJECT_ATTRIBUTES
                           NotificationEvent, // ManualReset
                           FALSE);            // InitialState
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtCreateEvent(&Mrsw->WriterEvent,
                           EVENT_ALL_ACCESS,
                           NULL,              // POBJECT_ATTRIBUTES
                           SynchronizationEvent, // AutoReset
                           FALSE);            // InitialState
    if (!NT_SUCCESS(Status)) {
        NtClose(Mrsw->ReaderEvent);
        return FALSE;
    }
    return TRUE;
}

VOID
PossibleMrswTimeout(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function is called whenever an Mrsw function times out.  It prompts
    the user, and if the user chooses Retry, the Mrsw function re-waits.
    If the user chooses Cancel, the CPU will attempt to launch NTSD and break
    into the debugger.

Arguments:

    Mrsw -- Supplies the Mrsw which may have a deadlock
    
Return Value:

--*/
{
    NTSTATUS Status;
    ULONG ErrorResponse;

    LOGPRINT((ERRORLOG, "WX86CPU: Possible deadlock in Mrsw %x\n", Mrsw));
    Status = NtRaiseHardError(
                            STATUS_POSSIBLE_DEADLOCK | 0x10000000,
                            0,
                            0,
                            NULL,
                            OptionRetryCancel,
                            &ErrorResponse);
    if (!NT_SUCCESS(Status) || ErrorResponse == ResponseCancel) {
        DbgBreakPoint();
    }
}


VOID
MrswWriterEnter(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to enter the Mrsw as the (single) writer.

Arguments:

    Mrsw -- Supplies the Mrsw to enter
    
Return Value:

--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;
    NTSTATUS r;

    //
    // reset the reader event so that any readers that find the 
    // WriterCount > 0 will actually wait.  We have to do that now,
    // because if we wait, the reader might wait on the event before we
    // got it reset.
    //
    r= NtClearEvent(Mrsw->ReaderEvent);
    if (!NT_SUCCESS(r)) {
#if DBG
        LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtClearEvent\n", r));
#endif
        RtlRaiseStatus(r);
    }
    
    //
    // Get the counters and increment the writer count
    // This is done atomically
    //
    dwCounters = MrswFetchAndIncrementWriter((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;
    CPUASSERTMSG(Counters.WriterCount != 0, "WriterCount overflowed");

    //
    // If there is a writer or a reader already, wait for them to finish
    //
    if ( (Counters.WriterCount > 1) || (Counters.ReaderCount) ) {
        NTSTATUS r;

        // Ensure We are not about to wait on ourselves.
        CPUASSERTMSG(Mrsw->WriterThreadId != ProxyGetCurrentThreadId(),
                     "MrswWriterEnter() called twice by the same thread");

        for (;;) {
            r = NtWaitForSingleObject(
                Mrsw->WriterEvent,
                FALSE,
                &MrswTimeout
                );
            if (r == STATUS_TIMEOUT) {
                PossibleMrswTimeout(Mrsw);
            } else if (NT_SUCCESS(r)) {
                break;
            } else {
#if DBG
                LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtWaitForCriticalSection\n", r));
#endif
                RtlRaiseStatus(r);
            }
        }
    }

#if DBG
    CPUASSERTMSG(Mrsw->WriterThreadId == 0, "Another writer still is active.");
    Mrsw->WriterThreadId = ProxyGetCurrentThreadId();
#endif
}

VOID
MrswWriterExit( 
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to exit the Mrsw.  It will restart the
    next writer if there is one, or the readers if there are any

Arguments:

    Mrsw -- Supplies the Mrsw to exit
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    // Ensure we are the active writer
    CPUASSERTMSG(Mrsw->WriterThreadId == ProxyGetCurrentThreadId(),
                 "MrswWriterExit: current thread is not the writer");

    //
    // Decrement the count of writers
    //
#if DBG
    //
    // Set the thread id to 0 first, so if another writer comes along,
    // we don't zero out its thread id.
    //
    Mrsw->WriterThreadId = 0;
#endif
    dwCounters = MrswFetchAndDecrementWriter((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;

    CPUASSERTMSG(Counters.WriterCount != 0xffff, "Writer underflow");

    //
    // Start a waiting writer if there is one.  If there is no writer
    // start the waiting readers
    //
    if (Counters.WriterCount) {

        NtSetEvent(Mrsw->WriterEvent, NULL);

    } else {

        NtSetEvent(Mrsw->ReaderEvent, NULL);
    }
}

VOID
MrswReaderEnter(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to enter the Mrsw as a reader.

Arguments:

    Mrsw -- Supplies the Mrsw to enter
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    for (;;) {
        //
        // Increment the count of readers.  If a writer is active, DO NOT
        // increment the read count.  In that case, we must block until the
        // writer is done, then try again.
        //
        dwCounters = MrswFetchAndIncrementReader((DWORD *)&(Mrsw->Counters));
        Counters = *(PMRSWCOUNTERS)&dwCounters;
        CPUASSERTMSG(Counters.WriterCount || Counters.ReaderCount != 0,
                     "Reader underflow");

        if (Counters.WriterCount) {
            NTSTATUS r;

            // Ensure we are not about to wait on ourselves.
            CPUASSERTMSG(Mrsw->WriterThreadId != ProxyGetCurrentThreadId(),
                         "MRSWReaderEnter(): Thread already has write lock");

            //
            // There is a writer, wait for it to finish
            //
            for (;;) {
                r = NtWaitForSingleObject(
                    Mrsw->ReaderEvent,
                    FALSE,
                    &MrswTimeout
                    );
                if (r == STATUS_TIMEOUT) {
                    PossibleMrswTimeout(Mrsw);
                } else if (NT_SUCCESS(r)) {
                    break;
                } else {
#if DBG
                    LOGPRINT((ERRORLOG, "WX86CPU: Got status %x from NtWaitForCriticalSection\n", r));
#endif
                    RtlRaiseStatus(r);
                }
            }
        } else {
            //
            // No writer, so MrswFetchAndIncrementReader() incremented the
            // reader count - OK to exit out of the loop.
            //
            break;
        }
    }
}

VOID
MrswReaderExit(
    PMRSWOBJECT Mrsw
    )
/*++

Routine Description:

    This function causes the caller to exit the Mrsw.  If this was the last
    reader, it will restart the a writer if there is one.

Arguments:

    Mrsw -- Supplies the Mrsw to exit
    
Return Value:


--*/
{
    DWORD dwCounters;
    MRSWCOUNTERS Counters;

    //
    // Decrement the count of active readers
    //
    dwCounters = MrswFetchAndDecrementReader((DWORD *)&(Mrsw->Counters));
    Counters = *(PMRSWCOUNTERS)&dwCounters;
    CPUASSERTMSG(Counters.ReaderCount != 0xffff, "Reader underflow");

    if (Counters.WriterCount) {

        if (Counters.ReaderCount == 0) {
            //
            // This thread is the last reader, and there is a writer
            // waiting.  Start the writer.
            //
            NtSetEvent(Mrsw->WriterEvent, NULL);
        }

    } else {
        //
        // There are no waiting readers and no writers, so do nothing.
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\cpumain\config.c ===
/*++
                                                                                
Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.c

Abstract:
    
    This module implements the configuration support for the CPU.
    
Author:

    13-Jun-1996 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"

ASSERTNAME;

char *szBadVarMsg="%Ws value out-of-range - replacing with 0x%x.\n";

//
// The list of all configurable variables in the CPU.  All are initialized
// to their default values.
//
DWORD CpuCacheReserve         = 6144*1024;
DWORD CpuCacheCommit          = MAX_PROLOG_SIZE;
DWORD CpuCacheGrowTicks       = 200;
DWORD CpuCacheShrinkTicks     = 1000;
DWORD CpuCacheChunkMin        = 32*1024;
DWORD CpuCacheChunkMax        = 512*1024;
DWORD CpuCacheChunkSize       = 64*1024;
LARGE_INTEGER MrswTimeout;
DWORD CompilerFlags           = COMPFL_FAST;
DWORD fUseNPXEM               = FALSE;
DWORD CpuMaxAllocRetries      = 4;
DWORD CpuWaitForMemoryTime    = 200;
DWORD CpuInstructionLookahead = MAX_INSTR_COUNT;
DWORD CpuDisableDynamicCache  = FALSE;
DWORD CpuEntryPointReserve    = 0x1000000;
DWORD CpuDisableRegCache      = FALSE;
DWORD CpuDisableNoFlags       = FALSE;
DWORD CpuDisableEbpAlign      = FALSE;
DWORD CpuSniffWritableCode    = FALSE;

#define IsPowerOfTwo(x)       (((x) & ((x)-1)) == 0)

VOID
GetConfigurationData(
    VOID
    )
/*++

Routine Description:

    Overrides any variable(s) listed above with values from the Registry.

Arguments:

    None

Return Value:

    None

--*/
{
    PCONFIGVAR pcfg;

    pcfg = Wx86FetchConfigVar(STR_CACHE_RESERVE);
    if (pcfg) {
        if (pcfg->Data < MAX_PROLOG_SIZE) {
            CpuCacheReserve = MAX_PROLOG_SIZE;
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_RESERVE, CpuCacheReserve));
        } else {
            CpuCacheReserve = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_COMMIT);
    if (pcfg) {
        if (pcfg->Data < MAX_PROLOG_SIZE) {
            CpuCacheCommit = MAX_PROLOG_SIZE;
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_COMMIT, CpuCacheCommit));
        } else {
            CpuCacheCommit = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
   if (CpuCacheCommit > CpuCacheReserve) {
        CpuCacheCommit = CpuCacheReserve;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_COMMIT, CpuCacheCommit));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_GROW_TICKS);
    if (pcfg) {
        CpuCacheGrowTicks = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_SHRINK_TICKS);
    if (pcfg) {
        CpuCacheShrinkTicks = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheShrinkTicks < CpuCacheGrowTicks) {
        CpuCacheShrinkTicks = CpuCacheGrowTicks;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_SHRINK_TICKS, CpuCacheGrowTicks));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKMIN);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data) ||
             pcfg->Data < MAX_PROLOG_SIZE ||
             pcfg->Data > CpuCacheReserve) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMIN, CpuCacheChunkMin));
        } else {
            CpuCacheChunkMin = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKMAX);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
        } else {
            CpuCacheChunkMax = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheChunkMax < CpuCacheChunkMin) {
        CpuCacheChunkMax = CpuCacheChunkMin;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
    } else if (CpuCacheChunkMax > CpuCacheReserve) {
        CpuCacheChunkMax = CpuCacheReserve;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKMAX, CpuCacheChunkMax));
    }

    pcfg = Wx86FetchConfigVar(STR_CACHE_CHUNKSIZE);
    if (pcfg) {
        if (!IsPowerOfTwo(pcfg->Data)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
        } else {
            CpuCacheChunkSize = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }
    if (CpuCacheChunkSize < CpuCacheChunkMin) {
        CpuCacheChunkSize = CpuCacheChunkMin;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
    } else if (CpuCacheChunkSize > CpuCacheChunkMax) {
        CpuCacheChunkSize = CpuCacheChunkMax;
        LOGPRINT((TRACELOG, szBadVarMsg, STR_CACHE_CHUNKSIZE, CpuCacheChunkSize));
    }

    pcfg = Wx86FetchConfigVar(STR_MRSW_TIMEOUT);
    if (pcfg) {
        if (pcfg->Data & 0x80000000) {
            //
            // Value is negative - use a big negative value to wait forever
            //
            MrswTimeout.LowPart =  0x00000000;
            MrswTimeout.HighPart = 0x80000000;
        } else {
            //
            // Multiply the time in ms by -10000 to convert into a relative
            // time usable by NtWaitForSingleObject().
            //
            MrswTimeout.QuadPart = Int32x32To64(pcfg->Data, -10000);
        }
        Wx86FreeConfigVar(pcfg);
    } else {
        //
        // Initialize MrswTimeout to be 3 times PEB->CriticalSectionTimeout
        //
        MrswTimeout.QuadPart = NtCurrentPeb()->CriticalSectionTimeout.QuadPart * 3;
    }

    pcfg = Wx86FetchConfigVar(STR_COMPILERFLAGS);
    if (pcfg) {
        if ( (pcfg->Data & (COMPFL_FAST|COMPFL_SLOW)) == (COMPFL_FAST|COMPFL_SLOW)) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_COMPILERFLAGS, CompilerFlags));
        } else {
            CompilerFlags = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_USEWINPXEM);
    if (pcfg) {
        fUseNPXEM = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_MAX_ALLOC_RETRIES);
    if (pcfg) {
        CpuMaxAllocRetries = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_WAIT_FOR_MEMORY_TIME);
    if (pcfg) {
        CpuWaitForMemoryTime = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_MAX_INSTRUCTIONS);
    if (pcfg) {
        if (pcfg->Data > MAX_INSTR_COUNT) {
            LOGPRINT((TRACELOG, szBadVarMsg, STR_CPU_MAX_INSTRUCTIONS, CpuInstructionLookahead));
        } else {
            CpuInstructionLookahead = pcfg->Data;
        }
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_DYNCACHE);
    if (pcfg) {
        CpuDisableDynamicCache = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_REGCACHE);
    if (pcfg) {
        CpuDisableRegCache = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_NOFLAGS);
    if (pcfg) {
        CpuDisableNoFlags = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_DISABLE_EBPALIGN);
    if (pcfg) {
        CpuDisableEbpAlign = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }

    pcfg = Wx86FetchConfigVar(STR_CPU_SNIFF_WRITABLE_CODE);
    if (pcfg) {
        CpuSniffWritableCode = pcfg->Data;
        Wx86FreeConfigVar(pcfg);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\simulate.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    simulate.c

Abstract:

    This module contains the code that drives the intel instruction
    execution process.

Author:

    Dave Hastings (daveh) creation-date 09-Jul-1994

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86nt.h"
#include "wx86.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "config.h"
#include "entrypt.h"
#include "compilep.h"
#include "compiler.h"
#include "instr.h"
#include "frag.h"
#include "cpumain.h"
#include "mrsw.h"
#include "cpunotif.h"
#include "tc.h"
#include "atomic.h"

ASSERTNAME;

//
// Private definition of what a WX86_CPUHINT really contains.
// The CPUHINT allows the CPU to bypass an expensive NativeAddressFromEip()
// call to map the Intel EIP value into a RISC address.  Most calls to
// CpuSimulate() are from RISC-to-x86 callbacks, and they have two DWORDS
// which the CPU uses to cache the NativeAddressFromEip() results.
//
//  Timestamp -- value of TranslationCacheTimestamp when the CPUHINT was
//               filled in.  This is used to determine if the Translation Cache
//               has been flushed.  If so, the EntryPoint pointer is now
//               invalid.
//  EntryPoint -- pointer to the ENTRYPOINT describing the Intel Address
//               corresponding to this callback.
//
//
typedef struct _CpuHint {
    DWORD       Timestamp;
    PENTRYPOINT EntryPoint;
} CPUHINT, *PCPUHINT;


//
// These values are modified by the wx86e debugger extension whenever it
// writes into this process's address space.  It is used whenever Int3
// instructions are added or removed from Intel code.  The CPU examines
// these variables whenever CPUNOTIFY_DBGFLUSHTC is set.
//
ULONG DbgDirtyMemoryAddr = 0xffffffff;
ULONG DbgDirtyMemoryLength;

#ifdef PROFILE
//
// Wrap our assembly entrypoint so we can see it in the cap output
//
VOID
_ProfStartTranslatedCode(
    PTHREADSTATE ThreadState,
    PVOID NativeCode    
    )
{
    StartTranslatedCode(ThreadState, NativeCode);
}
#endif

VOID
MsCpuSimulate(
    PWX86_CPUHINT Wx86CpuHint
)
/*++

Routine Description:

    This is the cpu internal routine that causes intel instructions
    to be executed.  Execution continues until something interesting
    happens (such as BOP Unsimulate)

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    PVOID NativeCode;
    DWORD CpuNotify;
    DWORD OldCompilerFlags = CompilerFlags;
    DECLARE_CPU;
        
    CPUASSERT(sizeof(CPUHINT) == sizeof(WX86_CPUHINT));

    //
    // Check CpuNotify to see if the Translation Cache needs flushing.
    //
    CpuNotify = cpu->CpuNotify;
    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_DBGFLUSHTC;

    if (cpu->flag_tf) {
        CpuNotify |= CPUNOTIFY_MODECHANGE;
        CompilerFlags = COMPFL_SLOW;
    }

    if (CpuNotify & (CPUNOTIFY_DBGFLUSHTC|CPUNOTIFY_MODECHANGE)) {
        if (CpuNotify & CPUNOTIFY_MODECHANGE) {
            //
            // On a fast/slow compiler mode change, flush the whole cache
            //
            DbgDirtyMemoryAddr = 0;
            DbgDirtyMemoryLength = 0xffffffff;
        }
        //
        // The debugger has modified memory - flush the Translation Cache
        //
        CpuFlushInstructionCache((PVOID)DbgDirtyMemoryAddr,
                                 DbgDirtyMemoryLength);
        DbgDirtyMemoryAddr = 0xffffffff;
        DbgDirtyMemoryLength = 0;
    }

    //
    // Flag ourseleves as having the TC lock.
    //
    CPUASSERTMSG(cpu->fTCUnlocked != FALSE,
                 "CPU has been reentered with the TC already locked.\n");
    cpu->fTCUnlocked = FALSE;
    //
    // The caller has already pushed a return address on the stack.
    // (Probably to a BOP FE).  Get the callstack in sync.
    //
    PUSH_CALLSTACK(*(DWORD *)cpu->Esp.i4, 0)

    if (Wx86CpuHint) {
        PCPUHINT CpuHint = (PCPUHINT)Wx86CpuHint;
        PVOID Eip = (PVOID)cpu->eipReg.i4;

        //
        // CpuNotify isn't set, and a hint is present...try to use it.
        //
        MrswReaderEnter(&MrswTC);
        if (CpuHint->Timestamp != TranslationCacheTimestamp ||
            CpuHint->EntryPoint->intelStart != Eip) {
            //
            // The hint is present, but invalid.  Get the new address and
            // update the hint
            //
            MrswReaderExit(&MrswTC);

#if 0
            LOGPRINT((DEBUGLOG, "CPU: CpuHint was invalid: got (%X,%X) expected (%X,%X)\r\n",
                                 CpuHint->Timestamp, ((CpuHint->Timestamp)?CpuHint->EntryPoint->intelStart:0),
                                 TranslationCacheTimestamp, Eip));
#endif
            CpuHint->EntryPoint = NativeAddressFromEip(Eip, FALSE);
            CpuHint->Timestamp = TranslationCacheTimestamp;
        }

        NativeCode = CpuHint->EntryPoint->nativeStart;
    } else {
        //
        // Find the address of the Native code to execute, and lock the
        // Translation cache
        //
        NativeCode = NativeAddressFromEip((PVOID)cpu->eipReg.i4, FALSE)->nativeStart;
    }


    while (TRUE) {

        if (cpu->CSTimestamp != TranslationCacheTimestamp) {
            //
            // The timestamp associated with the callstack is different
            // than the timestamp for the Translation Cache.  Therefore,
            // the TC has been flushed.  We must flush the callstack, too.
            //
            FlushCallstack(cpu);
        }


        //
        // Go execute the code
        //
#ifdef PROFILE
        _ProfStartTranslatedCode(cpu, NativeCode);
#else
        StartTranslatedCode(cpu, NativeCode);
#endif
 
        CompilerFlags = OldCompilerFlags;

        //
        // Release the translation cache
        //
        MrswReaderExit(&MrswTC);

        //
        // if TF flag is set, then switch the compiler to SLOW_MODE
        // and set the CPUNOTIFY_TRACEFLAG to generate an x86 single-step
        // exception.
        //
        cpu->CpuNotify |= cpu->flag_tf;

        //
        // Check and see if anything needs to be done
        //
 
        if (cpu->CpuNotify) {
            
            //
            // Atomically get CpuNotify and clear the appropriate bits
            //
            CpuNotify = cpu->CpuNotify;
            cpu->CpuNotify &= (CPUNOTIFY_TRACEADDR|CPUNOTIFY_SLOWMODE|CPUNOTIFY_TRACEFLAG);

            //
            // Indicate we have left the Translation Cache
            //
            cpu->fTCUnlocked = TRUE;

            if (CpuNotify & CPUNOTIFY_UNSIMULATE) {
                break;
            }

            if (CpuNotify & CPUNOTIFY_EXITTC) {
                // There is no work to do - The Translation Cache is going
                // away, so all active reader threads needed to leave the
                // cache ASAP and block inside NativeAddressFromEip() until
                // the cache flush has completed.
            }

            if (CpuNotify & CPUNOTIFY_SUSPEND) {
                //
                // Another thread wants to suspend us.  Notify that
                // thread that we're in a consistent state, then wait
                // until we are resumed.
                //
                CpupSuspendCurrentThread();
            }

            if (CpuNotify & CPUNOTIFY_SLOWMODE) {
                // log the instruction address for debugging purposes
                cpu->eipLog[cpu->eipLogIndex++] = cpu->eipReg.i4;
                cpu->eipLogIndex %= EIPLOGSIZE;
            }

            if (CpuNotify & CPUNOTIFY_INTX) {
                BYTE intnum;

                //
                // Get the interrupt number from the code stream, and
                // advance Eip to the start of the next instruction.
                //
                intnum = *(PBYTE)cpu->eipReg.i4;
                
                cpu->eipReg.i4 += 1;
                if (intnum == 0xcc) {
                    intnum = 3;
                } else {
                    cpu->eipReg.i4 += 1;
                }
                
                CpupDoInterrupt(intnum);

                //
                // Flush the entire translation cache since we don't know what memory
                // areas the debugger has changed. We do this by simulating
                // a compiler mode change.
                //
                CpuNotify |= CPUNOTIFY_MODECHANGE;

            } else if (CpuNotify & (CPUNOTIFY_TRACEADDR|CPUNOTIFY_TRACEFLAG)) {

                if ((CpuNotify & CPUNOTIFY_TRACEADDR) &&
                    ((DWORD)(ULONGLONG)cpu->TraceAddress == cpu->eipReg.i4) 
                ) {
                    cpu->TraceAddress = NULL;
                    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_TRACEADDR;
                    Wx86RaiseStatus(WX86CPU_SINGLE_STEP);
                }

                if (CpuNotify & CPUNOTIFY_TRACEFLAG) {
                    cpu->flag_tf = 0;
                    cpu->CpuNotify &= ~(ULONG)CPUNOTIFY_TRACEFLAG;
                    Wx86RaiseStatus(WX86CPU_SINGLE_STEP);
                }

                //
                // Flush the entire translation cache since we don't know what memory
                // areas the debugger has changed. We do this by simulating
                // a compiler mode change.
                //
                CpuNotify |= CPUNOTIFY_MODECHANGE;
            }

            if (CpuNotify & (CPUNOTIFY_DBGFLUSHTC|CPUNOTIFY_MODECHANGE)) {
                if (CpuNotify & CPUNOTIFY_MODECHANGE) {
                    //
                    // On a fast/slow compiler mode change, flush whole cache
                    //
                    DbgDirtyMemoryAddr = 0;
                    DbgDirtyMemoryLength = 0xffffffff;
                }
                //
                // The debugger has modified memory - flush the Translation
                // Cache
                //

                CpuFlushInstructionCache((PVOID)DbgDirtyMemoryAddr,
                                         DbgDirtyMemoryLength);
                DbgDirtyMemoryAddr = 0xffffffff;
                DbgDirtyMemoryLength = 0;
            }

            //
            // Indicate we are re-entering the Translation Cache
            //
            cpu->fTCUnlocked = FALSE;
        }


        if (cpu->flag_tf) {
            OldCompilerFlags = CompilerFlags;
            CompilerFlags = COMPFL_SLOW;

            if (!(CpuNotify & CPUNOTIFY_MODECHANGE)) {
                CpuFlushInstructionCache(NULL, 0xffffffff);
            }
        }

        //
        // Find the address of the Native code to execute, and lock the
        // Translation cache
        //

        NativeCode = NativeAddressFromEip((PVOID)cpu->eipReg.i4, FALSE)->nativeStart;

    }
}

PENTRYPOINT
NativeAddressFromEip(
    PVOID       Eip,
    BOOL        LockTCForWrite
    )
/*++

Routine Description:

    This routine finds (or creates) the native code for the specified Intel
    code.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

Arguments:

    Eip             -- Supplies the address of the Intel code
    LockTCForWrite  -- TRUE if caller wants TC locked for WRITE, FALSE if the
                       call wants it locked for READ.

Return Value:

    Entrypoint whose nativeStart Address corresponds to the Intel Address
    passed in.
    
--*/
{
    PENTRYPOINT Entrypoint;
    typedef VOID (*pfnMrswCall)(PMRSWOBJECT);
    pfnMrswCall MrswCall;
    DWORD OldEntrypointTimestamp;

    //
    // Assume we are going to call MrswReaderExit(&MrswEP) at the end
    // of this function.
    //


    MrswCall = MrswReaderExit;

    //
    // Lock the Entrypoint for reading
    //
    MrswReaderEnter(&MrswEP);

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);


    //
    // If there is no entrypoint, compile up the code
    //
    if (Entrypoint == NULL || Entrypoint->intelStart != Eip) {

        //
        // Unlock the Entrypoint read
        //
        OldEntrypointTimestamp = EntrypointTimestamp;
        MrswReaderExit(&MrswEP);

        //
        // Lock the Entrypoint for write, and change the function to be
        // called at the end of the function to be MrswWriterExit(&MrswEP)
        //
        MrswWriterEnter(&MrswEP);
        MrswCall = MrswWriterExit;

        //
        // See if another thread compiled the Entrypoint while we were
        // switching from read mode to write mode
        //
        if (OldEntrypointTimestamp != EntrypointTimestamp) {
            //
            // Timestamp has changed.  There is a possibility that another
            // thread has compiled code at Eip for us, so retry the search.
            //
            Entrypoint = EPFromIntelAddr(Eip);
        }

        //
        // Call the compiler.  It will do one of the following things:
        //  1. if Entrypoint==NULL, it will compile new code
        //  2. if Entrypoint!=NULL and Entrypoint->Eip == Eip, it will
        //     return Entrypoint unchanged
        //  3. otherwise, the Entrypoint needs splitting.  It will do so,
        //     and compile a subset of the code described by Entrypoint and
        //     then return a new Entrypoint
        //
        Entrypoint = Compile(Entrypoint, Eip);
    }

    //
    // Instruction was found - grab the translation cache for either
    // read or write, then free the entrypoint write lock.  The
    // order is important as it prevents the TC from being flushed
    // between the two Mrsw calls.
    //
    if (LockTCForWrite) {
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);
    } else {
        MrswReaderEnter(&MrswTC);
    }
    (*MrswCall)(&MrswEP);  // Either MrswReaderExit() or MrswWriterExit()

    return Entrypoint;
}

PVOID
NativeAddressFromEipNoCompile(
    PVOID Eip
    )
/*++

Routine Description:

    This routine finds the native code for the specified Intel code, if it
    exists.  No new code is compiled.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

Arguments:

    Eip -- Supplies the address of the Intel code

Return Value:

    Address of corresponding native code, or NULL if none exists.  Translation
    cache locked for WRITE if native code exists for Eip.  TC is locked for
    READ if no code exitss.
    
--*/
{
    PENTRYPOINT Entrypoint;
    DWORD OldEntrypointTimestamp;

    //
    // Lock the Entrypoint for reading
    //
    MrswReaderEnter(&MrswEP);

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);

    if (Entrypoint == NULL) {
        //
        // Entrypoint not found - no native code exists for this Intel address
        //
        MrswReaderEnter(&MrswTC);
        MrswReaderExit(&MrswEP);
        return NULL;

    } else if (Entrypoint->intelStart == Eip) {
        //
        // Exact instruction found - return the NATIVE address
        //
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);
        MrswReaderExit(&MrswEP);
        return Entrypoint->nativeStart;
    }

    //
    // Else the entrypoint contains the Intel address.  Nothing can
    // be done.  Release EP write and get TC read.
    //
    MrswReaderExit(&MrswEP);
    MrswReaderEnter(&MrswTC);
    return NULL;
}


PENTRYPOINT
NativeAddressFromEipNoCompileEPWrite(
    PVOID Eip
    )
/*++

Routine Description:

    This routine finds the native code for the specified Intel code, if it
    exists.  No new code is compiled.  This function is called by functions
    in patchfn.c during compile time when they need to decide whether to
    directly place the patched version in the Translation Cache or not.

    NOTE:  This function can only be called when the Translation Cache is
           not locked (either read or write) by the current thread.

    NOTE:  The difference between this function and NativeAddressFromEipNoCompile
           is that here we assume that we have the Entry Point write lock upon
           entry to the function.  This function makes no calls to MRSW functions
           for any locks.

Arguments:

    Eip -- Supplies the address of the Intel code

Return Value:

    Address of corresponding native code, or NULL if none exists.  All MRSW objects
    are in exactly the same state they were when we entered this function.
    
--*/
{
    PENTRYPOINT Entrypoint;

    //
    // Find the location of the Risc code corresponding to the
    // Intel EIP register
    //
    Entrypoint = EPFromIntelAddr(Eip);

    if (Entrypoint == NULL) {
        //
        // Entrypoint not found - no native code exists for this Intel address
        //
        return NULL;

    } else if (Entrypoint->intelStart == Eip) {
        //
        // Exact instruction found - return the NATIVE address
        //
        return Entrypoint;
    }

    //
    // Entrypoint needs to be split.  Can't do that without compiling.
    //
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\tc.c ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    tc.c

Abstract:

    This module implements the Translation Cache, where Intel code is
    translated into native code.
    
Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "tc.h"
#include "entrypt.h"
#include "mrsw.h"
#include "cpunotif.h"
#include "cpumain.h"
#include "instr.h"
#include "threadst.h"
#include "frag.h"
#include "atomic.h"
#ifdef CODEGEN_PROFILE
#include <coded.h>
#endif


ASSERTNAME;

#if MIPS
#define DBG_FILL_VALUE  0x73737373          // an illegal instruction
#else
#define DBG_FILL_VALUE  0x01110111
#endif

#ifdef CODEGEN_PROFILE
extern DWORD EPSequence;
#endif

//
// Descriptor for a range of the Translation Cache.
//
typedef struct _CacheInfo {
    PBYTE StartAddress;     // base address for the cache
    LONGLONG MaxSize;          // max size of the cache (in bytes)
    LONGLONG MinCommit;        // min amount that can be committed (bytes)
    LONGLONG NextIndex;        // next free address in the cache
    LONGLONG CommitIndex;      // next uncommitted address in the cache
    LONGLONG ChunkSize;        // amount to commit by
    ULONG LastCommitTime;   // time of last commit
} CACHEINFO, *PCACHEINFO;

//
// Pointers to the start and end of the function prolog for StartTranslatedCode
//
extern CHAR StartTranslatedCode[];
extern CHAR StartTranslatedCodePrologEnd[];

ULONG       TranslationCacheTimestamp = 1;
CACHEINFO   DynCache;       // Descriptor for dynamically allocated TC
RUNTIME_FUNCTION DynCacheFunctionTable;
BOOL        fTCInitialized;
extern DWORD TranslationCacheFlags;


BOOL
InitializeTranslationCache(
    VOID
    )
/*++

Routine Description:

    Per-process initialization for the Translation Cache.

Arguments:

    .
    
Return Value:

    .

--*/
{
    NTSTATUS Status;
    ULONGLONG pNewAllocation;
    ULONGLONG RegionSize;
    LONG PrologSize;

    //
    // Initialize non-zero fields in the CACHEINFO
    //
    DynCache.MaxSize = CpuCacheReserve;
    DynCache.MinCommit = CpuCacheCommit;
    DynCache.ChunkSize = CpuCacheChunkSize;

    //
    // Reserve DynCache.MaxSize bytes of memory.
    //
    RegionSize = DynCache.MaxSize;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &(PVOID)DynCache.StartAddress,
                                     0,
                                     (ULONGLONG *)&DynCache.MaxSize,
                                     MEM_RESERVE,
                                     PAGE_EXECUTE_READWRITE
                                    );
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Commit enough memory to store the function prolog.
    //
    pNewAllocation = (ULONGLONG)DynCache.StartAddress;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &(PVOID)pNewAllocation,
                                     0,
                                     &DynCache.MinCommit,
                                     MEM_COMMIT,
                                     PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        //
        // Commit failed.  Free the reserve and bail.
        //
ErrorFreeReserve:
        RegionSize = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &(PVOID)DynCache.StartAddress,
                            &RegionSize,
                            MEM_RELEASE
                           );

        return FALSE;
    }
#if DBG
    //
    // Fill the TC with a unique illegal value, so we can distinguish
    // old code from new code and detect overwrites.
    //
    RtlFillMemoryUlong(DynCache.StartAddress, DynCache.MinCommit, DBG_FILL_VALUE);
#endif

    //
    // Copy the prolog from StartTranslatedCode into the start of the cache.
    //
    PrologSize = (LONG)(StartTranslatedCodePrologEnd - StartTranslatedCode);
    CPUASSERT(PrologSize >= 0 && PrologSize < MAX_PROLOG_SIZE);
    RtlCopyMemory(DynCache.StartAddress, StartTranslatedCode, PrologSize);


    //
    // Notify the exception unwinder that this memory is going to contain
    // executable code.
    //
    DynCacheFunctionTable.BeginAddress = (UINT_PTR)DynCache.StartAddress;
    DynCacheFunctionTable.EndAddress = (UINT_PTR)(DynCache.StartAddress + DynCache.MaxSize);
    DynCacheFunctionTable.ExceptionHandler = NULL;
    DynCacheFunctionTable.HandlerData = NULL;
    DynCacheFunctionTable.PrologEndAddress = (UINT_PTR)(DynCache.StartAddress + MAX_PROLOG_SIZE);
    if (RtlAddFunctionTable(&DynCacheFunctionTable, 1) == FALSE) {
        goto ErrorFreeReserve;
    }

    //
    // Adjust the DynCache.StartAddress up by MAX_PROLOG_SIZE so cache
    // flushes don't erase it.
    //
    DynCache.StartAddress += MAX_PROLOG_SIZE;

    fTCInitialized = TRUE;
    return TRUE;
}


PCHAR
AllocateFromCache(
    PCACHEINFO Cache,
    ULONG Size
    )
/*++

Routine Description:

    Allocate space within a Translation Cache.  If there is insufficient
    space, the allocation will fail.

Arguments:

    Cache           - Data about the cache
    Size            - Size of the allocation request, in bytes
    
Return Value:

    Pointer to DWORD-aligned memory of 'Size' bytes.  NULL if insufficient
    space.

--*/
{
    PBYTE Address;

    // Ensure parameters and cache state are acceptable
    CPUASSERTMSG((Cache->NextIndex & 3)==0, "Cache not DWORD aligned");
    CPUASSERTMSG(Cache->NextIndex == 0 || *(DWORD *)&Cache->StartAddress[Cache->NextIndex-4] != DBG_FILL_VALUE, "Cache Corrupted");
    CPUASSERT(Cache->NextIndex == Cache->CommitIndex || *(DWORD *)&Cache->StartAddress[Cache->NextIndex] == DBG_FILL_VALUE);

    if ((Cache->NextIndex + Size) >= Cache->MaxSize) {
        //
        // Not enough space in the cache.
        //
        return FALSE;
    }

    Address = &Cache->StartAddress[Cache->NextIndex];
    Cache->NextIndex += Size;

    if (Cache->NextIndex > Cache->CommitIndex) {
        //
        // Need to commit more of the cache
        //

        LONGLONG RegionSize;
        NTSTATUS Status;
        PVOID pAllocation;
        ULONG CommitTime = NtGetTickCount();

        if (Cache->LastCommitTime) {
            if ((CommitTime-Cache->LastCommitTime) < CpuCacheGrowTicks) {
                //
                // Commits are happening too frequently.  Bump up the size of
                // each commit.
                //
                if (Cache->ChunkSize < CpuCacheChunkMax) {
                    Cache->ChunkSize *= 2;
                }
            } else if ((CommitTime-Cache->LastCommitTime) > CpuCacheShrinkTicks) {
                //
                // Commits are happening too slowly.  Reduce the size of each
                // Commit.
                //
                if (Cache->ChunkSize > CpuCacheChunkMin) {
                    Cache->ChunkSize /= 2;
                }
            }
        }

        RegionSize = Cache->ChunkSize;
        if (RegionSize < Size) {
            //
            // The commit size is smaller than the requested allocation.
            // Commit enough to satisfy the allocation plus one more like it.
            //
            RegionSize = Size*2;
        }
        if (RegionSize+Cache->CommitIndex >= Cache->MaxSize) {
            //
            // The ChunkSize is larger than the remaining free space in the
            // cache.  Use whatever space is left.
            //
            RegionSize = Cache->MaxSize - Cache->CommitIndex;
        }
        pAllocation = &Cache->StartAddress[Cache->CommitIndex];

        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         &pAllocation,
                                         0,
                                         &RegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            //
            // Commit failed.  Caller may flush the caches in order to
            // force success (as the static cache has no commit).
            //
            return NULL;
        }

        CPUASSERT((pAllocation == (&Cache->StartAddress[Cache->CommitIndex])))
        
#if DBG
        //
        // Fill the TC with a unique illegal value, so we can distinguish
        // old code from new code and detect overwrites.
        //
        RtlFillMemoryUlong(&Cache->StartAddress[Cache->CommitIndex],
                           RegionSize,
                           DBG_FILL_VALUE
                          );
#endif
        Cache->CommitIndex += RegionSize;
        Cache->LastCommitTime = CommitTime;

    }

    return Address;
}


VOID
FlushCache(
    PCACHEINFO Cache
    )
/*++

Routine Description:

    Flush out a Translation Cache.

Arguments:

    Cache - cache to flush
    
Return Value:

    .

--*/
{
    NTSTATUS Status;
    ULONGLONG RegionSize;
    PVOID pAllocation;

    //
    // Only decommit pages if the current commit size is >= the size
    // we want to shrink to.  It may not be that big if somebody called
    // CpuFlushInstructionCache() before the commit got too big.
    //
    if (Cache->CommitIndex > Cache->MinCommit) {
        Cache->LastCommitTime = NtGetTickCount();

        RegionSize = Cache->CommitIndex - Cache->MinCommit;
        pAllocation = &Cache->StartAddress[Cache->MinCommit];
        Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                     &pAllocation,
                                     &RegionSize,
                                     MEM_DECOMMIT);
        if (!NT_SUCCESS(Status)) {
            LOGPRINT((ERRORLOG, "NtFreeVM(%x, %x) failed %x\n",
                    &Cache->StartAddress[Cache->MinCommit],
                    Cache->CommitIndex - Cache->MinCommit,
                    Status));
            ProxyDebugBreak();
        }
        CPUASSERTMSG(NT_SUCCESS(Status), "Failed to decommit TranslationCache chunk");

        Cache->CommitIndex = Cache->MinCommit;
    }

#if DBG
    //
    // Fill the Cache with a unique illegal value, so we can
    // distinguish old code from new code and detect overwrites.
    //
    RtlFillMemoryUlong(Cache->StartAddress, Cache->CommitIndex, DBG_FILL_VALUE);
#endif

    Cache->NextIndex = 0;
}


PCHAR
AllocateTranslationCache(
    ULONG Size
    )
/*++

Routine Description:

    Allocate space within the Translation Cache.  If there is insufficient
    space, the cache will be flushed.  Allocations are guaranteed to
    succeed.

Arguments:

    Size            - Size of the allocation request, in bytes
    
Return Value:

    Pointer to DWORD-aligned memory of 'Size' bytes.  Always non-NULL.

--*/
{
    PCHAR Address;

    //
    // Check parameters
    //
    CPUASSERT(Size <= CpuCacheReserve);
    CPUASSERTMSG((Size & 3) == 0, "Requested allocation size DWORD-aligned")

    //
    // Make sure there is only one thread with access to the translation
    // cache.
    //
    CPUASSERT( (MrswTC.Counters.WriterCount > 0 && MrswTC.WriterThreadId == ProxyGetCurrentThreadId()) ||
               (MrswEP.Counters.WriterCount > 0 && MrswEP.WriterThreadId == ProxyGetCurrentThreadId()) );

    //
    // Try to allocate from the cache
    //
    Address = AllocateFromCache(&DynCache, Size);
    if (!Address) {
        //
        // Translation cache is full - time to flush Translation Cache
        // (Both Dyn and Stat caches go at once).
        //
#ifdef CODEGEN_PROFILE            
        DumpAllocFailure();
#endif
        FlushTranslationCache(0, 0xffffffff);
        Address = AllocateFromCache(&DynCache, Size);
        CPUASSERT(Address); // Alloc from cache after a flush
    }

    return Address;
}

VOID
FreeUnusedTranslationCache(
    PCHAR StartOfFree
    )
/*++

Routine Description:

    After allocating from the TranlsationCache, a caller can free the tail-
    end of the last allocation.

Arguments:

    StartOfFree -- address of first unused byte in the last allocation
    
Return Value:

    .

--*/
{
    CPUASSERT(StartOfFree > (PCHAR)DynCache.StartAddress &&
              StartOfFree < (PCHAR)DynCache.StartAddress + DynCache.NextIndex);

    DynCache.NextIndex = StartOfFree - DynCache.StartAddress;
}



VOID
FlushTranslationCache(
    PVOID IntelAddr,
    DWORD IntelLength
    )
/*++

Routine Description:

    Indicates that a range of Intel memory has changed and that any
    native code in the cache which corresponds to that Intel memory is stale
    and needs to be flushed.

    The caller *must* have the EP write lock before calling.  This routine
    locks the TC for write, then unlocks the TC when done.

    IntelAddr = 0, IntelLength = 0xffffffff guarantees the entire cache is
    flushed.

Arguments:

    IntelAddr   -- Intel address of the start of the range to flush
    IntelLength -- Length (in bytes) of memory to flush
    
Return Value:

    .

--*/
{
    if (IntelLength == 0xffffffff ||
        IsIntelRangeInCache(IntelAddr, IntelLength)) {

        DECLARE_CPU;
        //
        // Tell active readers to bail out of the Translation Cache, then
        // get the TC write lock.  The MrswWriterEnter() call will block
        // until the last active reader leaves the cache.
        //
        InterlockedIncrement(&ProcessCpuNotify);
        MrswWriterEnter(&MrswTC);
        InterlockedDecrement(&ProcessCpuNotify);

        //
        // Bump the timestamp
        //
        TranslationCacheTimestamp++;
        
#ifdef CODEGEN_PROFILE
        //
        // Write the contents of the translation cache and entrypoints to 
        // disk.
        //
        DumpCodeDescriptions(TRUE);
        EPSequence = 0;
#endif        

        //
        // Flush the per-process data structures.  Per-thread data structures
        // should be flushed in the CpuSimulate() loop by examining the
        // value of TranslationCacheTimestamp.
        //
        FlushEntrypoints();
        FlushIndirControlTransferTable();
        FlushCallstack(cpu);
        FlushCache(&DynCache);
        TranslationCacheFlags = 0;

        //
        // Allow other threads to become TC readers again.
        //
        MrswWriterExit(&MrswTC);
    }
}

VOID
CpuFlushInstructionCache(
    PVOID IntelAddr,
    DWORD IntelLength
    )
/*++

Routine Description:

    Indicates that a range of Intel memory has changed and that any
    native code in the cache which corresponds to that Intel memory is stale
    and needs to be flushed.

    IntelAddr = 0, IntelLength = 0xffffffff guarantees the entire cache is
    flushed.

Arguments:

    IntelAddr   -- Intel address of the start of the range to flush
    IntelLength -- Length (in bytes) of memory to flush
    
Return Value:

    .

--*/
{
    if (!fTCInitialized) {
        // we may be called before the CpuProcessInit() has been run if
        // a Dll is mapped because of a forwarder from one Dll to another.
        return;
    }

    MrswWriterEnter(&MrswEP);
    FlushTranslationCache(IntelAddr, IntelLength);
    MrswWriterExit(&MrswEP);
}


VOID
CpuStallExecutionInThisProcess(
    VOID
    )
/*++

Routine Description:

    Get all threads out of the Translation Cache and into a state where
    their x86 register sets are accessible via the Get/SetReg APIs.
    The caller is guaranteed to call CpuResumeExecutionInThisProcess()
    a short time after calling this API.

Arguments:

    None.
    
Return Value:

    None.  This API may wait for a long time if there are many threads, but
    it is guaranteed to return.

--*/
{
    //
    // Prevent additional threads from compiling code.
    //
    MrswWriterEnter(&MrswEP);

    //
    // Tell active readers to bail out of the Translation Cache, then
    // get the TC write lock.  The MrswWriterEnter() call will block
    // until the last active reader leaves the cache.
    //
    InterlockedIncrement(&ProcessCpuNotify);
    MrswWriterEnter(&MrswTC);
    InterlockedDecrement(&ProcessCpuNotify);
}


VOID
CpuResumeExecutionInThisProcess(
    VOID
    )
/*++

Routine Description:

    Allow threads to start running inside the Translation Cache again.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    //
    // Allow other threads to become EP and TC writers again.
    //
    MrswWriterExit(&MrswEP);
    MrswWriterExit(&MrswTC);
}


BOOL
AddressInTranslationCache(
    DWORD Address
    )
/*++

Routine Description:

    Determines if a RISC address is within the bounds of the Translation
    Cache.

Arguments:

    Address     -- Address to examine
    
Return Value:

    TRUE if Address is within the Translation Cache
    FALSE if not.

--*/
{
    PBYTE ptr = (PBYTE)Address;

    if (
        ((ptr >= DynCache.StartAddress) &&
         (ptr <= DynCache.StartAddress+DynCache.NextIndex))
    ) {
        ASSERTPtrInTC(ptr);
        return TRUE;
    }

    return FALSE;
}


#if DBG
VOID
ASSERTPtrInTC(
    PVOID ptr
)
/*++

Routine Description:

    (Checked-build-only).  CPUASSERTs if a particular native address pointer
    does not point into the Translation Cache.

Arguments:

    ptr             - native pointer in question
    
Return Value:

    none - either asserts or returns

--*/
{
    // Verify pointer is DWORD aligned.
    CPUASSERT(((LONGLONG)ptr & 3) == 0);


    if (
        (((PBYTE)ptr >= DynCache.StartAddress) && 
        ((PBYTE)ptr <= DynCache.StartAddress+DynCache.NextIndex))
    ) {
    
        // Verify the pointer points into allocated space in the cache
        CPUASSERT(*(PULONG)ptr != DBG_FILL_VALUE);
    
        return;
    }

    CPUASSERTMSG(FALSE, "Pointer is not within a Translation Cache");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\compiler\dumpcd.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    dumpcd.c

Abstract:

    This module dumps the contents of the 
    entrypoint tree and translation cache to a file.

Author:

    Dave Hastings (daveh) creation-date 02-May-1996

Revision History:


--*/

#ifdef CODEGEN_PROFILE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <entrypt.h>
#include <coded.h>

extern PEPNODE intelRoot;
extern EPNODE _NIL;

ULONG ProfileFlags = 0;

BOOL
ProcessEntrypoint(
    PENTRYPOINT Entrypoint
    );


#define CODE_BUFFER_SIZE 8184
UCHAR IntelCodeBuffer[CODE_BUFFER_SIZE];
ULONG NativeCodeBuffer[CODE_BUFFER_SIZE];

#define STACK_DEPTH 200

ULONG DumpStack[STACK_DEPTH];
ULONG DumpStackTop;

#define STACK_RESET()   DumpStackTop=0;

#define PUSH(x) {                                               \
    if (DumpStackTop == STACK_DEPTH-1) {                        \
        CHAR ErrorString[80];                                   \
        sprintf(ErrorString, "Error: Dump stack overflow\n");   \
        OutputDebugString(ErrorString);                         \
        goto Exit;                                              \
    } else {                                                    \
        DumpStack[DumpStackTop] = x;                            \
        DumpStackTop++;                                         \
    }                                                           \
}

#define POP(x) {                                                \
    if (DumpStackTop == 0) {                                    \
        CHAR ErrorString[80];                                   \
        sprintf(ErrorString, "Error: Dump stack underflow\n");  \
        OutputDebugString(ErrorString);                         \
        goto Exit;                                              \
    } else {                                                    \
        DumpStackTop--;                                         \
        x = DumpStack[DumpStackTop];                            \
    }                                                           \
}


BOOL CpuCodegenProfile = FALSE;
PCHAR CpuCodegenProfilePath = NULL;
HANDLE CpuCodegenProfileFile = INVALID_HANDLE_VALUE;

//
// Code Description file state
//
ULONG CurrentFileLocation;
ULONG CodeDescriptionFlags = 0;

VOID
InitCodegenProfile(
    VOID
    )
/*++

Routine Description:

    This routine gets the configuration information from the registry
    and creates the file to put the profile data into.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    LONG RetVal;
    DWORD KeyType;
    DWORD ProfileEnabled;
    DWORD BufferSize;
    CHAR FileName[MAX_PATH];
    LPTSTR CommandLine;
    CODEDESCRIPTIONHEADER Header;
    ULONG CommandLineLength;
    ULONG BytesWritten;
    BOOL Success;
    HKEY Key;
    
    //
    // Find out if codegen profiling is enabled.  If there is a problem
    // with the value in the registry, we will be disabled by default.
    //
    
    RetVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\Wx86",
        0,        
        KEY_READ,
        &Key
        );

    BufferSize = sizeof(ProfileEnabled);
    
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfile",
        NULL,
        &KeyType,
        (PVOID)&ProfileEnabled,
        &BufferSize
        );
    
    if ((RetVal != ERROR_SUCCESS) || (KeyType != REG_DWORD)) {
        OutputDebugString("Wx86Cpu: No CpuCodegenProfile value, or wrong type\n");
        return;
    }
    
    CpuCodegenProfile = ProfileEnabled;
    
    //
    // Get the path to store the datafile to.
    // First we get the size of the string (and verify that it is a string)
    // Then we get the actual string.
    //
    BufferSize = 0;
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfilePath",
        NULL,
        &KeyType,
        (PVOID)&ProfileEnabled,
        &BufferSize
        );
        
    if ((RetVal != ERROR_MORE_DATA) || (KeyType != REG_SZ)) {
        OutputDebugString("Wx86Cpu: Problem with CpuCodegenProfilePath\n");
        CpuCodegenProfile = FALSE;
        return;
    }
    
    CpuCodegenProfilePath = HeapAlloc(GetProcessHeap(), 0, BufferSize);
    
    if (CpuCodegenProfilePath == NULL) {
        OutputDebugString("Wx86Cpu: Can't allocate CpuCodegenProfilePath\n");
        CpuCodegenProfile = FALSE;
        return;
    }
    
    RetVal = RegQueryValueEx(
        Key,
        "CpuCodegenProfilePath",
        NULL,
        &KeyType,
        CpuCodegenProfilePath,
        &BufferSize
        );
        
    if ((RetVal != ERROR_SUCCESS) || (KeyType != REG_SZ)) {
        //
        // Something really bad just happened.  Don't do the profiling
        //
        OutputDebugString("Wx86Cpu: Inexplicable problem with CpuCodegenProfilePath\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Create file for the data
    //
    RetVal = GetTempFileName(CpuCodegenProfilePath, "prf", 0, FileName);
    
    if (RetVal == 0) {
        OutputDebugString("Wx86Cpu: GetTempFileName failed\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    CpuCodegenProfileFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        0,
        NULL,
        TRUNCATE_EXISTING,
        FILE_ATTRIBUTE_COMPRESSED,
        NULL
        );
        
    if (CpuCodegenProfileFile == INVALID_HANDLE_VALUE) {
        OutputDebugString("Wx86Cpu: Unable to create profile file\n");
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Write the file header to the file
    //
    CommandLine = GetCommandLine();
    CommandLineLength = strlen(CommandLine) + 1;
    Header.CommandLineOffset = sizeof(CODEDESCRIPTIONHEADER);
    Header.NextCodeDescriptionOffset = ((sizeof(CODEDESCRIPTIONHEADER) + 
         CommandLineLength) + 3) & ~3;
    Header.DumpFileRev = CODEGEN_PROFILE_REV;
    Header.StartTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile, 
        &Header, 
        sizeof(Header), 
        &BytesWritten,
        NULL
        );
        
    if (!Success || (BytesWritten != sizeof(Header))) {
        OutputDebugString("Wx86Cpu: Failed to write profile header\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        CommandLine,
        CommandLineLength,
        &BytesWritten,
        NULL
        );
        
    if (!Success || (BytesWritten != CommandLineLength)) {
        OutputDebugString("Wx86Cpu: Failed to write profile header\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
    
    //
    // Set the file position for the first code description
    //
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        Header.NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != Header.NextCodeDescriptionOffset) {
        OutputDebugString("Wx86Cpu: failed to update file position\n");
        CloseHandle(CpuCodegenProfileFile);
        HeapFree(GetProcessHeap(), 0, CpuCodegenProfilePath);
        CpuCodegenProfile = FALSE;
        return;
    }
}

VOID
TerminateCodegenProfile(
    VOID
    )
/*++

Routine Description:

    This function put in the terminating record and closes the file.

Arguments:

    None
    
Return Value:

    None.

--*/
{
    CODEDESCRIPTION CodeDescription;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    
    if (!CpuCodegenProfile) {
        return;
    }
    CodeDescription.NextCodeDescriptionOffset = 0xFFFFFFFF;
    CodeDescription.TypeTag = PROFILE_TAG_EOF;
    CodeDescription.CreationTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write termination record, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
    }
    
    CpuCodegenProfile = FALSE;
    CloseHandle(CpuCodegenProfileFile);
    
}

VOID 
DumpCodeDescriptions(
    BOOL TCFlush
    )
/*++

Routine Description:

    This routine dumps out the entrypoints, and the corresponding code
    to a file in binary form.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PEPNODE NextEntrypoint;
    EPNODE Entrypoint;
    ULONG Epcount = 0;
    
    if (!CpuCodegenProfile) {
        return;
    }
    
    //
    // Get the root of the entrypoint tree
    //
    NextEntrypoint = intelRoot;
    
    //
    // Initialize stack
    //
    STACK_RESET();
    PUSH(0);
    
    //
    // iterate over every entrypoint
    //
    while (NextEntrypoint != NULL) {
        Entrypoint = *NextEntrypoint;
        
        //
        // Process the top level entrypoint
        //
        if (!ProcessEntrypoint(&Entrypoint.ep)){
            goto Exit;
        }
                
        //
        // Process the sub entrypoints
        //
        while (Entrypoint.ep.SubEP) {
            Entrypoint.ep = *Entrypoint.ep.SubEP;
            
            //
            // Write the sub-entrypoint to the file
            //
            if (!ProcessEntrypoint(&Entrypoint.ep)){
                goto Exit;
            }
        }
            
        //
        // Set up for future iterations
        //
        if (Entrypoint.intelRight != &_NIL) {
            PUSH((ULONG)Entrypoint.intelRight);
        }
        
        if (Entrypoint.intelLeft != &_NIL) {
            PUSH((ULONG)Entrypoint.intelLeft);
        }
        
        POP((ULONG)NextEntrypoint);
    }
    
Exit: ;
    if (TCFlush) {
        CODEDESCRIPTION CodeDescription;
        ULONG NextCodeDescriptionOffset;
        BOOL Success;
        ULONG BytesWritten;
        CHAR ErrorString[80];
        
        NextCodeDescriptionOffset = (CurrentFileLocation + sizeof(CODEDESCRIPTION)) & ~3;
        CodeDescription.TypeTag = PROFILE_TAG_TCFLUSH;
        CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
        CodeDescription.CreationTime = GetCurrentTime();
        
        Success = WriteFile(
            CpuCodegenProfileFile,
            &CodeDescription,
            sizeof(CODEDESCRIPTION),
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
            sprintf(
                ErrorString,
                "Error:  Could not write code description, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return;
        }
        
        CurrentFileLocation = SetFilePointer(
            CpuCodegenProfileFile,
            NextCodeDescriptionOffset,
            NULL,
            FILE_BEGIN
            );
            
        if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
            sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
            OutputDebugString(ErrorString);
            return;
        }
    }    
}

BOOL
ProcessEntrypoint(
    PENTRYPOINT Entrypoint
    )
/*++

Routine Description:

    This routine writes the description for this entrypoint to the file.

Arguments:

    Entrypoint -- Supplies the entrypoint to describe
    File -- Supplies the file to write to
    
Return Value:

    True for success, False for failure
    
--*/
{
    ULONG NativeCodeLength, IntelCodeLength;
    CODEDESCRIPTION CodeDescription;
    ULONG NextCodeDescriptionOffset;
    NTSTATUS Status;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    
    //
    // Create the code description
    //
    NativeCodeLength = ((ULONG)Entrypoint->nativeEnd - (ULONG)Entrypoint->nativeStart + 4) & ~3;
    IntelCodeLength = (ULONG)Entrypoint->intelEnd - (ULONG)Entrypoint->intelStart + 1;
    CodeDescription.NativeCodeOffset = CurrentFileLocation + sizeof(CODEDESCRIPTION);
    CodeDescription.IntelCodeOffset = CodeDescription.NativeCodeOffset + NativeCodeLength;
    NextCodeDescriptionOffset = (CodeDescription.IntelCodeOffset + 
        IntelCodeLength + 3) & ~3;
    CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    CodeDescription.IntelAddress = (ULONG)Entrypoint->intelStart;
    CodeDescription.NativeAddress = (ULONG)Entrypoint->nativeStart;
    CodeDescription.SequenceNumber = Entrypoint->SequenceNumber;
    CodeDescription.ExecutionCount = Entrypoint->ExecutionCount;
    CodeDescription.IntelCodeSize = IntelCodeLength;
    CodeDescription.NativeCodeSize = NativeCodeLength;
    CodeDescription.TypeTag = PROFILE_TAG_CODEDESCRIPTION;
    CodeDescription.CreationTime = Entrypoint->CreationTime;
        
    //
    // Verify that we can get all of the Intel and Native code
    //
    if (
        (IntelCodeLength / sizeof(IntelCodeBuffer[1]) > CODE_BUFFER_SIZE) ||
        (NativeCodeLength) && (NativeCodeLength / sizeof(NativeCodeBuffer[1]) > CODE_BUFFER_SIZE)
    ) {
        sprintf(ErrorString, "Error: Code buffers not big enough:N %lx:I %lx\n", NativeCodeLength, IntelCodeLength);
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Get the native code
    //
    if (NativeCodeLength) {
        memcpy(NativeCodeBuffer, Entrypoint->nativeStart, NativeCodeLength);
    }    
    
    //
    // Get the Intel code
    //
    try {
        memcpy(IntelCodeBuffer, Entrypoint->intelStart, IntelCodeLength);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Apparently the intel code is no longer there.  This happens
        // if a dll gets unloaded
        //
        IntelCodeLength = 0;
        CodeDescription.IntelCodeSize = 0;
        CodeDescription.IntelCodeOffset = CodeDescription.NativeCodeOffset + NativeCodeLength;
        NextCodeDescriptionOffset = (CodeDescription.IntelCodeOffset + 
            IntelCodeLength + 3) & ~3;
        CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    }
    
    //
    // Write code description to disk
    //
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write code description, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Write Native code to disk
    //
    if (NativeCodeLength) {
        Success = WriteFile(
            CpuCodegenProfileFile,
            NativeCodeBuffer,
            NativeCodeLength,
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != NativeCodeLength)) {
            sprintf(
                ErrorString,
                "Error:  Could not write native code, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return FALSE;
        }
    }
    
    //
    // Write Intel code to disk
    //
    if (IntelCodeLength) {
        Success = WriteFile(
            CpuCodegenProfileFile,
            IntelCodeBuffer,
            IntelCodeLength,
            &BytesWritten,
            NULL
            );
        if (!Success || (BytesWritten != IntelCodeLength)) {
            sprintf(
                ErrorString,
                "Error:  Could not write native code, %lu\n",
                ProxyGetLastError()
                );
            OutputDebugString(ErrorString);
            return FALSE;
        }
    }
    Success = WriteFile(
        CpuCodegenProfileFile,
        IntelCodeBuffer,
        IntelCodeLength,
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != IntelCodeLength)) {
        sprintf(
            ErrorString,
            "Error:  Could not write native code, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    //
    // Update file pointer position
    // 
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
        sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
        OutputDebugString(ErrorString);
        return FALSE;
    }
    
    return TRUE;
}

VOID
DumpAllocFailure(
    VOID
    )
/*++

Routine Description:

    This routine adds an allocation failure record to the profile dump.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    CODEDESCRIPTION CodeDescription;
    BOOL Success;
    ULONG BytesWritten;
    CHAR ErrorString[80];
    ULONG NextCodeDescriptionOffset;

    if (!CpuCodegenProfile) {
        return;
    }
    NextCodeDescriptionOffset = CurrentFileLocation + sizeof(CODEDESCRIPTION);
    CodeDescription.NextCodeDescriptionOffset = NextCodeDescriptionOffset;
    CodeDescription.TypeTag = PROFILE_TAG_TCALLOCFAIL;
    CodeDescription.CreationTime = GetCurrentTime();
    
    Success = WriteFile(
        CpuCodegenProfileFile,
        &CodeDescription,
        sizeof(CODEDESCRIPTION),
        &BytesWritten,
        NULL
        );
    if (!Success || (BytesWritten != sizeof(CODEDESCRIPTION))) {
        sprintf(
            ErrorString,
            "Error:  Could not write termination record, %lu\n",
            ProxyGetLastError()
            );
        OutputDebugString(ErrorString);
    }
    
    //
    // Update file pointer position
    // 
    CurrentFileLocation = SetFilePointer(
        CpuCodegenProfileFile,
        NextCodeDescriptionOffset,
        NULL,
        FILE_BEGIN
        );
        
    if (CurrentFileLocation != (ULONG)NextCodeDescriptionOffset) {
        sprintf(ErrorString, "Error:  SetFilePointer didn't work\n");
        OutputDebugString(ErrorString);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\cpumain\cpumain.c ===
/*++
                                                                                
Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    cpumain.c

Abstract:
    
    This module implements the public interface to the CPU.
    
Author:

    03-Jul-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "instr.h"
#include "threadst.h"
#include "cpunotif.h"
#include "cpuregs.h"
#include "entrypt.h"
#include "compiler.h"
#include "instr.h"
#include "frag.h"
#include "entrypt.h"
#include "mrsw.h"
#include "tc.h"
#include "cpumain.h"
#include "wx86.h"
#include "atomic.h"
#ifdef CODEGEN_PROFILE
#include <coded.h>
#endif
#include "wow64t.h"
#include <wow64.h>

ASSERTNAME;

//
// Identify the CPU type for the debugger extensions
//
WX86_CPUTYPE Wx86CpuType = Wx86CpuCpu;

//
// Per-process CpuNotify bits.  These are different than the per-thread
// bits.
//
DWORD ProcessCpuNotify;


NTSTATUS
MsCpuProcessInit(
    VOID
    )
/*++

Routine Description:

    Initialize the CPU.  Must be called once at process initialization.

Arguments:

    None

Return Value:

    None

--*/
{
#if 0
    DbgBreakPoint();
#endif

    //
    // Read all configuration data from the registry
    //
    GetConfigurationData();

    MrswInitializeObject(&MrswEP);
    MrswInitializeObject(&MrswTC);
    MrswInitializeObject(&MrswIndirTable);

    if (!InitializeTranslationCache()) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!initEPAlloc()) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Entry Point allocator initialization failed"));
#endif
        return STATUS_UNSUCCESSFUL;
    }

    if (!initializeEntryPointModule()) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Entry Point module initialization failed"));
#endif
        return STATUS_UNSUCCESSFUL;
    }
#if 0
    if (!(Wx86LockSynchMutexHandle = CreateMutex(NULL, FALSE, "Wx86LockSynchMutex"))) {
#if DBG
        LOGPRINT((TRACELOG, "CpuProcessInit: Cannot create Wx86LockSynchMutex"));
#endif
        return STATUS_UNSUCCESSFUL;
    }
#endif
    RtlInitializeCriticalSection(&Wx86LockSynchCriticalSection);

    SynchObjectType = USECRITICALSECTION;

#ifdef CODEGEN_PROFILE
    InitCodegenProfile();
#endif

    return STATUS_SUCCESS;
}

BOOL
MsCpuProcessTerm(
    BOOL OFlyInit
    )
{
#if 0
    NtClose(Wx86LockSynchMutexHandle);
    termEPAlloc();
#endif
    return TRUE;
}



BOOL
MsCpuThreadInit(
    VOID
    )
/*++

Routine Description:

    Initialize the CPU.  Must be called once for each thread.

Arguments:

    None.

Return Value:

    TRUE if successful initialization, FALSE if init failed.

--*/
{
    DWORD StackBase;
    PTEB32 Teb32 = WOW64_GET_TEB32(NtCurrentTeb());
    DECLARE_CPU;

    if (!FragLibInit(cpu, Teb32->NtTib.StackBase)) {
        return FALSE;
    }

    //
    // Mark the callstack as valid
    //
    cpu->CSTimestamp = TranslationCacheTimestamp;

    //
    // Mark the TC as being unlocked
    //
    cpu->fTCUnlocked = TRUE;

    //
    // All done.
    //
    return TRUE;
}



VOID
CpuResetToConsistentState(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    Called by WX86 when the exception filter around CpuSimulate() fires.

Arguments:

    pExceptionPointers - state of the thread at the time the exception
                         occurred.

Return Value:

    None

--*/
{
    DECLARE_CPU;

    if (!cpu->fTCUnlocked) {
        //
        // We must unlock the TC before continuing
        //
        MrswReaderExit(&MrswTC);
        cpu->fTCUnlocked = TRUE;

        //
        // Call the compiler to deduce where Eip should be pointing
        // based on the RISC exception record.  It is called with
        // the Entrypoint write lock because it calls the compiler.
        // The compiler's global vars are usable only with EP write.
        //
        MrswWriterEnter(&MrswEP);
        GetEipFromException(cpu, pExceptionPointers);
        MrswWriterExit(&MrswEP);
    }
    Wow64TlsSetValue(WOW64_TLS_EXCEPTIONADDR, LongToPtr(cpu->eipReg.i4));
}


VOID
CpuPrepareToContinue(
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    Called by WX86 prior to resuming execution on EXCEPTION_CONTINUE_EXECUTION

Arguments:

    pExceptionPointers - alpha context with which execution will be resumed.

Return Value:

    None

--*/
{
}

BOOLEAN
CpuMapNotify(
    PVOID DllBase,
    BOOLEAN Mapped
    )
/*++

Routine Description:

    Called by WX86 when an x86 DLL is loaded or unloaded.

Arguments:

    DllBase -- address where x86 DLL was loaded.
    Mapped  -- TRUE if x86 DLL was just mapped in, FALSE if DLL is just about
               to be unmapped.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    if (Mapped) {
        NTSTATUS st;
        MEMORY_BASIC_INFORMATION mbi;
        ULONG Length;

        st = NtQueryVirtualMemory(NtCurrentProcess(),
                                  DllBase,
                                  MemoryBasicInformation,
                                  &mbi,
                                  sizeof(mbi),
                                  NULL);
        if (NT_SUCCESS(st)) {
            Length = (ULONG)mbi.RegionSize;
        } else {
            // Flush the whole translation cache
            DllBase = 0;
            Length = 0xffffffff;
        }

        CpuFlushInstructionCache(DllBase, Length);
    }
    return TRUE;
}


VOID
CpuEnterIdle(
    BOOL OFly
    )
/*++

Routine Description:

    Called by WX86 when Wx86 ofly is going idle, or when Wx86 is out of
    memory and needs some pages.  The CPU must free as many resources
    as possible.

Arguments:

    OFly    - TRUE if called from on-the-fly, FALSE if called due to
              out of memory.

Return Value:

    None.

--*/
{
    CpuFlushInstructionCache(0, 0xffffffff);
}

BOOL
CpuIsProcessorFeaturePresent(
    DWORD ProcessorFeature
    )
/*++

Routine Description:

    Called by whkrnl32!whIsProcessorFeaturePresent().  The CPU gets to
    fill in its own feature set.

Arguments:

    ProcessorFeature    -- feature to query (see winnt.h PF_*)

Return Value:

    TRUE if feature present, FALSE if not.

--*/
{
    BOOL fRet;

    switch (ProcessorFeature) {
    case PF_FLOATING_POINT_PRECISION_ERRATA:
    case PF_COMPARE_EXCHANGE_DOUBLE:
    case PF_MMX_INSTRUCTIONS_AVAILABLE:
        fRet = FALSE;
        break;

    case PF_FLOATING_POINT_EMULATED:
        //
        // TRUE when winpxem.dll used to emulate floating-point with x86
        // integer instructions.
        //
        fRet = fUseNPXEM;
        break;

    default:
        //
        // Look up the native feature set
        //
        fRet = ProxyIsProcessorFeaturePresent(ProcessorFeature);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\cpumain\wowprxy.c ===
/*++
                                                                                
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wowprxy.c

Abstract:
    
    This module implements pxoxy interfaces not inplemented yet.
    
Author:

    24-Aug-1999 askhalid

Revision History:

    29-Jan-2000  SamerA  Added CpupDoInterrupt and CpupRaiseException

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <errno.h>

#define _WOW64CPUAPI_
#define _WX86CPUAPI_
#include "wx86.h"

#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"

ASSERTNAME;

PVOID _HUGE;
CONFIGVAR CpuConfigData;



NTSTATUS
CpupDoInterrupt(
    IN DWORD InterruptNumber)
/*++

Routine Description:

    This routine simulates an x86 software interrupt.

Arguments:

    InterruptNumber  - Interrupt number to simulate

Return Value:

    NTSTATUS
--*/
{
    return Wow64RaiseException(InterruptNumber, NULL);
}


NTSTATUS
CpupRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord)
{
    return Wow64RaiseException(-1L, ExceptionRecord);
}



PCONFIGVAR
Wx86FetchConfigVar(
   PWSTR VariableName
   )
{
    return NULL;
}

VOID
Wx86FreeConfigVar(
   PCONFIGVAR ConfigVar
   )
{
}

VOID
Wx86RaiseStatus(
    NTSTATUS Status
    )
{
    EXCEPTION_RECORD ExRec;
    DECLARE_CPU;

    ExRec.ExceptionCode    = Status;
    ExRec.ExceptionFlags   = EXCEPTION_NONCONTINUABLE;
    ExRec.ExceptionRecord  = NULL;
    ExRec.ExceptionAddress = (PVOID)cpu->eipReg.i4;
    ExRec.NumberParameters = 0;
    
    CpupRaiseException(&ExRec);
}

void
Wx86DispatchBop(
    PBOPINSTR Bop
    )
{
    CONTEXT32 Context;
    DECLARE_CPU;

    Context.ContextFlags = CONTEXT_CONTROL_WX86|CONTEXT_INTEGER_WX86;
    MsCpuGetContext(&Context);

    cpu->Eax.i4=Wow64SystemService(cpu->Eax.i4,
                                   &Context);
}

BOOL
ProxyIsProcessorFeaturePresent (
    DWORD ProcessorFeature
    )
{
    BOOL rv;

    if ( ProcessorFeature < PROCESSOR_FEATURE_MAX ) {
        rv = (BOOL)(USER_SHARED_DATA->ProcessorFeatures[ProcessorFeature]);
        }
    else {
        rv = FALSE;
        }
    return rv;
}



VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG s,d; 
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = NULL;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG)lpArguments;
        d = (PULONG)ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }

    
    CpupRaiseException(&ExceptionRecord);

}



VOID
SetMathError ( 
              int Code 
              )
{
    int *_errno();
    *_errno() = Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\cpumain\wowrap.c ===
/*++
                                                                                
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    wowrap.c

Abstract:
    
    This module implements some wrapper (on wx86cpu) functions wow64 might call.
    
Author:

    24-Aug-1999 askhalid

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WOW64CPUAPI_
#define _WX86CPUAPI_
#define __WOW64_WRAPPER__

#include "wx86.h"
#include "wow64.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"
#include "instr.h"
#include "compiler.h"
#include "wow64cpu.h"

ASSERTNAME;

typedef struct _WowBopInstr {
    BOPINSTR Wx86Bop;
    BYTE Ret;
} WOWBOPINSTR;

WOWBOPINSTR Bop;

 
NTSTATUS 
CpuProcessInit(PSIZE_T pCpuThreadDataSize)
{
    NTSTATUS st;

    memset ( (char *)&Bop, 0, sizeof (Bop) );
    Bop.Wx86Bop.Instr1 = 0xc4;
    Bop.Wx86Bop.Instr2 = 0xc4;
    Bop.Ret    = 0xc3;   // ret

    st = MsCpuProcessInit();

    *pCpuThreadDataSize = sizeof(CPUCONTEXT);

    return st;

}

NTSTATUS 
CpuProcessTerm(VOID)
{
    return 0;
}




NTSTATUS 
CpuThreadInit(PVOID pPerThreadData) 
{
    PTEB32 Teb32 = NtCurrentTeb32();

    //
    // Initialize the pointer to the DoSystemService function.
    Teb32->WOW32Reserved = (ULONG)(LONGLONG)&Bop;

    if ( MsCpuThreadInit()) {
        return 0;
    }

    return STATUS_SEVERITY_ERROR;  //return right value
}

//
// Execution 
//
VOID 
CpuSimulate(VOID)
{
    MsCpuSimulate(NULL);
}

//
// Exception handling, context manipulation
//
/* already been defined
VOID  
CpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers)
{


}*/


NTSTATUS  
CpuGetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PCONTEXT32 Context)
/*++

Routine Description:

    Extracts the cpu context of the specified thread. If the target thread isn't the currently
    executing thread, then it should be guaranteed by the caller that the target thread 
    is suspended at a proper CPU state.
    Context->ContextFlags decides which IA32 register-set to retreive.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    //Context->ContextFlags = CONTEXT_FULL_WX86;
    if (NtCurrentThread() == ThreadHandle)
    {
        return MsCpuGetContext(Context);
    }

    return MsCpuGetContextThread(ProcessHandle,
                                 Teb,
                                 Context);
}


NTSTATUS
CpuSetContext(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    PCONTEXT32 Context)
/*++

Routine Description:

    Sets the cpu context for the specified thread. If the target thread isn't the currently
    executing thread, then it should be guaranteed by the caller that the target thread is 
    suspended at a proper CPU state.
    Context->ContextFlags decides which IA32 register-set to be set.

Arguments:

    ThreadHandle   - Target thread handle to retreive the context for
    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{

    //Context->ContextFlags = CONTEXT_FULL_WX86;  // make sure wow return the right flags
    if (NtCurrentThread() == ThreadHandle)
    {
        return MsCpuSetContext(Context);
    }
    
    return MsCpuSetContextThread(ProcessHandle,
                                 Teb,
                                 Context);
}
 
 


 
ULONG 
CpuGetStackPointer ( )
// create a wrapper that calls the Wx86 CPU's GetEsp
{
    DECLARE_CPU;
    return GetEsp(cpu);
} 

VOID 
CpuNotifyDllLoad ( 
    LPWSTR DllName, 
    PVOID DllBase, 
    ULONG DllSize 
    )
// - create a wrapper on the Wx86 CPU's CpuMapNotify
{
        CpuMapNotify( DllBase, TRUE );
}


VOID 
CpuNotifyDllUnload ( 
    PVOID DllBase  
    )
//  - create a wrapper on the Wx86 CPU's CpuMapNotify
{
    CpuMapNotify( DllBase, FALSE );
}

VOID  
CpuSetInstructionPointer (
    ULONG Value
    )
//- wrapper on SetEip
{
    DECLARE_CPU;

    SetEip( cpu, Value);
}

VOID
CpuSetStackPointer (
    ULONG val
    ) 
//  - wrapper on SetEsp
{
    DECLARE_CPU;

    SetEsp(cpu, val);
}

NTSTATUS 
CpuThreadTerm(VOID)
//- just create an empty stub function - the Wx86 CPU doesn't care about this
{
 return 0;
}

/*
LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32 //This is read only!
    )

*/

DWORD
ProxyWowDispatchBop( 
    ULONG ServiceNumber,
    PCONTEXT_WX86 px86Context,
    PULONG ArgBase
    )
{
    LONG ret=0;

    //CONTEXT32 _Context32;
    //_Context32.Edx = (ULONG)(ULONGLONG)ArgBase;  //this is the only field wow64 using

    if ( px86Context != NULL )
        ret = Wow64SystemService ( ServiceNumber, px86Context );
    return ret;

    //[bb] The wow64 equivalent is Wow64SystemService.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\dbgexts\w64cpuex.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w64cpuex.c

Abstract:

    Debugger extension DLL for debugging the CPU

Author:

    27-Sept-1999 BarryBo

Revision History:


--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>
#include "ntosdef.h"
#include "v86emul.h"
#include "ia64.h"
#include "wow64.h"
#include "wow64cpu.h"

#define MSCPU
#include "threadst.h"
#include "entrypt.h"
#include "config.h"
#include "instr.h"
#include "compiler.h"
#include "cpunotif.h"
#include "cpuregs.h"

/* Masks for bits 0 - 32. */
#define BIT0         0x1
#define BIT1         0x2
#define BIT2         0x4
#define BIT3         0x8
#define BIT4        0x10
#define BIT5        0x20
#define BIT6        0x40
#define BIT7        0x80
#define BIT8       0x100
#define BIT9       0x200
#define BIT10      0x400
#define BIT11      0x800
#define BIT12     0x1000
#define BIT13     0x2000
#define BIT14     0x4000
#define BIT15     0x8000
#define BIT16    0x10000
#define BIT17    0x20000
#define BIT18    0x40000
#define BIT19    0x80000
#define BIT20   0x100000
#define BIT21   0x200000
#define BIT22   0x400000
#define BIT23   0x800000
#define BIT24  0x1000000
#define BIT25  0x2000000
#define BIT26  0x4000000
#define BIT27  0x8000000
#define BIT28 0x10000000
#define BIT29 0x20000000
#define BIT30 0x40000000
#define BIT31 0x80000000

BOOL AutoFlushFlag = TRUE;

HANDLE Process;
HANDLE Thread;
PNTSD_OUTPUT_ROUTINE OutputRoutine;
PNTSD_GET_SYMBOL GetSymbolRoutine;
PNTSD_GET_EXPRESSION  GetExpression;
PWOW64GETCPUDATA CpuGetData;
LPSTR ArgumentString;

#define DEBUGGERPRINT (*OutputRoutine)
#define GETSYMBOL (*GetSymbolRoutine)
#define GETEXPRESSION (*GetExpression)
#define CPUGETDATA (*CpuGetData)

// Local copy of the current process/thread's CPU state
PVOID RemoteCpuData;
THREADSTATE LocalCpuContext;
BOOL ContextFetched;
BOOL ContextDirty;

// Cached addresses of interesting symbols within the CPU
HANDLE CachedProcess;
ULONG_PTR pCompilerFlags;
ULONG_PTR pTranslationCacheFlags;
ULONG_PTR pDirtyMemoryAddr;
ULONG_PTR pDirtyMemoryLength;

ULONG GetEfl(VOID);
VOID SetEfl(ULONG);

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
CONST BYTE ParityBit[] = {
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
};


/*
 * Does a plain old GetExpression under a try-except
 */
NTSTATUS
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        *pValue = GETEXPRESSION(Expression);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}


VOID
InvalidateSymbolsIfNeeded(
    VOID
    )
{
    if (CachedProcess == Process) {
        // The symbols match the current process
        return;
    }
    // else the symbols were for another process.  Invalidate the cache.
    pCompilerFlags = 0;
    pTranslationCacheFlags = 0;
    pDirtyMemoryAddr = 0;
    pDirtyMemoryLength = 0;
    CachedProcess = Process;
}


DWORD
GetCompilerFlags(void)
{
    NTSTATUS Status;
    DWORD CompilerFlags;

    InvalidateSymbolsIfNeeded();

    if (!pCompilerFlags) {
        Status = TryGetExpr("CompilerFlags", (ULONG_PTR *)&pCompilerFlags);
        if (!NT_SUCCESS(Status) || !pCompilerFlags) {
            DEBUGGERPRINT("Unable to get address of CompilerFlags Status %x\n",
                    Status
                   );
            pCompilerFlags = 0;
            return 0xffffffff;
        }
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pCompilerFlags, &CompilerFlags, sizeof(DWORD), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read CompilerFlags Status %x\n", Status);
        return 0xffffffff;
    }

    return CompilerFlags;
}

void
SetCompilerFlags(DWORD CompilerFlags)
{
    NTSTATUS Status;

    InvalidateSymbolsIfNeeded();

    if (!pCompilerFlags) {
        Status = TryGetExpr("CompilerFlags", (ULONG_PTR *)&pCompilerFlags);
        if (!NT_SUCCESS(Status) || !pCompilerFlags) {
            DEBUGGERPRINT("Unable to get address of CompilerFlags Status %x\n",
                    Status
                   );
            pCompilerFlags = 0;
            return;
        }
    }

    Status = NtWriteVirtualMemory(Process, (PVOID)pCompilerFlags, &CompilerFlags, sizeof(DWORD), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to writes CompilerFlags Status %x\n", Status);
        return;
    }
}

NTSTATUS
GetDirtyMemoryRange(PULONG DirtyMemoryAddr, PULONG DirtyMemoryLength)
{
    NTSTATUS Status;
    ULONG DirtyMemoryEnd;

    InvalidateSymbolsIfNeeded();

    if (pDirtyMemoryLength == 0) {
        //
        // First call to CpuFlushInstructionCache() - need to set up
        // the global variables.
        //

        Status = TryGetExpr("DbgDirtyMemoryAddr", (ULONG_PTR *)&pDirtyMemoryAddr);
        if (!NT_SUCCESS(Status) || !pDirtyMemoryAddr) {
            DEBUGGERPRINT("Unable to get address of DbgDirtyMemoryAddr Status %x\n",
                    Status
                   );
            return Status;
        }

        Status = TryGetExpr("DbgDirtyMemoryLength", (ULONG_PTR *)&pDirtyMemoryLength);
        if (!NT_SUCCESS(Status) || !pDirtyMemoryLength) {
            DEBUGGERPRINT("Unable to get address of DbgDirtyMemoryLength Status %x\n",
                    Status
                   );
            return Status;
        }
    }

    Status = NtReadVirtualMemory(Process,
                        (PVOID)pDirtyMemoryAddr,
                        DirtyMemoryAddr,
                        sizeof(ULONG),
                        NULL
                        );
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read pDirtyMemoryAddr %x Status %x\n",
                pDirtyMemoryAddr,
                Status
               );
        return Status;
    }

    Status = NtReadVirtualMemory(Process,
                        (PVOID)pDirtyMemoryLength,
                        DirtyMemoryLength,
                        sizeof(ULONG),
                        NULL
                        );
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read pDirtyMemoryLength %x Status %x\n",
                pDirtyMemoryLength,
                Status
               );
        pDirtyMemoryLength = 0;
        return Status;
    }

    return Status;
}




void
RemindUserToFlushTheCache(void)
{
    NTSTATUS Status;
    DWORD TranslationCacheFlags;
    DWORD CompilerFlags;
    BOOLEAN fCacheFlushPending;

    //
    // Read the value of TranslationCacheFlags
    //
    if (!pTranslationCacheFlags) {
        Status = TryGetExpr("TranslationCacheFlags", (ULONG_PTR *)&pTranslationCacheFlags);
        if (!NT_SUCCESS(Status) || !pTranslationCacheFlags) {
            DEBUGGERPRINT("Unable to get address of TranslationCacheFlags Status %x\n",
                    Status
                   );
            return;
        }
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pTranslationCacheFlags, &TranslationCacheFlags, sizeof(TranslationCacheFlags), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Unable to read TranslationCacheFlags Status %x\n", Status);
        return;
    }

    //
    // Read the value of CompilerFlags
    //
    CompilerFlags = GetCompilerFlags();
    if (CompilerFlags == 0xffffffff) {
        //
        // Got an error getting the CompilerFlags value.
        //
        return;
    }

    //
    // Determine if the Translation Cache is going to be flushed next time
    // the CPU runs or not.
    //
    fCacheFlushPending =
        (LocalCpuContext.CpuNotify & CPUNOTIFY_MODECHANGE) ? TRUE : FALSE;
    if (!fCacheFlushPending && (LocalCpuContext.CpuNotify & CPUNOTIFY_DBGFLUSHTC)) {
        DWORD Addr, Length;
        Status = GetDirtyMemoryRange(&Addr, &Length);
        if (!NT_SUCCESS(Status)) {
            return;
        }
        if (Addr == 0 && Length == 0xffffffff) {
            //
            // Cache flush is pending because user asked for !flush
            //
            fCacheFlushPending = TRUE;
        }
    }

    //
    // Give the user some worldly advice
    //
    if (LocalCpuContext.CpuNotify & (CPUNOTIFY_TRACEFLAG|CPUNOTIFY_SLOWMODE)) {
        //
        // We need to be in slow mode to get logging to work.
        //
        if (CompilerFlags & COMPFL_FAST) {
            //
            // Cpu is set to generate fast code.  Remedy that.
            //
            if (AutoFlushFlag) {
                SetCompilerFlags(COMPFL_SLOW);
            } else {
                DEBUGGERPRINT("CPU in fast mode.  Use '!wx86e.code SLOW' to switch to slow mode.\n");
            }
        }
        if (!fCacheFlushPending && (TranslationCacheFlags & COMPFL_FAST)) {
            //
            // Translation Cache contains fast code.  Rememdy that.
            //
            if (AutoFlushFlag) {
                LocalCpuContext.CpuNotify |= CPUNOTIFY_MODECHANGE;
                ContextDirty = TRUE;
            } else {
                DEBUGGERPRINT("Translation Cache contains fast code.  Use '!wx86e.flush' to flush,\n");
                DEBUGGERPRINT("or the CPU will probably jump somewhere unexpected.\n");
            }
        }

        if (fCacheFlushPending && TranslationCacheFlags == COMPFL_SLOW) {
            //
            // If there is a cache flush pending due to a switch in
            // compilation modes, but the code in the cache is already
            // correct, undo the cache flush
            //
            LocalCpuContext.CpuNotify &= ~(ULONG)CPUNOTIFY_MODECHANGE;
            ContextDirty = TRUE;
        }
    } else {
        //
        // We can run in fast mode.
        //
        if (CompilerFlags & COMPFL_SLOW) {
            //
            // Cpu is set to generate slow code.  Remedy that.
            //
            if (AutoFlushFlag) {
                SetCompilerFlags(COMPFL_FAST);
            } else {
                DEBUGGERPRINT("CPU in slow mode.  Use '!wx86e.code FAST' to switch to fast mode.\n");
            }
        }
        if (!fCacheFlushPending && (TranslationCacheFlags & COMPFL_SLOW)) {
            //
            // Translation Cache contains slow code.  Remedy that.
            //
            if (AutoFlushFlag) {
                LocalCpuContext.CpuNotify |= CPUNOTIFY_MODECHANGE;
                ContextDirty = TRUE;
            } else {
                DEBUGGERPRINT("Translation Cache contains slow code.  Use '!wx86e.flush' to flush.\n");
            }
        }

        if (fCacheFlushPending && TranslationCacheFlags == COMPFL_FAST) {
            //
            // If there is a cache flush pending due to a switch in
            // compilation modes, but the code in the cache is already
            // correct, undo the cache flush
            //
            LocalCpuContext.CpuNotify &= ~(ULONG)CPUNOTIFY_MODECHANGE;
            ContextDirty = TRUE;
        }
    }
}



WOW64CPUDBGAPI VOID
CpuDbgInitExtapi(
    HANDLE hArgProcess,
    HANDLE hArgThread,
    DWORD64 ArgCurrentPC,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    PWOW64GETCPUDATA lpGetData
    )
{
    Process = hArgProcess;
    Thread = hArgThread;
    OutputRoutine = lpExtensionApis->lpOutputRoutine;
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;
    CpuGetData = lpGetData;

    InvalidateSymbolsIfNeeded();
    ContextFetched = FALSE;
    ContextDirty = FALSE;
}


WOW64CPUDBGAPI BOOL
CpuDbgGetRemoteContext(
    PVOID CpuData
    )
{
    NTSTATUS Status;

    Status = NtReadVirtualMemory(Process,
                                 CpuData,
                                 &LocalCpuContext,
                                 sizeof(LocalCpuContext),
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("CpuDbgGetRemoteContext:  Error %x reading CPU data from %x\n", Status, CpuData);
        return FALSE;
    }

    ContextFetched = TRUE;
    RemoteCpuData = CpuData;

    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgSetRemoteContext(
    void
    )
{
    NTSTATUS Status;

    if (!ContextDirty) {
        // Perf. optimization... don't update the remote context if
        // nothing has changed.
        return TRUE;
    }

    if (!ContextFetched) {
        DEBUGGERPRINT("CpuDbgSetRemoteContext:  Remote context was never fetched!\n");
        return FALSE;
    }

    Status = NtWriteVirtualMemory(Process,
                                 RemoteCpuData,
                                 &LocalCpuContext,
                                 sizeof(LocalCpuContext),
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("CpuDbgSetRemoteContext:  Error %x writing CPU data to %x\n", Status, RemoteCpuData);
        return FALSE;
    }

    ContextDirty = FALSE;

    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgGetLocalContext(
    PCONTEXT32 Context
    )
{
    ULONG ContextFlags = Context->ContextFlags;
    PTHREADSTATE cpu = &LocalCpuContext;

    if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) {

        Context->EFlags = GetEfl();
        Context->SegCs  = CS;
        Context->Esp    = esp;
        Context->SegSs  = SS;
        Context->Ebp    = ebp;
        Context->Eip    = eip;
        //Context->Eip    = cpu->eipReg.i4;
    }

    if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) {
        Context->SegGs = GS;
        Context->SegFs = FS;
        Context->SegEs = ES;
        Context->SegDs = DS;
    }

    if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) {
        Context->Eax = eax;
        Context->Ebx = ebx;
        Context->Ecx = ecx;
        Context->Edx = edx;
        Context->Edi = edi;
        Context->Esi = esi;
    }

#if 0
    if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) {
    }

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS_WX86) == CONTEXT_DEBUG_REGISTERS_WX86) {
    }

    if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS_WX86) == CONTEXT_EXTENDED_REGISTERS_WX86) {
    }
#endif
    return TRUE;
}

WOW64CPUDBGAPI BOOL
CpuDbgSetLocalContext(
    PCONTEXT32 Context
    )
{
    ULONG ContextFlags = Context->ContextFlags;
    PTHREADSTATE cpu = &LocalCpuContext;

    if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) {
        //
        // i386 control registers are:
        // ebp, eip, cs, eflag, esp and ss
        //
        LocalCpuContext.GpRegs[GP_EBP].i4 = Context->Ebp;
        LocalCpuContext.eipReg.i4 = Context->Eip;
        LocalCpuContext.GpRegs[REG_CS].i4= KGDT_R3_CODE|3;   // Force Reality
        SetEfl(Context->EFlags);
        LocalCpuContext.GpRegs[GP_ESP].i4 = Context->Esp;
        LocalCpuContext.GpRegs[REG_SS].i4 = KGDT_R3_DATA|3;   // Force Reality
        ContextDirty = TRUE;
    }

    if ((ContextFlags & CONTEXT_INTEGER_WX86)  == CONTEXT_INTEGER_WX86){
        //
        // i386 integer registers are:
        // edi, esi, ebx, edx, ecx, eax
        //
        LocalCpuContext.GpRegs[GP_EDI].i4 = Context->Edi;
        LocalCpuContext.GpRegs[GP_ESI].i4 = Context->Esi;
        LocalCpuContext.GpRegs[GP_EBX].i4 = Context->Ebx;
        LocalCpuContext.GpRegs[GP_EDX].i4 = Context->Edx;
        LocalCpuContext.GpRegs[GP_ECX].i4 = Context->Ecx;
        LocalCpuContext.GpRegs[GP_EAX].i4 = Context->Eax;
        ContextDirty = TRUE;
    }

    if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) {
        //
        // i386 segment registers are:
        // ds, es, fs, gs
        // And since they are a constant, force them to be the right values
        //
        LocalCpuContext.GpRegs[REG_DS].i4 = KGDT_R3_DATA|3;
        LocalCpuContext.GpRegs[REG_ES].i4 = KGDT_R3_DATA|3;
        LocalCpuContext.GpRegs[REG_FS].i4 = KGDT_R3_TEB|3;
        LocalCpuContext.GpRegs[REG_GS].i4 = KGDT_R3_DATA|3;
        ContextDirty = TRUE;
    }

#if 0
    if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) {
    }

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS_WX86) == CONTEXT_DEBUG_REGISTERS_WX86) {
    }

    if ((ContextFlags & CONTEXT_EXTENDED_REGISTERS_WX86) == CONTEXT_EXTENDED_REGISTERS_WX86) {
    }
#endif

    return TRUE;
}

WOW64CPUDBGAPI VOID
CpuDbgFlushInstructionCache(
    PVOID Addr,
    DWORD Length
    )
{
    NTSTATUS Status;
    ULONG DirtyMemoryEnd;
    ULONG DirtyMemoryAddr;
    ULONG DirtyMemoryLength;

    Status = GetDirtyMemoryRange(&DirtyMemoryAddr, &DirtyMemoryLength);
    if (!NT_SUCCESS(Status)) {
        return;
    }
    if (DirtyMemoryAddr == 0xffffffff) {
        DirtyMemoryEnd = 0;
    } else {
        DirtyMemoryEnd = DirtyMemoryAddr + DirtyMemoryLength;
    }

    if (PtrToUlong(Addr) < DirtyMemoryAddr) {
        //
        // The new address is before the start of the dirty range
        //
        DirtyMemoryLength += DirtyMemoryAddr-PtrToUlong(Addr);
        DirtyMemoryAddr = PtrToUlong(Addr);
    }

    if (PtrToUlong(Addr)+Length > DirtyMemoryEnd) {
        //
        // The range is too small - grow it
        //
        DirtyMemoryEnd = PtrToUlong(Addr)+Length;
        DirtyMemoryLength = DirtyMemoryEnd - DirtyMemoryAddr;
    }

    // Tell the CPU to call CpuFlushInstructionCache() next time it runs.
    //
    // The wow64 debugger extension guarantees that it will call
    // DbgCpuGetRemoteContext before this call, and will call
    // DbgCpuSetRemoteContext after this call, so we can flush out
    // our context then.
    //
    NtWriteVirtualMemory(Process, (PVOID)pDirtyMemoryAddr, &DirtyMemoryAddr, sizeof(ULONG), NULL);
    NtWriteVirtualMemory(Process, (PVOID)pDirtyMemoryLength, &DirtyMemoryLength, sizeof(ULONG), NULL);
    LocalCpuContext.CpuNotify |= CPUNOTIFY_DBGFLUSHTC;
    ContextDirty = TRUE;
}

VOID SetEax(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EAX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEbx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EBX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEcx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ECX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEdx(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EDX].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEsi(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ESI].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEdi(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EDI].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEbp(ULONG ul) {
    LocalCpuContext.GpRegs[GP_EBP].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEsp(ULONG ul) {
    LocalCpuContext.GpRegs[GP_ESP].i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEip(ULONG ul) {
    LocalCpuContext.eipReg.i4 = ul;
    ContextDirty = TRUE;
}
VOID SetEfl(ULONG ul) {
    LocalCpuContext.flag_cf = (ul & BIT0) ? 0x80000000 : 0;
    LocalCpuContext.flag_pf = (ul & BIT2) ? 0 : 1;
    LocalCpuContext.flag_aux= (ul & BIT4) ? 0x10 : 0;
    LocalCpuContext.flag_zf = (ul & BIT6) ? 0 : 1;
    LocalCpuContext.flag_sf = (ul & BIT7) ? 0x80000000 : 0;
    LocalCpuContext.flag_tf = (ul & BIT8) ? 1 : 0;
    LocalCpuContext.flag_df = (ul & BIT10) ? 1 : -1;
    LocalCpuContext.flag_of = (ul & BIT11) ? 0x80000000 : 0;
    // iopl, NT, RF, VM are ignored
    LocalCpuContext.flag_ac = (ul & BIT18);

    LocalCpuContext.CpuNotify &= ~CPUNOTIFY_TRACEFLAG;
    LocalCpuContext.CpuNotify |= LocalCpuContext.flag_tf;
    ContextDirty = TRUE;

    // If the single-step flag is set and the CPU is in fast mode, this
    // will flush the cache if autoflush is set, or else remind the user
    // if autoflush is clear.
    RemindUserToFlushTheCache();
}

ULONG GetEax(VOID) {
    return LocalCpuContext.GpRegs[GP_EAX].i4;
}
ULONG GetEbx(VOID) {
    return LocalCpuContext.GpRegs[GP_EBX].i4;
}
ULONG GetEcx(VOID) {
    return LocalCpuContext.GpRegs[GP_ECX].i4;
}
ULONG GetEdx(VOID) {
    return LocalCpuContext.GpRegs[GP_EDX].i4;
}
ULONG GetEsi(VOID) {
    return LocalCpuContext.GpRegs[GP_ESI].i4;
}
ULONG GetEdi(VOID) {
    return LocalCpuContext.GpRegs[GP_EDI].i4;
}
ULONG GetEsp(VOID) {
    return LocalCpuContext.GpRegs[GP_ESP].i4;
}
ULONG GetEbp(VOID) {
    return LocalCpuContext.GpRegs[GP_EBP].i4;
}
ULONG GetEip(VOID) {
    return LocalCpuContext.eipReg.i4;
}
ULONG GetEfl(VOID) {
    return (LocalCpuContext.flag_ac  |          // this is either 0 or 2^18
            // VM, RF, NT are all 0
            ((LocalCpuContext.flag_of & 0x80000000) ? (1 << 11) : 0) |
            ((LocalCpuContext.flag_df == -1) ? 0 : (1 << 10)) |
            1 <<  9 |    // IF
            LocalCpuContext.flag_tf <<  8 |
            ((LocalCpuContext.flag_sf & 0x80000000) ? (1 <<  7) : 0) |
            ((LocalCpuContext.flag_zf) ? 0 : (1 << 6)) |
            ((LocalCpuContext.flag_aux & 0x10) ? (1 << 4) : 0) |
            ParityBit[LocalCpuContext.flag_pf & 0xff] <<  2 |
            0x2 |
            ((LocalCpuContext.flag_cf & 0x80000000) ? 1 : 0)
            );
}

CPUREGFUNCS CpuRegFuncs[] = {
    { "eax", SetEax, GetEax },
    { "ebx", SetEbx, GetEbx },
    { "ecx", SetEcx, GetEcx },
    { "edx", SetEdx, GetEdx },
    { "esi", SetEsi, GetEsi },
    { "edi", SetEdi, GetEdi },
    { "esp", SetEsp, GetEsp },
    { "ebp", SetEbp, GetEbp },
    { "eip", SetEip, GetEip },
    { "efl", SetEfl, GetEfl },
    { NULL, NULL, NULL}
};

WOW64CPUDBGAPI PCPUREGFUNCS
CpuDbgGetRegisterFuncs(
    void
    )
{
    return CpuRegFuncs;
}

#define DECLARE_EXTAPI(name)                    \
VOID                                            \
name(                                           \
    HANDLE hCurrentProcess,                     \
    HANDLE hCurrentThread,                      \
    DWORD64 dwCurrentPc,                        \
    PNTSD_EXTENSION_APIS lpExtensionApis,       \
    LPSTR lpArgumentString                      \
    )

#define INIT_EXTAPI                             \
    Process = hCurrentProcess;                  \
    Thread = hCurrentThread;                    \
    OutputRoutine = lpExtensionApis->lpOutputRoutine;           \
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;     \
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;    \
    ArgumentString = lpArgumentString;


DECLARE_EXTAPI(help)
{
    INIT_EXTAPI;

    DEBUGGERPRINT("WOW64 MS CPU debugger extensions:\n\n");
    DEBUGGERPRINT("epi [inteladdress]   - dump an entrypt based on x86 address\n");
    DEBUGGERPRINT("epn [nativeaddress]  - dump an entrypt based on a native address\n");
    DEBUGGERPRINT("dumpep               - all entrypts\n");
    DEBUGGERPRINT("code [fast|slow]     - set the CPU's code-gen mode\n");
    DEBUGGERPRINT("flush                - flush the Translation Cache\n");
    DEBUGGERPRINT("autoflush            - the debugger extension may auto-flush the TC\n");
    DEBUGGERPRINT("logeip               - enable EIP logging\n");
    DEBUGGERPRINT("last                 - dump the last EIP values\n");
    DEBUGGERPRINT("callstack            - dump the internal callstack cache\n");
}



DECLARE_EXTAPI(autoflush)
{
    INIT_EXTAPI;

    if (AutoFlushFlag) {
        AutoFlushFlag = FALSE;
        DEBUGGERPRINT("autoflush is OFF - use !flush to flush the cache when needed.\n");
    } else {
        AutoFlushFlag = TRUE;
        DEBUGGERPRINT("autoflush is ON - The CPU Cache will be flushed automatically.\n");
    }
}

DECLARE_EXTAPI(code)
{
    DWORD CompilerFlags;

    INIT_EXTAPI;

    CompilerFlags = GetCompilerFlags();
    if (CompilerFlags == 0xffffffff) {
        //
        // Got an error reading the CompilerFlags variable
        //
        return;
    }

    if (!ArgumentString) {
PrintCurrentValue:
        DEBUGGERPRINT("CPU Compiler is in %s mode.\n",
                (CompilerFlags & COMPFL_SLOW) ? "SLOW" : "FAST");
        return;
    }

    // Skip over whitespace
    while (*ArgumentString && isspace(*ArgumentString)) {
        ArgumentString++;
    }
    if (!*ArgumentString) {
        goto PrintCurrentValue;
    }

    if (_stricmp(ArgumentString, "fast") == 0) {
        SetCompilerFlags(COMPFL_FAST);
    } else if (_stricmp(ArgumentString, "slow") == 0) {
        SetCompilerFlags(COMPFL_SLOW);
    } else {
        DEBUGGERPRINT("usage: !code [fast|slow]\n");
    }

    RemindUserToFlushTheCache();
}

DECLARE_EXTAPI(flush)
{
    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }
    CpuDbgFlushInstructionCache(0, 0xffffffff);
    CpuDbgSetRemoteContext();
    DEBUGGERPRINT("CPU Translation Cache will flush next time CpuSimulate loops.\n");
}


DECLARE_EXTAPI(logeip)
{
    ULONG CpuNotify;

    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    CpuNotify = LocalCpuContext.CpuNotify;

    if (CpuNotify & CPUNOTIFY_SLOWMODE) {
        CpuNotify &= ~CPUNOTIFY_SLOWMODE;
    } else {
        CpuNotify |= CPUNOTIFY_SLOWMODE;
    }

    LocalCpuContext.CpuNotify = CpuNotify;
    ContextDirty = TRUE;

    if (CpuDbgSetRemoteContext()) {
        DEBUGGERPRINT("EIP logging ");
        if (CpuNotify & CPUNOTIFY_SLOWMODE) {
           DEBUGGERPRINT("ON - use !last to see the EIP log.\n");
        } else {
           DEBUGGERPRINT("OFF.\n");
        }
    }
}

DECLARE_EXTAPI(last)
{
    ULONG CpuNotify;
    DWORD64 n;
    char *pchCmd;
    DWORD64 EipOffset, i;

    INIT_EXTAPI;

    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    // Parse out the optional number of instructions.  Default is all
    // instructions in the log
    n = 0xffffffff;
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
         pchCmd++;
    }

    if (*pchCmd) {
        NTSTATUS Status;

        Status = TryGetExpr(pchCmd, &n);
        if (!NT_SUCCESS(Status) || !n) {
             DEBUGGERPRINT("Invalid Length: '%s' Status %x\n",
                     pchCmd,
                     Status
                     );
             return;
        }
    }

    CpuNotify = LocalCpuContext.CpuNotify;
    if (!(CpuNotify & CPUNOTIFY_SLOWMODE)) {
        DEBUGGERPRINT("Warning: logeip is not enabled.  Log may be out-of-date.\n");
    }

    EipOffset = LocalCpuContext.eipLogIndex;
    if (n >= EIPLOGSIZE) {
        n = EIPLOGSIZE;
    } else {
        EipOffset -= n;
    }

    for (i = 0; i<n; ++i, ++EipOffset) {
        EipOffset %= EIPLOGSIZE;
        if (LocalCpuContext.eipLog[EipOffset] == 0) {
            break;
        }
        DEBUGGERPRINT("%x %x\n", i, LocalCpuContext.eipLog[EipOffset]);
    }
}


DECLARE_EXTAPI(callstack)
/*++

Routine Description:

    This routine dumps out the callstack for the thread.

Arguments:

    none
    
Return Value:

    None.

--*/
{
    ULONG i;

    INIT_EXTAPI;
 
    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    //
    // Dump out the call stack
    //
    DEBUGGERPRINT("        CallStackTimeStamp : %08lx\n", LocalCpuContext.CSTimestamp);
    DEBUGGERPRINT("            CallStackIndex : %08lx\n", LocalCpuContext.CSIndex);
    DEBUGGERPRINT("        -----------------------------\n");
    DEBUGGERPRINT("                     Intel : Native\n");
    
    for (i = 0; i < CSSIZE; i++) {
        DEBUGGERPRINT(
            "                  %08lx : %08lx\n", 
            LocalCpuContext.callStack[i].intelAddr,
            LocalCpuContext.callStack[i].nativeAddr
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\bytefns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bytefns.h

Abstract:
    
    Prototypes for instructions which operate on BYTES.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef BYTEFNS_H
#define BYTEFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 8)
#include "common.h"
#undef DISPATCHCOMMON

#endif //BYTEFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\dbgexts\entrypt.c ===
/*++
                                                                                
Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    entrypt.c

Abstract:
    
    Debugger extensions that give an entry point from either an
    intel address or a native address
    
Author:

    02-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#define _WOW64CPUDBGAPI_
#define DECLARE_CPU_DEBUGGER_INTERFACE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>
#include "ntosdef.h"
#include "v86emul.h"
#include "ia64.h"
#include "wow64.h"
#include "wow64cpu.h"
#include "threadst.h"
#include "entrypt.h"

extern HANDLE Process;
extern HANDLE Thread;
extern PNTSD_OUTPUT_ROUTINE OutputRoutine;
extern PNTSD_GET_SYMBOL GetSymbolRoutine;
extern PNTSD_GET_EXPRESSION  GetExpression;
extern PWOW64GETCPUDATA CpuGetData;
extern LPSTR ArgumentString;

#define DEBUGGERPRINT (*OutputRoutine)
#define GETSYMBOL (*GetSymbolRoutine)
#define GETEXPRESSION (*GetExpression)
#define CPUGETDATA (*CpuGetData)


extern THREADSTATE LocalCpuContext;
extern BOOL ContextFetched;
extern BOOL ContextDirty;


#define DECLARE_EXTAPI(name)                    \
VOID                                            \
name(                                           \
    HANDLE hCurrentProcess,                     \
    HANDLE hCurrentThread,                      \
    DWORD64 dwCurrentPc,                        \
    PNTSD_EXTENSION_APIS lpExtensionApis,       \
    LPSTR lpArgumentString                      \
    )

#define INIT_EXTAPI                             \
    Process = hCurrentProcess;                  \
    Thread = hCurrentThread;                    \
    OutputRoutine = lpExtensionApis->lpOutputRoutine;           \
    GetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;     \
    GetExpression = lpExtensionApis->lpGetExpressionRoutine;    \
    ArgumentString = lpArgumentString;


#if _ALPHA_
#define EXCEPTIONDATA_SIGNATURE 0x01010101
#else
#define EXCEPTIONDATA_SIGNATURE 0x12341234
#endif

// Assume we can have at most 1/2 million entrypoints in a tree:
//  With 4MB Translation Cache, we can have 1 million RISC instructions
//  in the cache.  Assume each Intel instruction requires 2 RISC instructions,
//  and that each Intel instruction has its own Entrypoint.  In that case,
//  there can be at most 1/2 million entrypoints.  Realistically, that number
//  should be much smaller (like 50,000).
//
// Also, since the Entrypoint tree is balanced (a property of Red-Black trees),
//  the required stack depth should be log2(500,000).
//
#define MAX_EPN_STACK_DEPTH 512*1024
ULONG_PTR EPN_Stack[MAX_EPN_STACK_DEPTH];
ULONG EPN_StackTop;
ULONG EPN_MaxStackDepth;

#define EPN_STACK_RESET()   EPN_StackTop=0; EPN_MaxStackDepth=0

#define EPN_PUSH(x) {                                       \
    if (EPN_StackTop == MAX_EPN_STACK_DEPTH-1) {            \
        DEBUGGERPRINT("Error: EPN stack overflow\n");             \
        goto Error;                                         \
    } else {                                                \
        EPN_Stack[EPN_StackTop] = x;                        \
        EPN_StackTop++;                                     \
        if (EPN_StackTop > EPN_MaxStackDepth) EPN_MaxStackDepth=EPN_StackTop; \
    }                                                       \
}

#define EPN_POP(x) {                                        \
    if (EPN_StackTop == 0) {                                \
        DEBUGGERPRINT("Error: EPN stack underflow\n");            \
        goto Error;                                         \
    } else {                                                \
        EPN_StackTop--;                                     \
        x = EPN_Stack[EPN_StackTop];                        \
    }                                                       \
}


NTSTATUS
TryGetExpr(
    PSTR  Expression,
    PULONG_PTR pValue
    );


VOID 
findEPI(
    ULONG_PTR intelAddress,
    ULONG_PTR intelRoot
    )
/*++

Routine Description:

    This routine finds an entry point which contains intelAddress if in the
    tree under intelRoot.

Arguments:

    intelAddress -- The intel address to be contained in the entry point
    
    intelRoot -- The root of the tree to use for the search

Return Value:

    return-value - none

--*/
{
    EPNODE entrypoint;
    NTSTATUS Status;

    for (;;) {
        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return;
        }

        if (intelRoot == (ULONG_PTR)entrypoint.intelLeft) {
            //
            // At a NIL node.
            //
            break;
        }

        if (intelAddress < (ULONG_PTR)entrypoint.ep.intelStart){
            intelRoot = (ULONG_PTR)entrypoint.intelLeft;
        } else if (intelAddress > (ULONG_PTR)entrypoint.ep.intelEnd) {
            intelRoot = (ULONG_PTR)entrypoint.intelRight;
        } else {
            DEBUGGERPRINT ("Entry point for intel address %x is at %x\n", intelAddress, intelRoot);
            DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", entrypoint.ep.intelStart, entrypoint.ep.intelEnd);
            DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", entrypoint.ep.nativeStart, entrypoint.ep.nativeEnd);
            return;
        }
    }

    DEBUGGERPRINT("Entry point corresponding to intel address %x is not in the tree.\n", intelAddress);
}

DECLARE_EXTAPI(epi)
/*++

Routine Description:

    This routine dumps the entry point information for an intel address

Arguments:

Return Value:

    return-value - none

--*/
{
    CHAR *pchCmd;
    ULONG_PTR intelAddress, pIntelRoot, intelRoot;
    NTSTATUS Status;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    DEBUGGERPRINT ("Argument: %s\n", ArgumentString);
    
    //
    // advance to first token
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    //
    // if exists must be intel address
    //
    if (*pchCmd) {
       Status = TryGetExpr(pchCmd, &intelAddress);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Invalid Intel Address '%s' Status %x\n", pchCmd, Status);
            return;
        }
    } else {
        // Take the current eip value as the first argument
        intelAddress = LocalCpuContext.eipReg.i4;
    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(intelRoot), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    findEPI(intelAddress, intelRoot);
}

ULONG_PTR
findEPN(
    ULONG_PTR nativeAddress,
    ULONG_PTR intelRoot
    )
/*++

Routine Description:

    This routine finds an entry point which contains nativeAddress if in the
    tree under intelRoot.

Arguments:

    nativeAddress -- The native address to be contained in the entry point
    
    intelRoot -- The root of the tree to use for the search

Return Value:

    return-value - NULL - entrypoint not found
                   non-NULL - ptr to ENTRYPOINT matching the native address

--*/
{
    EPNODE entrypoint;
    NTSTATUS Status;
    PVOID SubEP;

    EPN_STACK_RESET();

    EPN_PUSH(0);

    while (intelRoot != 0) {

        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return 0;
        }

        if ((nativeAddress >= (ULONG_PTR)entrypoint.ep.nativeStart) &&
            (nativeAddress <= (ULONG_PTR)entrypoint.ep.nativeEnd)) {

            DEBUGGERPRINT ("Entry point for native address %x is at %x\n", nativeAddress, intelRoot);
            DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", entrypoint.ep.intelStart, entrypoint.ep.intelEnd);
            DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", entrypoint.ep.nativeStart, entrypoint.ep.nativeEnd);
            return intelRoot;
        }

        // If there are sub-entrypoints, search them, too.
        SubEP = (PVOID)entrypoint.ep.SubEP;
        while (SubEP) {
            ENTRYPOINT ep;

            Status = NtReadVirtualMemory(Process, SubEP, (PVOID)(&ep), sizeof(ENTRYPOINT), NULL);
            if (!NT_SUCCESS(Status)) {
                DEBUGGERPRINT("Error:  cannot read value of sub-entry point at location %x\n", SubEP);
                return 0;
            }

            if ((nativeAddress >= (ULONG_PTR)ep.nativeStart) &&
                (nativeAddress <= (ULONG_PTR)ep.nativeEnd)) {
                DEBUGGERPRINT ("Entry point for native address %x is at %x\n", nativeAddress, intelRoot);
                DEBUGGERPRINT ("Sub-entrypoint actually containing the native address is %x\n", SubEP);
                DEBUGGERPRINT ("intelStart = %x,  intelEnd = %x\n", ep.intelStart, ep.intelEnd);
                DEBUGGERPRINT ("nativeStart  = %x,  nativeEnd  = %x\n", ep.nativeStart, ep.nativeEnd);
                return (ULONG_PTR)SubEP;
            }

            SubEP = ep.SubEP;
        }

        if ((ULONG_PTR)entrypoint.intelRight != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelRight);
        }
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelLeft);
        }

        EPN_POP(intelRoot);
    }

    DEBUGGERPRINT("Entry point corresponding to native address %x is not in the tree.\n", nativeAddress);
Error:
    return 0;
}

VOID
FindEipFromNativeAddress(
    ULONG_PTR nativeAddress,
    ULONG_PTR pEP
    )
{
    ENTRYPOINT EP;
    NTSTATUS Status;
    PVOID pUL;
    ULONG UL;
    ULONG RiscStart;
    ULONG RiscEnd;
    ULONG cEntryPoints;

    Status = NtReadVirtualMemory(Process, (PVOID)pEP, (PVOID)(&EP), sizeof(ENTRYPOINT), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", pEP);
        return;
    }

    //
    // Search forward to the next EXCEPTIONDATA_SIGNATURE in the cache
    //
    pUL = (PVOID)(((ULONG_PTR)EP.nativeEnd+3) & ~3);
    do {
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }

        pUL = (PVOID)( (PULONG)pUL + 1);
    } while (UL != EXCEPTIONDATA_SIGNATURE);

    //
    // Found the signature, get cEntryPoints
    //
    Status = NtReadVirtualMemory(Process, pUL, &cEntryPoints, sizeof(ULONG), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
        return;
    }
    pUL = (PVOID)( (PULONG)pUL + 1); // skip cEntryPoints

    while (1) {
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }

        if (UL == (ULONG)pEP) {
            //
            // Found the right ENTRYPOINT pointer
            //
            break;
        }

        //
        // Skip over the pairs of (x86, risc) offsets
        //
        do {
            pUL = (PVOID)( (PULONG)pUL + 1);
            Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
            if (!NT_SUCCESS(Status)) {
                DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
                return;
            }
        } while ((UL & 1) == 0);

        cEntryPoints--;
        if (cEntryPoints == 0) {
            DEBUGGERPRINT("Error: cEntryPoints went to 0 at %x\n", pUL);
            return;
        }

        pUL = (PVOID)( (PULONG)pUL + 1);
    }

    //
    // pUL points at the correct entrypoint pointer
    //
    nativeAddress -= (ULONG_PTR)EP.nativeStart; // Make relative to start of EP
    RiscStart = 0;                          // Also relative to start of EP
    while (1) {
        ULONG UL2;

        pUL = (PVOID)( (PULONG)pUL + 1);
        Status = NtReadVirtualMemory(Process, pUL, &UL, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %x\n", pUL);
            return;
        }
        if (UL & 1) {
            break;
        }

        Status = NtReadVirtualMemory(Process, (PVOID)((PULONG)pUL+1), &UL2, sizeof(ULONG), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error: error reading from TC at %p\n", (ULONG_PTR)pUL+4);
            return;
        }
        RiscEnd = LOWORD(UL2) & 0xfffe;  // RiscEnd = RiscStart of next instr
        if ((RiscStart <= nativeAddress && nativeAddress < RiscEnd)
            || (UL & 1)) {
            DEBUGGERPRINT("Corresponding EIP=%p\n", (ULONG_PTR)EP.intelStart + HIWORD(UL));
            return;
        }
    }

    return;

}

DECLARE_EXTAPI(epn)
/*++

Routine Description:

    This routine dumps the entry point information for a native address

Arguments:

Return Value:

    return-value - none

--*/
{
    CHAR *pchCmd;
    ULONG_PTR nativeAddress, pIntelRoot, intelRoot, EP;
    NTSTATUS Status;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    //
    // advance to first token
    //
    pchCmd = ArgumentString;
    while (*pchCmd && isspace(*pchCmd)) {
        pchCmd++;
    }

    //
    // if exists must be intel address
    //
    if (*pchCmd) {
        Status = TryGetExpr(pchCmd, &nativeAddress);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Invalid Native Address '%s' Status %x\n", pchCmd, Status);
            return;
        }
    } else {
        // Use the current pc as the host address
        CONTEXT context;
        if (!GetThreadContext(Thread, &context)){
            DEBUGGERPRINT("Error:  cannot get thread context\n");
            return;
        }
#if defined (_MIPS_) || defined (_ALPHA_)
        nativeAddress = (ULONG)context.Fir;
#elif defined (_PPC_)
        nativeAddress = context.Iar;
#endif


    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(ULONG_PTR), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    EP = findEPN(nativeAddress, intelRoot);
    if (EP) {
        FindEipFromNativeAddress(nativeAddress, EP);
    }
}

DECLARE_EXTAPI(dumpep)
/*++

Routine Description:

    This routine dumps all entrypoints.

Arguments:

Return Value:

    return-value - none

--*/
{
    ULONG_PTR pIntelRoot, intelRoot;
    NTSTATUS Status;
    EPNODE entrypoint;

    INIT_EXTAPI;

    //
    // fetch the CpuContext for the current thread
    //
    if (!CpuDbgGetRemoteContext(CPUGETDATA(Process, Thread))) {
        return;
    }

    Status = TryGetExpr("intelRoot", &pIntelRoot);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot evaluate intelRoot\n");
        return;
    }

    Status = NtReadVirtualMemory(Process, (PVOID)pIntelRoot, (PVOID) (&intelRoot), sizeof(intelRoot), NULL);
    if (!NT_SUCCESS(Status)) {
        DEBUGGERPRINT("Error:  cannot read value of intelRoot\n");
        return;
    }

    EPN_STACK_RESET();

    EPN_PUSH(0);

    DEBUGGERPRINT("Entrypt: iStart:  iEnd:    rStart:  rEnd:    SubEP:   iLeft:   iRight:\n");
    //       xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
    while (intelRoot != 0) {
        PENTRYPOINT ep;

        Status = NtReadVirtualMemory(Process, (PVOID)intelRoot, (PVOID) (&entrypoint), sizeof(EPNODE), NULL);
        if (!NT_SUCCESS(Status)) {
            DEBUGGERPRINT("Error:  cannot read value of entry point at location %x\n", intelRoot);
            return;
        }

        ep = &entrypoint.ep;

        //
        // Print all entrypoints except NIL.
        //
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot &&
            (ULONG_PTR)entrypoint.intelRight != intelRoot) {

            DEBUGGERPRINT("%8.8X %8.8X %8.8X %8.8X %8.8X %8.8X %8.8X %8.8X\n",
                    intelRoot,
                    ep->intelStart,
                    ep->intelEnd,
                    ep->nativeStart,
                    ep->nativeEnd,
                    ep->SubEP,
                    entrypoint.intelLeft,
                    entrypoint.intelRight
                   );

            while (ep->SubEP) {
                PVOID SubEP;

                SubEP = (PVOID)ep->SubEP;
                Status = NtReadVirtualMemory(Process, SubEP, (PVOID)ep, sizeof(ENTRYPOINT), NULL);
                if (!NT_SUCCESS(Status)) {
                    DEBUGGERPRINT("Error:  cannot read value of sub-entry point at location %x\n", SubEP);
                    return;
                }

                DEBUGGERPRINT("%8.8X %8.8X %8.8X %8.8X %8.8X %8.8X\n",
                    SubEP,
                    ep->intelStart,
                    ep->intelEnd,
                    ep->nativeStart,
                    ep->nativeEnd,
                    ep->SubEP
                   );


            }
        }

        if ((ULONG_PTR)entrypoint.intelRight != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelRight);
        }
        if ((ULONG_PTR)entrypoint.intelLeft != intelRoot) {
            EPN_PUSH((ULONG_PTR)entrypoint.intelLeft);
        }

        EPN_POP(intelRoot);
    }
    DEBUGGERPRINT("---- End of Entrypoint Dump ----\n");
Error:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\comm1632.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    comm1632.h

Abstract:
    
    Prototypes for instructions which operate on WORDS or DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef COMM1632_H checks.

DISPATCHCOMMON(dispatch2);
DISPATCHCOMMON(LOCKdispatch2);
DISPATCHCOMMON(pushf);
DISPATCHCOMMON(popf);
DISPATCHCOMMON(pusha);
DISPATCHCOMMON(popa);
DISPATCHCOMMON(push_iw);
DISPATCHCOMMON(push_ibs);
DISPATCHCOMMON(GROUP_1WS);
DISPATCHCOMMON(LOCKGROUP_1WS);
DISPATCHCOMMON(mov_rw_mw);
DISPATCHCOMMON(lea_rw_mw);
DISPATCHCOMMON(pop_mw);
DISPATCHCOMMON(xchg_ax_cx);
DISPATCHCOMMON(xchg_ax_dx);
DISPATCHCOMMON(xchg_ax_bx);
DISPATCHCOMMON(xchg_ax_sp);
DISPATCHCOMMON(xchg_ax_bp);
DISPATCHCOMMON(xchg_ax_si);
DISPATCHCOMMON(xchg_ax_di);
DISPATCHCOMMON(cbw);
DISPATCHCOMMON(cwd);
DISPATCHCOMMON(mov_sp_iw);
DISPATCHCOMMON(mov_bp_iw);
DISPATCHCOMMON(mov_si_iw);
DISPATCHCOMMON(mov_di_iw);
DISPATCHCOMMON(loopne_b);
DISPATCHCOMMON(loope_b);
DISPATCHCOMMON(loop_b);
DISPATCHCOMMON(jcxz_b);
DISPATCHCOMMON(GROUP_5);
DISPATCHCOMMON(GROUP_8);
DISPATCHCOMMON(LOCKGROUP_5);
DISPATCHCOMMON(LOCKGROUP_8);
DISPATCHCOMMON(bts_m_r);
DISPATCHCOMMON(btc_m_r);
DISPATCHCOMMON(btr_m_r);
DISPATCHCOMMON(LOCKbts_m_r);
DISPATCHCOMMON(LOCKbtc_m_r);
DISPATCHCOMMON(LOCKbtr_m_r);
DISPATCHCOMMON(bt_m_r);
DISPATCHCOMMON(jo_w);
DISPATCHCOMMON(jno_w);
DISPATCHCOMMON(jb_w);
DISPATCHCOMMON(jae_w);
DISPATCHCOMMON(je_w);
DISPATCHCOMMON(jne_w);
DISPATCHCOMMON(jbe_w);
DISPATCHCOMMON(ja_w);
DISPATCHCOMMON(js_w);
DISPATCHCOMMON(jns_w);
DISPATCHCOMMON(jp_w);
DISPATCHCOMMON(jnp_w);
DISPATCHCOMMON(jl_w);
DISPATCHCOMMON(jnl_w);
DISPATCHCOMMON(jle_w);
DISPATCHCOMMON(jg_w);
DISPATCHCOMMON(inc_ax);
DISPATCHCOMMON(inc_bx);
DISPATCHCOMMON(inc_dx);
DISPATCHCOMMON(inc_cx);
DISPATCHCOMMON(inc_sp);
DISPATCHCOMMON(inc_bp);
DISPATCHCOMMON(inc_si);
DISPATCHCOMMON(inc_di);
DISPATCHCOMMON(dec_ax);
DISPATCHCOMMON(dec_bx);
DISPATCHCOMMON(dec_cx);
DISPATCHCOMMON(dec_dx);
DISPATCHCOMMON(dec_sp);
DISPATCHCOMMON(dec_bp);
DISPATCHCOMMON(dec_si);
DISPATCHCOMMON(dec_di);
DISPATCHCOMMON(push_ax);
DISPATCHCOMMON(push_bx);
DISPATCHCOMMON(push_cx);
DISPATCHCOMMON(push_dx);
DISPATCHCOMMON(push_sp);
DISPATCHCOMMON(push_bp);
DISPATCHCOMMON(push_si);
DISPATCHCOMMON(push_di);
DISPATCHCOMMON(pop_ax);
DISPATCHCOMMON(pop_bx);
DISPATCHCOMMON(pop_cx);
DISPATCHCOMMON(pop_dx);
DISPATCHCOMMON(pop_sp);
DISPATCHCOMMON(pop_bp);
DISPATCHCOMMON(pop_si);
DISPATCHCOMMON(pop_di);
DISPATCHCOMMON(bound);
DISPATCHCOMMON(retn_i);
DISPATCHCOMMON(retn);
DISPATCHCOMMON(retf_i);
DISPATCHCOMMON(retf);
DISPATCHCOMMON(enter);
DISPATCHCOMMON(leave);
DISPATCHCOMMON(movzx_regw_modrmb);
DISPATCHCOMMON(movsx_regw_modrmb);
DISPATCHCOMMON(lds_rw_mw);
DISPATCHCOMMON(lss_rw_mw);
DISPATCHCOMMON(les_rw_mw);
DISPATCHCOMMON(lfs_rw_mw);
DISPATCHCOMMON(lgs_rw_mw);
DISPATCHCOMMON(call_rel);
DISPATCHCOMMON(jmp_rel);
DISPATCHCOMMON(shld_regw_modrmw_immb);
DISPATCHCOMMON(shld_regw_modrmw_cl);
DISPATCHCOMMON(shrd_regw_modrmw_immb);
DISPATCHCOMMON(shrd_regw_modrmw_cl);
DISPATCHCOMMON(bsf_modrmw_regw);
DISPATCHCOMMON(bsr_modrmw_regw);
DISPATCHCOMMON(lar);
DISPATCHCOMMON(lsl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\bytefns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bytefns.c

Abstract:
    
    Instuctions which operate on BYTES

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "bytefns.h"

ASSERTNAME;

// set up to include common functions
#define MSB                 0x80
#define MANGLENAME(x)       x ## 8
#define MOD_RM              mod_rm_reg8
#define UTYPE		    unsigned char
#define STYPE		    signed char
#define GET_VAL 	    GET_BYTE
#define PUT_VAL             PUT_BYTE
#define OPNAME(x)           OP_ ## x ## 8
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 8
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 8)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 8 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 8 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 8 , pop1, op2)
#define AREG                GP_AL
#define BREG                GP_BL
#define CREG                GP_CL
#define DREG                GP_DL
#define DEREF(Op)           DEREF8(Op)

// include the common functions
#include "common.c"

// create the mod_rm_reg8() decoder function
#define MOD11_RM000         GP_AL
#define MOD11_RM001         GP_CL
#define MOD11_RM010         GP_DL
#define MOD11_RM011         GP_BL
#define MOD11_RM100         GP_AH
#define MOD11_RM101         GP_CH
#define MOD11_RM110         GP_DH
#define MOD11_RM111         GP_BH
#define REG000              GP_AL
#define REG001              GP_CL
#define REG010              GP_DL
#define REG011              GP_BL
#define REG100              GP_AH
#define REG101              GP_CH
#define REG110              GP_DH
#define REG111              GP_BH
#define MOD_RM_DECODER      mod_rm_reg8
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\common.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    common.h

Abstract:
    
    Prototypes for instructions which operate on BYTES, WORDS or DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef COMMON_H checks.

DISPATCHCOMMON(LOCKadd_m_r);
DISPATCHCOMMON(LOCKadd_r_m);
DISPATCHCOMMON(LOCKadd_a_i);
DISPATCHCOMMON(LOCKor_m_r);
DISPATCHCOMMON(LOCKor_r_m);
DISPATCHCOMMON(LOCKor_a_i);
DISPATCHCOMMON(LOCKadc_m_r);
DISPATCHCOMMON(LOCKadc_r_m);
DISPATCHCOMMON(LOCKadc_a_i);
DISPATCHCOMMON(LOCKsbb_m_r);
DISPATCHCOMMON(LOCKsbb_r_m);
DISPATCHCOMMON(LOCKsbb_a_i);
DISPATCHCOMMON(LOCKand_m_r);
DISPATCHCOMMON(LOCKand_r_m);
DISPATCHCOMMON(LOCKand_a_i);
DISPATCHCOMMON(LOCKsub_m_r);
DISPATCHCOMMON(LOCKsub_r_m);
DISPATCHCOMMON(LOCKsub_a_i);
DISPATCHCOMMON(LOCKxor_m_r);
DISPATCHCOMMON(LOCKxor_r_m);
DISPATCHCOMMON(LOCKxor_a_i);

DISPATCHCOMMON(add_m_r);
DISPATCHCOMMON(add_r_m);
DISPATCHCOMMON(add_a_i);
DISPATCHCOMMON(or_m_r);
DISPATCHCOMMON(or_r_m);
DISPATCHCOMMON(or_a_i);
DISPATCHCOMMON(adc_m_r);
DISPATCHCOMMON(adc_r_m);
DISPATCHCOMMON(adc_a_i);
DISPATCHCOMMON(sbb_m_r);
DISPATCHCOMMON(sbb_r_m);
DISPATCHCOMMON(sbb_a_i);
DISPATCHCOMMON(and_m_r);
DISPATCHCOMMON(and_r_m);
DISPATCHCOMMON(and_a_i);
DISPATCHCOMMON(sub_m_r);
DISPATCHCOMMON(sub_r_m);
DISPATCHCOMMON(sub_a_i);
DISPATCHCOMMON(xor_m_r);
DISPATCHCOMMON(xor_r_m);
DISPATCHCOMMON(xor_a_i);
DISPATCHCOMMON(cmp_m_r);
DISPATCHCOMMON(cmp_r_m);
DISPATCHCOMMON(cmp_a_i);
DISPATCHCOMMON(GROUP_1);
DISPATCHCOMMON(LOCKGROUP_1);
DISPATCHCOMMON(test_r_m);
DISPATCHCOMMON(xchg_r_m);
DISPATCHCOMMON(mov_m_r);
DISPATCHCOMMON(mov_r_m);
DISPATCHCOMMON(mov_a_m);
DISPATCHCOMMON(mov_m_a);
DISPATCHCOMMON(test_a_i);
DISPATCHCOMMON(mov_a_i);
DISPATCHCOMMON(mov_b_i);
DISPATCHCOMMON(mov_c_i);
DISPATCHCOMMON(mov_d_i);
DISPATCHCOMMON(GROUP_2);
DISPATCHCOMMON(mov_m_i);
DISPATCHCOMMON(GROUP_2_1);
DISPATCHCOMMON(GROUP_2_CL);
DISPATCHCOMMON(GROUP_3);
DISPATCHCOMMON(LOCKGROUP_3);
DISPATCHCOMMON(lods);
DISPATCHCOMMON(stos);
DISPATCHCOMMON(scas);
DISPATCHCOMMON(movs);
DISPATCHCOMMON(cmps);
DISPATCHCOMMON(jo);
DISPATCHCOMMON(jno);
DISPATCHCOMMON(jb);
DISPATCHCOMMON(jae);
DISPATCHCOMMON(je);
DISPATCHCOMMON(jne);
DISPATCHCOMMON(jbe);
DISPATCHCOMMON(ja);
DISPATCHCOMMON(js);
DISPATCHCOMMON(jns);
DISPATCHCOMMON(jp);
DISPATCHCOMMON(jnp);
DISPATCHCOMMON(jl);
DISPATCHCOMMON(jnl);
DISPATCHCOMMON(jle);
DISPATCHCOMMON(jg);
DISPATCHCOMMON(xadd_m_r);
DISPATCHCOMMON(cmpxchg_m_r);
DISPATCHCOMMON(LOCKxadd_m_r);
DISPATCHCOMMON(LOCKcmpxchg_m_r);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\comm1632.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    comm1632.c

Abstract:
    
    Instructions with common (shared) WORD, and DWORD flavors (but not BYTE).

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "wx86.h"
#include "config.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "comm1632.h"

extern OPERATION MANGLENAME(Group1Map)[];

// ---------------- single-byte functions -------------------------------
DISPATCHCOMMON(dispatch2)
{
    eipTemp++;
#if MSB==0x8000
    ((pfnDispatchInstruction)(Dispatch216[GET_BYTE(eipTemp)]))(State, Instr);
#else
    ((pfnDispatchInstruction)(Dispatch232[GET_BYTE(eipTemp)]))(State, Instr);
#endif
}
DISPATCHCOMMON(LOCKdispatch2)
{
    eipTemp++;
#if MSB==0x8000
    ((pfnDispatchInstruction)(LockDispatch216[GET_BYTE(eipTemp)]))(State, Instr);
#else
    ((pfnDispatchInstruction)(LockDispatch232[GET_BYTE(eipTemp)]))(State, Instr);
#endif
}
DISPATCHCOMMON(pushf)
{
    Instr->Operation = OPNAME(Pushf);
}
DISPATCHCOMMON(popf)
{
    Instr->Operation = OPNAME(Popf);
}
DISPATCHCOMMON(pusha)
{
    Instr->Operation = OPNAME(PushA);
}
DISPATCHCOMMON(popa)
{
    Instr->Operation = OPNAME(PopA);
}
DISPATCHCOMMON(push_iw)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(push_ibs)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCHCOMMON(GROUP_1WS)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1Map)[g];
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp + cbInstr + 1);
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }
    Instr->Size = cbInstr+2;
}
DISPATCHCOMMON(LOCKGROUP_1WS)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1LockMap)[g];
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = (UTYPE)(STYPE)(char)GET_BYTE(eipTemp + cbInstr + 1);
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }
    Instr->Size = cbInstr+2;
}
DISPATCHCOMMON(mov_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Mov);
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(lea_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Mov);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(pop_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Pop);
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(xchg_ax_cx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = CREG;
}
DISPATCHCOMMON(xchg_ax_dx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = DREG;
}
DISPATCHCOMMON(xchg_ax_bx)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = BREG;
}
DISPATCHCOMMON(xchg_ax_sp)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = SPREG;
}
DISPATCHCOMMON(xchg_ax_bp)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = BPREG;
}
DISPATCHCOMMON(xchg_ax_si)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = SIREG;
}
DISPATCHCOMMON(xchg_ax_di)
{
    Instr->Operation = OPNAME(Xchg);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_REGREF;
    Instr->Operand2.Reg = DIREG;
}
DISPATCHCOMMON(cbw)
{
    Instr->Operation = OPNAME(Cbw);
}
DISPATCHCOMMON(cwd)
{
    Instr->Operation = OPNAME(Cwd);
}
DISPATCHCOMMON(mov_sp_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_bp_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_si_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(mov_di_iw)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}
DISPATCHCOMMON(loopne_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loopne_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loopne_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(loope_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loope_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loope_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(loop_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OPNAME(CTRL_COND_Loop_bFwd);
    } else {
        Instr->Operation = OPNAME(CTRL_COND_Loop_b);
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(jcxz_b)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        // "ADR: jecxz" is the same as "DATA: jecxz"... which is "jcxz"
        Instr->Operand1.Immed = MAKELONG((char)GET_BYTE(eipTemp+1)+2+(short)LOWORD(eipTemp), HIWORD(eipTemp));
        if (Instr->Operand1.Immed > eipTemp) {
            Instr->Operation = OP_CTRL_COND_Jcxz_bFwd16;
        } else {
            Instr->Operation = OP_CTRL_COND_Jcxz_b16;
        }
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (CHAR)GET_BYTE(eipTemp+1)+2+eipTemp;
        if (Instr->Operand1.Immed > eipTemp) {
            Instr->Operation = OPNAME(CTRL_COND_Jcxz_bFwd);
        } else {
            Instr->Operation = OPNAME(CTRL_COND_Jcxz_b);
        }
    }
    Instr->Size = 2;
}
DISPATCHCOMMON(GROUP_5)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmW
        Instr->Operation = OPNAME(Inc);
        break;
    case 1: // dec modrmW
        Instr->Operation = OPNAME(Dec);
        break;
    case 2: // call indirmodrmW
        DEREF(Instr->Operand1);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp + cbInstr + 1;
        Instr->Operation = OP_CTRL_INDIR_Call;
        break;
    case 3: // call indirFARmodrmW
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp + cbInstr + 1;
        Instr->Operation = OP_CTRL_INDIR_Callf;
        break;
    case 4: // jmp  indirmodrmW
        DEREF(Instr->Operand1);
        Instr->Operation = OP_CTRL_INDIR_Jmp;
        break;
    case 5: // jmp  indirFARmodrmW
        Instr->Operation = OP_CTRL_INDIR_Jmpf;
        break;
    case 6: // push modrmW
        DEREF(Instr->Operand1);
        Instr->Operation = OPNAME(Push);
        break;
    case 7: // bad
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(LOCKGROUP_5)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmW
        Instr->Operation = LOCKOPNAME(Inc);
        break;
    case 1: // dec modrmW
        Instr->Operation = LOCKOPNAME(Dec);
        break;
    default:
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(inc_ax)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(inc_cx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(inc_dx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(inc_bx)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(inc_sp)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(inc_bp)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(inc_si)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(inc_di)
{
    Instr->Operation = OPNAME(Inc);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(dec_ax)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(dec_cx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(dec_dx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(dec_bx)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(dec_sp)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(dec_bp)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(dec_si)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(dec_di)
{
    Instr->Operation = OPNAME(Dec);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(push_ax)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(push_cx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(push_dx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(push_bx)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(push_sp)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(push_bp)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(push_si)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(push_di)
{
    Instr->Operation = OPNAME(Push);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(pop_ax)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
}
DISPATCHCOMMON(pop_cx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
}
DISPATCHCOMMON(pop_dx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
}
DISPATCHCOMMON(pop_bx)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
}
DISPATCHCOMMON(pop_sp)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SPREG;
}
DISPATCHCOMMON(pop_bp)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BPREG;
}
DISPATCHCOMMON(pop_si)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = SIREG;
}
DISPATCHCOMMON(pop_di)
{
    Instr->Operation = OPNAME(Pop);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DIREG;
}
DISPATCHCOMMON(bound)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Bound);
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(retn_i)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retn_i);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (DWORD)GET_SHORT(eipTemp+1);
    Instr->Size = 3;
}
DISPATCHCOMMON(retn)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retn);
}
DISPATCHCOMMON(retf_i)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retf_i);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (DWORD)GET_SHORT(eipTemp+1);
    Instr->Size = 3;
}
DISPATCHCOMMON(retf)
{
    Instr->Operation = OPNAME(CTRL_INDIR_Retf);
}
DISPATCHCOMMON(enter)
{
    Instr->Operation = OPNAME(Enter);
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+3);      // Nesting Level
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_SHORT(eipTemp+1);     // Stack bytes to alloc
    Instr->Size = 4;
}
DISPATCHCOMMON(leave)
{
    Instr->Operation = OPNAME(Leave);
}



//-------- double-byte functions -----------------------------------------------

DISPATCHCOMMON(GROUP_8)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // bad
    case 1: // bad
    case 2: // bad
    case 3: // bad
        BAD_INSTR;
        break;
    case 4: // bt modrmw immb
        // Note:  the difference between the Reg and Mem version of the btx
        // fragments is that the Reg version completely ignores any bits in the
        // second operand beyond the fifth bit.  In contrast, the Mem version uses
        // them together with the first operand to determine the memory address.
        // When the second operand is an immediate, the correct thing to do is to
        // ignore them, and so we call the Reg version all the time.

        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 5: // bts modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtsReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 6: // btr modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtrReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 7: // btc modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = OPNAME(BtcReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    }
}
DISPATCHCOMMON(LOCKGROUP_8)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // bad
    case 1: // bad
    case 2: // bad
    case 3: // bad
    case 4: // bt modrmw immb
        BAD_INSTR;
        break;
    case 5: // bts modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtsReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 6: // btr modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtrReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    case 7: // btc modrmw immb
        cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

        Instr->Operation = LOCKOPNAME(BtcReg);
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_BYTE(eipTemp+cbInstr+1);
        Instr->Size = cbInstr+3;
        break;
    }
}
DISPATCHCOMMON(movzx_regw_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Movzx8To);
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = GET_REG(eipTemp+1);
    DEREF8(Instr->Operand1);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(movsx_regw_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Movsx8To);
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = GET_REG(eipTemp+1);
    DEREF8(Instr->Operand1);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(les_rw_mw)
{
    if ((GET_BYTE(eipTemp+1) & 0xc7) == 0xc4) {
        //
        // BOP instruction
        //
        PBOPINSTR Bop = (PBOPINSTR)eipTemp;

        Instr->Size = sizeof(BOPINSTR);

        if (Bop->BopNum == 0xfe) {
            //
            // BOP FE - Unsimulate
            //
            Instr->Operation = OP_Unsimulate;

        } else {

            //
            // Generate a BOP.
            //
            if (Bop->Flags & BOPFL_ENDCODE) {
                //
                // This BOP is flagged as being the end of Intel code.
                // This is typically BOP FD in x86-to-Risc callbacks.
                //
                Instr->Operation = OP_BOP_STOP_DECODE;
            } else {
                Instr->Operation = OP_BOP;
            }
        }
    } else {
        int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

        Instr->Operation = OPNAME(Les);
        Instr->Size = 1+cbInstr;
    }
}
DISPATCHCOMMON(lds_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lds);
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(lss_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lss);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lfs_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lfs);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lgs_rw_mw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lgs);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bts_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtsReg);
    } else {
        Instr->Operation = OPNAME(BtsMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(btr_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtrReg);
    } else {
        Instr->Operation = OPNAME(BtrMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(btc_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtcReg);
    } else {
        Instr->Operation = OPNAME(BtcMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbts_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtsMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbtr_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtrMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(LOCKbtc_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        BAD_INSTR;
    } else {
        Instr->Operation = LOCKOPNAME(BtcMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bt_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    DEREF(Instr->Operand2);
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(BtReg);
    } else {
        Instr->Operation = OPNAME(BtMem);
    }
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(call_rel)
{
    Instr->Operation = OP_CTRL_UNCOND_Call;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1) + sizeof(UTYPE) + 1 + eipTemp;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = eipTemp + sizeof(UTYPE) + 1;
    Instr->Size = sizeof(UTYPE) + 1;
}
DISPATCHCOMMON(jmp_rel)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        short IP;

        // get the 16-bit loword from the 32-bit immediate value following
        // the JMP instruction, and add that value to the loword of EIP, and
        // use that value as the new IP register.
        IP = (short)GET_SHORT(eipTemp+1) +
             sizeof(UTYPE) + 1 + (short)LOWORD(eipTemp);
        Instr->Operand1.Immed = MAKELONG(IP, HIWORD(eipTemp));
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1) +
                                sizeof(UTYPE) + 1 + eipTemp;
    }
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OP_CTRL_UNCOND_JmpFwd;
    } else {
        Instr->Operation = OP_CTRL_UNCOND_Jmp;
    }
    Instr->Size = sizeof(UTYPE) + 1;
}
DISPATCHCOMMON(shld_regw_modrmw_immb)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shld);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_BYTE(eipTemp+cbInstr+1);
    Instr->Size = 3+cbInstr;
}
DISPATCHCOMMON(shld_regw_modrmw_cl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shld);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_REGVALUE;
    Instr->Operand3.Reg = GP_CL;
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(shrd_regw_modrmw_immb)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shrd);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_BYTE(eipTemp+cbInstr+1);
    Instr->Size = 3+cbInstr;
}
DISPATCHCOMMON(shrd_regw_modrmw_cl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Shrd);
    DEREF(Instr->Operand2);
    Instr->Operand3.Type = OPND_REGVALUE;
    Instr->Operand3.Reg = GP_CL;
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bsr_modrmw_regw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Bsr);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(bsf_modrmw_regw)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Bsf);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lar)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lar);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCHCOMMON(lsl)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Lsl);
    DEREF(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\common.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    common.c

Abstract:
    
    Instructions with common (shared) BYTE, WORD, and DWORD flavors.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// GET_REG  - function returning pointer to register
// MSB      - most signigicant bit
// MOD_RM   - decode mod/rm bits
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL  - writes a value into memory
// DISPATCHCOMMON - mangles function name by appening 8/16/32
// AREG     - GP_AL/GP_AX/GP_EAX, etc.
// BREG     - ...
// CREG     - ...
// DREG     - ...

OPERATION MANGLENAME(Group1Map)[8] = {OPNAME(Add),
                                      OPNAME(Or),
                                      OPNAME(Adc),
                                      OPNAME(Sbb),
                                      OPNAME(And),
                                      OPNAME(Sub),
                                      OPNAME(Xor),
                                      OPNAME(Cmp)};

OPERATION MANGLENAME(Group1LockMap)[8] = {LOCKOPNAME(Add),
                                          LOCKOPNAME(Or),
                                          LOCKOPNAME(Adc),
                                          LOCKOPNAME(Sbb),
                                          LOCKOPNAME(And),
                                          LOCKOPNAME(Sub),
                                          LOCKOPNAME(Xor),
                                          OPNAME(Cmp)};

// A macro to generate _m_r functions
#define DC_M_R(x, y)                                    \
    DISPATCHCOMMON(x ## _m_r)                           \
    {                                                   \
        int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);   \
                                                        \
        Instr->Operation = y;                           \
        DEREF(Instr->Operand2);                         \
        Instr->Size = cbInstr+1;                        \
    }                                                   

// A macro to generate _r_m functions
#define DC_R_M(x, y)                                    \
    DISPATCHCOMMON(x ## _r_m)                           \
    {                                                   \
        int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);   \
                                                        \
        Instr->Operation = y;                           \
        DEREF(Instr->Operand2);                         \
        Instr->Size = cbInstr+1;                        \
    }

// A macro to generate _a_i functions
#define DC_A_I(x, y)                                    \
    DISPATCHCOMMON(x ## _a_i)                           \
    {                                                   \
        Instr->Operation = y;                           \
        Instr->Operand1.Type = OPND_REGREF;             \
        Instr->Operand1.Reg = AREG;                     \
        Instr->Operand2.Type = OPND_IMM;                \
        Instr->Operand2.Immed = GET_VAL(eipTemp+1);     \
        Instr->Size = 1+sizeof(UTYPE);                  \
    }

// The monster macro which generates all three
#define DC_ALL(x, y)                                    \
    DC_M_R(x,y)                                         \
    DC_R_M(x,y)                                         \
    DC_A_I(x,y)                                         

// SETSIZE sets the size of a jump instruction
#if MSB==0x80
#define SETSIZE     Instr->Size = 1+sizeof(UTYPE); // 1 byte opcode    
#else                                                 
#define SETSIZE     Instr->Size = 2+sizeof(UTYPE); // 2 byte opcode   
#endif                                                    

#if DBG
#define CLEAR_ADRPREFIX         State->AdrPrefix = FALSE;
#else
#define CLEAR_ADRPREFIX
#endif

// This macro generates jump functions
// If the ADR: prefix is set, get the 16-bit loword from the 32-bit
// immediate value following the JMP instruction, and add that value
// to the loword of EIP, and use that value as the new IP register.
#define DISPATCHJUMP(x)                                 \
DISPATCHCOMMON(j ## x)                                  \
{                                                       \
    Instr->Operand1.Type = OPND_NOCODEGEN;              \
    if (State->AdrPrefix) {                             \
        Instr->Operand1.Immed = MAKELONG((short)GET_SHORT(eipTemp+1)+1+sizeof(UTYPE)+(short)LOWORD(eipTemp), HIWORD(eipTemp)); \
        CLEAR_ADRPREFIX;                                \
    } else {                                            \
        Instr->Operand1.Immed = (STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE)+eipTemp; \
    }                                                   \
    if (Instr->Operand1.Immed > eipTemp) {              \
        Instr->Operation = OP_CTRL_COND_J ## x ## Fwd;  \
    } else {                                            \
        Instr->Operation = OP_CTRL_COND_J ## x ##;      \
    }                                                   \
    SETSIZE                                             \
}


DC_ALL(LOCKadd, LOCKOPNAME(Add))
DC_ALL(LOCKor,  LOCKOPNAME(Or))
DC_ALL(LOCKadc, LOCKOPNAME(Adc))
DC_ALL(LOCKsbb, LOCKOPNAME(Sbb))
DC_ALL(LOCKand, LOCKOPNAME(And))
DC_ALL(LOCKsub, LOCKOPNAME(Sub))
DC_ALL(LOCKxor, LOCKOPNAME(Xor))

DC_ALL(add, OPNAME(Add))
DC_ALL(or,  OPNAME(Or))
DC_ALL(adc, OPNAME(Adc))
DC_ALL(sbb, OPNAME(Sbb))
DC_ALL(and, OPNAME(And))
DC_ALL(sub, OPNAME(Sub))
DC_ALL(xor, OPNAME(Xor))

DISPATCHCOMMON(cmp_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Cmp);
    DEREF(Instr->Operand1);     // both params are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(cmp_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Cmp);
    DEREF(Instr->Operand1);     // both params are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(cmp_a_i)
{
    Instr->Operation = OPNAME(Cmp);
    Instr->Operand1.Type = OPND_REGVALUE;   // both params are byval
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}

DISPATCHCOMMON(GROUP_1)
{
    int  cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g   = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr); // get immB
    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1Map)[g];
    if (g == 7) {
        // Cmp takes both params as byval
        DEREF(Instr->Operand1);
    }

    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}
DISPATCHCOMMON(LOCKGROUP_1)
{
    int  cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g   = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr); // get immB
    g = (g >> 3) & 0x07;
    Instr->Operation = MANGLENAME(Group1LockMap)[g];
    if (g == 7) {
        // Cmp takes both args as byval
        DEREF(Instr->Operand1);
    }

    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}

DISPATCHCOMMON(test_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OPNAME(Test);
    DEREF(Instr->Operand1);     // both args are byval
    DEREF(Instr->Operand2);
    Instr->Size = cbInstr+1;
}

DISPATCHCOMMON(xchg_r_m)
{
    int cbInstr = MOD_RM(State, &Instr->Operand2, &Instr->Operand1);

    // Operand2 is always a register.  If operand1 is a memory location,
    // we must use the locked version, otherwise use the regular version.
    if (Instr->Operand1.Type == OPND_REGREF){
        Instr->Operation = OPNAME(Xchg);
    } else {
        Instr->Operation = LOCKOPNAME(Xchg);
    }
    Instr->Size = cbInstr+1;
}

DISPATCHCOMMON(xadd_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(Xadd);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(cmpxchg_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OPNAME(CmpXchg);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(LOCKxadd_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = LOCKOPNAME(Xadd);
    Instr->Size = cbInstr+2;
}

DISPATCHCOMMON(LOCKcmpxchg_m_r)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = LOCKOPNAME(CmpXchg);
    Instr->Size = cbInstr+2;
}

DC_M_R(mov, OPNAME(Mov))
DC_R_M(mov, OPNAME(Mov))

DISPATCHCOMMON(mov_a_m)     // mov accum, [full displacement]
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_ADDRREF;
    DEREF(Instr->Operand2); // this is a klunky ADDRVAL8/16/32 expansion
    if (State->AdrPrefix) {
        Instr->Operand2.Immed = GET_SHORT(eipTemp+1);
        Instr->Size = 3;
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand2.Immed = GET_LONG(eipTemp+1);
        Instr->Size = 5;
    }
}
DISPATCHCOMMON(mov_m_a)     // mov [full displacement], accum
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_ADDRREF;
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Operand2.Reg = AREG;
    if (State->AdrPrefix) {
        Instr->Operand1.Immed = GET_SHORT(eipTemp+1);
        Instr->Size = 3;
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = GET_LONG(eipTemp+1);
        Instr->Size = 5;
    }
}

DISPATCHCOMMON(test_a_i)
{
    Instr->Operation = OPNAME(Test);
    Instr->Operand1.Type = OPND_REGVALUE;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = 1+sizeof(UTYPE);
}

DISPATCHCOMMON(mov_a_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = AREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_b_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = BREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_c_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = CREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(mov_d_i)
{
    Instr->Operation = OPNAME(Mov);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = DREG;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1);
    Instr->Size = sizeof(UTYPE)+1;
}
DISPATCHCOMMON(GROUP_2)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    // <instruction> modrm, imm
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr) & 0x1f;

    switch ((g >> 3) & 0x07) {
    case 0: // rol
        if (Instr->Operand2.Immed)
            Instr->Operation = OPNAME(Rol);
        else
            Instr->Operation = OP_Nop;
        break;
    case 1: // ror
        if (Instr->Operand2.Immed)
            Instr->Operation = OPNAME(Ror);
        else
            Instr->Operation = OP_Nop;
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar);
        break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }
    Instr->Size = 2+cbInstr;
}

DISPATCHCOMMON(mov_m_i)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);

    Instr->Operation = OPNAME(Mov);
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_VAL(eipTemp+cbInstr+1);
    Instr->Size = cbInstr+sizeof(UTYPE)+1;
}
DISPATCHCOMMON(GROUP_2_1)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    // <instruction> modrm, 1
    switch ((g >> 3) & 0x07) {
    case 0: // rol
        Instr->Operation = OPNAME(Rol1);
        break;
    case 1: // ror
        Instr->Operation = OPNAME(Ror1);
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl1);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr1);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl1);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr1);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar1);
    break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }

    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(GROUP_2_CL)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Operand2.Reg = GP_CL;   //UNDONE: the fragments must mask by 31

    // <instruction> modrm, imm
    switch ((g >> 3) & 0x07) {
    case 0: // rol
        Instr->Operation = OPNAME(Rol);
        break;
    case 1: // ror
        Instr->Operation = OPNAME(Ror);
        break;
    case 2: // rcl
        Instr->Operation = OPNAME(Rcl);
        break;
    case 3: // rcr
        Instr->Operation = OPNAME(Rcr);
        break;
    case 4: // shl
        Instr->Operation = OPNAME(Shl);
        break;
    case 5: // shr
        Instr->Operation = OPNAME(Shr);
        break;
    case 7: // sar
        Instr->Operation = OPNAME(Sar);
        break;
    case 6: // <bad>
        BAD_INSTR;
        break;
    }
    Instr->Size = 1+cbInstr;
}
DISPATCHCOMMON(GROUP_3)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 1: // bad
        BAD_INSTR;
        break;
    case 0: // test modrm, imm
        Instr->Operation = OPNAME(Test);
        DEREF(Instr->Operand1);     // both args are byval
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = GET_VAL(eipTemp+1+cbInstr);
        cbInstr += sizeof(UTYPE);   // account for the imm size
        break;
    case 2: // not, modrm
        Instr->Operation = OPNAME(Not);
        break;
    case 3: // neg, modrm
        Instr->Operation = OPNAME(Neg);
        break;
    case 4: // mul al, modrm
        Instr->Operation = OPNAME(Mul);
        break; 
    case 5: // imul al, modrm
        Instr->Operation = OPNAME(Muli);
        break; 
    case 6: // div al, modrm
        Instr->Operation = OPNAME(Div);
        break; 
    case 7: // idiv al, modrm
        Instr->Operation = OPNAME(Idiv);
        break; 
    }
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(LOCKGROUP_3)
{
    int cbInstr = MOD_RM(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0:
    case 1: // bad
        BAD_INSTR;
        break;
    case 2: // not, modrm
        Instr->Operation = LOCKOPNAME(Not);
        break;
    case 3: // neg, modrm
        Instr->Operation = LOCKOPNAME(Neg);
        break;
    default:
        BAD_INSTR;
        break;
    }
    Instr->Size = cbInstr+1;
}
DISPATCHCOMMON(lods)
{
    if (Instr->FsOverride) {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(FsRepLods);
        } else {
            Instr->Operation = OPNAME(FsLods);
        }
    } else {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(RepLods);
        } else {
            Instr->Operation = OPNAME(Lods);
        }
    }
}
DISPATCHCOMMON(scas)
{
    OPERATION ScasMap[6] = {OPNAME(Scas),
                            OPNAME(RepzScas),
                            OPNAME(RepnzScas),
                            OPNAME(FsScas),
                            OPNAME(FsRepzScas),
                            OPNAME(FsRepnzScas)
                            };

    Instr->Operation = ScasMap[State->RepPrefix + 3*Instr->FsOverride];
}
DISPATCHCOMMON(stos)
{
    if (State->RepPrefix) {
        Instr->Operation = OPNAME(RepStos);
    } else {
        Instr->Operation = OPNAME(Stos);
    }
}
DISPATCHCOMMON(movs)
{
    if (Instr->FsOverride) {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(FsRepMovs);
        } else {
            Instr->Operation = OPNAME(FsMovs);
        }
    } else {
        if (State->RepPrefix) {
            Instr->Operation = OPNAME(RepMovs);
        } else {
            Instr->Operation = OPNAME(Movs);
        }
    }
}
DISPATCHCOMMON(cmps)
{
    OPERATION CmpsMap[6] = {OPNAME(Cmps),
                            OPNAME(RepzCmps),
                            OPNAME(RepnzCmps),
                            OPNAME(FsCmps),
                            OPNAME(FsRepzCmps),
                            OPNAME(FsRepnzCmps)
                            };

    Instr->Operation = CmpsMap[State->RepPrefix + 3*Instr->FsOverride];
}

// Now the jump instructions:
DISPATCHJUMP(o)
DISPATCHJUMP(no)
DISPATCHJUMP(b)
DISPATCHJUMP(ae)
DISPATCHJUMP(e)
DISPATCHJUMP(ne)
DISPATCHJUMP(be)
DISPATCHJUMP(a)
DISPATCHJUMP(s)
DISPATCHJUMP(ns)
DISPATCHJUMP(p)
DISPATCHJUMP(np)
DISPATCHJUMP(l)
DISPATCHJUMP(nl)
DISPATCHJUMP(le)
DISPATCHJUMP(g)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\decoderp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    decoderp.h

Abstract:
    
    Private exports, defines for CPU Instruction decoder

Author:

    27-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef DECODERP_H
#define DECODERP_H


#define GET_BYTE(addr)       (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)      (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)       (*(UNALIGNED unsigned long *)(addr))

/*---------------------------------------------------------------------*/

typedef struct _DecoderState {
    DWORD InstructionAddress;
    INT   RepPrefix;
    BOOL  AdrPrefix;
    OPERATION OperationOverride;
} DECODERSTATE, *PDECODERSTATE;

#define eipTemp State->InstructionAddress

#define DISPATCH(x)  void x(PDECODERSTATE State, PINSTRUCTION Instr)

#if DBG
#define UNIMPL_INSTR(name)  {       \
    OutputDebugString("CPU: Warning:  unimplemented instruction " ## name ## " encountered\r\n"); \
    BAD_INSTR;                      \
    }
#else
#define UNIMPL_INSTR BAD_INSTR
#endif

#define BAD_INSTR                                   \
    State->OperationOverride = OP_BadInstruction;

#define PRIVILEGED_INSTR                            \
    State->OperationOverride = OP_PrivilegedInstruction;

#define get_reg32(cpu)          \
   (GP_EAX + (((*(PBYTE)(eipTemp+1)) >> 3) & 0x07))

#define get_reg16(cpu)          \
   (GP_AX + (((*(PBYTE)(eipTemp+1)) >> 3) & 0x07))

#define DEREF8(Op)                                                        \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type = (Op.Type == OPND_REGREF) ? OPND_REGVALUE : OPND_ADDRVALUE8;

#define DEREF16(Op)                                                       \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type = (Op.Type == OPND_REGREF) ? OPND_REGVALUE : OPND_ADDRVALUE16;

#define DEREF32(Op)                                                       \
    CPUASSERT(Op.Type == OPND_REGREF || Op.Type == OPND_ADDRREF);         \
    Op.Type++;

int scaled_index(PBYTE pmodrm, POPERAND op);
void get_segreg(PDECODERSTATE State, POPERAND op);
int     mod_rm_reg32(PDECODERSTATE State, POPERAND op1, POPERAND op2);
int     mod_rm_reg16(PDECODERSTATE State, POPERAND op1, POPERAND op2);
int     mod_rm_reg8 (PDECODERSTATE State, POPERAND op1, POPERAND op2);

#define PREFIX_NONE  0
#define PREFIX_REPZ  1
#define PREFIX_REPNZ 2

typedef void (*pfnDispatchInstruction)(PDECODERSTATE, PINSTRUCTION);
extern pfnDispatchInstruction Dispatch32[256];
extern pfnDispatchInstruction Dispatch232[256];
extern pfnDispatchInstruction Dispatch16[256];
extern pfnDispatchInstruction Dispatch216[256];
extern pfnDispatchInstruction LockDispatch32[256];
extern pfnDispatchInstruction LockDispatch232[256];
extern pfnDispatchInstruction LockDispatch16[256];
extern pfnDispatchInstruction LockDispatch216[256];

#endif //DECODERP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\dwordfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dwordfns.h

Abstract:
    
    Prototypes for instructions which operate on 32-bit DWORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef DWORDFNS_H
#define DWORDFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 32)
#include "common.h"
#include "comm1632.h"
#undef DISPATCHCOMMON

#endif //DWORDFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\ds32tbl.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    ds32tbl.c

Abstract:
    
    Dispatch tables for instructions with no DATA: override.  It is used for
    both DS: and FS: overrides.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "dwordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction Dispatch32[256] = {
    // 0
    add_m_r8,
    add_m_r32,
    add_r_m8,
    add_r_m32,
    add_a_i8,
    add_a_i32,
    push_es,
    pop_es,
    // 8
    or_m_r8,
    or_m_r32,
    or_r_m8,
    or_r_m32,
    or_a_i8,
    or_a_i32,
    push_cs,
    dispatch232,
    // 10
    adc_m_r8,
    adc_m_r32,
    adc_r_m8,
    adc_r_m32,
    adc_a_i8,
    adc_a_i32,
    push_ss,
    pop_ss,
    // 18
    sbb_m_r8,
    sbb_m_r32,
    sbb_r_m8,
    sbb_r_m32,
    sbb_a_i8,
    sbb_a_i32,
    push_ds,
    pop_ds,
    // 20
    and_m_r8,
    and_m_r32,
    and_r_m8,
    and_r_m32,
    and_a_i8,
    and_a_i32,
    ProcessPrefixes,	// es:
    daa,
    // 28
    sub_m_r8,
    sub_m_r32,
    sub_r_m8,
    sub_r_m32,
    sub_a_i8,
    sub_a_i32,
    ProcessPrefixes,	// cs:
    das,
    // 30
    xor_m_r8,
    xor_m_r32,
    xor_r_m8,
    xor_r_m32,
    xor_a_i8,
    xor_a_i32,
    ProcessPrefixes,	// ss:
    aaa,
    // 38
    cmp_m_r8,
    cmp_m_r32,
    cmp_r_m8,
    cmp_r_m32,
    cmp_a_i8,
    cmp_a_i32,
    ProcessPrefixes,	// ds:
    aas,
    // 40
    inc_ax32,
    inc_cx32,
    inc_dx32,
    inc_bx32,
    inc_sp32,
    inc_bp32,
    inc_si32,
    inc_di32,
    // 48
    dec_ax32,
    dec_cx32,
    dec_dx32,
    dec_bx32,
    dec_sp32,
    dec_bp32,
    dec_si32,
    dec_di32,
    // 50
    push_ax32,
    push_cx32,
    push_dx32,
    push_bx32,
    push_sp32,
    push_bp32,
    push_si32,
    push_di32,
    // 58
    pop_ax32,
    pop_cx32,
    pop_dx32,
    pop_bx32,
    pop_sp32,
    pop_bp32,
    pop_si32,
    pop_di32,
    // 60
    pusha32,
    popa32,
    bound32,
    arpl,
    ProcessPrefixes,	// fs:
    ProcessPrefixes,	// gs:
    ProcessPrefixes,	// data: prefix
    ProcessPrefixes,	// adr: prefix
    // 68
    push_iw32,
    imul_rw_m_iw32,
    push_ibs32,
    imul_rw_m_ib32,
    privileged,     // in_ib_dx
    privileged,     // in_iw_dx
    privileged,     // out_ib_dx
    privileged,     // out_iw_dx
    // 70
    jo8,
    jno8,
    jb8,
    jae8,
    je8,
    jne8,
    jbe8,
    ja8,
    // 78
    js8,
    jns8,
    jp8,
    jnp8,
    jl8,
    jnl8,
    jle8,
    jg8,
    // 80
    GROUP_18,
    GROUP_132,
    bad,
    GROUP_1WS32,
    test_r_m8,
    test_r_m32,
    xchg_r_m8,
    xchg_r_m32,
    // 88
    mov_m_r8,
    mov_m_r32,
    mov_r_m8,
    mov_r_m32,
    mov_mw_seg,
    lea_rw_mw32,
    mov_seg_mw,
    pop_mw32,
    // 90
    nop,
    xchg_ax_cx32,
    xchg_ax_dx32,
    xchg_ax_bx32,
    xchg_ax_sp32,
    xchg_ax_bp32,
    xchg_ax_si32,
    xchg_ax_di32,
    // 98
    cbw32,
    cwd32,
    call_md,
    wait,
    pushf32,
    popf32,
    sahf,
    lahf,
    // a0
    mov_a_m8,
    mov_a_m32,
    mov_m_a8,
    mov_m_a32,
    movs8,
    movs32,
    cmps8,
    cmps32,
    // a8
    test_a_i8,
    test_a_i32,
    stos8,
    stos32,
    lods8,
    lods32,
    scas8,
    scas32,
    // b0
    mov_a_i8,
    mov_c_i8,
    mov_d_i8,
    mov_b_i8,
    mov_ah_ib,
    mov_ch_ib,
    mov_dh_ib,
    mov_bh_ib,
    // b8
    mov_a_i32,
    mov_c_i32,
    mov_d_i32,
    mov_b_i32,
    mov_sp_iw32,
    mov_bp_iw32,
    mov_si_iw32,
    mov_di_iw32,
    // c0
    GROUP_28,
    GROUP_232,
    retn_i32,
    retn32,
    les_rw_mw32,
    lds_rw_mw32,
    mov_m_i8,
    mov_m_i32,
    // c8
    enter32,
    leave32,
    retf_i32,
    retf32,
    int3,
    int_ib,
    into,
    iret,
    // d0
    GROUP_2_18,
    GROUP_2_132,
    GROUP_2_CL8,
    GROUP_2_CL32,
    aam_ib,
    aad_ib,
    bad,
    xlat,
    // d8
    FLOAT_GP0,
    FLOAT_GP1,
    FLOAT_GP2,
    FLOAT_GP3,
    FLOAT_GP4,
    FLOAT_GP5,
    FLOAT_GP6,
    FLOAT_GP7,
    // e0
    loopne_b32,
    loope_b32,
    loop_b32,
    jcxz_b32,
    privileged,     // in_al_memb
    privileged,     // in_ax_memb
    privileged,     // out_memb_al
    privileged,     // out_memb_ax
    // e8
    call_rel32,
    jmp_rel32,
    jmpf_md,
    jmp_jb,
    privileged,     // in_al_dx
    privileged,     // in_ax_dx
    privileged,     // out_dx_al
    privileged,     // out_dx_ax
    // f0
    ProcessPrefixes,	// lock: prefix
    bad,
    ProcessPrefixes,	// repnz prefix
    ProcessPrefixes,	// repz prefix
    privileged, 	// halt
    cmc,
    GROUP_38,
    GROUP_332,
    // f8
    clc,
    stc,
    privileged,     // cli
    privileged,     // sti
    cld,
    std,
    GROUP_4,
    GROUP_532
};


pfnDispatchInstruction Dispatch232[256] = {
    // 0
    GROUP_6,
    GROUP_7,
    lar32,
    lsl32,
    bad,
    bad,
    privileged,	// clts
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    privileged,	// mov reg2W, eeeControl
    privileged,	// mov reg2W, eeeDebug
    privileged,	// mov eeeControl, reg2W
    privileged,	// mov eeeDebug, reg2W
    privileged,	// mov reg2W, eeeTest
    bad,
    privileged,	// mov eeeTest, reg2W
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    rdtsc,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    jo32,
    jno32,
    jb32,
    jae32,
    je32,
    jne32,
    jbe32,
    ja32,
    // 88
    js32,
    jns32,
    jp32,
    jnp32,
    jl32,
    jnl32,
    jle32,
    jg32,
    // 90
    seto_modrmb,
    setno_modrmb,
    setb_modrmb,
    setae_modrmb,
    sete_modrmb,
    setne_modrmb,
    setbe_modrmb,
    seta_modrmb,
    // 98
    sets_modrmb,
    setns_modrmb,
    setp_modrmb,
    setnp_modrmb,
    setl_modrmb,
    setge_modrmb,
    setle_modrmb,
    setg_modrmb,
    // a0
    push_fs,
    pop_fs,
    cpuid,
    bt_m_r32,
    shld_regw_modrmw_immb32,
    shld_regw_modrmw_cl32,
    bad,
    bad,
    // a8
    push_gs,
    pop_gs,
    bad,
    bts_m_r32,
    shrd_regw_modrmw_immb32,
    shrd_regw_modrmw_cl32,
    bad,
    imul_regw_modrmw32,
    // b0
    cmpxchg_m_r8,
    cmpxchg_m_r32,
    lss_rw_mw32,
    btr_m_r32,
    lfs_rw_mw32,
    lgs_rw_mw32,
    movzx_regw_modrmb32,
    movzx_regw_modrmw,
    // b8
    bad,
    bad,
    GROUP_832,
    btc_m_r32,
    bsf_modrmw_regw32,
    bsr_modrmw_regw32,
    movsx_regw_modrmb32,
    movsx_regw_modrmw,
    // c0
    xadd_m_r8,
    xadd_m_r32,
    bad,
    bad,
    bad,
    bad,
    bad,
    cmpxchg8b,
    // c8
    bswap_eax,
    bswap_ecx,
    bswap_edx,
    bswap_ebx,
    bswap_esp,
    bswap_ebp,
    bswap_esi,
    bswap_edi,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\floatfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    floatfns.h

Abstract:
    
    Prototypes for floating point instructions.

Author:

    20-Jun-1995 t-orig

Revision History:

--*/

DISPATCH(FLOAT_GP0);
DISPATCH(FLOAT_GP1);
DISPATCH(FLOAT_GP2);
DISPATCH(FLOAT_GP3);
DISPATCH(FLOAT_GP4);
DISPATCH(FLOAT_GP5);
DISPATCH(FLOAT_GP6);
DISPATCH(FLOAT_GP7);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\ds16tbl.c ===
// Tables for DS: 32-bit instructions
//  (ie. no FS:, but DATA: specified)
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ds16tbl.c

Abstract:
    
    Dispatch tables for instructions with DATA: override.  It is used for
    both DS: and FS: overrides.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "wordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction Dispatch16[256] = {
    // 0
    add_m_r8,
    add_m_r16,
    add_r_m8,
    add_r_m16,
    add_a_i8,
    add_a_i16,
    push_es,
    pop_es,
    // 8
    or_m_r8,
    or_m_r16,
    or_r_m8,
    or_r_m16,
    or_a_i8,
    or_a_i16,
    push_cs,
    dispatch216,
    // 10
    adc_m_r8,
    adc_m_r16,
    adc_r_m8,
    adc_r_m16,
    adc_a_i8,
    adc_a_i16,
    push_ss,
    pop_ss,
    // 18
    sbb_m_r8,
    sbb_m_r16,
    sbb_r_m8,
    sbb_r_m16,
    sbb_a_i8,
    sbb_a_i16,
    push_ds,
    pop_ds,
    // 20
    and_m_r8,
    and_m_r16,
    and_r_m8,
    and_r_m16,
    and_a_i8,
    and_a_i16,
    ProcessPrefixes,	// es:
    daa,
    // 28
    sub_m_r8,
    sub_m_r16,
    sub_r_m8,
    sub_r_m16,
    sub_a_i8,
    sub_a_i16,
    ProcessPrefixes,	// cs:
    das,
    // 30
    xor_m_r8,
    xor_m_r16,
    xor_r_m8,
    xor_r_m16,
    xor_a_i8,
    xor_a_i16,
    ProcessPrefixes,	// ss:
    aaa,
    // 38
    cmp_m_r8,
    cmp_m_r16,
    cmp_r_m8,
    cmp_r_m16,
    cmp_a_i8,
    cmp_a_i16,
    ProcessPrefixes,	// ds:
    aas,
    // 40
    inc_ax16,
    inc_cx16,
    inc_dx16,
    inc_bx16,
    inc_sp16,
    inc_bp16,
    inc_si16,
    inc_di16,
    // 48
    dec_ax16,
    dec_cx16,
    dec_dx16,
    dec_bx16,
    dec_sp16,
    dec_bp16,
    dec_si16,
    dec_di16,
    // 50
    push_ax16,
    push_cx16,
    push_dx16,
    push_bx16,
    push_sp16,
    push_bp16,
    push_si16,
    push_di16,
    // 58
    pop_ax16,
    pop_cx16,
    pop_dx16,
    pop_bx16,
    pop_sp16,
    pop_bp16,
    pop_si16,
    pop_di16,
    // 60
    pusha16,
    popa16,
    bound16,
    privileged, 	// arpl
    ProcessPrefixes,	// fs:
    ProcessPrefixes,	// gs:
    ProcessPrefixes,	// data: prefix
    ProcessPrefixes,	// adr: prefix
    // 68
    push_iw16,
    imul_rw_m_iw16,
    push_ibs16,
    imul_rw_m_ib16,
    privileged,     // in_ib_dx
    privileged,     // in_iw_dx
    privileged,     // out_ib_dx
    privileged,     // out_iw_dx
    // 70
    jo8,
    jno8,
    jb8,
    jae8,
    je8,
    jne8,
    jbe8,
    ja8,
    // 78
    js8,
    jns8,
    jp8,
    jnp8,
    jl8,
    jnl8,
    jle8,
    jg8,
    // 80
    GROUP_18,
    GROUP_116,
    bad,
    GROUP_1WS16,
    test_r_m8,
    test_r_m16,
    xchg_r_m8,
    xchg_r_m16,
    // 88
    mov_m_r8,
    mov_m_r16,
    mov_r_m8,
    mov_r_m16,
    mov_mw_seg,
    lea_rw_mw16,
    mov_seg_mw,
    pop_mw16,
    // 90
    nop,
    xchg_ax_cx16,
    xchg_ax_dx16,
    xchg_ax_bx16,
    xchg_ax_sp16,
    xchg_ax_bp16,
    xchg_ax_si16,
    xchg_ax_di16,
    // 98
    cbw16,
    cwd16,
    call_md,
    wait,
    pushf16,
    popf16,
    sahf,
    lahf,
    // a0
    mov_a_m8,
    mov_a_m16,
    mov_m_a8,
    mov_m_a16,
    movs8,
    movs16,
    cmps8,
    cmps16,
    // a8
    test_a_i8,
    test_a_i16,
    stos8,
    stos16,
    lods8,
    lods16,
    scas8,
    scas16,
    // b0
    mov_a_i8,
    mov_c_i8,
    mov_d_i8,
    mov_b_i8,
    mov_ah_ib,
    mov_ch_ib,
    mov_dh_ib,
    mov_bh_ib,
    // b8
    mov_a_i16,
    mov_c_i16,
    mov_d_i16,
    mov_b_i16,
    mov_sp_iw16,
    mov_bp_iw16,
    mov_si_iw16,
    mov_di_iw16,
    // c0
    GROUP_28,
    GROUP_216,
    retn_i16,
    retn16,
    les_rw_mw16,
    lds_rw_mw16,
    mov_m_i8,
    mov_m_i16,
    // c8
    enter16,
    leave16,
    retf_i16,
    retf16,
    int3,
    int_ib,
    into,
    iret,
    // d0
    GROUP_2_18,
    GROUP_2_116,
    GROUP_2_CL8,
    GROUP_2_CL16,
    aam_ib,
    aad_ib,
    bad,
    xlat,
    // d8
    FLOAT_GP0,
    FLOAT_GP1,
    FLOAT_GP2,
    FLOAT_GP3,
    FLOAT_GP4,
    FLOAT_GP5,
    FLOAT_GP6,
    FLOAT_GP7,
    // e0
    loopne_b16,
    loope_b16,
    loop_b16,
    jcxz_b16,
    privileged,     // in_al_memb
    privileged,     // in_ax_memb
    privileged,     // out_memb_al
    privileged,     // out_memb_ax
    // e8
    call_rel16,
    jmp_rel16,
    jmpf_md,
    jmp_jb,
    privileged,     // in_al_dx
    privileged,     // in_ax_dx
    privileged,     // out_dx_al
    privileged,     // out_dx_ax
    // f0
    ProcessPrefixes,	// lock: prefix
    bad,
    ProcessPrefixes,	// repnz prefix
    ProcessPrefixes,	// repz prefix
    privileged, 	// halt
    cmc,
    GROUP_38,
    GROUP_316,
    // f8
    clc,
    stc,
    privileged,     // cli
    privileged,     // sti
    cld,
    std,
    GROUP_4,
    GROUP_516
};


pfnDispatchInstruction Dispatch216[256] = {
    // 0
    GROUP_6,
    GROUP_7,
    lar16,
    lsl16,
    bad,
    bad,
    privileged,	// clts
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    privileged,	// mov reg2W, eeeControl
    privileged,	// mov reg2W, eeeDebug
    privileged,	// mov eeeControl, reg2W
    privileged,	// mov eeeDebug, reg2W
    privileged,	// mov reg2W, eeeTest
    bad,
    privileged,	// mov eeeTest, reg2W
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    rdtsc,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    jo16,
    jno16,
    jb16,
    jae16,
    je16,
    jne16,
    jbe16,
    ja16,
    // 88
    js16,
    jns16,
    jp16,
    jnp16,
    jl16,
    jnl16,
    jle16,
    jg16,
    // 90
    seto_modrmb,
    setno_modrmb,
    setb_modrmb,
    setae_modrmb,
    sete_modrmb,
    setne_modrmb,
    setbe_modrmb,
    seta_modrmb,
    // 98
    sets_modrmb,
    setns_modrmb,
    setp_modrmb,
    setnp_modrmb,
    setl_modrmb,
    setge_modrmb,
    setle_modrmb,
    setg_modrmb,
    // a0
    push_fs,
    pop_fs,
    bad,
    bt_m_r16,
    shld_regw_modrmw_immb16,
    shld_regw_modrmw_cl16,
    bad,
    bad,
    // a8
    push_gs,
    pop_gs,
    bad,
    bts_m_r16,
    shrd_regw_modrmw_immb16,
    shrd_regw_modrmw_cl16,
    bad,
    imul_regw_modrmw16,
    // b0
    cmpxchg_m_r8,
    cmpxchg_m_r16,
    lss_rw_mw16,
    btr_m_r16,
    lfs_rw_mw16,
    lgs_rw_mw16,
    movzx_regw_modrmb16,
    movzx_regw_modrmw,
    // b8
    bad,
    bad,
    GROUP_816,
    btc_m_r16,
    bsf_modrmw_regw16,
    bsr_modrmw_regw16,
    movsx_regw_modrmb16,
    movsx_regw_modrmw,
    // c0
    xadd_m_r8,
    xadd_m_r16,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bswap_eax,
    bswap_ecx,
    bswap_edx,
    bswap_ebx,
    bswap_esp,
    bswap_ebp,
    bswap_esi,
    bswap_edi,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\decoder.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    decoder.c

Abstract:
    
    Public Decoder APIs and helper functions use in decoding instructions

Author:

    27-Jun-1995 BarryBo

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoder.h"
#include "decoderp.h"

ASSERTNAME;

ULONG
DecoderExceptionFilter(
    PINSTRUCTION                Instruction,
    struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:
    Handles any exception thrown while decoding an instruction.  Creates
    an OP_Fault instruction with operand2 being the exception code and
    operand1 being the address where the exception occurred.

Arguments:

    Instruction         - Structure to be filled in with the decoding
    ExInfo              - Information about the exception.

Return Value:

    ULONG - always EXCEPTION_EXECUTE_HANDLER.

--*/
{
    Instruction->Operation = OP_Fault;
    Instruction->Operand1.Type = OPND_IMM;
    Instruction->Operand2.Immed = (ULONG)(ULONGLONG)ExInfo->ExceptionRecord->ExceptionAddress;
    Instruction->Operand2.Type = OPND_IMM;
    Instruction->Operand1.Immed = ExInfo->ExceptionRecord->ExceptionCode;
    Instruction->Size = 1;

    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
DecodeInstruction(
    DWORD           InstructionAddress,
    PINSTRUCTION    Instruction
    )
/*++

Routine Description:
    Decodes a single Intel instruction beginning at InstructionAddress, filling
    in the INSTRUCTION structure.

Arguments:

    InstructionAddress  - Address of first byte of the Intel Instruction
    Instruction         - Structure to be filled in with the decoding

Return Value:

    None - always succeeds.

--*/

{
    DECODERSTATE    DecoderState;


    //
    // Initialize the Instruction structure.  Instruction structures are
    // zero-filled by the analysis phase, so only non-zero fields need
    // to be filled in here.
    //
    Instruction->Size = 1;
    Instruction->Operand1.Reg = NO_REG;
    Instruction->Operand1.IndexReg = NO_REG;
    Instruction->Operand2.Reg = NO_REG;
    Instruction->Operand2.IndexReg = NO_REG;
    Instruction->Operand3.Reg = NO_REG;
    Instruction->Operand3.IndexReg = NO_REG;
    Instruction->IntelAddress = InstructionAddress;

    // Initialize the decoder state info
    DecoderState.InstructionAddress = InstructionAddress;
    DecoderState.RepPrefix = PREFIX_NONE;
    DecoderState.AdrPrefix = FALSE;
    DecoderState.OperationOverride = OP_MAX;

    try {

        // Decode the instruction, filling in the Instruction structure
        (Dispatch32[GET_BYTE(InstructionAddress)])(&DecoderState, Instruction);

    } except(DecoderExceptionFilter(Instruction, GetExceptionInformation())) {

    }

    // Handle illegal instructions
    if (DecoderState.OperationOverride != OP_MAX) {
        Instruction->Size = 1;
        Instruction->Operation = DecoderState.OperationOverride;
        Instruction->Operand1.Type = OPND_NONE;
        Instruction->Operand2.Type = OPND_NONE;
    }

    // If Operand2 is filled-in, then Operand1 must also be filled in.
    CPUASSERT(Instruction->Operand2.Type == OPND_NONE ||
              Instruction->Operand1.Type != OPND_NONE);
}



void get_segreg(PDECODERSTATE State, POPERAND op)
{
    BYTE Reg = ((*(PBYTE)(eipTemp+1)) >> 3) & 0x07;

    op->Type = OPND_REGVALUE;
    op->Reg = REG_ES + Reg;
    if (Reg > 5) {
        BAD_INSTR;
    }
}

int scaled_index(PBYTE pmodrm, POPERAND op)
{
    BYTE sib = *(pmodrm+1);
    INT IndexReg = GP_EAX + (sib >> 3) & 0x07;
    BYTE base = GP_EAX + sib & 0x07;

    op->Type = OPND_ADDRREF;
    op->Scale = sib >> 6;

    if (IndexReg != GP_ESP) {
        op->IndexReg = IndexReg;
    } // else op->IndexReg = NO_REG, which is the default value

    if (base == GP_EBP && ((*pmodrm) >> 6) == 0) {
        op->Immed = GET_LONG(pmodrm+2);
        return 5;   // account for sib+DWORD
    }

    op->Reg = base;
    return 1;   // account for sib
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\floatfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    floatfns.c

Abstract:
    
    Floating point instruction decoder.

Author:

    16-Aug-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

extern DWORD pfnNPXNPHandler;
extern BOOLEAN fUseNPXEM;

typedef float *PFLOAT;
typedef double *PDOUBLE;

typedef void (*pfnFrag0)(PCPUDATA);
typedef void (*pfnFrag1INT)(PCPUDATA, INT);
typedef void (*pfnFrag1FLOAT)(PCPUDATA, PFLOAT);
typedef void (*pfnFrag1DOUBLE)(PCPUDATA, PDOUBLE);
typedef void (*pfnFrag1PLONG)(PCPUDATA, PLONG);
typedef void (*pfnFrag2INTINT)(PCPUDATA, INT, INT);
typedef void (*pfnFrag1PUSHORT)(PCPUDATA, PUSHORT);

OPERATION GP0Mem[8] = {OP_FP_FADD32,
                           OP_FP_FMUL32,
                           OP_FP_FCOM32,
                           OP_FP_FCOMP32,
                           OP_FP_FSUB32,
                           OP_FP_FSUBR32,
                           OP_FP_FDIV32,
                           OP_FP_FDIVR32};


OPERATION GP0Top[8] = {OP_FP_FADD_ST_STi,
                         OP_FP_FMUL_ST_STi,
                         OP_FP_FCOM_STi,
                         OP_FP_FCOMP_STi,
                         OP_FP_FSUB_ST_STi,
                         OP_FP_FSUBR_ST_STi,
                         OP_FP_FDIV_ST_STi,
                         OP_FP_FDIVR_ST_STi};

OPERATION GP1GroupFCHS[8] = {OP_FP_FCHS,
                            OP_FP_FABS,
                            OP_BadInstruction,
                            OP_BadInstruction,
                            OP_FP_FTST,
                            OP_FP_FXAM,
                            OP_BadInstruction,
                            OP_BadInstruction};

OPERATION GP1GroupFLD1[8] = {OP_FP_FLD1,
                            OP_FP_FLDL2T,
                            OP_FP_FLDL2E,
                            OP_FP_FLDPI,
                            OP_FP_FLDLG2,
                            OP_FP_FLDLN2,
                            OP_FP_FLDZ,
                            OP_BadInstruction};

OPERATION GP1GroupF2XM1[8] = {OP_FP_F2XM1,
                             OP_FP_FYL2X,
                             OP_FP_FPTAN,
                             OP_FP_FPATAN,
                             OP_FP_FXTRACT,
                             OP_FP_FPREM1,
                             OP_FP_FDECSTP,
                             OP_FP_FINCSTP};

OPERATION GP1GroupFPREM[8] = {OP_FP_FPREM,
                             OP_FP_FYL2XP1,
                             OP_FP_FSQRT,
                             OP_FP_FSINCOS,
                             OP_FP_FRNDINT,
                             OP_FP_FSCALE,
                             OP_FP_FSIN,
                             OP_FP_FCOS};

OPERATION GP1Mem[8] = {OP_FP_FLD32,
                           OP_BadInstruction,        // never called
                           OP_FP_FST32,
                           OP_FP_FSTP32,
                           OP_FP_FLDENV,
                           OP_FP_FLDCW,
                           OP_FP_FNSTENV,
                           OP_FP_FNSTCW};

OPERATION GP2Mem[8] = {OP_FP_FIADD32,
                           OP_FP_FIMUL32,
                           OP_FP_FICOM32,
                           OP_FP_FICOMP32,
                           OP_FP_FISUB32,
                           OP_FP_FISUBR32,
                           OP_FP_FIDIV32,
                           OP_FP_FIDIVR32};

OPERATION GP4Mem[8] = {OP_FP_FADD64,
                            OP_FP_FMUL64,
                            OP_FP_FCOM64,
                            OP_FP_FCOMP64,
                            OP_FP_FSUB64,
                            OP_FP_FSUBR64,
                            OP_FP_FDIV64,
                            OP_FP_FDIVR64};

OPERATION GP4Reg[8] = {OP_FP_FADD_STi_ST,
                         OP_FP_FMUL_STi_ST,
                         OP_FP_FCOM_STi,
                         OP_FP_FCOMP_STi,
                         OP_FP_FSUB_STi_ST,
                         OP_FP_FSUBR_STi_ST,
                         OP_FP_FDIV_STi_ST,
                         OP_FP_FDIVR_STi_ST};

OPERATION GP5Mem[8] = {OP_FP_FLD64,
                        OP_BadInstruction,
                        OP_FP_FST64,
                        OP_FP_FSTP64,
                        OP_FP_FRSTOR,
                        OP_BadInstruction,
                        OP_FP_FNSAVE,
                        OP_FP_FNSTSW};

OPERATION GP5Reg[8] = {OP_FP_FFREE,
                         OP_FP_FXCH_STi,
                         OP_FP_FST_STi,
                         OP_FP_FSTP_STi,
                         OP_FP_FUCOM,
                         OP_FP_FUCOMP,
                         OP_BadInstruction,
                         OP_BadInstruction};

OPERATION GP6Mem[8] = {OP_FP_FIADD16,
                             OP_FP_FIMUL16,
                             OP_FP_FICOM16,
                             OP_FP_FICOMP16,
                             OP_FP_FISUB16,
                             OP_FP_FISUBR16,
                             OP_FP_FIDIV16,
                             OP_FP_FIDIVR16};

OPERATION GP6Reg[8] = {OP_FP_FADDP_STi_ST,
                         OP_FP_FMULP_STi_ST,
                         OP_FP_FCOMP_STi,
                         OP_FP_FCOMPP,
                         OP_FP_FSUBP_STi_ST,
                         OP_FP_FSUBRP_STi_ST,
                         OP_FP_FDIVP_STi_ST,
                         OP_FP_FDIVRP_STi_ST};

OPERATION GP7Mem[8] = {OP_FP_FILD16,
                             OP_BadInstruction,
                             OP_FP_FIST16,
                             OP_FP_FISTP16,
                             OP_FP_FBLD,
                             OP_FP_FILD64,
                             OP_FP_FBSTP,
                             OP_FP_FISTP64};

OPERATION GP7Reg[8] = {OP_FP_FFREE,     // not in Intel docs, but NTSD knows it
                         OP_FP_FXCH_STi,  // not in Intel docs, but NTSD knows it
                         OP_FP_FST_STi,
                         OP_FP_FSTP_STi,
                         OP_BadInstruction,
                         OP_BadInstruction,
                         OP_BadInstruction,
                         OP_BadInstruction};



//***************************************************************************


DISPATCH(FLOAT_GP0)     // d8 XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP0Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;
    } else {
        // register format

        Instr->Operation = GP0Top[(secondByte>>3) & 7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;        // dest of call
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}



DISPATCH(FLOAT_GP1)     // d9 XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        if (inst == 1) {
            Instr->Operation = OP_BadInstruction;
        } else {
            int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
            Instr->Operation = GP1Mem[(secondByte>>3) & 7];
            Instr->Size = cbInstr+1;
        }
    } else {
        // register format
        switch ( inst ) {
        case 0:                 // d9 c0+i
            Instr->Operation = OP_FP_FLD_STi;
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            break;
        case 1:                 // d9 c8+i
            Instr->Operation = OP_FP_FXCH_STi;
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            break;
        case 2:
            if (secondByte == 0xd0) {
                Instr->Operation = OP_FP_FNOP;          // FNOP  (d9 d0)
            } else {
                Instr->Operation = OP_BadInstruction;   // (d9 d1..d7)
            }
            break;
        case 3:                 // d9 d8+i
            Instr->Operation = OP_BadInstruction;
            //UNDONE: emstore.asm says FSTP Special Form 1
            break;
        case 4:                 // d9 e0+i
            Instr->Operation = GP1GroupFCHS[secondByte&7];
            break;
        case 5:
            Instr->Operation = GP1GroupFLD1[secondByte&7];
            break;
        case 6:
            Instr->Operation = GP1GroupF2XM1[secondByte&7];
            break;
        default:
        case 7:
            Instr->Operation = GP1GroupFPREM[secondByte&7];
            break;
        }
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP2)     // da XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP2Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;

    } else if (secondByte == 0xe9) {
        Instr->Operation = OP_FP_FUCOMPP;
        Instr->Size = 2;
    } else {
        Instr->Operation = OP_BadInstruction;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP3)     // db XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format
        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);

        switch ((secondByte>>3) & 7) {
        case 0:
            Instr->Operation = OP_FP_FILD32;
            break;
        case 1:
        case 4:
        case 6:
            Instr->Operation = OP_BadInstruction;
            break;
        case 2:
            Instr->Operation = OP_FP_FIST32;
            break;
        case 3:
            Instr->Operation = OP_FP_FISTP32;
            break;
        case 5:
            Instr->Operation = OP_FP_FLD80;
            break;
        case 7:
            Instr->Operation = OP_FP_FSTP80;
            break;
        }
        Instr->Size = cbInstr+1;
    } else {
        Instr->Size = 2;

        if (secondByte == 0xe2) {
            Instr->Operation = OP_FP_FNCLEX;
        } else if (secondByte == 0xe3) {
            Instr->Operation = OP_FP_FNINIT;
        } else {
            Instr->Operation = OP_FP_FNOP;  // FDISI, FENI, FSETPM are 2-byte FNOPs
        }
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}



DISPATCH(FLOAT_GP4)     // dc XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP4Mem[(secondByte>>3) & 7];
        Instr->Size = cbInstr+1;
    } else {
        // register format - "OP ST(i)"

        Instr->Operation = GP4Reg[(secondByte>>3) & 7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP5)     // dd XX
{
    BYTE secondByte;

    secondByte = *((PBYTE)(eipTemp+1));

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP5Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format "OP ST(i)"

        Instr->Operation = GP5Reg[(secondByte>>3)&7];
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = secondByte & 7;
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP6)     // de XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP6Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format

        if (inst == 3 && secondByte != 0xd9) {
            Instr->Operation = OP_BadInstruction;
        } else {
            Instr->Operation = GP6Reg[inst];
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
            Instr->Size = 2;
        }
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}


DISPATCH(FLOAT_GP7)     // df XX
{
    BYTE secondByte, inst;

    secondByte = *((PBYTE)(eipTemp+1));
    inst = (secondByte>>3) & 7;

    if (secondByte < 0xc0) {
        // memory format

        int cbInstr = mod_rm_reg32(State, &Instr->Operand1, NULL);
        Instr->Operation = GP7Mem[(secondByte>>3)&7];
        Instr->Size = cbInstr+1;
    } else {
        // register format
        if (inst == 4) {
            Instr->Operation = OP_FP_FNSTSW;
            Instr->Operand1.Type = OPND_REGREF;
            Instr->Operand1.Reg = GP_AX;
        } else {
            Instr->Operation = GP7Reg[inst];
            Instr->Operand1.Type = OPND_IMM;
            Instr->Operand1.Immed = secondByte & 7;
        }
        Instr->Size = 2;
    }

    if (fUseNPXEM) {
        // generate a "CALL pfnNPXNPHandler" instruction, with a length
        // the same as the FP instruction we're emulating.
        Instr->Operation = OP_CTRL_UNCOND_Call;
        Instr->Operand1.Type = OPND_IMM;
        Instr->Operand1.Immed = pfnNPXNPHandler;
        Instr->Operand2.Type = OPND_IMM;
        Instr->Operand2.Immed = eipTemp;    // addr of FP instr
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\dwordfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dwordfns.c

Abstract:
    
    Instuctions which operate on 32-bit DWORDS

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "dwordfns.h"

ASSERTNAME;

// set up to include common functions
#define GET_REG 	    get_reg32
#define MANGLENAME(x)       x ## 32
#define MSB		    0x80000000
#define MOD_RM              mod_rm_reg32
#define UTYPE		    unsigned long
#define STYPE		    signed long
#define GET_VAL 	    GET_LONG
#define PUT_VAL 	    PUT_LONG
#define PUSH_VAL	    PUSH_LONG
#define POP_VAL 	    POP_LONG
#define OPNAME(x)           OP_ ## x ## 32
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 32
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 32)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 32 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 32 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 32 , pop1, op2)
#define AREG                GP_EAX
#define BREG                GP_EBX
#define CREG                GP_ECX
#define DREG                GP_EDX
#define SPREG               GP_ESP
#define BPREG               GP_EBP
#define SIREG               GP_ESI
#define DIREG               GP_EDI
#define DEREF(Op)           DEREF32(Op)

// include the common functions with 8/16/32 flavors
#include "common.c"

// include the common functions with 16/32 flavors
#include "comm1632.c"

// create the mod_rm_reg32() decoder function
#define MOD11_RM000         GP_EAX
#define MOD11_RM001         GP_ECX
#define MOD11_RM010         GP_EDX
#define MOD11_RM011         GP_EBX
#define MOD11_RM100         GP_ESP
#define MOD11_RM101         GP_EBP
#define MOD11_RM110         GP_ESI
#define MOD11_RM111         GP_EDI
#define REG000              GP_EAX
#define REG001              GP_ECX
#define REG010              GP_EDX
#define REG011              GP_EBX
#define REG100              GP_ESP
#define REG101              GP_EBP
#define REG110              GP_ESI
#define REG111              GP_EDI
#define MOD_RM_DECODER      mod_rm_reg32
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\lds16tbl.c ===
// Tables for DS: 32-bit instructions
//  (ie. no FS:, but DATA: specified)
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lds16tbl.c

Abstract:
    
    Dispatch tables for instructions with DATA: override and the LOCK
    prefix.  It is used for both DS: and FS: overrides.

Author:

    23-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "wordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction LockDispatch16[256] = {
    // 0
    LOCKadd_m_r8,
    LOCKadd_m_r16,
    LOCKadd_r_m8,
    LOCKadd_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 8
    LOCKor_m_r8,
    LOCKor_m_r16,
    LOCKor_r_m8,
    LOCKor_r_m16,
    bad,
    bad,
    bad,
    LOCKdispatch216,
    // 10
    LOCKadc_m_r8,
    LOCKadc_m_r16,
    LOCKadc_r_m8,
    LOCKadc_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 18
    LOCKsbb_m_r8,
    LOCKsbb_m_r16,
    LOCKsbb_r_m8,
    LOCKsbb_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 20
    LOCKand_m_r8,
    LOCKand_m_r16,
    LOCKand_r_m8,
    LOCKand_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 28
    LOCKsub_m_r8,
    LOCKsub_m_r16,
    LOCKsub_r_m8,
    LOCKsub_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 30
    LOCKxor_m_r8,
    LOCKxor_m_r16,
    LOCKxor_r_m8,
    LOCKxor_r_m16,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    LOCKGROUP_18,
    LOCKGROUP_116,
    bad,
    LOCKGROUP_1WS16,
    bad,
    bad,
    xchg_r_m8,
    xchg_r_m16,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_38,
    LOCKGROUP_316,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_516,
};


pfnDispatchInstruction LockDispatch216[256] = {
    // 0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    LOCKbts_m_r16,
    bad,
    bad,
    bad,
    bad,
    // b0
    LOCKcmpxchg_m_r8,
    LOCKcmpxchg_m_r16,
    bad,
    LOCKbtr_m_r16,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    LOCKGROUP_816,
    LOCKbtc_m_r16,
    bad,
    bad,
    bad,
    bad,
    // c0
    LOCKxadd_m_r8,
    LOCKxadd_m_r16,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\miscfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    miscfns.h

Abstract:
    
    Prototypes for miscellaneous instructions.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef MISCFNS_H
#define MISCFNS_H

DISPATCH(ProcessPrefixes);
DISPATCH(bad);
DISPATCH(privileged);
DISPATCH(push_es);
DISPATCH(pop_es);
DISPATCH(push_cs);
DISPATCH(aas);
DISPATCH(push_ss);
DISPATCH(pop_ss);
DISPATCH(push_ds);
DISPATCH(pop_ds);
DISPATCH(daa);
DISPATCH(das);
DISPATCH(aaa);
DISPATCH(push_iw);
DISPATCH(imul_rw_mw);
DISPATCH(push_ibs);
DISPATCH(imul_rw_m_iw16);
DISPATCH(imul_rw_m_iw32);
DISPATCH(imul_rw_m_ib16);
DISPATCH(imul_rw_m_ib32);
DISPATCH(GROUP_1WS);
DISPATCH(mov_rw_mw);
DISPATCH(mov_mw_seg);
DISPATCH(lea_rw_mw);
DISPATCH(mov_seg_mw);
DISPATCH(pop_mw);
DISPATCH(nop);
DISPATCH(call_md);
DISPATCH(sahf);
DISPATCH(lahf);
DISPATCH(movsb);
DISPATCH(movsw);
DISPATCH(cmpsb);
DISPATCH(cmpsw);
DISPATCH(stosb);
DISPATCH(stosw);
DISPATCH(lodsb);
DISPATCH(lodsw);
DISPATCH(scasb);
DISPATCH(scasw);
DISPATCH(mov_ah_ib);
DISPATCH(mov_ch_ib);
DISPATCH(mov_dh_ib);
DISPATCH(mov_bh_ib);
DISPATCH(mov_sp_iw);
DISPATCH(mov_bp_iw);
DISPATCH(mov_si_iw);
DISPATCH(mov_di_iw);
DISPATCH(retn_iw);
DISPATCH(retn);
DISPATCH(enter_iw_ib);
DISPATCH(leaveX);    // 'leave' is already defined on PPC
DISPATCH(int3);
DISPATCH(int_ib);
DISPATCH(into);
DISPATCH(iret);
DISPATCH(aam_ib);
DISPATCH(aad_ib);
DISPATCH(xlat);
DISPATCH(FLOAT_INSTR);
DISPATCH(loopne_b);
DISPATCH(loope_b);
DISPATCH(loop_b);
DISPATCH(jcxz_b);
DISPATCH(jmpf_md);
DISPATCH(jmp_jb);
DISPATCH(cmc);
DISPATCH(clc);
DISPATCH(stc);
DISPATCH(cld);
DISPATCH(std);
DISPATCH(GROUP_4);
DISPATCH(GROUP_5);
DISPATCH(GROUP_6);
DISPATCH(GROUP_7);
DISPATCH(GROUP_8);
DISPATCH(seto_modrmb);
DISPATCH(setno_modrmb);
DISPATCH(setb_modrmb);
DISPATCH(setae_modrmb);
DISPATCH(sete_modrmb);
DISPATCH(setne_modrmb);
DISPATCH(setbe_modrmb);
DISPATCH(seta_modrmb);
DISPATCH(sets_modrmb);
DISPATCH(setns_modrmb);
DISPATCH(setp_modrmb);
DISPATCH(setnp_modrmb);
DISPATCH(setl_modrmb);
DISPATCH(setge_modrmb);
DISPATCH(setle_modrmb);
DISPATCH(setg_modrmb);
DISPATCH(push_fs);
DISPATCH(pop_fs);
DISPATCH(bt_modrmw_regw);
DISPATCH(push_gs);
DISPATCH(pop_gs);
DISPATCH(imul_regw_modrmw16);
DISPATCH(imul_regw_modrmw32);
DISPATCH(btr_modrmw_regw);
DISPATCH(movzx_regb_modrmb);
DISPATCH(movzx_regw_modrmw);
DISPATCH(btc_modrmw_regw);
DISPATCH(movsx_regb_modrmb);
DISPATCH(movsx_regw_modrmw);
DISPATCH(wait);
DISPATCH(bswap_eax);
DISPATCH(bswap_ebx);
DISPATCH(bswap_ecx);
DISPATCH(bswap_edx);
DISPATCH(bswap_esp);
DISPATCH(bswap_ebp);
DISPATCH(bswap_esi);
DISPATCH(bswap_edi);
DISPATCH(arpl);
DISPATCH(cpuid);
DISPATCH(cmpxchg8b);
DISPATCH(LOCKcmpxchg8b);
DISPATCH(rdtsc);

#endif //MISCFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\wordfns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wordfns.h

Abstract:
    
    Prototypes for instructions which operate on 16-bit WORDS.

Author:

    06-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef WORDFNS_H
#define WORDFNS_H

#define DISPATCHCOMMON(x) DISPATCH(x ## 16)
#include "common.h"
#include "comm1632.h"
#undef DISPATCHCOMMON

#endif //WORDFNS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\lds32tbl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lds32tbl.c

Abstract:
    
    Dispatch table for 32bit instructions with the LOCK prefix.

Author:

    23-Aug-1995 Ori Gershony (t-orig)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

#include "bytefns.h"
#include "dwordfns.h"
#include "miscfns.h"
#include "floatfns.h"

pfnDispatchInstruction LockDispatch32[256] = {
    // 0
    LOCKadd_m_r8,
    LOCKadd_m_r32,
    LOCKadd_r_m8,
    LOCKadd_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 8
    LOCKor_m_r8,
    LOCKor_m_r32,
    LOCKor_r_m8,
    LOCKor_r_m32,
    bad,
    bad,
    bad,
    LOCKdispatch232,
    // 10
    LOCKadc_m_r8,
    LOCKadc_m_r32,
    LOCKadc_r_m8,
    LOCKadc_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 18
    LOCKsbb_m_r8,
    LOCKsbb_m_r32,
    LOCKsbb_r_m8,
    LOCKsbb_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 20
    LOCKand_m_r8,
    LOCKand_m_r32,
    LOCKand_r_m8,
    LOCKand_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 28
    LOCKsub_m_r8,
    LOCKsub_m_r32,
    LOCKsub_r_m8,
    LOCKsub_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 30
    LOCKxor_m_r8,
    LOCKxor_m_r32,
    LOCKxor_r_m8,
    LOCKxor_r_m32,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    LOCKGROUP_18,
    LOCKGROUP_132,
    bad,
    LOCKGROUP_1WS32,
    bad,
    bad,
    xchg_r_m8,
    xchg_r_m32,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_38,
    LOCKGROUP_332,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKGROUP_532,
};


pfnDispatchInstruction LockDispatch232[256] = {
    // 0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 10
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 18
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 20
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 28
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 30
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 38
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 40
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 48
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 50
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 58
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 60
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 68
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 70
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 78
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 80
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 88
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 90
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // 98
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // a8
    bad,
    bad,
    bad,
    LOCKbts_m_r32,
    bad,
    bad,
    bad,
    bad,
    // b0
    LOCKcmpxchg_m_r8,
    LOCKcmpxchg_m_r32,
    bad,
    LOCKbtr_m_r32,
    bad,
    bad,
    bad,
    bad,
    // b8
    bad,
    bad,
    LOCKGROUP_832,
    LOCKbtc_m_r32,
    bad,
    bad,
    bad,
    bad,
    // c0
    LOCKxadd_m_r8,
    LOCKxadd_m_r32,
    bad,
    bad,
    bad,
    bad,
    bad,
    LOCKcmpxchg8b,
    // c8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // d8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // e8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f0
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    // f8
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad,
    bad
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\wordfns.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wordfns.c

Abstract:
    
    Instuctions which operate on 16-bit WORDS

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"
#include "wordfns.h"

ASSERTNAME;

// set up to include common functions
#define GET_REG 	    get_reg16
#define MANGLENAME(x)       x ## 16
#define MSB		    0x8000
#define MOD_RM              mod_rm_reg16
#define UTYPE		    unsigned short
#define STYPE		    signed short
#define GET_VAL 	    GET_SHORT
#define PUT_VAL 	    PUT_SHORT
#define PUSH_VAL	    PUSH_SHORT
#define POP_VAL             POP_SHORT
#define OPNAME(x)           OP_ ## x ## 16
#define LOCKOPNAME(x)       OP_SynchLock ## x ## 16
#define DISPATCHCOMMON(fn)  DISPATCH(fn ## 16)
#define CALLFRAGCOMMON0(fn)            CALLFRAG0( fn ## 16 )
#define CALLFRAGCOMMON1(fn, pop1)      CALLFRAG1( fn ## 16 , pop1)
#define CALLFRAGCOMMON2(fn, pop1, op2) CALLFRAG2( fn ## 16 , pop1, op2)
#define AREG                GP_AX
#define BREG                GP_BX
#define CREG                GP_CX
#define DREG                GP_DX
#define SPREG               GP_SP
#define BPREG               GP_BP
#define SIREG               GP_SI
#define DIREG               GP_DI
#define DEREF(Op)           DEREF16(Op)

// include the common functions with 8/16/32 flavors
#include "common.c"

// include the common functions with 16/32 flavors
#include "comm1632.c"

// create the mod_rm_reg16() decoder function
#define MOD11_RM000         GP_AX
#define MOD11_RM001         GP_CX
#define MOD11_RM010         GP_DX
#define MOD11_RM011         GP_BX
#define MOD11_RM100         GP_SP
#define MOD11_RM101         GP_BP
#define MOD11_RM110         GP_SI
#define MOD11_RM111         GP_DI
#define REG000              GP_AX
#define REG001              GP_CX
#define REG010              GP_DX
#define REG011              GP_BX
#define REG100              GP_SP
#define REG101              GP_BP
#define REG110              GP_SI
#define REG111              GP_DI
#define MOD_RM_DECODER      mod_rm_reg16
#include "modrm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\miscfns.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    miscfns.c

Abstract:
    
    Miscellaneous instuctions

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "threadst.h"
#include "instr.h"
#include "decoderp.h"

ASSERTNAME;

// table used by ProcessPrefixes
pfnDispatchInstruction *DispatchTables[4] = { Dispatch32, Dispatch16, LockDispatch32, LockDispatch16 };


// ---------------- single-byte functions -------------------------------
DISPATCH(ProcessPrefixes)
{
    int DataPrefix = 0;
    int LockPrefix = 0;
    int cbInstr = 0;

    for (;;) {
	switch (*(PBYTE)(eipTemp)) {
        case 0x64:          // fs:
            Instr->FsOverride = TRUE;
	    break;

	case 0xf3:	    // repz
            State->RepPrefix = PREFIX_REPZ;
	    break;

	case 0xf2:	    // repnz
            State->RepPrefix = PREFIX_REPNZ;
	    break;

	case 0xf0:	    // lock
            LockPrefix = 2;  // The lock tables are in locations 2 and 3 DispatchTables
	    break;

	case 0x2e:	    // cs:
	case 0x36:	    // ss:
	case 0x3e:	    // ds:
	case 0x26:	    // es:
        case 0x65:          // gs:
            Instr->FsOverride = FALSE;
	    break;

	case 0x66:	    // data
	    DataPrefix = 1;
	    break;

        case 0x67:          // adr
            State->AdrPrefix=TRUE;
	    break;

	default:
	    // No more prefixes found.	Set up dispatch tables based on
	    // the prefixes seen.

	    // Decode and execute the actual instruction
            ((DispatchTables[DataPrefix+LockPrefix])[GET_BYTE(eipTemp)])(State, Instr);

            // Adjust the Intel instruction size by the number of prefixes
            Instr->Size += cbInstr;

#if DBG
            // Ensure that if we saw an ADR: prefix, the decoder had code
            // to handle the prefix.  In the checked build, all functions which
            // handle the ADR: prefix clear State->AdrPrefix.
            if (State->AdrPrefix) {
                LOGPRINT((TRACELOG, "CPU Decoder: An unsupported instruction had an ADR: prefix.\r\n"
                        "Instruction Address = 0x%x.  Ignoring ADR: - this address may be data\r\n",
                        Instr->IntelAddress
                       ));
            }
#endif
            State->AdrPrefix = FALSE;

            // return to the decoder
	    return;
	}
        eipTemp++;
        cbInstr++;
    }
}
DISPATCH(bad)
{
    BAD_INSTR;
}
DISPATCH(privileged)
{
    PRIVILEGED_INSTR;
}
DISPATCH(push_es)
{
    Instr->Operation = OP_PushEs;
}
DISPATCH(pop_es)
{
    Instr->Operation = OP_PopEs;
}
DISPATCH(push_cs)
{
    Instr->Operation = OP_PushCs;
}
DISPATCH(aas)
{
    Instr->Operation = OP_Aas;
}
DISPATCH(push_ss)
{
    Instr->Operation = OP_PushSs;
}
DISPATCH(pop_ss)
{
    Instr->Operation = OP_PopSs;
}
DISPATCH(push_ds)
{
    Instr->Operation = OP_PushDs;
}
DISPATCH(pop_ds)
{
    Instr->Operation = OP_PopDs;
}
DISPATCH(daa)
{
    Instr->Operation = OP_Daa;
}
DISPATCH(das)
{
    Instr->Operation = OP_Das;
}
DISPATCH(aaa)
{
    Instr->Operation = OP_Aaa;
}
DISPATCH(aad_ib)
{
    Instr->Operation = OP_Aad;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(imul_rw_m_iw16) // reg16 = rm16 * immediate word
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg16;
    DEREF16(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_SHORT(eipTemp+1+cbInstr);
    Instr->Size = 3+cbInstr;
}
DISPATCH(imul_rw_m_iw32)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg32;
    DEREF32(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = GET_LONG(eipTemp+1+cbInstr);
    Instr->Size = 5+cbInstr;
}
DISPATCH(imul_rw_m_ib16) // reg16 = rm16 * sign-extended immediate byte
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg16;
    DEREF16(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = (DWORD)(short)(char)GET_BYTE(eipTemp+1+cbInstr);
    Instr->Size = 2+cbInstr;
}
DISPATCH(imul_rw_m_ib32)	// reg32 = rm32 * sign-extended immediate byte
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul3Arg32;
    DEREF32(Instr->Operand2);
    Instr->Operand3.Type = OPND_IMM;
    Instr->Operand3.Immed = (DWORD)(long)(char)GET_BYTE(eipTemp+1+cbInstr);
    Instr->Size = 2+cbInstr;
}
DISPATCH(mov_mw_seg)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
    get_segreg(State, &Instr->Operand2);

    Instr->Operation = OP_Mov16;
    Instr->Size = cbInstr+1;
}
DISPATCH(mov_seg_mw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, NULL);
    get_segreg(State, &Instr->Operand1);

    Instr->Operation = OP_Mov16;
    DEREF16(Instr->Operand2);
    CPUASSERT(Instr->Operand1.Type == OPND_REGVALUE);
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Size = cbInstr+1;
}
DISPATCH(nop)
{
    Instr->Operation = OP_Nop;
}
DISPATCH(call_md)
{
    Instr->Operation = OP_CTRL_UNCOND_Callf;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = eipTemp+1;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = eipTemp+sizeof(ULONG)+sizeof(USHORT)+1;
    Instr->Size = sizeof(ULONG)+sizeof(USHORT)+1;
}
DISPATCH(sahf)
{
    Instr->Operation = OP_Sahf;
}
DISPATCH(lahf)
{
    Instr->Operation = OP_Lahf;
}
DISPATCH(mov_ah_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_AH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_ch_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_CH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_dh_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_DH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(mov_bh_ib)
{
    Instr->Operation = OP_Mov8;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_BH;
    Instr->Operand2.Type = OPND_IMM;
    Instr->Operand2.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(int3)
{
    Instr->Operation = OP_Int;
}
DISPATCH(int_ib)
{
    Instr->Operation = OP_Int;
    Instr->Size = 2;
}
DISPATCH(into)
{
    Instr->Operation = OP_IntO;
}
DISPATCH(iret)
{
    Instr->Operation = OP_CTRL_INDIR_IRet;
}
DISPATCH(aam_ib)
{
    Instr->Operation = OP_Aam;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = GET_BYTE(eipTemp+1);
    Instr->Size = 2;
}
DISPATCH(xlat)
{
    Instr->Operation = OP_Xlat;
}
DISPATCH(jmpf_md)
{
    Instr->Operation = OP_CTRL_UNCOND_Jmpf;
    Instr->Operand1.Type = OPND_IMM;
    Instr->Operand1.Immed = eipTemp+1;
    Instr->Size = 7;
}
DISPATCH(jmp_jb)
{
    Instr->Operand1.Type = OPND_NOCODEGEN;
    if (State->AdrPrefix) {
        Instr->Operand1.Immed = MAKELONG((short)(char)GET_BYTE(eipTemp+1)+2+(short)LOWORD(eipTemp), HIWORD(eipTemp));
#if DBG
        State->AdrPrefix = FALSE;
#endif
    } else {
        Instr->Operand1.Immed = (DWORD)(long)(char)GET_BYTE(eipTemp+1)+2+eipTemp;
    }
    if (Instr->Operand1.Immed > eipTemp) {
        Instr->Operation = OP_CTRL_UNCOND_JmpFwd;
    } else {
        Instr->Operation = OP_CTRL_UNCOND_Jmp;
    }
    Instr->Size = 2;
}
DISPATCH(cmc)
{
    Instr->Operation = OP_Cmc;
}
DISPATCH(clc)
{
    Instr->Operation = OP_Clc;
}
DISPATCH(stc)
{
    Instr->Operation = OP_Stc;
}
DISPATCH(cld)
{
    Instr->Operation = OP_Cld;
}
DISPATCH(std)
{
    Instr->Operation = OP_Std;
}
DISPATCH(GROUP_4)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);
    BYTE g = GET_BYTE(eipTemp+1);

    switch ((g >> 3) & 0x07) {
    case 0: // inc modrmB
        Instr->Operation = OP_Inc8;
        Instr->Size = 1+cbInstr;
	break;
    case 1: // dec modrmB
        Instr->Operation = OP_Dec8;
        Instr->Size = 1+cbInstr;
        break;
    default:
	BAD_INSTR;
    }
}



//-------- double-byte functions -----------------------------------------------



DISPATCH(GROUP_6)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // sldt modrmw
    case 1: // str modrmw
    case 2: // lldt modrmw
    case 3: // ltr modrmw
        PRIVILEGED_INSTR;
        break;

    case 4: // verr modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Verr;
        Instr->Size = 2+cbInstr;
        break;

    case 5: // verw modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Verw;
        Instr->Size = 2+cbInstr;
        break;

    default:
	BAD_INSTR;	// bad
    }
}
DISPATCH(GROUP_7)
{
    BYTE g = GET_BYTE(eipTemp+1);
    int cbInstr;

    switch ((g >> 3) & 0x07) {
    case 0: // sgdt modrmw
    case 1: // sidt modrmw
    case 2: // lgdt modrmw
    case 3: // lidt modrmw
    case 6: // lmsw modrmw
        PRIVILEGED_INSTR;
        break;

    case 4: // smsw modrmw
        cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
        Instr->Operation = OP_Smsw;
        Instr->Size = 2+cbInstr;
        break;

    case 5: // bad
    case 7: // bad
	BAD_INSTR;
    }
}
DISPATCH(seto_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Seto;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setno_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setno;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setb_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setb;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setae_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setae;
    Instr->Size = 2+cbInstr;
}
DISPATCH(sete_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Sete;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setne_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setne;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setbe_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setbe;
    Instr->Size = 2+cbInstr;
}
DISPATCH(seta_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Seta;
    Instr->Size = 2+cbInstr;
}
DISPATCH(sets_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Sets;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setns_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setns;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setp_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setp;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setnp_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setnp;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setl_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setl;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setge_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setge;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setle_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setle;
    Instr->Size = 2+cbInstr;
}
DISPATCH(setg_modrmb)
{
    int cbInstr = mod_rm_reg8(State, &Instr->Operand1, NULL);

    Instr->Operation = OP_Setg;
    Instr->Size = 2+cbInstr;
}
DISPATCH(push_fs)
{
    Instr->Operation = OP_PushFs;
    Instr->Size = 2;
}
DISPATCH(pop_fs)
{
    Instr->Operation = OP_PopFs;
    Instr->Size = 2;
}
DISPATCH(push_gs)
{
    Instr->Operation = OP_PushGs;
    Instr->Size = 2;
}
DISPATCH(pop_gs)
{
    Instr->Operation = OP_PopGs;
    Instr->Size = 2;
}
DISPATCH(imul_regw_modrmw16) // reg16 = reg16 * mod/rm
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul16;
    DEREF32(Instr->Operand2);
    Instr->Size = 2+cbInstr;

}
DISPATCH(imul_regw_modrmw32) // reg32 = reg32 * mod/rm
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand2, &Instr->Operand1);

    Instr->Operation = OP_Imul32;
    DEREF32(Instr->Operand2);
    Instr->Size = 2+cbInstr;
}
DISPATCH(movzx_regw_modrmw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);

    DEREF16(Instr->Operand1);
    Instr->Operation = OP_Movzx16To32;
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = get_reg32(State);
    Instr->Size = 2+cbInstr;
}
DISPATCH(movsx_regw_modrmw)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, NULL);
    
    DEREF16(Instr->Operand1);
    Instr->Operation = OP_Movsx16To32;
    Instr->Operand2.Type = OPND_NOCODEGEN;
    Instr->Operand2.Reg = get_reg32(State);
    Instr->Size = 2+cbInstr;
}
DISPATCH(wait)
{
    Instr->Operation = OP_Wait;
}
DISPATCH(bswap_eax)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EAX;
    Instr->Size = 2;
}
DISPATCH(bswap_ebx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EBX;
    Instr->Size = 2;
}
DISPATCH(bswap_ecx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ECX;
    Instr->Size = 2;
}
DISPATCH(bswap_edx)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EDX;
    Instr->Size = 2;
}
DISPATCH(bswap_esp)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ESP;
    Instr->Size = 2;
}
DISPATCH(bswap_ebp)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EBP;
    Instr->Size = 2;
}
DISPATCH(bswap_esi)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_ESI;
    Instr->Size = 2;
}
DISPATCH(bswap_edi)
{
    Instr->Operation = OP_Bswap32;
    Instr->Operand1.Type = OPND_REGREF;
    Instr->Operand1.Reg = GP_EDI;
    Instr->Size = 2;
}
DISPATCH(arpl)
{
    int cbInstr = mod_rm_reg16(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_Arpl;
    CPUASSERT(Instr->Operand2.Type == OPND_REGREF);
    Instr->Operand2.Type = OPND_REGVALUE;
    Instr->Size = 1+cbInstr;
}
DISPATCH(cpuid)
{
    Instr->Operation = OP_CPUID;
    Instr->Size = 2;
}
DISPATCH(rdtsc)
{
    Instr->Operation = OP_Rdtsc;
    Instr->Size = 2;
}
DISPATCH(cmpxchg8b)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_CMPXCHG8B;
    Instr->Size = 2+cbInstr;
}
DISPATCH(LOCKcmpxchg8b)
{
    int cbInstr = mod_rm_reg32(State, &Instr->Operand1, &Instr->Operand2);

    Instr->Operation = OP_SynchLockCMPXCHG8B;
    Instr->Size = 2+cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\decoder\modrm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mod_rm.c

Abstract:
    
    Mod/Rm/Reg decoder.  Compiled multiple times to generate the following
    functions:  mod_rm_reg8     - for 8-bit integer instructions
                mod_rm_reg16    - for 16-bit integer instructions
                mod_rm_reg32    - for 32-bit integer instructions
                mod_rm_regst    - for floating-point instructions (mod=11
                                   indicates rm bits specify ST(i)).
                mod_rm_seg16    - for 16-bit integer instructions which
                                   specify a segment register in the remaining
                                   bits.

Author:

    29-Jun-1995 BarryBo

Revision History:

--*/

// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MOD_RM_DECODER   - name of the decoder
// MOD11_RM000      - the name of the thing to use when mod=11,rm=000.
// MOD11_RM001      - mod=11,rm=001
//  ...
// MOD11_RM111      - mod=11,rm=111
//
// REG000           - the name of the register to use when reg=000
//  ...
// REG111           - reg=111

int MOD_RM_DECODER(PDECODERSTATE State, POPERAND op1, POPERAND op2)
{
    int cbInstr;
    OPERAND ScratchOperand;

    if (op2 == NULL) {
        // If caller doesn't care about operand #2, then store the results
        // to a scratch structure.
        op2 = &ScratchOperand;
    }

    op2->Type = OPND_REGREF;

    if (State->AdrPrefix) {
        // ADR: prefix specified.

        // mm aaa rrr
        // |  |   |
        // |  |   +--- 'rm' bits from mod/rm
        // |  +------- reg bits
        // +---------- 'mod' bits from mod/rm
        switch (*(PBYTE)(eipTemp+1)) {
            case 0x00:                   // mod/rm = 00 000, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x01:                   // mod/rm = 00 001, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x02:                   // mod/rm = 00 010, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x03:                   // mod/rm = 00 011, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x04:                   // mod/rm = 00 100, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG000;
                break;
            case 0x05:                   // mod/rm = 00 101, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG000;
                break;
            case 0x06:                   // mod/rm = 00 110, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x07:                   // mod/rm = 00 111, reg=000
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG000;
                break;

            case 0x08:                   // mod/rm = 00 000, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x09:                   // mod/rm = 00 001, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0a:                   // mod/rm = 00 010, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op2->IndexReg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x0b:                   // mod/rm = 00 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op2->IndexReg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0c:                   // mod/rm = 00 100, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG001;
                break;
            case 0x0d:                   // mod/rm = 00 101, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG001;
                break;
            case 0x0e:                   // mod/rm = 00 110, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x0f:                   // mod/rm = 00 111, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG001;
                break;

            case 0x10:                   // mod/rm = 00 000, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x11:                   // mod/rm = 00 001, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x12:                   // mod/rm = 00 010, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x13:                   // mod/rm = 00 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x14:                   // mod/rm = 00 100, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG010;
                break;
            case 0x15:                   // mod/rm = 00 101, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG010;
                break;
            case 0x16:                   // mod/rm = 00 110, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x17:                   // mod/rm = 00 111, reg=010
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG010;
                break;

            case 0x18:                   // mod/rm = 00 000, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x19:                   // mod/rm = 00 001, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Reg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1a:                   // mod/rm = 00 010, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x1b:                   // mod/rm = 00 011, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1c:                   // mod/rm = 00 100, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG011;
                break;
            case 0x1d:                   // mod/rm = 00 101, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG011;
                break;
            case 0x1e:                   // mod/rm = 00 110, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x1f:                   // mod/rm = 00 111, reg=011
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG011;
                break;

            case 0x20:                   // mod/rm = 00 000, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x21:                   // mod/rm = 00 001, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x22:                   // mod/rm = 00 010, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x23:                   // mod/rm = 00 011, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x24:                   // mod/rm = 00 100, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG100;
                break;
            case 0x25:                   // mod/rm = 00 101, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG100;
                break;
            case 0x26:                   // mod/rm = 00 110, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x27:                   // mod/rm = 00 111, reg=100
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG100;
                break;

            case 0x28:                   // mod/rm = 00 000, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x29:                   // mod/rm = 00 001, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2a:                   // mod/rm = 00 010, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x2b:                   // mod/rm = 00 011, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2c:                   // mod/rm = 00 100, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG101;
                break;
            case 0x2d:                   // mod/rm = 00 101, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG101;
                break;
            case 0x2e:                   // mod/rm = 00 110, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x2f:                   // mod/rm = 00 111, reg=101
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG101;
                break;

            case 0x30:                   // mod/rm = 00 000, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x31:                   // mod/rm = 00 001, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x32:                   // mod/rm = 00 010, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x33:                   // mod/rm = 00 011, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x34:                   // mod/rm = 00 100, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG110;
                break;
            case 0x35:                   // mod/rm = 00 101, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG110;
                break;
            case 0x36:                   // mod/rm = 00 110, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x37:                   // mod/rm = 00 111, reg=110
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG110;
                break;

            case 0x38:                   // mod/rm = 00 000, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x39:                   // mod/rm = 00 001, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3a:                   // mod/rm = 00 010, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x3b:                   // mod/rm = 00 011, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3c:                   // mod/rm = 00 100, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op2->Reg = REG111;
                break;
            case 0x3d:                   // mod/rm = 00 101, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op2->Reg = REG111;
                break;
            case 0x3e:                   // mod/rm = 00 110, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x3f:                   // mod/rm = 00 111, reg=111
                cbInstr = 1;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0x40:                   // mod/rm = 01 000, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x41:                   // mod/rm = 01 001, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x42:                   // mod/rm = 01 010, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x43:                   // mod/rm = 01 011, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x44:                   // mod/rm = 01 100, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x45:                   // mod/rm = 01 101, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x46:                   // mod/rm = 01 110, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x47:                   // mod/rm = 01 111, reg=000
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG000;
                break;

            case 0x48:                   // mod/rm = 01 000, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x49:                   // mod/rm = 01 001, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4a:                   // mod/rm = 01 010, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4b:                   // mod/rm = 01 011, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4c:                   // mod/rm = 01 100, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4d:                   // mod/rm = 01 101, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4e:                   // mod/rm = 01 110, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x4f:                   // mod/rm = 01 111, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG001;
                break;

            case 0x50:                   // mod/rm = 01 000, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x51:                   // mod/rm = 01 001, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x52:                   // mod/rm = 01 010, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x53:                   // mod/rm = 01 011, reg=001
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x54:                   // mod/rm = 01 100, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x55:                   // mod/rm = 01 101, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x56:                   // mod/rm = 01 110, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x57:                   // mod/rm = 01 111, reg=010
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG010;
                break;

            case 0x58:                   // mod/rm = 01 000, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x59:                   // mod/rm = 01 001, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5a:                   // mod/rm = 01 010, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5b:                   // mod/rm = 01 011, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5c:                   // mod/rm = 01 100, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5d:                   // mod/rm = 01 101, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5e:                   // mod/rm = 01 110, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x5f:                   // mod/rm = 01 111, reg=011
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG011;
                break;

            case 0x60:                   // mod/rm = 01 000, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x61:                   // mod/rm = 01 001, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x62:                   // mod/rm = 01 010, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x63:                   // mod/rm = 01 011, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x64:                   // mod/rm = 01 100, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x65:                   // mod/rm = 01 101, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x66:                   // mod/rm = 01 110, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0x67:                   // mod/rm = 01 111, reg=100
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG100;
                break;

            case 0x68:                   // mod/rm = 01 000, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x69:                   // mod/rm = 01 001, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6a:                   // mod/rm = 01 010, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6b:                   // mod/rm = 01 011, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6c:                   // mod/rm = 01 100, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6d:                   // mod/rm = 01 101, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6e:                   // mod/rm = 01 110, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0x6f:                   // mod/rm = 01 111, reg=101
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG101;
                break;

            case 0x70:                   // mod/rm = 01 000, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x71:                   // mod/rm = 01 001, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x72:                   // mod/rm = 01 010, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x73:                   // mod/rm = 01 011, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x74:                   // mod/rm = 01 100, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x75:                   // mod/rm = 01 101, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x76:                   // mod/rm = 01 110, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0x77:                   // mod/rm = 01 111, reg=110
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG110;
                break;

            case 0x78:                   // mod/rm = 01 000, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x79:                   // mod/rm = 01 001, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7a:                   // mod/rm = 01 010, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7b:                   // mod/rm = 01 011, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7c:                   // mod/rm = 01 100, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7d:                   // mod/rm = 01 101, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7e:                   // mod/rm = 01 110, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0x7f:                   // mod/rm = 01 111, reg=111
                cbInstr = 2;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0x80:                   // mod/rm = 10 000, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x81:                   // mod/rm = 10 001, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x82:                   // mod/rm = 10 010, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x83:                   // mod/rm = 10 011, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x84:                   // mod/rm = 10 100, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x85:                   // mod/rm = 10 101, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x86:                   // mod/rm = 10 110, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;
            case 0x87:                   // mod/rm = 10 111, reg=000
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG000;
                break;

            case 0x88:                   // mod/rm = 10 000, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x89:                   // mod/rm = 10 001, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8a:                   // mod/rm = 10 010, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8b:                   // mod/rm = 10 011, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8c:                   // mod/rm = 10 100, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8d:                   // mod/rm = 10 101, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8e:                   // mod/rm = 10 110, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;
            case 0x8f:                   // mod/rm = 10 111, reg=001
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG001;
                break;

            case 0x90:                   // mod/rm = 10 000, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x91:                   // mod/rm = 10 001, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x92:                   // mod/rm = 10 010, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x93:                   // mod/rm = 10 011, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x94:                   // mod/rm = 10 100, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x95:                   // mod/rm = 10 101, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x96:                   // mod/rm = 10 110, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;
            case 0x97:                   // mod/rm = 10 111, reg=010
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG010;
                break;

            case 0x98:                   // mod/rm = 10 000, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x99:                   // mod/rm = 10 001, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9a:                   // mod/rm = 10 010, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9b:                   // mod/rm = 10 011, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9c:                   // mod/rm = 10 100, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9d:                   // mod/rm = 10 101, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9e:                   // mod/rm = 10 110, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;
            case 0x9f:                   // mod/rm = 10 111, reg=011
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG011;
                break;

            case 0xa0:                   // mod/rm = 10 000, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa1:                   // mod/rm = 10 001, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa2:                   // mod/rm = 10 010, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa3:                   // mod/rm = 10 011, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa4:                   // mod/rm = 10 100, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa5:                   // mod/rm = 10 101, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa6:                   // mod/rm = 10 110, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;
            case 0xa7:                   // mod/rm = 10 111, reg=100
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG100;
                break;

            case 0xa8:                   // mod/rm = 10 000, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xa9:                   // mod/rm = 10 001, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xaa:                   // mod/rm = 10 010, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xab:                   // mod/rm = 10 011, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xac:                   // mod/rm = 10 100, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xad:                   // mod/rm = 10 101, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xae:                   // mod/rm = 10 110, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;
            case 0xaf:                   // mod/rm = 10 111, reg=101
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG101;
                break;

            case 0xb0:                   // mod/rm = 10 000, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb1:                   // mod/rm = 10 001, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb2:                   // mod/rm = 10 010, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb3:                   // mod/rm = 10 011, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb4:                   // mod/rm = 10 100, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb5:                   // mod/rm = 10 101, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb6:                   // mod/rm = 10 110, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;
            case 0xb7:                   // mod/rm = 10 111, reg=110
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG110;
                break;

            case 0xb8:                   // mod/rm = 10 000, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xb9:                   // mod/rm = 10 001, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xba:                   // mod/rm = 10 010, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbb:                   // mod/rm = 10 011, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->IndexReg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbc:                   // mod/rm = 10 100, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_SI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbd:                   // mod/rm = 10 101, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_DI;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbe:                   // mod/rm = 10 110, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BP;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;
            case 0xbf:                   // mod/rm = 10 111, reg=111
                cbInstr = 3;
                op1->Type = OPND_ADDRREF;
                op1->Reg = GP_BX;
                op1->Immed = GET_SHORT(eipTemp+2);
                op2->Reg = REG111;
                break;

            /////////////////////////////////////////////////////////////////////

            case 0xc0:                   // mod/rm = 11 000, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG000;
                break;
            case 0xc1:                   // mod/rm = 11 001, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG000;
                break;
            case 0xc2:                   // mod/rm = 11 010, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG000;
                break;
            case 0xc3:                   // mod/rm = 11 011, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG000;
                break;
            case 0xc4:                   // mod/rm = 11 100, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG000;
                break;
            case 0xc5:                   // mod/rm = 11 101, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG000;
                break;
            case 0xc6:                   // mod/rm = 11 110, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG000;
                break;
            case 0xc7:                   // mod/rm = 11 111, reg=000
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG000;
                break;

            case 0xc8:                   // mod/rm = 11 000, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG001;
                break;
            case 0xc9:                   // mod/rm = 11 001, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG001;
                break;
            case 0xca:                   // mod/rm = 11 010, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG001;
                break;
            case 0xcb:                   // mod/rm = 11 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG001;
                break;
            case 0xcc:                   // mod/rm = 11 100, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG001;
                break;
            case 0xcd:                   // mod/rm = 11 101, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG001;
                break;
            case 0xce:                   // mod/rm = 11 110, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG001;
                break;
            case 0xcf:                   // mod/rm = 11 111, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG001;
                break;

            case 0xd0:                   // mod/rm = 11 000, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG010;
                break;
            case 0xd1:                   // mod/rm = 11 001, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG010;
                break;
            case 0xd2:                   // mod/rm = 11 010, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG010;
                break;
            case 0xd3:                   // mod/rm = 11 011, reg=001
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG010;
                break;
            case 0xd4:                   // mod/rm = 11 100, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG010;
                break;
            case 0xd5:                   // mod/rm = 11 101, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG010;
                break;
            case 0xd6:                   // mod/rm = 11 110, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG010;
                break;
            case 0xd7:                   // mod/rm = 11 111, reg=010
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG010;
                break;

            case 0xd8:                   // mod/rm = 11 000, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG011;
                break;
            case 0xd9:                   // mod/rm = 11 001, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG011;
                break;
            case 0xda:                   // mod/rm = 11 010, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG011;
                break;
            case 0xdb:                   // mod/rm = 11 011, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG011;
                break;
            case 0xdc:                   // mod/rm = 11 100, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG011;
                break;
            case 0xdd:                   // mod/rm = 11 101, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG011;
                break;
            case 0xde:                   // mod/rm = 11 110, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG011;
                break;
            case 0xdf:                   // mod/rm = 11 111, reg=011
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG011;
                break;

            case 0xe0:                   // mod/rm = 11 000, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG100;
                break;
            case 0xe1:                   // mod/rm = 11 001, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG100;
                break;
            case 0xe2:                   // mod/rm = 11 010, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG100;
                break;
            case 0xe3:                   // mod/rm = 11 011, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG100;
                break;
            case 0xe4:                   // mod/rm = 11 100, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG100;
                break;
            case 0xe5:                   // mod/rm = 11 101, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG100;
                break;
            case 0xe6:                   // mod/rm = 11 110, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG100;
                break;
            case 0xe7:                   // mod/rm = 11 111, reg=100
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG100;
                break;

            case 0xe8:                   // mod/rm = 11 000, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG101;
                break;
            case 0xe9:                   // mod/rm = 11 001, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG101;
                break;
            case 0xea:                   // mod/rm = 11 010, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG101;
                break;
            case 0xeb:                   // mod/rm = 11 011, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG101;
                break;
            case 0xec:                   // mod/rm = 11 100, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG101;
                break;
            case 0xed:                   // mod/rm = 11 101, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG101;
                break;
            case 0xee:                   // mod/rm = 11 110, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG101;
                break;
            case 0xef:                   // mod/rm = 11 111, reg=101
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG101;
                break;

            case 0xf0:                   // mod/rm = 11 000, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG110;
                break;
            case 0xf1:                   // mod/rm = 11 001, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG110;
                break;
            case 0xf2:                   // mod/rm = 11 010, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG110;
                break;
            case 0xf3:                   // mod/rm = 11 011, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG110;
                break;
            case 0xf4:                   // mod/rm = 11 100, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG110;
                break;
            case 0xf5:                   // mod/rm = 11 101, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG110;
                break;
            case 0xf6:                   // mod/rm = 11 110, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG110;
                break;
            case 0xf7:                   // mod/rm = 11 111, reg=110
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG110;
                break;

            case 0xf8:                   // mod/rm = 11 000, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
                op2->Reg = REG111;
                break;
            case 0xf9:                   // mod/rm = 11 001, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
                op2->Reg = REG111;
                break;
            case 0xfa:                   // mod/rm = 11 010, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
                op2->Reg = REG111;
                break;
            case 0xfb:                   // mod/rm = 11 011, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
                op2->Reg = REG111;
                break;
            case 0xfc:                   // mod/rm = 11 100, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
                op2->Reg = REG111;
                break;
            case 0xfd:                   // mod/rm = 11 101, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
                op2->Reg = REG111;
                break;
            case 0xfe:                   // mod/rm = 11 110, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
                op2->Reg = REG111;
                break;
            default:
            case 0xff:                   // mod/rm = 11 111, reg=111
                cbInstr = 1;
                op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
                op2->Reg = REG111;
                break;
            }
#if DBG
        State->AdrPrefix = FALSE;
#endif
        return cbInstr;
    }

    // else no ADR: prefix found...

    // mm aaa rrr
    // |  |   |
    // |  |   +--- 'rm' bits from mod/rm
    // |  +------- reg bits
    // +---------- 'mod' bits from mod/rm
    switch (*(PBYTE)(eipTemp+1)) {
        case 0x00:                   // mod/rm = 00 000, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG000;
            break;
        case 0x01:                   // mod/rm = 00 001, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG000;
            break;
        case 0x02:                   // mod/rm = 00 010, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG000;
            break;
        case 0x03:                   // mod/rm = 00 011, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG000;
            break;
        case 0x04:                   // mod/rm = 00 100, reg=000
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG000;
            break;
        case 0x05:                   // mod/rm = 00 101, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x06:                   // mod/rm = 00 110, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG000;
            break;
        case 0x07:                   // mod/rm = 00 111, reg=000
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG000;
            break;

        case 0x08:                   // mod/rm = 00 000, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG001;
            break;
        case 0x09:                   // mod/rm = 00 001, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG001;
            break;
        case 0x0a:                   // mod/rm = 00 010, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG001;
            break;
        case 0x0b:                   // mod/rm = 00 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG001;
            break;
        case 0x0c:                   // mod/rm = 00 100, reg=001
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG001;
            break;
        case 0x0d:                   // mod/rm = 00 101, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x0e:                   // mod/rm = 00 110, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG001;
            break;
        case 0x0f:                   // mod/rm = 00 111, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG001;
            break;

        case 0x10:                   // mod/rm = 00 000, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG010;
            break;
        case 0x11:                   // mod/rm = 00 001, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG010;
            break;
        case 0x12:                   // mod/rm = 00 010, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG010;
            break;
        case 0x13:                   // mod/rm = 00 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG010;
            break;
        case 0x14:                   // mod/rm = 00 100, reg=010
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG010;
            break;
        case 0x15:                   // mod/rm = 00 101, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x16:                   // mod/rm = 00 110, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG010;
            break;
        case 0x17:                   // mod/rm = 00 111, reg=010
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG010;
            break;

        case 0x18:                   // mod/rm = 00 000, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG011;
            break;
        case 0x19:                   // mod/rm = 00 001, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG011;
            break;
        case 0x1a:                   // mod/rm = 00 010, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG011;
            break;
        case 0x1b:                   // mod/rm = 00 011, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG011;
            break;
        case 0x1c:                   // mod/rm = 00 100, reg=011
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG011;
            break;
        case 0x1d:                   // mod/rm = 00 101, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x1e:                   // mod/rm = 00 110, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG011;
            break;
        case 0x1f:                   // mod/rm = 00 111, reg=011
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG011;
            break;

        case 0x20:                   // mod/rm = 00 000, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG100;
            break;
        case 0x21:                   // mod/rm = 00 001, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG100;
            break;
        case 0x22:                   // mod/rm = 00 010, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG100;
            break;
        case 0x23:                   // mod/rm = 00 011, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG100;
            break;
        case 0x24:                   // mod/rm = 00 100, reg=100
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG100;
            break;
        case 0x25:                   // mod/rm = 00 101, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x26:                   // mod/rm = 00 110, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG100;
            break;
        case 0x27:                   // mod/rm = 00 111, reg=100
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG100;
            break;

        case 0x28:                   // mod/rm = 00 000, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG101;
            break;
        case 0x29:                   // mod/rm = 00 001, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG101;
            break;
        case 0x2a:                   // mod/rm = 00 010, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG101;
            break;
        case 0x2b:                   // mod/rm = 00 011, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG101;
            break;
        case 0x2c:                   // mod/rm = 00 100, reg=101
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG101;
            break;
        case 0x2d:                   // mod/rm = 00 101, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x2e:                   // mod/rm = 00 110, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG101;
            break;
        case 0x2f:                   // mod/rm = 00 111, reg=101
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG101;
            break;

        case 0x30:                   // mod/rm = 00 000, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG110;
            break;
        case 0x31:                   // mod/rm = 00 001, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG110;
            break;
        case 0x32:                   // mod/rm = 00 010, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG110;
            break;
        case 0x33:                   // mod/rm = 00 011, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG110;
            break;
        case 0x34:                   // mod/rm = 00 100, reg=110
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG110;
            break;
        case 0x35:                   // mod/rm = 00 101, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x36:                   // mod/rm = 00 110, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG110;
            break;
        case 0x37:                   // mod/rm = 00 111, reg=110
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG110;
            break;

        case 0x38:                   // mod/rm = 00 000, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op2->Reg = REG111;
            break;
        case 0x39:                   // mod/rm = 00 001, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op2->Reg = REG111;
            break;
        case 0x3a:                   // mod/rm = 00 010, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op2->Reg = REG111;
            break;
        case 0x3b:                   // mod/rm = 00 011, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op2->Reg = REG111;
            break;
        case 0x3c:                   // mod/rm = 00 100, reg=111
            // s-i-b present
            cbInstr = 1 + scaled_index((BYTE *)(eipTemp+1), op1);
            op2->Reg = REG111;
            break;
        case 0x3d:                   // mod/rm = 00 101, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x3e:                   // mod/rm = 00 110, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op2->Reg = REG111;
            break;
        case 0x3f:                   // mod/rm = 00 111, reg=111
            cbInstr = 1;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0x40:                   // mod/rm = 01 000, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x41:                   // mod/rm = 01 001, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x42:                   // mod/rm = 01 010, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x43:                   // mod/rm = 01 011, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x44:                   // mod/rm = 01 100, reg=000
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG000;
            break;
        case 0x45:                   // mod/rm = 01 101, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x46:                   // mod/rm = 01 110, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x47:                   // mod/rm = 01 111, reg=000
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG000;
            break;

        case 0x48:                   // mod/rm = 01 000, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x49:                   // mod/rm = 01 001, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4a:                   // mod/rm = 01 010, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4b:                   // mod/rm = 01 011, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4c:                   // mod/rm = 01 100, reg=001
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG001;
            break;
        case 0x4d:                   // mod/rm = 01 101, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4e:                   // mod/rm = 01 110, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x4f:                   // mod/rm = 01 111, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG001;
            break;

        case 0x50:                   // mod/rm = 01 000, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x51:                   // mod/rm = 01 001, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x52:                   // mod/rm = 01 010, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x53:                   // mod/rm = 01 011, reg=001
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x54:                   // mod/rm = 01 100, reg=010
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG010;
            break;
        case 0x55:                   // mod/rm = 01 101, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x56:                   // mod/rm = 01 110, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x57:                   // mod/rm = 01 111, reg=010
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG010;
            break;

        case 0x58:                   // mod/rm = 01 000, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x59:                   // mod/rm = 01 001, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5a:                   // mod/rm = 01 010, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5b:                   // mod/rm = 01 011, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5c:                   // mod/rm = 01 100, reg=011
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG011;
            break;
        case 0x5d:                   // mod/rm = 01 101, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5e:                   // mod/rm = 01 110, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x5f:                   // mod/rm = 01 111, reg=011
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG011;
            break;

        case 0x60:                   // mod/rm = 01 000, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x61:                   // mod/rm = 01 001, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x62:                   // mod/rm = 01 010, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x63:                   // mod/rm = 01 011, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x64:                   // mod/rm = 01 100, reg=100
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG100;
            break;
        case 0x65:                   // mod/rm = 01 101, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x66:                   // mod/rm = 01 110, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0x67:                   // mod/rm = 01 111, reg=100
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG100;
            break;

        case 0x68:                   // mod/rm = 01 000, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x69:                   // mod/rm = 01 001, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6a:                   // mod/rm = 01 010, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6b:                   // mod/rm = 01 011, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6c:                   // mod/rm = 01 100, reg=101
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG101;
            break;
        case 0x6d:                   // mod/rm = 01 101, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6e:                   // mod/rm = 01 110, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0x6f:                   // mod/rm = 01 111, reg=101
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG101;
            break;

        case 0x70:                   // mod/rm = 01 000, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x71:                   // mod/rm = 01 001, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x72:                   // mod/rm = 01 010, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x73:                   // mod/rm = 01 011, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x74:                   // mod/rm = 01 100, reg=110
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG110;
            break;
        case 0x75:                   // mod/rm = 01 101, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x76:                   // mod/rm = 01 110, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0x77:                   // mod/rm = 01 111, reg=110
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG110;
            break;

        case 0x78:                   // mod/rm = 01 000, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x79:                   // mod/rm = 01 001, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7a:                   // mod/rm = 01 010, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7b:                   // mod/rm = 01 011, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7c:                   // mod/rm = 01 100, reg=111
            // s-i-b present
            cbInstr = 2 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+cbInstr);
            op2->Reg = REG111;
            break;
        case 0x7d:                   // mod/rm = 01 101, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7e:                   // mod/rm = 01 110, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0x7f:                   // mod/rm = 01 111, reg=111
            cbInstr = 2;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = (DWORD)(long)*(char *)(eipTemp+2);
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0x80:                   // mod/rm = 10 000, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x81:                   // mod/rm = 10 001, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x82:                   // mod/rm = 10 010, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x83:                   // mod/rm = 10 011, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x84:                   // mod/rm = 10 100, reg=000
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG000;
            break;
        case 0x85:                   // mod/rm = 10 101, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x86:                   // mod/rm = 10 110, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;
        case 0x87:                   // mod/rm = 10 111, reg=000
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG000;
            break;

        case 0x88:                   // mod/rm = 10 000, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x89:                   // mod/rm = 10 001, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8a:                   // mod/rm = 10 010, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8b:                   // mod/rm = 10 011, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8c:                   // mod/rm = 10 100, reg=001
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG001;
            break;
        case 0x8d:                   // mod/rm = 10 101, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8e:                   // mod/rm = 10 110, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;
        case 0x8f:                   // mod/rm = 10 111, reg=001
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG001;
            break;

        case 0x90:                   // mod/rm = 10 000, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x91:                   // mod/rm = 10 001, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x92:                   // mod/rm = 10 010, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x93:                   // mod/rm = 10 011, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x94:                   // mod/rm = 10 100, reg=010
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG010;
            break;
        case 0x95:                   // mod/rm = 10 101, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x96:                   // mod/rm = 10 110, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;
        case 0x97:                   // mod/rm = 10 111, reg=010
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG010;
            break;

        case 0x98:                   // mod/rm = 10 000, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x99:                   // mod/rm = 10 001, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9a:                   // mod/rm = 10 010, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9b:                   // mod/rm = 10 011, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9c:                   // mod/rm = 10 100, reg=011
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG011;
            break;
        case 0x9d:                   // mod/rm = 10 101, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9e:                   // mod/rm = 10 110, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;
        case 0x9f:                   // mod/rm = 10 111, reg=011
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG011;
            break;

        case 0xa0:                   // mod/rm = 10 000, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa1:                   // mod/rm = 10 001, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa2:                   // mod/rm = 10 010, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa3:                   // mod/rm = 10 011, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa4:                   // mod/rm = 10 100, reg=100
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG100;
            break;
        case 0xa5:                   // mod/rm = 10 101, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa6:                   // mod/rm = 10 110, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;
        case 0xa7:                   // mod/rm = 10 111, reg=100
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG100;
            break;

        case 0xa8:                   // mod/rm = 10 000, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xa9:                   // mod/rm = 10 001, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xaa:                   // mod/rm = 10 010, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xab:                   // mod/rm = 10 011, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xac:                   // mod/rm = 10 100, reg=101
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG101;
            break;
        case 0xad:                   // mod/rm = 10 101, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xae:                   // mod/rm = 10 110, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;
        case 0xaf:                   // mod/rm = 10 111, reg=101
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG101;
            break;

        case 0xb0:                   // mod/rm = 10 000, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb1:                   // mod/rm = 10 001, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb2:                   // mod/rm = 10 010, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb3:                   // mod/rm = 10 011, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb4:                   // mod/rm = 10 100, reg=110
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG110;
            break;
        case 0xb5:                   // mod/rm = 10 101, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb6:                   // mod/rm = 10 110, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;
        case 0xb7:                   // mod/rm = 10 111, reg=110
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG110;
            break;

        case 0xb8:                   // mod/rm = 10 000, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EAX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xb9:                   // mod/rm = 10 001, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ECX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xba:                   // mod/rm = 10 010, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbb:                   // mod/rm = 10 011, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBX;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbc:                   // mod/rm = 10 100, reg=111
            // s-i-b present
            cbInstr = 5 + scaled_index((BYTE *)(eipTemp+1), op1);
            op1->Immed = GET_LONG(eipTemp+cbInstr-3);
            op2->Reg = REG111;
            break;
        case 0xbd:                   // mod/rm = 10 101, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EBP;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbe:                   // mod/rm = 10 110, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_ESI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;
        case 0xbf:                   // mod/rm = 10 111, reg=111
            cbInstr = 5;
            op1->Type = OPND_ADDRREF;
            op1->Reg = GP_EDI;
            op1->Immed = GET_LONG(eipTemp+2);
            op2->Reg = REG111;
            break;

        /////////////////////////////////////////////////////////////////////

        case 0xc0:                   // mod/rm = 11 000, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG000;
            break;
        case 0xc1:                   // mod/rm = 11 001, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG000;
            break;
        case 0xc2:                   // mod/rm = 11 010, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG000;
            break;
        case 0xc3:                   // mod/rm = 11 011, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG000;
            break;
        case 0xc4:                   // mod/rm = 11 100, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG000;
            break;
        case 0xc5:                   // mod/rm = 11 101, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG000;
            break;
        case 0xc6:                   // mod/rm = 11 110, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG000;
            break;
        case 0xc7:                   // mod/rm = 11 111, reg=000
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG000;
            break;

        case 0xc8:                   // mod/rm = 11 000, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG001;
            break;
        case 0xc9:                   // mod/rm = 11 001, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG001;
            break;
        case 0xca:                   // mod/rm = 11 010, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG001;
            break;
        case 0xcb:                   // mod/rm = 11 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG001;
            break;
        case 0xcc:                   // mod/rm = 11 100, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG001;
            break;
        case 0xcd:                   // mod/rm = 11 101, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG001;
            break;
        case 0xce:                   // mod/rm = 11 110, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG001;
            break;
        case 0xcf:                   // mod/rm = 11 111, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG001;
            break;

        case 0xd0:                   // mod/rm = 11 000, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG010;
            break;
        case 0xd1:                   // mod/rm = 11 001, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG010;
            break;
        case 0xd2:                   // mod/rm = 11 010, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG010;
            break;
        case 0xd3:                   // mod/rm = 11 011, reg=001
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG010;
            break;
        case 0xd4:                   // mod/rm = 11 100, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG010;
            break;
        case 0xd5:                   // mod/rm = 11 101, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG010;
            break;
        case 0xd6:                   // mod/rm = 11 110, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG010;
            break;
        case 0xd7:                   // mod/rm = 11 111, reg=010
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG010;
            break;

        case 0xd8:                   // mod/rm = 11 000, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG011;
            break;
        case 0xd9:                   // mod/rm = 11 001, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG011;
            break;
        case 0xda:                   // mod/rm = 11 010, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG011;
            break;
        case 0xdb:                   // mod/rm = 11 011, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG011;
            break;
        case 0xdc:                   // mod/rm = 11 100, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG011;
            break;
        case 0xdd:                   // mod/rm = 11 101, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG011;
            break;
        case 0xde:                   // mod/rm = 11 110, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG011;
            break;
        case 0xdf:                   // mod/rm = 11 111, reg=011
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG011;
            break;

        case 0xe0:                   // mod/rm = 11 000, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG100;
            break;
        case 0xe1:                   // mod/rm = 11 001, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG100;
            break;
        case 0xe2:                   // mod/rm = 11 010, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG100;
            break;
        case 0xe3:                   // mod/rm = 11 011, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG100;
            break;
        case 0xe4:                   // mod/rm = 11 100, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG100;
            break;
        case 0xe5:                   // mod/rm = 11 101, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG100;
            break;
        case 0xe6:                   // mod/rm = 11 110, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG100;
            break;
        case 0xe7:                   // mod/rm = 11 111, reg=100
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG100;
            break;

        case 0xe8:                   // mod/rm = 11 000, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG101;
            break;
        case 0xe9:                   // mod/rm = 11 001, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG101;
            break;
        case 0xea:                   // mod/rm = 11 010, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG101;
            break;
        case 0xeb:                   // mod/rm = 11 011, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG101;
            break;
        case 0xec:                   // mod/rm = 11 100, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG101;
            break;
        case 0xed:                   // mod/rm = 11 101, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG101;
            break;
        case 0xee:                   // mod/rm = 11 110, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG101;
            break;
        case 0xef:                   // mod/rm = 11 111, reg=101
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG101;
            break;

        case 0xf0:                   // mod/rm = 11 000, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG110;
            break;
        case 0xf1:                   // mod/rm = 11 001, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG110;
            break;
        case 0xf2:                   // mod/rm = 11 010, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG110;
            break;
        case 0xf3:                   // mod/rm = 11 011, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG110;
            break;
        case 0xf4:                   // mod/rm = 11 100, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG110;
            break;
        case 0xf5:                   // mod/rm = 11 101, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG110;
            break;
        case 0xf6:                   // mod/rm = 11 110, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG110;
            break;
        case 0xf7:                   // mod/rm = 11 111, reg=110
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG110;
            break;

        case 0xf8:                   // mod/rm = 11 000, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM000;
            op2->Reg = REG111;
            break;
        case 0xf9:                   // mod/rm = 11 001, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM001;
            op2->Reg = REG111;
            break;
        case 0xfa:                   // mod/rm = 11 010, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM010;
            op2->Reg = REG111;
            break;
        case 0xfb:                   // mod/rm = 11 011, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM011;
            op2->Reg = REG111;
            break;
        case 0xfc:                   // mod/rm = 11 100, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM100;
            op2->Reg = REG111;
            break;
        case 0xfd:                   // mod/rm = 11 101, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM101;
            op2->Reg = REG111;
            break;
        case 0xfe:                   // mod/rm = 11 110, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM110;
            op2->Reg = REG111;
            break;
        default:
        case 0xff:                   // mod/rm = 11 111, reg=111
            cbInstr = 1;
            op1->Type = OPND_REGREF; op1->Reg = MOD11_RM111;
            op2->Reg = REG111;
            break;
        }
    return cbInstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\entrypt\entrypt.c ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    entrypt.c

Abstract:
    
    This module stores the Entry Point structures, and retrieves them
    given either an intel address or a native address.
    
Author:

    16-Jun-1995 t-orig

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "cpuassrt.h"
#include "entrypt.h"
#include "wx86.h"
#include "redblack.h"
#include "mrsw.h"

ASSERTNAME;

//
// Count of modifications made to the ENTRYPOINT tree.  Useful for code
// which unlocks the Entrypoint MRSW object and needs to see if another thread
// has invalidated the ENTRYPOINT tree or not.
//
DWORD EntrypointTimestamp;

EPNODE _NIL;
PEPNODE NIL=&_NIL;
PEPNODE intelRoot=&_NIL;
#if DBG_DUAL_TREES
PEPNODE dualRoot=&_NIL;
#endif

#if DBG_DUAL_TREES
VOID
VerifySubTree(
    PEPNODE intelEP,
    PEPNODE dualEP
    )
{
    CPUASSERT(intelEP != NILL || dualEP == NIL);
    CPUASSERT(intelEP->dual == dualEP);
    CPUASSERT(dualEP->dual == intelEP);
    CPUASSERT(intelEP->ep.intelStart == dualEP->ep.intelStart);
    CPUASSERT(intelEP->ep.intelEnd == dualEP->ep.intelEnd);
    CPUASSERT(intelEP->ep.nativeStart == dualEP->ep.nativeStart);
    CPUASSERT(intelEP->intelColor == dualEP->intelColor);

    VerifySubTree(intelEP->intelLeft, dualEP->intelLeft);
    VerifySubTree(intelEP->intelRight, dualEP->intelRight);
}

VOID
VerifyTrees(
    VOID
    )
{
    VerifySubTree(intelRoot, dualRoot);
}
#endif


#ifdef PROFILE
void StartCAP(void);
#endif



INT
initializeEntryPointModule(
    void
    )
/*++

Routine Description:

    Initializes the entry point module by allocating initial dll tables.  
    Should be called once for each process (thus this need not be called 
    by each thread).

Arguments:

    none

Return Value:

    return-value - 1 for success, 0 for failure

--*/
{
    NIL->intelLeft = NIL->intelRight  = NIL->intelParent = NIL;
    NIL->intelColor = BLACK;

#ifdef PROFILE
    StartCAP();
#endif

    return 1;
}



INT
insertEntryPoint(
    PEPNODE pNewEntryPoint
    )
/*++

Routine Description:

    Inserts the entry point structure into the correct red/black trees 
        (both intel and native)

Arguments:

    pNewEntryPoint - A pointer to the entry point structure to be inserted 
                     into the trees

Return Value:

    return-value - 1 - Success
                   0 - No entry for that region of memory
                   -1 -- There's a problem with the entry point table

--*/
{
#if DBG_DUAL_TREES
    PEPNODE pdualNewEntryPoint = malloc(sizeof(EPNODE));
    memcpy(pdualNewEntryPoint, pNewEntryPoint, sizeof(EPNODE));
#endif
    intelRoot = insertNodeIntoIntelTree (intelRoot, 
        pNewEntryPoint, 
        NIL);

#if DBG_DUAL_TREES
    dualRoot = insertNodeIntoIntelTree (dualRoot,
        pdualNewEntryPoint,
        NIL);
    pdualNewEntryPoint->dual = pNewEntryPoint;
    pNewEntryPoint->dual = pdualNewEntryPoint;
    VerifyTrees();
#endif

    //
    // Bump the timestamp
    //
    EntrypointTimestamp++;

    return 1;
}


#if 0   // dead code, but keep it around in case we decide we want it later.
INT
removeEntryPoint(
    PEPNODE pEP
    )
/*++

Routine Description:

    Removes an entry point structure from both the intel and native
        red/black trees

Arguments:

    pEP - A pointer to the entry point structure to be removed

Return Value:

    return-value - 1 - Success
                   0 - No entry for that region of memory
                   -1 -- There's a problem with the entry point table

--*/
{
    intelRoot = intelRBDelete (intelRoot, 
        pEP, 
        NIL);

#if DBG_DUAL_TREES
    CPUASSERT(pEP->dual->dual == pEP);
    dualRoot = intelRBDelete(dualRoot,
        pEP->dual,
        NIL);
    free(pEP->dual);
    pEP->dual = NULL;
    VerifyTrees();
#endif

    EntrypointTimestamp++;

    return 1;
}
#endif  // 0


PENTRYPOINT
EPFromIntelAddr(
    PVOID intelAddr
    )
/*++

Routine Description:

    Retrieves an entry point structure containing the given intel address

Arguments:
                                                                                
    intelAddr - The intel address contained within the code corresponding to 
        the entry point structure

Return Value:

    return-value - The entry point structure if found, NULL otherwise.

--*/
{
    PENTRYPOINT EP;
    PEPNODE pEPNode;

    pEPNode = findIntel(intelRoot, intelAddr, NIL);
    if (!pEPNode) {
        //
        // No EPNODE contains the address
        //
        return NULL;
    }

    //
    // The ENTRYPOINT inside the EPNODE contains the address.  Search
    // for an ENTRYPOINT which matches that address exactly.
    //
    EP = &pEPNode->ep;
    do {
        if (EP->intelStart == intelAddr) {
            //
            // Found a sub-Entrypoint whose Intel address exactly matches
            // the one we were looking for.
            //
            return EP;
        }
        EP=EP->SubEP;
    } while (EP);

    //
    // The EPNODE in the Red-black tree contains the Intel address, but
    // no sub-Entrypoint exactly describes the Intel address.
    //
    return &pEPNode->ep;
}

PENTRYPOINT
GetNextEPFromIntelAddr(
    PVOID intelAddr
    )
/*++

Routine Description:

    Retrieves the entry point following

Arguments:

    intelAddr - The intel address contained within the code corresponding to
        the entry point structure

Return Value:

    A pointer to the first EntryPoint which follows a particular Intel Address.

--*/
{
    PEPNODE pEP;
#if DBG_DUAL_TREES
    PEPNODE pDual;
#endif

    pEP = findIntelNext (intelRoot, intelAddr, NIL);

#if DBG_DUAL_TREES
    pDual = findIntelNext(dualRoot, intelAddr, NIL);
    CPUASSERT((pDual==NULL && pEP==NULL) ||
           (pDual->dual == pEP));
    VerifyTrees();
#endif

    return &pEP->ep;
}


BOOLEAN
IsIntelRangeInCache(
    PVOID Addr,
    DWORD Length
    )
/*++

Routine Description:

    Determines if any entrypoints are contained within a range of memory.
    Used to determine if the Translation Cache must be flushed.

    Must be called with either EP write or read lock.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOLEAN fContains;

    if (intelRoot == NIL) {
        //
        // Empty tree - no need to flush
        //
        return FALSE;
    }

    fContains = intelContainsRange(intelRoot,
                                   NIL,
                                   Addr,
                                   (PVOID)((ULONGLONG)Addr + Length)   
                                  );

    return fContains;
}


VOID
FlushEntrypoints(
    VOID
    )
/*++

Routine Description:

    Quickly deletes all entrypoints.  Called by the Translation Cache when
    the cache is flushed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (intelRoot != NIL) {
        //
        // Delete the heap containing all entrypoints in the tree
        //
        EPFree();

        //
        // Reset the root of the tree
        //
        intelRoot = NIL;
#if DBG_DUAL_TREES
        dualRoot = NIL;
#endif

        //
        // Bump the timestamp
        //
        EntrypointTimestamp++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\entrypt\redblack.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.c

Abstract:
    
    This module implements red/black trees.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "entrypt.h"
#include "redblack.h"
#include "stdio.h"
#include "stdlib.h"

// Disable warnings about MACRO redefinitions.   I'm redefining MACROS on 
// purpose...
#pragma warning (disable:4005)


//*************************************************************
//The Intel  Section:
//*************************************************************

//Intel MACROS
#define START(x)        x->ep.intelStart
#define END(x)          x->ep.intelEnd
#define KEY(x)          x->ep.intelStart
#define RIGHT(x)        x->intelRight
#define LEFT(x)         x->intelLeft
#define PARENT(x)       x->intelParent
#define COLOR(x)        x->intelColor

#define RB_INSERT       insertNodeIntoIntelTree
#define FIND            findIntel
#define CONTAINSRANGE   intelContainsRange
#define REMOVE          deleteNodeFromIntelTree
#define LEFT_ROTATE     intelLeftRotate
#define RIGHT_ROTATE    intelRightRotate
#define TREE_INSERT     intelTreeInsert
#define TREE_SUCCESSOR  intelTreeSuccessor
#define RB_DELETE       intelRBDelete
#define RB_DELETE_FIXUP intelRBDeleteFixup
#define FINDNEXT        findIntelNext

#include "redblack.fnc"


        
#ifdef BOTH
//*************************************************************
//The RISC  Section:
//*************************************************************

//RISC MACROS
#define START(x)        x->ep.nativeStart
#define END(x)          x->ep.nativeEnd
#define KEY(x)          x->ep.nativeStart
#define RIGHT(x)        x->nativeRight
#define LEFT(x)         x->nativeLeft
#define PARENT(x)       x->nativeParent
#define COLOR(x)        x->nativeColor

#define RB_INSERT       insertNodeIntoNativeTree
#define FIND            findNative
#define CONTAINSRANGE   nativeContainsRange
#define REMOVE          deleteNodeFromNativeTree
#define LEFT_ROTATE     nativeLeftRotate
#define RIGHT_ROTATE    nativeRightRotate
#define TREE_INSERT     nativeTreeInsert
#define TREE_SUCCESSOR  nativeTreeSuccessor
#define RB_DELETE       nativeRBDelete
#define RB_DELETE_FIXUP nativeRBDeleteFixup
#define FINDNEXT        findNativeNext

#include "redblack.fnc"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpufprem.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufprem.c

Abstract:

    Floating point remainder fragments (FPREM, FPREM1)

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"

//
// Forward references
//
NPXFUNC2(FPREM_VALID_VALID);
NPXFUNC2(FPREM_VALID_ZERO);
NPXFUNC2(FPREM_VALID_SPECIAL);
NPXFUNC2(FPREM_ZERO_VALIDORZERO);
NPXFUNC2(FPREM_ZERO_SPECIAL);
NPXFUNC2(FPREM_SPECIAL_VALIDORZERO);
NPXFUNC2(FPREM_SPECIAL_SPECIAL);
NPXFUNC2(FPREM_EMPTY_ANY);
NPXFUNC2(FPREM_ANY_EMPTY);

NPXFUNC2(FPREM1_VALID_VALID);
//NPXFUNC2(FPREM1_VALID_ZERO);       // same as FPREM_VALID_ZERO
NPXFUNC2(FPREM1_VALID_SPECIAL);
//NPXFUNC2(FPREM1_ZERO_VALIDORZERO); // same as FPREM_ZERO_VALIDORZERO
NPXFUNC2(FPREM1_ZERO_SPECIAL);
NPXFUNC2(FPREM1_SPECIAL_VALIDORZERO);
NPXFUNC2(FPREM1_SPECIAL_SPECIAL);
NPXFUNC2(FPREM1_EMPTY_ANY);
NPXFUNC2(FPREM1_ANY_EMPTY);


//
// Jump tables
//
const NpxFunc2 FPREMTable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FPREM_VALID_VALID, FPREM_VALID_ZERO, FPREM_VALID_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FPREM_ZERO_VALIDORZERO, FPREM_ZERO_VALIDORZERO, FPREM_ZERO_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FPREM_SPECIAL_VALIDORZERO, FPREM_SPECIAL_VALIDORZERO, FPREM_SPECIAL_SPECIAL, FPREM_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FPREM_EMPTY_ANY, FPREM_EMPTY_ANY, FPREM_EMPTY_ANY, FPREM_EMPTY_ANY }
};

const NpxFunc2 FPREM1Table[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FPREM1_VALID_VALID, FPREM_VALID_ZERO, FPREM1_VALID_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FPREM_ZERO_VALIDORZERO, FPREM_ZERO_VALIDORZERO, FPREM1_ZERO_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FPREM1_SPECIAL_VALIDORZERO, FPREM1_SPECIAL_VALIDORZERO, FPREM1_SPECIAL_SPECIAL, FPREM1_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY, FPREM1_EMPTY_ANY }
};


NPXFUNC2(FPREM_VALID_VALID)
{
    int ExpL;
    int ExpR;
    int ExpDiff;
    LONG Q;
    double DQ;

    ExpL = (int)((l->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpR = (int)((r->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpDiff = abs(ExpL-ExpR);
    if (ExpDiff < 64) {

        // Do the division and chop the integer result towards zero
        DQ = r->r64 / l->r64;
        if (DQ < 0) {
            Q = (long)ceil(DQ);
        } else {
            Q = (long)floor(DQ);
        }

        // Store the remainder
        r->r64 -= (DOUBLE)Q * l->r64;
        SetTag(r);

        // Store the status bits
        if (Q < 0) {
            //
            // Take the absolute value of Q before returning the low 3 bits
            // of the quotient.
            //
            Q = -Q;
        }
        cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
        cpu->FpStatusC0 = (Q>>2) & 1;
        cpu->FpStatusC3 = (Q>>1) & 1;
        cpu->FpStatusC1 = Q & 1;
    } else {
        DOUBLE PowerOfTwo;

        cpu->FpStatusC2 = 1;            // indicate the app must loop more
        PowerOfTwo = ldexp(1.0, ExpDiff-32);    // get 2^(ExpDiff-32)

        // get Q by chopping towards zero
        DQ = (r->r64/PowerOfTwo) / (l->r64/PowerOfTwo);
        if (DQ < 0) {
            Q = (long)ceil(DQ);
        } else {
            Q = (long)floor(DQ);
        }
        r->r64 -= (DOUBLE)Q * l->r64 * PowerOfTwo;
        SetTag(r);
    }
}

NPXFUNC2(FPREM_VALID_ZERO)
{
    // l is a number, but r is zero - return ST(0) unchanged
    cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
    // Q is 0, so store low 3 bits in the status word
    cpu->FpStatusC0 = 0;
    cpu->FpStatusC1 = 0;
    cpu->FpStatusC3 = 0;
}

NPXFUNC2(FPREM_VALID_SPECIAL)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // Dividing infinity.
        SetIndefinite(r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a QNAN, while l is a VALID.  Return
        // the QNAN as the result of the operation
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM_ZERO_VALIDORZERO)
{
    // l is zero, and r is a number or zero - return INDEFINITE due to the
    // division by zero.
    if (!HandleInvalidOp(cpu)) {
        SetIndefinite(r);
    }
}

NPXFUNC2(FPREM_ZERO_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
        SetIndefinite(r);
    } else {
        FPREM_VALID_SPECIAL(cpu, l, r);
    }
}

NPXFUNC2(FPREM_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // number / infinity - quotient == 0
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
        cpu->FpStatusC1 = 0;
        cpu->FpStatusC3 = 0;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a VALID, while l is a NAN.  Return
        // the NAN as the result of the operation
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = l->TagSpecial;
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM_VALID_SPECIAL(cpu, l, r);
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM_SPECIAL_VALIDORZERO(cpu, l, r);
    }

    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            SetIndefinite(r);
        }
        //
        // r is a NAN of some sort, and l is infinity - return the NAN
        // which is already in r.
        //
    } else {
        //
        // l is a NAN, and r is either a NAN or INFINITY.  Have the native
        // FPU return the largest NAN, and re-tag it as appropriate.
        //
        r->r64 = l->r64 + r->r64;
        SetTag(r);
    }

}

NPXFUNC2(FPREM_EMPTY_ANY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM_ANY_EMPTY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}


FRAG0(FPREM)
{
    // get remainder of r/l

    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPREMTable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM1_VALID_VALID)
{
    int ExpL;
    int ExpR;
    int ExpDiff;
    LONG Q;
    double DQ;
    double FloorQ, CeilQ;

    ExpL = (int)((l->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpR = (int)((r->rdw[1] >> 20) & 0x7ff) - 1023;
    ExpDiff = abs(ExpL-ExpR);
    if (ExpDiff < 64) {

        // Do the division and get the integer nearest to the value
        DQ = r->r64 / l->r64;
        FloorQ = floor(DQ);
        CeilQ = ceil(DQ);
        if (DQ-FloorQ >= CeilQ-DQ) {
            // CeilQ is closer - use it
            Q = (long)CeilQ;
        } else {
            // FloorQ is closer - use it
            Q = (long)FloorQ;
        }

        // Store the remainder
        r->r64 -= (DOUBLE)Q * l->r64;
        SetTag(r);

        // Store the status bits
        if (Q < 0) {
            //
            // Take the absolute value of Q before returning the low 3 bits
            // of the quotient.
            //
            Q = -Q;
        }
        cpu->FpStatusC2 = 0;            // indicate the final remainder is ready
        cpu->FpStatusC0 = (Q>>2) & 1;
        cpu->FpStatusC3 = (Q>>1) & 1;
        cpu->FpStatusC1 = Q & 1;
    } else {
        DOUBLE PowerOfTwo;

        cpu->FpStatusC2 = 1;            // indicate the app must loop more
        PowerOfTwo = ldexp(1.0, ExpDiff-32);    // get 2^(ExpDiff-32)

        // get Q by finding the integer nearest to the value
        DQ = (r->r64/PowerOfTwo) / (l->r64/PowerOfTwo);
        FloorQ = floor(DQ);
        CeilQ = ceil(DQ);
        if (DQ-FloorQ >= CeilQ-DQ) {
            // CeilQ is closer - use it
            Q = (long)CeilQ;
        } else {
            // FloorQ is closer - use it
            Q = (long)FloorQ;
        }
        r->r64 -= (DOUBLE)Q * l->r64 * PowerOfTwo;
        SetTag(r);
    }
}

NPXFUNC2(FPREM1_VALID_SPECIAL)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM1_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // dividing infinity
        SetIndefinite(r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a QNAN, while l is a VALID.  Return
        // the QNAN as the result of the operation
        // x86 emulator leaves condition flags alone
        break;
    }
}

NPXFUNC2(FPREM1_ZERO_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
        SetIndefinite(r);
    } else {
        FPREM1_VALID_SPECIAL(cpu, l, r);
    }
}

NPXFUNC2(FPREM1_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FPREM1_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // number / infinity - quotient == 0
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
        cpu->FpStatusC1 = 0;
        cpu->FpStatusC3 = 0;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into QNAN case

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is the destination and it is a VALID, while l is a NAN.  Return
        // the NAN as the result of the operation
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = l->TagSpecial;
        break;
    }
}

NPXFUNC2(FPREM1_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM1_VALID_SPECIAL(cpu, l, r);
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        FPREM1_SPECIAL_VALIDORZERO(cpu, l, r);
    }

    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            SetIndefinite(r);
        }
        //
        // r is a NAN of some sort, and l is infinity - return the NAN
        // which is already in r.
        //
    } else {
        //
        // l is a NAN, and r is either a NAN or INFINITY.  Have the native
        // FPU return the largest NAN, and re-tag it as appropriate.
        //
        r->r64 = l->r64 + r->r64;
        SetTag(r);
    }

}

NPXFUNC2(FPREM1_EMPTY_ANY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC2(FPREM1_ANY_EMPTY)
{
    if (HandleStackEmpty(cpu, l)) {
        return;
    }
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}
FRAG0(FPREM1)
{
    // get remainder of r/l

    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPREM1Table[l->Tag][r->Tag])(cpu, l, r);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\entrypt\redblack.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.h

Abstract:
    
    Prototypes for the red/black tree implementation.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/



// Intel prototypes:
PEPNODE
insertNodeIntoIntelTree(
    PEPNODE root,
    PEPNODE x,
    PEPNODE NIL
    );

PEPNODE
findIntel(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
findIntelNext(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
intelRBDelete(
    PEPNODE root,
    PEPNODE z,
    PEPNODE NIL
    );

BOOLEAN
intelContainsRange(
    PEPNODE root,
    PEPNODE NIL,
    PVOID StartAddr,
    PVOID EndAddr
    );



// RISC prototypes
PEPNODE
insertNodeIntoNativeTree(
    PEPNODE root,
    PEPNODE x,
    PEPNODE NIL
    );

PEPNODE
findNative(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
findNativeNext(
    PEPNODE root,
    PVOID addr,
    PEPNODE NIL
    );

PEPNODE
nativeRBDelete(
    PEPNODE root,
    PEPNODE z,
    PEPNODE NIL
    );

BOOLEAN
nativeContainsRange(
    PEPNODE root,
    PEPNODE NIL,
    PVOID StartAddr,
    PVOID EndAddr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpuarith.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpuarith.h

Abstract:
    
    Common code for arithmetic floating-point operations.

Author:

    04-Oct-1995 BarryBo, Created

Revision History:

--*/

#ifndef FPUARITH_H
#define FPUARITH_H

VOID
ChangeFpPrecision(
    PCPUDATA cpu,
    INT NewPrecision
    );

VOID
FpAddCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpDivCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpMulCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpSubCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    );

VOID
FpComCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r,
    BOOL     fUnordered
    );

#endif //FPUARITH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpuarith.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpuarith.c

Abstract:

    Floating point arithmetic fragments (Add/Sub/Mul/Div/Com/Tst)

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

#define CALLNPXFUNC2(table, lTag, rTag, l, r) {         \
    NpxFunc2 *p = (NpxFunc2 *)(table);                  \
    (*(p + (lTag)*TAG_MAX + (rTag)))(cpu, l, r);        \
    }

#define CALLNPXFUNC3(table, lTag, rTag, d, l, r) {      \
    NpxFunc3 *p = (NpxFunc3 *)(table);                  \
    (*(p + (lTag)*TAG_MAX + (rTag)))(cpu, d, l, r);     \
    }


//
// Forward declarations
//
NPXFUNC2(FpAdd32_VALID_VALID);
NPXFUNC2(FpAdd32_VALID_SPECIAL);
NPXFUNC2(FpAdd32_SPECIAL_VALID);
NPXFUNC2(FpAdd32_SPECIAL_SPECIAL);
NPXFUNC2(FpAdd_ANY_EMPTY);
NPXFUNC2(FpAdd_EMPTY_ANY);
NPXFUNC2(FpAdd64_VALID_VALID);
NPXFUNC2(FpAdd64_VALID_SPECIAL);
NPXFUNC2(FpAdd64_SPECIAL_VALID);
NPXFUNC2(FpAdd64_SPECIAL_SPECIAL);
NPXFUNC3(FpDiv32_VALID_VALID);
NPXFUNC3(FpDiv32_VALID_SPECIAL);
NPXFUNC3(FpDiv32_SPECIAL_VALID);
NPXFUNC3(FpDiv32_SPECIAL_SPECIAL);
NPXFUNC3(FpDiv_ANY_EMPTY);
NPXFUNC3(FpDiv_EMPTY_ANY);
NPXFUNC3(FpDiv64_VALID_VALID);
NPXFUNC3(FpDiv64_VALID_SPECIAL);
NPXFUNC3(FpDiv64_SPECIAL_VALID);
NPXFUNC3(FpDiv64_SPECIAL_SPECIAL);
NPXFUNC2(FpMul32_VALID_VALID);
NPXFUNC2(FpMul32_VALID_SPECIAL);
NPXFUNC2(FpMul32_SPECIAL_VALID);
NPXFUNC2(FpMul32_SPECIAL_SPECIAL);
NPXFUNC2(FpMul_ANY_EMPTY);
NPXFUNC2(FpMul_EMPTY_ANY);
NPXFUNC2(FpMul64_VALID_VALID);
NPXFUNC2(FpMul64_VALID_SPECIAL);
NPXFUNC2(FpMul64_SPECIAL_VALID);
NPXFUNC2(FpMul64_SPECIAL_SPECIAL);
NPXFUNC3(FpSub32_VALID_VALID);
NPXFUNC3(FpSub32_VALID_SPECIAL);
NPXFUNC3(FpSub32_SPECIAL_VALID);
NPXFUNC3(FpSub32_SPECIAL_SPECIAL);
NPXFUNC3(FpSub_ANY_EMPTY);
NPXFUNC3(FpSub_EMPTY_ANY);
NPXFUNC3(FpSub64_VALID_VALID);
NPXFUNC3(FpSub64_VALID_SPECIAL);
NPXFUNC3(FpSub64_SPECIAL_VALID);
NPXFUNC3(FpSub64_SPECIAL_SPECIAL);
NPXCOMFUNC(FpCom_VALID_VALID);
NPXCOMFUNC(FpCom_VALID_SPECIAL);
NPXCOMFUNC(FpCom_SPECIAL_VALID);
NPXCOMFUNC(FpCom_SPECIAL_SPECIAL);
NPXCOMFUNC(FpCom_VALID_EMPTY);
NPXCOMFUNC(FpCom_EMPTY_VALID);
NPXCOMFUNC(FpCom_EMPTY_SPECIAL);
NPXCOMFUNC(FpCom_SPECIAL_EMPTY);
NPXCOMFUNC(FpCom_EMPTY_EMPTY);

//
// Jump tables
//
const NpxFunc2 FpAdd32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpAdd32_VALID_VALID, FpAdd32_VALID_VALID, FpAdd32_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpAdd32_VALID_VALID, FpAdd32_VALID_VALID, FpAdd32_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpAdd32_SPECIAL_VALID, FpAdd32_SPECIAL_VALID, FpAdd32_SPECIAL_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY}
};
const NpxFunc2 FpAdd64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpAdd64_VALID_VALID, FpAdd64_VALID_VALID, FpAdd64_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpAdd64_VALID_VALID, FpAdd64_VALID_VALID, FpAdd64_VALID_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpAdd64_SPECIAL_VALID, FpAdd64_SPECIAL_VALID, FpAdd64_SPECIAL_SPECIAL, FpAdd_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY, FpAdd_EMPTY_ANY}
};

const NpxFunc3 FpDiv32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpDiv32_VALID_VALID, FpDiv32_VALID_VALID, FpDiv32_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpDiv32_VALID_VALID, FpDiv32_VALID_VALID, FpDiv32_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpDiv32_SPECIAL_VALID, FpDiv32_SPECIAL_VALID, FpDiv32_SPECIAL_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY}
};
const NpxFunc3 FpDiv64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpDiv64_VALID_VALID, FpDiv64_VALID_VALID, FpDiv64_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpDiv64_VALID_VALID, FpDiv64_VALID_VALID, FpDiv64_VALID_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpDiv64_SPECIAL_VALID, FpDiv64_SPECIAL_VALID, FpDiv64_SPECIAL_SPECIAL, FpDiv_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY, FpDiv_EMPTY_ANY}
};

const NpxFunc2 FpMul32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpMul32_VALID_VALID, FpMul32_VALID_VALID, FpMul32_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpMul32_VALID_VALID, FpMul32_VALID_VALID, FpMul32_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpMul32_SPECIAL_VALID, FpMul32_SPECIAL_VALID, FpMul32_SPECIAL_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY}
};
const NpxFunc2 FpMul64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpMul64_VALID_VALID, FpMul64_VALID_VALID, FpMul64_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpMul64_VALID_VALID, FpMul64_VALID_VALID, FpMul64_VALID_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpMul64_SPECIAL_VALID, FpMul64_SPECIAL_VALID, FpMul64_SPECIAL_SPECIAL, FpMul_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY, FpMul_EMPTY_ANY}
};

const NpxFunc3 FpSub32Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpSub32_VALID_VALID, FpSub32_VALID_VALID, FpSub32_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpSub32_VALID_VALID, FpSub32_VALID_VALID, FpSub32_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpSub32_SPECIAL_VALID, FpSub32_SPECIAL_VALID, FpSub32_SPECIAL_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY}
};
const NpxFunc3 FpSub64Table[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpSub64_VALID_VALID, FpSub64_VALID_VALID, FpSub64_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpSub64_VALID_VALID, FpSub64_VALID_VALID, FpSub64_VALID_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpSub64_SPECIAL_VALID, FpSub64_SPECIAL_VALID, FpSub64_SPECIAL_SPECIAL, FpSub_ANY_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY, FpSub_EMPTY_ANY}
};

const NpxComFunc FpComTable[TAG_MAX][TAG_MAX] = {
    // Left is TAG_VALID, Right is...
    {FpCom_VALID_VALID, FpCom_VALID_VALID, FpCom_VALID_SPECIAL, FpCom_VALID_EMPTY},
    // Left is TAG_ZERO, Right is...
    {FpCom_VALID_VALID, FpCom_VALID_VALID, FpCom_VALID_SPECIAL, FpCom_VALID_EMPTY},
    // Left is TAG_SPECIAL, Right is...
    {FpCom_SPECIAL_VALID, FpCom_SPECIAL_VALID, FpCom_SPECIAL_SPECIAL, FpCom_SPECIAL_EMPTY},
    // Left is TAG_EMPTY, Right is...
    {FpCom_EMPTY_VALID, FpCom_EMPTY_VALID, FpCom_EMPTY_SPECIAL, FpCom_EMPTY_EMPTY}
};


VOID
ChangeFpPrecision(
    PCPUDATA cpu,
    INT NewPrecision
    )
/*++

Routine Description:

    Called to modify the floating-point precision.  It modifies per-thread
    jump tables used by instructions which are sensitive to the FP
    precision bits.

Arguments:

    cpu - per-thread data
    NewPrecision - new precision value

Return Value:

    None

--*/
{
    cpu->FpControlPrecision = NewPrecision;

    if (NewPrecision == 0) {
        //
        // New precision is 32-bit
        //
        cpu->FpAddTable = FpAdd32Table;
        cpu->FpSubTable = FpSub32Table;
        cpu->FpMulTable = FpMul32Table;
        cpu->FpDivTable = FpDiv32Table;
    } else {
        //
        // New precision is 24, 64, or 80-bit - treat all as 64-bit
        //
        cpu->FpAddTable = FpAdd64Table;
        cpu->FpSubTable = FpSub64Table;
        cpu->FpMulTable = FpMul64Table;
        cpu->FpDivTable = FpDiv64Table;
    }
}


NPXFUNC2(FpAdd32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = (DOUBLE)( (FLOAT)l->r64 + (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpAdd64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = l->r64 + r->r64;

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpAdd32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpAdd64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpAdd_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC2(cpu->FpAddTable, l->Tag, TAG_SPECIAL, l, r);
    }
}

NPXFUNC2(FpAdd_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC2(cpu->FpAddTable, TAG_SPECIAL, r->Tag, l, r);
    }
}

VOID
FpAddCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC2(cpu->FpAddTable, l->Tag, r->Tag, l, r);
}



NPXFUNC3(FpDiv32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = (DOUBLE)( (FLOAT)l->r64 / (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpDiv64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = l->r64 / r->r64;

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpDiv32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpDiv64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpDiv_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC3(cpu->FpDivTable, l->Tag, TAG_SPECIAL, dest, l, r);
    }
}

NPXFUNC3(FpDiv_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC3(cpu->FpDivTable, TAG_SPECIAL, r->Tag, dest, l, r);
    }
}

VOID
FpDivCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements dest = l/r

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC3(cpu->FpDivTable, l->Tag, r->Tag, dest, l, r);
}


NPXFUNC2(FpMul32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = (DOUBLE)( (FLOAT)l->r64 * (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpMul64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    l->r64 = l->r64 * r->r64;

    // Compute the new tag value
    SetTag(l);
}

NPXFUNC2(FpMul32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul32_VALID_VALID(cpu, l, r);
}
NPXFUNC2(FpMul64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpMul64_VALID_VALID(cpu, l, r);
}

NPXFUNC2(FpMul_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC2(cpu->FpMulTable, l->Tag, TAG_SPECIAL, l, r);
    }
}

NPXFUNC2(FpMul_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC2(cpu->FpMulTable, TAG_SPECIAL, r->Tag, l, r);
    }
}

VOID
FpMulCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC2(cpu->FpMulTable, l->Tag, r->Tag, l, r);
}



NPXFUNC3(FpSub32_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = (DOUBLE)( (FLOAT)l->r64 - (FLOAT)r->r64 );

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpSub64_VALID_VALID)
{
    //UNDONE:  If 487 overflow exceptions are unmasked and an overflow occurs,
    //UNDONE:  a different value is written to 'l' than if the exception
    //UNDONE:  was masked.  To get this right, we need to install an
    //UNDONE:  exception handler around the addition and run the native FPU
    //UNDONE:  with overflow exceptions unmasked.  The trap handler must then
    //UNDONE:  map the exception back into FpStatus->ES so the next Intel
    //UNDONE:  FP instruction can get the Intel exception as expected.  Gross!
    //UNDONE:  Read Intel 16-24 for the gory details.

    dest->r64 = l->r64 - r->r64;

    // Compute the new tag value
    SetTag(dest);
}

NPXFUNC3(FpSub32_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub32_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub32_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub32_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub64_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    //
    // TAG_SPECIAL_INDEF, TAG_SPECIAL_QNAN, TAG_SPECIAL_DENORM, and
    // TAG_SPECIAL_INFINITY have no special handling - just use the
    // VALID_VALID code.
    FpSub64_VALID_VALID(cpu, dest, l, r);
}

NPXFUNC3(FpSub_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        CALLNPXFUNC3(cpu->FpSubTable, l->Tag, TAG_SPECIAL, dest, l, r);
    }
}

NPXFUNC3(FpSub_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        CALLNPXFUNC3(cpu->FpSubTable, TAG_SPECIAL, r->Tag, dest, l, r);
    }
}

VOID
FpSubCommon(
    PCPUDATA cpu,
    PFPREG   dest,
    PFPREG   l,
    PFPREG   r
    )

/*++

Routine Description:

    Implements dest = l-r

Arguments:

    cpu     - per-thread data
    dest    - destination FP register
    l       - left-hand FP register
    r       - right-hand FP register

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    CALLNPXFUNC3(cpu->FpSubTable, l->Tag, r->Tag, dest, l, r);
}



NPXCOMFUNC(FpCom_VALID_VALID)
{
    //
    // Note that this function is called when one or both of the values
    // is zero - the sign of 0.0 is ignored in the comparison, so the
    // C language '==' and '<' operators do the Right Thing.
    //

    if (l->r64 == r->r64) {
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
    } else if (l->r64 < r->r64) {
        cpu->FpStatusC3 = 0;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 1;
    } else {
        cpu->FpStatusC3 = 0;
        cpu->FpStatusC2 = 0;
        cpu->FpStatusC0 = 0;
    }
}

NPXCOMFUNC(FpCom_VALID_SPECIAL)
{
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (r->TagSpecial == TAG_SPECIAL_QNAN || r->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT(r->TagSpecial == TAG_SPECIAL_DENORM || r->TagSpecial == TAG_SPECIAL_INFINITY);
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_SPECIAL_VALID)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_QNAN || l->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT(l->TagSpecial == TAG_SPECIAL_DENORM || l->TagSpecial == TAG_SPECIAL_INFINITY);
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_QNAN || l->TagSpecial == TAG_SPECIAL_INDEF ||
        r->TagSpecial == TAG_SPECIAL_QNAN || r->TagSpecial == TAG_SPECIAL_INDEF) {
        //
        // Cannot compare a VALID to a QNAN/INDEF
        //
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
        return;
    }

    CPUASSERT((l->TagSpecial == TAG_SPECIAL_DENORM || l->TagSpecial == TAG_SPECIAL_INFINITY) &&
              (r->TagSpecial == TAG_SPECIAL_DENORM || r->TagSpecial == TAG_SPECIAL_INFINITY));
    FpCom_VALID_VALID(cpu, l, r, FALSE);
}

NPXCOMFUNC(FpCom_VALID_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {

        //
        // r is now Indefinite, which can't be compared.
        //
        CPUASSERT(r->Tag == TAG_SPECIAL && r->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

NPXCOMFUNC(FpCom_EMPTY_VALID)
{
    if (!HandleStackEmpty(cpu, l)) {

        //
        // l is now Indefinite, which can't be compared.
        //
        CPUASSERT(l->Tag == TAG_SPECIAL && l->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

NPXCOMFUNC(FpCom_EMPTY_SPECIAL)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FpComTable[TAG_SPECIAL][r->Tag])(cpu, l, r, fUnordered);
    }
}

NPXCOMFUNC(FpCom_SPECIAL_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FpComTable[r->Tag][TAG_SPECIAL])(cpu, l, r, fUnordered);
    }
}

NPXCOMFUNC(FpCom_EMPTY_EMPTY)
{
    if (!HandleStackEmpty(cpu, l) && !HandleStackEmpty(cpu, r)) {

        //
        // l and r are both now Indefinite, which can't be compared.
        //
        CPUASSERT(l->Tag == TAG_SPECIAL && l->TagSpecial == TAG_SPECIAL_INDEF);
        CPUASSERT(r->Tag == TAG_SPECIAL && r->TagSpecial == TAG_SPECIAL_INDEF);
        if (!fUnordered && HandleInvalidOp(cpu)) {
            // abort the FCOM/FTST instruction - Illegal opcode is unmasked
            return;
        }

        // Otherwise, FCOM's illegal opcode is masked, or the instruction
        // is FUCOM, for which QNANs are uncomparable.  Return "Not comparable"
        cpu->FpStatusC3 = 1;
        cpu->FpStatusC2 = 1;
        cpu->FpStatusC0 = 1;
    }
}

VOID
FpComCommon(
    PCPUDATA cpu,
    PFPREG   l,
    PFPREG   r,
    BOOL     fUnordered
    )

/*++

Routine Description:

    Implements l += r.

Arguments:

    cpu     - per-thread data
    l       - left-hand FP register
    r       - right-hand FP register
    fUnordered - TRUE for unordered compares

Return Value:

    None.  l is updated to contain the value of l+r.

--*/

{
    cpu->FpStatusC1 = 0;        // assume no error
    (*FpComTable[l->Tag][r->Tag])(cpu, l, r, fUnordered);
}


FRAG1(FADD32, FLOAT)      // FADD m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpAddCommon(cpu, cpu->FpST0, &m32real);
}

FRAG1(FADD64, DOUBLE)     // FADD m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpAddCommon(cpu, cpu->FpST0, &m64real);
}

FRAG1IMM(FADD_STi_ST, INT) // FADD ST(i), ST = add ST to ST(i)
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FADD_ST_STi, INT) // FADD ST, ST(i) = add ST(i) to ST
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FADDP_STi_ST, INT) // FADDP ST(i), ST = add ST to ST(i) and pop ST
{
    FpArithPreamble(cpu);

    FpAddCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIADD16, USHORT)   // FIADD m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpAddCommon(cpu, cpu->FpST0, &m16int);
}

FRAG1(FIADD32, ULONG)    // FIADD m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpAddCommon(cpu, cpu->FpST0, &m32int);
}


FRAG1(FCOM32, FLOAT)  // FCOM m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m32real, FALSE);
}

FRAG1(FCOM64, DOUBLE) // FCOM m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m64real, FALSE);
}

FRAG1IMM(FCOM_STi, INT) // FCOM ST(i)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], FALSE);
}

FRAG1(FCOMP32, FLOAT) // FCOMP m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m32real, FALSE);
    POPFLT;
}

FRAG1(FCOMP64, DOUBLE) // FCOMP m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpComCommon(cpu, cpu->FpST0, &m64real, FALSE);
    POPFLT;
}

FRAG1IMM(FCOMP_STi, INT) // FCOMP ST(i)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], FALSE);
    POPFLT;
}

FRAG0(FCOMPP)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(1)], FALSE);
    POPFLT;
    POPFLT;
}


FRAG1(FDIV32, FLOAT)  // FDIV m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
}

FRAG1(FDIV64, DOUBLE) // FDIV m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
}

FRAG1IMM(FDIV_ST_STi, INT) // FDIV ST, ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FDIV_STi_ST, INT) // FDIV ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1(FIDIV16, USHORT) // FIDIV m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m16int);
}

FRAG1(FIDIV32, ULONG)   // FIDIV m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, cpu->FpST0, &m32int);
}

FRAG1IMM(FDIVP_STi_ST, INT)    // FDIVP ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
    POPFLT;
}

FRAG1(FDIVR32, FLOAT)     // FDIVR m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpDivCommon(cpu, cpu->FpST0, &m32real, cpu->FpST0);
}

FRAG1(FDIVR64, DOUBLE)    // FDIVR m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpDivCommon(cpu, cpu->FpST0, &m64real, cpu->FpST0);
}

FRAG1IMM(FDIVR_ST_STi, INT) // FDIVR ST, ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FDIVR_STi_ST, INT) // FDIVR ST(i), ST
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FDIVRP_STi_ST, INT) // FDIVRP ST(i)
{
    FpArithPreamble(cpu);

    FpDivCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIDIVR16, USHORT)  // FIDIVR m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, &m16int, cpu->FpST0);
}

FRAG1(FIDIVR32, ULONG)   // FIDIVR m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpDivCommon(cpu, cpu->FpST0, &m32int, cpu->FpST0);
}

FRAG1(FICOM16, USHORT)   // FICOM m16int (Intel docs say m16real)
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m16int, FALSE);
}

FRAG1(FICOM32, ULONG)    // FICOM m32int (Intel docs say m32real)
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m32int, FALSE);
}

FRAG1(FICOMP16, USHORT)  // FICOMP m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m16int, FALSE);
    POPFLT;
}

FRAG1(FICOMP32, ULONG)   // FICOMP m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpComCommon(cpu, cpu->FpST0, &m32int, FALSE);
    POPFLT;
}

FRAG1(FMUL32, FLOAT)      // FMUL m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpMulCommon(cpu, cpu->FpST0, &m32real);
}

FRAG2(FMUL64, DOUBLE)     // FMUL m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpMulCommon(cpu, cpu->FpST0, &m64real);
}

FRAG1IMM(FMUL_STi_ST, INT) // FMUL ST(i), ST
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FMUL_ST_STi, INT) // FMUL ST, ST(i)
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FMULP_STi_ST, INT)    // FMULP ST(i), ST
{
    FpArithPreamble(cpu);

    FpMulCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FIMUL16, USHORT)      // FIMUL m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpMulCommon(cpu, cpu->FpST0, &m16int);
}

FRAG1(FIMUL32, ULONG)       // FIMUL m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpMulCommon(cpu, cpu->FpST0, &m32int);
}

FRAG1(FSUB32, FLOAT)      // FSUB m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
}

FRAG1(FSUBP32, FLOAT)     // FSUBP m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32real);
    POPFLT;
}

FRAG1(FSUB64, DOUBLE)     // FSUB m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
}

FRAG1(FSUBP64, DOUBLE)    // FSUBP m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m64real);
    POPFLT;
}

FRAG1IMM(FSUB_ST_STi, INT)   // FSUB ST, ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FSUB_STi_ST, INT)  // FSUB ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
}

FRAG1IMM(FSUBP_STi_ST, INT) // FSUBP ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], cpu->FpST0, &cpu->FpStack[ST(op1)]);
    POPFLT;
}

FRAG1(FISUB16, USHORT)   // FISUB m16int
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m16int);
}

FRAG1(FISUB32, ULONG)    // FISUB m32int
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, cpu->FpST0, &m32int);
}

FRAG1(FSUBR32, FLOAT)     // FSUBR m32real
{
    FPREG m32real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR4(&m32real, pop1);
    FpSubCommon(cpu, cpu->FpST0, &m32real, cpu->FpST0);
}

FRAG1(FSUBR64, DOUBLE)    // FSUBR m64real
{
    FPREG m64real;

    FpArithDataPreamble(cpu, pop1);

    GetIntelR8(&m64real, pop1);
    FpSubCommon(cpu, cpu->FpST0, &m64real, cpu->FpST0);
}

FRAG1IMM(FSUBR_ST_STi, INT) // FSUBR ST, ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FSUBR_STi_ST, INT) // FSUBR ST(i), ST
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
}

FRAG1IMM(FSUBRP_STi_ST, INT) // FSUBRP ST(i)
{
    FpArithPreamble(cpu);

    FpSubCommon(cpu, &cpu->FpStack[ST(op1)], &cpu->FpStack[ST(op1)], cpu->FpST0);
    POPFLT;
}

FRAG1(FISUBR16, USHORT)
{
    FPREG m16int;
    short s;

    FpArithDataPreamble(cpu, pop1);

    s = (short)GET_SHORT(pop1);
    if (s) {
        m16int.r64 = (DOUBLE)s;
        m16int.Tag = TAG_VALID;
    } else {
        m16int.r64 = 0.0;
        m16int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, &m16int, cpu->FpST0);
}

FRAG1(FISUBR32, ULONG)
{
    FPREG m32int;
    long l;

    FpArithDataPreamble(cpu, pop1);

    l = (long)GET_LONG(pop1);
    if (l) {
        m32int.r64 = (DOUBLE)l;
        m32int.Tag = TAG_VALID;
    } else {
        m32int.r64 = 0.0;
        m32int.Tag = TAG_ZERO;
    }
    FpSubCommon(cpu, cpu->FpST0, &m32int, cpu->FpST0);
}

FRAG0(FTST)
{
    FPREG Zero;

    FpArithPreamble(cpu);

    Zero.r64 = 0.0;
    Zero.Tag = TAG_ZERO;
    FpComCommon(cpu, cpu->FpST0, &Zero, FALSE);
}

FRAG1IMM(FUCOM, INT)        // FUCOM ST(i) / FUCOM
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], TRUE);
}

FRAG1IMM(FUCOMP, INT)       // FUCOMP ST(i) / FUCOMP
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(op1)], TRUE);
    POPFLT;
}

FRAG0(FUCOMPP)
{
    FpArithPreamble(cpu);

    FpComCommon(cpu, cpu->FpST0, &cpu->FpStack[ST(1)], TRUE);
    POPFLT;
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpufragp.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufragp.h

Abstract:
    
    Private include file for the 487 emulator portion of the Fragment Library

Author:

    04-Oct-1995 BarryBo, Created

Revision History:

--*/

#ifndef FPUFRAGP_H
#define FPUFRAGP_H

//
// ALPHA, PPC and INTEL have the same bit-patterns for QNAN/SNAN/INDEFINITE.
// MIPS has different representations.  NATIVE_NAN_IS_INTEL_FORMAT
// is used to distinguish between the different representations.
//
#if defined(_ALPHA_) || defined(_PPC_)
    #define NATIVE_NAN_IS_INTEL_FORMAT  1
#elif defined(_MIPS_)
    #define NATIVE_NAN_IS_INTEL_FORMAT  0
#else
    #error Unknown machine type
#endif


// Macros to access the register stack
#define ST(i)   ((cpu->FpTop+(i)) & 0x07)

#define PUSHFLT(x) {                    \
    INT Top;                            \
    Top = (cpu->FpTop-1) & 0x07;        \
    cpu->FpTop = Top;                   \
    x = cpu->FpST0 = &cpu->FpStack[Top];\
}

#define INCFLT  {                       \
    INT Top;                            \
    Top = (cpu->FpTop+1) & 0x07;        \
    cpu->FpTop = Top;                   \
    cpu->FpST0 = &cpu->FpStack[Top];    \
}

#define POPFLT  { cpu->FpST0->Tag = TAG_EMPTY; INCFLT; }


// Values for cpu->FpReg[].Tag
#define TAG_VALID   0       // value specified by Intel
#define TAG_ZERO    1       // value specified by Intel
#define TAG_SPECIAL 2       // value specified by Intel, indicates SpecialTag is set
#define TAG_EMPTY   3       // value specified by Intel
#define TAG_MAX     4       // value after the highest legal tag value


// Values for cpu->FpReg[].SpecialTag, valid only when Tag==TAG_SPECIAL
#define TAG_SPECIAL_DENORM  0       // private value for NPX emulator
#define TAG_SPECIAL_INFINITY 1      // private value for NPX emulator
#define TAG_SPECIAL_SNAN    2       // private value for NPX emulator
#define TAG_SPECIAL_QNAN    3       // private value for NPX emulator
#define TAG_SPECIAL_INDEF   4       // private value for NPX emulator

// Does a register hold a QNAN, SNAN, or INDEFINITE?
#define IS_TAG_NAN(FpReg)       \
    ((FpReg)->Tag == TAG_SPECIAL && (FpReg)->TagSpecial >= TAG_SPECIAL_SNAN)


// Common types used for jump tables in the 487 emulator
typedef VOID (*NpxFunc0)(PCPUDATA);
typedef VOID (*NpxFunc1)(PCPUDATA, PFPREG Fp);
typedef VOID (*NpxFunc2)(PCPUDATA cpu, PFPREG l, PFPREG r);
typedef VOID (*NpxFunc3)(PCPUDATA cpu, PFPREG dest, PFPREG l, PFPREG r);
typedef VOID (*NpxComFunc)(PCPUDATA cpu, PFPREG l, PFPREG r, BOOL fUnordered);
typedef VOID (*NpxPutIntelR4)(FLOAT *pIntelReal, PFPREG Fp);
typedef VOID (*NpxPutIntelR8)(DOUBLE *pIntelReal, PFPREG Fp);
typedef VOID (*NpxPutIntelR10)(PBYTE r10, PFPREG Fp);
typedef VOID (*NpxLoadIntelR10ToR8)(PCPUDATA cpu, PBYTE r10, PFPREG FpReg);
typedef VOID (*NpxPutI2)(PCPUDATA cpu, SHORT *pop1, PFPREG Fp);
typedef VOID (*NpxPutI4)(PCPUDATA cpu, LONG *pop1, PFPREG Fp);
typedef VOID (*NpxPutI8)(PCPUDATA cpu, LONGLONG *pop1, PFPREG Fp);

// Macros to declare functions for those common types
#define NPXFUNC0(name)  VOID name(PCPUDATA cpu)
#define NPXFUNC1(name)  VOID name(PCPUDATA cpu, PFPREG Fp)
#define NPXFUNC2(name)  VOID name(PCPUDATA cpu, PFPREG l, PFPREG r)
#define NPXFUNC3(name)  VOID name(PCPUDATA cpu, PFPREG dest, PFPREG l, PFPREG r)
#define NPXCOMFUNC(name) VOID name(PCPUDATA cpu, PFPREG l, PFPREG r, BOOL fUnordered)
#define NPXPUTINTELR4(name) VOID name(FLOAT *pIntelReal, PFPREG Fp)
#define NPXPUTINTELR8(name) VOID name(DOUBLE *pIntelReal, PFPREG Fp)
#define NPXPUTINTELR10(name) VOID name(PBYTE r10, PFPREG Fp)
#define NPXLOADINTELR10TOR8(name) VOID name(PCPUDATA cpu, PBYTE r10, PFPREG Fp)
#define NPXPUTI2(name)  VOID name(PCPUDATA cpu, SHORT *pop1, PFPREG Fp)
#define NPXPUTI4(name)  VOID name(PCPUDATA cpu, LONG *pop1, PFPREG Fp)
#define NPXPUTI8(name)  VOID name(PCPUDATA cpu, LONGLONG *pop1, PFPREG Fp)

extern const BYTE R8PositiveInfinityVal[8];
extern const BYTE R8NegativeInfinityVal[8];
#define R8PositiveInfinity *(DOUBLE *)R8PositiveInfinityVal
#define R8NegativeInfinity *(DOUBLE *)R8NegativeInfinityVal


VOID GetIntelR4(PFPREG Fp, FLOAT *pIntelReal);

#if NATIVE_NAN_IS_INTEL_FORMAT

    #define GetIntelR8(Fp, pIntelReal)                      \
        (Fp)->r64 = *(UNALIGNED DOUBLE *)(pIntelReal);      \
        SetTag(Fp);

    #define PutIntelR4(pIntelReal, Fp)                      \
        *(UNALIGNED FLOAT *)pIntelReal = (FLOAT)(Fp)->r64;

    #define PutIntelR8(pIntelReal, Fp)                      \
        *(UNALIGNED DOUBLE *)pIntelReal = (Fp)->r64;


#else

    VOID GetIntelR8(
        PFPREG Fp,
        DOUBLE *pIntelReal
        );

    extern NpxPutIntelR4 PutIntelR4Table[TAG_MAX];
    extern NpxPutIntelR8 PutIntelR8Table[TAG_MAX];

    #define PutIntelR4(pIntelReal, Fp)  \
        (*PutIntelR4Table[(Fp)->Tag])((pIntelReal), (Fp))

    #define PutIntelR8(pIntelReal, Fp)  \
        (*PutIntelR8Table[(Fp)->Tag])((pIntelReal), (Fp))

#endif

extern const NpxPutIntelR10 PutIntelR10Table[TAG_MAX];
#define PutIntelR10(pIntelReal, Fp)  (*PutIntelR10Table[(Fp)->Tag])((pIntelReal), (Fp))


VOID
SetTag(
    PFPREG FpReg
    );

VOID
ComputeR10Tag(
    USHORT *r10,
    PFPREG FpReg
    );

VOID
ChopR10ToR8(
    PBYTE r10,
    PFPREG FpReg,
    USHORT R10Exponent
);

VOID
LoadIntelR10ToR8(
    PCPUDATA cpu,
    PBYTE r10,
    PFPREG FpReg
);

BOOL
HandleSnan(
    PCPUDATA cpu,
    PFPREG   FpReg
    );

BOOL
HandleStackEmpty(
    PCPUDATA cpu,
    PFPREG FpReg
    );

VOID
UpdateFpExceptionFlags(
    PCPUDATA cpu
    );

VOID
SetIndefinite(
    PFPREG  FpReg
    );

BOOL
HandleInvalidOp(
    PCPUDATA cpu
    );

VOID
FpControlPreamble(
    PCPUDATA cpu
    );

VOID
FpArithPreamble(
    PCPUDATA cpu
    );

VOID
FpArithDataPreamble(
    PCPUDATA cpu,
    PVOID    FpData
    );

VOID
HandleStackFull(
    PCPUDATA cpu,
    PFPREG   FpReg
    );


#endif //FPUFRAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpubcd.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpubcd.c

Abstract:

    Floating point BCD fragments (FBLD, FBSTP)

Author:

    05-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include "wx86.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"

typedef VOID (*NpxPutBCD)(PCPUDATA cpu, PFPREG Fp, PBYTE pop1);
#define NPXPUTBCD(name) VOID name(PCPUDATA cpu, PFPREG Fp, PBYTE pop1)

NPXPUTBCD(FBSTP_VALID);
NPXPUTBCD(FBSTP_ZERO);
NPXPUTBCD(FBSTP_SPECIAL);
NPXPUTBCD(FBSTP_EMPTY);

const NpxPutBCD FBSTPTable[TAG_MAX] = {
    FBSTP_VALID,
    FBSTP_ZERO,
    FBSTP_SPECIAL,
    FBSTP_EMPTY
};

const double BCDMax=999999999999999999.0;

VOID
StoreIndefiniteBCD(
    PBYTE pop1
    )
/*++

Routine Description:

    Write out the BCD encoding for INDEFINITE.

    Note that ntos\dll\i386\emlsbcd.asm writes out a different
    bit-pattern than the 487 does!  The value written here matches
    a Pentium's response.

Arguments:

    pop1 - address of BCD to write to

Return Value:

    None

--*/
{
    //
    // Write out:          0xffff c0000000 00000000
    // emlsbcd.asm writes: 0xffff 00000000 00000000
    //                            ^
    //
    PUT_LONG(pop1, 0);
    PUT_LONG(pop1+4, 0xc0000000);
    PUT_SHORT(pop1+8, 0xffff);
}



FRAG1(FBLD, BYTE)
{
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
    } else {
        LONGLONG I64;
        DWORD dw0;
        INT Bytes;
        BYTE Val;
        PFPREG ST0;

        //
        // Get the BCD value into the FPU
        //
        dw0 = GET_LONG(pop1);

        PUSHFLT(ST0);

        if (dw0 == 0) {
            DWORD dw1 = GET_LONG(pop1+4);
            USHORT us0 = GET_SHORT(pop1+8);

            if (dw1 == 0xc0000000 && us0 == 0xffff) {

                //
                // The value is INDEFINITE
                //
                SetIndefinite(ST0);
                return;

            } else if (dw1 == 0 && (us0 & 0xff) == 0) {

                //
                // The value is +/- 0
                //
                ST0->Tag = TAG_ZERO;
                ST0->r64 = 0;
                ST0->rb[7] = (us0 >> 8); // copy in the sign bit
                return;
            }
        }

        //
        // Otherwise, the BCD value is TAG_VALID - load the digits in
        //
        I64 = 0;
        for (Bytes=8; Bytes>=0; --Bytes) {
            Val = GET_BYTE(pop1+Bytes);
            I64 = I64*100 + (Val>>4)*10 + (Val&0x0f);
        }

        //
        // Get the sign bit
        //
        Val = GET_BYTE(pop1+9) & 0x80;

        //
        // Set up the FP reg
        //
        ST0->Tag = TAG_VALID;
        ST0->r64 = (double)I64;
        ST0->rb[7] |= Val;       // copy in the sign bit
    }
}

NPXPUTBCD(FBSTP_VALID)
{
    BYTE Sign = Fp->rb[7] & 0x80;       // preserve the R8 sign
    BYTE Val;
    INT Bytes;
    LONGLONG I64;
    LONGLONG NewI64;
    DOUBLE r64;

    //
    // Take the absolute value of the R8 by clearing its sign bit
    //
    r64 = Fp->r64;
    *((PBYTE)&r64+7) &= 0x7f;

    //
    // Check the range of the R8
    //
    if (r64 > BCDMax) {
        //
        // Overflow - write out BCD indefinite.
        //
        StoreIndefiniteBCD(pop1);
        return;
    }

    //
    // Convert to an integer according the the current rounding mode
    //
    I64 = (LONGLONG)r64;

    //
    // Convert the integer to BCD, two digits at a time, and store it
    //
    for (Bytes = 0; Bytes < 9; ++Bytes) {
        NewI64 = I64 / 10;
        Val = (BYTE)(I64 - NewI64*10);  // low nibble Val = I64 mod 10
                                        // high nibble Val = 0

        I64 = NewI64 / 10;
        Val += 16*(BYTE)(NewI64 - I64*10);    // low nibble Val = I64 mod 10
                                        // high nibble Val = (I64/10) mod 10

        //
        // Store the two BCD digits
        //
        PUT_BYTE(pop1, Val);

        //
        // I64 has been divided by 100 since the top of the loop, so
        // there is nothing to do to it in order to loop again.  Update
        // the address we are writing to, then loop.
        //
        pop1++;
    }

    //
    // Store the sign bit, along with 7 zero bits in the top byte
    //
    PUT_BYTE(pop1, Sign);
    POPFLT;
}

NPXPUTBCD(FBSTP_ZERO)
{
    // Store out the signed zero value
    memset(pop1, 0, 9);
    PUT_BYTE(pop1+9, Fp->rb[7]);
    POPFLT;
}

NPXPUTBCD(FBSTP_SPECIAL)
{
    if (Fp->TagSpecial) {
        FBSTP_VALID(cpu, Fp, pop1);
    } else {
        //
        // INFINITY and NANs are invalid, and the masked behavior is
        // to write out INDEFINITE.
        //
        if (!HandleInvalidOp(cpu)) {
            StoreIndefiniteBCD(pop1);
            POPFLT;
        }
    }
}

NPXPUTBCD(FBSTP_EMPTY)
{
    if (!HandleStackEmpty(cpu, Fp)) {
        StoreIndefiniteBCD(pop1);
    }
}

FRAG1(FBSTP, BYTE)
{
    PFPREG ST0;

    FpArithDataPreamble(cpu, pop1);
    ST0 = cpu->FpST0;
    (*FBSTPTable[ST0->Tag])(cpu, ST0, pop1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\entrypt\epalloc.c ===
/*++
                                                                                
Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    epalloc.c

Abstract:
    
    This module allocates memory for the entry point structures
    
Author:

    21-Aug-1995 Ori Gershony (t-orig)

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "config.h"
#include "entrypt.h"

ASSERTNAME;

PVOID allocBase;        // Base of the allocation unit
PVOID commitLimit;      // Top of commited memory
PVOID allocLimit;       // Top of memory allocated to the user

#if DBG
#define EPTRASHVALUE    0x0b
#endif

INT
initEPAlloc(
    VOID
    )
/*++

Routine Description:

    Initializes the entry point memory allocator

Arguments:

    none

Return Value:

    return-value - non-zero for success, 0 for failure

--*/
{
    NTSTATUS Status;
    ULONGLONG ReserveSize = CpuEntryPointReserve;


    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &allocBase,
                                     0,
                                     &ReserveSize,
                                     MEM_RESERVE,
                                     PAGE_READWRITE
                                     );
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    // No memory is commited yet, nor is any allocated to the user

    allocLimit = commitLimit = allocBase;

    return (INT)(LONGLONG)allocBase;  
}


VOID
termEPAlloc(
    VOID
    )
/*++

Routine Description:

    Frees the memory used the the allocator.  This should only be
    called before the process is terminated.

Arguments:

    none

Return Value:

    return-value - none

--*/
{
    ULONGLONG ReserveSize = CpuEntryPointReserve;

    NtFreeVirtualMemory(NtCurrentProcess(),
                        &allocBase,
                        &ReserveSize,
                        MEM_RELEASE
                       );
}


BOOLEAN
commitMemory(
    LONG CommitDiff
    )
/*++

Routine Description:

    This routine tries to commit memory for use by the allocator.  If there
    is no more memory left, is fails and returns with zero.  Else it returns
    1 for success.  This is an internal function for use by the allocator
    only.

Arguments:

    none

Return Value:

    return-value - TRUE for success, FALSE for failure

--*/
{
    LONG CommitSize;
    DWORD i;
    LONGLONG TempCommitDiff = CommitDiff;

    for (i=0; i<CpuMaxAllocRetries; ++i) {
        NTSTATUS Status;
        LARGE_INTEGER Timeout;

        //
        // Try to allocate more memory
        //
        if ((LONG)(ULONGLONG)commitLimit + CommitDiff -(LONG)(ULONGLONG)allocBase > (LONG)(ULONGLONG)CpuEntryPointReserve) {
            //
            // The commit would extend pase the reserve.  Fail the
            // alloc, which will cause a cache/entrypoint flush.
            //
            return FALSE;
        }
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         &commitLimit,
                                         0,
                                         &TempCommitDiff,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                        );
        if (NT_SUCCESS(Status)) {
            //
            // Allocation succeeded.  Move commitLimit up and return success
            //
#if DBG
            RtlFillMemory(commitLimit, TempCommitDiff, EPTRASHVALUE);
#endif
            commitLimit = (PVOID) ((ULONG)(ULONGLONG)commitLimit + TempCommitDiff);
            return TRUE;
        }

        //
        // No pages available.  Sleep a bit and hope another thread frees a
        // page.
        //
        Timeout.QuadPart = (LONGLONG)CpuWaitForMemoryTime * -10000i64;
        NtDelayExecution(FALSE, &Timeout);
    }

    //
    // No pages available.  Return failure.  Caller will attempt to free
    // some pages and retry the EPAlloc call.
    return FALSE;
}


PVOID
EPAlloc(
    DWORD cb
    )
/*++

Routine Description:

    This routine allocated memory for use by the entry point module.

Arguments:

    cb - count of bytes to allocate from the entrypoint memory.

Return Value:

    return-value - The memory allocated if succeeded, NULL otherwise

--*/
{
    PVOID newAllocLimit, oldAllocLimit;
    LONG CommitDiff;

    

    CPUASSERTMSG(allocLimit == commitLimit || *(PBYTE)allocLimit == EPTRASHVALUE, "Entrypoint memory overrun");

    // Calculate new allocation limit
    oldAllocLimit = allocLimit;
    newAllocLimit = (PVOID) ((ULONG)(ULONGLONG)oldAllocLimit + cb);

    // See if we need to commit more memory
    CommitDiff = (LONG)(ULONGLONG)newAllocLimit - (LONG)(ULONGLONG)commitLimit;
    if (CommitDiff > 0){
        // Yes we do, so try to commit more memory
        if (!commitMemory(CommitDiff)){
            // Cannot commit more memory, so return failure
            return NULL;
        }
    }

    allocLimit = newAllocLimit;
    return oldAllocLimit;
}


VOID
EPFree(
    VOID
    )
/*++

Routine Description:

    This routine frees all entry point memory allocated so far

Arguments:

    none

Return Value:

    none

--*/
{
#if DBG
    //
    // Fill the committed space with a known value to make
    // debugging easier
    //
    RtlFillMemory(allocBase, (ULONG)(ULONGLONG)allocLimit-(ULONG)(ULONGLONG)allocBase, EPTRASHVALUE);
#endif
    allocLimit = allocBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpufrags.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpufrags.c

Abstract:

    Floating point instruction fragments

Author:

    06-Jul-1995 BarryBo

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/


/*
 *  Important design considerations:
 *
 * 1. Floating-point precision 32/64/80-bits.
 *      On a 487, all operations use 80-bit precision except for ADD, SUB(R),
 *      MUL, DIV(R), and SQRT, which use the precision control.
 *
 *      The emulator uses 64-bit precision for all operations except for those
 *      listed above, where 32-bit precision will be used if the app enables it.
 *
 * 2. Unmasked FP exceptions.
 *      The native FPU is set to mask *ALL* FP exceptions.  The emulator polls
 *      for exceptions at the ends of emulated instructions and simulates
 *      masked/unmasked exceptions as required.  If this is not done, the
 *      following scenerio can occur:
 *
 *       1. App unmasks all exceptions
 *       2. App loads two SNANS
 *       3. App performs FADD ST, ST(1)
 *       4. The emulated FADD is implemented as NATIVE FADD, plus NATIVE FST.
 *           The NATIVE FADD will set an unmaked exception and the NATIVE FST
 *           will raise the exception.  On Intel, the FADD is a single FP
 *           instruction, and the exception will not be raised until the next
 *           Intel instruction.
 *
 * 3. INDEFINITE/QNAN/SNAN.
 *      MIPS and PPC have a different representation for NANs than Intel/Alpha.
 *      Within the FpRegs array, NANs are stored in the native RISC format.
 *      All loads and stores of native values to Intel memory must use
 *      PutIntelR4/PutIntelR8 and GetIntelR4/GetIntelR8, which hide the
 *      conversion to/from native format.
 *          See \\orville\razzle\src\crtw32\fpw32\include\trans.h.
 *
 * 4. Floating-point Tag Word.
 *      For speed, the emulator keeps richer information about the values
 *      than the 487 does.  TAG_SPECIAL is further classified into
 *      INDEFINITE, QNAN, SNAN, or INFINITY.
 *
 * 5. Raising an FP exception.
 *      The 487 keeps track of the address of the last FP instruction and
 *      the Effective Address used to point to its operand.  The instruction
 *      opcode is also stored.  This information is required because the 486
 *      integer unit is operating concurrently and probably has updated
 *      EIP before the 487 raised the exception.
 *
 *      The CPU emulator must make EIP available to the 487 emulator for
 *      this purpose, too.  The Effective Address is passed as a parameter to
 *      instructions which care, so there is no issue (which is why all
 *      FP fragments take BYREF parameters instead of BYVAL).
 *
 *      Note that EIP must point to the first prefix for the instruction, not
 *      the opcode itself.
 *
 *      Data pointer is not affected by FINIT, FLDCW, FSTCW, FSTSW, FCLEX,
 *      FSTENV, FLDENV, FSAVE, and FRSTOR.  Data pointer is UNDEFINED if
 *      the instruction did not have a memory operand.
 *
 * 6. Thread initialization.
 *      The per-thread initialization performs no floating-point operations
 *      so that integer-only threads do not incur any overhead in NT.  For
 *      example, on an Intel MP box, any thread which executes a single FP
 *      instruction incurs additional overhead during context-switch for that
 *      thread.  We only want to add that overhead if the Intel app being
 *      emulated actually uses FP instructions.
 *
 * 7. Floating-point formats:
 *      Figure 15-10 and Table 15-3 (Intel page 15-12) describe the formats.
 *      WARNING: Figure 15-10 indicates the highest addressed byte is at
 *               the right.  In fact, the the sign bit is in the highest-
 *               addressed byte!  The mantissa is in the lowest bytes,
 *               followed by the exponent (Bias = 127,1023,16383), followed
 *               by the sign bit.
 *
 *      ie. memory = 0x00 0x00 0x00 0x00 0x00 0x00 0x08 0x40
 *          means, reverse the byte order:
 *                   0x40 0x08 0x00 0x00 0x00 0x00 0x00 0x00
 *          convert to binary:
 *                     4    0    0    8    0    0
 *                   0100 0000 0000 1000 0000 0000 ....
 *                   ||-----------| |------------- .... |
 *                   |  exponent      mantissa
 *                   sign
 *
 *          To get the unbiased exponent, subtract off the bias (1023 for R8)
 *              E = e-bias = 1024 - 1023 = 1
 *
 *          To get the mantissa, there is an implicit leading '1' (except R10)
 *              mantissa = 1 concatenated with 1000 0000 .... = 11 = 1.5(decimal)
 *
 *          Therefore, the value is +2^1*1.5 = 3
 *
 *
 */

//UNDONE: handle loading of unsupported format numbers.  TimP converts them
//        silently to INDEFINITE (the masked exception behavior)

//UNDONE: Fix the DENORMAL cases so they throw exceptions if needed.


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdio.h>
#include <limits.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "config.h"
#include "fragp.h"
#include "fpufrags.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

DWORD pfnNPXNPHandler;      // Address of x86 NPX emulator entrypoint


//
// Bit-patterns for +INFINITY and -INFINITY
//
const BYTE R8PositiveInfinityVal[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f };
const BYTE R8NegativeInfinityVal[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff };

//
// Sets floating-point ES bit in status word based on current control reg
// and status reg.
//
#define SetErrorSummary(cpu) {                              \
    if (!(cpu)->FpControlMask & (cpu)->FpStatusExceptions) {\
        (cpu)->FpStatusES = 1;                              \
    } else {                                                \
        (cpu)->FpStatusES = 0;                              \
    }                                                       \
}

//
// Forward declarations
//
VOID
StoreEnvironment(
    PCPUDATA cpu,
    DWORD    *pEnv
    );

// in fraglib\{mips|ppc|alpha}\fphelp.s:
VOID
SetNativeRoundingMode(
    DWORD x86RoundingMode
    );

#ifdef ALPHA
unsigned int GetNativeFPStatus(void);
#endif


NPXFUNC1(FRNDINT_VALID);
NPXFUNC1(FRNDINT_ZERO);
NPXFUNC1(FRNDINT_SPECIAL);
NPXFUNC1(FRNDINT_EMPTY);
NPXFUNC2(FSCALE_VALID_VALID);
NPXFUNC2(FSCALE_VALIDORZERO_VALIDORZERO);
NPXFUNC2(FSCALE_SPECIAL_VALIDORZERO);
NPXFUNC2(FSCALE_VALIDORZERO_SPECIAL);
NPXFUNC2(FSCALE_SPECIAL_SPECIAL);
NPXFUNC2(FSCALE_ANY_EMPTY);
NPXFUNC2(FSCALE_EMPTY_ANY);
NPXFUNC1(FSQRT_VALID);
NPXFUNC1(FSQRT_ZERO);
NPXFUNC1(FSQRT_SPECIAL);
NPXFUNC1(FSQRT_EMPTY);
NPXFUNC1(FXTRACT_VALID);
NPXFUNC1(FXTRACT_ZERO);
NPXFUNC1(FXTRACT_SPECIAL);
NPXFUNC1(FXTRACT_EMPTY);

const NpxFunc1 FRNDINTTable[TAG_MAX] = {
    FRNDINT_VALID,
    FRNDINT_ZERO,
    FRNDINT_SPECIAL,
    FRNDINT_EMPTY
};

const NpxFunc2 FSCALETable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FSCALE_VALID_VALID, FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_ZERO, right is ...
    { FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_VALIDORZERO, FSCALE_VALIDORZERO_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_SPECIAL, right is ...
    { FSCALE_SPECIAL_VALIDORZERO, FSCALE_SPECIAL_VALIDORZERO, FSCALE_SPECIAL_SPECIAL, FSCALE_ANY_EMPTY},
    // left is TAG_EMPTY, right is ...
    { FSCALE_EMPTY_ANY, FSCALE_ANY_EMPTY, FSCALE_ANY_EMPTY, FSCALE_EMPTY_ANY}
};

const NpxFunc1 FSQRTTable[TAG_MAX] = {
    FSQRT_VALID,
    FSQRT_ZERO,
    FSQRT_SPECIAL,
    FSQRT_EMPTY,
};

const NpxFunc1 FXTRACTTable[TAG_MAX] = {
    FXTRACT_VALID,
    FXTRACT_ZERO,
    FXTRACT_SPECIAL,
    FXTRACT_EMPTY
};


FRAG0(FpuInit)

/*++

Routine Description:

    Initialize the FPU emulator to match the underlying FPU hardware's state.
    Called once per thread.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    int i;
    ANSI_STRING ProcName;
    NTSTATUS Status;

    // IMPORTANT: Read note (6), above, before adding any new code here!

    // Initialize the non-zero values here.
    cpu->FpControlMask = FPCONTROL_IM|
                         FPCONTROL_DM|
                         FPCONTROL_ZM|
                         FPCONTROL_OM|
                         FPCONTROL_UM|
                         FPCONTROL_PM;
    cpu->FpST0 = &cpu->FpStack[0];
    for (i=0; i<8; ++i) {
        cpu->FpStack[i].Tag = TAG_EMPTY;
    }
    ChangeFpPrecision(cpu, 2);
}

FRAG1(FpuSaveContext, BYTE)

/*++

Routine Description:

    Store the CPU's state to memory.  The format is the same as FNSAVE and
    winnt.h's FLOATING_SAVE_AREA expect.

Arguments:

    cpu - per-thread data
    pop1 - destination where context is to be written.

Return Value:

    None

--*/

{
    INT i, ST;

    StoreEnvironment(cpu, (DWORD *)pop1);
    pop1+=28;   // move pop1 past the 28-byte Instruction and Data Pointer image
    for (i=0; i<8; ++i) {
        ST = ST(i);

        if (cpu->FpStack[ST].Tag == TAG_EMPTY) {
            // special case: writing out a TAG_EMPTY from FNSAVE should
            // not change the value to INDEFINITE - it should write out
            // the bits as if they were really a properly-tagged R8.
            FPREG Fp;

            Fp.r64 = cpu->FpStack[ST].r64;
            SetTag(&Fp);
            PutIntelR10(pop1, &Fp);
        } else {
            PutIntelR10(pop1, &cpu->FpStack[ST]);
        }
        pop1+=10;
    }
}


VOID
SetIndefinite(
    PFPREG  FpReg
    )

/*++

Routine Description:

    Writes an INDEFINITE to an FP register.

Arguments:

    FpReg - register to write the INDEFINITE to.

Return Value:

    None

--*/

{
    FpReg->Tag = TAG_SPECIAL;
    FpReg->TagSpecial = TAG_SPECIAL_INDEF;

#if NATIVE_NAN_IS_INTEL_FORMAT
    FpReg->rdw[0] = 0;
    FpReg->rdw[1] = 0xfff80000;
#else
    FpReg->rdw[0] = 0xffffffff;
    FpReg->rdw[1] = 0x7ff7ffff;
#endif
}


VOID
FpControlPreamble2(
    PCPUDATA cpu
    )

/*++

Routine Description:

    If any FP exceptions are pending from the previous FP instruction, raise
    them now.  Called at the top of each non-control FP instruction, if
    any floating-point exception is unmasked.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{

    //
    // Copy the RISC FP status register into the x86 FP status register
    //
    UpdateFpExceptionFlags(cpu);

    //
    // If there is an error (FpStatusES != FALSE), then raise the
    // unmasked exception if there is one.
    //
    if (cpu->FpStatusES) {
        EXCEPTION_RECORD ExRec;
        DWORD Exception = (~cpu->FpControlMask) & cpu->FpStatusExceptions;

        //
        // There was an unmasked FP exception set by the previous instruction.
        // Raise the exception now.  The order the bits are checked is
        // the same as Kt0720 in ntos\ke\i386\trap.asm checks them.
        //

        //
        // in ntos\ke\i386\trap.asm, floating-point exceptions all vector
        // to CommonDispatchException1Arg0d, which creates a 1-parameter
        // exception with 0 as the first dword of data.  Code in
        // \nt\private\sdktools\vctools\crt\fpw32\tran\i386\filter.c cares.
        // See _fpieee_flt(), where the line reads "if (pinfo[0]) {".
        //
        ExRec.NumberParameters = 1;         // 1 parameter
        ExRec.ExceptionInformation[0]=0;    // 0 = raised by hardware
        if (Exception & FPCONTROL_IM) {        // invalid operation
            if (cpu->FpStatusSF) {

                //
                // Can't use STATUS_FLOAT_STACK_CHECK, 'cause on RISC
                // nt kernel uses it to indicate the float instruction
                // needs to be emulated. The Wx86 exception filters
                // know how to handle this.
                //
                ExRec.ExceptionCode = STATUS_WX86_FLOAT_STACK_CHECK;

                //
                // STATUS_FLOAT_STACK_CHECK has two parameters:
                //  First is 0
                //  Second is the data offset
                //
                ExRec.NumberParameters = 2;
                ExRec.ExceptionInformation[1] = (DWORD)(ULONGLONG)cpu->FpData;  
            } else {
                ExRec.ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            }
        } else if (Exception & FPCONTROL_ZM) {      // zero divide
            ExRec.ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
        } else if (Exception & FPCONTROL_DM) {      // denormal
            ExRec.ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
        } else if (Exception & FPCONTROL_OM) {      // overflow
            ExRec.ExceptionCode = STATUS_FLOAT_OVERFLOW;
        } else if (Exception & FPCONTROL_UM) {      // underflow
            ExRec.ExceptionCode = STATUS_FLOAT_UNDERFLOW;
        } else if (!cpu->FpControlMask & FPCONTROL_PM) {   // precision
            ExRec.ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
        } else {
            //
            // ES is set, but all pending exceptions are masked.
            //    ie. ES is set because ZE is set, but only the
            //        FpControlDM exception is unmasked.
            // Nothing to do, so return.
            //
            return;
        }

        ExRec.ExceptionFlags   = 0;     // continuable exception
        ExRec.ExceptionRecord  = NULL;
        ExRec.ExceptionAddress = (PVOID)cpu->FpEip; // addr of faulting instr

        CpupRaiseException(&ExRec);
    }
}

VOID
FpControlPreamble(
    PCPUDATA cpu
    )

/*++

Routine Description:

    If any FP exceptions are pending from the previous FP instruction, raise
    them now.  Called at the top of each non-control FP instruction.  This
    routine is kept small so it can be inlined by the C compiler.  Most of
    the time, FP exceptions are masked, so there is no work to do.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    if (cpu->FpControlMask == (FPCONTROL_IM|
                               FPCONTROL_DM|
                               FPCONTROL_ZM|
                               FPCONTROL_OM|
                               FPCONTROL_UM|
                               FPCONTROL_PM)) {
        //
        // All FP exceptions are masked.  Nothing to do.
        //
        return;
    }

    FpControlPreamble2(cpu);
}



VOID
FpArithPreamble(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Called at the start of every arithmetic instruction which has no data
    pointer.  Calls FpControlPreamble() to handle any pending exceptions,
    then records the EIP and FP opcode for later exception handling.

    See Intel 16-2 for the list of arithmetic vs. nonarithmetic instructions.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/

{
    FpControlPreamble(cpu);

    // Save the EIP value for this instruction
    cpu->FpEip = eip;

    // Set the data pointer to 0 - this instruction doesn't have an EA
    cpu->FpData = NULL;
}


VOID
FpArithDataPreamble(
    PCPUDATA cpu,
    PVOID    FpData
    )

/*++

Routine Description:

    Called at the start of every arithmetic instruction which has a data
    pointer.  Calls FpArithPreamble() and FpControlPreamble().


Arguments:

    cpu         - per-thread data
    FpData      - pointer to data for this instruction

Return Value:

    None

--*/

{
    FpControlPreamble(cpu);

    // Save the EIP value for this instruction
    cpu->FpEip = eip;

    // Save the data pointer for this instruction
    cpu->FpData = FpData;
}

VOID
UpdateFpExceptionFlags(
    PCPUDATA cpu
    )
/*++

Routine Description:

    Copies native RISC Fp status bits into the x86 Fp status register.

Arguments:

    cpu - per-thread data

Return Value:

    None

--*/
{
    unsigned int NativeStatus;

    //
    // Get the current native FP status word, then clear it.
    // UNDONE: For speed, consider using native instructions to get and
    //         clear the status bits, rather than waiting for the C runtime
    //         to reformat the bits into the machine-independent format.
    //         This is especially true for _clearfp(), which returns the old
    //         fp status bits (except for those dealing with handled
    //         exceptions - the ones we want to look at).
    //
#ifdef ALPHA
    #define SW_FPCR_STATUS_INVALID          0x00020000
    #define SW_FPCR_STATUS_DIVISION_BY_ZERO 0x00040000
    #define SW_FPCR_STATUS_OVERFLOW         0x00080000
    #define SW_FPCR_STATUS_UNDERFLOW        0x00100000
    #define SW_FPCR_STATUS_INEXACT          0x00200000

    NativeStatus = GetNativeFPStatus();
#else
    #define SW_FPCR_STATUS_INVALID          _SW_INVALID
    #define SW_FPCR_STATUS_DIVISION_BY_ZERO _SW_ZERODIVIDE
    #define SW_FPCR_STATUS_OVERFLOW         _SW_OVERFLOW
    #define SW_FPCR_STATUS_UNDERFLOW        _SW_UNDERFLOW
    #define SW_FPCR_STATUS_INEXACT          _SW_INEXACT

    NativeStatus = _statusfp();
    _clearfp();
#endif

    //
    // Decide what exceptions have happened during the instruction.
    // Exceptions are rare, so assume there are none by testing to see if
    // any exception is pending before checking each individual bit.
    //
    if (NativeStatus & (SW_FPCR_STATUS_INVALID|
                        SW_FPCR_STATUS_DIVISION_BY_ZERO|
                        SW_FPCR_STATUS_OVERFLOW|
#ifndef ALPHA
                        _SW_DENORMAL|
#endif
                        SW_FPCR_STATUS_UNDERFLOW)) {

        DWORD Mask = cpu->FpControlMask;
        DWORD Exceptions = cpu->FpStatusExceptions;

        if (NativeStatus & SW_FPCR_STATUS_INVALID) {
            if (!(Mask & FPCONTROL_IM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_IM; // Invalid instruction
            cpu->FpStatusSF = 0;    // Invalid operand, not stack overflow/underflow
        }

        if (NativeStatus & SW_FPCR_STATUS_DIVISION_BY_ZERO) {
            if (!(Mask & FPCONTROL_ZM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_ZM;
        }

#ifndef ALPHA
        if (NativeStatus & _SW_DENORMAL) {
            if (!(Mask & FPCONTROL_DM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_DM;
        }
#endif

        if (NativeStatus & SW_FPCR_STATUS_OVERFLOW) {
            if (!(Mask & FPCONTROL_OM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_OM;
        }

        if (NativeStatus & SW_FPCR_STATUS_UNDERFLOW) {
            if (!(Mask & FPCONTROL_UM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            Exceptions |= FPCONTROL_UM;
        }

        cpu->FpStatusExceptions = Exceptions;
    }
}


USHORT
GetControlReg(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Control Register from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Control Register.

--*/

{
    USHORT c;

    c = (cpu->FpControlInfinity << 12) |
        (cpu->FpControlRounding << 10) |
        (cpu->FpControlPrecision << 8) |
        (1 << 6) |      // this reserved bit is 1 on 487 chips
        (USHORT)cpu->FpControlMask;

    return c;
}


VOID
SetControlReg(
    PCPUDATA cpu,
    USHORT   NewControl
    )

/*++

Routine Description:

    Sets the FPU Control Register to the specified value.  The native FPU
    is set to match.

Arguments:

    cpu        - per-thread data
    NewControl - new value for the Control Register.

Return Value:

    None.

--*/

{
    INT NewPrecision;

    // Break the Intel Control Word into component parts
    cpu->FpControlMask = NewControl & (FPCONTROL_IM|
                                       FPCONTROL_DM|
                                       FPCONTROL_ZM|
                                       FPCONTROL_OM|
                                       FPCONTROL_UM|
                                       FPCONTROL_PM);

    cpu->FpControlRounding  = (NewControl>>10) & 3;
    cpu->FpControlInfinity =  (NewControl>>12) & 3;

    NewPrecision = (NewControl>>8) & 3;
    if (NewPrecision != cpu->FpControlPrecision) {
        //
        // Modify jump tables for instructions which are sensitive
        // to the floating-point precision.
        //
        ChangeFpPrecision(cpu, NewPrecision);
    }

    // Set the native FPU to the correct rounding mode.  Precision
    // is emulated in software.
    SetNativeRoundingMode(cpu->FpControlRounding);

    // Setting the 487 control word may have masked or unmasked exceptions.
    SetErrorSummary(cpu);
}


USHORT
GetStatusReg(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Status Register from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Status Register.

--*/

{
    USHORT s;

    UpdateFpExceptionFlags(cpu);

    s = (cpu->FpStatusES << 15) |       // The 'B' bit is a mirror of 'ES'
        (cpu->FpStatusC3 << 14) |
        (cpu->FpTop << 11) |
        (cpu->FpStatusC2 << 10) |
        (cpu->FpStatusC1 << 9) |
        (cpu->FpStatusC0 << 8) |
        (cpu->FpStatusES << 7) |
        (cpu->FpStatusSF << 6) |
        (USHORT)cpu->FpStatusExceptions;

    // the PE bit in the status word is hard-wired to 0, so mask it now.
    return s & ~FPCONTROL_PM;
}

VOID
SetStatusReg(
    PCPUDATA cpu,
    USHORT   NewStatus
)

/*++

Routine Description:

    Sets the FPU Status Register to the specified value.

Arguments:

    cpu       - per-thread data
    NewStatus - new value for the Status Register.

Return Value:

    None.

--*/

{
    //
    // Break the Intel Status Word into component parts
    //
    cpu->FpStatusExceptions = NewStatus & (FPCONTROL_IM|
                                           FPCONTROL_DM|
                                           FPCONTROL_ZM|
                                           FPCONTROL_OM|
                                           FPCONTROL_UM);
    cpu->FpStatusSF = (NewStatus >> 6) & 1;
    cpu->FpStatusC0 = (NewStatus >> 8) & 1;
    cpu->FpStatusC1 = (NewStatus >> 9) & 1;
    cpu->FpStatusC2 = (NewStatus >> 10) & 1;
    cpu->FpTop = (NewStatus >> 11) & 7;
    cpu->FpST0 = &cpu->FpStack[cpu->FpTop];
    cpu->FpStatusC3 = (NewStatus >> 14) & 1;

    //
    // ES (and B) are recomputed based on the mask bits in the control word.
    // The caller must do that by calling SetErrorSummary().
    //
}


USHORT
GetTagWord(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Creates the USHORT 487 Tag Word from the current CPU state.

Arguments:

    cpu - per-thread data

Return Value:

    USHORT value of the 487 Tag Word.

--*/

{
    USHORT s;
    INT i;

    s = 0;
    for (i=7; i >= 0; --i) {
        s = (s << 2) | (USHORT)cpu->FpStack[i].Tag;
    }

    return s;
}

VOID
SetTagWord(
    PCPUDATA cpu,
    USHORT s
    )
/*++

Routine Description:

    Given a new Tag Word and the FP stack, recomputes the Tag field for each entry
    in the FP stack.

Arguments:

    cpu - per-thread data
    s   - new Tag word

Return Value:

    None.

--*/
{
    INT i;
    BYTE Tag;

    for(i=0; i < 8; ++i) {
        Tag = (BYTE)(s & 3);
        s >>= 2;

        if (Tag == TAG_EMPTY) {
            cpu->FpStack[i].Tag = TAG_EMPTY;
        } else {
            // Special value - must reclassify into the richer set of tags,
            // or the caller is setting the tags to valid or zero.  We must
            // reclassify them in case the value in the register is not what
            // the caller said it was.
            SetTag(&cpu->FpStack[i]);
        }
    }    
}

VOID GetEnvironment(
    PCPUDATA cpu,
    DWORD *pEnv
    )
/*++

Routine Description:

    Implements the core of FLDENV

Arguments:

    cpu - per-thread data
    pEnv - destination to load FP environment from

Return Value:

    None.

--*/
{
    SetControlReg(cpu, (USHORT)GET_LONG(pEnv));
    SetStatusReg(cpu, (USHORT)GET_LONG(pEnv+1));
    SetErrorSummary(cpu);
    SetTagWord(cpu, (USHORT)GET_LONG(pEnv+2));
    cpu->FpEip = GET_LONG(pEnv+3);
    // ignore CS = GET_LONG(pEnv+4);
    cpu->FpData = (PVOID)GET_LONG(pEnv+5);
    // ignore DS = GET_LONG(pEnv+6);
}


VOID
StoreEnvironment(
    PCPUDATA cpu,
    DWORD *pEnv
    )

/*++

Routine Description:

    Implements the core of FSTENV, FNSTENV

Arguments:

    cpu  - per-thread data
    pEnv - destination to store FP environment to

Return Value:

    None.

--*/

{
    PUT_LONG(pEnv,   (DWORD)GetControlReg(cpu));
    PUT_LONG(pEnv+1, (DWORD)GetStatusReg(cpu));
    PUT_LONG(pEnv+2, (DWORD)GetTagWord(cpu));
    PUT_LONG(pEnv+3, cpu->FpEip);
    //
    // If FpEip is zero, then assume the FPU is uninitialized (ie. app
    // has run FNINIT but no other FP instructions).  In that case, FNINIT
    // is supposed to have set FpCS and FpDS to 0.  We don't want to add
    // the extra overhead of settings FpCS and FpDS on each FP instruction.
    // Instead, we simulate this situation by writing 0 for the selector
    // values.
    //
    //
    if (cpu->FpEip) {
        PUT_LONG(pEnv+4, (DWORD)CS);
        PUT_LONG(pEnv+6, (DWORD)DS);
    } else {
        PUT_LONG(pEnv+4, 0);
        PUT_LONG(pEnv+6, 0);
    }
    PUT_LONG(pEnv+5, (DWORD)(ULONGLONG)cpu->FpData);   

    // Mask all exceptions
    cpu->FpControlMask = FPCONTROL_IM|
                         FPCONTROL_DM|
                         FPCONTROL_ZM|
                         FPCONTROL_OM|
                         FPCONTROL_UM|
                         FPCONTROL_PM;
}


BOOL
HandleStackEmpty(
    PCPUDATA cpu,
    PFPREG FpReg
    )

/*++

Routine Description:

    Handles FP stack underflow errors.  If Invalid Instruction Exceptions
    are masked, writes an INDEFINITE into the register.  Otherwise it records
    a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - reg to set to INDEFINITE if the exception is masked.

Return Value:

    None.

--*/

{
    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusC1 = 0;    // O/U# = 0 = underflow
    cpu->FpStatusSF = 1;    // stack overflow/underflow, not invalid operand

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - handle it by returning INDEFINITE
        SetIndefinite(FpReg);
        return FALSE;
    } else {
        cpu->FpStatusES = 1;
        return TRUE;
    }
}


VOID
HandleStackFull(
    PCPUDATA cpu,
    PFPREG   FpReg
    )

/*++

Routine Description:

    Handles FP stack overflow errors.  If Invalid Instruction Exceptions
    are masked, writes an INDEFINITE into the register.  Otherwise it records
    a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - register which caused the error.

Return Value:

    None.

--*/

{
    CPUASSERT(FpReg->Tag != TAG_EMPTY);

    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusC1 = 1;    // O/U# = 1 = overflow
    cpu->FpStatusSF = 1;    // stack overflow/underflow, not invalid operand

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - handle it by returning INDEFINITE
        SetIndefinite(FpReg);
    } else {
        cpu->FpStatusES = 1;
    }
}


BOOL
HandleInvalidOp(
    PCPUDATA cpu
    )

/*++

Routine Description:

    Called whenever an instruction handles an invalid operation.  If exceptions
    are masked, it is a no-op.  Otherwise it records a pending excption and
    aborts the operation.

Arguments:

    cpu - per-thread data

Return Value:

    BOOL - TRUE if instruction should be aborted due to unmasked exception.

--*/

{
    cpu->FpStatusExceptions |= FPCONTROL_IM;
    cpu->FpStatusSF = 0;    // invalid operand, not stack overflow/underflow

    if (cpu->FpControlMask & FPCONTROL_IM) {
        // Invalid Operation is masked - continue instruction
        return FALSE;
    } else {
        // Unmasked exception - abort instruction
        cpu->FpStatusES = 1;
        return TRUE;
    }
}


BOOL
HandleSnan(
    PCPUDATA cpu,
    PFPREG   FpReg
    )

/*++

Routine Description:

    Handles the case when an SNAN (Signalling NAN) is detected.  If exceptions
    are masked, converts the SNAN to a QNAN with the same mantissa.  Otherwise,
    it records a pending exception and aborts the instruction.

Arguments:

    cpu   - per-thread data
    FpReg - register which caused the error.

Return Value:

    BOOL - TRUE if instruction should be aborted due to unmasked exception.

--*/

{
    BOOL fAbort;

    CPUASSERT(FpReg->Tag == TAG_SPECIAL && FpReg->TagSpecial == TAG_SPECIAL_SNAN);
#if NATIVE_NAN_IS_INTEL_FORMAT
    CPUASSERT((FpReg->rdw[1] & 0x00080000) == 0); // FP value is not a SNAN
#else
    CPUASSERT(FpReg->rdw[1] & 0x00080000);        // FP value is not a SNAN
#endif

    fAbort = HandleInvalidOp(cpu);
    if (!fAbort) {
        // Invalid Operation is masked - handle it by converting to QNAN
        FpReg->rdw[1] ^= 0x00080000; // invert the top bit of the mantissa
        FpReg->TagSpecial = TAG_SPECIAL_QNAN;
    }
    return fAbort;
}



FRAG0(FABS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    switch (ST0->Tag) {
    case TAG_VALID:
    case TAG_ZERO:
        //
        // Clear the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        //
        ST0->rdw[1] &= 0x7fffffff;
        break;

    case TAG_EMPTY:
        if (HandleStackEmpty(cpu, ST0)) {
            break;
        }
        // else fall through to TAG_SPECIAL

    case TAG_SPECIAL:
        //
        // Clear the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        //
        ST0->rdw[1] &= 0x7fffffff;
        if (ST0->TagSpecial == TAG_SPECIAL_INDEF) {
            //
            // INDEFINITE with its sign changed to POSITIVE becomes just a QNAN
            //
            ST0->TagSpecial = TAG_SPECIAL_QNAN;
        }
        break;
    }
}

FRAG0(FCHS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    switch (ST0->Tag) {
    case TAG_VALID:
    case TAG_ZERO:
        // toggle the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        ST0->rdw[1] ^= 0x80000000;
        break;

    case TAG_EMPTY:
        if (HandleStackEmpty(cpu, ST0)) {
            break;
        }
        // else fall through to TAG_SPECIAL

    case TAG_SPECIAL:
        // toggle the sign bit for NANs, VALID, ZERO, INFINITY, etc.
        ST0->rdw[1] ^= 0x80000000;

        if (ST0->TagSpecial == TAG_SPECIAL_INDEF) {

            //
            // INDEFINITE with its sign changed to POSITIVE becomes
            // just a QNAN
            //
            ST0->TagSpecial = TAG_SPECIAL_QNAN;

        } else if (ST0->TagSpecial == TAG_SPECIAL_QNAN &&
                   ST0->rdw[0] == 0 &&
                   ST0->rdw[1] == 0xfff80000) {

            //
            // this particular QNAN becames INDEFINITE
            //
            ST0->TagSpecial = TAG_SPECIAL_INDEF;
        }
        break;
    }

}

FRAG0(FNCLEX)
{
    // NOWAIT flavor, so no preamble
    cpu->FpStatusES = 0;
    cpu->FpStatusExceptions = 0;
}

FRAG0(FDECSTP)
{
    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(cpu->FpST0);
}

FRAG1IMM(FFREE, INT)
{
    FpArithPreamble(cpu);

    CPUASSERT((op1 & 0x07) == op1);
    cpu->FpStack[ST(op1)].Tag = TAG_EMPTY;
}

FRAG0(FINCSTP)
{
    FpArithPreamble(cpu);
    cpu->FpStatusC1 = 0;        // assume no error
    INCFLT;
}

FRAG0(FNINIT)
{
    int i;

    SetControlReg(cpu, 0x37f);
    SetStatusReg(cpu, 0);
    cpu->FpStatusES = 0;
    for (i=0; i<8; ++i) {
        cpu->FpStack[i].Tag = TAG_EMPTY;
    }
    cpu->FpEip = 0;
    cpu->FpData = 0;
}

FRAG1(FLDCW, USHORT*)
{
    FpControlPreamble(cpu);

    SetControlReg(cpu, GET_SHORT(pop1));
}

FRAG1(FLDENV, BYTE)
{
    // Intel instruction set docs don't define the layout for the structure.
    // This code is copied from ntos\dll\i386\emlsenv.asm.
    GetEnvironment(cpu, (DWORD *)pop1);
}

NPXFUNC1(FRNDINT_VALID)
{
    double fraction;

    fraction = modf(Fp->r64, &Fp->r64);
    switch (cpu->FpControlRounding) {
    case 0:     // _RC_NEAR
        if (fraction <= -0.5) {
            // Fp->r64 is negative and the fraction is >= 0.5
            Fp->r64-=1.0;
        } else if (fraction >= 0.5) {
            // Fp->r64 is positive and the fraction is >= 0.5
            Fp->r64+=1.0;
        }
        break;

    case 1:     // _RC_DOWN
        if (fraction < 0.0) {
            // Fp->r64 is negative and there is a fraction.  Round down
            Fp->r64-=1.0;
        }
        break;

    case 2:     // _RC_UP
        if (fraction > 0.0) {
            // Fp->r64 is positive and there is a fraction.  Round up
            Fp->r64+=1.0;
        }
        break;

    case 3:     // _RC_CHOP
        // nothing to do - modf chops
        break;

    default:
        CPUASSERT(FALSE);
    }
    if (Fp->r64 == 0.0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }
}

NPXFUNC1(FRNDINT_ZERO)
{
    // nothing to do - zero is already an integer!
}

NPXFUNC1(FRNDINT_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FRNDINT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
    case TAG_SPECIAL_INFINITY:
        // infinity and NANs are unchanged
        break;
    }
}

NPXFUNC1(FRNDINT_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}


FRAG0(FRNDINT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*FRNDINTTable[ST0->Tag])(cpu, ST0);
}

FRAG1(FRSTOR, BYTE)
{
    INT i;
    PBYTE DataImagePtr = pop1;

    //
    // Load the status register first, so that the ST(i) calculation
    // is correct.
    //
    SetStatusReg(cpu, (USHORT)GET_LONG(pop1+4));

    // Intel instruction set docs don't define the layout for the structure.
    // This code is copied from ntos\dll\i386\emlsenv.asm.
    pop1 += 28;   // move past the Numeric Instruction and Data Pointer image
    for (i=0; i<8; ++i) {
        LoadIntelR10ToR8(cpu, pop1, &cpu->FpStack[ST(i)]);
        pop1+=10;
    }

   //
   // Setting tags requires looking at the R8 values on the FP stack, so do this
   // after loading the FP stack from memory
   // 
   GetEnvironment(cpu, (DWORD *)DataImagePtr);
}

FRAG1(FNSAVE, BYTE)
{
    FpuSaveContext(cpu, pop1);
    FNINIT(cpu);
}

NPXFUNC2(FSCALE_VALID_VALID)
{
    l->r64 = _scalb(l->r64, (long)r->r64);

    //
    // Assume the scaling did not overflow
    //
    SetTag(l);

    if (errno == ERANGE) {
        if (l->r64 == HUGE_VAL) {
            //
            // The scaling overflowed - fix up the result
            //
            l->r64 = R8PositiveInfinity;
            l->Tag = TAG_SPECIAL;
            l->TagSpecial = TAG_SPECIAL_INFINITY;
        } else if (l->r64 == -HUGE_VAL) {
            //
            // The scaling overflowed - fix up the result
            //
            l->r64 = R8NegativeInfinity;
            l->Tag = TAG_SPECIAL;
            l->TagSpecial = TAG_SPECIAL_INFINITY;
        }
    }
}

NPXFUNC2(FSCALE_VALIDORZERO_VALIDORZERO)
{
    // no work to do - either: adding 0 to the exponent
    //                     or: adding nonzero to the exponent on 0
}

NPXFUNC2(FSCALE_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSCALE_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // no change if adjusting the exponent of INFINITY
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, l);
        // fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC2(FSCALE_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSCALE_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (l->Tag != TAG_ZERO) {
            // scaling VALID by INFINITY - return INDEFINITE
            SetIndefinite(l);
        }
        // else scaling ZERO by INFINITY - return ZERO
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, r);
        // fall into TAG_SPECIAL_QNAN:

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC2(FSCALE_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FSCALETable[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FSCALETable[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_INFINITY) {

        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {

            // two infinities - return INDEFINITE
            SetIndefinite(l);

        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // Copy the NAN from r to l, to return it
            l->r64 = r->r64;
            l->TagSpecial = r->TagSpecial;
        }
    } else {

        CPUASSERT(IS_TAG_NAN(l));
        if (r->TagSpecial == TAG_SPECIAL_INFINITY) {
            //
            // l already has the NAN to return
            //
        } else {
            CPUASSERT(IS_TAG_NAN(r));

            //
            // Return the largest of the two NANs
            //
            l->r64 = r->r64 + l->r64;
            SetTag(l);
        }
    }
}

NPXFUNC2(FSCALE_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FSCALETable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FSCALE_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FSCALETable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FSCALE)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    (*FSCALETable[l->Tag][r->Tag])(cpu, l, r);
}

NPXFUNC1(FSQRT_VALID)
{
    if (Fp->rb[7] & 0x80) {
        // value is negative - return INDEFINITE
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(Fp);
        }
    } else {
        Fp->r64 = sqrt(Fp->r64);
        SetTag(Fp);
    }
}

NPXFUNC1(FSQRT_ZERO)
{
    // according to the docs, sqrt(-0.0) is -0.0, so there is nothing to do
}

NPXFUNC1(FSQRT_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSQRT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        if (Fp->rb[7] & 0x80) {
            // negative infinity - invalid op
            SetIndefinite(Fp);
        }
        // else positive infinity, which is preserved
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        break;
    }
}

NPXFUNC1(FSQRT_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
    // nothing else to do
}

FRAG0(FSQRT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*FSQRTTable[ST0->Tag])(cpu, ST0);
}

FRAG1(FNSTCW, USHORT)
{
    // No-wait flavor - no preamble required.
    PUT_SHORT(pop1, GetControlReg(cpu));
}

FRAG1(FNSTENV, BYTE)
{
    // No-wait flavor - no preamble required.

    StoreEnvironment(cpu, (DWORD *)pop1);
}

FRAG1(FNSTSW, USHORT)
{
    // No-wait flavor - no preamble required
    PUT_SHORT(pop1, GetStatusReg(cpu));
}

FRAG0(OPT_FNSTSWAxSahf)
{
    DWORD Status;

    // No-wait flavor - no preamble required
    Status = GetStatusReg(cpu);
    ax = (USHORT)Status;
    SET_CFLAG(Status << (31-8));    // FLAG_CF==1<<0
    SET_PFLAG(!(Status & (FLAG_PF<<8))); // flag_pf contains an index into ParityBit[] array
    SET_AUXFLAG(Status >> 8);       // AUX bit is already in the right place
    SET_ZFLAG(!(Status & (FLAG_ZF<<8))); // zf has inverse logic
    SET_SFLAG(Status << (31-7-8));  // SFLAG is bit 7 in AH
}

FRAG0(FXAM)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    ST0 = cpu->FpST0;

    // C1 = sign bit
    cpu->FpStatusC1 = ST0->rdw[1] >> 31;

    // Set C3, C2, C0 based on the type of the number
    switch (ST0->Tag) {
    case TAG_VALID:
        cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 0;
        break;

    case TAG_ZERO:
        cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 0;
        break;

    case TAG_EMPTY:
        cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 1;
        break;

    case TAG_SPECIAL:
        switch (cpu->FpST0->TagSpecial) {
        case TAG_SPECIAL_DENORM:
            cpu->FpStatusC3 = 1; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 0;
            break;

        case TAG_SPECIAL_SNAN:
        case TAG_SPECIAL_QNAN:
        case TAG_SPECIAL_INDEF:
            cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 0; cpu->FpStatusC0 = 1;
            break;

        case TAG_SPECIAL_INFINITY:
            cpu->FpStatusC3 = 0; cpu->FpStatusC2 = 1; cpu->FpStatusC0 = 1;
            break;
        }
        break;
    }
}

FRAG1IMM(FXCH_STi, INT)
{
    PFPREG pReg;
    PFPREG ST0;
    FPREG Temp;

    FpArithPreamble(cpu);

    CPUASSERT( (op1&0x07)==op1 );

    ST0 = cpu->FpST0;

    if (ST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, ST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    pReg = &cpu->FpStack[ST(op1)];
    if (pReg->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, pReg)) {
            // unmasked exception - abort the instruction
            return;
        }
    }

    Temp.Tag = pReg->Tag;
    Temp.TagSpecial = pReg->TagSpecial;
    Temp.r64 = pReg->r64;
    pReg->Tag = ST0->Tag;
    pReg->TagSpecial = ST0->TagSpecial;
    pReg->r64 = ST0->r64;
    ST0->Tag = Temp.Tag;
    ST0->TagSpecial = Temp.TagSpecial;
    ST0->r64 = Temp.r64;
}

NPXFUNC1(FXTRACT_VALID)
{
    DOUBLE Significand;
    int Exponent;

    Exponent = (int)_logb(Fp->r64);
    Significand = _scalb(Fp->r64, (long)-Exponent);

    //
    // Place the exponent in what will become ST(1)
    //
    Fp->r64 = (DOUBLE)Exponent;
    if (Exponent == 0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }

    //
    // Place the mantissa in ST, with the same sign as the original value
    //
    PUSHFLT(Fp);
    Fp->r64 = Significand;
    if (Significand == 0.0) {
        Fp->Tag = TAG_ZERO;
    } else {
        Fp->Tag = TAG_VALID;
    }
}

NPXFUNC1(FXTRACT_ZERO)
{
    DWORD Sign;

    //
    // ST(1) gets -infinity, ST gets 0 with same sign as the original value
    //
    Sign = Fp->rdw[1] & 0x80000000;
    Fp->r64 = R8NegativeInfinity;
    Fp->Tag = TAG_SPECIAL;
    Fp->TagSpecial = TAG_SPECIAL_INFINITY;
    PUSHFLT(Fp);
    Fp->rdw[0] = 0;
    Fp->rdw[1] = Sign;
    Fp->Tag = TAG_ZERO;

    //
    // Raise the zero-divide exception
    //
    if (!(cpu->FpControlMask & FPCONTROL_ZM)) {
        cpu->FpStatusES = 1;    // Unmasked exception
    }
    cpu->FpStatusExceptions |= FPCONTROL_ZM;
}

NPXFUNC1(FXTRACT_SPECIAL)
{
    DOUBLE Temp;
    FPTAG TempTagSpecial;

    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FXTRACT_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        //
        // According to ntos\dll\i386\emxtract.asm, ST(0) = infinity (same sign)
        // and ST(1) = +infinity
        //
        Temp = Fp->r64;
        Fp->r64 = R8PositiveInfinity;
        CPUASSERT(Fp->Tag == TAG_SPECIAL && Fp->TagSpecial == TAG_SPECIAL_INFINITY);
        PUSHFLT(Fp);
        Fp->r64 = Temp;
        Fp->Tag = TAG_SPECIAL;
        Fp->TagSpecial = TAG_SPECIAL_INFINITY;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, Fp)) {
            return;
        }
        // else fall thru to TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        //
        // Copy the QNAN to both ST(1) and ST
        //
        Temp = Fp->r64;
        TempTagSpecial = Fp->TagSpecial;
        PUSHFLT(Fp);
        Fp->r64 = Temp;
        Fp->Tag = TAG_SPECIAL;
        Fp->TagSpecial = TempTagSpecial;
        break;
    }
}

NPXFUNC1(FXTRACT_EMPTY)
{
    CPUASSERT(FALSE);    // this was taken care of by the real FXTRACT
}

FRAG0(FXTRACT)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;

    //
    // We must take care of this case first, so that the check for ST(7)
    // can occur next, before any other exception handling takes place.
    //
    if (ST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, ST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    (*FXTRACTTable[ST0->Tag])(cpu, ST0);
}

FRAG0(WaitFrag)
{
    FpControlPreamble(cpu);
}

FRAG0(FNOP)
{
    FpArithPreamble(cpu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag16.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag16.h

Abstract:
    
    Prototypes for instruction fragments which operate on 16-bit WORDS.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG16_H
#define FRAG16_H

#define FRAGCOMMON0(fn)     FRAG0( fn ## 16)
#define FRAGCOMMON1(fn)     FRAG1( fn ## 16, USHORT)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16, USHORT)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16, USHORT, USHORT)
#define FRAGCOMMON2(fn)     FRAG2( fn ## 16, USHORT)
#define FRAGCOMMON2REF(fn)  FRAG2REF( fn ## 16, USHORT)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16, USHORT, USHORT, USHORT)
#include "shared.h"
#include "shr1632.h"
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#define FRAGCOMMON0(fn)     FRAG0( fn ## 16A)
#define FRAGCOMMON1(fn)     FRAG1( fn ## 16A, USHORT)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16A, USHORT)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16A, USHORT, USHORT)
#define FRAGCOMMON2(fn)     FRAG2( fn ## 16A, USHORT)
#define FRAGCOMMON2REF(fn)  FRAG2REF( fn ## 16A, USHORT)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16A, USHORT, USHORT, USHORT)
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpuload.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpuload.c

Abstract:

    Floating point load functions

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

VOID GetIntelR4(
    PFPREG Fp,
    FLOAT *pIntelReal
    )
/*++

Routine Description:

    Load an Intel R4 and convert it to a native R4, accounting for
    the difference in how MIPS represents QNAN/SNAN.

    NOTE: This is not in fpufrag.c due to a code-generator bug on PPC -
          irbexpr.c:932 asserts trying to inline this function.  Moving it
          to a different file defeats the inliner.

Arguments:

    Fp         - floating-point register to load the R4 into
    pIntelReal - R4 value to load (in Intel format)
    
Return Value:

    None.

--*/
{
    DWORD d = GET_LONG(pIntelReal);

    if ((d & 0x7f800000) == 0x7f800000) {

        Fp->Tag = TAG_SPECIAL;

        // Found some sort of NAN
        if (d == 0xffc00000) {  // Indefinite

            // Create the native indefinite form
#if NATIVE_NAN_IS_INTEL_FORMAT
            Fp->rdw[0] = 0;
            Fp->rdw[1] = 0xfff80000;
#else
            Fp->rdw[0] = 0xffffffff;
            Fp->rdw[1] = 0x7ff7ffff;
#endif
            Fp->TagSpecial = TAG_SPECIAL_INDEF;

        } else if (d == 0x7f800000) {   // +infinity

            Fp->r64 = R8PositiveInfinity;
            Fp->TagSpecial = TAG_SPECIAL_INFINITY;

        } else if (d == 0xff800000) {   // -infinity

            Fp->r64 = R8NegativeInfinity;
            Fp->TagSpecial = TAG_SPECIAL_INFINITY;

        } else {                // SNAN/QNAN

            DWORD Sign;

            if (d & 0x00400000) {
                //
                // Intel QNAN
                //
                Fp->TagSpecial = TAG_SPECIAL_QNAN;

            } else {
                //
                // Intel SNAN
                //
                Fp->TagSpecial = TAG_SPECIAL_SNAN;
            }

#if !NATIVE_NAN_IS_INTEL_FORMAT
            //
            // Toggle the NAN to native format
            //
            d ^= 0x00400000;
#endif

            //
            // Cast the r4 RISC QNAN to double.  Don't trust the CRT to
            // do the right thing - MIPS converts them both to INDEFINITE.
            //
            Sign = d & 0x80000000;
            d &= 0x007fffff;    // grab the mantissa from the r4 (23 bits)
            Fp->rdw[1] = Sign | 0x7ff00000 | (d >> 3); // store 20 bits of mantissa, plus sign
            Fp->rdw[0] = d << 25;               // store 3 bits of mantissa
        }

    } else { // denormal, zero, or number

        // Coerce it to an R8
        Fp->r64 = (DOUBLE)*(FLOAT *)&d;

        // Compute its tag by looking at the value *after* the conversion,
        // as the native FPU may have normalized the value
        if (Fp->r64 == 0.0) {
            Fp->Tag = TAG_ZERO;
        } else if ((Fp->rdw[1] & 0x7ff00000) == 0) {
            // Exponent is 0 - R8 denormal
            Fp->Tag = TAG_SPECIAL;
            Fp->TagSpecial = TAG_SPECIAL_DENORM;
        } else {
            Fp->Tag = TAG_VALID;
#if DBG
            SetTag(Fp);
            CPUASSERT(Fp->Tag == TAG_VALID);
#endif
        }
    }
}

#if !NATIVE_NAN_IS_INTEL_FORMAT

VOID GetIntelR8(
    PFPREG Fp,
    DOUBLE *pIntelReal
    )
/*++

Routine Description:

    Load an Intel R8 and convert it to a native R8, accounting for
    the difference in how MIPS represents QNAN/SNAN.

Arguments:

    Fp         - floating-point register to load the R8 into
    pIntelReal - R8 value to load (in Intel format)
    
Return Value:

    None.

--*/
{
    //
    // Copy the R8 into the FP register
    //
    Fp->r64 = *(UNALIGNED DOUBLE *)pIntelReal;

    //
    // Compute its tag
    //
    SetTag(Fp);

    //
    // If the value is QNAN/SNAN/INDEF, convert it to native format
    //
    if (IS_TAG_NAN(Fp)) {

        if (Fp->rdw[0] == 0 && Fp->rdw[1] == 0xfff80000) {
            // indefinite - make the R8 into a native indefinite
            Fp->TagSpecial = TAG_SPECIAL_INDEF;
            Fp->rdw[0] = 0xffffffff;
            Fp->rdw[1] = 0x7ff7ffff;
        } else {
            if (Fp->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - QNAN
                Fp->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // top bit of mantissa clear - SNAN
                Fp->TagSpecial = TAG_SPECIAL_SNAN;
            }
            Fp->rdw[1] ^= 0x00080000; // invert the top bit of the mantissa
        }
    }
}

#endif //!NATIVE_NAN_IS_INTEL_FORMAT




VOID
SetTag(
    PFPREG FpReg
    )

/*++

Routine Description:

    Sets the Tag value corresponding to a r64 value in an FP register.
    Assumes the R8 value is in native format (ie. Intel NANs are already
    converted to native NANs).

Arguments:

    FpReg - register to set Tag field in.

Return Value:

    None

--*/

{
    DWORD Exponent;

    /* On average, the value will be zero or a valid real, so those cases
     * have the fastest code paths.  NANs tend to be less frequent and are
     * slower to calculate.
     */
    Exponent = FpReg->rdw[1] & 0x7ff00000;
    if (Exponent == 0x7ff00000) {
        // exponent is all 1's - NAN of some sort

        FpReg->Tag = TAG_SPECIAL;

        if (FpReg->rdw[0] == 0 && (FpReg->rdw[1] & 0x7fffffff) == 0x7ff00000) {
            // Exponent is all 1s, mantissa is all 0s - Infinity
            FpReg->TagSpecial = TAG_SPECIAL_INFINITY;
        } else {

#if NATIVE_NAN_IS_INTEL_FORMAT
            if (FpReg->rdw[0] == 0 && FpReg->rdw[1] == 0xfff80000) {
                // indefinite
                FpReg->TagSpecial = TAG_SPECIAL_INDEF;
            } else if (FpReg->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // Top bit of mantissa clear - but some mantissa bit set - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            }
#else   //!NATIVE_NAN_IS_INTEL_FORMAT
            if (FpReg->rdw[0] == 0xffffffff && FpReg->rdw[1] == 0x7ff7ffff) {
                // indefinite
                FpReg->TagSpecial = TAG_SPECIAL_INDEF;
            } else if (FpReg->rdw[1] & 0x00080000) {
                // top bit of mantissa is set - SNAN
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            } else {
                // top bit of mantissa clear - QNAN
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            }
#endif  //!NATIVE_NAN_IS_INTEL_FORMAT

        }
    } else if (Exponent == 0) {
        // exponent is 0 - DENORMAL or ZERO
        if ((FpReg->rdw[1] & 0x1ffff) == 0 && FpReg->rdw[0] == 0) {
            // mantissa is all zeroes - ZERO
            FpReg->Tag = TAG_ZERO;
        } else {
            FpReg->Tag = TAG_SPECIAL;
            FpReg->TagSpecial = TAG_SPECIAL_DENORM;
        }
    } else {
        // Exponent is not all 1's and not all 0's - a VALID
        FpReg->Tag = TAG_VALID;
    }
}

FRAG1(FILD16, SHORT)    // FILD m16int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        SHORT s;

        s = (SHORT)GET_SHORT(pop1);
        ST0->r64 = (DOUBLE)s;
        if (s) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}

FRAG1(FILD32, LONG)     // FILD m32int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LONG l;

        l = (LONG)GET_LONG(pop1);
        ST0->r64 = (DOUBLE)l;
        if (l) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}

FRAG1(FILD64, LONGLONG) // FILD m64int
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LONGLONG ll;

        ll = *(UNALIGNED LONGLONG *)pop1;
        ST0->r64 = (DOUBLE)ll;
        if (ll) {
            ST0->Tag = TAG_VALID;
        } else {
            ST0->Tag = TAG_ZERO;
        }
    }
}


FRAG1(FLD32, FLOAT)       // FLD m32real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        GetIntelR4(ST0, pop1);
        if (ST0->Tag == TAG_SPECIAL) {
            if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
                if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                    cpu->FpStatusES = 1;    // Unmasked exception
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
                cpu->FpStatusExceptions |= FPCONTROL_DM;
            } else if (ST0->TagSpecial == TAG_SPECIAL_SNAN) {
                if (HandleSnan(cpu, ST0)) {
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
            }
        }
    }
}

FRAG1(FLD64, DOUBLE)      // FLD m64real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        GetIntelR8(ST0, pop1);
        if (ST0->Tag == TAG_SPECIAL) {
            if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
                if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                    cpu->FpStatusES = 1;    // Unmasked exception
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
                cpu->FpStatusExceptions |= FPCONTROL_DM;
            } else if (ST0->TagSpecial == TAG_SPECIAL_SNAN) {
                if (HandleSnan(cpu, ST0)) {
                    //
                    // Instruction needs to be aborted due to unmasked
                    // exception.  We've already hosed ST0, so "correct"
                    // it by popping the FP stack.  Note that
                    // the contents of the register have been lost, which
                    // is a compatibility break with Intel.
                    //
                    POPFLT;
                }
            }
        }
    }
}

FRAG0(FLD1)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 1.0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDL2T)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 2.3025850929940456840E0 / 6.9314718055994530942E-1;  //log2(10) = ln10/ln2
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDL2E)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 1.4426950408889634074E0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDPI)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 3.14159265358979323846;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDLG2)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 6.9314718055994530942E-1 / 2.3025850929940456840E0;
        ST0->Tag = TAG_VALID;
    }
}

FRAG0(FLDLN2)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 6.9314718055994530942E-1;
        ST0->Tag = TAG_VALID;
    }
}


FRAG1IMM(FLD_STi, INT)
{
    PFPREG ST0;
    PFPREG STi;

    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    STi = &cpu->FpStack[ST(op1)];
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = STi->r64;
        ST0->Tag = STi->Tag;
        ST0->TagSpecial = STi->TagSpecial;
    }
}

FRAG0(FLDZ)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        ST0->r64 = 0.0;
        ST0->Tag = TAG_ZERO;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpufrags.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fpufrags.h

Abstract:
    
    Prototypes for floating-point instruction fragments.

Author:

    11-Jul-1995 BarryBo, Created

Revision History:

--*/

FRAG0(FpuInit);
FRAG1(FpuSaveContext, BYTE);

FRAG0(F2XM1);
FRAG0(FABS);
FRAG1(FADD32, FLOAT);      // FADD m32real
FRAG1(FADD64, DOUBLE);     // FADD m64real
FRAG1IMM(FADD_STi_ST, INT); // FADD ST(i), ST = add ST to ST(i)
FRAG1IMM(FADD_ST_STi, INT); // FADD ST, ST(i) = add ST(i) to ST
FRAG1IMM(FADDP_STi_ST, INT); // FADDP ST(i), ST = add ST to ST(i) and pop ST
FRAG1(FIADD16, USHORT);   // FIADD m16int
FRAG1(FIADD32, ULONG);    // FIADD m32int
FRAG1(FBLD, BYTE);
FRAG1(FBSTP, BYTE);
FRAG0(FCHS);
FRAG0(FNCLEX);
FRAG1(FCOM32, FLOAT);  // FCOM m32real
FRAG1(FCOM64, DOUBLE); // FCOM m64real
FRAG1IMM(FCOM_STi, INT); // FCOM ST(i)
FRAG1(FCOMP32, FLOAT); // FCOMP m32real
FRAG1(FCOMP64, DOUBLE); // FCOMP m64real
FRAG1IMM(FCOMP_STi, INT); // FCOMP ST(i)
FRAG0(FCOMPP);
FRAG0(FCOS);
FRAG0(FDECSTP);
FRAG1(FDIV32, FLOAT);  // FDIV m32real
FRAG1(FDIV64, DOUBLE); // FDIV m64real
FRAG1IMM(FDIV_ST_STi, INT); // FDIV ST, ST(i)
FRAG1IMM(FDIV_STi_ST, INT); // FDIV ST(i), ST
FRAG1(FIDIV16, USHORT); // FIDIV m16int
FRAG1(FIDIV32, ULONG);   // FIDIV m32int
FRAG1IMM(FDIVP_STi_ST, INT);    // FDIVP ST(i), ST
FRAG1(FDIVR32, FLOAT);     // FDIVR m32real
FRAG1(FDIVR64, DOUBLE);    // FDIVR m64real
FRAG1IMM(FDIVR_ST_STi, INT); // FDIVR ST, ST(i)
FRAG1IMM(FDIVR_STi_ST, INT); // FDIVR ST(i), ST
FRAG1IMM(FDIVRP_STi_ST, INT); // FDIVRP ST(i)
FRAG1(FIDIVR16, USHORT);  // FIDIVR m16int
FRAG1(FIDIVR32, ULONG);   // FIDIVR m32int
FRAG1IMM(FFREE, INT);
FRAG1(FICOM16, USHORT);   // FICOM m16int (Intel docs say m16real);
FRAG1(FICOM32, ULONG);    // FICOM m32int (Intel docs say m32real);
FRAG1(FICOMP16, USHORT);  // FICOMP m16int
FRAG1(FICOMP32, ULONG);   // FICOMP m32int
FRAG1(FILD16, SHORT);    // FILD m16int
FRAG1(FILD32, LONG);     // FILD m32int
FRAG1(FILD64, LONGLONG); // FILD m64int
FRAG0(FINCSTP);
FRAG0(FNINIT);
FRAG1(FIST16, SHORT);     // FIST m16int
FRAG1(FISTP16, SHORT);    // FISTP m16int
FRAG1(FIST32, LONG);      // FIST m32int
FRAG1(FISTP32, LONG);     // FISTP m32int
FRAG1(FIST64, LONGLONG);  // FIST m64int
FRAG1(FISTP64, LONGLONG); // FISTP m64int
FRAG1(FLD32, FLOAT);       // FLD m32real
FRAG1(FLD64, DOUBLE);      // FLD m64real
FRAG1(FLD80, BYTE);        // FLD m80real
FRAG0(FLD1);
FRAG0(FLDL2T);
FRAG0(FLDL2E);
FRAG0(FLDPI);
FRAG0(FLDLG2);
FRAG0(FLDLN2);
FRAG1IMM(FLD_STi, INT);
FRAG0(FLDZ);
FRAG1(FLDCW, USHORT*);
FRAG1(FLDENV, BYTE);
FRAG1(FMUL32, FLOAT);      // FMUL m32real
FRAG2(FMUL64, DOUBLE);     // FMUL m64real
FRAG1IMM(FMUL_STi_ST, INT); // FMUL ST(i), ST
FRAG1IMM(FMUL_ST_STi, INT); // FMUL ST, ST(i)
FRAG1IMM(FMULP_STi_ST, INT);    // FMULP ST(i), ST
FRAG1(FIMUL16, USHORT);      // FIMUL m16int
FRAG1(FIMUL32, ULONG);       // FIMUL m32int
FRAG0(FPATAN);
FRAG0(FPREM);
FRAG0(FPREM1);
FRAG0(FPTAN);
FRAG0(FRNDINT);
FRAG1(FRSTOR, BYTE);
FRAG1(FNSAVE, BYTE);
FRAG0(FSCALE);
FRAG0(FSIN);
FRAG0(FSINCOS);
FRAG0(FSQRT);
FRAG1(FST32, FLOAT);       // FST m32real
FRAG1(FSTP32, FLOAT);      // FSTP m32real
FRAG1(FST64, DOUBLE);      // FST m64real
FRAG1(FSTP64, DOUBLE);     // FSTP m64real
FRAG1(FSTP80, BYTE);       // FSTP m80real
FRAG1IMM(FST_STi, INT);      // FST ST(i)
FRAG1IMM(FSTP_STi, INT);     // FSTP ST(i)
FRAG0(OPT_FSTP_ST0);     // FSTP ST(0)
FRAG1(FNSTCW, USHORT);
FRAG1(FNSTENV, BYTE);
FRAG1(FNSTSW, USHORT);
FRAG0(OPT_FNSTSWAxSahf);    // FNSTSW AX, SAHF
FRAG1(FSUB32, FLOAT);      // FSUB m32real
FRAG1(FSUBP32, FLOAT);     // FSUBP m32real
FRAG1(FSUB64, DOUBLE);     // FSUB m64real
FRAG1(FSUBP64, DOUBLE);    // FSUBP m64real
FRAG1IMM(FSUB_ST_STi, INT);   // FSUB ST, ST(i)
FRAG1IMM(FSUB_STi_ST, INT);  // FSUB ST(i), ST
FRAG1IMM(FSUBP_STi_ST, INT); // FSUBP ST(i), ST
FRAG1(FISUB16, USHORT);   // FISUB m16int
FRAG1(FISUB32, ULONG);    // FISUB m64int
FRAG1(FSUBR32, FLOAT);     // FSUBR m32real
FRAG1(FSUBR64, DOUBLE);    // FSUBR m64real
FRAG1IMM(FSUBR_ST_STi, INT); // FSUBR ST, ST(i)
FRAG1IMM(FSUBR_STi_ST, INT); // FSUBR ST(i), ST
FRAG1IMM(FSUBRP_STi_ST, INT); // FSUBRP ST(i)
FRAG1(FISUBR16, USHORT);
FRAG1(FISUBR32, ULONG);
FRAG0(FTST);
FRAG1IMM(FUCOM, INT);        // FUCOM ST(i) / FUCOM
FRAG1IMM(FUCOMP, INT);       // FUCOMP ST(i) / FUCOMP
FRAG0(FUCOMPP);
FRAG0(FXAM);
FRAG1IMM(FXCH_STi, INT);
FRAG0(FXTRACT);
FRAG0(FYL2X);
FRAG0(FYL2XP1);
FRAG0(WaitFrag);
FRAG0(FNOP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpur10.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpur10.c

Abstract:

    Floating point 10-byte real support

Author:

    06-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"

ASSERTNAME;

//
// Forward declarations
//
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_VALID);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_ZERO);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_SPECIAL);
NPXLOADINTELR10TOR8(LoadIntelR10ToR8_EMPTY);
NPXPUTINTELR10(PutIntelR10_VALID);
NPXPUTINTELR10(PutIntelR10_ZERO);
NPXPUTINTELR10(PutIntelR10_SPECIAL);
NPXPUTINTELR10(PutIntelR10_EMPTY);

//
// Jump tables
//
const NpxLoadIntelR10ToR8 LoadIntelR10ToR8Table[TAG_MAX] = {
    LoadIntelR10ToR8_VALID,
    LoadIntelR10ToR8_ZERO,
    LoadIntelR10ToR8_SPECIAL,
    LoadIntelR10ToR8_EMPTY
};
const NpxPutIntelR10 PutIntelR10Table[TAG_MAX] = {
    PutIntelR10_VALID,
    PutIntelR10_ZERO,
    PutIntelR10_SPECIAL,
    PutIntelR10_EMPTY
};


VOID
ComputeR10Tag(
    USHORT *r10,
    PFPREG FpReg
    )

/*++

Routine Description:

    Computes the TAG value for an R10, classifying it so conversion to R8
    is simpler.

Arguments:

    r10 - pointer to R10 value to classify.
    FpReg - OUT FP register to set Tag and TagSpecial fields in

Return Value:

    Tag value which classifies the R10.

--*/

{
    USHORT Exponent;

    /* On average, the value will be zero or a valid real, so those cases
     * have the fastest code paths.  NANs tend to be less frequent and are
     * slower to calculate.
     */
    Exponent = r10[4] & 0x7fff;
    if (Exponent == 0x7fff) {

        // exponent is all 1's - NAN or INFINITY of some sort
        FpReg->Tag = TAG_SPECIAL;

        if (r10[0] == 0 && r10[1] == 0 && r10[2] == 0) {
            // Low 6 bytes of mantissa are 0.

            if (r10[3] & 0x4000) {
                // 2nd bit of mantissa set - INDEF or QNAN
                if (r10[3] == 0xc000 && r10[4] == 0xffff) {
                    // INDEF - negative and only top 2 bits of mantissa set
                    FpReg->TagSpecial = TAG_SPECIAL_INDEF;
                } else {
                    // QNAN - positive or more than 2 top bits set
                    FpReg->TagSpecial = TAG_SPECIAL_QNAN;
                }
            } else if (r10[3] & 0x3fff) {
                // SNAN - Only top 1 bit of mantissa is set
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            } else {
                FpReg->TagSpecial = TAG_SPECIAL_INFINITY;
            }
        } else {
            // Some bit is set in the low 6 bytes - SNAN or QNAN
            if (r10[3] & 0x4000) {
                // QNAN - Top 2 bits of mantissa set
                FpReg->TagSpecial = TAG_SPECIAL_QNAN;
            } else {
                // SNAN - 2nd bit of mantissa clear
                FpReg->TagSpecial = TAG_SPECIAL_SNAN;
            }
        }
    } else if (Exponent == 0) {
        // exponent is 0 - DENORMAL or ZERO
        if (r10[0] == 0 && r10[1] == 0 && r10[2] == 0 && r10[3] == 0) {
            // mantissa is all zeroes - ZERO
            FpReg->Tag = TAG_ZERO;
        } else {
            FpReg->Tag = TAG_SPECIAL;
            FpReg->TagSpecial = TAG_SPECIAL_DENORM;
        }
    } else {
        // Exponent is not all 1's and not all 0's - a VALID
        FpReg->Tag = TAG_VALID;
    }
}

VOID
ChopR10ToR8(
    PBYTE r10,
    PFPREG FpReg,
    USHORT R10Exponent
)

/*++

Routine Description:

    Chops a 10-byte real to fit into an FPREG's r64 field.  The FPREG's Tag
    value is not set.

Arguments:

    r10     - 10-byte real to load
    FpReg   - Destination FP register
    R10Exponent - Biased exponent from the R10 value

Return Value:

    None

--*/

{
    short Exponent;
    PBYTE r8 = (PBYTE)&FpReg->r64;

    if (FpReg->Tag == TAG_SPECIAL && FpReg->TagSpecial != TAG_SPECIAL_DENORM) {

        //
        // The caller must handle all other special values itself.
        //
        CPUASSERT(FpReg->TagSpecial == TAG_SPECIAL_QNAN || FpReg->TagSpecial == TAG_SPECIAL_SNAN);

        //
        // The R10 is a QNAN or an SNAN - ignore its exponent (fifteen 1's)
        // and set Exponent to be the correct number of 1 bits for an R8
        // (11 ones, in the correct location within a SHORT)
        //
        Exponent = (short)0x7ff0;

    } else {

        //
        // The R10 is a valid number.  Convert the R10 exponent to an
        // R8 exponent by changing the bias.
        //
        Exponent = (short)R10Exponent - 16383;
        if (Exponent < -1022) {
            //
            // Exponent is too small - silently convert the R10 to an
            // R8 +/-DBL_MIN
            //
            if (r8[7] & 0x80) {
                FpReg->r64 = -DBL_MIN;
            } else {
                FpReg->r64 = DBL_MIN;
            }
            return;
        } else if (Exponent > 1023) {
            //
            // Exponent is too big - silently convert the R10 to an
            // R8 +/-DBL_MAX
            //
            if (r8[7] & 0x80) {
                FpReg->r64 = -DBL_MAX;
            } else {
                FpReg->r64 = DBL_MAX;
            }
            return;
        }

        //
        // Bias the exponent and shift it to the correct location for an R8
        //
        Exponent = ((USHORT)(Exponent + 1023) & 0x7ff) << 4;
    }

    // Copy in the top 7 bits of the exponent along with the sign bit
    r8[7] = (r10[9] & 0x80) | ((USHORT)Exponent >> 8);

    // Copy in the remaining 4 bits of the exponent, along with bits 1-4 of
    // the R10's mantissa (bit 0 is always 1 in R10s).
    r8[6] = (Exponent & 0xf0) | ((r10[7] >> 3) & 0x0f);

    // Copy bits 6-13 from the R10's mantissa
    r8[5] = (r10[7] << 5) | ((r10[6] >> 3) & 0x1f); // bits 5-12 from the R10
    r8[4] = (r10[6] << 5) | ((r10[5] >> 3) & 0x1f); // bits 14-20 from the R10
    r8[3] = (r10[5] << 5) | ((r10[4] >> 3) & 0x1f); // bits 21-28 from the R10
    r8[2] = (r10[4] << 5) | ((r10[3] >> 3) & 0x1f); // bits 29-36 from the R10
    r8[1] = (r10[3] << 5) | ((r10[2] >> 3) & 0x1f); // bits 37-44 from the R10
    r8[0] = (r10[2] << 5) | ((r10[1] >> 3) & 0x1f); // bits 45-52 from the R10
    //
    // Bits 53-64 from the R10 are ignored.  The caller may examine them
    // and round the resulting R8 accordingly.
    //
}

VOID
NextValue(
    PFPREG Fp,
    BOOLEAN RoundingUp
    )
/*++

Routine Description:

    Replaces a floating-point value with either its higher- or lower-
    valued neighbour.

Arguments:

    Fp          - floating-point value to adjust (tag must be set to one of:
                  TAG_VALID, TAG_ZERO or TAG_SPECIAL/TAG_SPECIAL_DENORM)
    RoundingUp  - TRUE if the next value is to be the higher-valued neighbour.
                  FALSE to return the lower-valued neighbour.

Return Value:

    None.  Value in FP and the Tag may have changed.

--*/
{
    DWORD OldExp;
    DWORD NewExp;
    DWORD Sign;


    if (Fp->Tag == TAG_ZERO) {
        //
        // Neighbour of 0.0 is +/- DBL_MIN.
        //
        Fp->Tag = TAG_VALID;
        if (RoundingUp) {
            Fp->r64 = DBL_MIN;
        } else {
            Fp->r64 = -DBL_MIN;
        }

        return;
    }

    //
    // Remember the original sign and exponent
    //
    Sign =   Fp->rdw[1] & 0x80000000;
    OldExp = Fp->rdw[1] & 0x7ff00000;

    //
    // Treat x as a 64-bit integer then add or subtract 1.
    //
    if ((Sign && RoundingUp) || (!Sign && !RoundingUp)) {
        //
        // x is negative.  Subtract 1.
        //
        Fp->rdw[0]--;
        if (Fp->rdw[0] == 0xffffffff) {
            //
            // need to borrow from the high dword
            //
            Fp->rdw[1]--;
        }
    } else {
        //
        // x is positive.  Add 1.
        //
        Fp->rdw[0]++;
        if (Fp->rdw[0] == 0) {
            //
            // propagate carry to the high dword
            //
            Fp->rdw[1]++;
        }
    }

    //
    // Get the new value of the exponent
    //
    NewExp = Fp->rdw[1] & 0x7ff00000;

    if (NewExp != OldExp) {
        //
        // A borrow or a carry caused the exponent to change.
        //
        if (NewExp == 0x7ff00000) {
            //
            // Got an overflow.  Return the largest double value.
            //
            Fp->Tag = TAG_VALID;
            if (Sign) {
                Fp->r64 = -DBL_MAX;
            } else {
                Fp->r64 = DBL_MAX;
            }
        } else if (OldExp && !NewExp) {
            //
            // The original value was a normal number, but the result is a
            // denormal.  Convert the underflow to a 0 with the correct sign.
            //
            Fp->Tag = TAG_ZERO;
            Fp->rdw[0] = 0;
            Fp->rdw[1] = Sign;
        }
    }
}



NPXLOADINTELR10TOR8(LoadIntelR10ToR8_VALID)
{
    USHORT R10Exponent = (*(USHORT *)&r10[8]) & 0x7fff;

    // Copy the value in, chopping exponent and mantissa to fit
    ChopR10ToR8(r10, Fp, R10Exponent);

    if (r10[0] != 0 || (r10[1]&0x7) != 0) {
        // The value can't fit without rounding.  DO NOT REPORT THIS
        // AS AN OVERFLOW EXCEPTION - THIS ONLY OCCURS BECAUSE THE
        // FPU EMULATOR IS USING R8 ARITHMETIC INTERNALLY.  Because of
        // this, the roundoff should be performed silently.  The default
        // behavior when a masked overflow exception is performed is to
        // store +/-infinity.  We don't want hand-coded R10's loading as
        // infinity as many instructions thow Invalid Operation exceptions
        // when they detect an infinity.

        switch (cpu->FpControlRounding) {
        case 0:     // round to nearest or even
            {
                FPREG a, c;
                double ba, cb;

                a = *Fp;
                NextValue(&a, FALSE);   // a is lower neighbour
                // b = Fp->r64.
                c = *Fp;
                NextValue(&c, TRUE);    // c is higher neighbour
                ba = Fp->r64 - a.r64;
                cb = c.r64 - Fp->r64;

                if (ba == cb) {
                    // a and c are equally close to b - select the even
                    // number (LSB==0)
                    if ( ((*(PBYTE)&a) & 1) == 0) {
                        *Fp = a;
                    } else {
                        *Fp = c;
                    }
                } else if (ba < cb) {
                    // a is closer to b than c is.  Choose a
                    *Fp = a;
                } else {
                    // c is closer to b than a is.  Choose c
                    *Fp = c;
                }
            }
            break;

        case 1:     // round down (towards -infinity)
            NextValue(Fp, FALSE);
            break;

        case 2:     // round up (towards +infinity)
            NextValue(Fp, TRUE);
            break;

        case 3:     // chop (truncate toward zero)
            if (Fp->rdw[0] == 0 && (Fp->rdw[1] & 0x7fffffff) == 0) {
                //
                // Truncated value is 0.0.  Reclassify.
                //
                Fp->Tag = TAG_ZERO;
            }
            break;
        }
    }
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_ZERO)
{
    // write in zeroes
    Fp->r64 = 0.0;

    // copy in the sign bit
    Fp->rb[7] = r10[9] & 0x80;
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_INFINITY:
        Fp->rdw[0] = 0;          // low 32 bits of mantissa are zero
        Fp->rdw[1] = 0x7ff00000; // mantissa=0, exponent=1s
        Fp->rb[7] |= r10[9] & 0x80; // copy in the sign bit
        break;

    case TAG_SPECIAL_INDEF:
#if NATIVE_NAN_IS_INTEL_FORMAT
        Fp->rdw[0] = 0;
        Fp->rdw[1] = 0xfff80000;
#else
        Fp->rdw[0] = 0xffffffff;
        Fp->rdw[1] = 0x7ff7ffff;
#endif
        break;

    case TAG_SPECIAL_SNAN:
    case TAG_SPECIAL_QNAN:
        ChopR10ToR8(r10, Fp, (USHORT)((*(USHORT *)&r10[8]) & 0x7fff));
#if !NATIVE_NAN_IS_INTEL_FORMAT
        Fp->rb[6] ^= 0x08; // invert the top bit of the mantissa
#endif
        break;

    case TAG_SPECIAL_DENORM:
        LoadIntelR10ToR8_VALID(cpu, r10, Fp);
        break;
    }
}

NPXLOADINTELR10TOR8(LoadIntelR10ToR8_EMPTY)
{
    CPUASSERT(FALSE);
}

VOID
LoadIntelR10ToR8(
    PCPUDATA cpu,
    PBYTE r10,
    PFPREG FpReg
)

/*++

Routine Description:

    Converts an Intel 10-byte real to an FPREG (Tag and 64-byte real).

    According to emload.asm, this is not an arithmetic operation,
    so SNANs do not throw exceptions.

Arguments:

    cpu     - per-thread data
    r10     - 10-byte real to load
    FpReg   - destination FP register.

Return Value:

    None

--*/

{
    // Classify the R10 and store its tag into the FP register
    ComputeR10Tag( (USHORT*)r10, FpReg );

    // Perform the coersion based on the classification
    (*LoadIntelR10ToR8Table[FpReg->Tag])(cpu, r10, FpReg);
}


FRAG1(FLD80, BYTE)        // FLD m80real
{
    PFPREG ST0;
    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    PUSHFLT(ST0);
    if (ST0->Tag != TAG_EMPTY) {
        HandleStackFull(cpu, ST0);
    } else {
        LoadIntelR10ToR8(cpu, pop1, ST0);
        if (ST0->Tag == TAG_SPECIAL && ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            if (!(cpu->FpControlMask & FPCONTROL_DM)) {
                cpu->FpStatusES = 1;    // Unmasked exception
            }
            cpu->FpStatusExceptions |= FPCONTROL_DM;
        }
    }
}


NPXPUTINTELR10(PutIntelR10_VALID)
{
    USHORT Exponent;
    FPREG  FpReg;

    //
    // Ugly compatibility hack here.  If the app sets the Tag word so all
    // registers are VALID, but the registers actually contain ZERO, detect
    // and correct that so we write the correct value back to memory.
    //
    FpReg.r64 = Fp->r64;
    SetTag(&FpReg);
    if (FpReg.Tag != TAG_VALID &&
        !(FpReg.Tag == TAG_SPECIAL && FpReg.TagSpecial == TAG_SPECIAL_DENORM)) {
        //
        // The app lied to us.  The tag word does not match the value in the
        // tag field.  Write the value according to its actual tag, not
        // according to the tag the app tried to foist on us.
        //
        PutIntelR10(r10, &FpReg);
        return;
    }

    // Grab the 11-bit SIGNED exponent and sign-extend it to 15 bits
    Exponent = (short)((FpReg.rdw[1] >> 20) & 0x7ff) - 1023 + 16383;

    // Drop in the sign bit
    if (FpReg.rb[7] >= 0x80) {
        Exponent |= 0x8000;
    }

    // Write the sign and exponent into the r10
    r10[9] = (Exponent >> 8) & 0xff;
    r10[8] = Exponent & 0xff;

    // Bit 0 of the mantissa is always 1 for R10 values, so write that
    // in, along with the first 7 bits of the FpReg.rb mantissa.
    r10[7] = 0x80 | ((FpReg.rb[6] & 0x0f) << 3) | (FpReg.rb[5] >> 5);

    // Copy in the remaining bits of the FpReg.rb mantissa
    r10[6] = (FpReg.rb[5] << 3) | (FpReg.rb[4] >> 5); // copy bits 7-14 from the FpReg.rb
    r10[5] = (FpReg.rb[4] << 3) | (FpReg.rb[3] >> 5); // copy bits 15-22
    r10[4] = (FpReg.rb[3] << 3) | (FpReg.rb[2] >> 5); // copy bits 23-30
    r10[3] = (FpReg.rb[2] << 3) | (FpReg.rb[1] >> 5); // copy bits 31-38
    r10[2] = (FpReg.rb[1] << 3) | (FpReg.rb[0] >> 5); // copy bits 39-46
    r10[1] = FpReg.rb[0] << 3; // copy bits 46-52, then fill the remaining bits
    r10[0] = 0;          // of the R10 mantissa with 0s
}

NPXPUTINTELR10(PutIntelR10_ZERO)
{
    r10[9] = Fp->rb[7];     // copy in sign plus 7 bits of exponent
    memset(r10, 0, 9);      // remainder is all zeroes
}

NPXPUTINTELR10(PutIntelR10_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_INDEF:
        r10[9] = 0xff;          // sign=1, exponent = 7 1s
        r10[8] = 0xff;          // exponent = 8 1s
        r10[7] = 0xc0;          // mantissa = 1100.00
        memset(r10, 0, 7);      // store rest of mantissa
        break;

    case TAG_SPECIAL_INFINITY:
        r10[9] = Fp->rb[7];         // copy in sign plus 7 bits of exponent
        r10[8] = 0xff;          // remainder of exponent is all 1s
        r10[7] = 0x80;          // top bit of mantissa is 1, rest is 0s
        memset(r10, 0, 7);      // remainder is all zeroes
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN:
        r10[9] = Fp->rb[7];         // copy in sign plus 7 1 bits of exponent
        r10[8] = 0xff;          // remainder of exponent is all 1s
        // Bit 0 of the mantissa is always 1 for R10 values, so write that
        // in, along with the first 7 bits of the R8 mantissa.
        r10[7] = 0x80 | ((Fp->rb[6] & 0x0f) << 3) | (Fp->rb[5] >> 5);
#if !NATIVE_NAN_IS_INTEL_FORMAT
        r10[7] ^= 0x40;         // switch the meaning of the NAN
#endif
        r10[6] = (Fp->rb[5] << 3) | (Fp->rb[4] >> 5); // copy bits 7-14 from the R8
        r10[5] = (Fp->rb[4] << 3) | (Fp->rb[3] >> 5); // copy bits 15-22
        r10[4] = (Fp->rb[3] << 3) | (Fp->rb[2] >> 5); // copy bits 23-30
        r10[3] = (Fp->rb[2] << 3) | (Fp->rb[1] >> 5); // copy bits 31-38
        r10[2] = (Fp->rb[1] << 3) | (Fp->rb[0] >> 5); // copy bits 39-46
        r10[1] = Fp->rb[0] << 3; // copy bits 46-52, then fill the remaining bits
        r10[0] = 0;          // of the R10 mantissa with 0s
        break;

    default:
        CPUASSERT(FALSE);        // fall through in free builds

    case TAG_SPECIAL_DENORM:
        PutIntelR10_VALID(r10, Fp);
        break;
    }
}

NPXPUTINTELR10(PutIntelR10_EMPTY)
{
    CPUASSERT(FALSE);    // Callers must handle TAG_EMPTY on their own.
}

FRAG1(FSTP80, BYTE)       // FSTP m80real
{
    PFPREG ST0;

    FpArithDataPreamble(cpu, pop1);

    cpu->FpStatusC1 = 0;        // assume no error
    ST0 = cpu->FpST0;
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }
    PutIntelR10(pop1, ST0);
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fpustore.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fpustore.c

Abstract:

    Floating point store functions

Author:

    04-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"
#include "fpuarith.h"

ASSERTNAME;

//
// Forward declarations
//

__int64 CastDoubleToInt64(double d);    // in alpha\fphelp.s


#if !NATIVE_NAN_IS_INTEL_FORMAT

//
// Forward declarations
//
NPXPUTINTELR4(PutIntelR4_VALID);
NPXPUTINTELR4(PutIntelR4_ZERO);
NPXPUTINTELR4(PutIntelR4_SPECIAL);
NPXPUTINTELR4(PutIntelR4_EMPTY);
NPXPUTINTELR8(PutIntelR8_VALID);
NPXPUTINTELR8(PutIntelR8_ZERO);
NPXPUTINTELR8(PutIntelR8_SPECIAL);
NPXPUTINTELR8(PutIntelR8_EMPTY);

//
// Jump tables
//
const NpxPutIntelR4 PutIntelR4Table[TAG_MAX] = {
    PutIntelR4_VALID,
    PutIntelR4_ZERO,
    PutIntelR4_SPECIAL,
    PutIntelR4_EMPTY
    };

const NpxPutIntelR8 PutIntelR8Table[TAG_MAX] = {
    PutIntelR8_VALID,
    PutIntelR8_ZERO,
    PutIntelR8_SPECIAL,
    PutIntelR8_EMPTY
    };



NPXPUTINTELR4(PutIntelR4_VALID)
{
    FLOAT f = (FLOAT)Fp->r64;
    PUT_LONG(pIntelReal, *(DWORD *)&f);
}

NPXPUTINTELR4(PutIntelR4_ZERO)
{
    //
    // This cannot simply write a constant 0.0 to memory as it must
    // copy the correct sign from the 0.0 in the FP register.
    //
    PUT_LONG(pIntelReal, Fp->rdw[1]);
}

NPXPUTINTELR4(PutIntelR4_SPECIAL)
{
    switch (Fp->TagSpecial) {
    default:
        CPUASSERT(FALSE);    // unknown tag - fall into TAG_INDEF

    case TAG_SPECIAL_INFINITY:
    case TAG_SPECIAL_DENORM:
        PutIntelR4_VALID(pIntelReal, Fp);
        break;

    case TAG_SPECIAL_INDEF:
        // Write out the R4 indefinite bit pattern
        PUT_LONG(pIntelReal, 0xffc00000);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN: {
        DWORD d[2];
        FLOAT f;
        //
        // Truncate the R8 to an R4, and toggle the top bit of the mantissa
        // to form an Intel QNAN/SNAN (which is different than a native
        // QNAN/SNAN).
        //
        d[0] = Fp->rdw[0];
        d[1] = Fp->rdw[1] ^ 0x00400000;
        f = *(FLOAT *)d;
        PUT_LONG(pIntelReal, *(DWORD *)&f);
        }
        break;
    }
}

NPXPUTINTELR4(PutIntelR4_EMPTY)
{
    //
    // It is assumed that callers of PutIntelR4() have already handled
    // TAG_EMPTY by raising an exception or converting it to TAG_INDEF.
    //
    CPUASSERT(FALSE);
}



NPXPUTINTELR8(PutIntelR8_VALID)
{
    *(UNALIGNED DOUBLE *)pIntelReal = Fp->r64;
}

NPXPUTINTELR8(PutIntelR8_ZERO)
{
    //
    // This cannot simply write a constant 0.0 to memory as it must
    // copy the correct sign from the 0.0 in the FP register.
    //
    *(UNALIGNED DOUBLE *)pIntelReal = Fp->r64;
}

NPXPUTINTELR8(PutIntelR8_SPECIAL)
{
    DWORD *pdw = (DWORD *)pIntelReal;

    switch (Fp->TagSpecial) {
    default:
        CPUASSERT(FALSE);    // unknown tag - fall into TAG_INDEF

    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        // Both can be done as a simple R8-toR8 copy
        PutIntelR8_VALID(pIntelReal, Fp);
        break;

    case TAG_SPECIAL_INDEF:
        // Write out an Intel Indefinite
        PUT_LONG(pdw, 0);
        PUT_LONG((pdw+1), 0xfff80000);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_SNAN:
        //
        // Toggle the top bit of the mantissa to form an Intel QNAN/SNAN
        // (which is different than a native QNAN/SNAN).
        //
        PUT_LONG(pdw, Fp->rdw[0]);
        PUT_LONG((pdw+1), Fp->rdw[1] ^ 0x00080000);
        break;
    }
}

NPXPUTINTELR8(PutIntelR8_EMPTY)
{
    //
    // It is assumed that callers of PutIntelR8() have already handled
    // TAG_EMPTY by raising an exception or converting it to TAG_INDEF.
    //
    CPUASSERT(FALSE);
}

#endif //!NATIVE_NAN_IS_INTEL_FORMAT



FRAG1(FIST16, SHORT)     // FIST m16int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    SHORT i16;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        //
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x8000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_SHORT(pop1, 0x8000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i16 = (SHORT)i64;
            if ((__int64)i16 != i64) {
                goto IntOverflow;
            }
            PUT_SHORT(pop1, i16);
        }
        break;

    case TAG_ZERO:
        PUT_SHORT(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_SHORT(pop1, (SHORT)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x8000
            PUT_SHORT(pop1, 0x8000);
        }
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_SHORT(pop1, 0x8000);
        }
        break;
    }
}

FRAG1(FISTP16, SHORT)    // FISTP m16int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    SHORT i16;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x8000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_SHORT(pop1, 0x8000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i16 = (SHORT)i64;
            if ((__int64)i16 != i64) {
                goto IntOverflow;
            }
            PUT_SHORT(pop1, i16);
        }
        POPFLT;
        break;

    case TAG_ZERO:
        PUT_SHORT(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_SHORT(pop1, (SHORT)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x8000
            PUT_SHORT(pop1, 0x8000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_SHORT(pop1, 0x8000);
            POPFLT;
        }
        break;
    }
}


FRAG1(FIST32, LONG)      // FIST m32int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    LONG i32;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x80000000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_LONG(pop1, 0x80000000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i32 = (LONG)i64;
            if ((__int64)i32 != i64) {
                goto IntOverflow;
            }
            PUT_LONG(pop1, i32);
        }
        break;

    case TAG_ZERO:
        PUT_LONG(pop1, 0);
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_LONG(pop1, (LONG)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pop1, 0x80000000);
        }
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_LONG(pop1, 0x80000000);
            POPFLT;
        }
        break;
    }
}

FRAG1(FISTP32, LONG)     // FISTP m32int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;
    LONG i32;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64
            // Raise I exception on overflow, or write 0x80000000 for masked
            // exception.
            //
IntOverflow:
            if (HandleInvalidOp(cpu)) {
                return;
            }
            PUT_LONG(pop1, 0x80000000);
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
            i32 = (LONG)i64;
            if ((__int64)i32 != i64) {
                goto IntOverflow;
            }
            PUT_LONG(pop1, i32);
        }
        POPFLT;
        break;

    case TAG_ZERO:
        PUT_LONG(pop1, 0);
        POPFLT;
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            PUT_LONG(pop1, (LONG)i64);
        } else if (!HandleInvalidOp(cpu)) {
            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pop1, 0x80000000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            PUT_LONG(pop1, 0x80000000);
            POPFLT;
        }
        break;
    }
}


FRAG1(FISTP64, LONGLONG) // FISTP m64int
{
    PFPREG ST0 = cpu->FpST0;
    __int64 i64;
    int Exponent;

    FpArithDataPreamble(cpu, pop1);

    switch (ST0->Tag) {
    case TAG_VALID:
        Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
        if (Exponent >= 64) {
            //
            // Exponent is too big - this cannot be converted to an __int64,
            // Raise I exception on overflow, or write 0x800...0 for masked
            // exception
            //
            if (HandleInvalidOp(cpu)) {
                return;
            }
            i64 = (__int64)0x8000000000000000i64;
        } else {
            i64 = CastDoubleToInt64(ST0->r64);
        }
        *(UNALIGNED LONGLONG *)pop1 = (LONGLONG)i64;
        POPFLT;
        break;

    case TAG_ZERO:
        *(UNALIGNED LONGLONG *)pop1 = 0;
        POPFLT;
        break;

    case TAG_SPECIAL:
        if (ST0->TagSpecial == TAG_SPECIAL_DENORM) {
            i64 = CastDoubleToInt64(ST0->r64);
            *(UNALIGNED LONGLONG *)pop1 = (LONGLONG)i64;
        } else if (!HandleInvalidOp(cpu)) {
            DWORD *pdw = (DWORD *)pop1;

            // INFINITY and NANs are all invalid operations, and the masked
            // behavior is to write 0x80000000
            PUT_LONG(pdw,   0x00000000);
            PUT_LONG((pdw+1), 0x80000000);
        }
        POPFLT;
        break;

    case TAG_EMPTY:
        if (!HandleStackEmpty(cpu, ST0)) {
            DWORD *pdw = (DWORD *)pop1;

            PUT_LONG(pdw,   0x00000000);
            PUT_LONG((pdw+1), 0x80000000);
            POPFLT;
        }
        break;
    }
}

FRAG1(FST32, FLOAT)       // FST m32real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR4(pop1, cpu->FpST0);
}

FRAG1(FSTP32, FLOAT)      // FSTP m32real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR4(pop1, cpu->FpST0);
    POPFLT;
}

FRAG1(FST64, DOUBLE)      // FST m64real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR8(pop1, cpu->FpST0);
}

FRAG1(FSTP64, DOUBLE)     // FSTP m64real
{
    FpArithDataPreamble(cpu, pop1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    PutIntelR8(pop1, cpu->FpST0);
    POPFLT;
}

FRAG1IMM(FST_STi, INT)      // FST ST(i)
{
    FpArithPreamble(cpu);

    CPUASSERT( (op1 & 0x07) == op1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    cpu->FpStack[ST(op1)] = *cpu->FpST0;
}

FRAG1IMM(FSTP_STi, INT)     // FSTP ST(i)
{
    FpArithPreamble(cpu);

    CPUASSERT( (op1 & 0x07) == op1);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    //CONSIDER: According to TimP, FSTP ST(0) is commonly used to pop the
    //          stack.  It may be worthwhile to test if op1==0 and skip the
    //          assignment and go right to the POPFLT.
    cpu->FpStack[ST(op1)] = *cpu->FpST0;
    POPFLT;
}

FRAG0(OPT_FSTP_ST0)     // FSTP ST(0)
{
    FpArithPreamble(cpu);

    if (cpu->FpST0->Tag == TAG_EMPTY) {
        if (HandleStackEmpty(cpu, cpu->FpST0)) {
            // unmasked exception - abort the instruction
            return;
        }
    }
    POPFLT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag16.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag16.c

Abstract:
    
    Instuction fragments which operate on 16-bit WORDS

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag16.h"

// set up to include common functions
#define MSB		    0x8000
#define LMB                 15  // Left Most Bit
#define UTYPE		    unsigned short
#define STYPE		    signed short
#define GET_VAL 	    GET_SHORT
#define PUT_VAL 	    PUT_SHORT
#define PUSH_VAL	    PUSH_SHORT
#define POP_VAL 	    POP_SHORT
#define FRAGCOMMON0(fn)     FRAG0(fn ## 16)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 16,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 16, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 16, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16, UTYPE, UTYPE, UTYPE)
#define AREG                ax
#define BREG		    bx
#define CREG		    cx
#define DREG		    dx
#define SPREG		    sp
#define BPREG		    bp
#define SIREG		    si
#define DIREG		    di
#define SET_FLAGS_ADD       SET_FLAGS_ADD16
#define SET_FLAGS_SUB       SET_FLAGS_SUB16
#define SET_FLAGS_INC       SET_FLAGS_INC16
#define SET_FLAGS_DEC       SET_FLAGS_DEC16
#define GET_BYTE(addr)      (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)     (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)      (*(UNALIGNED unsigned long *)(addr))

#undef PUT_BYTE
#undef PUT_SHORT
#undef PUT_LONG

#define PUT_BYTE(addr,dw)   {GET_BYTE(addr)=(unsigned char)dw;}
#define PUT_SHORT(addr,dw)  {GET_SHORT(addr)=(unsigned short)dw;}
#define PUT_LONG(addr,dw)   {GET_LONG(addr)=(unsigned long)dw;}

// include the common functions with 8/16/32 flavors, with no alignment issues
#include "shared.c"

// include the common functions with 16/32 flavors, with no alignment issues
#include "shr1632.c"

// include the common unaligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common unaligned functions with 16/32 flavors
#include "shr1632a.c"

#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG

#if MSCPU
#define FRAGCOMMON0(fn)     FRAG0(fn ## 16A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 16A,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 16A, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 16A, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 16A, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 16A, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 16A, UTYPE, UTYPE, UTYPE)
#define GET_BYTE(addr)      (*(unsigned char *)(addr))
#define GET_SHORT(addr)     (*(unsigned short *)(addr))
#define GET_LONG(addr)      (*(unsigned long *)(addr))

// include the common aligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common aligned functions with 16/32 flavors
#include "shr1632a.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fputrig.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fputrig.c

Abstract:

    Floating point trig and transcendental functions

Author:

    05-Oct-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include "wx86.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "fpufragp.h"

ASSERTNAME;

//
// Forward declarations
//
NPXFUNC1(FCOS_VALID);
NPXFUNC1(FCOS_ZERO);
NPXFUNC1(FCOS_SPECIAL);
NPXFUNC1(FCOS_EMPTY);
NPXFUNC2(FPATAN_VALID_VALID);
NPXFUNC2(FPATAN_VALID_SPECIAL);
NPXFUNC2(FPATAN_SPECIAL_VALID);
NPXFUNC2(FPATAN_SPECIAL_SPECIAL);
NPXFUNC2(FPATAN_EMPTY_ALL);
NPXFUNC2(FPATAN_ALL_EMPTY);
NPXFUNC0(FPTAN_VALID);
NPXFUNC0(FPTAN_ZERO);
NPXFUNC0(FPTAN_SPECIAL);
NPXFUNC0(FSIN_VALID);
NPXFUNC0(FSIN_ZERO);
NPXFUNC0(FSIN_SPECIAL);
NPXFUNC0(FSIN_EMPTY);
NPXFUNC0(FSINCOS_VALID);
NPXFUNC0(FSINCOS_ZERO);
NPXFUNC0(FSINCOS_SPECIAL);
NPXFUNC2(FYL2X_VALID_VALID);
NPXFUNC2(FYL2X_VALID_ZERO);
NPXFUNC2(FYL2X_ZERO_VALID);
NPXFUNC2(FYL2X_ZERO_ZERO);
NPXFUNC2(FYL2X_SPECIAL_VALIDORZERO);
NPXFUNC2(FYL2X_VALIDORZERO_SPECIAL);
NPXFUNC2(FYL2X_SPECIAL_SPECIAL);
NPXFUNC2(FYL2X_ANY_EMPTY);
NPXFUNC2(FYL2X_EMPTY_ANY);
NPXFUNC2(FYL2XP1_VALIDORZERO_ZERO);
NPXFUNC2(FYL2XP1_VALIDORZERO_VALID);
NPXFUNC2(FYL2XP1_SPECIAL_VALIDORZERO);
NPXFUNC2(FYL2XP1_VALIDORZERO_SPECIAL);
NPXFUNC2(FYL2XP1_SPECIAL_SPECIAL);
NPXFUNC2(FYL2XP1_ANY_EMPTY);
NPXFUNC2(FYL2XP1_EMPTY_ANY);
NPXFUNC1(F2XM1_VALID);
NPXFUNC1(F2XM1_ZERO);
NPXFUNC1(F2XM1_SPECIAL);
NPXFUNC1(F2XM1_EMPTY);


//
// Jump tables
//
const NpxFunc1 FCOSTable[TAG_MAX] = {
    FCOS_VALID,
    FCOS_ZERO,
    FCOS_SPECIAL,
    FCOS_EMPTY
};

const NpxFunc2 FPATANTable[TAG_MAX][TAG_MAX] = {
    // left = TAG_VALID, right is ...
    { FPATAN_VALID_VALID, FPATAN_VALID_VALID, FPATAN_VALID_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_ZERO, right is ...
    { FPATAN_VALID_VALID, FPATAN_VALID_VALID, FPATAN_VALID_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_SPECIAL, right is ...
    { FPATAN_SPECIAL_VALID, FPATAN_SPECIAL_VALID, FPATAN_SPECIAL_SPECIAL, FPATAN_ALL_EMPTY },
    // left = TAG_EMPTY, right is ...
    { FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL, FPATAN_EMPTY_ALL }
};

const NpxFunc0 FPTANTable[TAG_MAX-1] = {
    FPTAN_VALID,
    FPTAN_ZERO,
    FPTAN_SPECIAL
};

const NpxFunc0 FSINTable[TAG_MAX] = {
    FSIN_VALID,
    FSIN_ZERO,
    FSIN_SPECIAL,
    FSIN_EMPTY
};

const NpxFunc0 FSINCOSTable[TAG_MAX-1] = {
    FSINCOS_VALID,
    FSINCOS_ZERO,
    FSINCOS_SPECIAL
};

// In the functions, l == ST(0), r = ST(1)
// r = r*log(l), l must be > 0
const NpxFunc2 FYL2XTable[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FYL2X_VALID_VALID, FYL2X_VALID_ZERO, FYL2X_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FYL2X_ZERO_VALID, FYL2X_ZERO_ZERO, FYL2X_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FYL2X_SPECIAL_VALIDORZERO, FYL2X_SPECIAL_VALIDORZERO, FYL2X_SPECIAL_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY, FYL2X_EMPTY_ANY}
};

// In the functions, l == ST(0), r = ST(1)
// r = r*(logl+1), l must be > 1
const NpxFunc2 FYL2XP1Table[TAG_MAX][TAG_MAX] = {
    // left is TAG_VALID, right is ...
    { FYL2XP1_VALIDORZERO_VALID, FYL2XP1_VALIDORZERO_ZERO, FYL2XP1_VALIDORZERO_SPECIAL, FYL2XP1_ANY_EMPTY },
    // left is TAG_ZERO, right is ...
    { FYL2XP1_VALIDORZERO_VALID, FYL2XP1_VALIDORZERO_ZERO, FYL2XP1_VALIDORZERO_SPECIAL, FYL2X_ANY_EMPTY },
    // left is TAG_SPECIAL, right is ...
    { FYL2XP1_SPECIAL_VALIDORZERO, FYL2XP1_SPECIAL_VALIDORZERO, FYL2XP1_SPECIAL_SPECIAL, FYL2XP1_ANY_EMPTY },
    // left is TAG_EMPTY, right is ...
    { FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY, FYL2XP1_EMPTY_ANY}
};

const NpxFunc1 F2XM1Table[TAG_MAX] = {
    F2XM1_VALID,
    F2XM1_ZERO,
    F2XM1_SPECIAL,
    F2XM1_EMPTY
};



NPXFUNC1(FCOS_VALID)
{
    Fp->r64 = cos(Fp->r64);
    SetTag(Fp);
}

NPXFUNC1(FCOS_ZERO)
{
    Fp->Tag = TAG_VALID;
    Fp->r64 = 1.0;
}

NPXFUNC1(FCOS_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FCOS_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        cpu->FpStatusC2 = 1;
        SetIndefinite(Fp);
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        break;

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        HandleInvalidOp(cpu);
        break;
    }
}

NPXFUNC1(FCOS_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}

FRAG0(FCOS)
{
    PFPREG ST0;
    FpArithPreamble(cpu);

    cpu->FpStatusC2 = 0;
    ST0 = cpu->FpST0;
    (*FCOSTable[ST0->Tag])(cpu, ST0);
}

NPXFUNC2(FPATAN_VALID_VALID)
{
    l->r64 = Proxyatan2(l->r64, r->r64);
    SetTag(l);
    POPFLT;
}

NPXFUNC2(FPATAN_VALID_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        FPATAN_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            break;
        }
        // else fall into QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // return the QNAN as the result
        l->r64 = r->r64;
        l->Tag = TAG_SPECIAL;
        l->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FPATAN_SPECIAL_VALID)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
    case TAG_SPECIAL_INFINITY:
        FPATAN_VALID_VALID(cpu, l, r);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            break;
        }
        // else fall into QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // The QNAN is already in l, so nothing to do.
        POPFLT;
        break;
    }
}

NPXFUNC2(FPATAN_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, r)) {
        return;
    }
    if (IS_TAG_NAN(l)) {
        if (IS_TAG_NAN(r)) {
            //
            // Return the larger of the two NANs
            //
            l->r64 = l->r64 + r->r64;
            SetTag(l);
        }
        //
        // else l is a NAN and r isn't - return the NAN in l
        //
        POPFLT;
        return;
    }
    if (IS_TAG_NAN(r)) {
        // r is a NAN and l isn't - return the NAN in l
        l->r64 = r->r64;
        l->Tag = TAG_SPECIAL;
        l->TagSpecial = r->TagSpecial;
        POPFLT;
    }

    // Otherwise, l and r are both INFINITY.  Return INDEFINITE
    CPUASSERT(l->TagSpecial == TAG_SPECIAL_INFINITY &&
              r->TagSpecial == TAG_SPECIAL_INFINITY);
    SetIndefinite(l);
    POPFLT;
}

NPXFUNC2(FPATAN_EMPTY_ALL)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FPATANTable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

NPXFUNC2(FPATAN_ALL_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FPATANTable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

FRAG0(FPATAN)
{
    PFPREG l = &cpu->FpStack[ST(1)];
    PFPREG r = cpu->FpST0;

    FpArithPreamble(cpu);
    (*FPATANTable[l->Tag][r->Tag])(cpu, l, r);
}


NPXFUNC0(FPTAN_VALID)
{
    int Exponent;
    PFPREG ST0;

    // get the exponent and make sure it is < 63
    ST0 = cpu->FpST0;
    Exponent = (int)((ST0->rdw[1] >> 20) & 0x7ff) - 1023;
    if (Exponent >= 63) {
        cpu->FpStatusC2 = 1;
        return;
    }
    ST0->r64 = tan(ST0->r64);
    SetTag(ST0);
    PUSHFLT(ST0);
    ST0->Tag = TAG_VALID;
    ST0->r64 = 1.0;
}

NPXFUNC0(FPTAN_ZERO)
{
    PFPREG ST0;

    ST0=cpu->FpST0;
    ST0->r64 = 0.0;
    ST0->Tag = TAG_ZERO;
    PUSHFLT(ST0);
    ST0->r64 = 1.0;
    ST0->Tag = TAG_VALID;
}

NPXFUNC0(FPTAN_SPECIAL)
{
    if (cpu->FpST0->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, cpu->FpST0)) {
        return;
    } else if (cpu->FpST0->TagSpecial == TAG_SPECIAL_DENORM) {
        FPTAN_VALID(cpu);
    }
    cpu->FpStatusC2 = 1;
}

FRAG0(FPTAN)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    ST0 = cpu->FpST0;

    //
    // TAG_EMPTY is handled first so that we can check ST(7) before
    // anything else has a chance to raise an exception.
    //
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    // assume no error
    cpu->FpStatusC2 = 0;

    // calculate the value
    CPUASSERT(ST0->Tag < TAG_EMPTY); // EMPTY was already handled
    (*FPTANTable[ST0->Tag])(cpu);
}

NPXFUNC0(FSIN_VALID)
{
    PFPREG ST0;

    ST0 = cpu->FpST0;
    ST0->r64 = sin(ST0->r64);
    SetTag(ST0);
}

NPXFUNC0(FSIN_ZERO)
{
    // sin(0.0) == 0.0, so there is nothing to do
}

NPXFUNC0(FSIN_SPECIAL)
{
    if (cpu->FpST0->TagSpecial == TAG_SPECIAL_SNAN && HandleSnan(cpu, cpu->FpST0)) {
        return;
    } else if (cpu->FpST0->TagSpecial == TAG_SPECIAL_DENORM) {
        FSIN_VALID(cpu);
    }
    cpu->FpStatusC2 = 1;
}

NPXFUNC0(FSIN_EMPTY)
{
    if (!HandleStackEmpty(cpu, cpu->FpST0)) {
        cpu->FpStatusC2 = 1;
    }
}

FRAG0(FSIN)
{
    FpArithPreamble(cpu);

    // assume no error
    cpu->FpStatusC2 = 0;

    // calculate the value
    (*FSINTable[cpu->FpST0->Tag])(cpu);
}

NPXFUNC0(FSINCOS_VALID)
{
    DOUBLE Val;
    PFPREG ST0;

    ST0 = cpu->FpST0;
    Val = ST0->r64;
    ST0->r64 = sin(Val);
    SetTag(ST0);
    PUSHFLT(ST0);
    ST0->r64 = cos(Val);
    SetTag(ST0);
}

NPXFUNC0(FSINCOS_ZERO)
{
    PFPREG ST0;

    ST0=cpu->FpST0;
    ST0->r64 = 0.0;
    ST0->Tag = TAG_ZERO;
    PUSHFLT(ST0);
    ST0->r64 = 1.0;
    ST0->Tag = TAG_VALID;
}

NPXFUNC0(FSINCOS_SPECIAL)
{
    switch (cpu->FpST0->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        FSINCOS_VALID(cpu);
        break;

    case TAG_SPECIAL_INFINITY:
        cpu->FpStatusC2 = 1;
        SetIndefinite(cpu->FpST0);
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, cpu->FpST0)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        cpu->FpStatusC2 = 1;
        break;
    }
}

FRAG0(FSINCOS)
{
    PFPREG ST0;

    FpArithPreamble(cpu);

    // assume no errors
    cpu->FpStatusC2 = 0;

    ST0 = cpu->FpST0;
    if (ST0->Tag == TAG_EMPTY && HandleStackEmpty(cpu, ST0)) {
        return;
    }

    if (cpu->FpStack[ST(7)].Tag != TAG_EMPTY) {
        HandleStackFull(cpu, &cpu->FpStack[ST(7)]);
        return;
    }

    CPUASSERT(ST0->Tag < TAG_EMPTY); // EMPTY was already handled
    (*FSINCOSTable[ST0->Tag])(cpu);
}

NPXFUNC2(FYL2X_VALID_VALID)
{
    if (l->r64 < 0.0) {
        // ST0 is negative - invalid operation
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r * log10(l->r64) / log10(2)
    //
    r->r64 *= Proxylog10(l->r64) / (0.301029995664);
    SetTag(r);
    POPFLT;
}

NPXFUNC2(FYL2X_VALID_ZERO)
{
    if (l->r64 < 0.0) {
        // ST0 is negative - invalid operation
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r*log2(l), but r=0, so the answer is 0.
    r->r64 = 0;
    r->Tag = TAG_ZERO;
    POPFLT;
}

NPXFUNC2(FYL2X_ZERO_VALID)
{
    // Divide-by-zero error
    cpu->FpStatusExceptions |= FPCONTROL_ZM;
    if (cpu->FpControlMask & FPCONTROL_ZM) {
        // Zero-divide exception is masked - return -INFINITY
        r->r64 = R8NegativeInfinity;
        r->Tag = TAG_SPECIAL;
        r->TagSpecial = TAG_SPECIAL_INFINITY;
        POPFLT;
    } else {
        cpu->FpStatusES = 1;
    }
}

NPXFUNC2(FYL2X_ZERO_ZERO)
{
    if (!HandleInvalidOp(cpu)) {
        SetIndefinite(r);
        POPFLT;
    }
}


NPXFUNC2(FYL2X_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XTable[TAG_VALID][r->Tag])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (r->Tag == TAG_ZERO || r->rb[7] & 0x80) {
            // 0*infinity, or anything*-infinity
            SetIndefinite(r);
        } else {
            // return -infinity
            r->rb[7] |= 0x80;
        }
        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // l is a NAN and r is VALID or ZERO - return the NAN
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2X_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XTable[l->Tag][TAG_VALID])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // log(x)*infinity
        if (l->r64 > 1.0) {
            // return the original infinity - nothing to do
        } else if (l->r64 < 0.0 || l->r64 == 1.0) {
            if (HandleInvalidOp(cpu)) {
                return;
            }
            SetIndefinite(r);
        } else {
            // return infinity with sign flipped
            r->rb[7] ^= 0x80;
        }

        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is a NAN and l is VALID or ZERO - return the NAN
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2X_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XTable[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XTable[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->Tag == TAG_SPECIAL_INFINITY) {

        if (r->Tag == TAG_SPECIAL_INFINITY) {

            // two infinities - return INDEFINITE
            SetIndefinite(r);

        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // r already has the NAN to return
        }
    } else {
        CPUASSERT(IS_TAG_NAN(l));

        if (r->Tag == TAG_SPECIAL_INFINITY) {
            //
            // Return the NAN from l
            //
            r->r64 = l->r64;
            r->TagSpecial = l->TagSpecial;
        } else {
            //
            // Return the largest of the two NANs
            //
            r->r64 = l->r64 + r->r64;
            SetTag(r);
        }
    }
    POPFLT;
}


NPXFUNC2(FYL2X_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FYL2XTable[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FYL2X_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FYL2XTable[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FYL2X)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    // In the functions, l == ST(0), r = ST(1)
    (*FYL2XTable[l->Tag][r->Tag])(cpu, l, r);
}



NPXFUNC2(FYL2XP1_VALIDORZERO_VALID)
{
    if (l->r64 < -1.0) {
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    } else if (l->r64 == -1.0) {
        // Divide-by-zero error
        cpu->FpStatusExceptions |= FPCONTROL_ZM;
        if (cpu->FpControlMask & FPCONTROL_ZM) {
            // Zero-divide exception is masked - return -INFINITY
            r->r64 = R8NegativeInfinity;
            r->Tag = TAG_SPECIAL;
            r->TagSpecial = TAG_SPECIAL_INFINITY;
            POPFLT;
        } else {
           cpu->FpStatusES = 1;
        }
        return;
    }
    // r = r * log10(l+1) / log10(2)
    //
    r->r64 *= Proxylog10(l->r64 + 1.0) / (0.301029995664);
    SetTag(r);
    POPFLT;
}

NPXFUNC2(FYL2XP1_VALIDORZERO_ZERO)
{
    if (l->r64 < -1.0) {
        if (!HandleInvalidOp(cpu)) {
            SetIndefinite(r);
            POPFLT;
        }
        return;
    }
    // r = r*log2(l), but r=0, so the answer is 0.
    r->r64 = 0;
    r->Tag = TAG_ZERO;
    POPFLT;
}

NPXFUNC2(FYL2XP1_SPECIAL_VALIDORZERO)
{
    switch (l->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XP1Table[TAG_VALID][r->Tag])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        if (r->Tag == TAG_ZERO || r->rb[7] & 0x80) {
            if (HandleInvalidOp(cpu)) {
                return;
            }

            // 0*infinity, or anything*-infinity
            SetIndefinite(r);
        } else {
            // return -infinity
            r->rb[7] |= 0x80;
        }
        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, l)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // l is a NAN and r is VALID or ZERO - return the NAN
        r->r64 = l->r64;
        r->Tag = l->Tag;
        r->TagSpecial = r->TagSpecial;
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2XP1_VALIDORZERO_SPECIAL)
{
    switch (r->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        (*FYL2XP1Table[l->Tag][TAG_VALID])(cpu, l, r);
        break;

    case TAG_SPECIAL_INFINITY:
        // log(x)*infinity
        if (l->r64 > 1.0) {
            // return the original infinity - nothing to do
        } else if (l->r64 < 0.0 || l->r64 == 1.0) {
            if (HandleInvalidOp(cpu)) {
                return;
            }
            SetIndefinite(r);
        } else {
            // return infinity with sign flipped
            r->rb[7] ^= 0x80;
        }

        POPFLT;
        break;

    case TAG_SPECIAL_SNAN:
        if (HandleSnan(cpu, r)) {
            return;
        }
        // else fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // r is a NAN and l is VALID or ZERO - return the NAN
        POPFLT;
        break;
    }
}

NPXFUNC2(FYL2XP1_SPECIAL_SPECIAL)
{
    if (l->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, l)) {
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_SNAN && HandleStackEmpty(cpu, r)) {
        return;
    }

    if (l->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XP1Table[TAG_VALID][r->Tag])(cpu, l, r);
        return;
    }
    if (r->TagSpecial == TAG_SPECIAL_DENORM) {
        (*FYL2XP1Table[l->Tag][TAG_VALID])(cpu, l, r);
        return;
    }

    if (l->Tag == TAG_SPECIAL_INFINITY) {

        if (r->Tag == TAG_SPECIAL_INFINITY) {

            if (l->rb[7] & 0x80) {
                // l is negative infinity.  Invalid op
                if (HandleInvalidOp(cpu)) {
                    return;
                }
                SetIndefinite(r);
            }


        } else {
            CPUASSERT(IS_TAG_NAN(r));

            // r already has the NAN to return
        }
    } else {
        CPUASSERT(IS_TAG_NAN(l));

        if (r->Tag == TAG_SPECIAL_INFINITY) {
            //
            // Return the NAN from l
            //
            r->r64 = l->r64;
            r->TagSpecial = l->TagSpecial;
        } else {
            //
            // Return the largest of the two NANs
            //
            r->r64 = l->r64 + r->r64;
            SetTag(r);
        }
    }
    POPFLT;
}


NPXFUNC2(FYL2XP1_ANY_EMPTY)
{
    if (!HandleStackEmpty(cpu, r)) {
        (*FYL2XP1Table[l->Tag][TAG_SPECIAL])(cpu, l, r);
    }
}

NPXFUNC2(FYL2XP1_EMPTY_ANY)
{
    if (!HandleStackEmpty(cpu, l)) {
        (*FYL2XP1Table[TAG_SPECIAL][r->Tag])(cpu, l, r);
    }
}

FRAG0(FYL2XP1)
{
    PFPREG l, r;

    FpArithPreamble(cpu);

    l = cpu->FpST0;
    r = &cpu->FpStack[ST(1)];

    // In the functions, l == ST(0), r = ST(1)
    (*FYL2XP1Table[l->Tag][r->Tag])(cpu, l, r);
}



NPXFUNC1(F2XM1_VALID)
{
    Fp->r64 = pow(2.0, Fp->r64) - 1.0;
    SetTag(Fp);
}

NPXFUNC1(F2XM1_ZERO)
{
    // nothing to do - return the same zero
}

NPXFUNC1(F2XM1_SPECIAL)
{
    switch (Fp->TagSpecial) {
    case TAG_SPECIAL_DENORM:
        F2XM1_VALID(cpu, Fp);
        break;

    case TAG_SPECIAL_INFINITY:
        if (Fp->rb[7] & 0x80) {
            // -infinity - return 1
            Fp->r64 = 1.0;
            Fp->Tag = TAG_VALID;
        }
        // else +infinity - return +infinity
        break;

    case TAG_SPECIAL_SNAN:
        HandleSnan(cpu, Fp);
        // fall into TAG_SPECIAL_QNAN

    case TAG_SPECIAL_QNAN:
    case TAG_SPECIAL_INDEF:
        // return the NAN
        break;
    }
}

NPXFUNC1(F2XM1_EMPTY)
{
    HandleStackEmpty(cpu, Fp);
}

FRAG0(F2XM1)
{
    PFPREG ST0;

    FpArithPreamble(cpu);
    ST0 = cpu->FpST0;
    (*F2XM1Table[ST0->Tag])(cpu, ST0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag32.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag32.h

Abstract:
    
    Prototypes for instruction fragments which operate on 32-bit DWORDS.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG32_H
#define FRAG32_H

#define FRAGCOMMON0(fn)     FRAG0(fn ## 32)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32, DWORD)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32, DWORD)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32, DWORD, DWORD)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32, DWORD)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32, DWORD)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32, DWORD, DWORD, DWORD)
#include "shared.h"
#include "shr1632.h"
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32A, DWORD)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32A, DWORD)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32A, DWORD, DWORD)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32A, DWORD)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32A, DWORD)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32A, DWORD, DWORD, DWORD)
#include "shareda.h"
#include "shr1632a.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag32.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag32.c

Abstract:
    
    Instuction fragments which operate on 32-bit DWORDS, shared with CCPU

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag32.h"
#include "optfrag.h"

// set up to include common functions
#define MSB		    0x80000000
#define LMB                 31  // Left Most Bit
#define UTYPE		    unsigned long
#define STYPE		    signed long
#define GET_VAL 	    GET_LONG
#define PUT_VAL 	    PUT_LONG
#define PUSH_VAL	    PUSH_LONG
#define POP_VAL 	    POP_LONG
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32, UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32, UTYPE, UTYPE, UTYPE)
#define AREG                eax
#define BREG		    ebx
#define CREG		    ecx
#define DREG		    edx
#define SPREG		    esp
#define BPREG		    ebp
#define SIREG		    esi
#define DIREG		    edi
#define SET_FLAGS_ADD       SET_FLAGS_ADD32
#define SET_FLAGS_SUB       SET_FLAGS_SUB32
#define SET_FLAGS_INC       SET_FLAGS_INC32
#define SET_FLAGS_DEC       SET_FLAGS_DEC32
#define GET_BYTE(addr)      (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)     (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)      (*(UNALIGNED unsigned long *)(addr))

#define PUT_BYTE(addr,dw)   {GET_BYTE(addr)=dw;}
#define PUT_SHORT(addr,dw)  {GET_SHORT(addr)=dw;}
#define PUT_LONG(addr,dw)   {GET_LONG(addr)=dw;}

// include the common functions with 8/16/32 flavors
#include "shared.c"

// include the common functions with 16/32 flavors
#include "shr1632.c"

// include the common unaligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common unaligned functions with 16/32 flavors
#include "shr1632a.c"

#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG

#if MSCPU
#define FRAGCOMMON0(fn)     FRAG0(fn ## 32A)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 32A,UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 32A, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 32A, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 32A, UTYPE, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 32A, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 32A, UTYPE, UTYPE, UTYPE)
#define GET_BYTE(addr)      (*(unsigned char *)(addr))
#define GET_SHORT(addr)     (*(unsigned short *)(addr))
#define GET_LONG(addr)      (*(unsigned long *)(addr))

// include the common aligned functions with 8/16/32 flavors
#include "shareda.c"

// include the common aligned functions with 16/32 flavors
#include "shr1632a.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag8.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag8.c

Abstract:
    
    Instuction fragments which operate on BYTES

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "frag8.h"

// set up to include common functions
#define MSB		    0x80
#define LMB                 7   // Left Most Bit
#define UTYPE		    unsigned char
#define STYPE		    signed char
#define GET_VAL 	    GET_BYTE
#define PUT_VAL 	    PUT_BYTE
#define FRAGCOMMON0(fn)     FRAG0(fn ## 8)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 8, UTYPE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 8, UTYPE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 8, UTYPE, UTYPE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 8, UTYPE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 8, UTYPE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 8, UTYPE, UTYPE, UTYPE)
#define AREG                al
#define BREG		    bl
#define CREG		    cl
#define DREG		    dl
#define SET_FLAGS_ADD       SET_FLAGS_ADD8
#define SET_FLAGS_SUB       SET_FLAGS_SUB8
#define SET_FLAGS_INC       SET_FLAGS_INC8
#define SET_FLAGS_DEC       SET_FLAGS_DEC8

// include the common functions
#include "shared.c"
#include "shareda.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fraglib.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    fraglib.h

Abstract:
    
    Public interface to the fragment library.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAGLIB_H
#define FRAGLIB_H

#ifdef MSCCPU
#include "ccpu.h"
#define FRAG0(x)                        void x(PCPUCONTEXT cpu)
#define FRAG1(x, t)                     void x(PCPUCONTEXT cpu, t *pop1)
#define FRAG1IMM(x, t)                  void x(PCPUCONTEXT cpu, t op1)
#define FRAG2(x, t)                     void x(PCPUCONTEXT cpu, t *pop1, t op2)
#define FRAG2REF(x, t)                  void x(PCPUCONTEXT cpu, t *pop1, t *pop2)
#define FRAG2IMM(x, t1, t2)             void x(PCPUCONTEXT cpu, t1 op1, t2 op2)
#define FRAG3(x, t1, t2, t3)            void x(PCPUCONTEXT cpu, t1 *pop1, t2 op2, t3 op3)
#else
#include "threadst.h"
#define FRAGCONTROLTRANSFER(x)          ULONG x(PTHREADSTATE cpu)
#define FRAG0(x)                        void x(PTHREADSTATE cpu)
#define FRAG1(x, t)                     void x(PTHREADSTATE cpu, t *pop1)
#define FRAG1IMM(x, t)                  void x(PTHREADSTATE cpu, t op1)
#define FRAG2(x, t)                     void x(PTHREADSTATE cpu, t *pop1, t op2)
#define FRAG2REF(x, t)                  void x(PTHREADSTATE cpu, t *pop1, t *pop2)
#define FRAG2IMM(x, t1, t2)             void x(PTHREADSTATE cpu, t1 op1, t2 op2)
#define FRAG3(x, t1, t2, t3)            void x(PTHREADSTATE cpu, t1 *pop1, t2 op2, t3 op3)
#endif

//
// Function for initializing the fragment library
//
BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    );


#define CALLFRAG0(x)                    x(cpu)
#define CALLFRAG1(x, pop1)              x(cpu, pop1)
#define CALLFRAG2(x, pop1, op2)         x(cpu, pop1, op2)
#define CALLFRAG3(x, pop1, op2, op3)    x(cpu, pop1, op2, op3)

#include "fragmisc.h"
#include "frag8.h"
#include "frag16.h"
#include "frag32.h"
#include "fpufrags.h"
#include "lock.h"
#include "synlock.h"

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
extern const BYTE ParityBit[256];

// These fragments are used only by the compiler
#ifdef MSCPU
#include "ctrltrns.h"
#include "optfrag.h"
#endif

#endif //FRAGLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\frag8.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    frag8.h

Abstract:
    
    Prototypes for instruction fragments which operate on 8-bit BYTES.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#ifndef FRAG8_H
#define FRAG8_H

#define FRAGCOMMON0(fn)     FRAG0(fn ## 8)
#define FRAGCOMMON1(fn)     FRAG1(fn ## 8, BYTE)
#define FRAGCOMMON1IMM(fn)  FRAG1IMM( fn ## 8, BYTE)
#define FRAGCOMMON2IMM(fn)  FRAG2IMM( fn ## 8, BYTE, BYTE)
#define FRAGCOMMON2(fn)     FRAG2(fn ## 8, BYTE)
#define FRAGCOMMON2REF(fn)  FRAG2REF(fn ## 8, BYTE)
#define FRAGCOMMON3(fn)     FRAG3(fn ## 8, BYTE, BYTE, BYTE)
#include "shared.h"
#include "shareda.h"
#undef FRAGCOMMON0
#undef FRAGCOMMON1
#undef FRAGCOMMON1IMM
#undef FRAGCOMMON2IMM
#undef FRAGCOMMON2
#undef FRAGCOMMON2REF
#undef FRAGCOMMON3

#endif //FRAG8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fragmisc.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fragmisc.h

Abstract:
    
    Prototypes for misc. instruction fragments.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/
FRAG0(CbwFrag16);
FRAG0(CbwFrag32);
FRAG0(PushEsFrag);
FRAG0(PopEsFrag);
FRAG0(PushFsFrag);
FRAG0(PopFsFrag);
FRAG0(PushGsFrag);
FRAG0(PopGsFrag);
FRAG0(PushCsFrag);
FRAG0(AasFrag);
FRAG0(PushSsFrag);
FRAG0(PopSsFrag);
FRAG0(PushDsFrag);
FRAG0(PopDsFrag);
FRAG0(DaaFrag);
FRAG0(DasFrag);
FRAG0(AaaFrag);
FRAG1IMM(AadFrag, BYTE);
FRAG2(ImulFrag16, USHORT);
FRAG2(ImulFrag16A, USHORT);
FRAG3(Imul3ArgFrag16, USHORT, USHORT, USHORT);
FRAG3(Imul3ArgFrag16A, USHORT, USHORT, USHORT);
FRAG2(ImulNoFlagsFrag16, USHORT);
FRAG2(ImulNoFlagsFrag16A, USHORT);
FRAG3(Imul3ArgNoFlagsFrag16, USHORT, USHORT, USHORT);
FRAG3(Imul3ArgNoFlagsFrag16A, USHORT, USHORT, USHORT);
FRAG2(ImulFrag32, DWORD);
FRAG2(ImulFrag32A, DWORD);
FRAG3(Imul3ArgFrag32, DWORD, DWORD, DWORD);
FRAG3(Imul3ArgFrag32A, DWORD, DWORD, DWORD);
FRAG2(ImulNoFlagsFrag32, DWORD);
FRAG2(ImulNoFlagsFrag32A, DWORD);
FRAG3(Imul3ArgNoFlagsFrag32, DWORD, DWORD, DWORD);
FRAG3(Imul3ArgNoFlagsFrag32A, DWORD, DWORD, DWORD);
FRAG0(SahfFrag);
FRAG0(LahfFrag);
FRAG1IMM(AamFrag, BYTE);
FRAG0(XlatFrag);
FRAG0(CmcFrag);
FRAG0(ClcFrag);
FRAG0(StcFrag);
FRAG0(CldFrag);
FRAG0(StdFrag);
FRAG1(SetoFrag, BYTE);
FRAG1(SetnoFrag, BYTE);
FRAG1(SetbFrag, BYTE);
FRAG1(SetaeFrag, BYTE);
FRAG1(SeteFrag, BYTE);
FRAG1(SetneFrag, BYTE);
FRAG1(SetbeFrag, BYTE);
FRAG1(SetaFrag, BYTE);
FRAG1(SetsFrag, BYTE);
FRAG1(SetnsFrag, BYTE);
FRAG1(SetpFrag, BYTE);
FRAG1(SetnpFrag, BYTE);
FRAG1(SetlFrag, BYTE);
FRAG1(SetgeFrag, BYTE);
FRAG1(SetleFrag, BYTE);
FRAG1(SetgFrag, BYTE);
FRAG2(Movzx8ToFrag16, USHORT);
FRAG2(Movzx8ToFrag16A, USHORT);
FRAG2(Movsx8ToFrag16, USHORT);
FRAG2(Movsx8ToFrag16A, USHORT);
FRAG2(Movzx8ToFrag32, DWORD);
FRAG2(Movzx8ToFrag32A, DWORD);
FRAG2(Movsx8ToFrag32, DWORD);
FRAG2(Movsx8ToFrag32A, DWORD);
FRAG2(Movzx16ToFrag32, DWORD);
FRAG2(Movzx16ToFrag32A, DWORD);
FRAG2(Movsx16ToFrag32, DWORD);
FRAG2(Movsx16ToFrag32A, DWORD);
FRAG1(BswapFrag32, DWORD);
FRAG2(ArplFrag, USHORT);
FRAG1(VerrFrag, USHORT);
FRAG1(VerwFrag, USHORT);
FRAG1(SmswFrag, USHORT);
FRAG2REF(CmpXchg8bFrag32, ULONGLONG);

#if MSCPU
FRAG0(IntFrag);
FRAG0(IntOFrag);
FRAG0(NopFrag);
FRAG0(PrivilegedInstructionFrag);
FRAG0(BadInstructionFrag);
FRAG2(FaultFrag, DWORD);
FRAG0(CPUID);
#endif //MSCPU
FRAG0(Rdtsc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\lock.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lock.c

Abstract:
    
    32bit instructions with the LOCK prefix

Author:

    15-Aug-1995 t-orig (Ori Gershony)

Revision History:

        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
        20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "lock.h"


// Define a macro which calls the lock helper functions
#define CALLLOCKHELPER0(fn)             fn ## LockHelper ()
#define CALLLOCKHELPER1(fn,a1)          fn ## LockHelper (a1)
#define CALLLOCKHELPER2(fn,a1,a2)       fn ## LockHelper (a1,a2)
#define CALLLOCKHELPER3(fn,a1,a2,a3)    fn ## LockHelper (a1,a2,a3)
#define CALLLOCKHELPER4(fn,a1,a2,a3,a4) fn ## LockHelper (a1,a2,a3,a4)

// Now define 32bit MSB
#define MSB		    0x80000000

#define SET_FLAGS_ADD   SET_FLAGS_ADD32
#define SET_FLAGS_SUB   SET_FLAGS_SUB32
#define SET_FLAGS_INC   SET_FLAGS_INC32
#define SET_FLAGS_DEC   SET_FLAGS_DEC32

FRAG2(LockAddFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Add, &op1, pop1, op2); 
    SET_FLAGS_ADD(result, op1, op2, MSB);
}

FRAG2(LockOrFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(Or, pop1, op2); 
    SET_PFLAG(result);
    SET_ZFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG2(LockAdcFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER4(Adc, &op1, pop1, op2, cpu->flag_cf);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}

FRAG2(LockSbbFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER4(Sbb, &op1, pop1, op2, cpu->flag_cf);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAG2(LockAndFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(And, pop1, op2); 
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG2(LockSubFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Sub, &op1, pop1, op2); 
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAG2(LockXorFrag32, ULONG)
{
    ULONG result;

    result = CALLLOCKHELPER2(Xor, pop1, op2); 
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAG1(LockNotFrag32, ULONG)
{
    CALLLOCKHELPER1(Not, pop1);
}

FRAG1(LockNegFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER2(Neg, &op1, pop1);
    SET_CFLAG_IND(result == 0);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result);
    SET_OFLAG_IND(op1 & result & MSB);
}

FRAG1(LockIncFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Add, &op1, pop1, 1); 
    SET_FLAGS_INC(result, op1);
}

FRAG1(LockDecFrag32, ULONG)
{
    ULONG result, op1;

    result = CALLLOCKHELPER3(Sub, &op1, pop1, 1); 
    SET_FLAGS_DEC(result, op1);
}

FRAG2(LockBtsMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Bts, pop1, bit));
}

FRAG2(LockBtsRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Bts, pop1, bit));
}

FRAG2(LockBtrMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Btr, pop1, bit));
}

FRAG2(LockBtrRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Btr, pop1, bit));
}

FRAG2(LockBtcMemFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    pop1 += (op2 >> 5);
    SET_CFLAG_IND(CALLLOCKHELPER2(Btc, pop1, bit));
}

FRAG2(LockBtcRegFrag32, ULONG)
{
    ULONG bit = 1<<(op2&0x1f);

    SET_CFLAG_IND(CALLLOCKHELPER2(Btc, pop1, bit));
}

FRAG2REF(LockXchgFrag32, ULONG)
{
    CALLLOCKHELPER2(Xchg, pop1, pop2);
}

FRAG2REF(LockXaddFrag32, ULONG)
{
    ULONG op1, op2;

    op2 = CALLLOCKHELPER3(Xadd, &op1, pop1, pop2);
    // op1 has the original value of dest (*pop1)
    // op2 has the result of the XADD
    // so, op2-op1 is the original value of src
    SET_FLAGS_ADD(op2, (op2-op1), op1, MSB);
}
FRAG2REF(LockCmpXchgFrag32, ULONG)
{
    ULONG op1;
    ULONG Value = eax;

    SET_ZFLAG(CALLLOCKHELPER4(CmpXchg, &eax, pop1, pop2, &op1));
    SET_FLAGS_SUB(Value-op1, Value, op1, MSB);
}
FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)
{
    ULONGLONG op1;
    ULONGLONG EdxEax;
    ULONGLONG EcxEbx;

    EdxEax = (((ULONGLONG)edx) << 32) | (ULONGLONG)eax;
    EcxEbx = (ULONGLONG)ecx << 32 | (ULONGLONG)ebx;
    SET_ZFLAG(CALLLOCKHELPER3(CmpXchg8b, &EdxEax, &EcxEbx, pop1));
    edx = (ULONG)(EdxEax >> 32);
    eax = (ULONG)EdxEax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fragp.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fragp.h

Abstract:
    
    Private exports, defines for shared code fragments.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

#include "cpumain.h"

#ifndef FRAGP_H
#define FRAGP_H

#include "fraglib.h"
#include "eflags.h"

//
// This function patches a call to pass the mips address corresponding to
// intelAddr directly to the call fragments.
//
PULONG
patchCallRoutine(
    IN PULONG intelAddr,
    IN PULONG patchAddr
    );

//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
extern const BYTE ParityBit[256];

#if _ALPHA_
// defined in fraginit.c, used in the Alpha code generator
extern DWORD fByteInstructionsOK;
#endif

#ifdef MSCCPU

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->cs
#define DS      cpu->ds
#define ES      cpu->es
#define SS      cpu->ss
#define FS      cpu->fs
#define GS      cpu->gs


#define CPUDATA  CPUCONTEXT
#define PCPUDATA PCPUCONTEXT

#else   //!MSCCPU

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->GpRegs[REG_CS].i2
#define DS      cpu->GpRegs[REG_DS].i2
#define ES      cpu->GpRegs[REG_ES].i2
#define SS      cpu->GpRegs[REG_SS].i2
#define FS      cpu->GpRegs[REG_FS].i2
#define GS      cpu->GpRegs[REG_GS].i2

#define CPUDATA  THREADSTATE
#define PCPUDATA PTHREADSTATE

#endif  //!MSCCPU

#define MSB32   0x80000000

#define SET_FLAG(flag, b)    flag = (DWORD)b
#define SET_CFLAG(b)	     SET_FLAG(cpu->flag_cf, (b))
#define SET_PFLAG(b)	     SET_FLAG(cpu->flag_pf, (b))
#define SET_AUXFLAG(b)	     SET_FLAG(cpu->flag_aux,(b))
#define SET_ZFLAG(b)         SET_FLAG(cpu->flag_zf, (b))
#define SET_SFLAG(b)	     SET_FLAG(cpu->flag_sf, (b))
// SET_DFLAG is special
#define SET_OFLAG(b)	     SET_FLAG(cpu->flag_of, (b))
#define SET_TFLAG(b)	     SET_FLAG(cpu->flag_tf, (b))
#define SET_RFLAG(b)   //UNDONE: not used until 386 debug registers implemented

#define AUX_VAL             0x10
#define GET_AUXFLAG         (cpu->flag_aux & AUX_VAL)
#define SET_AUXFLAG_ON      SET_AUXFLAG(AUX_VAL)
#define SET_AUXFLAG_OFF     SET_AUXFLAG(0x0)

#define GET_OFLAG           (cpu->flag_of & MSB32)
#define GET_OFLAGZO         (cpu->flag_of >> 31)
#define SET_OFLAG_ON        SET_OFLAG(MSB32)
#define SET_OFLAG_OFF       SET_OFLAG(0)
#define SET_OFLAG_IND(b)    SET_OFLAG(b ? MSB32 : 0)

#define GET_CFLAG           (cpu->flag_cf & MSB32)
#define GET_CFLAGZO         (cpu->flag_cf >> 31)
#define SET_CFLAG_ON        SET_CFLAG(MSB32)
#define SET_CFLAG_OFF       SET_CFLAG(0)
#define SET_CFLAG_IND(b)    SET_CFLAG(b ? MSB32 : 0)

#define GET_SFLAG           (cpu->flag_sf & MSB32)
#define GET_SFLAGZO         (cpu->flag_sf >> 31)
#define SET_SFLAG_ON        SET_SFLAG(MSB32)
#define SET_SFLAG_OFF       SET_SFLAG(0)
#define SET_SFLAG_IND(b)    SET_SFLAG(b ? MSB32 : 0)

#define GET_PFLAG           (ParityBit[cpu->flag_pf & 0xff])


#define GET_BYTE(addr)       (*(UNALIGNED unsigned char *)(addr))
#define GET_SHORT(addr)      (*(UNALIGNED unsigned short *)(addr))
#define GET_LONG(addr)       (*(UNALIGNED unsigned long *)(addr))

#define PUT_BYTE(addr,dw)    {GET_BYTE(addr)=dw;}
#define PUT_SHORT(addr,dw)   {GET_SHORT(addr)=dw;}
#define PUT_LONG(addr,dw)    {GET_LONG(addr)=dw;}

typedef void (*pfnFrag0)(PCPUDATA);
typedef void (*pfnFrag18)(PCPUDATA, BYTE *);
typedef void (*pfnFrag116)(PCPUDATA, USHORT *);
typedef void (*pfnFrag132)(PCPUDATA, DWORD *);
typedef void (*pfnFrag28)(PCPUDATA, BYTE *, BYTE);
typedef void (*pfnFrag216)(PCPUDATA, USHORT *, USHORT);
typedef void (*pfnFrag232)(PCPUDATA, DWORD *, DWORD);
typedef void (*pfnFrag38)(PCPUDATA, BYTE *, BYTE, BYTE);
typedef void (*pfnFrag316)(PCPUDATA, USHORT *, USHORT, USHORT);
typedef void (*pfnFrag332)(PCPUDATA, DWORD *, DWORD, DWORD);

/*---------------------------------------------------------------------*/
extern void CpupUnlockTCAndDoInterrupt(PTHREADSTATE cpu, int Interrupt);

#define Int0()              CpupUnlockTCAndDoInterrupt(cpu, 0)   // Divide error
#define Int3()              CpupUnlockTCAndDoInterrupt(cpu, 3)   // Breakpoint
#define Int4()              CpupUnlockTCAndDoInterrupt(cpu, 4)   // Overflow
#define Int5()              CpupUnlockTCAndDoInterrupt(cpu, 5)   // Bound check
#define Int6()              CpupUnlockTCAndDoInterrupt(cpu, 6)   // Invalid opcode
#define Int8()              CpupUnlockTCAndDoInterrupt(cpu, 8)   // Double fault
#define Int13(sel)          CpupUnlockTCAndDoInterrupt(cpu, 13)  // General protection

#define PRIVILEGED_INSTR        Int13(0)
#define BREAKPOINT_INSTR        Int3()
#define OVERFLOW_INSTR          Int4()

/*---------------------------------------------------------------------*/

#define PUSH_LONG(dw) {     \
    DWORD NewEsp = esp-4;   \
    *(DWORD *)(NewEsp) = (DWORD)(dw); \
    esp=NewEsp;             \
    }

#define POP_LONG(dw)  {     \
    DWORD espTemp = esp;    \
    (dw)=*(DWORD *)espTemp; \
    esp=espTemp+4;          \
    }

#define PUSH_SHORT(s) {     \
    DWORD NewEsp = esp-2;   \
    *(USHORT *)(NewEsp)=(USHORT)(s); \
    esp=NewEsp;                 \
    }

#define POP_SHORT(s) {      \
    DWORD espTemp = esp;    \
    (s)=*(USHORT *)espTemp; \
    esp=espTemp+2;          \
    }

#define XCHG(t, r1, r2) {   \
    t temp;		    \
    temp = r1;		    \
    r1=r2;		    \
    r2=temp;		    \
    }

#define XCHG_MEM(t, m1, m2) { \
    t temp;		    \
    temp = *m1; 	    \
    *m1 = *m2;		    \
    *m2 = temp; 	    \
    }

#define do_j_b(f) {         \
    if (cpu->AdrPrefix) {                           \
        if (f) {                                    \
            cpu->eipTempReg.i2+=(char)GET_BYTE(eipTemp+1)+2;   \
        } else {                                    \
            cpu->eipTempReg.i2+=2;                  \
        }                                           \
        cpu->AdrPrefix = PREFIX_NONE;               \
    } else {                                        \
        if (f) {                                    \
            eipTemp+=(char)GET_BYTE(eipTemp+1)+2;   \
        } else {                                    \
            eipTemp+=2;                             \
        }                                           \
    }                                               \
}

#define DO_J(f) {           \
    if (cpu->AdrPrefix) {                                       \
        if (f) {                                                \
            cpu->eipTempReg.i2+=(STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE); \
        } else {                                                \
            cpu->eipTempReg.i2+=1+sizeof(UTYPE);                \
        }                                                       \
        cpu->AdrPrefix = PREFIX_NONE;                           \
    } else {                                                    \
        if (f) {                                                \
            eipTemp+=(STYPE)GET_VAL(eipTemp+1)+1+sizeof(UTYPE); \
        } else {                                                \
            eipTemp+=1+sizeof(UTYPE);                           \
        }                                                       \
    }                                                           \
}

#define SET_FLAGS_ADD32(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG(~((op1) ^ (op2)) & ((op2) ^ (r)));                        \
    SET_CFLAG(carry ^ cpu->flag_of);                                    \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_ADD16(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((~((op1) ^ (op2)) & ((op2) ^ (r))) << 16);                \
    SET_CFLAG((carry<<16) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_ADD8(r, op1, op2, msb) {                              \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((~((op1) ^ (op2)) & ((op2) ^ (r))) << 24);                \
    SET_CFLAG((carry<<24) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB32(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG(((op1) ^ (op2)) & ((op1) ^ (r)));                         \
    SET_CFLAG(carry ^ cpu->flag_of);                                    \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB16(r, op1, op2, msb) {                             \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((((op1) ^ (op2)) & ((op1) ^ (r))) << 16);                 \
    SET_CFLAG((carry<<16) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_SUB8(r, op1, op2, msb) {                              \
    DWORD carry = (op1) ^ (op2) ^ (r);                                  \
    /* next line is different for ADD/SUB */                            \
    SET_OFLAG((((op1) ^ (op2)) & ((op1) ^ (r))) << 24);                 \
    SET_CFLAG((carry<<24) ^ cpu->flag_of);                              \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_AUXFLAG(carry);                                                 \
    SET_PFLAG((r));                                                     \
    }

#define SET_FLAGS_INC32(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG(~((op1) ^ 1) & (1 ^ (r)));                                \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_INC16(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((~((op1) ^ 1) & (1 ^ (r))) << 16);                        \
    SET_ZFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_INC8(r, op1) {                                        \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((~((op1) ^ 1) & (1 ^ (r))) << 24);                        \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC32(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG(((op1) ^ 1) & ((op1) ^ (r)));                             \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r));                                                     \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC16(r, op1) {                                       \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((((op1) ^ 1) & ((op1) ^ (r))) << 16);                     \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 16);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }

#define SET_FLAGS_DEC8(r, op1) {                                        \
    DWORD carry = (op1) ^ 1 ^ (r);                                      \
    /* next line is different for INC/DEC */                            \
    SET_OFLAG((((op1) ^ 1) & ((op1) ^ (r))) << 24);                     \
    SET_ZFLAG((r));                                                     \
    SET_SFLAG((r) << 24);                                               \
    SET_PFLAG((r));                                                     \
    SET_AUXFLAG(carry);                                                 \
    }


VOID    CpuRaiseStatus( NTSTATUS Status );

#endif //FRAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fragmisc.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fragmisc.c

Abstract:
    
    Miscellaneous instuction fragments.

Author:

    12-Jun-1995 BarryBo

Revision History:

      24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
      20-Sept-1999[barrybo]  added FRAG2REF(CmpXchg8bFrag32, ULONGLONG)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <float.h>
#include "wx86.h"
#include "wx86nt.h"
#include "fragp.h"
#include "fragmisc.h"
#include "cpunotif.h"
#include "config.h"
#include "mrsw.h"
#include "cpuassrt.h"
#if MSCPU
#include "atomic.h"
#endif
ASSERTNAME;

void
CpupUnlockTCAndDoInterrupt(
    PTHREADSTATE cpu,
    int Interrupt
    )
{
    MrswReaderExit(&MrswTC);
    cpu->fTCUnlocked = TRUE;
    CpupDoInterrupt(Interrupt);
    // If we get here, CpupDoInterrupt returned due to CONTINUE_EXECUTION.
    // We need to redesign so we can jump to EndTranslatedCode now, as
    // the cache may have been flushed.
    CPUASSERT(FALSE);
    MrswReaderEnter(&MrswTC);
    cpu->fTCUnlocked = FALSE;
}


FRAG0(CbwFrag32)
{
    eax = (signed long)(signed short)ax;
}
FRAG0(CbwFrag16)
{
    ax = (signed short)(signed char)al;
}
FRAG0(PushEsFrag)
{
    PUSH_LONG(ES);
}
FRAG0(PopEsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    ES = (USHORT)temp;
}
FRAG0(PushFsFrag)
{
    PUSH_LONG(FS);
}
FRAG0(PopFsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    FS = (USHORT)temp;
}
FRAG0(PushGsFrag)
{
    PUSH_LONG(GS);
}
FRAG0(PopGsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    GS = (USHORT)temp;
}
FRAG0(PushCsFrag)
{
    PUSH_LONG(CS);
}
FRAG0(AasFrag)
{
    if ( (al & 0x0f) > 9 || GET_AUXFLAG) {
        ah--;
        al = (al-6) & 0x0f;
        SET_CFLAG_ON;
        SET_AUXFLAG_ON;
    } else {
        SET_CFLAG_OFF;
        SET_AUXFLAG_OFF;
        al &= 0xf;
    }
}
FRAG0(PushSsFrag)
{
    PUSH_LONG(SS);
}
FRAG0(PopSsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    SS = (USHORT)temp;
}
FRAG0(PushDsFrag)
{
    PUSH_LONG(DS);
}
FRAG0(PopDsFrag)
{
    DWORD temp;
    POP_LONG(temp);
    DS = (USHORT)temp;
}
FRAG0(DaaFrag)
{
    if ((al & 0x0f) > 9 || GET_AUXFLAG) {
    al += 6;
    SET_AUXFLAG_ON;
    } else {
    SET_AUXFLAG_OFF;
    }
    if ((al & 0xf0) > 0x90 || GET_CFLAG) {
    al += 0x60;
    SET_CFLAG_ON;
    } else {
    SET_CFLAG_OFF;
    }
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG0(DasFrag)
{
    if ( (al & 0x0f) > 9 || GET_AUXFLAG) {
    al -= 6;
    SET_AUXFLAG_ON;
    } else {
    SET_AUXFLAG_OFF;
    }
    if ( al > 0x9f || GET_CFLAG) {
    al -= 0x60;
    SET_CFLAG_ON;
    } else {
    SET_CFLAG_OFF;
    }
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG0(AaaFrag)
{
    if ((al & 0x0f) > 9 || GET_AUXFLAG) {
        al=(al+6) & 0x0f;
        ah++;       // inc ah
        SET_AUXFLAG_ON;
        SET_CFLAG_ON;
    } else {
        SET_AUXFLAG_OFF;
        SET_CFLAG_OFF;
        al &= 0xf;
    }
}
FRAG1IMM(AadFrag, BYTE)
{
    al += ah * op1;
    ah = 0;
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7)); // SET_SFLAG_IND(al & 0x80);
}
FRAG2(ImulFrag16, USHORT)
{
    Imul3ArgFrag16(cpu, pop1, GET_SHORT(pop1), op2);
}
FRAG2(ImulFrag16A, USHORT)
{
    Imul3ArgFrag16A(cpu, pop1, *pop1, op2);
}
FRAG3(Imul3ArgFrag16, USHORT, USHORT, USHORT)
{
    long result;

    result = (long)(short)op2 * (long)(short)op3;
    PUT_SHORT(pop1, (USHORT)(short)result);
    if (HIWORD(result) == 0 || HIWORD(result) == 0xffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG3(Imul3ArgFrag16A, USHORT, USHORT, USHORT)
{
    long result;

    result = (short)op2 * (short)op3;
    *pop1 = (USHORT)(short)result;
    if (HIWORD(result) == 0 || HIWORD(result) == 0xffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG2(ImulNoFlagsFrag16, USHORT)
{
    short op1 = (short)GET_SHORT(pop1);

    PUT_SHORT(pop1, (op2 * (short)op2));
}
FRAG2(ImulNoFlagsFrag16A, USHORT)
{
    *(short *)pop1 *= (short)op2;
}
FRAG3(Imul3ArgNoFlagsFrag16, USHORT, USHORT, USHORT)
{
    PUT_SHORT(pop1, ((short)op2 * (short)op3));
}
FRAG3(Imul3ArgNoFlagsFrag16A, USHORT, USHORT, USHORT)
{
    *pop1 = (USHORT)((short)op2 * (short)op3);
}
FRAG2(ImulFrag32, DWORD)
{
    Imul3ArgFrag32(cpu, pop1, GET_LONG(pop1), op2);
}
FRAG2(ImulFrag32A, DWORD)
{
    Imul3ArgFrag32A(cpu, pop1, *pop1, (long)op2);
}
FRAG3(Imul3ArgFrag32A, DWORD, DWORD, DWORD)
{
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64((long)op2, (long)op3);
    result = *(LARGE_INTEGER *)&ll;
    *pop1 = result.LowPart;
    if (result.HighPart == 0 || result.HighPart == 0xffffffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG3(Imul3ArgFrag32, DWORD, DWORD, DWORD)
{
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64((long)op2, (long)op3);
    result = *(LARGE_INTEGER *)&ll;
    PUT_LONG(pop1, result.LowPart);
    if (result.HighPart == 0 || result.HighPart == 0xffffffff) {
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    } else {
    SET_CFLAG_ON;
    SET_OFLAG_ON;
    }
}
FRAG2(ImulNoFlagsFrag32, DWORD)
{
    long op1 = (LONG)GET_LONG(pop1);

    PUT_LONG(pop1, (op1 * (long)op2));
}
FRAG2(ImulNoFlagsFrag32A, DWORD)
{
    *(long *)pop1 *= (long)op2;
}
FRAG3(Imul3ArgNoFlagsFrag32A, DWORD, DWORD, DWORD)
{
    *pop1 = (DWORD)( (long)op2 * (long)op3);
}
FRAG3(Imul3ArgNoFlagsFrag32, DWORD, DWORD, DWORD)
{
    PUT_LONG(pop1, ((long)op2 * (long)op3));
}

FRAG0(SahfFrag)
{
    DWORD dw = (DWORD)ah;

    SET_CFLAG(dw << 31);         // CFLAG is low-bit of ah
    SET_PFLAG (!(dw & FLAG_PF)); // flag_pf contains an index into ParityBit[] array
    SET_AUXFLAG(dw);             // AUX bit is already in the right place
    SET_ZFLAG (!(dw & FLAG_ZF)); // zf has inverse logic
    SET_SFLAG(dw << (31-7));     // SFLAG is bit 7 in AH
}
FRAG0(LahfFrag)
{
    ah= 2 |                                 // this bit is always set on Intel
        ((GET_CFLAG) ? FLAG_CF : 0) |
        ((GET_PFLAG) ? FLAG_PF : 0) |
        ((GET_AUXFLAG)? FLAG_AUX: 0) |
        ((cpu->flag_zf) ? 0 : FLAG_ZF) |    // zf has inverse logic
        ((GET_SFLAG) ? FLAG_SF : 0);
}
FRAG1IMM(AamFrag, BYTE)
{
    ah = al / op1;
    al %= op1;
    SET_ZFLAG(al);
    SET_PFLAG(al);
    SET_SFLAG(al << (31-7));
}
FRAG0(XlatFrag)
{
    al = GET_BYTE(ebx+al);
}
FRAG0(CmcFrag)
{
    SET_CFLAG_IND(!GET_CFLAG);
}
FRAG0(ClcFrag)
{
    SET_CFLAG_OFF;
}
FRAG0(StcFrag)
{
    SET_CFLAG_ON;
}
FRAG0(CldFrag)
{
    cpu->flag_df = 1;
}
FRAG0(StdFrag)
{
    cpu->flag_df = 0xffffffff;
}
FRAG1(SetoFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_OFLAGZO);
}
FRAG1(SetnoFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_OFLAG == 0));
}
FRAG1(SetbFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_CFLAGZO);
}
FRAG1(SetaeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG == 0));
}
FRAG1(SeteFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf == 0));  // inverse logic
}
FRAG1(SetneFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf != 0));  // inverse logic
}
FRAG1(SetbeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG || cpu->flag_zf == 0));  // inverse logic
}
FRAG1(SetaFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_CFLAG == 0 && cpu->flag_zf != 0));  // inverse logic
}
FRAG1(SetsFrag, BYTE)
{
    PUT_BYTE(pop1, (BYTE)GET_SFLAGZO);
}
FRAG1(SetnsFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAG == 0));
}
FRAG1(SetpFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_PFLAG != 0));
}
FRAG1(SetnpFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_PFLAG == 0));
}
FRAG1(SetlFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAG != GET_OFLAG));
}
FRAG1(SetgeFrag, BYTE)
{
    PUT_BYTE(pop1, (GET_SFLAGZO == GET_OFLAGZO));
}
FRAG1(SetleFrag, BYTE)
{
    PUT_BYTE(pop1, (!cpu->flag_zf || (GET_SFLAG != GET_OFLAG))); // inverse logic
}
FRAG1(SetgFrag, BYTE)
{
    PUT_BYTE(pop1, (cpu->flag_zf && !(GET_SFLAG ^ GET_OFLAG)));    // inverse logic
}
FRAG2(Movzx8ToFrag16, USHORT)
{
    PUT_SHORT(pop1, (USHORT)(BYTE)op2);
}
FRAG2(Movzx8ToFrag16A, USHORT)
{
    *pop1 = (USHORT)(BYTE)op2;
}
FRAG2(Movsx8ToFrag16, USHORT)
{
    PUT_SHORT(pop1, (USHORT)(short)(char)(BYTE)op2);
}
FRAG2(Movsx8ToFrag16A, USHORT)
{
    *pop1 = (USHORT)(short)(char)(BYTE)op2;
}
FRAG2(Movzx8ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(BYTE)op2);
}
FRAG2(Movzx8ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(BYTE)op2;
}
FRAG2(Movsx8ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(long)(char)(BYTE)op2);
}
FRAG2(Movsx8ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(long)(char)(BYTE)op2;
}
FRAG2(Movzx16ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(USHORT)op2);
}
FRAG2(Movzx16ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(USHORT)op2;
}
FRAG2(Movsx16ToFrag32, DWORD)
{
    PUT_LONG(pop1, (DWORD)(long)(short)(USHORT)op2);
}
FRAG2(Movsx16ToFrag32A, DWORD)
{
    *pop1 = (DWORD)(long)(short)(USHORT)op2;
}
FRAG1(BswapFrag32, DWORD)
{
    DWORD d;
    PBYTE pSrc = (PBYTE)pop1;

    d = (pSrc[0] << 24) | (pSrc[1] << 16) | (pSrc[2] << 8) | pSrc[3];
    // pop1 is always a pointer to a register, so an ALIGNED store is correct
    *pop1 = d;
}

FRAG2(ArplFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1);

    op2 &= 3;              // just get the RPL bits of the selector
    if ((op1&3) < op2) {
        // RPL bits of DEST < RPL bits of SRC
        op1 = (op1 & ~3) | op2; // copy RPL bits from SRC to DEST
        PUT_SHORT(pop1, op1);   // store DEST
        SET_ZFLAG(0);           // ZF=1
    } else {
        SET_ZFLAG(1);
    }
}

FRAG1(VerrFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1) & ~3;  // mask off RPL bits

    if (op1 == KGDT_R3_CODE ||          // CS: selector
        op1 == KGDT_R3_DATA ||          // DS:, SS:, ES: selector
        op1 == KGDT_R3_TEB              // FS: selector
       ) {
        SET_ZFLAG(0);       // ZF=1
    } else {
        SET_ZFLAG(1);       // ZF=0
    }
}

FRAG1(VerwFrag, USHORT)
{
    USHORT op1 = GET_SHORT(pop1) & ~3;  // mask off RPL bits

    if (op1 == KGDT_R3_DATA ||          // DS:, SS:, ES: selector
        op1 == KGDT_R3_TEB              // FS: selector
       ) {
        SET_ZFLAG(0);       // ZF=1
    } else {
        SET_ZFLAG(1);       // ZF=0
    }
}

FRAG1(SmswFrag, USHORT)
{
    //
    // This value is empirically discovered by running it on a Pentium
    // machine.  CR0_PE, CR0_EX, and CR0_NE bits were set, and all others
    // notably CR0_MP, are clear.
    //
    PUT_SHORT(pop1, 0x31);
}

#if MSCPU
FRAG0(IntOFrag)
{
    if (GET_OFLAG) {
        Int4();     // raise overflow
    }
}
FRAG0(NopFrag)
{
}
FRAG0(PrivilegedInstructionFrag)
{
    PRIVILEGED_INSTR;
}
FRAG0(BadInstructionFrag)
{
    Int6();     // Throw invalid opcode exception
}
FRAG2(FaultFrag, DWORD)
{
    // pop1 = exception code
    // op2  = address where fault occurred
#if DBG
    LOGPRINT((TRACELOG, "CPU: FaultFrag called\r\n"));
#endif

    RtlRaiseStatus((NTSTATUS)(ULONGLONG)pop1);   
}
#endif //MSCPU
FRAG0(CPUID)
{
    switch (eax) {
    case 0:
        eax = 1;            // We are a 486 with CPUID (PPro returns 2)
        //ebx = 0x756e6547;   // "GenuineIntel"
        //edx = 0x49656e69;
        //ecx = 0x6c65746e;
        ebx = 0x7263694d;   // "Micr" with M in the low nibble of BL
        edx = 0x666f736f;   // "osof" with o in the low nibble of DL
        ecx = 0x55504374;   // "tCPU" with t in the low nibble of CL
        break;

    case 1:
        eax = (0 << 12) |   // Type   = 0 (2 bits) Original OEM Processor
              (4 << 8) |    // Family = 4 (4 bits) 80486
              (1 << 4) |    // Model  = 1 (4 bits)
              0;            // Stepping=0 (4 bits)
        edx = (fUseNPXEM) ? 1: 0;   // bit 0:  FPU on-chip.  wx86cpu doesn't
                                    // support any other features.
        break;

    default:
        //
        // The Intel behavior indicates that if eax is out-of-range, the
        // results returned in the regsiters are unpredictable but it
        // doesn't fault.
        //
        break;
    }
}
FRAG2REF(CmpXchg8bFrag32, ULONGLONG)
{
    ULONGLONG EdxEax;
    ULONGLONG Value;

    EdxEax = (((ULONGLONG)edx) << 32) | (ULONGLONG)eax;
    Value = *(ULONGLONG UNALIGNED *)pop1;

    if (Value == EdxEax) {
    ULONGLONG EcxEbx;

    EcxEbx = (ULONGLONG)ecx << 32 | (ULONGLONG)ebx;
    *(ULONGLONG UNALIGNED *)pop1 = EcxEbx;
        SET_ZFLAG(0);       // zf has inverse logic
    } else {
    eax = (ULONG)Value;
    edx = (ULONG)(Value >> 32);
        SET_ZFLAG(1);       // zf has inverse logic
    }
}
FRAG0(Rdtsc)
{
    LARGE_INTEGER Counter;

    // This is cheese, but it will at least return a value that increases
    // over time.
    NtQueryPerformanceCounter(&Counter, NULL);
    edx = Counter.HighPart;
    eax = Counter.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\fraginit.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name: 

    fraginit.c

Abstract:
    
    Initialization, termination, and CPU interface functions

Author:

    25-Aug-1995 BarryBo

Revision History:

--*/
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#ifdef MSCCPU
#include "ccpu.h"
#include "msccpup.h"
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG
#else
#include "threadst.h"
#include "instr.h"
#include "frag.h"
ASSERTNAME;
#endif
#include "fragp.h"


//
// Table mapping a byte to a 0 or 1, corresponding to the parity bit for
// that byte.
//
const BYTE ParityBit[] = {
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1
};

#if _ALPHA_
//
// TRUE if the CPU should generate the new LDB/STB instructions for accessing
// data less than one DWORD long or when accessing unaligned data.
//
DWORD fByteInstructionsOK;
#endif


int *
_errno(
    )
/*++

Routine Description:

    Stub function so the CPU can pull in floating-point CRT support
    without the C startup code.

Arguments:

    None.
    
Return Value:

    Pointer to per-thread [actually per-fiber] errno value.

--*/
{
    DECLARE_CPU;

    return &cpu->ErrnoVal;
}

BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    )
/*++

Routine Description:

    This routine initializes the fragment library.

Arguments:

    cpu - per-thread CPU data
    StackBase - initial ESP value
    
Return Value:

    True if successful.

--*/
{
    //
    // Initialize the 487 emulator
    //
    FpuInit(cpu);

    //
    // Initialize all non-zero fields in the cpu
    //
    cpu->flag_df = 1;       // direction flag is initially UP
    cpu->flag_if = 1;       // enable interrupts
    ES = SS = DS = KGDT_R3_DATA+3;
    CS = KGDT_R3_CODE+3;
    FS = KGDT_R3_TEB+3;
    esp = StackBase;        // set up the initial ESP value

#if _ALPHA_
    //
    // See if LDB/STB instructions are implemented.
    //
    fByteInstructionsOK = (DWORD)ProxyIsProcessorFeaturePresent(
                                    PF_ALPHA_BYTE_INSTRUCTIONS);
#endif

    return TRUE;
}


DWORD GetEax(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return eax;
}
DWORD GetEbx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ebx;
}
DWORD GetEcx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ecx;
}
DWORD GetEdx(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return edx;
}
DWORD GetEsp(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return esp;
}
DWORD GetEbp(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ebp;
}
DWORD GetEsi(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return esi;
}
DWORD GetEdi(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return edi;
}
DWORD GetEip(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return eip;
}
void SetEax(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    eax = dw;
}
void SetEbx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ebx = dw;
}
void SetEcx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ecx = dw;
}
void SetEdx(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    edx = dw;
}
void SetEsp(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    esp = dw;
}
void SetEbp(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ebp = dw;
}
void SetEsi(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    esi = dw;
}
void SetEdi(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    edi = dw;
}
void SetEip(PVOID CpuContext, DWORD dw)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    eip = dw;
}
VOID SetCs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    CS = us;
}
VOID SetSs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    SS = us;
}
VOID SetDs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    DS = us;
}
VOID SetEs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    ES = us;
}
VOID SetFs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    FS = us;
}
VOID SetGs(PVOID CpuContext, USHORT us)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    GS = us;
}
USHORT GetCs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return CS;
}
USHORT GetSs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return SS;
}
USHORT GetDs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return DS;
}
USHORT GetEs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return ES;
}
USHORT GetFs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return FS;
}
USHORT GetGs(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    return GS;
}
ULONG GetEfl(PVOID CpuContext)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;
    DWORD dw;

    dw = ((GET_CFLAG) ? FLAG_CF : 0)
     | 2
     | 3 << 12     // iopl
     | ((GET_AUXFLAG) ? FLAG_AUX : 0)
     | ((GET_PFLAG) ? FLAG_PF : 0)
     | ((cpu->flag_zf) ? 0 : FLAG_ZF)   // zf has inverse logic
     | ((GET_SFLAG) ? FLAG_SF : 0)
     | ((cpu->flag_tf) ? FLAG_TF : 0)
     | ((cpu->flag_if) ? FLAG_IF : 0)
     | ((cpu->flag_df == -1) ? FLAG_DF : 0)
     | ((GET_OFLAG) ? FLAG_OF : 0)
     | cpu->flag_ac;

    return dw;
}
void  SetEfl(PVOID CpuContext, ULONG RegValue)
{
    PCPUCONTEXT cpu = (PCPUCONTEXT)CpuContext;

    // IOPL, IF, NT, RF, VM, AC ignored.

    SET_CFLAG_IND(RegValue & FLAG_CF);
    cpu->flag_pf = (RegValue & FLAG_PF) ? 0 : 1;    // see ParityBit[] table
    cpu->flag_aux= (RegValue & FLAG_AUX) ? AUX_VAL : 0;
    cpu->flag_zf = (RegValue & FLAG_ZF) ? 0 : 1;    // inverse logic
    SET_SFLAG_IND(RegValue & FLAG_SF);
    cpu->flag_tf = (RegValue & FLAG_TF) ? 1 : 0;
    cpu->flag_df = (RegValue & FLAG_DF) ? -1 : 1;
    SET_OFLAG_IND(RegValue & FLAG_OF);
    cpu->flag_ac = (RegValue & FLAG_AC);
}


#if DBG
VOID
DoAssert(
    PSZ exp,
    PSZ msg,
    PSZ mod,
    INT line
    )
{
    if (msg) {
        LOGPRINT((ERRORLOG, "CPU ASSERTION FAILED:\r\n  %s\r\n%s\r\nFile: %s Line %d\r\n", msg, exp, mod, line));
    } else {
        LOGPRINT((ERRORLOG, "CPU ASSERTION FAILED:\r\n  %s\r\nFile: %s Line %d\r\n", exp, mod, line));
    }

    DbgBreakPoint();
}
#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\lock.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    lock.h

Abstract:
    
    Prototypes for lock instructions

Author:

    15-Aug-1995 t-orig (Ori Gershony)

Revision History:

--*/



// Macros for prototyping the lock helper functions
#define LOCKHELPER0(fn)             ULONG fn ## LockHelper ()
#define LOCKHELPER1(fn,a1)          ULONG fn ## LockHelper (a1)
#define LOCKHELPER2(fn,a1,a2)       ULONG fn ## LockHelper (a1,a2)
#define LOCKHELPER3(fn,a1,a2,a3)    ULONG fn ## LockHelper (a1,a2,a3)
#define LOCKHELPER4(fn,a1,a2,a3,a4) ULONG fn ## LockHelper (a1,a2,a3,a4)


// The lock fragments
FRAG2(LockAddFrag32, ULONG);
FRAG2(LockOrFrag32, ULONG);
FRAG2(LockAdcFrag32, ULONG);
FRAG2(LockSbbFrag32, ULONG);
FRAG2(LockAndFrag32, ULONG);
FRAG2(LockSubFrag32, ULONG);
FRAG2(LockXorFrag32, ULONG);
FRAG1(LockNotFrag32, ULONG);
FRAG1(LockNegFrag32, ULONG);
FRAG1(LockIncFrag32, ULONG);
FRAG1(LockDecFrag32, ULONG);
FRAG2(LockBtsMemFrag32, ULONG);
FRAG2(LockBtsRegFrag32, ULONG);
FRAG2(LockBtrMemFrag32, ULONG);
FRAG2(LockBtrRegFrag32, ULONG);
FRAG2(LockBtcMemFrag32, ULONG);
FRAG2(LockBtcRegFrag32, ULONG);
FRAG2REF(LockXchgFrag32, ULONG);
FRAG2REF(LockXaddFrag32, ULONG);
FRAG2REF(LockCmpXchgFrag32, ULONG);
FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG);


// The lock helper functions
LOCKHELPER3(Add, ULONG *localpop1, ULONG *pop1, ULONG op2); 
LOCKHELPER2(Or, ULONG *pop1, ULONG op2); 
LOCKHELPER4(Adc, ULONG *localpop1, ULONG *pop1, ULONG op2, ULONG carry);
LOCKHELPER4(Sbb, ULONG *localpop1, ULONG *pop1, ULONG op2, ULONG carry);
LOCKHELPER2(And, ULONG *pop1, ULONG op2); 
LOCKHELPER3(Sub, ULONG *localpop1, ULONG *pop1, ULONG op2); 
LOCKHELPER2(Xor, ULONG *pop1, ULONG op2); 
LOCKHELPER1(Not, ULONG *pop1);
LOCKHELPER2(Neg, ULONG *localpop1, ULONG *pop1);
LOCKHELPER2(Bts, ULONG *pop1, ULONG bit);
LOCKHELPER2(Btr, ULONG *pop1, ULONG bit);
LOCKHELPER2(Btc, ULONG *pop1, ULONG bit);
LOCKHELPER2(Xchg, ULONG *pop1, ULONG *pop2);
LOCKHELPER3(Xadd, ULONG *localpop1, ULONG *pop1, ULONG *pop2);
LOCKHELPER4(CmpXchg, ULONG *Reax, ULONG *pop1, ULONG *pop2, ULONG *localpop1);
LOCKHELPER3(CmpXchg8b, ULONGLONG *EaxEcx, ULONGLONG *EcxEdx, ULONGLONG *pop2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\optfrag.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    optfrag.c

Abstract:
    
    Instruction Fragments which correspond to optimizations.

Author:

    6-July-1995 Ori Gershony (t-orig)

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "cpuassrt.h"
#include "fragp.h"
#include "optfrag.h"

ASSERTNAME;

// This fragment corresponds to:
//      push ebx
//      push esi
//      push edi
FRAG0(OPT_PushEbxEsiEdiFrag)
{
    ULONG *espval;

    espval=(ULONG *)esp;

    *(espval-1) = ebx;
    *(espval-2) = esi;
    *(espval-3) = edi;
    esp=(ULONG)(LONGLONG)espval-12;   
}

//  This fragment corresponds to:
//      pop edi
//      pop esi
//      pop ebx
FRAG0(OPT_PopEdiEsiEbxFrag)
{
    ULONG *espval;

    espval=(ULONG *)esp;

    edi=*espval;
    esi=*(espval+1);
    ebx=*(espval+2);
    esp=(ULONG)(LONGLONG)espval+12; 
}

// This fragment corresponds to:
//      push ebp
//      mov ebp,esp
//      sub esp, op1
FRAG1IMM(OPT_SetupStackFrag, ULONG)
{
    ULONG result, oldespminusfour;

    oldespminusfour = esp-4;
    result = oldespminusfour - op1;
    
    *(ULONG *)oldespminusfour = ebp;
    ebp = oldespminusfour;
    esp = result;
    SET_FLAGS_SUB32(result, oldespminusfour, op1, 0x80000000);
}
FRAG1IMM(OPT_SetupStackNoFlagsFrag, ULONG)
{
    ULONG result, oldespminusfour;

    oldespminusfour = esp-4;
    result = oldespminusfour - op1;
    
    *(ULONG *)oldespminusfour = ebp;
    ebp = oldespminusfour;
    esp = result;
}

FRAG1(OPT_ZEROFrag32, LONG)
{
    // implements: XOR samereg, samereg
    //             SUB samereg, samereg
    // ie. XOR EAX, EAX   or SUB ECX, ECX

    *pop1 = 0;
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
    SET_SFLAG_OFF;
    SET_ZFLAG(0);
    SET_PFLAG(0);
    SET_AUXFLAG(0);
}

FRAG1(OPT_ZERONoFlagsFrag32, LONG)
{
    // implements: XOR samereg, samereg
    //             SUB samereg, samereg
    // ie. XOR EAX, EAX   or SUB ECX, ECX

    *pop1 = 0;
}

FRAG3(OPT_CmpSbbFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    result = (ULONG)-(LONG)(cf >> 31);
    *pop1 = result;     // pop1 is a pointer to a reg, so always aligned
    SET_OFLAG_OFF;
    SET_CFLAG(result);
    SET_SFLAG(result);
    SET_ZFLAG(result);
    SET_AUXFLAG(result);
    SET_PFLAG(result);
}
FRAG3(OPT_CmpSbbNoFlagsFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    *pop1 = (ULONG)-(LONG)(cf >> 31);
}
FRAG3(OPT_CmpSbbNegFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //              NEG op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    // pop1 is a pointer to a reg, so it is always aligned
    if (cf >= 0x80000000) {
        result = 1;
        *pop1 = result;         // store the result before updating flags
        SET_CFLAG_ON;           // set if result != 0
        SET_AUXFLAG(0xfe);      // this is (BYTE)(0xffffffff ^ 0x00000001)
    } else {
        result = 0;
        *pop1 = result;         // store the result before updating flags
        SET_CFLAG_OFF;          // cleared if result==0
        SET_AUXFLAG(0);         // this is (BYTE)(0x0 ^ 0x0)
        SET_OFLAG_OFF;          // this is (0x0 & 0x0) << 31
    }
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG_OFF;
    SET_OFLAG_OFF;      // this is either (0xffffffff & 0x00000001) or (0 & 0)
}
FRAG3(OPT_CmpSbbNegNoFlagsFrag32, ULONG, ULONG, ULONG)
{
    ULONG result;
    ULONG cf;

    //
    // implements:  CMP op2, op3
    //              SBB op1, op1
    //              NEG op1
    //
    result = op2-op3;
    cf = (op2 ^ op3 ^ result) ^ ((op2 ^ op3) & (op2 ^ result));
    // result is 1 if high bit of cf is set, 0 if high bit is clear
    *pop1 = cf >> 31;
}

FRAG2IMM(OPT_Push2Frag32, ULONG, ULONG)
{
    //
    // implements:      PUSH op1
    //                  PUSH op2
    // Note that the analysis phase must ensure that the value of op2 does
    // not depend on the value of ESP, as op2 will be computed before the
    // first PUSH is excuted.
    //
    PUSH_LONG(op1);
    PUSH_LONG(op2);
}
FRAG2REF(OPT_Pop2Frag32, ULONG)
{
    //
    // implements:      POP pop1
    //                  POP pop2
    //
    // Note that the analysis phase must ensure that the value of pop2 does
    // not depend on the value of pop1, as pop1 will not have been popped
    // when the value of pop2 is computed.
    //
    POP_LONG(*pop1);
    POP_LONG(*pop2);
}

FRAG1(OPT_CwdIdivFrag16, USHORT)
{
    short op1;
    short result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (short)GET_SHORT(pop1);
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (short)ax / op1;

    dx = (short)ax % op1;
    ax = result;
}
FRAG1(OPT_CwdIdivFrag16A, USHORT)
{
    short op1;
    short result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (short)*pop1;
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (short)ax / op1;

    dx = (short)ax % op1;
    ax = result;
}

FRAG1(OPT_CwdIdivFrag32, ULONG)
{
    long op1;
    long result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (long)GET_LONG(pop1);
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (long)eax / op1;

    edx = (long)eax % op1;
    eax = result;
}
FRAG1(OPT_CwdIdivFrag32A, ULONG)
{
    long op1;
    long result;

    //
    // implements:      CWD
    //                  IDIV EAX, *pop1
    // The CWD sign-extends EAX into EDX:EAX, which means, we can
    // avoid a 64-bit division and just divide EAX.  There is no
    // possibility of overflow.
    //
    op1 = (long)*pop1;
    // Must do the divide before modifying edx, in case op1==0 and we fault.
    result = (long)eax / op1;

    edx = (long)eax % op1;
    eax = result;
}

//  This fragment should never be called!
FRAG0(OPT_OPTIMIZEDFrag)
{
    CPUASSERTMSG(FALSE, "OPTIMIZED fragment should never be called!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shr1632.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    shr1632.c

Abstract:
    
    Instruction fragments with common (shared) WORD, and DWORD flavors
    (but not BYTE).

Author:

    12-Jun-1995 BarryBo

Revision History:
        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wx86.h"
#include "wx86nt.h"
#include "shr1632.h"

FRAGCOMMON0(PushfFrag)
{
    UTYPE dw;

    dw =   ((GET_CFLAG) ? FLAG_CF : 0)
        | 2
        | ((GET_AUXFLAG) ? FLAG_AUX : 0)  // The auxflag is special
        | ((GET_PFLAG) ? FLAG_PF : 0)
        | ((cpu->flag_zf) ? 0 : FLAG_ZF)  // zf has inverse logic
        | ((GET_SFLAG) ? FLAG_SF : 0)
        | ((cpu->flag_tf) ? FLAG_TF : 0)
        | FLAG_IF
        | ((cpu->flag_df == -1) ? FLAG_DF : 0)
        | ((GET_OFLAG) ? FLAG_OF : 0)
#if MSB==0x80000000
        | cpu->flag_ac
        | cpu->flag_id
        // VM and RF bits are both 0
#endif
        ;
    PUSH_VAL(dw);
}
FRAGCOMMON0(PopfFrag)
{
    UTYPE dw;

    POP_VAL(dw);
    // ignore: FLAG_NT, FLAG_RF, FLAG_VM, IOPL
    SET_CFLAG_IND (dw & FLAG_CF);
    cpu->flag_pf = (dw & FLAG_PF) ? 0 : 1;  // pf is an index into the ParityBit[] array
    cpu->flag_aux= (dw & FLAG_AUX) ? AUX_VAL : 0;
    cpu->flag_zf = (dw & FLAG_ZF) ? 0 : 1;  // zf has inverse logic
    SET_SFLAG_IND (dw & FLAG_SF);
    cpu->flag_tf = (dw & FLAG_TF) ? 1 : 0;
    cpu->flag_df = (dw & FLAG_DF) ? -1 : 1;
    SET_OFLAG_IND (dw & FLAG_OF);
#if MSB==0x80000000
    cpu->flag_ac = (dw & FLAG_AC);
    cpu->flag_id = (dw & FLAG_ID);
#endif
}
FRAGCOMMON0(PushAFrag)
{
    // can't use PUSH_VAL() as ESP cannot be updated until after we're sure
    // things can't fault
    *(UTYPE *)(esp-sizeof(UTYPE)) = AREG;
    *(UTYPE *)(esp-2*sizeof(UTYPE)) = CREG;
    *(UTYPE *)(esp-3*sizeof(UTYPE)) = DREG;
    *(UTYPE *)(esp-4*sizeof(UTYPE)) = BREG;
    *(UTYPE *)(esp-5*sizeof(UTYPE)) = SPREG;
    *(UTYPE *)(esp-6*sizeof(UTYPE)) = BPREG;
    *(UTYPE *)(esp-7*sizeof(UTYPE)) = SIREG;
    *(UTYPE *)(esp-8*sizeof(UTYPE)) = DIREG;
    esp -= 8*sizeof(UTYPE);
}
FRAGCOMMON0(PopAFrag)
{
    // can't use POP_VAL() as ESP cannot be updated untile after we're sure
    // things can't fault
    DIREG = *(UTYPE *)(esp);
    SIREG = *(UTYPE *)(esp+sizeof(UTYPE));
    BPREG = *(UTYPE *)(esp+2*sizeof(UTYPE));
    // ignore [E]SP register image on the stack
    BREG = *(UTYPE *)(esp+4*sizeof(UTYPE));
    DREG = *(UTYPE *)(esp+5*sizeof(UTYPE));
    CREG = *(UTYPE *)(esp+6*sizeof(UTYPE));
    AREG = *(UTYPE *)(esp+7*sizeof(UTYPE));
    esp += 8*sizeof(UTYPE);
}
FRAGCOMMON1IMM(PushFrag)
{
    PUSH_VAL(op1);
}
FRAGCOMMON0(CwdFrag)
{
    DREG = (AREG & MSB) ? (UTYPE)0xffffffff : 0;
}
FRAGCOMMON2(BoundFrag)
{
    if ((op2 < GET_VAL(pop1)) ||
        (op2 > (GET_VAL( (ULONG)(ULONGLONG)(pop1) + sizeof(UTYPE))))) {   

           Int5(); // raise BOUND exception
    }
}
FRAGCOMMON2IMM(EnterFrag)
{
    BYTE level;
    DWORD frameptr;
    DWORD espTemp;

    level = (BYTE)(op1 % 32);
    espTemp = esp - sizeof(UTYPE);
    *(UTYPE *)(espTemp) = BPREG;  // can't use PUSH_VAL because esp can't be changed
    frameptr = espTemp;
    if (level) {
        BYTE i;
        DWORD ebpTemp = ebp;
        for (i=1; i<= level-1; ++i) {
            ebpTemp -= sizeof(UTYPE);
            espTemp -= sizeof(UTYPE);
            *(UTYPE *)espTemp =  (UTYPE)ebpTemp;
        }
        espTemp-=sizeof(UTYPE);
        *(DWORD *)espTemp = frameptr;
    }
    ebp = frameptr;
    esp = espTemp-op2;
}
FRAGCOMMON0(LeaveFrag)
{
    DWORD espTemp;

    espTemp = ebp;
    BPREG = *(UTYPE *)espTemp;
    esp = espTemp + sizeof(UTYPE);
}
FRAGCOMMON2(LesFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    ES = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LdsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    DS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LssFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    SS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LfsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    FS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
    //UNDONE: what about the selector base for FS?
}
FRAGCOMMON2(LgsFrag)
{
    *pop1 = GET_VAL(op2);       // pop1 is always a ptr to a register
    GS = GET_SHORT(op2+sizeof(UTYPE));
    //UNDONE: fault if segment register not loaded with correct value?
}
FRAGCOMMON2(LslFrag)
{
    //
    // pop1 is a pointer to a register, so can use aligned code
    //

    op2 &= ~3;      // mask off RPL bits
    if (op2 == KGDT_R3_CODE ||          // CS: selector
        op2 == KGDT_R3_DATA             // DS:, SS:, ES: selector
       ) {
        *pop1 = (UTYPE)-1;          // limit=0xffffffff
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_TEB) {
        *pop1 = 0xfff;              // limit=0xfff (1 x86 page)
        SET_ZFLAG(0);               // ZF=1
    } else {
        SET_ZFLAG(1);               // ZF=0
    }
}
FRAGCOMMON2(LarFrag)
{
    //
    // pop1 is a pointer to a register, so can use aligned code
    //

    op2 &= ~3;      // mask off RPL bits
    if (op2 == KGDT_R3_CODE) {
        *pop1 = (UTYPE)0xcffb00;
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_DATA) {
        *pop1 = (UTYPE)0xcff300;
        SET_ZFLAG(0);               // ZF=1
    } else if (op2 == KGDT_R3_TEB) {
        *pop1 = (UTYPE)0x40f300;
        SET_ZFLAG(0);               // ZF=1
    } else {
        SET_ZFLAG(1);               // ZF=0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shared.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shared.h

Abstract:
    
    Prototypes for instruction fragments shared between 8, 16, and 32-bit.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef SHARED_H checks.

FRAGCOMMON1IMM(OPT_FastTestFrag);
FRAGCOMMON2IMM(CmpFrag);
FRAGCOMMON2IMM(TestFrag);
FRAGCOMMON0(LodsFrag);
FRAGCOMMON0(RepLodsFrag);
FRAGCOMMON0(FsLodsFrag);
FRAGCOMMON0(FsRepLodsFrag);
FRAGCOMMON0(ScasFrag);
FRAGCOMMON0(ScasNoFlagsFrag);
FRAGCOMMON0(RepzScasFrag);
FRAGCOMMON0(RepzScasNoFlagsFrag);
FRAGCOMMON0(RepnzScasFrag);
FRAGCOMMON0(RepnzScasNoFlagsFrag);
FRAGCOMMON0(FsScasFrag);
FRAGCOMMON0(FsScasNoFlagsFrag);
FRAGCOMMON0(FsRepzScasFrag);
FRAGCOMMON0(FsRepzScasNoFlagsFrag);
FRAGCOMMON0(FsRepnzScasFrag);
FRAGCOMMON0(FsRepnzScasNoFlagsFrag);
FRAGCOMMON0(StosFrag);
FRAGCOMMON0(RepStosFrag);
FRAGCOMMON0(MovsFrag);
FRAGCOMMON0(RepMovsFrag);
FRAGCOMMON0(FsMovsFrag);
FRAGCOMMON0(FsRepMovsFrag);
FRAGCOMMON0(CmpsFrag);
FRAGCOMMON0(RepzCmpsFrag);
FRAGCOMMON0(RepnzCmpsFrag);
FRAGCOMMON0(FsCmpsFrag);
FRAGCOMMON0(FsRepzCmpsFrag);
FRAGCOMMON0(FsRepnzCmpsFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shared.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shared.c

Abstract:
    
    Instruction fragments with common (shared) BYTE, WORD, and DWORD flavors.

Author:

    12-Jun-1995 BarryBo

Revision History:

--*/


// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MSB          - most significant bit
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL      - writes a value into memory
// FRAGCOMMON{0,1,2}  - mangles the function name and declares parameters
// AREG     - al/ax/eax
// BREG     - ...
// CREG     - ...
// DREG     - ...

FRAGCOMMON1IMM(OPT_FastTestFrag)
{
    SET_ZFLAG(op1);
    SET_PFLAG(op1);
    SET_SFLAG(op1 << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}

FRAGCOMMON2IMM(CmpFrag)
{
    UTYPE result;

    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
}

FRAGCOMMON2IMM(TestFrag)
{
    UTYPE result;

    result = op1 & op2;
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}


FRAGCOMMON0(RepMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    while (ecx) {
        PUT_VAL(edi, GET_VAL(esi));
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(FsRepMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();

    while (ecx) {
        PUT_VAL(edi, GET_VAL(esi + Base));
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(MovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    PUT_VAL(edi, GET_VAL(esi));
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(FsMovsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    PUT_VAL(edi, GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb())); 
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(RepnzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb(); 
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi + Base);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op1, op2;

    while (ecx) {
        op1 = GET_VAL(esi + Base);
        op2 = GET_VAL(edi);
        result = op1 - op2;
        SET_FLAGS_SUB(result, op1, op2, MSB);
        esi += LoopIncr;
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(CmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    op1 = GET_VAL(esi);
    op2 = GET_VAL(edi);
    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(FsCmpsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op1, op2;

    op1 = GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb()); 
    op2 = GET_VAL(edi);
    result = op1 - op2;
    SET_FLAGS_SUB(result, op1, op2, MSB);
    esi += LoopIncr;
    edi += LoopIncr;
}
FRAGCOMMON0(RepStosFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE Value = AREG;

    while (ecx) {
        PUT_VAL(edi, Value);
        edi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(StosFrag)
{
    PUT_VAL(edi, AREG);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(RepnzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {        // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepnzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result == 0) {        // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepnzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result == 0) {    // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(RepzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzScasFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        SET_FLAGS_SUB(result, Value, op2, MSB);
        edi += LoopIncr;
        ecx--;
        if (cpu->flag_zf) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(FsRepzScasNoFlagsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  
    UTYPE result, op2;
    UTYPE Value = AREG;

    while (ecx) {
        op2 = GET_VAL(edi + Base);
        result = Value - op2;
        edi += LoopIncr;
        ecx--;
        if (result) {     // inverse logic
            break;
        }
    }
}
FRAGCOMMON0(ScasFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi);
    result = AREG - op2;
    SET_FLAGS_SUB(result, AREG, op2, MSB);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(ScasNoFlagsFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi);
    result = AREG - op2;
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsScasFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    result = AREG - op2;
    SET_FLAGS_SUB(result, AREG, op2, MSB);
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsScasNoFlagsFrag)
{
    UTYPE result, op2;

    op2 = GET_VAL(edi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    result = AREG - op2;
    edi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(LodsFrag)
{
    AREG = GET_VAL(esi);
    esi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(FsLodsFrag)
{
    AREG = GET_VAL(esi + (DWORD)(ULONGLONG)NtCurrentTeb());  
    esi += sizeof(UTYPE)*cpu->flag_df;
}
FRAGCOMMON0(RepLodsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;

    while (ecx) {
        AREG = GET_VAL(esi);
        esi += LoopIncr;
        ecx--;
    }
}
FRAGCOMMON0(FsRepLodsFrag)
{
    DWORD LoopIncr = sizeof(UTYPE)*cpu->flag_df;
    DWORD Base = (DWORD)(ULONGLONG)NtCurrentTeb();  

    while (ecx) {
        AREG = GET_VAL(esi + Base);
        esi += LoopIncr;
        ecx--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\optfrag.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    optfrag.h

Abstract:
    
    Prototypes for misc. instruction fragments.

Author:

    6-July-1995 Ori Gershony (t-orig)

Revision History:

--*/

FRAG0(OPT_PushEbxEsiEdiFrag);
FRAG0(OPT_PopEdiEsiEbxFrag);
FRAG1IMM(OPT_SetupStackFrag, ULONG);
FRAG1IMM(OPT_SetupStackNoFlagsFrag, ULONG);
FRAG1(OPT_ZEROFrag32, LONG);
FRAG1(OPT_ZERONoFlagsFrag32, LONG);
FRAG3(OPT_CmpSbbFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNoFlagsFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNegFrag32, ULONG, ULONG, ULONG);
FRAG3(OPT_CmpSbbNegNoFlagsFrag32, ULONG, ULONG, ULONG);
FRAG2IMM(OPT_Push2Frag32, ULONG, ULONG);
FRAG2REF(OPT_Pop2Frag32, ULONG);
FRAG1(OPT_CwdIdivFrag16, USHORT);
FRAG1(OPT_CwdIdivFrag16A, USHORT);
FRAG1(OPT_CwdIdivFrag32, ULONG);
FRAG1(OPT_CwdIdivFrag32A, ULONG);
FRAG0(OPT_OPTIMIZEDFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shareda.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shareda.h

Abstract:
    
    Prototypes for instruction fragments shared between 8, 16, and 32-bit,
    with ALIGNED and UNALIGNED flavors.

Author:

    05-Nov-1995 BarryBo, Created

Revision History:

--*/

// WARNING: This file may be included multiple times by a single source file,
// WARNING: so don't add #ifndef SHARED_H checks.

FRAGCOMMON2(AddFrag);
FRAGCOMMON2(AddNoFlagsFrag);
FRAGCOMMON1(IncFrag);
FRAGCOMMON1(IncNoFlagsFrag);
FRAGCOMMON1(DecFrag);
FRAGCOMMON1(DecNoFlagsFrag);
FRAGCOMMON2(OrFrag);
FRAGCOMMON2(OrNoFlagsFrag);
FRAGCOMMON2(AdcFrag);
FRAGCOMMON2(AdcNoFlagsFrag);
FRAGCOMMON2(SbbFrag);
FRAGCOMMON2(SbbNoFlagsFrag);
FRAGCOMMON2(AndFrag);
FRAGCOMMON2(AndNoFlagsFrag);
FRAGCOMMON2(SubFrag);
FRAGCOMMON2(SubNoFlagsFrag);
FRAGCOMMON2(XorFrag);
FRAGCOMMON2(XorNoFlagsFrag);
FRAGCOMMON2REF(XchgFrag);
FRAGCOMMON2(RolFrag);
FRAGCOMMON2(RorFrag);
FRAGCOMMON2(RclFrag);
FRAGCOMMON2(RcrFrag);
FRAGCOMMON2(ShlFrag);
FRAGCOMMON2(ShlNoFlagsFrag);
FRAGCOMMON2(ShrFrag);
FRAGCOMMON2(ShrNoFlagsFrag);
FRAGCOMMON2(SarFrag);
FRAGCOMMON2(SarNoFlagsFrag);
FRAGCOMMON1(Rol1Frag);
FRAGCOMMON1(Rol1NoFlagsFrag);
FRAGCOMMON1(Ror1Frag);
FRAGCOMMON1(Ror1NoFlagsFrag);
FRAGCOMMON1(Rcl1Frag);
FRAGCOMMON1(Rcl1NoFlagsFrag);
FRAGCOMMON1(Rcr1Frag);
FRAGCOMMON1(Rcr1NoFlagsFrag);
FRAGCOMMON1(Shl1Frag);
FRAGCOMMON1(Shl1NoFlagsFrag);
FRAGCOMMON1(Shr1Frag);
FRAGCOMMON1(Shr1NoFlagsFrag);
FRAGCOMMON1(Sar1Frag);
FRAGCOMMON1(Sar1NoFlagsFrag);
FRAGCOMMON1(NotFrag);
FRAGCOMMON1(NegFrag);
FRAGCOMMON1(NegNoFlagsFrag);
FRAGCOMMON1(MulFrag);
FRAGCOMMON1(MulNoFlagsFrag);
FRAGCOMMON1(MuliFrag);
FRAGCOMMON1(MuliNoFlagsFrag);
FRAGCOMMON1(DivFrag);
FRAGCOMMON1(IdivFrag);
FRAGCOMMON2REF(XaddFrag);
FRAGCOMMON2REF(XaddNoFlagsFrag);
FRAGCOMMON2REF(CmpXchgFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shr1632.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632.h

Abstract:
    
    Prototypes for instruction fragments shared between 16 and 32 bits.

Author:

    12-Jun-1995 BarryBo, Created

Revision History:

--*/

FRAGCOMMON0(PushfFrag);
FRAGCOMMON0(PopfFrag);
FRAGCOMMON0(PushAFrag);
FRAGCOMMON0(PopAFrag);
FRAGCOMMON1IMM(PushFrag);
FRAGCOMMON0(CwdFrag);
FRAGCOMMON2(BoundFrag);
FRAGCOMMON2IMM(EnterFrag);
FRAGCOMMON0(LeaveFrag);
FRAGCOMMON2(LesFrag);
FRAGCOMMON2(LdsFrag);
FRAGCOMMON2(LssFrag);
FRAGCOMMON2(LfsFrag);
FRAGCOMMON2(LgsFrag);
FRAGCOMMON2(LslFrag);
FRAGCOMMON2(LarFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shr1632a.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632a.h

Abstract:
    
    Prototypes for instruction fragments shared between 16 and 32 bits, with
    ALIGNED an UNALIGNED flavors.

Author:

    05-Nov-1995 BarryBo, Created

Revision History:

--*/

FRAGCOMMON2(BtRegFrag);
FRAGCOMMON2(BtsRegFrag);
FRAGCOMMON2(BtcRegFrag);
FRAGCOMMON2(BtrRegFrag);
FRAGCOMMON2(BtMemFrag);
FRAGCOMMON2(BtsMemFrag);
FRAGCOMMON2(BtcMemFrag);
FRAGCOMMON2(BtrMemFrag);
FRAGCOMMON3(ShldFrag);
FRAGCOMMON3(ShrdFrag);
FRAGCOMMON3(ShldNoFlagsFrag);
FRAGCOMMON3(ShrdNoFlagsFrag);
FRAGCOMMON2(BsfFrag);
FRAGCOMMON2(BsrFrag);
FRAGCOMMON1(PopFrag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shr1632a.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shr1632a.c

Abstract:
    
    Instruction fragments with common (shared) WORD, and DWORD flavors
    (but not BYTE).

    Compiled twice per flavor, once with UNALIGNED and once with ALIGNED
    pointers.

Author:

    05-Nov-1995 BarryBo

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "shr1632a.h"

FRAGCOMMON2(BtMemFrag)
{
    UTYPE bit = 1<<(op2&LMB);

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    SET_CFLAG_IND(GET_VAL(pop1+op2) & bit);
}
FRAGCOMMON2(BtsMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1|bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtcMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, op1 ^ bit);
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtrMemFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op2 /= LMB+1;   // compute offset of the correct WORD/DWORD
    pop1 += op2;
    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1&(~bit)));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtRegFrag)
{
    UTYPE bit = 1<<(op2&LMB);

    SET_CFLAG_IND(GET_VAL(pop1) & bit);
}
FRAGCOMMON2(BtsRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1|bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtcRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1 ^ bit));
    SET_CFLAG_IND(NewCFlag);
}
FRAGCOMMON2(BtrRegFrag)
{
    DWORD NewCFlag;
    UTYPE bit = 1<<(op2&LMB);
    UTYPE op1;

    op1 = GET_VAL(pop1);

    NewCFlag = op1 & bit;
    // Intel docs indicate that we can safely overwrite all 2/4 bytes
    // when writing the value back out.  (pg. 26/43)
    PUT_VAL(pop1, (op1&(~bit)));
    SET_CFLAG_IND(NewCFlag);
}

FRAGCOMMON3(ShldFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    DWORD NewCFlag;
    UTYPE Base;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);
    NewCFlag = Base & (1<<(LMB+1-op3));     // Get the new CF value

    Base <<= op3;               // shift Base left
    op2 >>= LMB+1-op3;          // shift the top op3 bits of op2 right
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
    SET_CFLAG_IND(NewCFlag);
    SET_ZFLAG(Base);
    SET_PFLAG(Base);
    SET_SFLAG(Base << (31-LMB));
}
FRAGCOMMON3(ShldNoFlagsFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    UTYPE Base;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);

    Base <<= op3;               // shift Base left
    op2 >>= LMB+1-op3;          // shift the top op3 bits of op2 right
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
}
FRAGCOMMON3(ShrdFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    DWORD NewCFlag;
    UTYPE Base;
    int i;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);
    NewCFlag = Base & (1<<(op3-1));     // Get the new CF value

    Base >>= op3;               // shift Base right
    op2 <<= LMB+1-op3;          // shift the low op3 bits of op2
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
    SET_CFLAG_IND(NewCFlag);
    SET_ZFLAG(Base);
    SET_PFLAG(Base);
    SET_SFLAG(Base << (31-LMB));
}
FRAGCOMMON3(ShrdNoFlagsFrag)
{
    // pop1 = Base   -- ptr to dest reg/mem
    // op2  = inBits -- value of register containing bits to shift into Base
    // op3  = count  -- number of bits to shift


    UTYPE Base;
    int i;

    if (op3 == 0) {
        return;         // nothing to do - nop with all flags preserved
    }
    op3 &= 0x1f;        // make the count MOD 32 (now op3 = ShiftAmt)
#if MSB == 0x8000
    if (op3 > 16) {
        // Bad parameters - *pop1 UNDEFINED!
        //                - CF,OF,SF,ZF,AF,PF UNDEFINED!
        return;
    }
#endif

    Base = GET_VAL(pop1);

    Base >>= op3;               // shift Base right
    op2 <<= LMB+1-op3;          // shift the low op3 bits of op2
    Base |= op2;                // merge the two together
    PUT_VAL(pop1, Base);
}
FRAGCOMMON2(BsfFrag)
{
    int i;

    if (op2 == 0) {
        // value is 0 - set ZFLAG and return
        SET_ZFLAG(0);
        // *pop1 = UNDEFINED
        return;
    }

    // scan from bit 0 forward, looking for the index of '1' bit
    for (i=0; (op2 & 1) == 0; ++i) {
        op2 >>= 1;
    }

    // write the index of the '1' bit and clear the ZFLAG
    PUT_VAL(pop1, i);
    SET_ZFLAG(op2);
}
FRAGCOMMON2(BsrFrag)
{
    int i;

    if (op2 == 0) {
        // value is 0 - set ZFLAG and return
        SET_ZFLAG(0);
        // *pop1 = UNDEFINED
        return;
    }

    // scan from bit 31/15 downward, looking for the index of '1' bit
    for (i=LMB; (op2 & MSB) == 0; --i) {
        op2 <<= 1;
    }

    // write the index of the '1' bit and clear the ZFLAG
    PUT_VAL(pop1, i);
    SET_ZFLAG(op2);
}
FRAGCOMMON1(PopFrag)
{
    POP_VAL(GET_VAL(pop1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\shareda.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    shareda.c

Abstract:
    
    Instruction fragments with common (shared) BYTE, WORD, and DWORD flavors.
    Compiled twice per flavor, once with UNALIGNED and once with ALIGNED
    pointers.

Author:

    05-Nov-1995 BarryBo

Revision History:

--*/


// THIS FILE IS #include'd INTO FILES WHICH DEFINE THE FOLLOWING MACROS:
// MSB          - most significant bit
// UTYPE    - UNSIGNED type which defines registers (BYTE/USHORT/DWORD)
// STYPE    -   SIGNED type which defines registers (char/short/long)
// GET_VAL  - dereference a pointer of the right type (GET_BYTE/...)
// PUT_VAL      - writes a value into memory
// FRAGCOMMON{0,1,2}  - mangles the function name and declares parameters
// AREG     - al/ax/eax
// BREG     - ...
// CREG     - ...
// DREG     - ...

FRAGCOMMON2(AddFrag)
{
    UTYPE result;
    UTYPE op1 = GET_VAL(pop1);

    result = op1 + op2;
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2(AddNoFlagsFrag)
{
    UTYPE result;
    UTYPE op1 = GET_VAL(pop1);

    result = op1 + op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(IncFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1+1;
    PUT_VAL(pop1, result);
    SET_FLAGS_INC(result, op1);
}
FRAGCOMMON1(IncNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1+1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(DecFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1-1;
    PUT_VAL(pop1, result);
    SET_FLAGS_DEC(result, op1);
}
FRAGCOMMON1(DecNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1-1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(OrFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1 | op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(OrNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = op1 | op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(AdcFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 + op2 + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2(AdcNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 + op2 + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(SbbFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2 - (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}
FRAGCOMMON2(SbbNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2 - (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(AndFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 & op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(AndNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 & op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(SubFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2;
    PUT_VAL(pop1, result);
    SET_FLAGS_SUB(result, op1, op2, MSB);
}
FRAGCOMMON2(SubNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result = op1 - op2;
    PUT_VAL(pop1, result);
}
FRAGCOMMON2(XorFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result  = op1 ^ op2;
    PUT_VAL(pop1, result);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_SFLAG(result << (31-LMB));
    SET_CFLAG_OFF;
    SET_OFLAG_OFF;
}
FRAGCOMMON2(XorNoFlagsFrag)
{
    UTYPE result, op1;

    op1 = GET_VAL(pop1);
    result  = op1 ^ op2;
    PUT_VAL(pop1, result);
}
// Note:  both pop1 and pop2 are given by reference
FRAGCOMMON2REF(XchgFrag)
{
    XCHG_MEM(UTYPE, pop1, pop2);
}
FRAGCOMMON2REF(XaddFrag)
{
    UTYPE op1, op2, result;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);
    result = op1+op2;

    PUT_VAL(pop2, op1);
    PUT_VAL(pop1, result);
    SET_FLAGS_ADD(result, op1, op2, MSB);
}
FRAGCOMMON2REF(XaddNoFlagsFrag)
{
    UTYPE op1, op2, result;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);
    result = op1+op2;

    PUT_VAL(pop2, op1);
    PUT_VAL(pop1, result);
}
FRAGCOMMON2REF(CmpXchgFrag)
{
    UTYPE op1, op2;
    UTYPE Value = AREG;

    op1 = GET_VAL(pop1);
    op2 = GET_VAL(pop2);

    SET_FLAGS_SUB(Value-op1, Value, op1, MSB);

    if (Value == op1) {
        PUT_VAL(pop1, op2);
        SET_ZFLAG(0);       // zf has inverse logic
    } else {
        AREG = op1;
        SET_ZFLAG(1);       // zf has inverse logic
    }
}
FRAGCOMMON2(RolFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
        b = _rotl(b, op2);      // an instrinsic rotlw instruction on PPC
#else
        b = (b << op2) | (b >> (LMB-op2+1));
#endif

        PUT_VAL(pop1, b);
        SET_CFLAG((DWORD)b << 31);
    }
}
FRAGCOMMON2(RorFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
        b = _rotr(b, op2);      // an instrinsic rotlw instruction on PPC
#else
        b = (b >> op2) | (b << (LMB-op2+1));
#endif
        PUT_VAL(pop1, b)
        SET_CFLAG((DWORD)b << (31-LMB));
    }
}
FRAGCOMMON2(RclFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;
        DWORD temp_cf;

        b = GET_VAL(pop1);
        temp_cf = (DWORD)b << (31-LMB+op2-1);
        b = (b << op2) | (b >> (LMB-op2+2)) | ((UTYPE)GET_CFLAGZO << (op2-1));
        PUT_VAL(pop1, b);
        SET_CFLAG(temp_cf);
    }
}
FRAGCOMMON2(RcrFrag)
{
    op2 &= LMB;
    if (op2) {
        UTYPE b;
        DWORD temp_cf;

        b = GET_VAL(pop1);
        temp_cf = (DWORD)b << (32-op2);
        b = (b << (LMB-op2+2)) | (b >> op2) | (UTYPE)((GET_CFLAGZO) << (LMB-op2+1));
        PUT_VAL(pop1, b)
        SET_CFLAG(temp_cf);
    }
}
FRAGCOMMON2(ShlFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;
        UTYPE newb;

        b = GET_VAL(pop1);
        b <<= (op2-1);
        newb = b << 1;
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << (31-LMB));
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG(newb << (31-LMB));
    }
}
FRAGCOMMON2(ShlNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
        b <<= op2;
        PUT_VAL(pop1, b);
    }
}
FRAGCOMMON2(ShrFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;
        UTYPE newb;

        b = GET_VAL(pop1);
        b >>= (op2-1);
        newb = b >> 1;
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << 31);
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG_OFF;
    }
}
FRAGCOMMON2(ShrNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b;

        b = GET_VAL(pop1);
        b >>= op2;
        PUT_VAL(pop1, b);
    }
}
FRAGCOMMON2(SarFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b, temp, newb;

        b = GET_VAL(pop1);
        temp = b & MSB;
        b >>= (op2-1);
        newb = b >> 1;
        if (temp) {
            newb |= ~((1u << (LMB-op2+1))-1u);
        }
        PUT_VAL(pop1, newb);
        SET_CFLAG((DWORD)b << 31);
        SET_ZFLAG(newb);
        SET_PFLAG(newb);
        SET_SFLAG(newb << (31-LMB));
    }
}
FRAGCOMMON2(SarNoFlagsFrag)
{
    op2 &= 0x1f;
    if (op2) {
        UTYPE b, temp, newb;

        b = GET_VAL(pop1);
        temp = b & MSB;
        newb = b >> op2;
        if (temp) {
            newb |= ~((1u << (LMB-op2+1))-1u);
        }
        PUT_VAL(pop1, newb);
    }
}
FRAGCOMMON1(Rol1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
#if _PPC_ && (LMB==31)
    b = _rotl(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    b = (b<<1) + (b >> LMB);
#endif
    PUT_VAL(pop1, b);
    SET_CFLAG((DWORD)temp_cf << (31-LMB));
    SET_OFLAG((DWORD)(temp_cf ^ b) << (31-LMB));
}
FRAGCOMMON1(Rol1NoFlagsFrag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
#if _PPC_ && (LMB==31)
    b = _rotl(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    b = (b<<1) + (b >> LMB);
#endif
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Ror1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
    newb = _rotr(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    newb = (b >> 1) | (b << LMB);
#endif
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << 31);
    SET_OFLAG((DWORD)((newb>>LMB) ^ (newb>>(LMB-1)) & 1) << 31);   // xor top 2 bits together
}
FRAGCOMMON1(Ror1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
#if _PPC_ && (LMB==31)
    newb = _rotr(b, 1);      // an instrinsic rotlw instruction on PPC
#else
    newb = (b >> 1) | (b << LMB);
#endif
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Rcl1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & MSB;
    b = (b<<1) + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, b);
    SET_CFLAG(temp_cf << (31-LMB));
    SET_OFLAG((DWORD)(temp_cf ^ b) << (31-LMB));
}
FRAGCOMMON1(Rcl1NoFlagsFrag)
{
    UTYPE b;

    b = GET_VAL(pop1);
    b = (b<<1) + (UTYPE)GET_CFLAGZO;
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Rcr1Frag)
{
    UTYPE b, temp_cf;

    b = GET_VAL(pop1);
    temp_cf = b & 1;
    b = (b >> 1) + (UTYPE)((cpu->flag_cf & 0x80000000) >> (31-LMB));
    PUT_VAL(pop1, b);
    SET_CFLAG((DWORD)temp_cf << 31);
    SET_OFLAG(((DWORD)b << (31-LMB)) ^ ((DWORD)b << (31-LMB+1))); // xor top 2 bits together
}
FRAGCOMMON1(Rcr1NoFlagsFrag)
{
    UTYPE b;

    b = GET_VAL(pop1);
    b = (b >> 1) + (UTYPE)((cpu->flag_cf & 0x80000000) >> (31-LMB));
    PUT_VAL(pop1, b);
}
FRAGCOMMON1(Shl1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b << 1;
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << (31-LMB));
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG(newb << (31-LMB));
    SET_OFLAG(GET_CFLAG ^ GET_SFLAG);
}
FRAGCOMMON1(Shl1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b << 1;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Shr1Frag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b >> 1;
    PUT_VAL(pop1, newb);
    SET_OFLAG((DWORD)b << (31-LMB));
    SET_CFLAG((DWORD)b << 31);
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG_OFF;
}
FRAGCOMMON1(Shr1NoFlagsFrag)
{
    UTYPE b, newb;

    b = GET_VAL(pop1);
    newb = b >> 1;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(Sar1Frag)
{
    UTYPE b, temp, newb;

    b = GET_VAL(pop1);
    temp = b & MSB;
    newb = (b >> 1) + temp;
    PUT_VAL(pop1, newb);
    SET_CFLAG((DWORD)b << 31);
    SET_ZFLAG(newb);
    SET_PFLAG(newb);
    SET_SFLAG(newb << (31-LMB));
    SET_OFLAG_OFF;
}
FRAGCOMMON1(Sar1NoFlagsFrag)
{
    UTYPE b, temp, newb;

    b = GET_VAL(pop1);
    temp = b & MSB;
    newb = (b >> 1) + temp;
    PUT_VAL(pop1, newb);
}
FRAGCOMMON1(NotFrag)
{
    PUT_VAL(pop1, ~GET_VAL(pop1));
}
FRAGCOMMON1(NegFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = (UTYPE)-(STYPE)op1;
    PUT_VAL(pop1, result);
    SET_CFLAG_IND(result != 0);
    SET_ZFLAG(result);
    SET_PFLAG(result);
    SET_AUXFLAG(op1 ^ result);
    SET_SFLAG(result << (31-LMB));
    SET_OFLAG((DWORD)(op1 & result) << (31-LMB));
}
FRAGCOMMON1(NegNoFlagsFrag)
{
    UTYPE op1, result;

    op1 = GET_VAL(pop1);
    result = (UTYPE)-(STYPE)op1;
    PUT_VAL(pop1, result);
}
FRAGCOMMON1(MulFrag)
{
#if MSB == 0x80
    USHORT result;

    result = (USHORT)al * (USHORT)GET_BYTE(pop1);
    if (result <= 0xff) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = result;
#elif MSB == 0x8000
    ULONG result;

    result = (ULONG)ax * (ULONG)GET_SHORT(pop1);
    if (result <= 0xffff) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;

    result = RtlEnlargedUnsignedMultiply(eax, GET_LONG(pop1));
    if (result.HighPart == 0) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    eax = result.LowPart;
    edx = result.HighPart;
#endif
} 
FRAGCOMMON1(MulNoFlagsFrag)
{
#if MSB == 0x80
    USHORT result;

    result = (USHORT)al * (USHORT)GET_BYTE(pop1);
    ax = result;
#elif MSB == 0x8000
    ULONG result;

    result = (ULONG)ax * (ULONG)GET_SHORT(pop1);
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;

    result = RtlEnlargedUnsignedMultiply(eax, GET_LONG(pop1));
    eax = result.LowPart;
    edx = result.HighPart;
#endif
} 
FRAGCOMMON1(MuliFrag)
{
#if MSB == 0x80
    SHORT result;

    result = (short)(char)al * (short)(char)GET_BYTE(pop1);
    if ((result & 0xff80) == 0 || (result & 0xff80) == 0xff80) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = result;
#elif MSB == 0x8000
    LONG result;

    result = (long)(short)ax * (long)(short)GET_SHORT(pop1);
    if ((result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64(eax, (long)GET_LONG(pop1));
    result = *(LARGE_INTEGER *)&ll;
    if ((result.HighPart == 0 && (result.LowPart & 0x80000000) == 0) ||
        (result.HighPart == 0xffffffff && (result.LowPart & 0x80000000) == 0x80000000)) {
        SET_CFLAG_OFF;
        SET_OFLAG_OFF;
    } else {
        SET_CFLAG_ON;
        SET_OFLAG_ON;
    }
    eax = result.LowPart;
    edx = result.HighPart;
#endif
}
FRAGCOMMON1(MuliNoFlagsFrag)
{
#if MSB == 0x80
    SHORT result;

    result = (short)(char)al * (short)(char)GET_BYTE(pop1);
    ax = result;
#elif MSB == 0x8000
    LONG result;

    result = (long)(short)ax * (long)(short)GET_SHORT(pop1);
    ax = LOWORD(result);
    dx = HIWORD(result);
#else   // MSB == 0x80000000
    LARGE_INTEGER result;
    LONGLONG ll;

    ll = Int32x32To64(eax, (long)GET_LONG(pop1));
    result = *(LARGE_INTEGER *)&ll;
    eax = result.LowPart;
    edx = result.HighPart;
#endif
}
FRAGCOMMON1(DivFrag)
{
#if MSB == 0x80
    USHORT result, remainder;
    USHORT dividend, divisor;

    dividend = (USHORT)ax;
    divisor  = GET_VAL(pop1);

    result    = dividend / divisor; // may get div-by-zero fault
    remainder = dividend % divisor;
    if ((result & 0xff00) == 0) {
        al = (UTYPE)result;
        ah = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#elif MSB == 0x8000
    DWORD result, remainder;
    DWORD dividend, divisor;

    dividend = (((DWORD)dx)<<16) | (DWORD)ax;
    divisor =  (DWORD)GET_VAL(pop1);

    result    = dividend / divisor; // may get div-by-zero fault
    remainder = dividend % divisor;
    if ((result & 0xffff0000) == 0) {
        AREG = (UTYPE)result;
        DREG = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#else // MSB == 0x80000000
    LARGE_INTEGER result;
    LARGE_INTEGER remainder;
    LARGE_INTEGER dividend;
    LARGE_INTEGER divisor;

    // build large_integers, without sign extending the 32-bit values
    dividend.LowPart = AREG;
    dividend.HighPart = DREG;
    divisor.LowPart = (long)GET_LONG(pop1);
    divisor.HighPart = 0;
    result = RtlLargeIntegerDivide(dividend, divisor, &remainder);

    if (result.HighPart == 0) {
        AREG = result.LowPart;
        DREG = remainder.LowPart;
    } else {
        OVERFLOW_INSTR;
    }
#endif
}
FRAGCOMMON1(IdivFrag)
{
#if MSB == 0x80
    short result, remainder;

    result    = (signed short)ax / (STYPE)GET_VAL(pop1); // may get div-by-zero fault
    remainder = (signed short)ax % (STYPE)GET_VAL(pop1);
    if ((result & 0xff80) == 0 || (result & 0xff80) == 0xff80) {
        al = (UTYPE)result;
        ah = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#elif MSB == 0x8000
    LONG result, remainder;

    result    = (signed long)((dx<<16) | ax) / (signed long)(STYPE)GET_VAL(pop1); // may get div-by-zero fault
    remainder = (signed long)((dx<<16) | ax) % (signed long)(STYPE)GET_VAL(pop1);
    if ((result & 0xffff8000) == 0 || (result & 0xffff8000) == 0xffff8000) {
        AREG = (UTYPE)result;
        DREG = (UTYPE)remainder;
    } else {
        OVERFLOW_INSTR;
    }
#else // MSB == 0x80000000
    LARGE_INTEGER result;
    LARGE_INTEGER remainder;
    LARGE_INTEGER dividend;
    LARGE_INTEGER divisor;
    DWORD op1;

    //
    // Since RtlLargeIntegerDivide and all of the overhead is large,
    // it is worthwhile making this check:
    //
    if ((long)DREG == -(long)(AREG >> 31)) {
        //
        // EDX:EAX is really just the value of EAX sign-extended into EDX.
        // This division can be performed with 32-bit arithmetic and no
        // overflow checking.
        //
        OPT_CwdIdivFrag32(cpu, pop1);
        return;
    }

    op1 = GET_LONG(pop1);

    // build UNSIGNED large_integers
    dividend.LowPart = AREG;
    dividend.HighPart = DREG;
    if (dividend.QuadPart < 0) {
        dividend.QuadPart = -dividend.QuadPart;
    }

    if ((long)op1 < 0) {
        divisor.LowPart = -(long)op1;
    } else {
        divisor.LowPart = op1;
    }
    divisor.HighPart = 0;

    // perform UNSIGNED division
    result = RtlLargeIntegerDivide(dividend, divisor, &remainder);

    // if divisor and dividend signs are different, fudge the result
    if ((dividend.HighPart != (int)DREG) ^ (divisor.LowPart != (int)op1)) {
        result.QuadPart = -result.QuadPart;
    }

    // adjust the sign of the remainder if the dividend is negative
    if (dividend.HighPart != (int)DREG) {
        remainder.QuadPart = -remainder.QuadPart;
    }

    if ((result.HighPart == 0 && (result.LowPart & MSB) == 0) ||
        (result.HighPart == 0xffffffff && (result.LowPart & MSB))) {
        AREG = (UTYPE)result.LowPart;
        DREG = (UTYPE)remainder.LowPart;
    } else {
        OVERFLOW_INSTR;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\soalpha.h ===
// CodeTemplate:gensocpu

//
//soalpha.h -- Generated file.  Do not hand edit
//


//
// Thread State offsets
//
#define Eax 0x0
#define Ebx 0xc
#define Ecx 0x4
#define Edx 0x8
#define Esi 0x18
#define Edi 0x1c
#define Ebp 0x14
#define Esp 0x10
#define Eip 0x38
#define CSReg 0x24
#define CpuNotify 0x158
#define fTCUnlocked 0x168

//
// Register mappings
//
#if MIPS
#ifdef _codegen_
// 0-3 are ZERO, at, v0, v1
#define RegArg0             4           // a0 arg register
#define RegArg1             5           // a1 arg register
#define RegArg2             6           // a2 arg register
#define RegArg3             7           // a3 arg register
#define RegTemp0            8           // t0 temp for operand0
#define RegTemp1            9           // t1 temp for operand1
#define RegTemp2            10          // t2 temp for operand2
#define RegTemp3            11          // t3 temp for operand3
#define RegTemp4            12          // t4 temp2 for operand0
#define RegTemp5            13          // t5 temp2 for operand1
#define RegTemp6            14          // t6 temp2 for operand2
#define RegTemp7            15          // t7 temp2 for operand3
#define RegPointer          16          // s0 saved
#define RegEip              17          // s1 saved
#define RegCache0           18          // s2 saved
#define RegCache1           19          // s3 saved
#define RegCache2           20          // s4 saved
#define RegCache3           21          // s5 saved
#define RegCache4           22          // s6 saved
#define RegProcessCpuNotify 23          // s7 saved
#define RegTemp8            24          // t8 temp unused
#define RegTemp             25          // t9 temp
// 26-29 are k0, k1, gp, sp
//#define RegS8             30          // s8 saved (DO NOT USE - USED BY trampln.s FOR EXCEPTION DISPATCHING)
#else
// 0-3 are ZERO, at, v0, v1
#define RegArg0             $4          // a0 arg register
#define RegArg1             $5          // a1 arg register
#define RegArg2             $6          // a2 arg register
#define RegArg3             $7          // a3 arg register
#define RegTemp0            $8          // t0 temp for operand0
#define RegTemp1            $9          // t1 temp for operand1
#define RegTemp2            $10         // t2 temp for operand2
#define RegTemp3            $11         // t3 temp for operand3
#define RegTemp4            $12         // t4 temp2 for operand0
#define RegTemp5            $13         // t5 temp2 for operand1
#define RegTemp6            $14         // t6 temp2 for operand2
#define RegTemp7            $15         // t7 temp2 for operand3
#define RegPointer          $16         // s0 saved
#define RegEip              $17         // s1 saved
#define RegCache0           $18         // s2 saved
#define RegCache1           $19         // s3 saved
#define RegCache2           $20         // s4 saved
#define RegCache3           $21         // s5 saved
#define RegCache4           $22         // s6 saved
#define RegProcessCpuNotify $23         // s7 saved
#define RegTemp8            $24         // t8 temp unused
#define RegTemp             $25         // t9 temp
// 26-29 are k0, k1, gp, sp
//#define RegS8             $30         // s8 saved (DO NOT USE - USED BY trampln.s FOR EXCEPTION DISPATCHING)
#endif

#define NUM_CACHE_REGS              5
#define EXCEPTIONDATA_SIGNATURE     0x12341234


#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name) \
	.text;\
	.globl name;\
	.ent name;\
name##:
;
#define END_FRAGMENT(name) \
	.globl _End##name;\
_End##name##:;\
	.end name;
#endif


#endif

#if ALPHA
#ifdef _codegen_
//
// Register mappings
//
// 0 is v0
#define RegTemp0            1   // t0 temp for operand1
#define RegTemp1            2   // t1 temp for operand2
#define RegTemp2            3   // t2 temp for operand3
#define RegTemp3            4   // t3 temp1 for operand1
#define RegTemp4            5   // t4 temp1 for operand2
#define RegTemp5            6   // t5 temp1 for operand3
#define RegTemp6            7   // t6 temp2 for operand1 and operand3
#define RegTemp7            8   // t7 temp2 for operand2
// 9-14 are s0-s5
#define RegPointer          9   // s0 saved
#define RegEip              10  // s1 saved
#define RegProcessCpuNotify 11  // s2 saved
#define RegCache0           12  // s3 saved
#define RegCache1           13  // s4 saved
#define RegCache2           14  // s5 saved
// 15 is fp
#define RegArg0             16  // a0 arg register
#define RegArg1             17  // a1 arg register
#define RegArg2             18  // a2 arg register
#define RegArg3             19  // a3 arg register
#define RegArg4             20  // a4 arg register
#define RegArg5             21  // a5 arg register
#define RegTemp8            22  // t8 temp3 for operand1 and operand3
#define RegTemp9            23  // t9 temp3 for operand2
#define RegTemp10           24  // t10 temp4 for operand1 and operand3
#define RegTemp11           25  // t11 temp4 for operand2
// 26 is ra
#define RegTemp             27  // t12 temp
// 28-31 are AT, gp, sp, zero
#else
//
// Register mappings
//
// 0 is v0
#define RegTemp0            $1   // t0 temp for operand1
#define RegTemp1            $2   // t1 temp for operand2
#define RegTemp2            $3   // t2 temp for operand3
#define RegTemp3            $4   // t3 temp1 for operand1
#define RegTemp4            $5   // t4 temp1 for operand2
#define RegTemp5            $6   // t5 temp1 for operand3
#define RegTemp6            $7   // t6 temp2 for operand1 and operand3
#define RegTemp7            $8   // t7 temp2 for operand2
// 9-14 are s0-s5
#define RegPointer          $9   // s0 saved
#define RegEip              $10  // s1 saved
#define RegProcessCpuNotify $11  // s2 saved
#define RegCache0           $12  // s3 saved
#define RegCache1           $13  // s4 saved
#define RegCache2           $14  // s5 saved
// 15 is fp
#define RegArg0             $16  // a0 arg register
#define RegArg1             $17  // a1 arg register
#define RegArg2             $18  // a2 arg register
#define RegArg3             $19  // a3 arg register
#define RegArg4             $20  // a4 arg register
#define RegArg5             $21  // a5 arg register
#define RegTemp8            $22  // t8 temp3 for operand1 and operand3
#define RegTemp9            $23  // t9 temp3 for operand2
#define RegTemp10           $24  // t10 temp4 for operand1 and operand3
#define RegTemp11           $25  // t11 temp4 for operand2
// 26 is ra
#define RegTemp             $27  // t12 temp
// 28-31 are AT, gp, sp, zero
#endif

#define NUM_CACHE_REGS              3
#define EXCEPTIONDATA_SIGNATURE     0x01010101


#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name) \
        .text;\
        .globl name;\
        .ent name;\
name##:
;
#define END_FRAGMENT(name) \
        .globl _End##name;\
_End##name##:;\
        .end name;
#endif        
#endif

#if PPC
#ifdef _codegen_
// r0 is temp unused (reads as zero in some instructions)
// r1 is stack pointer
// r2 is TOC pointer
#define RegArg0             3   // arg register 0
#define RegArg1             4   // arg register 1
#define RegArg2             5   // arg register 2
#define RegArg3             6   // arg register 3
#define RegTemp0            7   // temp for operand1 (acutally arg reg 4)
#define RegTemp1            8   // temp for operand2 (acutally arg reg 5)
#define RegTemp2            9   // temp for operand3 (acutally arg reg 6)
#define RegUt1              10  // temp
#define RegUt2              11  // temp
#define RegUt3              12  // temp
// all registers past r12 must be preserved
// r13 is the TEB pointer, set up by NT and assumed to be valid by C code
#define RegPointer          14  // saved
#define RegEip              15  // saved
#define RegProcessCpuNotify 16  // saved
#define RegCache0           17  // saved
#define RegCache1           18  // saved
#define RegCache2           19  // saved
#define RegCache3           20  // saved
#define RegCache4           21  // saved
#define RegCache5           22  // saved
#define RegTemp             23  // saved
// r24-r31 are unused
#else
// r0 is temp unused (reads as zero in some instructions)
// r1 is stack pointer
// r2 is TOC pointer
#define RegArg0             r3  // arg register 0
#define RegArg1             r4  // arg register 1
#define RegArg2             r5  // arg register 2
#define RegArg3             r6  // arg register 3
#define RegTemp0            r7  // temp for operand1 (acutally arg reg 4)
#define RegTemp1            r8  // temp for operand2 (acutally arg reg 5)
#define RegTemp2            r9  // temp for operand3 (acutally arg reg 6)
#define RegUt1              r10 // temp
#define RegUt2              r11 // temp
#define RegUt3              r12 // temp
// all registers past r12 must be preserved
// r13 is the TEB pointer, set up by NT and assumed to be valid by C code
#define RegPointer          r14 // saved
#define RegEip              r15 // saved
#define RegProcessCpuNotify r16 // saved
#define RegCache0           r17 // saved
#define RegCache1           r18 // saved
#define RegCache2           r19 // saved
#define RegCache3           r20 // saved
#define RegCache4           r21 // saved
#define RegCache5           r22 // saved
#define RegTemp             r23 // saved
// r24-r31 are unused
#endif

#define NUM_CACHE_REGS              6
#define EXCEPTIONDATA_SIGNATURE     0x12341234

#ifndef _codegen_
//
// asm fragment delcarator and end macro
//
#define FRAGMENT(name)   \
    .text;               \
    .align 2;            \
    .globl name;         \
name##:         
    
#define END_FRAGMENT(name) \
    .globl _End##name;     \
_End##name:;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\synlock.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    synlock.h

Abstract:
    
    Prototypes for synlock.c

Author:

    22-Aug-1995 t-orig (Ori Gershony)

Revision History:
        24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
        20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/



//
// Macros for 8 bit fragments
//
#define SLOCKFRAG1_8(x)                                 \
    FRAG1(SynchLock ## x ## Frag8, unsigned char);

#define SLOCKFRAG2_8(x)                                 \
    FRAG2(SynchLock ## x ## Frag8, unsigned char);

#define SLOCKFRAG2REF_8(x)                              \
    FRAG2REF(SynchLock ## x ## Frag8, unsigned char);    


//
// Macros for 16 bit fragments
//
#define SLOCKFRAG1_16(x)                                \
    FRAG1(SynchLock ## x ## Frag16, unsigned short);

#define SLOCKFRAG2_16(x)                                \
    FRAG2(SynchLock ## x ## Frag16, unsigned short);

#define SLOCKFRAG2REF_16(x)                             \
    FRAG2REF(SynchLock ## x ## Frag16, unsigned short);


//
// Macros for 32 bit fragments
//
#define SLOCKFRAG1_32(x)                                \
    FRAG1(SynchLock ## x ## Frag32, unsigned long);

#define SLOCKFRAG2_32(x)                                \
    FRAG2(SynchLock ## x ## Frag32, unsigned long);

#define SLOCKFRAG2REF_32(x)                             \
    FRAG2REF(SynchLock ## x ## Frag32, unsigned long);

//
// Monster macros!
//
#define SLOCKFRAG1(x)       \
    SLOCKFRAG1_8(x)         \
    SLOCKFRAG1_16(x)        \
    SLOCKFRAG1_32(x)

#define SLOCKFRAG2(x)       \
    SLOCKFRAG2_8(x)         \
    SLOCKFRAG2_16(x)        \
    SLOCKFRAG2_32(x)

#define SLOCKFRAG2REF(x)    \
    SLOCKFRAG2REF_8(x)      \
    SLOCKFRAG2REF_16(x)     \
    SLOCKFRAG2REF_32(x)


//
// Now finally the actual fragments
//

SLOCKFRAG2(Add)
SLOCKFRAG2(Or)
SLOCKFRAG2(Adc)
SLOCKFRAG2(Sbb)
SLOCKFRAG2(And)
SLOCKFRAG2(Sub)
SLOCKFRAG2(Xor)
SLOCKFRAG1(Not)
SLOCKFRAG1(Neg)
SLOCKFRAG1(Inc)
SLOCKFRAG1(Dec)
SLOCKFRAG2REF(Xchg)
SLOCKFRAG2REF(Xadd)
SLOCKFRAG2REF(CmpXchg)
FRAG2REF(SynchLockCmpXchg8bFrag32, ULONGLONG);

//
// Bts, Btr and Btc only come in 16bit and 32bit flavors
//
SLOCKFRAG2_16(BtsMem)
SLOCKFRAG2_16(BtsReg)
SLOCKFRAG2_16(BtrMem)
SLOCKFRAG2_16(BtrReg)
SLOCKFRAG2_16(BtcMem)
SLOCKFRAG2_16(BtcReg)

SLOCKFRAG2_32(BtsMem)
SLOCKFRAG2_32(BtsReg)
SLOCKFRAG2_32(BtrMem)
SLOCKFRAG2_32(BtrReg)
SLOCKFRAG2_32(BtcMem)
SLOCKFRAG2_32(BtcReg)

//
// Now undef the macros
//
#undef SLOCKFRAG1_8
#undef SLOCKFRAG2_8
#undef SLOCKFRAG2REF_8
#undef SLOCKFRAG1_16
#undef SLOCKFRAG2_16
#undef SLOCKFRAG2REF_16
#undef SLOCKFRAG1_32
#undef SLOCKFRAG2_32
#undef SLOCKFRAG2REF_32
#undef SLOCKFRAG1
#undef SLOCKFRAG2
#undef SLOCKFRAG2REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\synlock.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    synlock.c

Abstract:
    
    Implementation of the intel locked instructions.  All locked instructions
    wait on a single global mutex (shared between processes).  This takes care
    of any synchronization problem between intel processes.  Instructions which
    access aligned 32bit memory are also synchronized with native processes
    via the functions in lock.c.

Author:

    22-Aug-1995 t-orig (Ori Gershony)

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "fragp.h"
#include "cpumain.h"
#include "lock.h"
#include "synlock.h"

//
// The following two variables are used to synchronize intel instructions
// with the LOCK prefix.  The critical section is a lot faster, but it does
// not guarantee synchronization in shared memory.  Eventually we should use
// the critical section by default, and the mutex for certain applications which
// need it (maybe get a list from the registry).
//
HANDLE           Wx86LockSynchMutexHandle;
RTL_CRITICAL_SECTION Wx86LockSynchCriticalSection;

//
// The following variable decided which synchronization object is used
// Remove the '#define' below to allow runtime selection of whether
// x86 LOCK: prefixes on 8-bit and 16-bit instructions and unaligned
// 32-bit instructions are synchronized across the entire machine
// or only within the current process.  With the '#define' present,
// LOCK: prefixes imply only per-process synchronization.
//
SYNCHOBJECTTYPE SynchObjectType;
#define SynchObjectType USECRITICALSECTION
 
#define GET_SYNCHOBJECT                                         \
    if (SynchObjectType == USECRITICALSECTION){                 \
        RtlEnterCriticalSection(&Wx86LockSynchCriticalSection); \
    } else {                                                    \
        WaitForSingleObject(Wx86LockSynchMutexHandle, INFINITE);\
    }

#define RELEASE_SYNCHOBJECT                                     \
    if (SynchObjectType == USECRITICALSECTION){                 \
        RtlLeaveCriticalSection(&Wx86LockSynchCriticalSection); \
    } else {                                                    \
        ReleaseMutex(Wx86LockSynchMutexHandle);                 \
    }

//
// Macros for 8 bit fragments
//
#define SLOCKFRAG1_8(x)                                 \
    FRAG1(SynchLock ## x ## Frag8, unsigned char)       \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1);                         \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2_8(x)                                 \
    FRAG2(SynchLock ## x ## Frag8, unsigned char)       \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1, op2);                    \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2REF_8(x)                              \
    FRAG2REF(SynchLock ## x ## Frag8, unsigned char)    \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag8 (cpu, pop1, pop2);                   \
        RELEASE_SYNCHOBJECT                             \
    }


//
// Macros for 16 bit fragments
//
#define SLOCKFRAG1_16(x)                                \
    FRAG1(SynchLock ## x ## Frag16, unsigned short)     \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1);                        \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2_16(x)                                \
    FRAG2(SynchLock ## x ## Frag16, unsigned short)     \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1, op2);                   \
        RELEASE_SYNCHOBJECT                             \
    }

#define SLOCKFRAG2REF_16(x)                             \
    FRAG2REF(SynchLock ## x ## Frag16, unsigned short)  \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        x ## Frag16 (cpu, pop1, pop2);                  \
        RELEASE_SYNCHOBJECT                             \
    }


//
// Macros for 32 bit fragments
// Note:  in the 32bit case, we check if pop1 is aligned and
//        call the lock version if it is.
//

 
#define SLOCKFRAG1_32(x)                                \
    FRAG1(SynchLock ## x ## Frag32, unsigned long)      \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG)(ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1);            \
        } else {                                        \
            x ## Frag32 (cpu, pop1);                    \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }

 
#define SLOCKFRAG2_32(x)                                \
    FRAG2(SynchLock ## x ## Frag32, unsigned long)      \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG) (ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1, op2);       \
        } else {                                        \
            x ## Frag32 (cpu, pop1, op2);               \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }
 
#define SLOCKFRAG2REF_32(x)                             \
    FRAG2REF(SynchLock ## x ## Frag32, unsigned long)   \
    {                                                   \
        GET_SYNCHOBJECT                                 \
        if (((ULONG)(ULONGLONG)pop1 & 0x3) == 0){                  \
            Lock ## x ## Frag32 (cpu, pop1, pop2);      \
        } else {                                        \
            x ## Frag32 (cpu, pop1, pop2);              \
        }                                               \
        RELEASE_SYNCHOBJECT                             \
    }

//
// Monster macros!
//
#define SLOCKFRAG1(x)       \
    SLOCKFRAG1_8(x)         \
    SLOCKFRAG1_16(x)        \
    SLOCKFRAG1_32(x)

#define SLOCKFRAG2(x)       \
    SLOCKFRAG2_8(x)         \
    SLOCKFRAG2_16(x)        \
    SLOCKFRAG2_32(x)

#define SLOCKFRAG2REF(x)    \
    SLOCKFRAG2REF_8(x)      \
    SLOCKFRAG2REF_16(x)     \
    SLOCKFRAG2REF_32(x)


//
// Now finally the actual fragments
//



SLOCKFRAG2(Add)
SLOCKFRAG2(Or)
SLOCKFRAG2(Adc)
SLOCKFRAG2(Sbb)
SLOCKFRAG2(And)
SLOCKFRAG2(Sub)
SLOCKFRAG2(Xor)
SLOCKFRAG1(Not)
SLOCKFRAG1(Neg)
SLOCKFRAG1(Inc)
SLOCKFRAG1(Dec)
SLOCKFRAG2REF(Xchg)
SLOCKFRAG2REF(Xadd)
SLOCKFRAG2REF(CmpXchg)
FRAG2REF(SynchLockCmpXchg8bFrag32, ULONGLONG)
{
    GET_SYNCHOBJECT
    if (((ULONG)(ULONGLONG)pop1 & 0x7) == 0){
	LockCmpXchg8bFrag32 (cpu, pop1, pop2);
    } else {
	CmpXchg8bFrag32 (cpu, pop1, pop2);
    }
    RELEASE_SYNCHOBJECT
}

//
// Bts, Btr and Btc only come in 16bit and 32bit flavors
//
SLOCKFRAG2_16(BtsMem)
SLOCKFRAG2_16(BtsReg)
SLOCKFRAG2_16(BtrMem)
SLOCKFRAG2_16(BtrReg)
SLOCKFRAG2_16(BtcMem)
SLOCKFRAG2_16(BtcReg)

SLOCKFRAG2_32(BtsMem)
SLOCKFRAG2_32(BtsReg)
SLOCKFRAG2_32(BtrMem)
SLOCKFRAG2_32(BtrReg)
SLOCKFRAG2_32(BtcMem)
SLOCKFRAG2_32(BtcReg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\suspend.c ===
/*++

Copyright (c) 1999-1998 Microsoft Corporation

Module Name: 

    suspend.c

Abstract:
    
    This module implements CpuSuspendThread, CpuGetContext and CpuSetContext.

Author:

    14-Dec-1999  SamerA

Revision History:

--*/
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#ifdef MSCCPU
#include "ccpu.h"
#include "msccpup.h"
#undef GET_BYTE
#undef GET_SHORT
#undef GET_LONG
#else
#include "threadst.h"
#include "instr.h"
#include "frag.h"
ASSERTNAME;
#endif
#include "fragp.h"
#include "cpunotif.h"


VOID
RemoteSuspendAtNativeCode (
    VOID);




NTSTATUS
CpupFreeSuspendMsg(
    PCPU_SUSPEND_MSG CpuSuspendMsg)
/*++

Routine Description:

    This routine frees the resources associated with the suspend message structure on
    the remote side.
    
Arguments:

    CpuSuspendMsg   - Address of Suspend message structure

Return Value:

    NTSTATUS.

--*/
{
    SIZE_T RegionSize;

    NtClose(CpuSuspendMsg->StartSuspendCallEvent);
    NtClose(CpuSuspendMsg->EndSuspendCallEvent);
    
    RegionSize = sizeof(*CpuSuspendMsg);
    NtFreeVirtualMemory(NtCurrentProcess(),
                        &CpuSuspendMsg,
                        &RegionSize,
                        MEM_RELEASE);

    return STATUS_SUCCESS;
}


VOID
CpupSuspendAtNativeCode(
    PCONTEXT Context,
    PCPU_SUSPEND_MSG SuspendMsg)
/*++

Routine Description:

    Prepares the current to get suspended. This routine is executed as a result
    of calling RtlRemoteCall on this current thread. This routine will
    update the CPUCONTEXT of the current thread with the passed SuspendM Message
    and  notify the CPU that the current thread needs to be suspended.
    This routine must call NtContinue at the end to continue execution at
    the point where it has been interrupted.
    
    NOTE : Any change to the parameter list of this function must accompany
           a change to the RtlRemoteCall in CpuSuspendThread() and 
           RemoteSuspendAtNativeCode().
    
Arguments:

    Context     - Context to return to execute at
    SuspendMsg  - Suspend message address

Return Value:

    NONE

--*/
{
    DECLARE_CPU;


    InterlockedCompareExchangePointer(&cpu->SuspendMsg,
                                      SuspendMsg,
                                      NULL);

    if (cpu->SuspendMsg == SuspendMsg)
    {
        cpu->CpuNotify |= CPUNOTIFY_SUSPEND;
    }
    else
    {
        CpupFreeSuspendMsg(SuspendMsg);
    }

    if (Context)
    {
        NtContinue(Context,FALSE);
    }
        
    CPUASSERT(FALSE);

    return;
}



NTSTATUS
CpupSuspendCurrentThread(
    VOID)
/*++

Routine Description:

    This routine is called from the main CPU loop after leaving the translation cache,
    and start running native code. 
    Now it's the best time to suspend the currently executing thread.
    
Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    LARGE_INTEGER TimeOut;
    PCPU_SUSPEND_MSG CpuSuspendMsg;
    SIZE_T RegionSize;
    DECLARE_CPU;


    CpuSuspendMsg = cpu->SuspendMsg;

    NtStatus = NtSetEvent(CpuSuspendMsg->StartSuspendCallEvent, NULL);

    if (NT_SUCCESS(NtStatus))
    {
        TimeOut.QuadPart = UInt32x32To64( 40000, 10000 );
        TimeOut.QuadPart *= -1;

        NtStatus = NtWaitForSingleObject(CpuSuspendMsg->EndSuspendCallEvent,
                                         FALSE,
                                         &TimeOut);
    }
    else
    {
        LOGPRINT((TRACELOG, "CpupSuspendCurrentThread: Couldn't signal Start suspendcall event (%lx) -%lx\n", 
                  CpuSuspendMsg->StartSuspendCallEvent, NtStatus));

    }

    CpupFreeSuspendMsg(CpuSuspendMsg);

    cpu->SuspendMsg = NULL;

    return NtStatus;
}


NTSTATUS CpupReadBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Source,
    OUT PVOID Destination,
    IN ULONG Size)
/*++

Routine Description:

    This routine reads the source buffer into the destination buffer. It
    optimizes calls to NtReadVirtualMemory by checking whether the
    source buffer is in the currnt process or not.
    
Arguments:

    ProcessHandle  - Target process handle to read data from
    Source         - Target base address to read data from
    Destination    - Address of buffer to receive data read from the specified address space
    Size           - Size of data to read

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    return NtReadVirtualMemory(ProcessHandle,
                               Source,
                               Destination,
                               Size,
                               NULL);
}

NTSTATUS
CpupWriteBuffer(
    IN HANDLE ProcessHandle,
    IN PVOID Target,
    IN PVOID Source,
    IN ULONG Size)
/*++

Routine Description:

    Writes data to memory taken into consideration if the write is cross-process
    or not
    
Arguments:

    ProcessHandle  - Target process handle to write data into
    Target         - Target base address to write data at
    Source         - Address of contents to write in the specified address space
    Size           - Size of data to write
    
Return Value:

    NTSTATUS.

--*/
{
    return NtWriteVirtualMemory(ProcessHandle,
                                Target,
                                Source,
                                Size,
                                NULL);
}



NTSTATUS
CpupSetupSuspendCallParamters(
    IN HANDLE RemoteProcessHandle,
    IN PCPU_SUSPEND_MSG SuspendMsg,
    OUT PVOID *Arguments)
/*++

Routine Description:

    This routine setup the arguments for the remoted call to 
    CpupSuspendAtNativeCode.
    
Arguments:

    RemoteProcessHandle   - Handle of process to setup the arguments in
    SuspendMsg            - Suspend message to remote to the target process
    Arguments             - Pointer to an array of parameters

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CPU_SUSPEND_MSG RemoteSuspendMsg;
    SIZE_T RegionSize;


    NtStatus = NtDuplicateObject(NtCurrentProcess(),
                                 SuspendMsg->StartSuspendCallEvent,
                                 RemoteProcessHandle,
                                 &RemoteSuspendMsg.StartSuspendCallEvent,
                                 0,
                                 0,
                                 DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't duplicate event (%lx) into %lx -%lx\n", 
                  SuspendMsg->StartSuspendCallEvent, RemoteProcessHandle, NtStatus));

        return NtStatus;
    }

    NtStatus = NtDuplicateObject(NtCurrentProcess(),
                                 SuspendMsg->EndSuspendCallEvent,
                                 RemoteProcessHandle,
                                 &RemoteSuspendMsg.EndSuspendCallEvent,
                                 0,
                                 0,
                                 DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't duplicate event (%lx) into %lx -%lx\n", 
                  SuspendMsg->EndSuspendCallEvent, RemoteProcessHandle, NtStatus));
        return NtStatus;
    }

    RegionSize = sizeof(RemoteSuspendMsg);
    *Arguments = NULL;
    NtStatus = NtAllocateVirtualMemory(RemoteProcessHandle,
                                       Arguments,
                                       0,
                                       &RegionSize,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = NtWriteVirtualMemory(RemoteProcessHandle,
                                        *Arguments,
                                        &RemoteSuspendMsg,
                                        sizeof(RemoteSuspendMsg),
                                        NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't write parameters in target process (%lx) -%lx\n", 
                      RemoteProcessHandle,NtStatus));

            NtFreeVirtualMemory(RemoteProcessHandle,
                                Arguments,
                                &RegionSize,
                                MEM_RELEASE);
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "CpupSetupSuspendCallParamters: Couldn't allocate parameters space in target process (%lx) -%lx\n", 
                  RemoteProcessHandle,NtStatus));
    }

    return NtStatus;
}


NTSTATUS
CpuSuspendThread(
    IN HANDLE ThreadHandle,
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    OUT PULONG PreviousSuspendCount OPTIONAL)
/*++

Routine Description:

    This routine is entered while the target thread is actually suspended, however, it's 
    not known if the target thread is in a consistent state relative to
    the CPU. This routine guarantees that the target thread to suspend isn't the
    currently executing thread. It will establish a handshake protocol to suspend the
    target thread at a consistent cpu state.

Arguments:

    ThreadHandle          - Handle of target thread to suspend
    ProcessHandle         - Handle of target thread's process 
    Teb                   - Address of the target thread's TEB
    PreviousSuspendCount  - Previous suspend count

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, WaitStatus;
    ULONG_PTR CpuSimulationFlag;
    CPU_SUSPEND_MSG CpuSuspendMsg;
    PVOID Arguments;
    LARGE_INTEGER TimeOut;
    

    
    CpuSuspendMsg.StartSuspendCallEvent = INVALID_HANDLE_VALUE;
    CpuSuspendMsg.EndSuspendCallEvent = INVALID_HANDLE_VALUE;

    //
    // Are we in CPU simulation
    // 
    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_INCPUSIMULATION])),
                              &CpuSimulationFlag,
                              sizeof(CpuSimulationFlag));

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't read INCPUSIMULATION flag (%lx) -%lx\n", 
                  CpuSimulationFlag, NtStatus));
        goto Cleanup;
    }

    if (!CpuSimulationFlag)
    {
        LOGPRINT((TRACELOG, "CpuSuspendThread: Thread is not running simulated code, so leave it suspended (%lx)", 
                  ThreadHandle));
        goto Cleanup;
    }

    NtStatus = NtCreateEvent(&CpuSuspendMsg.StartSuspendCallEvent,
                             EVENT_ALL_ACCESS,
                             NULL,
                             SynchronizationEvent,
                             FALSE);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't create StartSuspendCallEvent -%lx\n", 
                  NtStatus));
        goto Cleanup;
    }

    NtStatus = NtCreateEvent(&CpuSuspendMsg.EndSuspendCallEvent,
                             EVENT_ALL_ACCESS,
                             NULL,
                             SynchronizationEvent,
                             FALSE);    
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't create EndSuspendCallEvent -%lx\n", 
                  NtStatus));
        goto Cleanup;
    }

    NtStatus = CpupSetupSuspendCallParamters(ProcessHandle,
                                             &CpuSuspendMsg,
                                             &Arguments);
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlRemoteCall(ProcessHandle,
                                 ThreadHandle,
                                 (PVOID)RemoteSuspendAtNativeCode,
                                 1,
                                 (PULONG_PTR)&Arguments,
                                 TRUE,
                                 TRUE);
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = NtResumeThread(ThreadHandle, NULL);
            if (!NT_SUCCESS(NtStatus))
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't resume thread (%lx) -%lx\n", 
                          ThreadHandle, NtStatus));
                goto Cleanup;
            }

            TimeOut.QuadPart = UInt32x32To64( 20000, 10000 );
            TimeOut.QuadPart *= -1;

            WaitStatus = NtWaitForSingleObject(CpuSuspendMsg.StartSuspendCallEvent,
                                               FALSE,
                                               &TimeOut);

            NtStatus = NtSuspendThread(ThreadHandle, PreviousSuspendCount);

            if (!NT_SUCCESS(WaitStatus))
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Couldn't wait for StartSuspendCallEvent -%lx\n", 
                          NtStatus));
                goto Cleanup;
            }
            
            if (WaitStatus == STATUS_TIMEOUT)
            {
                LOGPRINT((ERRORLOG, "CpuSuspendThread: Timeout on StartSuspendCallEvent -%lx. Thread %lx may already be waiting.\n", 
                          NtStatus, ThreadHandle));
            }


            if (NT_SUCCESS(NtStatus))
            {
                NtSetEvent(CpuSuspendMsg.EndSuspendCallEvent, NULL);
            }
        }
        else
        {
            LOGPRINT((ERRORLOG, "CpuSuspendThread: RtlRemoteCall failed -%lx\n", 
                      NtStatus));
        }
    }

Cleanup:    
    ;
    
    if (CpuSuspendMsg.StartSuspendCallEvent != INVALID_HANDLE_VALUE)
    {
        NtClose(CpuSuspendMsg.StartSuspendCallEvent);
    }

    if (CpuSuspendMsg.EndSuspendCallEvent != INVALID_HANDLE_VALUE)
    {
        NtClose(CpuSuspendMsg.EndSuspendCallEvent);
    }

    return NtStatus;
}


NTSTATUS
GetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine extracts the context record out of the specified cpu context. 

Arguments:

    cpu      - CPU context structure
    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    try 
    {
        ContextFlags = Context->ContextFlags;

        if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) 
        {
            Context->EFlags = GetEfl(cpu);
            Context->SegCs  = CS;
            Context->Esp    = esp;
            Context->SegSs  = SS;
            Context->Ebp    = ebp;
            Context->Eip    = eip;
            //Context->Eip    = cpu->eipReg.i4;
        }

        if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) 
        {
            Context->SegGs = GS;
            Context->SegFs = FS;
            Context->SegEs = ES;
            Context->SegDs = DS;
        }

        if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) 
        {
            Context->Eax = eax;
            Context->Ebx = ebx;
            Context->Ecx = ecx;
            Context->Edx = edx;
            Context->Edi = edi;
            Context->Esi = esi;
        }

        if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) 
        {
            //
            // FpuSaveContext() is the same as FNSAVE, except FNSAVE resets the
            // FPU when its done.
            //
            CALLFRAG1(FpuSaveContext, (PBYTE)&Context->FloatSave);
            Context->FloatSave.Cr0NpxState = 1;    // (Math Present)
        }

//    if ((ContextFlags & CONTEXT_DEBUG_WX86) == CONTEXT_DEBUG_WX86) 
//    {
//    }
    } 
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}


NTSTATUS
CpupGetContextRecord(
    IN PCPUCONTEXT cpu,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine extracts the context record out of the specified cpu context. 

Arguments:

    cpu      - CPU context structure
    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    return GetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuGetContext(
    IN OUT PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine extracts the context record for the currently 
    executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return CpupGetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuGetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine extracts the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
                     optimization purposes.
    Context        - Context record to fill                 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;


    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                              &CpuRemoteContext,
                              sizeof(CpuRemoteContext));

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  CpuRemoteContext,
                                  &CpuContext,
                                  FIELD_OFFSET(CPUCONTEXT, FpData));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupGetContextRecord(&CpuContext, Context);
        }
        else
        {
            LOGPRINT((ERRORLOG, "MsCpuGetContextThread: Couldn't read CPU context %lx -%lx\n", 
                      CpuRemoteContext, NtStatus));
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "MsCpuGetContextThread: Couldn't read CPU context address-%lx\n", 
                  NtStatus));
    }

    return NtStatus;
}


NTSTATUS
SetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the passed context record for the specified CPUCONTEXT.

Arguments:

    cpu      - CPU context structure
    Context  - Context record to set 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ContextFlags;

    try 
    {
        ContextFlags = Context->ContextFlags;

        if ((ContextFlags & CONTEXT_CONTROL_WX86) == CONTEXT_CONTROL_WX86) 
        {
            SetEfl(cpu, Context->EFlags);
            CS = (USHORT)Context->SegCs;
            esp = Context->Esp;
            SS = (USHORT)Context->SegSs;
            ebp = Context->Ebp;
            eip = Context->Eip;
#if MSCCPU
            eipTemp = Context->Eip;
#endif
        }

        if ((ContextFlags & CONTEXT_SEGMENTS_WX86) == CONTEXT_SEGMENTS_WX86) 
        {
            GS = (USHORT)Context->SegGs;
            FS = (USHORT)Context->SegFs;
            ES = (USHORT)Context->SegEs;
            DS = (USHORT)Context->SegDs;
        }

        if ((ContextFlags & CONTEXT_INTEGER_WX86) == CONTEXT_INTEGER_WX86) 
        {
            eax = Context->Eax;
            ebx = Context->Ebx;
            ecx = Context->Ecx;
            edx = Context->Edx;
            edi = Context->Edi;
            esi = Context->Esi;
        }

        if ((ContextFlags & CONTEXT_FLOATING_POINT_WX86) == CONTEXT_FLOATING_POINT_WX86) 
        {
            CALLFRAG1(FRSTOR, (PBYTE)&Context->FloatSave);
            // Ignore:  Context->FloatSave.Cr0NpxState
        }

//    if ((ContextFlags & CONTEXT_DEBUG_WX86) == CONTEXT_DEBUG_WX86) 
//    {
//    }
    } 
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}


NTSTATUS
CpupSetContextRecord(
    PCPUCONTEXT cpu,
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the passed context record for the specified CPU.

Arguments:

    cpu      - CPU context structure
    Context  - Context record to set 

Return Value:

    NTSTATUS.

--*/
{
    return SetContextRecord(cpu, Context);
}


NTSTATUS
MsCpuSetContext(
    PCONTEXT_WX86 Context
    )
/*++

Routine Description:

    This routine sets the context record for the currently executing thread. 

Arguments:

    Context  - Context record to fill 

Return Value:

    NTSTATUS.

--*/
{
    DECLARE_CPU;

    return CpupSetContextRecord(cpu, Context);
}



NTSTATUS
MsCpuSetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context)
/*++

Routine Description:

    This routine sets the context record of any thread. This is a generic routine.
    When entered, if the target thread isn't the currently executing thread, then it should be 
    guaranteed that the target thread is suspended at a proper CPU state.

Arguments:

    ProcessHandle  - Open handle to the process that the thread runs in
    Teb            - Pointer to the target's thread TEB
    Context        - Context record to set

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCPUCONTEXT CpuRemoteContext;
    CPUCONTEXT CpuContext;



    NtStatus = CpupReadBuffer(ProcessHandle,
                              ((PCHAR)Teb + FIELD_OFFSET(TEB, TlsSlots[WOW64_TLS_CPURESERVED])),
                              &CpuRemoteContext,
                              sizeof(CpuRemoteContext));

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = CpupReadBuffer(ProcessHandle,
                                  CpuRemoteContext,
                                  &CpuContext,
                                  FIELD_OFFSET(CPUCONTEXT, FpData));

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = CpupSetContextRecord(&CpuContext, Context);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = CpupWriteBuffer(ProcessHandle,
                                           CpuRemoteContext,
                                           &CpuContext,
                                           FIELD_OFFSET(CPUCONTEXT, FpData));

                if (!NT_SUCCESS(NtStatus))
                {
                    LOGPRINT((ERRORLOG, "MsCpuSetContextThread: Couldn't write CPU context %lx -%lx\n", 
                              CpuRemoteContext, NtStatus));
                }
            }
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "MsCpuSetContextThread: Couldn't read CPU context address-%lx\n", 
                  NtStatus));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\codeseq.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codeseq.h

Abstract:

    This header file contains the function prototypes for all fragments
    in codeseq.c

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996

Revision History:


--*/


#undef FRAGMENT
#undef PATCH_FRAGMENT
#undef OP_FRAGMENT

#if _ALPHA_
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG CurrentECU,                \
        IN PINSTRUCTION Instruction         \
        );

    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG CurrentECU,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        );
#else
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN PINSTRUCTION Instruction         \
        );

    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        );
#endif

#define OP_FRAGMENT(name)               \
ULONG                                   \
Gen##name (                             \
    IN PULONG CodeLocation,             \
    IN POPERAND Operand,                \
    IN ULONG OperandNumber              \
    );


FRAGMENT(AddFragNoFlags32)
FRAGMENT(AddFragNoFlags32A)
FRAGMENT(AndFragNoFlags32)
FRAGMENT(AndFragNoFlags32A)
FRAGMENT(DecFragNoFlags32)
FRAGMENT(DecFragNoFlags32A)
FRAGMENT(IncFragNoFlags32)
FRAGMENT(IncFragNoFlags32A)
FRAGMENT(OrFragNoFlags32)
FRAGMENT(OrFragNoFlags32A)
FRAGMENT(SubFragNoFlags32)
FRAGMENT(SubFragNoFlags32A)
FRAGMENT(XorFragNoFlags32)
FRAGMENT(XorFragNoFlags32A)
FRAGMENT(StartBasicBlock)
FRAGMENT(JumpToNextCompilationUnit)
PATCH_FRAGMENT(JumpToNextCompilationUnit2)
FRAGMENT(CallCFrag)
FRAGMENT(CallCFragNoCpu)
FRAGMENT(CallCFragLoadEip)
FRAGMENT(CallCFragLoadEipNoCpu)
FRAGMENT(CallCFragLoadEipNoCpuSlow)
FRAGMENT(CallCFragLoadEipSlow)
FRAGMENT(CallCFragSlow)
FRAGMENT(CallCFragNoCpuSlow)
FRAGMENT(JaFrag)
FRAGMENT(JaeFrag)
FRAGMENT(JbeFrag)
FRAGMENT(JbFrag)
FRAGMENT(JeFrag)
FRAGMENT(JgFrag)
FRAGMENT(JlFrag)
FRAGMENT(JleFrag)
FRAGMENT(JneFrag)
FRAGMENT(JnlFrag)
FRAGMENT(JnoFrag)
FRAGMENT(JnpFrag)
FRAGMENT(JnsFrag)
FRAGMENT(JoFrag)
FRAGMENT(JpFrag)
FRAGMENT(JsFrag)
FRAGMENT(JecxzFrag)
FRAGMENT(JcxzFrag)
FRAGMENT(LoopFrag32)
FRAGMENT(LoopFrag16)
FRAGMENT(LoopneFrag32)
FRAGMENT(LoopneFrag16)
FRAGMENT(LoopeFrag32)
FRAGMENT(LoopeFrag16)
FRAGMENT(JxxBody)
PATCH_FRAGMENT(JxxBody2)
FRAGMENT(JxxStartSlow)
FRAGMENT(JxxBodySlow)
PATCH_FRAGMENT(JxxBodySlow2)
FRAGMENT(JxxBodyFwd)
PATCH_FRAGMENT(JxxBodyFwd2)
FRAGMENT(CallJmpDirect)
PATCH_FRAGMENT(CallJmpDirect2)
FRAGMENT(CallJmpDirectSlow)
PATCH_FRAGMENT(CallJmpDirectSlow2)
FRAGMENT(CallJmpFwdDirect)
PATCH_FRAGMENT(CallJmpFwdDirect2)
FRAGMENT(CallJmpfDirect)
PATCH_FRAGMENT(CallJmpfDirect2)
FRAGMENT(CallJmpIndirect)
FRAGMENT(CallJmpfIndirect)
FRAGMENT(CallRetIndirect)
FRAGMENT(CallDirect)
PATCH_FRAGMENT(CallDirect2)
PATCH_FRAGMENT(CallDirect3)
FRAGMENT(CallfDirect)
PATCH_FRAGMENT(CallfDirect2)
PATCH_FRAGMENT(CallfDirect3)
FRAGMENT(CallIndirect)
FRAGMENT(CallfIndirect)
PATCH_FRAGMENT(CallIndirect2)
PATCH_FRAGMENT(CallfIndirect2)
FRAGMENT(Movsx8To32)
FRAGMENT(Movsx8To32Slow)
FRAGMENT(Movsx16To32)
FRAGMENT(Movsx16To32Slow)
FRAGMENT(Movsx8To16)
FRAGMENT(Movsx8To16Slow)
FRAGMENT(Movzx8To32)
FRAGMENT(Movzx8To32Slow)
FRAGMENT(Movzx16To32)
FRAGMENT(Movzx16To32Slow)
FRAGMENT(Movzx8To16)
FRAGMENT(Movzx8To16Slow)
FRAGMENT(EndCompilationUnit)
FRAGMENT(EndMovSlow)

#if _ALPHA_
OP_FRAGMENT(OperandMovRegToReg8B)
OP_FRAGMENT(OperandMovToMem8D)
OP_FRAGMENT(OperandMovToMem16D)
#endif

OP_FRAGMENT(OperandMovToMem32B)
OP_FRAGMENT(OperandMovToMem32D)
OP_FRAGMENT(OperandMovToMem16B)
OP_FRAGMENT(OperandMovToMem16W)
OP_FRAGMENT(OperandMovToMem8B)
OP_FRAGMENT(OperandMovToReg)
OP_FRAGMENT(OperandMovRegToReg32)
OP_FRAGMENT(OperandMovRegToReg16)
OP_FRAGMENT(OperandMovRegToReg8)
OP_FRAGMENT(OperandImm)
OP_FRAGMENT(OperandRegRef)
OP_FRAGMENT(OperandRegVal)
OP_FRAGMENT(LoadCacheReg)

ULONG GenOperandAddr(
    PULONG CodeLocation,
    POPERAND Operand,
    ULONG OperandNumber,
    ULONG FsOverride
    );

#undef FRAGMENT
#undef PATCH_FRAGMENT
#undef OP_FRAGMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\codeseqp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    codeseqp.h

Abstract:

    This header file contains the non-processor-specific includes and
    declarations used by mips, ppc, and alpha codeseq.c files.

Author:

    Barry Bond (barrybo) creation-date 23-Sept-1996

Revision History:

          24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
          20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#define _codegen_
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <instr.h>
#include <config.h>
#include <threadst.h>
#include <frag.h>
#include <fragp.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <compiler.h>
#include <codegen.h>
#include <codesize.h>
#include <opt.h>
#if _ALPHA_
#include <soalpha.h>
#elif _MIPS_
#include <somips.h>
#elif _PPC_
#include <soppc.h>
#endif
#include <process.h>

extern int JumpToNextCompilationUnitHelper();
extern int CallJxxHelper();
extern int CallJxxSlowHelper();
extern int CallJxxFwdHelper();
extern int CallJmpDirectHelper();
extern int CallJmpDirectSlowHelper();
extern int CallJmpFwdDirectHelper();
extern int CallJmpfDirectHelper();
extern int CallJmpfDirect2Helper();
extern int CallDirectHelper();
extern int CallfDirectHelper();
extern int CallDirectHelper2();
extern int CallfDirectHelper2();
extern int CallIndirectHelper();
extern int CallfIndirectHelper();
extern int IndirectControlTransferHelper();
extern int IndirectControlTransferFarHelper();
extern int RegisterOffset[];

#define START_FRAGMENT                  \
    PULONG d = CodeLocation;

//
// fragment generation function beginnings and endings
//
#if _ALPHA_
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG CurrentECU,                \
        IN PINSTRUCTION Instruction         \
        )                                   \
    {                                       \
        const ULONG fCompiling = TRUE;      \
        START_FRAGMENT
#else
    #define FRAGMENT(name)                  \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN PINSTRUCTION Instruction         \
        )                                   \
    {                                       \
        const ULONG fCompiling = TRUE;      \
        START_FRAGMENT
#endif

 

#define END_FRAGMENT                    \
    return (ULONG)(ULONGLONG)(d - CodeLocation) * sizeof(ULONG);      \
}
        
#define OP_FRAGMENT(name)               \
ULONG                                   \
Gen##name (                             \
    IN PULONG CodeLocation,             \
    IN POPERAND Operand,                \
    IN ULONG OperandNumber              \
    )                                   \
{                                       \
    START_FRAGMENT

//
// These functions have a private interface.  The caller and callee have to
// agree how many of the parameters are valid.  This lets us use the same
// basic form for all of the code that goes into the translation cache
//
#if _ALPHA_
    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG CurrentECU,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        )                                   \
    {                                       \
        START_FRAGMENT
#else
    #define PATCH_FRAGMENT(name)            \
    ULONG                                   \
    Gen##name (                             \
        IN PULONG CodeLocation,             \
        IN ULONG fCompiling,                \
        IN ULONG Param1,                    \
        IN ULONG Param2                     \
        )                                   \
    {                                       \
        START_FRAGMENT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\process.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains the proessor-independent routines used during
    RISC code generation.

Author:

    Barry Bond (barrybo) creation-date 27-Sept-1996

Revision History:


--*/

#ifndef _PROCESS_H_
#define _PROCESS_H_

#define ALIGN_DWORD_ALIGNED 2
#define ALIGN_WORD_ALIGNED 1
#define ALIGN_BYTE_ALIGNED 0

extern DWORD RegCache[NUM_CACHE_REGS];  // One entry for each cached register
extern DWORD Arg1Contents;
extern DWORD Arg2Contents;

ULONG
LookupRegInCache(
    ULONG Reg
    );

#define GetArgContents(OperandNumber)       \
    ((OperandNumber == 1) ? Arg1Contents :  \
    (OperandNumber == 2) ? Arg2Contents :   \
    NO_REG)

VOID SetArgContents(
    ULONG OperandNumber,
    ULONG Reg
    );

USHORT
ChecksumMemory(
    ENTRYPOINT *pEP
    );

DWORD
SniffMemory(
    ENTRYPOINT *pEP,
    USHORT Checksum
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\findpc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    findpc.h

Abstract:

    This module declares a function to determine the address of the translation
    cache within the callstack.

Author:

    Barry Bond (barrybo) creation-date 13-May-1996

Revision History:


--*/

ULONG
FindPcInTranslationCache(
    PEXCEPTION_POINTERS pExceptionPointers
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\ctrltrns.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    ctrltrns.c

Abstract:
    
    Control Transfer Fragments.

Author:

    10-July-1995 t-orig (Ori Gershony)

Revision History:

            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)

--*/  

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_

#include "wx86nt.h"
#include "wx86cpu.h"
#include "instr.h"
#include "config.h"
#include "cpuassrt.h"
#include "fragp.h"
#include "entrypt.h"
#include "compiler.h"
#include "ctrltrns.h"
#include "threadst.h"
#include "tc.h"
#include "cpunotif.h"
#include "atomic.h"

ASSERTNAME;

VOID
FlushCallstack(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Flush the callstack - the Translation Cache is flushing, which
    invalidates the callstack.

Arguments:

    cpu - per-thread info
    
Return Value:

    .

--*/
{
    //
    // Mark the callstack as valid.
    //
    cpu->CSTimestamp = TranslationCacheTimestamp;

    memset(cpu->callStack, 0, CSSIZE*sizeof(CALLSTACK));
    //
    // No need to reset cpu->CSIndex as the stack is actually implemented
    // within a circular buffer.  It can start at any offset
    //
}

// Call
ULONG
CTRL_CallFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    ULONG inteldest,
    ULONG intelnext,
    ULONG nativenext
    )
{
    PUSH_LONG(intelnext);
    PUSH_CALLSTACK(intelnext, nativenext);
    ASSERTPtrInTCOrZero((PVOID)nativenext);

    eip = inteldest;

    return inteldest;
}

// Call FAR
ULONG
CTRL_CallfFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    PUSHORT pinteldest,
    ULONG intelnext,
    ULONG nativenext
    )
{
    USHORT sel;
    DWORD offset;

    offset = *(UNALIGNED PULONG)(pinteldest);
    sel = *(UNALIGNED PUSHORT)(pinteldest+2);

    PUSH_LONG(CS);
    PUSH_LONG(intelnext);
    PUSH_CALLSTACK(intelnext, nativenext);
    ASSERTPtrInTCOrZero((PVOID)nativenext);

    eip = offset;
    CS = sel;

    return (ULONG)(ULONGLONG)pinteldest;  
}

// IRet
ULONG CTRL_INDIR_IRetFrag(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    DWORD CSTemp;

    POP_LONG(intelAddr);
    POP_LONG(CSTemp);
    PopfFrag32(cpu);

    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}

// Now the ret fragments
ULONG CTRL_INDIR_RetnFrag32(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;

    POP_LONG(intelAddr);
    eip = intelAddr;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetnFrag16(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;

    POP_SHORT(intelAddr);
    intelAddr &= 0x0000ffff;
    eip = intelAddr;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetfFrag32(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    ULONG CSTemp;

    POP_LONG(intelAddr);
    POP_LONG(CSTemp);

    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_RetfFrag16(PTHREADSTATE cpu)
{
    ULONG intelAddr, nativeAddr;
    ULONG CSTemp;

    POP_SHORT(intelAddr);
    POP_SHORT(CSTemp);
    intelAddr &= 0x0000ffff;
    eip = intelAddr;
    CS = (USHORT)CSTemp;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retn_iFrag32(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;

    intelAddr = *(DWORD *)esp;
    eip = intelAddr;
    esp += numBytes+4;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retn_iFrag16(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;

    intelAddr = *(USHORT *)esp;
    eip = intelAddr;
    esp += numBytes+2;
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retf_iFrag32(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;
    USHORT CSTemp;

    intelAddr = *(DWORD *)esp;
    CSTemp = *(USHORT *)(esp+sizeof(ULONG));
    eip = intelAddr;
    CS = CSTemp;
    esp += numBytes+sizeof(ULONG)+sizeof(ULONG);
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
ULONG CTRL_INDIR_Retf_iFrag16(PTHREADSTATE cpu, ULONG numBytes)
{
    ULONG intelAddr, nativeAddr;
    USHORT CSTemp;

    intelAddr = *(USHORT *)esp;
    CSTemp = *(USHORT *)(esp+sizeof(USHORT));
    eip = intelAddr;
    CS = CSTemp;
    esp += numBytes+sizeof(USHORT)+sizeof(USHORT);
    POP_CALLSTACK(intelAddr,nativeAddr);
    ASSERTPtrInTCOrZero((PVOID)nativeAddr);

    return nativeAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\fragdata.c ===
/*--

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fragdata.c

Abstract:

    This module contains arrays that are used to connect operations with
    fragments.  There is a fragment description array, and a fragment array.

Author:

    Dave Hastings (daveh) creation-date 08-Jan-1995


Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <instr.h>
#include <config.h>
#include <threadst.h>
#include <frag.h>
#include <fraglib.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <ctrltrns.h>

CONST FRAGDESC Fragments[] = {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   \
        {FastPlaceFn, SlowPlaceFn, Opfl, RegsSet, FlagsNeeded, FlagsSet},

    #include "idata.h"
};

CONST PVOID FragmentArray[] = {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   \
        FragName,

    #include "idata.h"
};

CONST PPLACEOPERATIONFN PlaceFn[] = {
    #define DEF_PLACEFN(Name) Name,

    #include "fndata.h"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\patchfn.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    patchfn.c

Abstract:

    This module contains generic functions to patch fragments.  Structures
    that describe the fragments to be patched.  The structures live in 
    the processor specific directory.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:

    Barry Bond (barrybo) 1-Apr-1995
        Switch the PPC build to the AXP model of patching
            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)
        
        
Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#include "wx86.h"
#include "wx86nt.h"
#include "wx86cpu.h"
#include "cpuassrt.h"
#include "instr.h"
#include "config.h"
#include "fragp.h"
#include "entrypt.h"
#include "compiler.h"
#include "ctrltrns.h"
#include "threadst.h"
#include "instr.h"
#include "frag.h"
#include "ptchstrc.h"
#include "mrsw.h"
#include "tc.h"
#include "codeseq.h"
#include "codesize.h"
#include "opt.h"
#if _ALPHA_
#define _codegen_
#include "soalpha.h"
#undef fTCUnlocked      // this is a field in CPUCONTEXT
ULONG
GetCurrentECU(
    PULONG CodeLocation
    );
#endif

ASSERTNAME;

extern CHAR CallJxxHelper[];
extern CHAR CallJmpDirectHelper[];
extern CHAR IndirectControlTransferHelper[];
extern CHAR IndirectControlTransferFarHelper[];
extern CHAR CallDirectHelper[];
extern CHAR CallDirectHelper2[];
extern CHAR CallIndirectHelper[];
extern CHAR JumpToNextCompilationUnitHelper[];
 
#define OFFSET(type, field) ((LONG)(ULONGLONG)(&((type *)0)->field))

ULONG RegisterOffset[] = {
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i4), // EAX
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i4), // ECX
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i4), // EDX
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i4), // EBX
    OFFSET(THREADSTATE, GpRegs[GP_ESP].i4), // ESP
    OFFSET(THREADSTATE, GpRegs[GP_EBP].i4), // EBP
    OFFSET(THREADSTATE, GpRegs[GP_ESI].i4), // ESI
    OFFSET(THREADSTATE, GpRegs[GP_EDI].i4), // EDI
    OFFSET(THREADSTATE, GpRegs[REG_ES]),    // ES
    OFFSET(THREADSTATE, GpRegs[REG_CS]),    // CS
    OFFSET(THREADSTATE, GpRegs[REG_SS]),    // SS
    OFFSET(THREADSTATE, GpRegs[REG_DS]),    // DS
    OFFSET(THREADSTATE, GpRegs[REG_FS]),    // FS
    OFFSET(THREADSTATE, GpRegs[REG_GS]),    // GS
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i2), // AX
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i2), // CX
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i2), // DX
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i2), // BX
    OFFSET(THREADSTATE, GpRegs[GP_ESP].i2), // SP
    OFFSET(THREADSTATE, GpRegs[GP_EBP].i2), // BP
    OFFSET(THREADSTATE, GpRegs[GP_ESI].i2), // SI
    OFFSET(THREADSTATE, GpRegs[GP_EDI].i2), // DI
    OFFSET(THREADSTATE, GpRegs[GP_EAX].i1), // AL
    OFFSET(THREADSTATE, GpRegs[GP_ECX].i1), // CL
    OFFSET(THREADSTATE, GpRegs[GP_EDX].i1), // DL
    OFFSET(THREADSTATE, GpRegs[GP_EBX].i1), // BL
    OFFSET(THREADSTATE, GpRegs[GP_EAX].hb), // AH
    OFFSET(THREADSTATE, GpRegs[GP_ECX].hb), // CH
    OFFSET(THREADSTATE, GpRegs[GP_EDX].hb), // DH
    OFFSET(THREADSTATE, GpRegs[GP_EBX].hb)  // BH
};


ULONG
PatchJumpToNextCompilationUnit(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
    )
/*++

Routine Description:

    This routine ends basic blocks when the native address of the next
    basic block is known.
     
Arguments:

    PatchAddr -- address of JumpToNextCompilationUnit code in the TC
    IntelDest -- intel address of the next basic block

Return Value:

    Native address to jump to to resume execution.
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }
    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the next basic block, and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;  

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - JumpToNextCompilationUnit_SIZE;
        //
        // The Translation Cache wasn't flushed - replace the
        // JumpToNextCompilationUnit fragment by JumpToNextCompilationUnit2
        //
        NativeSize=GenJumpToNextCompilationUnit2(CodeLocation,
                                                 FALSE, // patching, not compiling
#if _ALPHA_
                                                 GetCurrentECU(CodeLocation),
#endif
                                                 NativeDest,
                                                 0);
        
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
        
    } else {

        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);


    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - NativeDest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - NativeDest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)&EndTranslatedCode;  
    }
}

ULONG
PlaceJxx(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize = (*pfn)(CodeLocation,
#if _ALPHA_
                        CurrentECU,
#endif
                        Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);

    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        //
        NativeSize += GenJxxBody(CodeLocation,
#if _ALPHA_
                                 CurrentECU,
#endif
                                 Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBody2(CodeLocation,
                    TRUE,   // compiling, not patching
#if _ALPHA_
                    CurrentECU,
#endif
                    (ULONG)IntelDest,
                    (ULONG)(ULONGLONG)EP); 
    }
    return NativeSize;
}


ULONG
PlaceJxxSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to load RegEip with the branch-not-taken value
    //
    NativeSize = GenJxxStartSlow(CodeLocation,
#if _ALPHA_
                                 CurrentECU,
#endif
                                 Instruction);

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize += (*pfn)(CodeLocation+NativeSize/sizeof(ULONG),
#if _ALPHA_
                         CurrentECU,
#endif
                         Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);

    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        //
        NativeSize += GenJxxBodySlow(CodeLocation,
#if _ALPHA_
                                     CurrentECU,
#endif
                                     Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBodySlow2(CodeLocation,
                       TRUE,    // compiling, not patching
#if _ALPHA_
                       CurrentECU,
#endif
                       (ULONG)IntelDest,
                       (ULONG)(ULONGLONG)EP);  
    }
    return NativeSize;
}


ULONG
PlaceJxxFwd(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

     This routine copies the fragment into place, and modifies the 
     instructions that load the destination into the register
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PPLACEOPERATIONFN pfn;
    PENTRYPOINT EP;
    ULONG NativeSize;

    //
    // Generate the code to determine if the branch is taken or not
    //
    pfn = (PPLACEOPERATIONFN)FragmentArray[Instruction->Operation];
    NativeSize = (*pfn)(CodeLocation,
#if _ALPHA_
                        CurrentECU,
#endif
                        Instruction);
    CodeLocation += NativeSize/sizeof(ULONG);


    // Let's see if we can place the patched version immediately

    // ASSUME:  The first argument is always a NOCODEGEN
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );
    IntelDest = Instruction->Operand1.Immed;

    // Assert that the branch is going forward.
    CPUASSERT(IntelDest > Instruction->IntelAddress);

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // knowing NativeDest requires compilation.  Just place the unpatched
        // version to be patched later.
        NativeSize += GenJxxBodyFwd(CodeLocation,
#if _ALPHA_
                                    CurrentECU,
#endif
                                    Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize += GenJxxBodyFwd2(CodeLocation,
                       TRUE,    // compiling, not patching
#if _ALPHA_
                       CurrentECU,
#endif
                       (ULONG)(ULONGLONG)EP, 
                       0);
    }
    return NativeSize;
}


ULONG
PatchJxx(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXSTRUC by a JXXSTRC2 at runtime.  It is called
     when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUC in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC
    // write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxx_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBody2
        //
        NativeSize=GenJxxBody2(CodeLocation,
                               FALSE, // patching, not compiling
#if _ALPHA_
                               GetCurrentECU(CodeLocation),
#endif
                               (DWORD)IntelDest,
                               (DWORD)NativeDest);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {

        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PatchJxxSlow(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXSTRUC by a JXXSTRC2 at runtime.  It is called
     when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUC in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC
    // write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxxSlow_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBody2
        //
        NativeSize = GenJxxBodySlow2(CodeLocation,
                                     FALSE, // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     (DWORD)IntelDest,
                                     (DWORD)NativeDest);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PatchJxxFwd(
    IN ULONG IntelDest,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

     This routine replaces a JXXBODYFWD by a JXXBODYFWD2 at runtime.  It is
     called when the conditional branch is taken, and the native address of the
     destination is not yet known.
     
Arguments:

    inteldest  -- Intel destination address if the branch is taken
    patchaddr  -- address of the JXXSTRUCFWD in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution.
    
--*/
{
    ULONG NativeDest;       // branch-taken address
    PULONG fragaddr;        // address of START of the fragment
    DWORD TCTimestamp;      // old timestamp of the Translation Cache
    ULONG NativeSize;
    DECLARE_CPU;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch over to being a TC writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Get the native destination address of the branch and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJxxFwd_PATCHRA_OFFSET;
        //
        // The Translation Cache was not flushed while switching to a TC
        // writer or by the compilation.  Replace JxxBody by the faster
        // JxxBodyFwd2
        //
        NativeSize = GenJxxBodyFwd2(CodeLocation,
                                    FALSE, // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    (DWORD)NativeDest,
                                    0);

        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
            
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader again
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a reader.  nativedest is invalid
        // so do an EndTranslatedCode instead.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG
PlaceJmpDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpDirect(CodeLocation,
#if _ALPHA_
                                      CurrentECU,
#endif
                                      Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpDirect2(CodeLocation,
                                       TRUE,    // compiling, not patching
#if _ALPHA_
                                       CurrentECU,
#endif
                                       (ULONG)(ULONGLONG)  EP,
                                       IntelDest);
    }

    return NativeSize;
}


ULONG 
PatchJmpDirect(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;
    
    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpDirect2(CodeLocation,
                                       FALSE, // patching, not compiling
#if _ALPHA_
                                       GetCurrentECU(CodeLocation),
#endif
                                       (ULONG)NativeDest,
                                       IntelDest);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpDirectSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpDirectSlow(CodeLocation,
#if _ALPHA_
                                          CurrentECU,
#endif
                                          Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpDirectSlow2(CodeLocation,
                                           TRUE, // compiling, not patching
#if _ALPHA_
                                           CurrentECU,
#endif
                                           (ULONG)(ULONGLONG)  EP,
                                           IntelDest);
    }

    return NativeSize;
}


ULONG 
PatchJmpDirectSlow(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;


    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpDirectSlow_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpDirectSlow2(CodeLocation,
                                           FALSE, // patching, not compiling
#if _ALPHA_
                                           GetCurrentECU(CodeLocation),
#endif
                                           (ULONG)NativeDest,
                                           IntelDest);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpFwdDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_NOCODEGEN );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched version for
        // now and patch it later if necessary
        //
        NativeSize = GenCallJmpFwdDirect(CodeLocation,
#if _ALPHA_
                                         CurrentECU,
#endif
                                         Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpFwdDirect2(CodeLocation,
                                          TRUE, // compiling, not patching
#if _ALPHA_
                                          CurrentECU,
#endif
                                          (ULONG)(ULONGLONG)  EP,
                                          0);
    }

    return NativeSize;
}


ULONG 
PatchJmpFwdDirect(
    IN PULONG PatchAddr,
    IN ULONG IntelDest
)
/*++

Routine Description:

    This routine patches a JMPDIRECT to a JMPDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    IntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;
    DECLARE_CPU;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpFwdDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPDIRECT
        // fragment by JMPDIRECT2
        //
        NativeSize = GenCallJmpFwdDirect2(CodeLocation,
                                          FALSE, // patching, not compiling
#if _ALPHA_
                                          GetCurrentECU(CodeLocation),
#endif
                                          (ULONG)NativeDest,
                                          0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceJmpfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional jump fragment into place and patches
    the instructions that jump to EndTranslatedCode
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    PENTRYPOINT EP;
    ULONG NativeSize;

    // ASSUME:  The first argument is always an IMM, pointing at the address
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );
    IntelDest = Instruction->Operand1.Immed;

    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)*(UNALIGNED DWORD *)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        NativeSize = GenCallJmpfDirect(CodeLocation,
#if _ALPHA_
                                       CurrentECU,
#endif
                                       Instruction);
        
    } else {
        //
        // We can place the patched version right away!
        //
        NativeSize = GenCallJmpfDirect2(CodeLocation,
                                        TRUE, // compiling, not patching
#if _ALPHA_
                                        CurrentECU,
#endif
                                        (ULONG)(ULONGLONG)  EP,
                                        0);
    }

    return NativeSize;
}



ULONG 
PatchJmpfDirect(
    PTHREADSTATE cpu,
    IN PULONG pIntelDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a JMPFDIRECT to a JMPFDIRECT2.  It is called when
    the native destination address of a jmp instruction is not yet known.
    It patches the jmp to jump directly to the corresponding native code.
     
Arguments:

    PatchAddr -- address of the JMPDIRECT in the Translation Cache
    pIntelDest -- intel address of the destination of the jmp

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    PVOID IntelDest;
    USHORT Sel;
    ULONG NativeSize;

    if (cpu->flag_tf) {
        return (ULONG)(ULONGLONG)&EndTranslatedCode;
    }

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the destination of the jmp and get the TC write lock
    //
    IntelDest = (PVOID)*(UNALIGNED DWORD *)pIntelDest;
    Sel = *(UNALIGNED PUSHORT)(pIntelDest+1);
    eip = (ULONG)(ULONGLONG)  IntelDest;
    CS = Sel;
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip(IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallJmpfDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the JMPFDIRECT
        // fragment by JMPFDIRECT2
        //
        NativeSize = GenCallJmpfDirect2(CodeLocation,
                                        FALSE,  // patching, not compiling
#if _ALPHA_
                                        GetCurrentECU(CodeLocation),
#endif
                                        (ULONG)NativeDest,
                                        0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            (PVOID)CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Switch back to being a TC reader
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed - nativedest is valid
        //
        return NativeDest;
    } else {
        //
        // TC was flushed while becomming a TC reader again - nativedest
        // is now bogus.
        //
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}

ULONG
PlaceCallDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional call fragment into place.
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    DWORD IntelNext;
    PENTRYPOINT EP;

    // ASSUME:  The first argument is always an immediate
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );

    IntelDest = Instruction->Operand1.Immed;
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        GenCallDirect(CodeLocation,
#if _ALPHA_
                      CurrentECU,
#endif
                      Instruction);
    } else {
        //
        // We can place the patched version right away!  Deterime if the
        // NativeNext address is known.
        //
        IntelNext = Instruction->Operand2.Immed;

        //
        // If the current instruction is not the last one compiled, then
        // NativeNext is CodeLocation+CallDirect_SIZE and CallDirect3 can
        // be placed right away.
        //
        if (Instruction != &InstructionStream[NumberOfInstructions-1]) {
            GenCallDirect3(CodeLocation,
                           TRUE, // compiling, not patching
#if _ALPHA_
                           CurrentECU,
#endif
                           (ULONG)(ULONGLONG)  EP,
                           (ULONG)(ULONGLONG)  (CodeLocation+CallDirect_SIZE));
        } else {
            GenCallDirect2(CodeLocation,
                           TRUE, // compiling, not patching
#if _ALPHA_
                           CurrentECU,
#endif
                           (ULONG)(ULONGLONG)  EP,
                           0);
        }
    }
    return CallDirect_SIZE * sizeof(ULONG);
}


ULONG
PlaceCallfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine copies the unconditional FAR call fragment into place.
     
Arguments:

    Instruction - Supplies a description of the instruction the fragment
        represents
    CodeLocation - Supplies the address the code for the fragment has been
        copied to

Return Value:

    Size of code placed at CodeLocation
    
--*/
{
    DWORD IntelDest;
    DWORD IntelAddr;
    DWORD IntelNext;
    PVOID NativeNext;
    PENTRYPOINT EP;

    // ASSUME:  The first two arguments are pIntelDest and IntelNext, stored
    //          as immediates.
    CPUASSERT( Instruction->Operand1.Type == OPND_IMM );
    CPUASSERT( Instruction->Operand2.Type == OPND_IMM );

    IntelAddr = Instruction->Operand1.Immed;

    // Get the offset portion of the address (skipping the selector)
    IntelDest = *(UNALIGNED DWORD *)(IntelAddr+2);
    EP = NativeAddressFromEipNoCompileEPWrite((PVOID)IntelDest);

    if (EP == NULL) {
        //
        // Knowing NativeDest requires compilation.  Just place the unpatched
        // version for now and patch it later if necessary
        //
        GenCallfDirect(CodeLocation,
#if _ALPHA_
                       CurrentECU,
#endif
                       Instruction);
    } else {
        //
        // We can place the patched version right away!  Deterime if the
        // NativeNext address is known.
        //
        IntelNext = Instruction->Operand2.Immed;

        //
        // If the current instruction is not the last one compiled, then
        // NativeNext is CodeLocation+CallfDirect_SIZE and CallDirect3 can
        // be placed right away.
        //
        if (Instruction != &InstructionStream[NumberOfInstructions-1]) {
            GenCallfDirect3(CodeLocation,
                            TRUE, // compiling, not patching
#if _ALPHA_
                            CurrentECU,
#endif
                            (ULONG)(ULONGLONG)  EP,
                            (ULONG)(ULONGLONG)  (CodeLocation+CallfDirect_SIZE));
        } else {
            GenCallfDirect2(CodeLocation,
                            TRUE, // compiling, not patching
#if _ALPHA_
                            CurrentECU,
#endif
                            (ULONG)(ULONGLONG)  EP,
                            0);
        }
    }
    return CallfDirect_SIZE * sizeof(ULONG);
}

DWORD
PatchCallDirectExceptionFilter(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Called if CTRL_CallFrag() throws an exception from within
    PatchCallDirect().  If this happens, the Translation Cache is in fact
    unlocked, although cpu->fTCUnlocked == FALSE.  Need to fix this up before
    CpuResetToConsistentState() gets run and unlocks the cache a second time.

Arguments:

    cpu
    
Return Value:

    None.

--*/
{
    //
    // Indicate the TC read lock is not held.
    //
    cpu->fTCUnlocked = TRUE;

    //
    // Continue unwinding the stack
    //
    return EXCEPTION_CONTINUE_SEARCH;
}


ULONG 
PatchCallDirect(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLDIRECT to a CALLDIRECT2.  It is called when
    the native destination address of a call instruction is not yet known.
    It patches the call to jump directly to the corresponding native code.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    ULONG NativeSize;

    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the code at the destination of the call and get the TC write lock
    //
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip((PVOID)IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the CALLDIRECT
        // fragment by CALLDIRECT2
        //
        NativeSize = GenCallDirect2(CodeLocation,
                                    FALSE,  // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    NativeDest,
                                    0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (Cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(Cpu);
        }
    }

    //
    // Push IntelNext on the stack and update the stack optimization code.
    // This must be done while still in TC write mode.  If it isn't, then
    // the transition back to TC reader may allow a TC cache flush, invalidating
    // nativedest before it is written into the stack optimization.  (The
    // stack optimization is blown away whenever the TC is flushed, so if
    // it is written in BEFORE the flush, it will just get blown away.
    //
    try {
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0 /* nativenext is unknown */);
    } _except(PatchCallDirectExceptionFilter(Cpu)) {
        // nothing to do - the exception filter does everything
    }

    //
    // Become a TC reader again.
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);
    Cpu->fTCUnlocked = FALSE;

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again.
        //
        return NativeDest;
    } else {
        //
        // TC was flushed - nativedest is invalid.  The callstack optimization
        // was deleted when the TC flush occurred, so do an EndTranslatedCode
        // instead.
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG 
PatchCallfDirect(
    IN PTHREADSTATE cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLFDIRECT to a CALLFDIRECT2.  It is called when
    the native destination address of a call instruction is not yet known.
    It patches the call to jump directly to the corresponding native code.
     
Arguments:

    cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeDest;
    PVOID IntelDest;
    ULONG NativeSize;


    //
    // Switch from being a TC reader to a writer
    //
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    //
    // Compile the code at the destination of the call and get the TC write lock
    //
    IntelDest = (PVOID)*(UNALIGNED DWORD *)pIntelDest;
    NativeDest = (ULONG)(ULONGLONG)  NativeAddressFromEip(IntelDest, TRUE)->nativeStart;

    if (TCTimestamp == TranslationCacheTimestamp) {
        PULONG CodeLocation = PatchAddr - CallfDirect_PATCHRA_OFFSET;
        //
        // The Translation Cache wasn't flushed - replace the CALLDIRECT
        // fragment by CALLDIRECT2
        //
        NativeSize = GenCallfDirect2(CodeLocation,
                                     FALSE,  // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     NativeDest,
                                     0);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );
    } else {
        TCTimestamp = TranslationCacheTimestamp;

        if (cpu->CSTimestamp != TCTimestamp) {
            //
            // The cache was flushed by another thread in the small window
            // between mrsw calls in this thread, we plan on jumping directly
            // to NativeDest, so the CPU callstack needs to be flushed.
            // Normally this would be done in the CpuSimulate() loop as a
            // result of jumping to EndTranslatedCode.
            //
            FlushCallstack(cpu);
        }
    }

    //
    // Push IntelNext on the stack and update the stack optimization code.
    // This must be done while still in TC write mode.  If it isn't, then
    // the transition back to TC reader may allow a TC cache flush, invalidating
    // nativedest before it is written into the stack optimization.  (The
    // stack optimization is blown away whenever the TC is flushed, so if
    // it is written in BEFORE the flush, it will just get blown away.
    //
    try {
        CTRL_CallfFrag(cpu, pIntelDest, IntelNext, 0 /* nativenext is unknown */);
    } _except(PatchCallDirectExceptionFilter(cpu)) {
        // nothing to do - the exception filter does everything
    }

    //
    // Become a TC reader again.
    //
    MrswWriterExit(&MrswTC);
    MrswReaderEnter(&MrswTC);
    cpu->fTCUnlocked = FALSE;

    if (TCTimestamp == TranslationCacheTimestamp) {
        //
        // TC was not flushed while becomming a reader again.
        //
        return NativeDest;
    } else {
        //
        // TC was flushed - nativedest is invalid.  The callstack optimization
        // was deleted when the TC flush occurred, so do an EndTranslatedCode
        // instead.
        return (ULONG)(ULONGLONG)  &EndTranslatedCode;
    }
}


ULONG 
PatchCallDirect2(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN ULONG NativeDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a CALLDIRECT2 to a CALLDIRECT3.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    NativeDest  -- native address of the destination of the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
        PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLDIRECT2 by CALLDIRECT3.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);

            // The CALLDIRECT2 code is now gone, so set up for the call and
            // then go to EndTranslatedCode to make the control transfer.
            //
            CTRL_CallFrag(Cpu,
                          IntelDest,
                          IntelNext,
                          0   // nativenext is also unknown
                          );

            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }

        CodeLocation = PatchAddr - CallDirect2_PATCHRA_OFFSET;
        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLDIRECT2 to be CALLDIRECT3
        //
        NativeSize = GenCallDirect3(CodeLocation,
                                    FALSE,  // patching, not compiling
#if _ALPHA_
                                    GetCurrentECU(CodeLocation),
#endif
                                    NativeDest,
                                    NativeNext);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, NativeNext);

        //
        // Switch back to being a TC reader
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // TC was flushed while we were becomming a reader again.
            // nativedest and nativenext are invalid, but stack optimization
            // code was flushed.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    } else {        // NativeNext == NULL, TC locked for Read
        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // Cache was flushed by another thread.  NativeDest is invalid.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    }

    return NativeDest;
}


ULONG 
PatchCallfDirect2(
    IN PTHREADSTATE Cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN ULONG NativeDest,
    IN PULONG PatchAddr
)
/*++

Routine Description:

    This routine patches a CALLFDIRECT2 to a CALLFDIRECT3.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    NativeDest  -- native address of the destination of the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    Native address to jump to in order to resume execution
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
        PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLDIRECT2 by CALLDIRECT3.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);

            // The CALLFDIRECT2 code is now gone, so set up for the call and
            // then go to EndTranslatedCode to make the control transfer.
            //
            CTRL_CallfFrag(Cpu,
                           pIntelDest,
                           IntelNext,
                           0   // nativenext is also unknown
                           );

            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }

        CodeLocation = PatchAddr - CallfDirect2_PATCHRA_OFFSET;
        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLFDIRECT2 to be CALLFDIRECT3
        //
        NativeSize = GenCallfDirect3(CodeLocation,
                                     FALSE,  // patching, not compiling
#if _ALPHA_
                                     GetCurrentECU(CodeLocation),
#endif
                                     NativeDest,
                                     NativeNext);
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, NativeNext);

        //
        // Switch back to being a TC reader
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // TC was flushed while we were becomming a reader again.
            // nativedest and nativenext are invalid, but stack optimization
            // code was flushed.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    } else {        // NativeNext == NULL, TC locked for Read
        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, 0);

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // Cache was flushed by another thread.  NativeDest is invalid.
            //
            return (ULONG)(ULONGLONG)  &EndTranslatedCode;
        }
    }

    return NativeDest;
}


DWORD
PatchCallIndirectExceptionFilter(
    PTHREADSTATE cpu
    )
/*++

Routine Description:

    Called if CTRL_CallFrag() throws an exception from within
    PatchCallIndirect().  If this happens, the Translation Cache Write lock
    is being held.  This must be released before the exception can be
    allowed to continue.

Arguments:

    cpu
    
Return Value:

    None.

--*/
{
    //
    // Release the TC write lock.
    //
    MrswWriterExit(&MrswTC);

    //
    // Indicate the TC read lock is not held, either
    //
    cpu->fTCUnlocked = TRUE;

    //
    // Continue unwinding the stack
    //
    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
PatchCallIndirect(
    IN PTHREADSTATE Cpu,
    IN ULONG IntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLINDIRECT to a CALLINDIRECT2.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    IntelDest -- intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    None.  cpu->Eip updated to be IntelDest.
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    NativeNext = (ULONG)(ULONGLONG)  NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
         PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLINDIRECT by CALLINDIRECT2.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);


            // The CALLINDIRECT code is now gone, so set up for the call
            // without patching anything
            //
            CTRL_CallFrag(
                Cpu,
                IntelDest,
                IntelNext,
                0     // nativenext is unknown
                );

            return;
        }

        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLINDIRECT to be CALLINDIRECT2
        //
        CodeLocation = PatchAddr - CallIndirect_PATCHRA_OFFSET;
        NativeSize = GenCallIndirect2(CodeLocation,
                                      FALSE,  // patching, not compiling
#if _ALPHA_
                                      GetCurrentECU(CodeLocation),
#endif
                                      NativeNext,
                                      getUniqueIndex());
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        _try {
            CTRL_CallFrag(Cpu, IntelDest, IntelNext, NativeNext);
        } _except(PatchCallIndirectExceptionFilter(Cpu)) {
            // nothing to do - the exception filter does everything
        }

        //
        // Switch back to being a TC reader.  TC flushes during the switch
        // are OK and require no extra work.
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

    } else {        // NativeNext == NULL, TC locked for read.

        CTRL_CallFrag(Cpu, IntelDest, IntelNext, 0);
    }

    return;
}

VOID
PatchCallfIndirect(
    IN PTHREADSTATE Cpu,
    IN PUSHORT pIntelDest,
    IN ULONG IntelNext,
    IN PULONG PatchAddr
    )
/*++

Routine Description:

    This routine patches a CALLFINDIRECT to a CALLFINDIRECT2.  It is called when
    the native destination address of the instruction after the call is not yet
    known.  It patches the fragment to place the native address of the
    instruction after the call on the optimized callstack.
     
Arguments:

    Cpu       -- per-thread info
    pIntelDest-- ptr to SEL:OFFSET intel address of the destination of the call
    IntelNext -- intel address of the instruction following the call
    PatchAddr -- address of the CALLDIRECT2 in the Translation Cache

Return Value:

    None.  cpu->eip updated to IntelDest
    
--*/
{
    DWORD TCTimestamp;
    ULONG NativeNext;
    ULONG IntelDest;
    ULONG NativeSize;

    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);

    IntelDest = *(UNALIGNED DWORD *)pIntelDest;
    NativeNext = (ULONG)(ULONGLONG)   NativeAddressFromEipNoCompile((PVOID)IntelNext);

    if (NativeNext) {
         PULONG CodeLocation;

        //
        // The code at the return address from the call has already been
        // compiled.  Replace CALLINDIRECT by CALLINDIRECT2.  TC is locked
        // for write.
        //

        if (TCTimestamp != TranslationCacheTimestamp) {
            //
            // The TC was flushed while switching from reader to writer.
            // Become a TC reader again
            //
            MrswWriterExit(&MrswTC);
            MrswReaderEnter(&MrswTC);


            // The CALLFINDIRECT code is now gone, so set up for the call
            // without patching anything
            //
            CTRL_CallfFrag(
                Cpu,
                pIntelDest,
                IntelNext,
                0     // nativenext is unknown
                );

            return;
        }

        //
        // Else the TC was not flushed, and nativenext is now known.  Patch
        // CALLFINDIRECT to be CALLFINDIRECT2
        //
        CodeLocation = PatchAddr - CallfIndirect_PATCHRA_OFFSET;
        NativeSize = GenCallfIndirect2(CodeLocation,
                                       FALSE,  // patching, not compiling
#if _ALPHA_
                                       GetCurrentECU(CodeLocation),
#endif
                                       NativeNext,
                                       getUniqueIndex());
        NtFlushInstructionCache(
            NtCurrentProcess(),
            CodeLocation, 
            NativeSize
            );

        //
        // Push IntelNext on the stack and update the stack optimization code.
        // This must be done while still in TC write mode.  If it isn't, then
        // the transition back to TC reader may allow a TC cache flush, invalidating
        // nativedest before it is written into the stack optimization.  (The
        // stack optimization is blown away whenever the TC is flushed, so if
        // it is written in BEFORE the flush, it will just get blown away.
        //
        _try {
            CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, NativeNext);
        } _except(PatchCallIndirectExceptionFilter(Cpu)) {
            // nothing to do - the exception filter does everything
        }

        //
        // Switch back to being a TC reader.  TC flushes during the switch
        // are OK and require no extra work.
        //
        MrswWriterExit(&MrswTC);
        MrswReaderEnter(&MrswTC);

    } else {        // NativeNext == NULL, TC locked for read.

        CTRL_CallfFrag(Cpu, pIntelDest, IntelNext, 0);
    }

    return;
}



//*********************************************************************************
// Below are functions for the Indirect Control Transfer Table
//*********************************************************************************

// This number must be below 0xffff, because we want to be able to load it with just
// one instruction (now we use ori).  It should also be a factor of two to get good
// code generation for % (so that we won't have to use a division instruction).
#define MAX_TABLE_ENTRIES   0x1000

typedef struct _IndirControlTransferTable {
    ULONG intelAddr;
    ULONG nativeAddr;
} INDIRCONTROLTRANSFERTABLE, *PINDIRCONTROLTRANSFERTABLE;

INDIRCONTROLTRANSFERTABLE IndirControlTransferTable[MAX_TABLE_ENTRIES];

// The last used index in the table
ULONG lastTableIndex;

ULONG
getUniqueIndex(
    VOID
    )
/*++

Routine Description:

    This function returns the next free index to the indirect control
    transfer table.  If it reaches the end of the table, it wraps around.
    NOTE:  we need not worry about synchronization  here, because we have
    an Entry Point write lock whenever we are called.

Arguments:

    none

Return Value:

    An index into the table

--*/
{
    return (lastTableIndex = ((lastTableIndex + 1) % MAX_TABLE_ENTRIES));
}

VOID
FlushIndirControlTransferTable(
    VOID
    )
/*++

Routine Description:

    This routine flushes the Indirect Control Transfer Table
    NOTE:  we need not worry about synchronizations here, because the routine
    which calls us (FlushTranslationCache) has a Translation Cache write lock.

Arguments:

    none

Return Value:

    none

--*/
{
    RtlZeroMemory (IndirControlTransferTable, sizeof(INDIRCONTROLTRANSFERTABLE)*MAX_TABLE_ENTRIES);
    lastTableIndex = 0;
}

ULONG
IndirectControlTransfer(
    IN ULONG tableEntry,
    IN ULONG intelAddr,
    IN PTHREADSTATE cpu
    )
/*++

Routine Description:

    This routine is used by an indirect control transfer operation to try
    and save a call to the Entry Point Manager.

Arguments:

    tableEntry -- The index of the table entry where information might be
        available about intelAddr

    intelAddr -- The intel address we want to go to

    cpu -- pointer to per-thread CPU data

Return Value:

    The native address we want to go to

--*/
{
    ULONG nativeAddr;
    DWORD TCTimestamp;

    //
    // Detect apps which do the following:
    //    call foo
    // where
    //    foo:   mov eax, [esp]
    //           ...
    //           jmp eax        ; this is really a 'ret' instruction
    //
    // This is the way _alloca() works - you call it with eax==number of bytes
    // to allocate, and it jumps back to its caller with esp munged.
    //
    // What happens is the callstack cache gets out-of-sync.  If the app
    // is trying to do an indirect jump to the address already on the
    // callstack cache, we will pop the callstack cache.
    //
    if (ISTOPOF_CALLSTACK(intelAddr)) {
        POP_CALLSTACK(intelAddr, nativeAddr);
        if (nativeAddr) {
            return nativeAddr;
        }
    }

    // First see if the table is filled in correctly already
    MrswReaderEnter(&MrswIndirTable);
    if (IndirControlTransferTable[tableEntry].intelAddr == intelAddr){
        nativeAddr = IndirControlTransferTable[tableEntry].nativeAddr;
        if (nativeAddr) {
            MrswReaderExit(&MrswIndirTable);
            return nativeAddr;
        }
    }
    MrswReaderExit(&MrswIndirTable);

    // Give up the translation cache reading lock so that we can call NativeAddressFromEip
    TCTimestamp = TranslationCacheTimestamp;
    MrswReaderExit(&MrswTC);
    nativeAddr = (ULONG) (ULONGLONG)NativeAddressFromEip((PVOID)intelAddr, FALSE)->nativeStart; 

    // Note:  we now have a TC read lock obtained by NativeAddressFromEip.  
    if (TCTimestamp == TranslationCacheTimestamp) {
        // We haven't flushed the cache.  Save the native address in the table.
        MrswWriterEnter(&MrswIndirTable);
        IndirControlTransferTable[tableEntry].intelAddr = intelAddr;
        IndirControlTransferTable[tableEntry].nativeAddr = nativeAddr;
        MrswWriterExit(&MrswIndirTable);
    } else {
        //
        // Translation cache was flushed, possibly by another thread.
        // Flush our callstack before resuming execution of RISC code
        // in the Translation Cache.
        //
        FlushCallstack(cpu);
    }
    // Return the native address to IndirectControlTransferHelper which will go there.
    return nativeAddr;
}

ULONG
IndirectControlTransferFar(
    IN PTHREADSTATE cpu,
    IN PUSHORT pintelAddr,
    IN ULONG tableEntry
    )
/*++

Routine Description:

    This routine is used by a FAR indirect control transfer operation to try
    and save a call to the Entry Point Manager.

Arguments:

    tableEntry -- The index of the table entry where information might be
        available about intelAddr

    pintelAddr -- Pointer to SEL:OFFSET intel address we want to go to

Return Value:

    The native address we want to go to

--*/
{
    USHORT Sel;
    ULONG Offset;

    Offset = *(UNALIGNED PULONG)pintelAddr;
    Sel = *(UNALIGNED PUSHORT)(pintelAddr+2);

    CS = Sel;
    eip = Offset;

    return IndirectControlTransfer(tableEntry, Offset, cpu);
}



ULONG
PlaceNop(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    )
{
    return 0;
}


#if _ALPHA_
ULONG
GetCurrentECU(
    PULONG CodeLocation
    )
/*++

Routine Description:

    This routine returns the correct ECU.  CurrentECU is the target for 
    branch instructions when a fragment wants to jump to EndTranslatedCode.
    
    N.B.  This routine cannot change the global CurrentECU.  This is set in
          Compile(), and is the only way to locate the ECU at the end of 
          the translation cache if the exception info hasn't been placed
          yet.
    
Arguments:
    
    CodeLocation -- The code location which will be patched.
                            
Return Value:

    None.
    
--*/
{
    //
    // Find an EndCompilationUnit fragment by searching the Translation Cache
    // for the next EXCEPTIONDATA_SIGNATURE.  The code immediately before it
    // is an EndCompilationUnit fragment.
    //
    while (*CodeLocation != EXCEPTIONDATA_SIGNATURE) {
        CodeLocation++;
    }
    return (ULONG)(ULONGLONG)(CodeLocation-EndCompilationUnit_SIZE); 
}
#endif      // _ALPHA_-only
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\ctrltrns.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ctrltrns.h

Abstract:
    
    Prototypes for control transfer fragments.

Author:

    10-July-1995 t-orig (Ori Gershony)

Revision History:

--*/

BOOL
InitializeCallstack(
    VOID
    );

VOID
FlushCallstack(
    PTHREADSTATE cpu
    );

// Called by the assembly-langauge CallDirectX fragments
ULONG
CTRL_CallFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    ULONG inteldest,
    ULONG intelnext,
    ULONG nativenext
    );

ULONG
CTRL_CallfFrag(
    PTHREADSTATE cpu,       // cpu state pointer
    PUSHORT pinteldest,
    ULONG intelnext,
    ULONG nativenext
    );

// And now the ret fragments
ULONG CTRL_INDIR_IRetFrag(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetnFrag32(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetnFrag16(PTHREADSTATE cpu);
ULONG CTRL_INDIR_Retn_iFrag32(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_Retn_iFrag16(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_RetfFrag32(PTHREADSTATE cpu);
ULONG CTRL_INDIR_RetfFrag16(PTHREADSTATE cpu);
ULONG CTRL_INDIR_Retf_iFrag32(PTHREADSTATE cpu, ULONG numBytes);
ULONG CTRL_INDIR_Retf_iFrag16(PTHREADSTATE cpu, ULONG numBytes);

// And a few others
VOID BOPFrag(PTHREADSTATE cpu, ULONG bop, ULONG imm);
VOID UnsimulateFrag(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\ptchstrc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    patchstrc.h

Abstract:

    This include file contains structures describing the patchable 
    fragments.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:


--*/

#ifndef _PATCHSTRC_H_
#define _PATCHSTRC_H_


ULONG
PlaceJxx(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJxxSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJxxFwd(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceJmpDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpDirectSlow(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpFwdDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceJmpfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
ULONG
PlaceCallDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceCallfDirect(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );

ULONG
PlaceNop(
    IN PULONG CodeLocation,
#if _ALPHA_
    IN ULONG CurrentECU,
#endif
    IN PINSTRUCTION Instruction
    );
    
extern ULONG EndTranslatedCode[];    
extern CONST PVOID FragmentArray[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\fraglib\cpu\process.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    Process.c

Abstract:

    This module contains the entrypoints for processing instructions.

Author:

    Barry Bond (barrybo) creation-date 1-Apr-1996


Revision History:

            24-Aug-1999 [askhalid] copied from 32-bit wx86 directory and make work for 64bit.
            20-Sept-1999[barrybo]  added FRAG2REF(LockCmpXchg8bFrag32, ULONGLONG)


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define _WX86CPUAPI_
#include <wx86.h>
#include <wx86nt.h>
#include <wx86cpu.h>
#include <cpuassrt.h>
#include <config.h>
#include <instr.h>
#include <threadst.h>
#include <frag.h>
#include <compiler.h>
#include <ptchstrc.h>
#include <codeseq.h>
#include <findpc.h>
#include <tc.h>
#include <opt.h>
#include <atomic.h>
#include <cpunotif.h>
#define _codegen_
#if _PPC_
#include <soppc.h>
#elif _MIPS_
#include <somips.h>
#elif _ALPHA_
#include <soalpha.h>
ENTRYPOINT EntrypointECU;
#endif
#include <process.h>

ASSERTNAME;

#define MAX_OPERAND_SIZE 32     // allow upto 32 instructions per operand


DWORD RegCache[NUM_CACHE_REGS];     // One entry for each cached register
DWORD LastRegDeleted;

DWORD Arg1Contents;   // GP_ number of x86 reg held in A1, or NO_REG
DWORD Arg2Contents;   // GP_ number of x86 reg held in A1, or NO_REG

typedef enum _Operand_Op {
#if _ALPHA_
    OP_MovRegToReg8B,
#endif
    OP_MovToMem32B,
    OP_MovToMem32W,
    OP_MovToMem32D,
    OP_MovToMem16B,
    OP_MovToMem16W,
    OP_MovToMem16D,
    OP_MovToMem8B,
    OP_MovToMem8D,
    OP_MovRegToReg32,
    OP_MovRegToReg16,
    OP_MovRegToReg8
} OPERAND_OP;


CONST PPLACEOPERANDFN OpFragments[] = {
#if _ALPHA_
    GenOperandMovRegToReg8B,
#endif
    GenOperandMovToMem32B,
    GenOperandMovToMem32B,
    GenOperandMovToMem32D,
    GenOperandMovToMem16B,
    GenOperandMovToMem16W,
#if _ALPHA_
    GenOperandMovToMem16D,
    GenOperandMovToMem8B,
    GenOperandMovToMem8D,
#else
    GenOperandMovToMem16W,
    GenOperandMovToMem8B,
    GenOperandMovToMem8B,
#endif
    GenOperandMovRegToReg32,
    GenOperandMovRegToReg16,
    GenOperandMovRegToReg8
};


VOID
UpdateEntrypointNativeInfo(
    PCHAR NativeEnd
    );

ULONG
PlaceExceptionData(
    PCHAR Location,
    DWORD cEntryPoints
    );

ULONG
PlaceNativeCode(
    PCHAR CodeLocation
    );

VOID
DetermineOperandAlignment(
    BOOL EbpAligned,
    POPERAND Operand
    );
    
ULONG
DetermineInstructionAlignment(
    PINSTRUCTION Instruction
    );

ULONG
PlaceOperand(
    ULONG OperandNumber,
    POPERAND Operand,
    PINSTRUCTION Instruction,
    PCHAR Location
    );

PCHAR
InterleaveInstructions(
    OUT PCHAR CodeLocation,
    IN PCHAR  Op1Code,
    IN ULONG  Op1Count,
    IN PCHAR  Op2Code,
    IN ULONG  Op2Count
    );


ULONG
LookupRegInCache(
    ULONG Reg
    )
/*++

Routine Description:

    Determines if an x86 register is cached in a RISC register or not, and
    if so, which RISC register contains the x86 register.

Arguments:

    Reg - one of the GP_ constants or NO_REG.

Return Value:

    Offset into RegCache[] array if the x86 register is cached in a RISC
    register, or NO_REG if the x86 register is not cached.
    
--*/
{
    int RegCacheNum;

    //
    // Map the register number into one of the 32-bit x86 regs.
    //   ie. REG_AH, REG_AL, and REG_AX all become REG_EAX.
    //
    if (Reg == NO_REG) {
        return NO_REG;
    } else if (Reg >= GP_AH) {
        Reg -= GP_AH;
    } else if (Reg >= GP_AL) {
        Reg -= GP_AL;
    } else if (Reg >= GP_AX) {
        Reg -= GP_AX;
    } else if (Reg >= REG_ES) {
        return NO_REG;
    }

    //
    // Search the register cache to see if the 32-bit x86 register
    // is loaded into a RISC register already.
    //
    for (RegCacheNum=0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
        if (RegCache[RegCacheNum] == Reg) {
            return RegCacheNum;
        }
    }

    return NO_REG;
}

VOID SetArgContents(
    ULONG OperandNumber,
    ULONG Reg
    )
/*++

Routine Description:

    Updates information about what argument registers are known to
    contain x86 register values.

Arguments:

    OperandNumber - Number of ArgReg to update
                     (0 means no ArgReg caches the x86 register)
    Reg           - New contents of AREG_NP(OperandNumber)
                     (NO_REG means the ArgReg does not cache an x86 register)

Return Value:

    None.
    
--*/
{
    ULONG Reg2;
    ULONG Reg3;
    ULONG Reg4;

    //
    // If an 8- or 16-bit register is known to be in a particular
    // argreg, then older copies of the 32-bit register are invalid.
    // ie.  if a fragment calls SetArgContents(1, GP_AH) and Arg2Contents
    // is GP_AX, then Arg2Contents must be invalidated.
    //
    if (Reg >= GP_AH) {
        //
        // For a hi-8 register, invalidate the 16- and 32-bit versions
        //
        Reg2 = GP_AX + Reg-GP_AH;
        Reg3 = GP_EAX + Reg-GP_AH;
        Reg4 = NO_REG;
    } else if (Reg >= GP_AL) {
        //
        // For a low-8 register, invalidate the 16-bit and 32-bit versions
        //
        Reg2 = GP_AX + Reg-GP_AL;
        Reg3 = GP_EAX + Reg-GP_AL;
        Reg4 = NO_REG;
    } else if (Reg >= GP_AX) {
        //
        // For a 16-bit register, invalidate the lo-8, high-8 and 32-bit versions
        //
        Reg2 = GP_EAX + Reg-GP_AX;
        Reg3 = GP_AH + Reg-GP_AX;
        Reg4 = GP_AL + Reg-GP_AX;
    } else {
        //
        // For a 32-bit register, invalidate the low-8, high-8, and 16-bit versions
        //
        Reg2 = GP_AH + Reg-GP_EAX;
        Reg3 = GP_AL + Reg-GP_EAX;
        Reg4 = GP_AX + Reg-GP_EAX;
    }

    //
    // Assume that all other registers known to hold Reg are invalid, as
    // SetArgContents() is called only after a new value is stored from the
    // argreg into memory.
    //
    if (Arg1Contents == Reg || Arg1Contents == Reg2 || Arg1Contents == Reg3 || Arg1Contents == Reg4) {
        Arg1Contents = NO_REG;
    }
    if (Arg2Contents == Reg || Arg2Contents == Reg2 || Arg2Contents == Reg3 || Arg2Contents == Reg4) {
        Arg2Contents = NO_REG;
    }

    if (OperandNumber == 1) {
        Arg1Contents = Reg;
    } else if (OperandNumber == 2) {
        Arg2Contents = Reg;
    }
}

ULONG
LoadRegCacheForInstruction(
    DWORD RegsToCache,
    PCHAR CodeLocation
    )
/*++

Routine Description:

    Loads x86 regsisters into RISC registers based on information the
    analysis phase placed into RegsToCache and the current contents of
    the register cache.

Arguments:

    RegsToCache - list of x86 registers which will be referenced frequently
                  in subsequent instructions
    CodeLocation - pointer to place to generate code

Return Value:

    Count of DWORDs of code generated to load x86 registers into the cache.
    
--*/
{
    DWORD i;
    int RegCacheNum;
    PCHAR Location = CodeLocation;

    //
    // Iterate over the 8 32-bit x86 general-purpose registers
    //
    for (i=0; i<REGCOUNT; ++i, RegsToCache >>= REGSHIFT) {
        if (RegsToCache & REGMASK) {
            //
            // There is a register to cache.  See if it is already cached.
            //
            for (RegCacheNum = 0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
                if (RegCache[RegCacheNum] == i) {
                    //
                    // Register is already cached.  Nothing to do.
                    //
                    goto NextCachedReg;
                }
            }

            //
            // The register is not already cached, so cache it.
            //
            for (RegCacheNum = 0; RegCacheNum<NUM_CACHE_REGS; ++RegCacheNum) {
                if (RegCache[RegCacheNum] == NO_REG) {
                    //
                    // This slot is empty, so use it.
                    //
                    RegCache[RegCacheNum] = i;
                    //
                    // Generate code to load the register
                    //
                    Location += GenLoadCacheReg(
                                        (PULONG)Location,
                                        NULL,
                                        RegCacheNum
                                        );
                    goto NextCachedReg;
                }
            }

            //
            // There is no free register to cache the value in.
            // Select a cached register and use it.
            //
            LastRegDeleted = (LastRegDeleted+1) % NUM_CACHE_REGS;
            RegCache[LastRegDeleted] = i;
            //
            // Generate code to load the register
            //
            Location += GenLoadCacheReg(
                (PULONG)Location,
                NULL,
                LastRegDeleted
                );
        }
NextCachedReg:;
    }

    return (ULONG) (ULONGLONG)(Location - CodeLocation);  
}

VOID
ResetRegCache(
    VOID
    )
/*++

Routine Description:

    Invalidates the entire register cache by marking RISC registers as free.
    Functionally the same as:
        InvalidateRegCacheForInstruction(0xffffffff)
        LastRegDeleted = 0;

Arguments:

    None.

Return Value:

    None.
    
--*/
{
    int CacheRegNum;

    for (CacheRegNum = 0; CacheRegNum<NUM_CACHE_REGS; CacheRegNum++) {
        RegCache[CacheRegNum] = NO_REG;
    }
    LastRegDeleted = 0;
}


VOID
InvalidateRegCacheForInstruction(
    DWORD RegsSet
    )
/*++

Routine Description:

    Invalidates the register cache by marking RISC registers as free if
    RegsSet indicates the previous instruction modified the x86 register
    in the cache.

Arguments:

    RegsSet - list of x86 registers which have been modified.

Return Value:

    None.
    
--*/
{
    int CacheRegNum;

    //
    // Invalidate cached registers which have been alterd
    //
    for (CacheRegNum = 0; CacheRegNum<NUM_CACHE_REGS; CacheRegNum++) {
        if (RegCache[CacheRegNum] != NO_REG &&
            ((REGMASK << (REGSHIFT*RegCache[CacheRegNum])) & RegsSet)) {
            RegCache[CacheRegNum] = NO_REG;
            LastRegDeleted = CacheRegNum;
        }
    }
}

VOID
CleanupMovInstruction(
    PINSTRUCTION pInstr
    )
/*++

Routine Description:

    Performs some final optimizatins on MOV instructions.  This cannot
    be performed during the x86 analysis phase as it needs to know
    about register caching.

Arguments:

    pInstr - MOV instruction to clean up.

Return Value:

    None.  pInstr modified.
    
--*/
{
    if (pInstr->Operand1.Type == OPND_REGREF) {
        ULONG Reg;

        if (pInstr->Operand2.Type == OPND_REGVALUE &&
            pInstr->Operand2.Reg < GP_AH &&
            (Reg = LookupRegInCache(pInstr->Operand2.Reg)) != NO_REG) {

            //
            // pInstr is a MOV reg1, reg2 (Where reg2 is not a Hi8),
            // and reg2 is cached.  Set Operand1 to be an OPND_MOVREGTOREG
            // with Reg=destination register and IndexReg = source register
            // (in the cache).
            //
            pInstr->Operand2.Type = OPND_NONE;
            pInstr->Operand1.Type = OPND_MOVREGTOREG;
            pInstr->Operand1.IndexReg = pInstr->Operand1.Reg;
            pInstr->Operand1.Reg = Reg;
            pInstr->Operand1.Immed = pInstr->Operation;

        } else {

            //
            // pInstr is a MOV reg, X.  Rewrite it to be a NOP
            // with Operand1 set to X, Operand2 set to OPND_NONE,
            // and Operand3 set to OPND_MOVTOREG.
            //
            Reg = pInstr->Operand1.Reg;

            pInstr->Operand1 = pInstr->Operand2;
            pInstr->Operand2.Type = OPND_NONE;
            pInstr->Operand3.Type = OPND_MOVTOREG;
            pInstr->Operand3.Reg = Reg;
            pInstr->Operand3.Immed = pInstr->Operation;
        }
    } else {
        pInstr->Operand3.Type = OPND_MOVTOMEM;
        pInstr->Operand3.Immed = pInstr->Operation;

    }
}

ULONG PlaceInstructions(
    PCHAR CodeLocation,
    DWORD cEntryPoints
    )
/*++

Routine Description:

    Generates optimized native code for the entire InstructionStream[] array.

Arguments:

    CodeLocation    -- place to write the native code
    cEntryPoints    -- count of ENTRYPOINT structures describing the x86 code

Return Value:

    Size of native code generated, in bytes.
    
--*/
{
    ULONG NativeSize;
    int i;
    ULONG IntelNext;
    PULONG NextCompilationUnitStart;

    FixupCount = 0;

    //
    // Generate native code
    //
    NativeSize = PlaceNativeCode(CodeLocation);

    //
    // Generate the JumpToNextCompilationUnit code.  It loads
    // RegEip with the intel address of the Intel instruction following
    // this run of code.
    //
    // First, find the last non-Nop instruction in the stream.  These
    // are only present if there is an OPT_ instruction in the stream,
    // so the loop is guaranteed to terminate.
    //

    

    for (i=NumberOfInstructions-1; InstructionStream[i].Size == 0; i--)
        ;
    IntelNext = InstructionStream[i].IntelAddress +
                InstructionStream[i].Size;
    NextCompilationUnitStart = (PULONG)(CodeLocation+NativeSize);


    NativeSize += GenJumpToNextCompilationUnit(NextCompilationUnitStart,
#if _ALPHA_
                                               (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                               (PINSTRUCTION)IntelNext);



#if _ALPHA_
    //
    // Fixups which reference EntrypointECU will be patched by ApplyFixups()
    // to point at the EndCompilationUnit fragment generated here
    //

    EntrypointECU.nativeStart = CodeLocation + NativeSize;
    NativeSize += GenEndCompilationUnit((PULONG)(CodeLocation + NativeSize), 0, NULL);
#endif

    //
    // Update the nativeStart and nativeEnd fields in Entrypoints
    //
    UpdateEntrypointNativeInfo(CodeLocation + NativeSize);

    //
    // Use fixup information to finish generation
    //
    ApplyFixups(NextCompilationUnitStart);

    //
    // Optimize the resulting code
    //
    PeepNativeCode(CodeLocation, NativeSize);

    //
    // Generate the information required to regenerate EIP after
    // an exception
    //
    NativeSize += PlaceExceptionData(CodeLocation + NativeSize, cEntryPoints);

    return NativeSize;

}

VOID
UpdateEntrypointNativeInfo(
    PCHAR NativeEnd
    )
/*++

Routine Description:

    After native code is generated, this function sets the nativeStart and
    nativeEnd fields of entrypoints.

Arguments:

    NativeEnd       -- highest native address used for the generated code.

Return Value:

    None.  EntryPoints updated.
    
--*/
{
    PENTRYPOINT EntryPoint = NULL;
    ULONG i;
    BYTE InstrCount;

    InstrCount = 0;
    for (i=0; i<NumberOfInstructions; ++i) {

        //
        // Keep count of the number of x86 instructions within the
        // entrypoint (not counting 0-byte NOPs)
        //
        if (InstructionStream[i].Operation != OP_Nop ||
            InstructionStream[i].Size != 0) {
            InstrCount++;
        }

        if (EntryPoint != InstructionStream[i].EntryPoint) {
            if (EntryPoint) {
                EntryPoint->nativeEnd = InstructionStream[i].NativeStart-1;
            }
            InstrCount = 1;
            EntryPoint = InstructionStream[i].EntryPoint;
            EntryPoint->nativeStart = InstructionStream[i].NativeStart;
        }
    }
    EntryPoint->nativeEnd = NativeEnd;
}

ULONG
PlaceExceptionData(
    PCHAR Location,
    DWORD cEntryPoints
    )
/*++

Routine Description:

    Places the data required to regenerate EIP after an exception occurs.

Arguments:

    Locatoion       -- address to store the exception data to
    cEntryPoints    -- count of EntryPoints describing the x86 code generated

Return Value:

    Size of exception data, in bytes.
    
--*/
{
    DWORD i;
    PENTRYPOINT EP;
    PULONG pData;
    PINSTRUCTION pInstr;

    //
    // The format of the Exception data is a series of ULONGs:
    //   EXCEPTIONDATA_SIGNATURE (an illegal RISC instruction)
    //   cEntryPoints            (count of ENTRYPOINTs in InstructionStream[])
    //   for each ENTRYPOINT in the InstructionStream {
    //      ptr to ENTRYPOINT
    //      for each x86 instruction with non-zero x86 size {
    //          MAKELONG(offset of start of x86 instr from EP->IntelAddress,
    //                   offset of first RISC instr in the x86 instr from
    //                    EP->nativeStart)
    //      }
    //  }
    //
    // The last RISC offset in each EntryPoint has the low bit set to
    // mark it as the last offset.
    //
    //
    pData = (PULONG)Location;
    *pData = EXCEPTIONDATA_SIGNATURE;
    pData++;

    *pData = cEntryPoints;
    pData++;

    EP = NULL;
    pInstr = &InstructionStream[0];
    for (i=0; i<NumberOfInstructions; ++i, pInstr++) {
        if (EP != pInstr->EntryPoint) {
            if (EP) {
                //
                // flag the previous offset NativeStart as the last one for
                // that EntryPoint.
                //
                *(pData-1) |= 1;
            }
            EP = pInstr->EntryPoint;
            *pData = (ULONG)(ULONGLONG)EP;   
            pData++;
        }

        if (pInstr->Operation != OP_Nop || pInstr->Size != 0) {
            *pData = MAKELONG(
                (USHORT)(pInstr->NativeStart - (PCHAR)EP->nativeStart),
                (USHORT)(pInstr->IntelAddress - (ULONG)(ULONGLONG)EP->intelStart));  
            pData++;
        }
    }

    *(pData-1) |= 1;        // Flag the pair of offsets as the last.
    return (ULONG)(LONGLONG) ( (PCHAR)pData - Location);  
}

VOID
GetEipFromException(
    PCPUCONTEXT cpu,
    PEXCEPTION_POINTERS pExceptionPointers
    )
/*++

Routine Description:

    This routine derives the value of EIP from a RISC exception record.

    1. Walk the stack until the instruction pointer points into the
       Translation Cache.
    2. Walk forward through the Translation Cache until the
       EXCEPTIONDATA_SIGNATURE signature is found.
    3. Find the ENTRYPOINT which describes the faulting instruction.
    4. Find the correct x86 instruction by examining the pairs of
       RISC offsets of the starts of x86 instructions.

Arguments:

    cpu                -- current cpu state
    pExceptionPointers -- state of the thread when the exception occurred
                            
Return Value:

    None.  cpu->Eip now points at faulting x86 instruction.
    
--*/
{
    ULONG NextPc;
    PENTRYPOINT EP;
    PULONG Location;
    ULONG i;
    ULONG cEntryPoints;
    ULONG RiscStart;
    ULONG RiscEnd;

    //
    // 1. Walk the stack until the instruction pointer points into the
    //    Translation Cache
    //
    NextPc = FindPcInTranslationCache(pExceptionPointers);
    if (!NextPc) {
        //
        // The Translation Cache is not on the stack.  Nothing we can do.
        //
        CPUASSERTMSG(FALSE, "FindPcInTranslationCache failed");
        cpu->eipReg.i4 = 0x81234567;
        return;
    }

    //
    // 2. Walk forwards through the Translation Cache until the
    //    EXCEPTIONDATA_SIGNATURE signature is found
    //
    CPUASSERTMSG((NextPc & 3) == 0, "NextPc is not DWORD-aligned");
    Location = (PULONG)NextPc;
    while (*Location != EXCEPTIONDATA_SIGNATURE) {
        Location++;
        if (!AddressInTranslationCache((ULONG) (ULONGLONG) Location)) {  
            cpu->eipReg.i4 = 0x80012345;
            CPUASSERTMSG(FALSE, "EXCEPTIONDATA_SIGNATURE not found");
            return;
        }
    }

    //
    // 3. Find the ENTRYPOINT which describes the address within
    //    the Cache.
    //
    Location++;     // skip over EXCEPTIONDATA_SIGNATURE
    cEntryPoints = *Location;
    Location++;     // skip over cEntryPoints
    for (i=0; i<cEntryPoints; ++i) {
        EP = (PENTRYPOINT)*Location;
         
        if ((ULONG)(ULONGLONG)EP->nativeStart <= NextPc && (ULONG)(ULONGLONG)EP->nativeEnd > NextPc) {
            //
            // This EntryPoint describes the Pc value in the cache
            //
            break;
        }

        //
        // Skip over the pairs of x86 instruction starts and RISC
        // instruction starts.
        //
        do {
            Location++;
        } while ((*Location & 1) == 0);
        Location++;
    }
    if (i == cEntryPoints) {
        CPUASSERTMSG(FALSE, "Entrypoint not found in EXCEPTIONDATA");
        cpu->eipReg.i4 = 0x80001234;
        return;
    }

    //
    // 4. Find the correct x86 instruction by examining the pairs of
    //    RISC offsets of the starts of x86 instructions.
    //
     
    NextPc -= (ULONG)(ULONGLONG)EP->nativeStart;   // Make relative to nativeStart of EP
    RiscStart = 0;                      // Also relative to nativeStart of EP
    Location++;
    while ((*Location & 1) == 0) {

        RiscEnd = LOWORD(*(Location + 1)) & 0xfffe; // RiscEnd = RiscStart of next instr
        if (RiscStart <= NextPc && NextPc < RiscEnd) {
            cpu->eipReg.i4 = (ULONG)(ULONGLONG)EP->intelStart + HIWORD(*Location);  
            return;
        }
        RiscStart = RiscEnd;
        Location++;
    }
     
    cpu->eipReg.i4 = (ULONG)(ULONGLONG)EP->intelStart + HIWORD(*Location);
}



    
ULONG
PlaceNativeCode(
    PCHAR CodeLocation
    )
/*++

Routine Description:

    Generates native code for the set of x86 instructions described by
    InstructionStream[] and NumberOfInstructions.

Arguments:

    CodeLocation    -- pointer to location to generate native code into.

Return Value:

    Returns the number of bytes in the native code for this compilation unit
    
Notes:

    None.
    
--*/
{
    PENTRYPOINT EntryPoint = NULL;
    PINSTRUCTION pInstr;
    PBYTE Location;
    PBYTE StartLocation;
    ULONG Size;
    ULONG i;
    OPERATION Op;
    CHAR Op1Buffer[MAX_OPERAND_SIZE*sizeof(ULONG)];
    CHAR Op2Buffer[MAX_OPERAND_SIZE*sizeof(ULONG)];
    ULONG Op1Size;
    ULONG Op2Size;
    BOOLEAN fMovInstruction;

    Location = CodeLocation;
    pInstr = &InstructionStream[0];
    for (i=NumberOfInstructions; i > 0; --i, pInstr++) {

        Op = pInstr->Operation;
        pInstr->NativeStart = Location;

        if (EntryPoint != pInstr->EntryPoint) {
            //
            // This instruction begins an EntryPoint
            //
            EntryPoint = pInstr->EntryPoint;
            StartLocation = Location;

            //
            // Reset per-basic-block state
            //
            ResetRegCache();
            Arg1Contents = Arg2Contents = NO_REG;
            Location += GenStartBasicBlock((PULONG)Location,
 
#if _ALPHA_
                                           (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                           pInstr);
        }

        if (pInstr->RegsToCache) {
            //
            // Load up frequently-used x86 registers into RISC registers
            //
            Location += LoadRegCacheForInstruction(pInstr->RegsToCache,
                                                   Location);
        }

        if ((Op==OP_Mov32) || (Op==OP_Mov16) || (Op==OP_Mov8)) {
            //
            // Make some final x86 code optimzations based on the
            // register caching info.
            //
            CleanupMovInstruction(pInstr);
            fMovInstruction = TRUE;
        } else {
            fMovInstruction = FALSE;
        }

        //
        // Generate code for the operands
        //
        Op1Size = PlaceOperand(1, &pInstr->Operand1, pInstr, Op1Buffer);
        Op2Size = PlaceOperand(2, &pInstr->Operand2, pInstr, Op2Buffer);
#if _PPC_
        if (pInstr->Operand1.Type == OPND_ADDRVALUE32 &&
            pInstr->Operand1.Alignment != ALIGN_DWORD_ALIGNED &&
            pInstr->Operand2.Type == OPND_ADDRVALUE32 &&
            pInstr->Operand2.Alignment != ALIGN_DWORD_ALIGNED) {
            //
            // Two MakeValue32 operands cannot be interleaved on PPC due
            // to the fact that they share registers RegUt1, RegUt2, RegUt3
            //
            memcpy(Location, Op1Buffer, Op1Size);
            Location += Op1Size;
            memcpy(Location, Op2Buffer, Op2Size);
            Location += Op2Size;
        } else {
            Location = InterleaveInstructions(Location,
                                              Op1Buffer,
                                              Op1Size,
                                              Op2Buffer,
                                              Op2Size);
        }
#elif _ALPHA_
        memcpy(Location, Op1Buffer, Op1Size);
        Location += Op1Size;
        memcpy(Location, Op2Buffer, Op2Size);
        Location += Op2Size;
#else
        Location = InterleaveInstructions(Location,
                                          Op1Buffer,
                                          Op1Size,
                                          Op2Buffer,
                                          Op2Size);
#endif
        Location += PlaceOperand(3, &pInstr->Operand3, pInstr, Location);

        if (DetermineInstructionAlignment(pInstr)) {
            //
            // The instruction has an aligned version and the operands
            // are sufficiently aligned to use it.
            //
            Op++;
            pInstr->Operation = Op;
        }

        //
        // Generate the body of the instruction
        //
        if (CompilerFlags & COMPFL_FAST) {
 
            Location += (*PlaceFn[Fragments[Op].FastPlaceFn])((PULONG)Location,
#if _ALPHA_
                                                              (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                                              pInstr);
        } else {
 
            Location += (*PlaceFn[Fragments[Op].SlowPlaceFn])((PULONG)Location,
#if _ALPHA_
                                                              (ULONG)(ULONGLONG)&EntrypointECU,
#endif
                                                              pInstr);
        }

        if (pInstr->RegsSet) {
            //
            // Mark RISC registers in the cache as invalid if this instruction
            // modified the matching x86 register.
            //
            InvalidateRegCacheForInstruction(pInstr->RegsSet);
        }

        if (!fMovInstruction) {
            //
            // If the instruction isn't a MOV, then assume the arg regs
            // were modified by the fragment
            //
            Arg1Contents = Arg2Contents = NO_REG;
        }

    }

    return (ULONG)(ULONGLONG)(Location - CodeLocation);  
}
    

VOID
DetermineOperandAlignment(
    BOOL EbpAligned,
    POPERAND Operand
    )
/*++

Routine Description:

    This function determines the alignment of an operand.  It also sets the 
    alignment field in the specified operand.  The alignment returned indicates
    the best we can determine at compile time.  An operand that is specified
    as byte aligned may actually turn out to be dword aligned.

Arguments:

    Operand -- Supplies the operand
    
Return Value:

    Returns the value specifying the alignment
    
Notes:
    
    It would be really handy here to have an idea what the register 
    contents were.  It would allow us to try to be more optimistic
    about the alignment.
    
    This routine should be expanded for all of the alignment cases
    assuming its possible.
    
--*/
{
    USHORT LowBits;

    switch (Operand->Type) {
    
        //
        // All of the following are regarded as dword aligned, including
        // high register refrence.  The code for handing high half registers
        // takes care of alignment
        //
        case OPND_MOVREGTOREG :
#if _ALPHA_
            if (Operand->IndexReg >= GP_AH) {
                // The Hi8 registers are considered to be only BYTE-aligned
                // on Alpha.  This matters for 'mov bh, val' instructions.
                // We need to select the MovFrag8B fragment in this case.
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
            } else {
                Operand->Alignment = ALIGN_DWORD_ALIGNED;
            }
            break;
#endif
            // fall into the other cases on MIPS and PPC.

        case OPND_REGREF :
        case OPND_MOVTOREG :
#if _ALPHA_
            if (Operand->Reg >= GP_AH) {
                // The Hi8 registers are considered to be only BYTE-aligned
                // on Alpha.  This matters for 'mov bh, val' instructions.
                // We need to select the MovFrag8B fragment in this case.
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
                break;
            }
#endif
            // fall into the other cases on MIPS and PPC

        case OPND_NONE :
        case OPND_NOCODEGEN :
        case OPND_REGVALUE :
        case OPND_IMM:
                    
            Operand->Alignment = ALIGN_DWORD_ALIGNED;
            break;
            
        //
        // All of the following have alignment depending on the formation
        // of the operand
        //
        case OPND_ADDRREF :
        case OPND_ADDRVALUE32 : 
        case OPND_ADDRVALUE16 :
        case OPND_ADDRVALUE8 : 
        
            if ((Operand->Reg != NO_REG) && (Operand->Reg != GP_ESP) && (Operand->Reg != GP_EBP || !EbpAligned)) {
            
                //
                // We have a reg + ... form.  Since we have no idea what the
                // contents of the register are, we can't guess about the
                // alignment.
                //
                Operand->Alignment = ALIGN_BYTE_ALIGNED;
                
            } else {
            
                //
                // Figure out low two bits
                //
                LowBits = (USHORT)(Operand->Immed & 0x3);
                
                if ((Operand->IndexReg != NO_REG) && (Operand->IndexReg != GP_ESP) && (Operand->IndexReg != GP_EBP || !EbpAligned)) {
                    LowBits = (LowBits | (1 << Operand->Scale)) & 0x3;
                }
                
                //
                // Convert lowbits into alignment
                //
                if (!LowBits) {
                    Operand->Alignment = ALIGN_DWORD_ALIGNED;
                } else if (!(LowBits & 0x1)){
                    Operand->Alignment = ALIGN_WORD_ALIGNED;
                } else {
                    Operand->Alignment = ALIGN_BYTE_ALIGNED;
                }
            }
            break;

        case OPND_MOVTOMEM:
            //
            // No alignment issue with this operand.
            //
            break;
                
        default : 
                
            CPUASSERTMSG(FALSE, "Bad Operand type");
    }
}
    
ULONG
DetermineInstructionAlignment(
    PINSTRUCTION Instruction
    )
/*++

Routine Description:

    This routine determines if the aligned form of an instruction can
    be used.

Arguments:

    Instruction - Supplies a pointer to the instruction
    
Return Value:

    Returns the alignment condition of the instruction
    
Notes:

    The results of this are pretty much ignored for inline mov's.  They are
    currently the only instructions that care about the details of the 
    alignment.  For the rest, naturally aligned or un-aligned is sufficient.
    
--*/
{
    OPERATION Op = Instruction->Operation;

    //
    // If the instruction does not have an aligned version, then
    // there is no work to do.
    //
    if (!(Fragments[Op].Flags & OPFL_ALIGN)) {
        return FALSE;
    }
    
    if (Instruction->Operand1.Type != OPND_ADDRREF) {
        ;
    } else if (Instruction->Operand1.Alignment == ALIGN_DWORD_ALIGNED) {
        ;
    } else if ((Instruction->Operand1.Alignment == ALIGN_WORD_ALIGNED) &&
        (Fragments[Op].Flags & OPFL_ADDR16) 
    ) {
        ;
    } else {
        return FALSE;
    }
    
    if (Instruction->Operand2.Type != OPND_ADDRREF) {
        ;
    } else if (Instruction->Operand2.Alignment == ALIGN_DWORD_ALIGNED) {
        ;
    } else if ((Instruction->Operand2.Alignment == ALIGN_WORD_ALIGNED) &&
        (Fragments[Op].Flags & OPFL_ADDR16) 
    ) {
        ;
    } else {
        return FALSE;
    }

    return TRUE;
}


ULONG
PlaceOperand(
    ULONG OperandNumber,
    POPERAND Operand,
    PINSTRUCTION Instruction,
    PCHAR Location
    )    
/*++

Routine Description:

    This routine generates the fragments necessary to form and operand.

Arguments:

    OperandNumber - number of operand (selects arg register number to target)
    Operand - Supplies the operand
    Instruction - The instruction containing the operand
    Location - Location to generate code into

Return Value:

    The size in bytes of the fragments selected.
    
--*/
{

    OPERAND_OP Op;
    ULONG RegCacheNum;
    PCHAR StartLocation;

#define GEN_OPERAND(Op)     (OpFragments[Op])((PULONG)Location, Operand, OperandNumber)
    
    //
    // Early return for no operands
    //
    if (Operand->Type == OPND_NONE || Operand->Type == OPND_NOCODEGEN) {
        return 0;
    }

    StartLocation = Location;

    DetermineOperandAlignment(Instruction->EbpAligned, Operand);
    
    switch (Operand->Type) {
    
        case OPND_REGVALUE:

            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandRegVal((PULONG)Location,
                                             Operand,
                                             OperandNumber
                                            );
            }
            break;

        case OPND_REGREF:

            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandRegRef((PULONG)Location,
                                             Operand,
                                             OperandNumber
                                            );
            }
            break;
            
        case OPND_ADDRREF:
        case OPND_ADDRVALUE8:
        case OPND_ADDRVALUE16:
        case OPND_ADDRVALUE32:
            Location += GenOperandAddr((PULONG)Location,
                                       Operand,
                                       OperandNumber,
                                       Instruction->FsOverride
                                       );
            break;
        
        case OPND_IMM :
            if ((CompilerFlags & COMPFL_FAST)
                && (Fragments[Instruction->Operation].Flags & OPFL_INLINEARITH)) {
                break;
            } else {
                Location += GenOperandImm((PULONG)Location,
                                          Operand,
                                          OperandNumber);
            }
            break;

        case OPND_MOVTOREG:
            Location += GenOperandMovToReg((PULONG)Location,
                                           Operand,
                                           OperandNumber);

            break;

        case OPND_MOVREGTOREG:
            switch (Operand->Immed) {
            case OP_Mov32:
                Op = OP_MovRegToReg32;
                break;
            case OP_Mov16:
                Op = OP_MovRegToReg16;
                break;
            case OP_Mov8:
#if _ALPHA_
                if (Operand->Alignment == ALIGN_BYTE_ALIGNED) {
                    Op = OP_MovRegToReg8B;
                    break;
                }
#endif
                Op = OP_MovRegToReg8;
                break;
            default:
                CPUASSERT(FALSE);
            }
            Location += GEN_OPERAND(Op);
            break;

        case OPND_MOVTOMEM:
            switch (Operand->Immed) {
            case OP_Mov32:
                Op = OP_MovToMem32B + Instruction->Operand1.Alignment;
                break;
            case OP_Mov16:
                Op = OP_MovToMem16B + Instruction->Operand1.Alignment;
                break;
            case OP_Mov8:
                Op = OP_MovToMem8D;
#if _ALPHA_
                if (Instruction->Operand1.Alignment != ALIGN_DWORD_ALIGNED) {
                    Op = OP_MovToMem8B;
                }
#endif
                break;

            default:
                CPUASSERT(FALSE);       // unknown MOV opcode
            }
            //
            // Generate the correct code based on the alignment of the operand
            //
            Location += GEN_OPERAND(Op);
            break;
            
        default:
        
            //
            // This is an internal error
            //
            CPUASSERT(FALSE);  // Unknown operand type!!!!
    }
    
    return (ULONG)(ULONGLONG)(Location - StartLocation);  
}

PCHAR
InterleaveInstructions(
    OUT PCHAR CodeLocation,
    IN PCHAR  Op1Code,
    IN ULONG  Op1Count,
    IN PCHAR  Op2Code,
    IN ULONG  Op2Count
)
/*++

Routine Description:

    This routine interleaves two streams of native code into one stream
    to try and avoid pipeline stalls.  It assumes that the two streams
    have no interdependencies (like they can't use the same register).

Arguments:

    CodeLocation -- Supplies the location to place the code at
    Op1Code      -- Code for the first operand
    Op1Count     -- Count of BYTES in the first operand
    Op2Code      -- Code for the second operand
    Op2Count     -- Count of BYTES in the second operand

Return Value:

    New value for CodeLocation - just past the end of the operands.

Notes:

    None

--*/
{
    PULONG pCode = (PULONG)CodeLocation;
    PULONG LongCode;
    PULONG ShortCode;
    ULONG LongCount;
    ULONG ShortCount;
    ULONG LongTail;

    //
    // Figure out which operand has more instructions - it starts first
    //
    if (Op1Count > Op2Count) {
        LongCode = (PULONG)Op1Code;
        LongCount = Op1Count / sizeof(ULONG);
        ShortCode = (PULONG)Op2Code;
        ShortCount = Op2Count / sizeof(ULONG);
    } else {
        LongCode = (PULONG)Op2Code;
        LongCount = Op2Count / sizeof(ULONG);
        ShortCode = (PULONG)Op1Code;
        ShortCount = Op1Count / sizeof(ULONG);
    }

    // get the length of the part of the longer operand which
    // goes after the interleaved part (in BYTES)
    LongTail = (LongCount - ShortCount) * sizeof(ULONG);

    //
    // Interleave instructions from both operands
    //
    while (ShortCount) {
        *pCode++ = *LongCode++;
        *pCode++ = *ShortCode++;
        ShortCount--;
    }

    //
    // Copy in the remaining instructions from the longer operand
    //
    if (LongTail) {
        memcpy(pCode, LongCode, LongTail);
    }

    return CodeLocation + Op1Count + Op2Count;
}


USHORT
ChecksumMemory(
    ENTRYPOINT *pEP
    )
/*++

Routine Description:

    Perform a simple checksum on the range of Intel addresses specified
    in an Entrypoint.

Arguments:

    pEp -- entrypoint describing Intel memory to checksum

Return Value:

    Checksum for the memory

Notes:

    None

--*/
{
    USHORT Checksum = 0;
    PBYTE pb = (PBYTE)pEP->intelStart;

    while (pb != (PBYTE)pEP->intelEnd) {
        Checksum = ((Checksum << 1) | ((Checksum >> 15) & 1)) + (USHORT)*pb;
        pb++;
    };

    return Checksum;
}


DWORD
SniffMemory(
    ENTRYPOINT *pEP,
    USHORT Checksum
    )
/*++

Routine Description:

    Called from the StartBasicBlock code for regions of memory which
    must be sniffed to determine if the x86 app has modified its code or not.

Arguments:

    pEp         -- entrypoint describing Intel memory to checksum
    Checksum    -- checksum of the code at compile-time

Return Value:

    TRUE    - code has not changed...native translation OK
    FALSE   - code has been modified.  CpuNotify has been set to flush
              the cache on the next CpuSimulateLoop.  Caller must jump
              to EndTranslatedCode immediately!

Notes:

    None

--*/
{
    USHORT NewChecksum = ChecksumMemory(pEP);

    if (NewChecksum != Checksum) {
        DECLARE_CPU;

        //
        // Intel code has been modified!!!!!  We must flush the cache and
        // recompile!!!!
        //
#if DBG
        LOGPRINT((TRACELOG, "WX86CPU: Intel code at %x modified!\n", pEP->intelStart));
#endif
        #undef CpuNotify   // soalpha.h defines this to be offset of CpuNotify
        InterlockedOr(&cpu->CpuNotify, CPUNOTIFY_MODECHANGE);
        cpu->eipReg.i4 = (ULONG)(ULONGLONG)pEP->intelStart;  
        return FALSE;
    }

    //
    // Intel code has not been modified.  Continue simulation without
    // recompilation
    //
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\atomic.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    atomic.h

Abstract:

    This is the include file for atomic.s - atomic operations on memory, used
    for synchronization.

Author:

    Barry Bond (barrybo) creation-date 03-Aug-1995

Revision History:


--*/

#ifndef _ATOMIC_H_
#define _ATOMIC_H_

DWORD
MrswFetchAndIncrementWriter(
    DWORD *pCounters
    );

DWORD
MrswFetchAndIncrementReader(
    DWORD *pCounters
    );

DWORD
MrswFetchAndDecrementWriter(
    DWORD *pCounters
    );

DWORD
MrswFetchAndDecrementReader(
    DWORD *pCounters
    );

DWORD
InterlockedAnd(
    DWORD *pDWORD,
    DWORD AndValue
    );

DWORD
InterlockedOr(
    DWORD *pDWORD,
    DWORD OrValue
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\analysis.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    analysis.h

Abstract:

    This module contains interfaces and structures exported by the analysis
    module.

Author:

    Dave Hastings (daveh) creation-date 26-Jun-1995

Revision History:


--*/

#ifndef _ANALYSIS_H_
#define _ANALYSIS_H_

ULONG
GetInstructionStream(
    PINSTRUCTION InstructionStream,
    PULONG NumberOfInstructions,
    PVOID pIntelInstruction,
    PVOID pLastIntelInstruction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\compiler.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    compiler.h

Abstract:

    This include file defines the exports from compiler.lib.

Author:

    Dave Hastings (daveh) creation-date 10-Jul-1995

Revision History:


--*/

#ifndef _COMPILER_H_
#define _COMPILER_H_

#include <threadst.h>

//
// Bit-flags which affect the way the compiler generates code.
//
#define COMPFL_FAST     1   // fastmode - implicit Eip, infrequent CpuNotify
                            //            checks, few ENTRYPOINTs
#define COMPFL_SLOW     2   // slowmode - build ENTRYPOINT for each instruction

extern DWORD CompilerFlags;         // controls how the compiler generates code

extern INSTRUCTION InstructionStream[MAX_INSTR_COUNT];
extern ULONG NumberOfInstructions;


PENTRYPOINT
NativeAddressFromEip(
    PVOID IntelEip,
    BOOL  LockTCForWrite
    );
    
PVOID
NativeAddressFromEipNoCompile(
    PVOID IntelEip
    );
    
PENTRYPOINT
NativeAddressFromEipNoCompileEPWrite(
    PVOID IntelEip
    );

VOID
GetEipFromException(
    PCPUCONTEXT cpu,
    PEXCEPTION_POINTERS pExceptionPointers
    );


//
// This API is defined inside the fragment library, but is only used by the
// compiling cpu (MSCPU). 
//
VOID
StartTranslatedCode(
    PTHREADSTATE ThreadState,
    PVOID NativeCode    
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\config.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This file defines the names of all configuration variables within
    the CPU.

Author:

    Barry Bond (barrybo)  creation-date 12-Jun-1996

Revision History:


--*/

#ifndef _CONFIG_H_
#define _CONFIG_H_

//
// Global definitions
//
#ifndef _ALPHA_
#define MAX_PROLOG_SIZE     0x1000  // max size of StartTranslatedCode prolog
#else
#define MAX_PROLOG_SIZE     0x2000  // max size of StartTranslatedCode prolog
#endif

#define MAX_INSTR_COUNT 200         // max number of instructions to compile

/*
 * The amount of memory to reserve (in bytes) for the dynamically-
 * allocated CPU Translation Cache.  This reserve is added to the
 * 2MB statically-allocated cache.
 *
 * Minimum size is 1 page of memory (4096 on MIPS and PPC, 8192 on Alpha).
 * Default value is 2MB. (DYN_CACHE_SIZE)
 * Maximum size is all available memory.
 *
 */
#define STR_CACHE_RESERVE  L"CpuCacheReserve"
extern DWORD CpuCacheReserve;

/*
 * The amount of memory to commit (in bytes) for the dynamically-
 * allocated CPU Translation Cache.  The 2MB statically-allocated
 * cache is fully committed at startup.
 *
 * Minimum size is 1 page of memory (4096 on MIPS and PPC, 8192 on Alpha).
 * Default value is 1 page. (MAX_PROLOG_SIZE)
 * Maximum size is size of reserve.
 *
 */
#define STR_CACHE_COMMIT   L"CpuCacheCommit"
extern DWORD CpuCacheCommit;

/*
 * If consecutive cache commits occur within the specified time, the amount
 * committed each time doubles. (in ms)
 *
 * Minimum value is 0
 * Default value is 200
 * Maximum value is -1
 *
 */
#define STR_CACHE_GROW_TICKS L"CpuCacheGrowTicks"
extern DWORD CpuCacheGrowTicks;

/*
 * If consecutive cache commits occur past the specified time, the amount
 * committed each time is cut in half. (in ms)
 *
 * Minimum value is 0
 * Default value is 1000
 * Maximum value is -1
 *
 */
#define STR_CACHE_SHRINK_TICKS L"CpuCacheShrinkTicks"
extern DWORD CpuCacheShrinkTicks;

/*
 * Minimum amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 32768
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKMIN L"CpuCacheChunkMin"
extern DWORD CpuCacheChunkMin;

/*
 * Maximum amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 512k
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKMAX L"CpuCacheChunkMax"
extern DWORD CpuCacheChunkMax;

/*
 * Initial amount of memory (in bytes) to commit in the Translation Cache.
 * Note that this value will be rounded up to the next power of 2.
 *
 * Minimum value is 1 page
 * Default value is 65536
 * Maximum value is size of cache
 *
 */
#define STR_CACHE_CHUNKSIZE L"CpuCacheChunkSize"
extern DWORD CpuCacheChunkSize;

/*
 * Time to wait for other threads to synchronize (in ms).
 *
 * Minimum time is 0
 * Default time is 3 times the default time used for NT critical sections
 * Maximum time is -1 (infinity)
 *
 */
#define STR_MRSW_TIMEOUT   L"CpuTimeout"
extern LARGE_INTEGER MrswTimeout;

/*
 * Default compilation flags
 *
 * See cpu\inc\compiler.h for COMPFL_ values and meanings
 *
 * Default=COMPFL_FAST
 *
 */
#define STR_COMPILERFLAGS L"CpuCompilerFlags"
extern DWORD CompilerFlags;

/*
 * Flag indicating whether winpxem.dll will be used to emulate
 * floating-point instructions using the Intel Windows NT 486SX
 * emulator instead of the Wx86 implementation.
 *
 * Default=0
 * Non-zero indicates winpxem.dll will be used.
 *
 */
#define STR_USEWINPXEM L"CpuNoFPU"
extern DWORD fUseNPXEM;

/*
 * Number of times to retry memory allocations before failing.
 *
 * Min = 1
 * Default = 4
 * Max = 0xffffffff
 *
 */
#define STR_CPU_MAX_ALLOC_RETRIES L"CpuMaxAllocRetries"
extern DWORD CpuMaxAllocRetries;

/*
 * Time to sleep between memory allocation retries (in ms).
 *
 * Min = 0
 * Default = 200
 * Max = 0xffffffff
 *
 */
#define STR_CPU_WAIT_FOR_MEMORY_TIME L"CpuWaitForMemoryTime"
extern DWORD CpuWaitForMemoryTime;

/*
 * Number of instructions of lookahead in the CPU
 *
 * Min = 1
 * Default = 200 (MAX_INSTR_COUNT)
 * Max = 200 (MAX_INSTR_COUNT)
 *
 */
#define STR_CPU_MAX_INSTRUCTIONS L"CpuInstructionLookahead"
extern DWORD CpuInstructionLookahead;

/*
 * Disable the Dynamic Translation Cache altogether
 *
 * Default = 0 - Dynamic Translation Cache enabled
 * nonzero - use only the static Translation Cache
 *
 */
#define STR_CPU_DISABLE_DYNCACHE L"CpuDisableDynamicCache"
extern DWORD CpuDisableDynamicCache;

/*
 * Size of ENTRYPOINT descriptor reservation, in bytes
 *
 * Default = 0x1000000
 *
 */
#define STR_CPU_ENTRYPOINT_RESERVE L"CpuEntryPointReserve"
extern DWORD CpuEntryPointReserve;

/*
 * Disable caching of x86 registers in RISC registers
 *
 * Default = 0 - x86 registers cached in RISC registers
 * nonzero - x86 registers accessed only from memory
 *
 */
#define STR_CPU_DISABLE_REGCACHE L"CpuDisableRegCache"
extern DWORD CpuDisableRegCache;

/*
 * Disable dead x86 flag removal
 *
 * Default = 0 - dead x86 flags not computed
 * nonzero - x86 flags always computed
 *
 */
#define STR_CPU_DISABLE_NOFLAGS L"CpuDisableNoFlags"
extern DWORD CpuDisableNoFlags;

/*
 * Disable Ebp alignment detection.
 *
 * Default = 0 - If EBP is determined to be a stack frame pointer, assume
 *               it is an aligned pointer.
 * nonzero - Assume EBP is always an unaligned pointer.
 *
 */
#define STR_CPU_DISABLE_EBPALIGN L"CpuDisableEbpAlign"
extern DWORD CpuDisableEbpAlign;

/*
 * Enable sniff-checking on x86 code found in writable memory
 *
 * Default = 0 - No sniff-checking performed.
 * nonzero - Sniff-check pages with writable attributes.
 *
 */
#define STR_CPU_SNIFF_WRITABLE_CODE L"CpuSniffWritableCode"
extern DWORD CpuSniffWritableCode;

/*
 * Logging verbosity.  Only configurable under the debugger.
 *
 */
extern DWORD ModuleLogFlags;

VOID
GetConfigurationData(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\coded.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coded.h

Abstract:

    This is the include file for the code description dumper, and it's 
    associated utilities.

Author:

    Dave Hastings (daveh) creation-date 20-May-1996

Revision History:


--*/

#define CODEGEN_PROFILE_REV 1

typedef struct _CodeDescriptionHeader {
    ULONG NextCodeDescriptionOffset;
    ULONG CommandLineOffset;
    ULONG ProcessorType;
    ULONG DumpFileRev;
    ULONG StartTime;
} CODEDESCRIPTIONHEADER, *PCODEDESCRIPTIONHEADER;

typedef struct _CodeDescription {
    ULONG NextCodeDescriptionOffset;
    ULONG TypeTag;
    ULONG NativeCodeOffset;
    ULONG NativeCodeSize;
    ULONG IntelCodeOffset;
    ULONG IntelCodeSize;
    ULONG NativeAddress;
    ULONG IntelAddress;    
    ULONG SequenceNumber;
    ULONG ExecutionCount;
    ULONG CreationTime;
} CODEDESCRIPTION, *PCODEDESCRIPTION;

#define PROFILE_CODEDESCRIPTIONS            0x00000001

#define PROFILE_CD_CREATE_DESCRIPTIONFILE   0x00000001
#define PROFILE_CD_CLOSE_DESCRIPTIONFILE    0x00000002

#define PROFILE_TAG_CODEDESCRIPTION         0x0
#define PROFILE_TAG_EOF                     0xFFFFFFFF
#define PROFILE_TAG_TCFLUSH                 0xFFFFFFFE
#define PROFILE_TAG_TCALLOCFAIL             0xFFFFFFFD
extern ULONG ProfileFlags;
extern ULONG CodeDescriptionFlags;

VOID
InitCodegenProfile(
    VOID
    );
    
VOID
TerminateCodegenProfile(
    VOID
    );

VOID 
DumpCodeDescriptions(
    BOOL TCFlush
    );

VOID
DumpAllocFailure(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\cpuassrt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cpuassrt.h

Abstract:

    This include file defines the assertion mechanism for the compiling
    CPU.

Author:

    Barry Bond (barrybo) creation-date 07-Aug-1995

Revision History:


--*/

#ifndef _CPUASSRT_H_
#define _CPUASSRT_H_

// This function is defined in fraglib\fraginit.c
VOID
CpuStartDebugger(
    VOID
    );


#if DBG

#undef ASSERTNAME
#define ASSERTNAME     static char szModule[] = __FILE__;

// This function is defined in fraglib\fraginit.c
VOID
DoAssert(
    PSZ exp,
    PSZ msg,
    PSZ mod,
    INT line
    );

#define CPUASSERT(exp)                                      \
{                                                           \
    if (!(exp)) {                                           \
        DoAssert( #exp , NULL, szModule, __LINE__);         \
    }                                                       \
}

#define CPUASSERTMSG(exp,msg)                               \
{                                                           \
    if (!(exp)) {                                           \
        DoAssert( #exp , (msg), szModule, __LINE__);        \
    }                                                       \
}

#else   //!DBG

#define ASSERTNAME
#define CPUASSERT(exp)
#define CPUASSERTMSG(exp,msg)

#endif  //!DBG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\cpunotif.h ===
/*++ 

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cpunotif.h

Abstract:
    
    definitions for CPUNOTIFY constants

Author:

    21-July-1995 t-orig (Ori Gershony), created

Revision History:

--*/


//
// defines for Wx86Tib.CpuNotify
//
#define CPUNOTIFY_TRACEFLAG  0x00000001   // Trace Flag value
#define CPUNOTIFY_TRACEADDR  0x00000002   // Trace Address is set
#define CPUNOTIFY_INSTBREAK  0x00000004   // Debug Reg Instruction breakpoints
#define CPUNOTIFY_DATABREAK  0x00000008   // Debug Reg Data breakpoints
#define CPUNOTIFY_SLOWMODE   0x00000010   // Cpu runs in slow mode
#define CPUNOTIFY_INTERRUPT  0x00000020   // async request for cpu
#define CPUNOTIFY_UNSIMULATE 0x00000040   // cpu has reached a Bop fe
#define CPUNOTIFY_CPUTRAP    0x00000080   // catch all for cpu internal usage
#define CPUNOTIFY_EXITTC     0x00000100   // TC is about to be flushed
#define CPUNOTIFY_DBGFLUSHTC 0x00000200   // debugger modified memory - flush TC
#define CPUNOTIFY_SUSPEND    0x00000400   // SuspendThread() called on this thread
#define CPUNOTIFY_INTX       0x00000800   // INTx instruction hit
#define CPUNOTIFY_MODECHANGE 0x00001000   // Compiler switched between fast and slow - flush TC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\cpuregs.h ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpuregs.h

Abstract:
    
    Handy defines from x86 reg names to cpu register fields
    
Author:

Revision History:

--*/

#define eax     cpu->GpRegs[GP_EAX].i4
#define ebx     cpu->GpRegs[GP_EBX].i4
#define ecx     cpu->GpRegs[GP_ECX].i4
#define edx     cpu->GpRegs[GP_EDX].i4
#define esp     cpu->GpRegs[GP_ESP].i4
#define ebp     cpu->GpRegs[GP_EBP].i4
#define esi     cpu->GpRegs[GP_ESI].i4
#define edi     cpu->GpRegs[GP_EDI].i4
#define eip     cpu->eipReg.i4
#define eipTemp cpu->eipTempReg.i4

#define ax      cpu->GpRegs[GP_EAX].i2
#define bx      cpu->GpRegs[GP_EBX].i2
#define cx      cpu->GpRegs[GP_ECX].i2
#define dx      cpu->GpRegs[GP_EDX].i2
#define sp      cpu->GpRegs[GP_ESP].i2
#define bp      cpu->GpRegs[GP_EBP].i2
#define si      cpu->GpRegs[GP_ESI].i2
#define di      cpu->GpRegs[GP_EDI].i2

#define al      cpu->GpRegs[GP_EAX].i1
#define bl      cpu->GpRegs[GP_EBX].i1
#define cl      cpu->GpRegs[GP_ECX].i1
#define dl      cpu->GpRegs[GP_EDX].i1

#define ah      cpu->GpRegs[GP_EAX].hb
#define bh      cpu->GpRegs[GP_EBX].hb
#define ch      cpu->GpRegs[GP_ECX].hb
#define dh      cpu->GpRegs[GP_EDX].hb

#define CS      cpu->GpRegs[REG_CS].i2
#define DS      cpu->GpRegs[REG_DS].i2
#define ES      cpu->GpRegs[REG_ES].i2
#define SS      cpu->GpRegs[REG_SS].i2
#define FS      cpu->GpRegs[REG_FS].i2
#define GS      cpu->GpRegs[REG_GS].i2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\cpumain.h ===
/*++
                                                                                
Copyright (c) 1995 Microsoft Corporation

Module Name:

    cpumain.h

Abstract:
    
    Prototypes from cpumain.c
    
Author:

    01-Aug-1995 Ori Gershony (t-orig)

Revision History:

    29-Jan-2000  SamerA  Added CpupDoInterrupt and CpupRaiseException
--*/

#ifndef CPUMAIN_H
#define CPUMAIN_H

//
// Indicator that threads must check CpuNotify.  0 if threads don't need
// to check, nonzero if they do.
//
extern DWORD ProcessCpuNotify;

//
// Simulates an x86 software interrupt
//
NTSTATUS
CpupDoInterrupt(
    IN DWORD InterruptNumber);

//
// Raises a software exception
//
NTSTATUS
CpupRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord);

//
// Raises an exception from the cpu
//
VOID
CpuRaiseStatus(
    NTSTATUS Status
    );

//
// The following two variables are used to synchronize intel instructions
// with the LOCK prefix.  The critical section is a lot faster, but it does
// not guarantee synchronization in shared memory.  Eventually we should use
// the critical section by default, and the mutex for certain applications which
// need it (maybe get a list from the registry).
//
extern HANDLE           Wx86LockSynchMutexHandle;
extern CRITICAL_SECTION Wx86LockSynchCriticalSection;


//
// The following variable decided which synchronization object is used
//
typedef enum {USECRITICALSECTION, USEMUTEX} SYNCHOBJECTTYPE;
extern SYNCHOBJECTTYPE SynchObjectType;

#endif // CPUMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\entrypt.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    entrypt.h

Abstract:
    
    The interface to the entry point module.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/

#ifndef _ENTRYPT_H_
#define _ENTRYPT_H_

//
// Time to wait, in milliseconds, to sleep before retrying a memory
// allocation which failed due to lack of free pages.
//
#define CPU_WAIT_FOR_MEMORY_TIME    200

//
// Number of times to retry memory allocations
//
#define CPU_MAX_ALLOCATION_RETRIES  4


// Note:  if BOTH is defined, than the code compiled will allow one to
//        retrieve an entry point structure from either an intel or native
//        address.  If both is not defined, than an entry point structure 
//        can only be retrieved from an intel address.   Defining both 
//        increases the cost (time and space) of most operation by a 
//        factor of 2.
//#define BOTH

// Set this to 1 if you suspect there is a heap corruption which is
// trashing the red-black trees.  It creates a second red-black tree
// which mirrors the first, and walks both trees frequently to ensure
// they actually match.  Since the checking mechanism uses NT asserts,
// this only works on a checked NT build using a checked CPU.
#define DBG_DUAL_TREES 0

//
// This timestamp is bumped whenever an entrypoint is added, split, or
// when all entrypoits are flushed.  It an be used to determine if
// the entrypoints need to be re-searched afte switching from an Mrsw
// reader to an Mrsw Writer.
//
extern DWORD EntrypointTimestamp;

// The Entry Point Structure
typedef struct _entryPoint {
    PVOID intelStart;
    PVOID intelEnd;
    PVOID nativeStart;
    PVOID nativeEnd;
    USHORT FlagsNeeded;
    struct _entryPoint *SubEP;
#ifdef CODEGEN_PROFILE
    ULONG SequenceNumber;
    ULONG ExecutionCount;
    ULONG CreationTime;
#endif
} ENTRYPOINT, *PENTRYPOINT;

// The colors
typedef enum {RED, BLACK} COL;

// The EPNODE structure
typedef struct _epNode
{
    ENTRYPOINT ep;

    struct _epNode *intelLeft;
    struct _epNode *intelRight;
    struct _epNode *intelParent;
    COL intelColor;

#ifdef BOTH
    struct _epNode *nativeLeft;
    struct _epNode *nativeRight;
    struct _epNode *nativeParent;
    COL riscColor;
#endif

#if DBG_DUAL_TREES
    struct _epNode *dual;
#endif

} EPNODE, *PEPNODE;


// Prototypes

INT
initializeEntryPointModule(
    void
    );

PENTRYPOINT 
EPFromIntelAddr(
    PVOID intelAddr
    );

PENTRYPOINT
GetNextEPFromIntelAddr(
    PVOID intelAddr
    );

VOID
FlushEntrypoints(
    VOID
    );

#ifdef BOTH
PENTRYPOINT 
EPFromNativeAddr(
    PVOID nativeAddr
    );
#endif

INT
insertEntryPoint(
    PEPNODE pNewEntryPoint
    );

INT 
removeEntryPoint(
    PEPNODE pEP
    );

PVOID
EPAlloc(
    DWORD cb
    );

VOID
EPFree(
    VOID
    );

INT
initEPAlloc(
    VOID
    );

BOOLEAN
IsIntelRangeInCache(
    PVOID Addr,
    DWORD Length
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\decoder.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    decoder.h

Abstract:

    This module defines the interface to the Instruction Decoder.
    

Author:

    Barry Bond (barrybo) creation-date 29-June-1995

Revision History:


--*/

#ifndef _DECODER_H_
#define _DECODER_H_

VOID
DecodeInstruction(
    DWORD           InstructionAddress,
    PINSTRUCTION    Instruction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\eflags.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    eflags.h

Abstract:

    Bit positions for the various flag bits inside EFLAGS

Author:

    Barry Bond (barrybo) creation-date 25-January-2000

Revision History:


--*/

#ifndef _EFLAGS_INCLUDED
#define _EFLAGS_INCLUDED

#define FLAG_CF	    (1<<0)	    // carry
// bit 1 is always 1
#define FLAG_PF	    (1<<2)	    // parity
// bit 3 is always 0
#define FLAG_AUX    (1<<4)	    // aux carry
// bit 5 is always 0
#define FLAG_ZF     (1<<6)	    // zero
#define FLAG_SF     (1<<7)	    // sign
#define FLAG_TF     (1<<8)	    // trap
#define FLAG_IF	    (1<<9)	    // interrupt enable
#define FLAG_DF     (1<<10)	    // direction
#define FLAG_OF     (1<<11)	    // overflow
#define FLAG_IOPL   (3<<12)	    // IOPL = 3
#define FLAG_NT	    (1<<14)	    // nested task
// bit 15 is 0
#define FLAG_RF	    (1<<16)	    // resume flag
#define FLAG_VM	    (1<<17)	    // virtual mode
#define FLAG_AC     (1<<18)     // alignment check
#define FLAG_ID     (1<<21)     // ID bit (CPUID present if this can be toggled)

#endif //_EFLAGS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\fndata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fndata.h

Abstract:

    This module contains definitions of all placement functions for
    fragments.  Before including this file, the DEF_PLACEFN macro must be
    defined.

Author:

    Barry Bond (barrybo) creation-date 12-Sep-1996

Revision History:


--*/


#ifndef DEF_PLACEFN
#error Must define DEF_PLACEFN(FunctionName)
#endif

// Each DEF_PLACEFN defines a new place function

DEF_PLACEFN(GenCallCFrag)
DEF_PLACEFN(GenCallCFragNoCpu)
DEF_PLACEFN(GenCallCFragLoadEip)
DEF_PLACEFN(GenCallCFragLoadEipNoCpu)
DEF_PLACEFN(GenCallCFragSlow)
DEF_PLACEFN(GenCallCFragNoCpuSlow)
DEF_PLACEFN(GenCallCFragLoadEipSlow)
DEF_PLACEFN(GenCallCFragLoadEipNoCpuSlow)
DEF_PLACEFN(PlaceJxx)
DEF_PLACEFN(PlaceJxxSlow)
DEF_PLACEFN(PlaceJxxFwd)
DEF_PLACEFN(PlaceCallDirect)
DEF_PLACEFN(PlaceCallfDirect)
DEF_PLACEFN(GenCallIndirect)
DEF_PLACEFN(GenCallfIndirect)
DEF_PLACEFN(GenCallJmpIndirect)
DEF_PLACEFN(GenCallJmpfIndirect)
DEF_PLACEFN(PlaceJmpDirect)
DEF_PLACEFN(PlaceJmpDirectSlow)
DEF_PLACEFN(PlaceJmpFwdDirect)
DEF_PLACEFN(PlaceJmpfDirect)
DEF_PLACEFN(GenCallRetIndirect)
DEF_PLACEFN(PlaceNop)
DEF_PLACEFN(GenMovsx8To32)
DEF_PLACEFN(GenMovsx8To32Slow)
DEF_PLACEFN(GenMovsx8To16)
DEF_PLACEFN(GenMovsx8To16Slow)
DEF_PLACEFN(GenMovsx16To32)
DEF_PLACEFN(GenMovsx16To32Slow)
DEF_PLACEFN(GenMovzx8To32)
DEF_PLACEFN(GenMovzx8To32Slow)
DEF_PLACEFN(GenMovzx8To16)
DEF_PLACEFN(GenMovzx8To16Slow)
DEF_PLACEFN(GenMovzx16To32)
DEF_PLACEFN(GenMovzx16To32Slow)
DEF_PLACEFN(GenStartBasicBlock)
DEF_PLACEFN(GenJumpToNextCompilationUnit)
DEF_PLACEFN(GenEndMovSlow)
DEF_PLACEFN(GenAddFragNoFlags32)
DEF_PLACEFN(GenAddFragNoFlags32A)
DEF_PLACEFN(GenAndFragNoFlags32)
DEF_PLACEFN(GenAndFragNoFlags32A)
DEF_PLACEFN(GenDecFragNoFlags32)
DEF_PLACEFN(GenDecFragNoFlags32A)
DEF_PLACEFN(GenIncFragNoFlags32)
DEF_PLACEFN(GenIncFragNoFlags32A)
DEF_PLACEFN(GenOrFragNoFlags32)
DEF_PLACEFN(GenOrFragNoFlags32A)
DEF_PLACEFN(GenSubFragNoFlags32)
DEF_PLACEFN(GenSubFragNoFlags32A)
DEF_PLACEFN(GenXorFragNoFlags32)
DEF_PLACEFN(GenXorFragNoFlags32A)

#undef DEF_PLACEFN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\frag.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    frag.h

Abstract:

    This module contains public structures and interfaces for the fragment
    library.

Author:

    Dave Hastings (daveh) creation-date 24-Jun-1995

Revision History:


--*/

#ifndef _FRAG_H_
#define _FRAG_H_

//
// function declaration for the function to patch Operand fragments
// CodeLocation specifies the location of the beginning of the copy
// of the fragment in memory.  Reference indicates if it is a value
// or reference operand.  Argument number refers to which argument it
// is for the c call to the operation fragment (zero based)
//
typedef INT (*PPLACEOPERANDFN)(
    IN PULONG CodeLocation,
    IN POPERAND Operand,
    IN ULONG OperandNumber
    );

//
// function declaration for the function to patch operation fragments
// CodeLocation specifies the location of the beginning of the copy
// of the fragment in memory
//
typedef ULONG (*PPLACEOPERATIONFN)(PULONG CodeLocation,
#if _ALPHA_
                                   ULONG CurrentECU,
#endif
                                   PINSTRUCTION Instruction);

//
// Structure to describe and locate the code for a fragment
//
typedef struct _FragDescr {
    BYTE FastPlaceFn;       // index into PlaceFn[] when in fast mode
    BYTE SlowPlaceFn;       // index into PlaceFn[] when in slow mode
    USHORT Flags;           // OPFL_ flags
    DWORD RegsSet;          // registers set by this instr
    USHORT FlagsNeeded;     // bits from flags register required for this instr
    USHORT FlagsSet;        // bits from flags register modified by this instr
} FRAGDESC;
typedef CONST FRAGDESC *PFRAGDESCR;

//
// Bit definitions for FRAGDESC.Flags field
//
#define OPFL_ALIGN          1
#define OPFL_HASNOFLAGS     2
#define OPFL_STOP_COMPILE   4
#define OPFL_END_NEXT_EP    8
#define OPFL_CTRLTRNS       16
#define OPFL_ADDR16         32
#define OPFL_INLINEARITH    64

// Bit values for FRAGDESC.RegsSet field
#define REGAL         1
#define REGAH         2
#define REGAX         3
#define REGEAX        7
#define REGCL         (1<<3)
#define REGCH         (2<<3)
#define REGCX         (3<<3)
#define REGECX        (7<<3)
#define REGDL         (1<<6)
#define REGDH         (2<<6)
#define REGDX         (3<<6)
#define REGEDX        (7<<6)
#define REGBL         (1<<9)
#define REGBH         (2<<9)
#define REGBX         (3<<9)
#define REGEBX        (7<<9)
#define REGSP         (3<<12)
#define REGESP        (7<<12)
#define REGBP         (3<<15)
#define REGEBP        (7<<15)
#define REGSI         (3<<18)
#define REGESI        (7<<18)
#define REGDI         (3<<21)
#define REGEDI        (7<<21)
#define ALLREGS       (REGEAX|REGEBX|REGECX|REGEDX|REGESP|REGEBP|REGESI|REGEDI)

//
// Constants to help break apart bitfields of REG... constants.  Register
// caching code uses a single DWORD to hold caching information for the 8
// x86 general-purpose registers (REGEAX through REGEDI), using 3 bits of
// data for each.
//
#define REGMASK       7
#define REGCOUNT      8
#define REGSHIFT      3

//
// Declare fragment description array
//
extern CONST FRAGDESC Fragments[OP_MAX];
extern CONST PPLACEOPERATIONFN PlaceFn[FN_MAX];



VOID
FlushCallstack(
    PTHREADSTATE cpu
    );

//
// The following three functions are used by the indirect control transfer code
//

ULONG
getUniqueIndex(
    VOID
    );

VOID
FlushIndirControlTransferTable(
    VOID
    );

ULONG
IndirectControlTransfer(
    IN ULONG tableEntry,
    IN ULONG intelAddr,
    IN PTHREADSTATE cpu
    );

ULONG
IndirectControlTransferFar(
    IN PTHREADSTATE cpu,
    IN PUSHORT pintelAddr,
    IN ULONG tableEntry
    );

ULONG PlaceInstructions(
    PCHAR CodeLocation,
    DWORD cEntryPoints
    );

//
// Function for initializing the fragment library
//
BOOL
FragLibInit(
    PCPUCONTEXT cpu,
    DWORD StackBase
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\idata.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    idata.h

Abstract:

    This module contains definitions of all x86 instructions.  Before
    including this file, the DEF_INSTR macro must be defined.

Author:

    Dave Hastings (daveh) creation-date 23-Jun-1995

Revision History:


--*/

//
// Possible values for instruction flags (OPFL_):
//  CTRLTRNS -
//             Direct control transfers.  The compiler will build an entrypoint
//             for the destination of the call, provided it is within the
//             current instruction stream
//  END_NEXT_EP -
//             Indicates the instruction following the current one must
//             have its own entrypoint.  ie. CALL instructions.
//  STOP_COMPILE -
//             Compilation will halt after this instruction.  The remainder
//             of the instruction stream will be discarded.
//  ALIGN    -
//             The instruction has an ALIGNED flavor, created by adding 1
//             to the current Operation value.
//  HASNOFLAGS -
//             The instruction as a NOFLAGS flavor, created by the following
//             formula:
//              OP_NOFLAGS = OP + (Flags & OPFL_ALIGN) ? 2 : 1;
//
//

#include <eflags.h>
#define ALLFLAGS (FLAG_CF|FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF)


#ifndef DEF_INSTR
#error Must define DEF_INSTR(OpName,FlagsNeeded,FlagsSet,RegsSet,Opfl,FastPlaceFn,FastSize,SlowPlaceFn,SlowSize,FragName) before including this file
#endif


//
// Each DEF_INSTR defines a new instruction, with the following format:
// DEF_INSTR(instruction name,
//               flags read, flags set, registers implictly modified
//               OP flags
//               place function, size of assembly code for call to fragment
//               address of fragment)
//

DEF_INSTR(OP_CTRL_COND_Ja,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJaFrag)
DEF_INSTR(OP_CTRL_COND_Jae,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJaeFrag)
DEF_INSTR(OP_CTRL_COND_Jbe,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJbeFrag)
DEF_INSTR(OP_CTRL_COND_Jb,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJbFrag)
DEF_INSTR(OP_CTRL_COND_Je,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJeFrag)
DEF_INSTR(OP_CTRL_COND_Jg,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJgFrag)
DEF_INSTR(OP_CTRL_COND_Jl,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJlFrag)
DEF_INSTR(OP_CTRL_COND_Jle,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJleFrag)
DEF_INSTR(OP_CTRL_COND_Jne,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJneFrag)
DEF_INSTR(OP_CTRL_COND_Jnl,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnlFrag)
DEF_INSTR(OP_CTRL_COND_Jno,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnoFrag)
DEF_INSTR(OP_CTRL_COND_Jnp,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnpFrag)
DEF_INSTR(OP_CTRL_COND_Jns,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJnsFrag)
DEF_INSTR(OP_CTRL_COND_Jo,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJoFrag)
DEF_INSTR(OP_CTRL_COND_Jp,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJpFrag)
DEF_INSTR(OP_CTRL_COND_Js,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJsFrag)
DEF_INSTR(OP_CTRL_COND_JaFwd,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJaFrag)
DEF_INSTR(OP_CTRL_COND_JaeFwd,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJaeFrag)
DEF_INSTR(OP_CTRL_COND_JbeFwd,
              FLAG_CF|FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJbeFrag)
DEF_INSTR(OP_CTRL_COND_JbFwd,
              FLAG_CF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJbFrag)
DEF_INSTR(OP_CTRL_COND_JeFwd,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJeFrag)
DEF_INSTR(OP_CTRL_COND_JgFwd,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJgFrag)
DEF_INSTR(OP_CTRL_COND_JlFwd,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJlFrag)
DEF_INSTR(OP_CTRL_COND_JleFwd,
              FLAG_ZF|FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJleFrag)
DEF_INSTR(OP_CTRL_COND_JneFwd,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJneFrag)
DEF_INSTR(OP_CTRL_COND_JnlFwd,
              FLAG_SF|FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnlFrag)
DEF_INSTR(OP_CTRL_COND_JnoFwd,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnoFrag)
DEF_INSTR(OP_CTRL_COND_JnpFwd,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnpFrag)
DEF_INSTR(OP_CTRL_COND_JnsFwd,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJnsFrag)
DEF_INSTR(OP_CTRL_COND_JoFwd,
              FLAG_OF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJoFrag)
DEF_INSTR(OP_CTRL_COND_JpFwd,
              FLAG_PF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJpFrag)
DEF_INSTR(OP_CTRL_COND_JsFwd,
              FLAG_SF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJsFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_b32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJecxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_b16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenJcxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_bFwd32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJecxzFrag)
DEF_INSTR(OP_CTRL_COND_Jcxz_bFwd16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenJcxzFrag)
DEF_INSTR(OP_CTRL_COND_Loop_b32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopFrag32)
DEF_INSTR(OP_CTRL_COND_Loop_b16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopFrag16)
DEF_INSTR(OP_CTRL_COND_Loop_bFwd32,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopFrag32)
DEF_INSTR(OP_CTRL_COND_Loop_bFwd16,
              0, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopFrag16)
DEF_INSTR(OP_CTRL_COND_Loope_b32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopeFrag32)
DEF_INSTR(OP_CTRL_COND_Loope_b16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopeFrag16)
DEF_INSTR(OP_CTRL_COND_Loope_bFwd32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopeFrag32)
DEF_INSTR(OP_CTRL_COND_Loope_bFwd16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopeFrag16)
DEF_INSTR(OP_CTRL_COND_Loopne_b32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopneFrag32)
DEF_INSTR(OP_CTRL_COND_Loopne_b16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxx,
              FN_PlaceJxxSlow,
              GenLoopneFrag16)
DEF_INSTR(OP_CTRL_COND_Loopne_bFwd32,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopneFrag32)
DEF_INSTR(OP_CTRL_COND_Loopne_bFwd16,
              FLAG_ZF, 0, 0,
              OPFL_CTRLTRNS,
              FN_PlaceJxxFwd,
              FN_PlaceJxxSlow,
              GenLoopneFrag16)
DEF_INSTR(OP_CTRL_UNCOND_Call,
              0, 0, ALLREGS,
              OPFL_CTRLTRNS|OPFL_END_NEXT_EP,
              FN_PlaceCallDirect,
              FN_PlaceCallDirect,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Callf,
              0, 0, ALLREGS,
              OPFL_CTRLTRNS|OPFL_END_NEXT_EP,
              FN_PlaceCallfDirect,
              FN_PlaceCallfDirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Call,
              ALLFLAGS, 0, ALLREGS,
              OPFL_END_NEXT_EP,
              FN_GenCallIndirect,
              FN_GenCallIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Callf,
              ALLFLAGS, 0, ALLREGS,
              OPFL_END_NEXT_EP,
              FN_GenCallfIndirect,
              FN_GenCallfIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Jmp,
              ALLFLAGS, 0, 0,
              OPFL_END_NEXT_EP,
              FN_GenCallJmpIndirect,
              FN_GenCallJmpIndirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Jmpf,
              ALLFLAGS, 0, 0,
              OPFL_END_NEXT_EP,
              FN_GenCallJmpfIndirect,
              FN_GenCallJmpfIndirect,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Jmp,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpDirect,
              FN_PlaceJmpDirectSlow,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_JmpFwd,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpFwdDirect,
              FN_PlaceJmpDirectSlow,
              NULL)
DEF_INSTR(OP_CTRL_UNCOND_Jmpf,
              0, 0, 0,
              OPFL_END_NEXT_EP|OPFL_CTRLTRNS,
              FN_PlaceJmpfDirect,
              FN_PlaceJmpfDirect,
              NULL)
DEF_INSTR(OP_CTRL_INDIR_Retn_i16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retn_iFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retn_i32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retn_iFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retn16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetnFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retn32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetnFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retf_i16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retf_iFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retf_i32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_Retf_iFrag32)
DEF_INSTR(OP_CTRL_INDIR_Retf16,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetfFrag16)
DEF_INSTR(OP_CTRL_INDIR_Retf32,
              ALLFLAGS, 0, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_RetfFrag32)
DEF_INSTR(OP_Int,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              IntFrag)
DEF_INSTR(OP_CTRL_INDIR_IRet,
              ALLFLAGS, ALLFLAGS, REGESP,
              OPFL_END_NEXT_EP,
              FN_GenCallRetIndirect,
              FN_GenCallRetIndirect,
              CTRL_INDIR_IRetFrag)
DEF_INSTR(OP_Unsimulate,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragNoCpu,
              FN_GenCallCFragNoCpuSlow,
              UnsimulateFrag)
DEF_INSTR(OP_PrivilegedInstruction,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              PrivilegedInstructionFrag)
DEF_INSTR(OP_BadInstruction,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              BadInstructionFrag)
DEF_INSTR(OP_Fault,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              FaultFrag)
DEF_INSTR(OP_IntO,
              FLAG_OF, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEip,
              FN_GenCallCFragLoadEipSlow,
              IntOFrag)

// Next 4 must be consecutive
DEF_INSTR(OP_Add32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag32)
DEF_INSTR(OP_Add32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag32A)
DEF_INSTR(OP_AddNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenAddFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag32)
DEF_INSTR(OP_AddNoFlags32A,
              0, ALLFLAGS, 0,
              OPFL_INLINEARITH,
              FN_GenAddFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Add16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag16)
DEF_INSTR(OP_Add16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag16A)
DEF_INSTR(OP_AddNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag16)
DEF_INSTR(OP_AddNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Add8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AddFrag8)
DEF_INSTR(OP_AddNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AddNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Inc32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag32)
DEF_INSTR(OP_Inc32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag32A)
DEF_INSTR(OP_IncNoFlags32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenIncFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag32)
DEF_INSTR(OP_IncNoFlags32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenIncFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Inc16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag16)
DEF_INSTR(OP_Inc16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag16A)
DEF_INSTR(OP_IncNoFlags16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag16)
DEF_INSTR(OP_IncNoFlags16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Inc8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IncFrag8)
DEF_INSTR(OP_IncNoFlags8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              IncNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Dec32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag32)
DEF_INSTR(OP_Dec32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag32A)
DEF_INSTR(OP_DecNoFlags32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenDecFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag32)
DEF_INSTR(OP_DecNoFlags32A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenDecFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Dec16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag16)
DEF_INSTR(OP_Dec16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag16A)
DEF_INSTR(OP_DecNoFlags16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag16)
DEF_INSTR(OP_DecNoFlags16A,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Dec8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DecFrag8)
DEF_INSTR(OP_DecNoFlags8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              DecNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sub32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag32)
DEF_INSTR(OP_Sub32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag32A)
DEF_INSTR(OP_SubNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenSubFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag32)
DEF_INSTR(OP_SubNoFlags32A,
              0, ALLFLAGS, 0,
              OPFL_INLINEARITH,
              FN_GenSubFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sub16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag16)
DEF_INSTR(OP_Sub16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag16A)
DEF_INSTR(OP_SubNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag16)
DEF_INSTR(OP_SubNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sub8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SubFrag8)
DEF_INSTR(OP_SubNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SubNoFlagsFrag8)

DEF_INSTR(OP_Cmp32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag32)
DEF_INSTR(OP_Cmp16,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag16)
DEF_INSTR(OP_Cmp8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Adc32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag32)
DEF_INSTR(OP_Adc32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag32A)
DEF_INSTR(OP_AdcNoFlags32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag32)
DEF_INSTR(OP_AdcNoFlags32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Adc16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag16)
DEF_INSTR(OP_Adc16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag16A)
DEF_INSTR(OP_AdcNoFlags16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag16)
DEF_INSTR(OP_AdcNoFlags16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Adc8,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcFrag8)
DEF_INSTR(OP_AdcNoFlags8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AdcNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sbb32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag32)
DEF_INSTR(OP_Sbb32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag32A)
DEF_INSTR(OP_SbbNoFlags32,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag32)
DEF_INSTR(OP_SbbNoFlags32A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sbb16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag16)
DEF_INSTR(OP_Sbb16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag16A)
DEF_INSTR(OP_SbbNoFlags16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag16)
DEF_INSTR(OP_SbbNoFlags16A,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sbb8,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbFrag8)
DEF_INSTR(OP_SbbNoFlags8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SbbNoFlagsFrag8)


DEF_INSTR(OP_Mov32,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)
DEF_INSTR(OP_Mov16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)
DEF_INSTR(OP_Mov8,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenEndMovSlow,
              NULL)

// Next 4 must be consecutive
DEF_INSTR(OP_Or32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag32)
DEF_INSTR(OP_Or32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag32A)
DEF_INSTR(OP_OrNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenOrFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag32)
DEF_INSTR(OP_OrNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenOrFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Or16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag16)
DEF_INSTR(OP_Or16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag16A)
DEF_INSTR(OP_OrNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag16)
DEF_INSTR(OP_OrNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Or8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OrFrag8)
DEF_INSTR(OP_OrNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OrNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_And32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag32)
DEF_INSTR(OP_And32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag32A)
DEF_INSTR(OP_AndNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenAndFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag32)
DEF_INSTR(OP_AndNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenAndFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_And16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag16)
DEF_INSTR(OP_And16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag16A)
DEF_INSTR(OP_AndNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag16)
DEF_INSTR(OP_AndNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_And8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AndFrag8)
DEF_INSTR(OP_AndNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              AndNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Xor32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag32)
DEF_INSTR(OP_Xor32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag32A)
DEF_INSTR(OP_XorNoFlags32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_INLINEARITH,
              FN_GenXorFragNoFlags32, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag32)
DEF_INSTR(OP_XorNoFlags32A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_INLINEARITH,
              FN_GenXorFragNoFlags32A, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Xor16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag16)
DEF_INSTR(OP_Xor16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag16A)
DEF_INSTR(OP_XorNoFlags16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag16)
DEF_INSTR(OP_XorNoFlags16A,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xor8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XorFrag8)
DEF_INSTR(OP_XorNoFlags8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XorNoFlagsFrag8)

DEF_INSTR(OP_Test32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag32)
DEF_INSTR(OP_Test16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag16)
DEF_INSTR(OP_Test8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              TestFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Xchg32,
              0, 0, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag32)
DEF_INSTR(OP_Xchg32A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xchg16,
              0, 0, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag16)
DEF_INSTR(OP_Xchg16A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag16A)
DEF_INSTR(OP_Xchg8,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XchgFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rol32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag32)
DEF_INSTR(OP_Rol32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rol16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag16)
DEF_INSTR(OP_Rol16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag16A)
DEF_INSTR(OP_Rol8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RolFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Ror32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag32)
DEF_INSTR(OP_Ror32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Ror16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag16)
DEF_INSTR(OP_Ror16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag16A)
DEF_INSTR(OP_Ror8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RorFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rcl32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag32)
DEF_INSTR(OP_Rcl32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcl16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag16)
DEF_INSTR(OP_Rcl16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag16A)
DEF_INSTR(OP_Rcl8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RclFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Rcr32,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag32)
DEF_INSTR(OP_Rcr32A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcr16,
              FLAG_CF, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag16)
DEF_INSTR(OP_Rcr16A,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag16A)
DEF_INSTR(OP_Rcr8,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RcrFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shl32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag32)
DEF_INSTR(OP_Shl32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag32A)
DEF_INSTR(OP_ShlNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag32)
DEF_INSTR(OP_ShlNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shl16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag16)
DEF_INSTR(OP_Shl16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag16A)
DEF_INSTR(OP_ShlNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag16)
DEF_INSTR(OP_ShlNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shl8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShlFrag8)
DEF_INSTR(OP_ShlNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShlNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shr32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag32)
DEF_INSTR(OP_Shr32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag32A)
DEF_INSTR(OP_ShrNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag32)
DEF_INSTR(OP_ShrNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shr16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag16)
DEF_INSTR(OP_Shr16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag16A)
DEF_INSTR(OP_ShrNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag16)
DEF_INSTR(OP_ShrNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shr8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrFrag8)
DEF_INSTR(OP_ShrNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sar32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag32)
DEF_INSTR(OP_Sar32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag32A)
DEF_INSTR(OP_SarNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag32)
DEF_INSTR(OP_SarNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sar16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag16)
DEF_INSTR(OP_Sar16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag16A)
DEF_INSTR(OP_SarNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag16)
DEF_INSTR(OP_SarNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sar8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SarFrag8)
DEF_INSTR(OP_SarNoFlags8,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              SarNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rol132,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag32)
DEF_INSTR(OP_Rol132A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag32A)
DEF_INSTR(OP_Rol1NoFlags32,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag32)
DEF_INSTR(OP_Rol1NoFlags32A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rol116,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag16)
DEF_INSTR(OP_Rol116A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag16A)
DEF_INSTR(OP_Rol1NoFlags16,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag16)
DEF_INSTR(OP_Rol1NoFlags16A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rol18,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rol1Frag8)
DEF_INSTR(OP_Rol1NoFlags8,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Rol1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Ror132,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag32)
DEF_INSTR(OP_Ror132A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag32A)
DEF_INSTR(OP_Ror1NoFlags32,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag32)
DEF_INSTR(OP_Ror1NoFlags32A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Ror116,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag16)
DEF_INSTR(OP_Ror116A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag16A)
DEF_INSTR(OP_Ror1NoFlags16,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag16)
DEF_INSTR(OP_Ror1NoFlags16A,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Ror18,
              0, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Ror1Frag8)
DEF_INSTR(OP_Ror1NoFlags8,
              0, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Ror1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rcl132,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag32)
DEF_INSTR(OP_Rcl132A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag32A)
DEF_INSTR(OP_Rcl1NoFlags32,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag32)
DEF_INSTR(OP_Rcl1NoFlags32A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rcl116,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag16)
DEF_INSTR(OP_Rcl116A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag16A)
DEF_INSTR(OP_Rcl1NoFlags16,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag16)
DEF_INSTR(OP_Rcl1NoFlags16A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcl18,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1Frag8)
DEF_INSTR(OP_Rcl1NoFlags8,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcl1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Rcr132,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag32)
DEF_INSTR(OP_Rcr132A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag32A)
DEF_INSTR(OP_Rcr1NoFlags32,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag32)
DEF_INSTR(OP_Rcr1NoFlags32A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Rcr116,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag16)
DEF_INSTR(OP_Rcr116A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag16A)
DEF_INSTR(OP_Rcr1NoFlags16,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag16)
DEF_INSTR(OP_Rcr1NoFlags16A,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Rcr18,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1Frag8)
DEF_INSTR(OP_Rcr1NoFlags8,
              FLAG_CF, FLAG_CF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rcr1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shl132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag32)
DEF_INSTR(OP_Shl132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag32A)
DEF_INSTR(OP_Shl1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag32)
DEF_INSTR(OP_Shl1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shl116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag16)
DEF_INSTR(OP_Shl116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag16A)
DEF_INSTR(OP_Shl1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag16)
DEF_INSTR(OP_Shl1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shl18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shl1Frag8)
DEF_INSTR(OP_Shl1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shl1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Shr132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag32)
DEF_INSTR(OP_Shr132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag32A)
DEF_INSTR(OP_Shr1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag32)
DEF_INSTR(OP_Shr1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shr116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag16)
DEF_INSTR(OP_Shr116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag16A)
DEF_INSTR(OP_Shr1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag16)
DEF_INSTR(OP_Shr1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Shr18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Shr1Frag8)
DEF_INSTR(OP_Shr1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Shr1NoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Sar132,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag32)
DEF_INSTR(OP_Sar132A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag32A)
DEF_INSTR(OP_Sar1NoFlags32,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag32)
DEF_INSTR(OP_Sar1NoFlags32A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Sar116,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag16)
DEF_INSTR(OP_Sar116A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag16A)
DEF_INSTR(OP_Sar1NoFlags16,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag16)
DEF_INSTR(OP_Sar1NoFlags16A,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Sar18,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Sar1Frag8)
DEF_INSTR(OP_Sar1NoFlags8,
              0, FLAG_CF|FLAG_OF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              Sar1NoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Not32,
              0, 0, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag32)
DEF_INSTR(OP_Not32A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Not16,
              0, 0, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag16)
DEF_INSTR(OP_Not16A,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag16A)
DEF_INSTR(OP_Not8,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NotFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Neg32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag32)
DEF_INSTR(OP_Neg32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag32A)
DEF_INSTR(OP_NegNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag32)
DEF_INSTR(OP_NegNoFlags32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Neg16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag16)
DEF_INSTR(OP_Neg16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag16A)
DEF_INSTR(OP_NegNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag16)
DEF_INSTR(OP_NegNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Neg8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              NegFrag8)
DEF_INSTR(OP_NegNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              NegNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Mul32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag32)
DEF_INSTR(OP_Mul32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag32A)
DEF_INSTR(OP_MulNoFlags32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag32)
DEF_INSTR(OP_MulNoFlags32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Mul16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag16)
DEF_INSTR(OP_Mul16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag16A)
DEF_INSTR(OP_MulNoFlags16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag16)
DEF_INSTR(OP_MulNoFlags16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Mul8,
              0, FLAG_CF|FLAG_OF, REGAX,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulFrag8)
DEF_INSTR(OP_MulNoFlags8,
              0, FLAG_CF|FLAG_OF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MulNoFlagsFrag8)

// Next 4 must be consecutive
DEF_INSTR(OP_Muli32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag32)
DEF_INSTR(OP_Muli32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag32A)
DEF_INSTR(OP_MuliNoFlags32,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag32)
DEF_INSTR(OP_MuliNoFlags32A,
              0, FLAG_CF|FLAG_OF, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Muli16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag16)
DEF_INSTR(OP_Muli16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag16A)
DEF_INSTR(OP_MuliNoFlags16,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag16)
DEF_INSTR(OP_MuliNoFlags16A,
              0, FLAG_CF|FLAG_OF, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Muli8,
              0, FLAG_CF|FLAG_OF, REGAX,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliFrag8)
DEF_INSTR(OP_MuliNoFlags8,
              0, FLAG_CF|FLAG_OF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MuliNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Div32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag32)
DEF_INSTR(OP_Div32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Div16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag16)
DEF_INSTR(OP_Div16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag16A)
DEF_INSTR(OP_Div8,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DivFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Idiv32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag32)
DEF_INSTR(OP_Idiv32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Idiv16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag16)
DEF_INSTR(OP_Idiv16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag16A)
DEF_INSTR(OP_Idiv8,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              IdivFrag8)

DEF_INSTR(OP_Lods32,
              0, 0, REGEAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag32)
DEF_INSTR(OP_Lods16,
              0, 0, REGAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag16)
DEF_INSTR(OP_Lods8,
              0, 0, REGAL|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LodsFrag8)

DEF_INSTR(OP_FsLods32,
              0, 0, REGEAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag32)
DEF_INSTR(OP_FsLods16,
              0, 0, REGAX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag16)
DEF_INSTR(OP_FsLods8,
              0, 0, REGAL|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsLodsFrag8)

DEF_INSTR(OP_RepLods32,
              0, 0, REGEAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag32)
DEF_INSTR(OP_RepLods16,
              0, 0, REGAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag16)
DEF_INSTR(OP_RepLods8,
              0, 0, REGAL|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepLodsFrag8)

DEF_INSTR(OP_FsRepLods32,
              0, 0, REGEAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag32)
DEF_INSTR(OP_FsRepLods16,
              0, 0, REGAX|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag16)
DEF_INSTR(OP_FsRepLods8,
              0, 0, REGAL|REGECX|REGESI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepLodsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_Scas32,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag32)
DEF_INSTR(OP_ScasNoFlags32,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_Scas16,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag16)
DEF_INSTR(OP_ScasNoFlags16,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_Scas8,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasFrag8)
DEF_INSTR(OP_ScasNoFlags8,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsScas32,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag32)
DEF_INSTR(OP_FsScasNoFlags32,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsScas16,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag16)
DEF_INSTR(OP_FsScasNoFlags16,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsScas8,
              0, ALLFLAGS, REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasFrag8)
DEF_INSTR(OP_FsScasNoFlags8,
              0, ALLFLAGS, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag32)
DEF_INSTR(OP_RepnzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag16)
DEF_INSTR(OP_RepnzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_RepnzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasFrag8)
DEF_INSTR(OP_RepnzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag32)
DEF_INSTR(OP_FsRepnzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag16)
DEF_INSTR(OP_FsRepnzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepnzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasFrag8)
DEF_INSTR(OP_FsRepnzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag32)
DEF_INSTR(OP_RepzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag16)
DEF_INSTR(OP_RepzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_RepzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasFrag8)
DEF_INSTR(OP_RepzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzScasNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag32)
DEF_INSTR(OP_FsRepzScasNoFlags32,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag32)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag16)
DEF_INSTR(OP_FsRepzScasNoFlags16,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag16)
// Next 2 must be consecutive
DEF_INSTR(OP_FsRepzScas8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasFrag8)
DEF_INSTR(OP_FsRepzScasNoFlags8,
              ALLFLAGS, ALLFLAGS, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzScasNoFlagsFrag8)

DEF_INSTR(OP_Stos32,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag32)
DEF_INSTR(OP_Stos16,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag16)
DEF_INSTR(OP_Stos8,
              0, 0, REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StosFrag8)

DEF_INSTR(OP_RepStos32,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag32)
DEF_INSTR(OP_RepStos16,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag16)
DEF_INSTR(OP_RepStos8,
              0, 0, REGECX|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepStosFrag8)

DEF_INSTR(OP_Movs32,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag32)
DEF_INSTR(OP_Movs16,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag16)
DEF_INSTR(OP_Movs8,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              MovsFrag8)

DEF_INSTR(OP_FsMovs32,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag32)
DEF_INSTR(OP_FsMovs16,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag16)
DEF_INSTR(OP_FsMovs8,
              0, 0, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsMovsFrag8)

DEF_INSTR(OP_RepMovs32,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag32)
DEF_INSTR(OP_RepMovs16,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag16)
DEF_INSTR(OP_RepMovs8,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepMovsFrag8)

DEF_INSTR(OP_FsRepMovs32,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag32)
DEF_INSTR(OP_FsRepMovs16,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag16)
DEF_INSTR(OP_FsRepMovs8,
              0, 0, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepMovsFrag8)

DEF_INSTR(OP_Cmps32,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag32)
DEF_INSTR(OP_Cmps16,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag16)
DEF_INSTR(OP_Cmps8,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpsFrag8)

DEF_INSTR(OP_RepzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag32)
DEF_INSTR(OP_RepzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag16)
DEF_INSTR(OP_RepzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepzCmpsFrag8)

DEF_INSTR(OP_FsRepzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag32)
DEF_INSTR(OP_FsRepzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag16)
DEF_INSTR(OP_FsRepzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepzCmpsFrag8)

DEF_INSTR(OP_FsCmps32,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag32)
DEF_INSTR(OP_FsCmps16,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag16)
DEF_INSTR(OP_FsCmps8,
              0, ALLFLAGS, REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsCmpsFrag8)

DEF_INSTR(OP_RepnzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag32)
DEF_INSTR(OP_RepnzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag16)
DEF_INSTR(OP_RepnzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              RepnzCmpsFrag8)

DEF_INSTR(OP_FsRepnzCmps32,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag32)
DEF_INSTR(OP_FsRepnzCmps16,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag16)
DEF_INSTR(OP_FsRepnzCmps8,
              ALLFLAGS, ALLFLAGS, REGECX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FsRepnzCmpsFrag8)

DEF_INSTR(OP_PushA32,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushAFrag32)
DEF_INSTR(OP_PushA16,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushAFrag16)

DEF_INSTR(OP_PopA32,
              0, 0, ALLREGS,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopAFrag32)
DEF_INSTR(OP_PopA16,
              0, 0, ALLREGS,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopAFrag16)

DEF_INSTR(OP_Push32,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFrag32)
DEF_INSTR(OP_Push16,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFrag16)

// Next 2 must be consecutive
DEF_INSTR(OP_Pop32,
              0, 0, REGESP,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag32)
DEF_INSTR(OP_Pop32A,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Pop16,
              0, 0, REGESP,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag16)
DEF_INSTR(OP_Pop16A,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFrag16A)

DEF_INSTR(OP_Cbw32,
              0, 0, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CbwFrag32)
DEF_INSTR(OP_Cbw16,
              0, 0, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CbwFrag16)

DEF_INSTR(OP_Cwd32,
              0, 0, REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CwdFrag32)
DEF_INSTR(OP_Cwd16,
              0, 0, REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CwdFrag16)

DEF_INSTR(OP_Bound32,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BoundFrag32)
DEF_INSTR(OP_Bound16,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BoundFrag16)

DEF_INSTR(OP_Enter32,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              EnterFrag32)
DEF_INSTR(OP_Enter16,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              EnterFrag16)

DEF_INSTR(OP_Leave32,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LeaveFrag32)
DEF_INSTR(OP_Leave16,
              0, 0, REGESP|REGEBP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LeaveFrag16)

DEF_INSTR(OP_Les32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LesFrag32)
DEF_INSTR(OP_Les16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LesFrag16)

DEF_INSTR(OP_Lds32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LdsFrag32)
DEF_INSTR(OP_Lds16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LdsFrag16)

DEF_INSTR(OP_Lss32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LssFrag32)
DEF_INSTR(OP_Lss16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LssFrag16)

DEF_INSTR(OP_Lfs32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LfsFrag32)
DEF_INSTR(OP_Lfs16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LfsFrag16)

DEF_INSTR(OP_Lgs32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LgsFrag32)
DEF_INSTR(OP_Lgs16,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LgsFrag16)

DEF_INSTR(OP_BtReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag32)
DEF_INSTR(OP_BtReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag32A)
DEF_INSTR(OP_BtReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag16)
DEF_INSTR(OP_BtReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtRegFrag16)

DEF_INSTR(OP_BtsReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag32)
DEF_INSTR(OP_BtsReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag32A)
DEF_INSTR(OP_BtsReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag16)
DEF_INSTR(OP_BtsReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsRegFrag16A)

DEF_INSTR(OP_BtcReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag32)
DEF_INSTR(OP_BtcReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag32A)
DEF_INSTR(OP_BtcReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag16)
DEF_INSTR(OP_BtcReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcRegFrag16A)

DEF_INSTR(OP_BtrReg32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag32)
DEF_INSTR(OP_BtrReg32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag32A)
DEF_INSTR(OP_BtrReg16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag16)
DEF_INSTR(OP_BtrReg16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrRegFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag32)
DEF_INSTR(OP_BtMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag16)
DEF_INSTR(OP_BtMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtsMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag32)
DEF_INSTR(OP_BtsMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtsMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag16)
DEF_INSTR(OP_BtsMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtsMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtcMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag32)
DEF_INSTR(OP_BtcMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtcMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag16)
DEF_INSTR(OP_BtcMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtcMemFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_BtrMem32,
              0, FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag32)
DEF_INSTR(OP_BtrMem32A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_BtrMem16,
              0, FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag16)
DEF_INSTR(OP_BtrMem16A,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BtrMemFrag16A)

DEF_INSTR(OP_Pushf32,
              ALLFLAGS, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushfFrag32)
DEF_INSTR(OP_Pushf16,
              ALLFLAGS, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushfFrag16)

DEF_INSTR(OP_Popf32,
              0, ALLFLAGS, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopfFrag32)
DEF_INSTR(OP_Popf16,
              0, ALLFLAGS, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopfFrag16)

// Next 4 must be consecutive
DEF_INSTR(OP_Shld32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag32)
DEF_INSTR(OP_Shld32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag32A)
DEF_INSTR(OP_ShldNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag32)
DEF_INSTR(OP_ShldNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shld16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag16)
DEF_INSTR(OP_Shld16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShldFrag16A)
DEF_INSTR(OP_ShldNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag16)
DEF_INSTR(OP_ShldNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShldNoFlagsFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Shrd32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag32)
DEF_INSTR(OP_Shrd32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag32A)
DEF_INSTR(OP_ShrdNoFlags32,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag32)
DEF_INSTR(OP_ShrdNoFlags32A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Shrd16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag16)
DEF_INSTR(OP_Shrd16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ShrdFrag16A)
DEF_INSTR(OP_ShrdNoFlags16,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag16)
DEF_INSTR(OP_ShrdNoFlags16A,
              FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_PF, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              ShrdNoFlagsFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_Bsr32,
              0, FLAG_ZF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag32)
DEF_INSTR(OP_Bsr32A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Bsr16,
              0, FLAG_ZF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag16)
DEF_INSTR(OP_Bsr16A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsrFrag16A)

// Next 2 must be consecutive
DEF_INSTR(OP_Bsf32,
              0, FLAG_ZF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag32)
DEF_INSTR(OP_Bsf32A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_Bsf16,
              0, FLAG_ZF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag16)
DEF_INSTR(OP_Bsf16A,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              BsfFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Xadd32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag32)
DEF_INSTR(OP_Xadd32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag32A)
DEF_INSTR(OP_XaddNoFlags32,
              0, ALLFLAGS, 0,
              OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag32)
DEF_INSTR(OP_XaddNoFlags32A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Xadd16,
              0, ALLFLAGS, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag16)
DEF_INSTR(OP_Xadd16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag16A)
DEF_INSTR(OP_XaddNoFlags16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16|OPFL_ALIGN,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag16)
DEF_INSTR(OP_XaddNoFlags16A,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag16A)
// Next 2 must be consecutive
DEF_INSTR(OP_Xadd8,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XaddFrag8)
DEF_INSTR(OP_XaddNoFlags8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              XaddNoFlagsFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_CmpXchg32,
              0, ALLFLAGS, REGEAX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag32)
DEF_INSTR(OP_CmpXchg32A,
              0, ALLFLAGS, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_CmpXchg16,
              0, ALLFLAGS, REGAX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag16)
DEF_INSTR(OP_CmpXchg16A,
              0, ALLFLAGS, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmpXchgFrag16A)
DEF_INSTR(OP_CmpXchg8,
              0, ALLFLAGS, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
	      CmpXchgFrag8)
DEF_INSTR(OP_CMPXCHG8B,
	      0, FLAG_ZF, REGEAX|REGEDX,
	      0,
	      FN_GenCallCFrag, FN_GenCallCFragSlow,
	      CmpXchg8bFrag32)
DEF_INSTR(OP_SynchLockCMPXCHG8B,
	      0, FLAG_ZF, REGEAX|REGEDX,
	      0,
	      FN_GenCallCFrag, FN_GenCallCFragSlow,
	      SynchLockCmpXchg8bFrag32)

DEF_INSTR(OP_Lar32,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LarFrag32)
DEF_INSTR(OP_Lar16,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LarFrag16)

DEF_INSTR(OP_Lsl32,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LslFrag32)
DEF_INSTR(OP_Lsl16,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LslFrag16)

DEF_INSTR(OP_BOP,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              0,
              FN_GenCallCFragLoadEipNoCpu, FN_GenCallCFragLoadEipNoCpuSlow,
              BOPFrag)

DEF_INSTR(OP_BOP_STOP_DECODE,
              ALLFLAGS, ALLFLAGS, ALLREGS,
              OPFL_STOP_COMPILE,
              FN_GenCallCFragLoadEipNoCpu, FN_GenCallCFragLoadEipNoCpuSlow,
              BOPFrag)

DEF_INSTR(OP_PushEs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushEsFrag)

DEF_INSTR(OP_PopEs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopEsFrag)

DEF_INSTR(OP_PushFs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushFsFrag)

DEF_INSTR(OP_PopFs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopFsFrag)

DEF_INSTR(OP_PushGs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushGsFrag)

DEF_INSTR(OP_PopGs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopGsFrag)

DEF_INSTR(OP_PushCs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushCsFrag)

DEF_INSTR(OP_PushSs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushSsFrag)

DEF_INSTR(OP_PopSs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopSsFrag)

DEF_INSTR(OP_PushDs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PushDsFrag)

DEF_INSTR(OP_PopDs,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              PopDsFrag)

DEF_INSTR(OP_Aas,
              FLAG_AUX, FLAG_CF|FLAG_AUX, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AasFrag)

DEF_INSTR(OP_Daa,
              FLAG_AUX|FLAG_CF, FLAG_SF|FLAG_ZF|FLAG_CF|FLAG_AUX|FLAG_PF, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DaaFrag)

DEF_INSTR(OP_Das,
              FLAG_AUX|FLAG_CF, FLAG_SF|FLAG_ZF|FLAG_AUX|FLAG_CF|FLAG_PF, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              DasFrag)

DEF_INSTR(OP_Aaa,
              FLAG_AUX, FLAG_AUX|FLAG_CF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AaaFrag)

DEF_INSTR(OP_Aad,
              0, FLAG_PF|FLAG_ZF|FLAG_SF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AadFrag)

DEF_INSTR(OP_Aam,
              0, FLAG_SF|FLAG_PF|FLAG_ZF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              AamFrag)

// Next 4 must be consecutive
DEF_INSTR(OP_Imul32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag32)
DEF_INSTR(OP_Imul32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag32A)
DEF_INSTR(OP_ImulNoFlags32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag32)
DEF_INSTR(OP_ImulNoFlags32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Imul16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag16)
DEF_INSTR(OP_Imul16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulFrag16A)
DEF_INSTR(OP_ImulNoFlags16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag16)
DEF_INSTR(OP_ImulNoFlags16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ImulNoFlagsFrag16A)

// Next 4 must be consecutive
DEF_INSTR(OP_Imul3Arg32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag32)
DEF_INSTR(OP_Imul3Arg32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag32A)
DEF_INSTR(OP_Imul3ArgNoFlags32,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag32)
DEF_INSTR(OP_Imul3ArgNoFlags32A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag32A)
// Next 4 must be consecutive
DEF_INSTR(OP_Imul3Arg16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16|OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag16)
DEF_INSTR(OP_Imul3Arg16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgFrag16A)
DEF_INSTR(OP_Imul3ArgNoFlags16,
              0, FLAG_OF|FLAG_CF, 0,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag16)
DEF_INSTR(OP_Imul3ArgNoFlags16A,
              0, FLAG_OF|FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Imul3ArgNoFlagsFrag16A)

DEF_INSTR(OP_Sahf,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SahfFrag)

DEF_INSTR(OP_Lahf,
              ALLFLAGS, 0, REGAH,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              LahfFrag)

DEF_INSTR(OP_Xlat,
              0, 0, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              XlatFrag)

DEF_INSTR(OP_Cmc,
              FLAG_CF, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CmcFrag)

DEF_INSTR(OP_Clc,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ClcFrag)

DEF_INSTR(OP_Stc,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StcFrag)

DEF_INSTR(OP_Cld,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CldFrag)

DEF_INSTR(OP_Std,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              StdFrag)

DEF_INSTR(OP_Seto,
              0, FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetoFrag)

DEF_INSTR(OP_Setno,
              0, FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnoFrag)

DEF_INSTR(OP_Setb,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetbFrag)

DEF_INSTR(OP_Setae,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetaeFrag)

DEF_INSTR(OP_Sete,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SeteFrag)

DEF_INSTR(OP_Setne,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetneFrag)

DEF_INSTR(OP_Setbe,
              0, FLAG_CF|FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetbeFrag)

DEF_INSTR(OP_Seta,
              0, FLAG_CF|FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetaFrag)

DEF_INSTR(OP_Sets,
              0, FLAG_SF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetsFrag)

DEF_INSTR(OP_Setns,
              0, FLAG_SF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnsFrag)

DEF_INSTR(OP_Setp,
              0, FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetpFrag)

DEF_INSTR(OP_Setnp,
              0, FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetnpFrag)

DEF_INSTR(OP_Setl,
              0, FLAG_SF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetlFrag)

DEF_INSTR(OP_Setge,
              0, FLAG_SF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetgeFrag)

DEF_INSTR(OP_Setle,
              0, FLAG_SF|FLAG_ZF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetleFrag)

DEF_INSTR(OP_Setg,
              0, FLAG_SF|FLAG_ZF|FLAG_OF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SetgFrag)

DEF_INSTR(OP_Nop,
              0, 0, 0,
              0,
              FN_PlaceNop, FN_GenCallCFragNoCpuSlow,
              NopFrag)

DEF_INSTR(OP_Movsx8To32,
              0, 0, 0,
              0,
              FN_GenMovsx8To32,
              FN_GenMovsx8To32Slow,
              NULL)

DEF_INSTR(OP_Movsx8To16,
              0, 0, 0,
              0,
              FN_GenMovsx8To16,
              FN_GenMovsx8To16Slow,
              NULL)

DEF_INSTR(OP_Movsx16To32,
              0, 0, 0,
              0,
              FN_GenMovsx16To32,
              FN_GenMovsx16To32Slow,
              NULL)

DEF_INSTR(OP_Movzx8To32,
              0, 0, 0,
              0,
              FN_GenMovzx8To32,
              FN_GenMovzx8To32Slow,
              NULL)

DEF_INSTR(OP_Movzx8To16,
              0, 0, 0,
              0,
              FN_GenMovzx8To16,
              FN_GenMovzx8To16Slow,
              NULL)

DEF_INSTR(OP_Movzx16To32,
              0, 0, 0,
              0,
              FN_GenMovzx16To32,
              FN_GenMovzx16To32Slow,
              NULL)

DEF_INSTR(OP_Wait,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              WaitFrag)

DEF_INSTR(OP_Bswap32,
              0, 0, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              BswapFrag32)

DEF_INSTR(OP_Arpl,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              ArplFrag)

DEF_INSTR(OP_Verr,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              VerrFrag)

DEF_INSTR(OP_Verw,
              0, FLAG_ZF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              VerwFrag)

DEF_INSTR(OP_Smsw,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SmswFrag)

DEF_INSTR(OP_FP_FADD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD32)

DEF_INSTR(OP_FP_FMUL32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL32)

DEF_INSTR(OP_FP_FCOM32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM32)

DEF_INSTR(OP_FP_FCOMP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP32)

DEF_INSTR(OP_FP_FSUB32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB32)

DEF_INSTR(OP_FP_FDIV32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV32)

DEF_INSTR(OP_FP_FDIVR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR32)

DEF_INSTR(OP_FP_FADD_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD_ST_STi)

DEF_INSTR(OP_FP_FMUL_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL_ST_STi)

DEF_INSTR(OP_FP_FCOM_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM_STi)

DEF_INSTR(OP_FP_FCOMP_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP_STi)

DEF_INSTR(OP_FP_FSUB_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB_ST_STi)

DEF_INSTR(OP_FP_FSUBR_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR_ST_STi)

DEF_INSTR(OP_FP_FDIV_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV_ST_STi)

DEF_INSTR(OP_FP_FDIVR_ST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR_ST_STi)

DEF_INSTR(OP_FP_FCHS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCHS)

DEF_INSTR(OP_FP_FABS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FABS)

DEF_INSTR(OP_FP_FTST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FTST)

DEF_INSTR(OP_FP_FXAM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXAM)

DEF_INSTR(OP_FP_FLD1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD1)

DEF_INSTR(OP_FP_FLDL2T,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDL2T)

DEF_INSTR(OP_FP_FLDL2E,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDL2E)

DEF_INSTR(OP_FP_FLDPI,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDPI)

DEF_INSTR(OP_FP_FLDLG2,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDLG2)

DEF_INSTR(OP_FP_FLDLN2,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDLN2)

DEF_INSTR(OP_FP_FLDZ,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLDZ)

DEF_INSTR(OP_FP_F2XM1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              F2XM1)

DEF_INSTR(OP_FP_FYL2X,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FYL2X)

DEF_INSTR(OP_FP_FPTAN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPTAN)

DEF_INSTR(OP_FP_FPATAN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPATAN)

DEF_INSTR(OP_FP_FXTRACT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXTRACT)

DEF_INSTR(OP_FP_FPREM1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPREM1)

DEF_INSTR(OP_FP_FDECSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDECSTP)

DEF_INSTR(OP_FP_FINCSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FINCSTP)

DEF_INSTR(OP_FP_FPREM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FPREM)

DEF_INSTR(OP_FP_FYL2XP1,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FYL2XP1)

DEF_INSTR(OP_FP_FSQRT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSQRT)

DEF_INSTR(OP_FP_FSINCOS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSINCOS)

DEF_INSTR(OP_FP_FRNDINT,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FRNDINT)

DEF_INSTR(OP_FP_FSCALE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSCALE)

DEF_INSTR(OP_FP_FSIN,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSIN)

DEF_INSTR(OP_FP_FCOS,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOS)

DEF_INSTR(OP_FP_FLD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD32)

DEF_INSTR(OP_FP_FST32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST32)

DEF_INSTR(OP_FP_FSTP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP32)

DEF_INSTR(OP_FP_FLDENV,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FLDENV)

DEF_INSTR(OP_FP_FLDCW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FLDCW)

DEF_INSTR(OP_FP_FNSTENV,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTENV)

DEF_INSTR(OP_FP_FNSTCW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTCW)

DEF_INSTR(OP_FP_FIADD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIADD32)

DEF_INSTR(OP_FP_FIMUL32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIMUL32)

DEF_INSTR(OP_FP_FICOM32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOM32)

DEF_INSTR(OP_FP_FICOMP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOMP32)

DEF_INSTR(OP_FP_FISUBR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUBR32)

DEF_INSTR(OP_FP_FISUBR16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUBR16)

DEF_INSTR(OP_FP_FIDIV32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIV32)

DEF_INSTR(OP_FP_FIDIVR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIVR32)

DEF_INSTR(OP_FP_FADD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD64)

DEF_INSTR(OP_FP_FMUL64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL64)

DEF_INSTR(OP_FP_FCOM64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOM64)

DEF_INSTR(OP_FP_FSUB64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB64)

DEF_INSTR(OP_FP_FSUBR64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR64)

DEF_INSTR(OP_FP_FDIV64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV64)

DEF_INSTR(OP_FP_FDIVR64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR64)

DEF_INSTR(OP_FP_FADD_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADD_STi_ST)

DEF_INSTR(OP_FP_FMUL_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMUL_STi_ST)

DEF_INSTR(OP_FP_FSUBR_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR_STi_ST)

DEF_INSTR(OP_FP_FSUB_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUB_STi_ST)

DEF_INSTR(OP_FP_FDIVR_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVR_STi_ST)

DEF_INSTR(OP_FP_FDIV_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIV_STi_ST)

DEF_INSTR(OP_FP_FFREE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FFREE)

DEF_INSTR(OP_FP_FXCH_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FXCH_STi)

DEF_INSTR(OP_FP_FST_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST_STi)

DEF_INSTR(OP_FP_FSTP_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP_STi)

DEF_INSTR(OP_FP_FUCOM,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOM)

DEF_INSTR(OP_FP_FUCOMP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOMP)

DEF_INSTR(OP_FP_FIADD16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIADD16)

DEF_INSTR(OP_FP_FIMUL16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIMUL16)

DEF_INSTR(OP_FP_FICOM16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOM16)

DEF_INSTR(OP_FP_FICOMP16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FICOMP16)

DEF_INSTR(OP_FP_FISUB16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUB16)

DEF_INSTR(OP_FP_FIDIV16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIV16)

DEF_INSTR(OP_FP_FIDIVR16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIDIVR16)

DEF_INSTR(OP_FP_FADDP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FADDP_STi_ST)

DEF_INSTR(OP_FP_FMULP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FMULP_STi_ST)

DEF_INSTR(OP_FP_FCOMPP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMPP)

DEF_INSTR(OP_FP_FSUBP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBP_STi_ST)

DEF_INSTR(OP_FP_FSUBRP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBRP_STi_ST)

DEF_INSTR(OP_FP_FDIVRP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVRP_STi_ST)

DEF_INSTR(OP_FP_FILD16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD16)

DEF_INSTR(OP_FP_FIST16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIST16)

DEF_INSTR(OP_FP_FBLD,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FBLD)

DEF_INSTR(OP_FP_FILD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD64)

DEF_INSTR(OP_FP_FBSTP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FBSTP)

DEF_INSTR(OP_FP_FLD80,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD80)

DEF_INSTR(OP_FP_FSTP80,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP80)

DEF_INSTR(OP_FP_FISUB32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISUB32)

DEF_INSTR(OP_FP_FCOMP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FCOMP64)

DEF_INSTR(OP_FP_FLD64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD64)

DEF_INSTR(OP_FP_FST64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FST64)

DEF_INSTR(OP_FP_FSTP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSTP64)

DEF_INSTR(OP_FP_FRSTOR,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FRSTOR)

DEF_INSTR(OP_FP_FNSAVE,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FNSAVE)

DEF_INSTR(OP_FP_FDIVP_STi_ST,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FDIVP_STi_ST)

DEF_INSTR(OP_FP_FISTP16,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP16)

DEF_INSTR(OP_FP_FISTP64,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP64)

DEF_INSTR(OP_FP_FLD_STi,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FLD_STi)

DEF_INSTR(OP_FP_FUCOMPP,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FUCOMPP)

DEF_INSTR(OP_FP_FILD32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FILD32)

DEF_INSTR(OP_FP_FIST32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FIST32)

DEF_INSTR(OP_FP_FISTP32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FISTP32)

DEF_INSTR(OP_FP_FNCLEX,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNCLEX)

DEF_INSTR(OP_FP_FNINIT,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNINIT)

DEF_INSTR(OP_FP_FNSTSW,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNSTSW)

DEF_INSTR(OP_FP_FSUBR32,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              FSUBR32)

DEF_INSTR(OP_FP_FNOP,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              FNOP)

DEF_INSTR(OP_CPUID,
              0, 0, GP_EAX|GP_EBX|GP_ECX|GP_EDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              CPUID)

DEF_INSTR(OP_SynchLockAdd32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag32)
DEF_INSTR(OP_SynchLockAdd16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag16)
DEF_INSTR(OP_SynchLockAdd8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAddFrag8)

DEF_INSTR(OP_SynchLockSub32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag32)
DEF_INSTR(OP_SynchLockSub16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag16)
DEF_INSTR(OP_SynchLockSub8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSubFrag8)

DEF_INSTR(OP_SynchLockNeg32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag32)
DEF_INSTR(OP_SynchLockNeg16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag16)
DEF_INSTR(OP_SynchLockNeg8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNegFrag8)

DEF_INSTR(OP_SynchLockInc32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag32)
DEF_INSTR(OP_SynchLockInc16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag16)
DEF_INSTR(OP_SynchLockInc8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockIncFrag8)

DEF_INSTR(OP_SynchLockDec32,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag32)
DEF_INSTR(OP_SynchLockDec16,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag16)
DEF_INSTR(OP_SynchLockDec8,
              0, FLAG_AUX|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockDecFrag8)

DEF_INSTR(OP_SynchLockAdc32,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag32)
DEF_INSTR(OP_SynchLockAdc16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag16)
DEF_INSTR(OP_SynchLockAdc8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAdcFrag8)

DEF_INSTR(OP_SynchLockSbb32,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag32)
DEF_INSTR(OP_SynchLockSbb16,
              FLAG_CF, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag16)
DEF_INSTR(OP_SynchLockSbb8,
              FLAG_CF, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockSbbFrag8)

DEF_INSTR(OP_SynchLockOr32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag32)
DEF_INSTR(OP_SynchLockOr16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag16)
DEF_INSTR(OP_SynchLockOr8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockOrFrag8)

DEF_INSTR(OP_SynchLockAnd32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag32)
DEF_INSTR(OP_SynchLockAnd16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag16)
DEF_INSTR(OP_SynchLockAnd8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockAndFrag8)

DEF_INSTR(OP_SynchLockXor32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag32)
DEF_INSTR(OP_SynchLockXor16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag16)
DEF_INSTR(OP_SynchLockXor8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXorFrag8)

DEF_INSTR(OP_SynchLockNot32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag32)
DEF_INSTR(OP_SynchLockNot16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag16)
DEF_INSTR(OP_SynchLockNot8,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockNotFrag8)

DEF_INSTR(OP_SynchLockBtsMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsMemFrag32)
DEF_INSTR(OP_SynchLockBtsMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsMemFrag16)

DEF_INSTR(OP_SynchLockBtrMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrMemFrag32)
DEF_INSTR(OP_SynchLockBtrMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrMemFrag16)

DEF_INSTR(OP_SynchLockBtcMem32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcMemFrag32)
DEF_INSTR(OP_SynchLockBtcMem16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcMemFrag16)

DEF_INSTR(OP_SynchLockBtsReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsRegFrag32)
DEF_INSTR(OP_SynchLockBtsReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtsRegFrag16)

DEF_INSTR(OP_SynchLockBtrReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrRegFrag32)
DEF_INSTR(OP_SynchLockBtrReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtrRegFrag16)

DEF_INSTR(OP_SynchLockBtcReg32,
              0, FLAG_CF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcRegFrag32)
DEF_INSTR(OP_SynchLockBtcReg16,
              0, FLAG_CF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockBtcRegFrag16)

DEF_INSTR(OP_SynchLockXchg32,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag32)
DEF_INSTR(OP_SynchLockXchg16,
              0, 0, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag16)
DEF_INSTR(OP_SynchLockXchg8,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXchgFrag8)

DEF_INSTR(OP_SynchLockXadd32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag32)
DEF_INSTR(OP_SynchLockXadd16,
              0, ALLFLAGS, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag16)
DEF_INSTR(OP_SynchLockXadd8,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockXaddFrag8)

DEF_INSTR(OP_SynchLockCmpXchg32,
              0, ALLFLAGS, REGEAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag32)
DEF_INSTR(OP_SynchLockCmpXchg16,
              0, ALLFLAGS, REGAX,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag16)
DEF_INSTR(OP_SynchLockCmpXchg8,
              0, ALLFLAGS, REGAL,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              SynchLockCmpXchgFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_SetupStack,
              0, ALLFLAGS, REGEBP|REGESP,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_SetupStackFrag)
DEF_INSTR(OP_OPT_SetupStackNoFlags,
              0, ALLFLAGS, REGEBP|REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_SetupStackNoFlagsFrag)

DEF_INSTR(OP_OPT_PushEbxEsiEdi,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_PushEbxEsiEdiFrag)

DEF_INSTR(OP_OPT_PopEdiEsiEbx,
              0, 0, REGESP|REGEBX|REGESI|REGEDI,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_PopEdiEsiEbxFrag)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_ZERO32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_ZEROFrag32)
DEF_INSTR(OP_OPT_ZERONoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_ZERONoFlagsFrag32)

DEF_INSTR(OP_OPT_FastTest32,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag32)
DEF_INSTR(OP_OPT_FastTest16,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag16)
DEF_INSTR(OP_OPT_FastTest8,
              0, FLAG_CF|FLAG_ZF|FLAG_SF|FLAG_OF|FLAG_PF, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FastTestFrag8)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CmpSbb32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CmpSbbFrag32)
DEF_INSTR(OP_OPT_CmpSbbNoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_CmpSbbNoFlagsFrag32)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CmpSbbNeg32,
              0, ALLFLAGS, 0,
              OPFL_HASNOFLAGS,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CmpSbbNegFrag32)
DEF_INSTR(OP_OPT_CmpSbbNegNoFlags32,
              0, ALLFLAGS, 0,
              0,
              FN_GenCallCFragNoCpu, FN_GenCallCFragNoCpuSlow,
              OPT_CmpSbbNegNoFlagsFrag32)

DEF_INSTR(OP_OPT_Push232,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_Push2Frag32)

DEF_INSTR(OP_OPT_Pop232,
              0, 0, REGESP,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_Pop2Frag32)

// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CwdIdiv32,
              0, 0, REGEAX|REGEDX,
              OPFL_ALIGN,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag32)
DEF_INSTR(OP_OPT_CwdIdiv32A,
              0, 0, REGEAX|REGEDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag32A)
// Next 2 must be consecutive
DEF_INSTR(OP_OPT_CwdIdiv16,
              0, 0, REGAX|REGDX,
              OPFL_ALIGN|OPFL_ADDR16,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag16)
DEF_INSTR(OP_OPT_CwdIdiv16A,
              0, 0, REGAX|REGDX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_CwdIdivFrag16A)

DEF_INSTR(OP_OPT_FNSTSWAxSahf,
              0, FLAG_CF|FLAG_PF|FLAG_AUX|FLAG_ZF|FLAG_SF, REGAX,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              OPT_FNSTSWAxSahf)

DEF_INSTR(OP_OPT_FSTP_ST0,
              0, 0, 0,
              0,
              FN_GenCallCFragLoadEip, FN_GenCallCFragLoadEipSlow,
              OPT_FSTP_ST0)

DEF_INSTR(OP_Rdtsc,
              0, 0, 0,
              0,
              FN_GenCallCFrag, FN_GenCallCFragSlow,
              Rdtsc)




// Undefine DEF_INSTR so this file can be included multiple times
#undef DEF_INSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\instr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    instr.h

Abstract:

    This module contains structures, enums and constants used to define the
    Intel instruction stream.

Author:

    Dave Hastings (daveh) creation-date 23-Jun-1995

Revision History:


--*/

#ifndef _INSTR_H_
#define _INSTR_H_

// We need the definitions of Entry Points for the instruction structure
#include "entrypt.h"

//
// This enumeration defines all of the possible operations.
//  N.B.  It is also used to find the fragment corresponding to the
//        operation.
//
typedef enum _Operation {
    #define DEF_INSTR(OpName, FlagsNeeded, FlagsSet, RegsSet, Opfl, FastPlaceFn, SlowPlaceFn, FragName)   OpName,
    #include "idata.h"
    OP_MAX      
} OPERATION, *POPERATION;

typedef enum _PlaceFn {
    #define DEF_PLACEFN(Name) FN_ ## Name,
    #include "fndata.h"
    FN_MAX
} PLACEFN;


typedef struct _Operand {
    enum {
        OPND_NONE = 0,
        OPND_NOCODEGEN,
        OPND_REGREF,
        OPND_REGVALUE,
        OPND_ADDRREF,
        OPND_ADDRVALUE32,
        OPND_ADDRVALUE16,
        OPND_ADDRVALUE8,
        OPND_IMM,
        OPND_MOVTOREG,
        OPND_MOVREGTOREG,
        OPND_MOVTOMEM,
    } Type;
    ULONG Immed;
    ULONG Reg;
    ULONG Scale;
    ULONG IndexReg;
    ULONG Alignment;
} OPERAND, *POPERAND;

typedef struct _Instruction {
    OPERATION Operation;
    OPERAND Operand1;
    OPERAND Operand2;
    OPERAND Operand3;
    ULONG FsOverride;
    ULONG Size;
    PCHAR NativeStart;
    ULONG IntelAddress;
    DWORD RegsSet;
    DWORD RegsNeeded;
    DWORD RegsToCache;
    BOOL EbpAligned;
    PENTRYPOINT EntryPoint;

} INSTRUCTION, *PINSTRUCTION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\mrsw.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mrsw.h

Abstract:

    This is the include file for the multiple reader single writer
    syncronization.

Author:

    Dave Hastings (daveh) creation-date 26-Jul-1995

Revision History:


--*/

#ifndef _MRSW_H_
#define _MRSW_H_

typedef union {
    DWORD Counters;
    struct {
        DWORD WriterCount : 16;
        DWORD ReaderCount : 16;
    };
} MRSWCOUNTERS, *PMRSWCOUNTERS;

typedef struct _MrswObject {
    MRSWCOUNTERS Counters;
    HANDLE WriterEvent;
    HANDLE ReaderEvent;
#if DBG
    DWORD  WriterThreadId;
#endif
} MRSWOBJECT, *PMRSWOBJECT;

BOOL
MrswInitializeObject(
    PMRSWOBJECT Mrsw
    );

VOID
MrswWriterEnter(
    PMRSWOBJECT Mrsw
    );

VOID
MrswWriterExit(
    PMRSWOBJECT Mrsw
    );
    
VOID
MrswReaderEnter(
    PMRSWOBJECT Mrsw
    );

VOID
MrswReaderExit(
    PMRSWOBJECT Mrsw
    );

extern MRSWOBJECT MrswEP; // Entrypoint MRSW synchronization object
extern MRSWOBJECT MrswTC; // Translation cache MRSW synchronization object
extern MRSWOBJECT MrswIndirTable; // Indirect Control Transfer Table synchronization object

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\tc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tc.h

Abstract:

    This include file defines the Translation Cache interface.

Author:

    Barry Bond (barrybo) creation-date 29-Jul-1995

Revision History:


--*/

#ifndef _TC_H_
#define _TC_H_

extern ULONG TranslationCacheTimestamp;
extern DWORD TranslationCacheFlags;

BOOL
InitializeTranslationCache(
    VOID
    );

PCHAR
AllocateTranslationCache(
    ULONG Size
    );

VOID
FreeUnusedTranslationCache(
    PCHAR StartOfFree
    );

VOID
PauseAllActiveTCReaders(
    VOID
    );

VOID
FlushTranslationCache(
    PVOID IntelAddr,
    DWORD IntelLength
    );

BOOL
AddressInTranslationCache(
    DWORD Addr
    );

#if DBG
    VOID
    ASSERTPtrInTC(
        PVOID ptr
    );

    #define ASSERTPtrInTCOrZero(ptr) {          \
        if (ptr) {                              \
            ASSERTPtrInTC(ptr);                 \
        }                                       \
    }


#else
    #define ASSERTPtrInTC(ptr)
    #define ASSERTPtrInTCOrZero(ptr)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\threadst.h ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    threadst.h

Abstract:

    This module defines the structures and constant for describing a
    thread's state.
    

Author:

    Dave Hastings (daveh) creation-date 20-May-1995

Revision History:


--*/

#ifndef _THREADST_H_
#define _THREADST_H_

#define EIPLOGSIZE  32    // keep track of the last N instructions run

#define CSSIZE  512       // Size of call stack (512*8 = 2048 bytes = 1 page)

typedef union _REG32 {    // definition of a 32-bit x86 register
    struct {
	BYTE i1;
	BYTE hb;
    };
    USHORT i2;
    ULONG  i4;
} REG32;

#if defined(_ALPHA_)
typedef DWORD FPTAG;        // bytes are too slow on AXP
#else
typedef BYTE  FPTAG;
#endif

typedef struct _FPREG {     // definition of an x86 floating-point register
    union {
        double  r64;
        DWORD   rdw[2];
        BYTE    rb[8];
    };
    FPTAG   Tag;
    FPTAG   TagSpecial;
} FPREG, *PFPREG;

//
// CALLSTACK is an optimization for CALL/RET pairs, so that an expensive
// NativeAddressFromEip() call can be avoided when determining the RISC
// address of an x86 return address.
//
typedef struct _callStack {
    ULONG intelAddr;
    ULONG nativeAddr;
} CALLSTACK, *PCALLSTACK;

// Indices into CPUSTATE.Regs[].  get_reg32() depends on EAX through
// EDI being contiguous and ordered the same as they are in the mod/rm and
// reg instruction encodings (ie. EAX=0,ECX=1,EDX=2,EBX=3,ESP=4,EBP=5,ESI=6,
// EDI=7)
#define GP_EAX  0x00
#define GP_ECX  0x01
#define GP_EDX  0x02
#define GP_EBX  0x03
#define GP_ESP  0x04
#define GP_EBP  0x05
#define GP_ESI  0x06
#define GP_EDI  0x07

// Segment registers.  get_segreg() depends on the order.
#define REG_ES  0x08
#define REG_CS  0x09
#define REG_SS  0x0a
#define REG_DS  0x0b
#define REG_FS  0x0c
#define REG_GS  0x0d


// Identifiers for components of registers.  get_reg16() depends on the order.
#define GP_AX   0x0e
#define GP_CX   0x0f
#define GP_DX   0x10
#define GP_BX   0x11
#define GP_SP   0x12
#define GP_BP   0x13
#define GP_SI   0x14
#define GP_DI   0x15

// PlaceOperandFragments() depends on GP_AH and beyond, and that no registers
// are past GP_BH.
#define GP_AL   0x16
#define GP_CL   0x17
#define GP_DL   0x18
#define GP_BL   0x19
#define GP_AH   0x1a
#define GP_CH   0x1b
#define GP_DH   0x1c
#define GP_BH   0x1d

#define NO_REG  0xffffffff

typedef struct _CPU_SUSPEND_MSG
{
    // Owned by local thread 
    HANDLE StartSuspendCallEvent;
    HANDLE EndSuspendCallEvent;

} CPU_SUSPEND_MSG, *PCPU_SUSPEND_MSG;

// all information related to a particular thread of the CPU belongs here
typedef struct _ThreadState {

    //
    // General-purpose and segment registers
    // accessible as an array of REG32 or by Register Name
    // NOTE: the name orders must match the GP_XXX defines for registers
    //
    union {
        REG32 GpRegs[14];
        struct _RegisterByName {
            REG32 Eax;
            REG32 Ecx;
            REG32 Edx;
            REG32 Ebx;
            REG32 Esp;
            REG32 Ebp;
            REG32 Esi;
            REG32 Edi;
            REG32 Es;
            REG32 Cs;
            REG32 Ss;
            REG32 Ds;
            REG32 Fs;
            REG32 Gs;
            };
        };

    REG32 eipReg;       // Pointer to start of current instruction (never
			//  points into the middle of an instruction)

    DWORD   flag_cf;    // 0 = carry
    DWORD   flag_pf;    // 2 = parity
    DWORD   flag_aux;   // 4 = aux carry
    DWORD   flag_zf;    // 6 = zero
    DWORD   flag_sf;    // 7 = sign
    DWORD   flag_tf;    // 8 = trap
    DWORD   flag_if;    // 9 = interrupt enable
    DWORD   flag_df;    // 10 = direction   (1 = clear, -1 = set)
    DWORD   flag_of;    // 11 = overflow
    DWORD   flag_nt;    // 14 = nested task
    DWORD   flag_rf;    // 16 = resume flag
    DWORD   flag_vm;    // 17 = virtual mode
    DWORD   flag_ac;    // 18 = alignment check

    // Floating-point registers
    FPREG  FpStack[8];
    PFPREG FpST0;
    INT    FpTop;
    INT    FpStatusC3;
    INT    FpStatusC2;
    INT    FpStatusC1;
    INT    FpStatusC0;
    INT    FpStatusSF;
    INT    FpStatusES;      // Error Summary Status
    INT    FpControlInfinity;
    INT    FpControlRounding;
    INT    FpControlPrecision;
    DWORD  FpStatusExceptions;
    DWORD  FpControlMask;
    DWORD  FpEip;           // EIP for the current FP instruction
    PVOID  FpData;          // Effective address for current FP instruction
    PVOID  FpAddTable;      // ptr to table of function pointers for FADD
    PVOID  FpSubTable;      // ptr to table of function pointers for FSUB
    PVOID  FpMulTable;      // ptr to table of function pointers for FMUL
    PVOID  FpDivTable;      // ptr to table of function pointers for FDIV

    ULONG CpuNotify;

    PVOID TraceAddress; // Used by debugger extensions

    DWORD  fTCUnlocked;     // FALSE means TC must be unlocked after exception

    // SuspendThread/ResumeThread support
    PCPU_SUSPEND_MSG SuspendMsg;

    int   eipLogIndex;  // Index of next entry to write into in the log
    DWORD eipLog[EIPLOGSIZE]; // log of last EIPLOGSIZE instructions run

    ULONG CSIndex;    // Index into the stack (offset of current location)
    DWORD CSTimestamp;// Value of TranslationCacheTimestamp corresponding to the callstack cache
    CALLSTACK callStack[CSSIZE];    // callstack optimization

    int ErrnoVal;           // CRT errno value

    DWORD   flag_id;    // 21 = ID (CPUID present if this can be toggled)

}  THREADSTATE, *PTHREADSTATE, CPUCONTEXT, *PCPUCONTEXT;

// Bit offsets in cpu->FpControlMask.  Same as the x86 bit positions
#define FPCONTROL_IM    1       // Invalid operation
#define FPCONTROL_DM    2       // Denormalized operation
#define FPCONTROL_ZM    4       // Zero divide
#define FPCONTROL_OM    8       // Overflow
#define FPCONTROL_UM    16      // Underflow
#define FPCONTROL_PM    32      // Precision

// This macro allows one to access the cpu state via the local variable cpu
#define DECLARE_CPU                                         \
    PCPUCONTEXT cpu=(PCPUCONTEXT)Wow64TlsGetValue(WOW64_TLS_CPURESERVED);

//
// The following macros allow one to push and pop values from the
// call stack
//

#define ISTOPOF_CALLSTACK(iAddr)                            \
    (cpu->callStack[(cpu->CSIndex)].intelAddr == iAddr)

#define PUSH_CALLSTACK(iAddr,nAddr)                         \
{                                                           \
    PCALLSTACK pCallStack;                                  \
                                                            \
    cpu->CSIndex = (cpu->CSIndex+1) % CSSIZE;               \
    pCallStack = &cpu->callStack[cpu->CSIndex];             \
    pCallStack->intelAddr = iAddr;                          \
    pCallStack->nativeAddr = nAddr;                         \
}

#define POP_CALLSTACK(iAddr,nAddr)                          \
{                                                           \
    PCALLSTACK pCallStack;                                  \
    extern ULONG TranslationCacheTimestamp;                 \
                                                            \
    CPUASSERTMSG(                                           \
        (cpu->CSTimestamp == TranslationCacheTimestamp),    \
        "POP_CALLSTACK: About to return and invalid value\n"\
        );                                                  \
                                                            \
    pCallStack = &cpu->callStack[cpu->CSIndex];             \
    if (iAddr == pCallStack->intelAddr) {                   \
        nAddr = pCallStack->nativeAddr;                     \
    } else {                                                \
        nAddr = 0;                                          \
    }                                                       \
    cpu->CSIndex = (cpu->CSIndex-1) % CSSIZE;               \
}

PCPUCONTEXT GetCpuContext ();  //has been implemented in wowproxy

NTSTATUS
CpupSuspendCurrentThread(
    VOID);


#endif  //_THREADST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\ppcreg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ppcreg.h

Abstract:

    This file establishes the mapping between the traditional NT register
    names and the PPC register names.  This really should have been in
    kxppc.h.  

Author:

    Dave Hastings (daveh) creation-date 13-Sep-1995

Revision History:


--*/

#define sp   r1                         // stack pointer
#define a0   r3                         // argument registers
#define a1   r4                         //
#define a2   r5                         //
#define a3   r6                         //
#define a4   r7                         //
#define a5   r8                         //
#define a6   r9                         //
#define a7   r10                        //
#define v0   r3                         // function return value
#define TebReg r13                        // Callee saved registers
#define s0   r14                        // 
#define s1   r15                        // 
#define s2   r16                        // 
#define s3   r17                        // 
#define s4   r18                        // 
#define s5   r19                        // 
#define s6   r20                        // 
#define s7   r21                        // 
#define s8   r22                        // 
#define s9   r23                        // 
#define s10  r24                        // 
#define s11  r25                        // 
#define s12  r26                        // 
#define s13  r27                        // 
#define s14  r28                        // 
#define s15  r29                        // 
#define s16  r30                        // 
#define s18  r31                        //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\wx86cpu.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wx86cpu.h

Abstract:

    Defines the functions exported from the CPU DLL.

Author:

    22-Aug-1995 BarryBo, Created

Revision History:

--*/

#ifndef _WX86CPU_
#define _WX86CPU_

#if !defined(_WX86CPUAPI_)
#define WX86CPUAPI DECLSPEC_IMPORT
#else
#define WX86CPUAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif



#define WX86CPU_UNSIMULATE             STATUS_WX86_UNSIMULATE
#define WX86CPU_CONTINUE               STATUS_WX86_CONTINUE
#define WX86CPU_SINGLE_STEP            STATUS_WX86_SINGLE_STEP
#define WX86CPU_BREAKPOINT             STATUS_WX86_BREAKPOINT


//
// Values used by the wx86e debugger extension to determine the CPU type
//
typedef enum _Wx86CpuType {
   Wx86CpuUnknown,
   Wx86CpuCcpu386,
   Wx86CpuCcpu,
   Wx86CpuCpu,
   Wx86CpuFx32,
   Wx86CpuOther
} WX86_CPUTYPE, *PWX86_CPUTYPE;

typedef struct Wx86CpuHint {
    DWORD Hint;
    DWORD_PTR Hint2;
} WX86_CPUHINT, *PWX86_CPUHINT;

#if !defined(__WOW64_WRAPPER__)
//
// Initialization and Termination routines
//


WX86CPUAPI BOOL CpuProcessTerm(BOOL OFlyInit);

//
// Cache manipulation functions
//
WX86CPUAPI VOID CpuFlushInstructionCache(PVOID BaseAddress, DWORD Length);
//WX86CPUAPI BOOLEAN CpuMapNotify(PVOID DllBase, BOOLEAN Mapped); moved down
WX86CPUAPI VOID CpuEnterIdle(BOOL fOFly);

//
// CPU feature set information
//
WX86CPUAPI BOOL CpuIsProcessorFeaturePresent(DWORD ProcessorFeature);

//
// Public Functions to get and set individual registers
// are defined in Wx86.h
//


//
// Functions for exception handling
//


WX86CPUAPI VOID MsCpuResetToConsistentState(PEXCEPTION_POINTERS pExecptionPointers);
WX86CPUAPI VOID CpuPrepareToContinue(PEXCEPTION_POINTERS pExecptionPointers);

//
// Functions for process/thread manipulation
//
WX86CPUAPI VOID  CpuStallExecutionInThisProcess(VOID);
WX86CPUAPI VOID  CpuResumeExecutionInThisProcess(VOID);
WX86CPUAPI DWORD CpuGetThreadContext(HANDLE hThread, PVOID CpuContext, PCONTEXT_WX86 Context);
WX86CPUAPI DWORD CpuSetThreadContext(HANDLE hThread, PVOID CpuContext, PCONTEXT_WX86 Context);

#endif //__WOW64_WRAPPER__
WX86CPUAPI BOOLEAN CpuMapNotify(PVOID DllBase, BOOLEAN Mapped);
WX86CPUAPI NTSTATUS MsCpuProcessInit(VOID);
WX86CPUAPI BOOL MsCpuThreadInit(VOID);
WX86CPUAPI VOID MsCpuSimulate(PWX86_CPUHINT);

WX86CPUAPI
NTSTATUS
MsCpuSetContext(
    PCONTEXT_WX86 Context);

NTSTATUS
MsCpuSetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context);

WX86CPUAPI 
NTSTATUS 
MsCpuGetContext(
    IN OUT PCONTEXT_WX86 Context);

WX86CPUAPI 
NTSTATUS
MsCpuGetContextThread(
    IN HANDLE ProcessHandle,
    IN PTEB Teb,
    IN OUT PCONTEXT_WX86 Context);



#ifdef __cplusplus
} // extern "C"
#endif

#endif  //_WX86CPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\inc\wx86.h ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    wx86.h

Abstract:

    Public exports, defines for wx86.dll

Author:

    10-Jan-1995 Jonle,Created

Revision History:

    24-Aug-1999 [askhalid] isolated some definition from wow64 
                and define some proxy and wrapper functions.

--*/

#include <wow64.h>

#if !defined(_WX86CPUAPI_)
#define WX86CPUAPI DECLSPEC_IMPORT
#else
#define WX86CPUAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _ConfigVariable {
   LIST_ENTRY ConfigEntry;
   DWORD      Data;
   UNICODE_STRING Name;
   WCHAR      Buffer[1];
} CONFIGVAR, *PCONFIGVAR;

PCONFIGVAR
Wx86FetchConfigVar(
   PWSTR VariableName
   );

VOID
Wx86RaiseStatus(
    NTSTATUS Status
    );

void
Wx86RaiseInterrupt(
    ULONG IntNum,
    ULONG EipVal,
    ULONG EspVal,
    BOOL  bParameter,
    ULONG Parameter
    );

VOID
Wx86FreeConfigVar(
   PCONFIGVAR ConfigVar
   );


#define BOPFL_ENDCODE  0x01
typedef struct _BopInstr {
    BYTE    Instr1;         // 0xc4c4 - the x86 BOP instruction
    BYTE    Instr2;
    BYTE    BopNum;
    BYTE    Flags;
    USHORT  ApiNum;
    BYTE    RetSize;
    BYTE    ArgSize;
} BOPINSTR;
typedef UNALIGNED BOPINSTR * PBOPINSTR;


void
Wx86DispatchBop(
    PBOPINSTR Bop
    );

/////////////////////////////////

#define ProxyGetCurrentThreadId()       \
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)

#define ProxyDebugBreak()               \
            DbgBreakPoint()

BOOL ProxyIsProcessorFeaturePresent (DWORD feature);

VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    );

WX86CPUAPI DWORD GetEdi(PVOID CpuContext);
WX86CPUAPI VOID SetEdx(PVOID CpuContext, DWORD val);
WX86CPUAPI VOID SetEdi(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEfl(PVOID CpuContext);
WX86CPUAPI VOID SetEfl(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEsp(PVOID CpuContext);
WX86CPUAPI VOID SetEip(PVOID CpuContext, DWORD val);
WX86CPUAPI VOID SetEsp(PVOID CpuContext, DWORD val);
WX86CPUAPI DWORD GetEip(PVOID CpuContext);
DWORD ProxyWowDispatchBop( 
    ULONG ServiceNumber,
    PVOID Context32,
    PULONG ArgBase
    );

double Proxylog10( double x );
double Proxyatan2( double y, double x );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\ieeemisc.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    ieeemisc.c 

Abstract:
    
    IEEE miscellaneous recommended functions
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

 

#include <trans.h>
#include <math.h>
#include <float.h>


/***
* _copysign - copy sign
*
*Purpose:
*   copysign(x,y) returns x with the sign of y. Hence, abs(x) := copysign
*   even if x is NaN [IEEE std 854-1987 Appendix]
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if one of the arguments is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _copysign (double x, double y)
{
    double retval;
    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1<<31) |
            *D_HI(y) &  (1<<31) ;

    return retval;
}



/***
* _chgsign - change sign
*
*Purpose:
*  x is copied with its sign reversed, not 0-x; the distinction is germane
*  when x is +0, -0, or NaN
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if x is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _chgsign (double x)
{
    double retval;

    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1 << 31)  |
            ~*D_HI(x) & (1<<31);

    return retval;
}


/***
* _scalb - scale by power of 2
*
*Purpose:
*   _scalb(x,n) returns x * 2^n for integral values of n without
*   computing 2^n
*   Special case:
*      If x is infinity or zero, _scaleb returns x
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Overflow, Underflow
*
*******************************************************************************/

double _scalb(double x, long n)
{
    //
    // It turns out that our implementation of ldexp matces the IEEE
    // description of _scalb. The only problem with calling ldexp
    // is that if an exception occurs, the operation code reported
    // to the handler will be the one that corresponds to ldexp
    // (i.e., we do not define a new operation code for _scalb
    //

    return ldexp(x,n);
}




/***
* _logb - extract exponent
*
*Purpose:
*   _logb(x) returns the unbiased exponent of x, a signed integer in the
*   format of x, except that logb(NaN) is a NaN, logb(+INF) is +INF,and
*   logb(0) is is -INF and signals the division by zero exception.
*   For x positive and finite, 1<= abs(scalb(x, -logb(x))) < 2
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Division by zero
*
*******************************************************************************/
double _logb(double x)
{
    unsigned int savedcw;
    int exp;
    double retval;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        RETURN(savedcw, x);
    case T_QNAN:
        return _handle_qnan1(OP_LOGB, x, savedcw);
    default: //T_SNAN
        return _except1(FP_I, OP_LOGB, x, _s2qnan(x), savedcw);
    }
    }

    if (x == 0) {
     return _except1(FP_Z, OP_LOGB, x, -D_INF, savedcw);
    }

    (void) _decomp(x, &exp);

    //
    // x == man * 2^exp, where .5 <= man < 1. According to the spec
    // of this function, we should compute the exponent so that
    // 1<=man<2, i.e., we should decrement the computed exp by one
    //

    retval = (double) (exp - 1);

    RETURN(savedcw, retval);

}





/***
* _nextafter - next representable neighbor
*
*Purpose:
*  _nextafter(x,y) returns the next representable neighbor of x in
*  the direction toward y. The following special cases arise: if
*  x=y, then the result is x without any exception being signaled;
*  otherwise, if either x or y is a quiet NaN, then the result is
*  one or the other of the input NaNs. Overflow is sibnaled when x
*  is finite but nextafter(x,y) is infinite; underflow is signaled
*  when nextafter(x,y) lies strictly between -2^Emin, 2^Emin; in
*  both cases, inexact is signaled.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   O, U, I, P
*
*******************************************************************************/

double _nextafter(double x, double y)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
    if (IS_D_SNAN(x) || IS_D_SNAN(y)){
        return _except2(FP_I,OP_NEXTAFTER,x,y,_d_snan2(x,y),savedcw);
    }
    if (IS_D_QNAN(x) || IS_D_QNAN(y)){
        return _handle_qnan2(OP_NEXTAFTER,x,y,savedcw);
    }

    //
    // infinite arguments are not treated as special cases
    //
    }

    if (y == x) {

    //
    // no exceptions are raised in this case
    //

    RETURN(savedcw, x);
    }

    if (x == 0) {

    *D_LO(result) = 1;

    if (y > x) {
        *D_HI(result) = 0;
    }

    else {

        //
        // result should be negative
        //

        *D_HI(result) = (unsigned long)(1<<31);
    }

    }


    //
    // At this point x!=y, and x!=0. x can be treated as a 64bit
    // integer in sign/magnitude representation. To get the next
    // representable neighbor we add or subtract one from this
    // integer. (Note that for boundary cases like x==INF, need to
    // add one will never occur --this would mean that y should
    // be greater than INF, which is impossible)
    //

    if (x > 0 && y < x ||
    x < 0 && y > x) {

    //
    // decrease value by one
    //

    *D_LO(result) = *D_LO(x) - 1;
    *D_HI(result) = *D_HI(x);

    if (*D_LO(x) == 0) {

        //
        // a borrow should propagate to the high order dword
        //

        (*D_HI(result)) --;
    }
    }

    else if (x > 0 && y > x ||
         x < 0 && y < x) {

    //
    // increase value by one
    //

    *D_LO(result) = *D_LO(x) + 1;
    *D_HI(result) = *D_HI(x);

    if (*D_LO(result) == 0) {

        //
        // a carry should propagate to the high order dword
        //

        (*D_HI(result)) ++;
    }
    }


    //
    // check if an exception should be raised
    //


    if ( IS_D_DENORM(result) ) {

    //
    // should signal underflow and inexact
    // and provide a properly scaled value
    //

    double mant;
    int exp;

    mant = _decomp(result, &exp);
    result = _set_exp(mant, exp+IEEE_ADJUST);

    return _except2(FP_U|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }



    if ( IS_D_INF(result) || IS_D_MINF(result) ) {

    //
    // should signal overflow and inexact
    // and provide a properly scaled value
    //

    double mant;
    int exp;

    mant = _decomp(result, &exp);
    result = _set_exp(mant, exp-IEEE_ADJUST);

    return _except2(FP_O|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }


    RETURN(savedcw, result);
}




/***
* _finite -
*
*Purpose:
*   finite(x) returns the value TRUE if -INF < x < +INF and returns
*   false otherwise [IEEE std]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _finite(double x)
{
    if (IS_D_SPECIAL(x)) {

    //
    // x is INF or NaN
    //

    return 0;
    }
    return 1;
}





/***
* _isnan -
*
*Purpose:
*   isnan(x) returns the value TRUE if x is a NaN, and returns FALSE
*   otherwise.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
    return 1;
    }
    return 0;
}




/***
*double _fpclass(double x) - floating point class
*
*Purpose:
*   Compute the floating point class of a number, according
*   to the recommendations of the IEEE std. 754
*
*Entry:
*
*Exit:
*
*Exceptions:
*   This function is never exceptional, even when the argument is SNAN
*
*******************************************************************************/

int _fpclass(double x)
{
    int sign;

    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
        return _FPCLASS_PINF;
    case T_NINF:
        return _FPCLASS_NINF;
    case T_QNAN:
        return _FPCLASS_QNAN;
    default: //T_SNAN
        return _FPCLASS_SNAN;
    }
    }
    sign = (*D_EXP(x)) & 0x8000;

    if (IS_D_DENORM(x))
    return sign? _FPCLASS_ND : _FPCLASS_PD;

    if (x == 0.0)
    return sign? _FPCLASS_NZ : _FPCLASS_PZ;

    return sign? _FPCLASS_NN : _FPCLASS_PN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\fpexcept.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    fpexcept.c

Abstract:
    
    This module handle boundary conditions while doing math operation. 
    Need to reimplement or remove if not required.
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/



#if defined(_NTSUBSET_) || defined (_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _KERNEL32_          // Don't Export RaiseException
#endif  // _NTSUBSET_

#define DEFINE_EXTERN_HERE
#include <trans.h>
#undef DEFINE_EXTERN_HERE
#include <errno.h>
#include <math.h>
#include <windows.h>

VOID ProxyRaiseException(
    IN DWORD dwExceptionCode,
    IN DWORD dwExceptionFlags,
    IN DWORD nNumberOfArguments,
    IN CONST ULONG_PTR *lpArguments
    );

//
// copy a double without generating floating point instructions
// (avoid invalid operation on x87)
//

#define COPY_DOUBLE(pdest, psrc) \
      ( *(unsigned int *)pdest = *(unsigned int *)psrc,   \
        *((unsigned int *)pdest+1) = *((unsigned int *)psrc+1) )



//
// _matherr_flag is a communal variable. It is equal to zero
// if the user has redefined matherr(). Otherwise it has a
// non zero value. The default matherr routine does nothing
// and returns 0.
//

int _matherr_flag;

//
// a routine for artificially setting the fp status bits in order
// to signal a software generated masked fp exception.
//

extern void _set_statfp(unsigned int);


void _raise_exc(_FPIEEE_RECORD *prec,unsigned int *pcw,
    int flags, int opcode, double *parg1, double *presult);

double _umatherr(int type, unsigned int opcode,
                 double arg1, double arg2, double presult,
                 unsigned int cw);

static char *_get_fname(unsigned int opcode);

/***
* _handle_qnan1, _handle_qnan2 - handle quiet NaNs as function arguments
*
*Purpose:
*   Do all necessary work for handling the case where the argument
*   or one of the arguments of a floating point function is a quiet NaN
*
*Entry:
*   unsigned int opcode: The operation code of the fp function
*   double x: the fp function argument
*   double y: the fp function second argument (_handle_qnan2 only)
*   unsigned int savedcw: the user's control word
*
*Exit:
*   restore the user's control word,  and
*   return the suggested return value for the fp function
*
*Exceptions:
*
*******************************************************************************/

double _handle_qnan1(unsigned int opcode,
                     double x,
                     unsigned int savedcw)
{
    if (! _matherr_flag) {

        //
        // QNaN arguments are treated as domain errors
        // invoke the user's matherr routine
        // _umatherr will take care of restoring the
        // user's control word
        //

        return _umatherr(_DOMAIN,opcode,x,0.0,x,savedcw);
    }
    else {
        SetMathError ( EDOM );
        _rstorfp(savedcw);
        return x;
    }
}


double _handle_qnan2(unsigned int opcode,
                     double x,
                     double y,
                     unsigned int savedcw)
{
    double result;

    //
    // NaN propagation should be handled by the underlying fp h/w
    //

    result = x+y;

    if (! _matherr_flag) {
        return _umatherr(_DOMAIN,opcode,x,y,result,savedcw);
    }
    else {
        SetMathError ( EDOM );
        _rstorfp(savedcw);
        return result;
    }
}



/***
* _except1 - exception handling shell for fp functions with one argument
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg: the argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except1(int flags,
                int opcode,
                double arg,
                double result,
                unsigned int cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // At this point _handle_exception has failed to deal
        // with the error
        // An IEEE exception should be raised
        //

        _FPIEEE_RECORD rec;

        // The rec structure will be filled in by _raise_exc,
        // except for the Operand2 information

        rec.Operand2.OperandValid = 0;
        _raise_exc(&rec, &cw, flags, opcode, &arg, &result);
    }


    //
    // At this point we have either the masked response of the
    // exception, or a value supplied by the user's IEEE exception
    // handler. The _matherr mechanism is supported for backward
    // compatibility.
    //

    type = _errcode(flags);

    // Inexact result fp exception does not have a matherr counterpart;
    // in that case type is 0.

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg, 0.0, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _except2 - exception handling shell for fp functions with two arguments
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg1: the first argument of the fp function
*   double arg2: the second argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except2(int flags,
                int opcode,
                double arg1,
                double arg2,
                double result,
                unsigned int cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // trap should be taken
        //

        _FPIEEE_RECORD rec;

        //
        // fill in operand2 info. The rest of rec will be
        // filled in by _raise_exc
        //

        rec.Operand2.OperandValid = 1;
        rec.Operand2.Format = _FpFormatFp64;
        rec.Operand2.Value.Fp64Value = arg2;

        _raise_exc(&rec, &cw, flags, opcode, &arg1, &result);

    }

    type = _errcode(flags);

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg1, arg2, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _raise_exc - raise fp IEEE exception
*
*Purpose:
*   fill in an fp IEEE record struct and raise a fp exception
*
*
*Entry / Exit:
*   IN _FPIEEE_RECORD prec   pointer to an IEEE record
*   IN OUT unsigned int *pcw     pointer to user's fp control word
*   IN int flags,       exception flags
*   IN int opcode,      fp operation code
*   IN double *parg1,        pointer to first argument
*   IN double *presult)      pointer to result
*
*Exceptions:
*
*******************************************************************************/

void _raise_exc( _FPIEEE_RECORD *prec,
                 unsigned int *pcw,
                 int flags,
                 int opcode,
                 double *parg1,
                 double *presult)
{
    DWORD exc_code;
    unsigned int sw;

    //
    // reset all control bits
    //

    *(int *)&(prec->Cause) = 0;
    *(int *)&(prec->Enable) = 0;
    *(int *)&(prec->Status) = 0;

    //
    // Precision exception may only coincide with overflow
    // or underflow. If this is the case, overflow (or
    // underflow) take priority over precision exception.
    // The order of checks is from the least important
    // to the most important exception
    //

    if (flags & FP_P) {
        exc_code = (DWORD) STATUS_FLOAT_INEXACT_RESULT;
        prec->Cause.Inexact = 1;
    }
    if (flags & FP_U) {
        exc_code = (DWORD) STATUS_FLOAT_UNDERFLOW;
        prec->Cause.Underflow = 1;
    }
    if (flags & FP_O) {
        exc_code = (DWORD) STATUS_FLOAT_OVERFLOW;
        prec->Cause.Overflow = 1;
    }
    if (flags & FP_Z) {
        exc_code = (DWORD) STATUS_FLOAT_DIVIDE_BY_ZERO;
        prec->Cause.ZeroDivide = 1;
    }
    if (flags & FP_I) {
        exc_code = (DWORD) STATUS_FLOAT_INVALID_OPERATION;
        prec->Cause.InvalidOperation = 1;
    }


    //
    // Set exception enable bits
    //

    prec->Enable.InvalidOperation = (*pcw & IEM_INVALID) ? 0 : 1;
    prec->Enable.ZeroDivide = (*pcw & IEM_ZERODIVIDE) ? 0 : 1;
    prec->Enable.Overflow = (*pcw & IEM_OVERFLOW) ? 0 : 1;
    prec->Enable.Underflow = (*pcw & IEM_UNDERFLOW) ? 0 : 1;
    prec->Enable.Inexact = (*pcw & IEM_INEXACT) ? 0 : 1;


    //
    // Set status bits
    //

    sw = _statfp();


    if (sw & ISW_INVALID) {
        prec->Status.InvalidOperation = 1;
    }
    if (sw & ISW_ZERODIVIDE) {
        prec->Status.ZeroDivide = 1;
    }
    if (sw & ISW_OVERFLOW) {
        prec->Status.Overflow = 1;
    }
    if (sw & ISW_UNDERFLOW) {
        prec->Status.Underflow = 1;
    }
    if (sw & ISW_INEXACT) {
        prec->Status.Inexact = 1;
    }


    switch (*pcw & IMCW_RC) {
    case IRC_CHOP:
        prec->RoundingMode = _FpRoundChopped;
        break;
    case IRC_UP:
        prec->RoundingMode = _FpRoundPlusInfinity;
        break;
    case IRC_DOWN:
        prec->RoundingMode = _FpRoundMinusInfinity;
        break;
    case IRC_NEAR:
        prec->RoundingMode = _FpRoundNearest;
        break;
    }

#ifdef _M_IX86

    switch (*pcw & IMCW_PC) {
    case IPC_64:
        prec->Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        prec->Precision = _FpPrecision53;
        break;
    case IPC_24:
        prec->Precision = _FpPrecision24;
        break;
    }

#endif


#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
    prec->Precision = _FpPrecision53;
#endif

    prec->Operation = opcode;

    prec->Operand1.OperandValid = 1;
    prec->Operand1.Format = _FpFormatFp64;
    prec->Operand1.Value.Fp64Value = *parg1;

    prec->Result.OperandValid = 1;
    prec->Result.Format = _FpFormatFp64;
    prec->Result.Value.Fp64Value = *presult;

    //
    // By convention software exceptions use the first exception
    // parameter in order to pass a pointer to the _FPIEEE_RECORD
    // structure.
    //

    _clrfp();

    
    ProxyRaiseException(exc_code,0,1,(CONST ULONG_PTR *)&prec);


    //
    // user's trap handler may have changed either the fp environment
    // or the result
    //

    //
    // Update exception mask
    //

    if (prec->Enable.InvalidOperation)
        (*pcw) &= ~IEM_INVALID;
    if (prec->Enable.ZeroDivide)
        (*pcw) &= ~IEM_ZERODIVIDE;
    if (prec->Enable.Overflow)
        (*pcw) &= ~IEM_OVERFLOW;
    if (prec->Enable.Underflow)
        (*pcw) &= ~IEM_UNDERFLOW;
    if (prec->Enable.Inexact)
        (*pcw) &= ~IEM_INEXACT;

    //
    // Update Rounding mode
    //

    switch (prec->RoundingMode) {
    case _FpRoundChopped:
         *pcw = *pcw & ~IMCW_RC | IRC_CHOP;
         break;
    case _FpRoundPlusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_UP;
         break;
    case _FpRoundMinusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_DOWN;
         break;
    case _FpRoundNearest:
         *pcw = *pcw & ~IMCW_RC | IRC_NEAR;
         break;
    }


#ifdef _M_IX86

    //
    // Update Precision Control
    //

    switch (prec->Precision) {
    case _FpPrecisionFull:
         *pcw = *pcw & ~IMCW_RC | IPC_64;
         break;
    case _FpPrecision53:
         *pcw = *pcw & ~IMCW_RC | IPC_53;
         break;
    case _FpPrecision24:
         *pcw = *pcw & ~IMCW_RC | IPC_24;
         break;
    }

#endif

    //
    // Update result
    //

    *presult = prec->Result.Value.Fp64Value;
}



/***
* _handle_exc - produce masked response for IEEE fp exception
*
*Purpose:
*
*Entry:
*   unsigned int flags      the exception flags
*   double *presult         the default result
*   unsigned int cw         user's fp control word
*
*Exit:
*   returns 1 on successful handling, 0 on failure
*   On success, *presult becomes the masked response
*
*Exceptions:
*
*******************************************************************************/

int _handle_exc(unsigned int flags, double * presult, unsigned int cw)
{
    //
    // flags_p is useful for deciding whether there are still unhandled
    // exceptions in case multiple exceptions have occurred
    //

    int flags_p = flags & (FP_I | FP_Z | FP_O | FP_U | FP_P);

    if (flags & FP_I && cw & IEM_INVALID) {

        //
        // Masked response for invalid operation
        //

        _set_statfp(ISW_INVALID);
        flags_p &= ~FP_I;
    }

    else if (flags & FP_Z && cw & IEM_ZERODIVIDE) {

        //
        // Masked response for Division by zero
        // result should already have the proper value
        //

        _set_statfp( ISW_ZERODIVIDE);
        flags_p &= ~FP_Z;
    }

    else if (flags & FP_O && cw & IEM_OVERFLOW) {

        //
        // Masked response for Overflow
        //

        _set_statfp(ISW_OVERFLOW);
        switch (cw & IMCW_RC) {
        case IRC_NEAR:
            *presult = *presult > 0.0 ? D_INF : -D_INF;
            break;
        case IRC_UP:
            *presult = *presult > 0.0 ? D_INF : -D_MAX;
            break;
        case IRC_DOWN:
            *presult = *presult > 0.0 ? D_MAX : -D_INF;
            break;
        case IRC_CHOP:
            *presult = *presult > 0.0 ? D_MAX : -D_MAX;
            break;
        }

        flags_p &= ~FP_O;
    }

    else if (flags & FP_U && cw & IEM_UNDERFLOW) {

        //
        // Masked response for Underflow:
        // According to the IEEE standard, when the underflow trap is not
        // enabled, underflow shall be signaled only when both tininess
        // and loss of accuracy have been detected
        //

        int aloss=0;    // loss of accuracy flag

        if (flags & FP_P) {
            aloss = 1;
        }

        //
        // a zero value in the result denotes
        // that even after ieee scaling, the exponent
        // was too small.
        // in this case the masked response is also
        // zero (sign is preserved)
        //

        if (*presult != 0.0) {
            double result;
            int expn, newexp;

            result = _decomp(*presult, &expn);
            newexp = expn - IEEE_ADJUST;

            if (newexp < MINEXP - 53) {
                result *= 0.0;          // produce a signed zero
                aloss = 1;
            }
            else {
                int neg = result < 0;       // save sign

                //
                // denormalize result
                //

                (*D_EXP(result)) &= 0x000f; /* clear exponent field */
                (*D_EXP(result)) |= 0x0010; /* set hidden bit */

                for (;newexp<MINEXP;newexp++) {
                    if (*D_LO(result) & 0x1 && !aloss) {
                        aloss = 1;
                    }

                    /* shift mantissa to the right */
                    (*D_LO(result)) >>= 1;
                    if (*D_HI(result) & 0x1) {
                        (*D_LO(result)) |= 0x80000000;
                    }
                    (*D_HI(result)) >>= 1;
                }
                if (neg) {
                    result = -result;       // restore sign
                }
            }

            *presult = result;
        }
        else {
            aloss = 1;
        }

        if (aloss) {
            _set_statfp(ISW_UNDERFLOW);
        }

        flags_p &= ~FP_U;
    }


    //
    // Separate check for precision exception
    // (may coexist with overflow or underflow)
    //

    if (flags & FP_P && cw & IEM_INEXACT) {

        //
        // Masked response for inexact result
        //

        _set_statfp(ISW_INEXACT);
        flags_p &= ~FP_P;
    }

    return flags_p ? 0: 1;
}



/***
* _umatherr - call user's matherr routine
*
*Purpose:
*   call user's matherr routine and set errno if appropriate
*
*
*Entry:
*     int type              type of excpetion
*     unsigned int opcode   fp function that caused the exception
*     double arg1           first argument of the fp function
*     double arg2           second argument of the fp function
*     double retval         return value of the fp function
*     unsigned int cw       user's fp control word
*
*Exit:
*     fp control word       becomes the user's fp cw
*     errno                 modified if user's matherr returns 0
*     return value          the retval entered by the user in
*                           the _exception matherr struct
*
*Exceptions:
*
*******************************************************************************/

double _umatherr(
              int type,
              unsigned int opcode,
              double arg1,
              double arg2,
              double retval,
              unsigned int cw
              )
{
    struct _exception exc;

    //
    // call matherr only if the name of the function
    // is registered in the table, i.e., only if exc.name is valid
    //

    if (exc.name = _get_fname(opcode)) {
        exc.type = type;

        COPY_DOUBLE(&exc.arg1,&arg1);
        COPY_DOUBLE(&exc.arg2,&arg2);
        COPY_DOUBLE(&exc.retval,&retval);

        _rstorfp(cw);

        
        //if (_matherr(&exc) == 0) {
            _set_errno(type);
        //}
        return  exc.retval;
    }
    else {

        //
        // treat this case as if matherr returned 0
        //

        _rstorfp(cw);
        _set_errno(type);
        return retval;
    }

}



/***
* _set_errno - set errno
*
*Purpose:
*   set correct error value for errno
*
*Entry:
*   int matherrtype:    the type of math error
*
*Exit:
*   modifies errno
*
*Exceptions:
*
*******************************************************************************/

void _set_errno(int matherrtype)
{
    switch(matherrtype) {
    case _DOMAIN:
        SetMathError ( EDOM );
        break;
    case _OVERFLOW:
    case _SING:
        SetMathError ( ERANGE );
        break;
    }
}



/***
* _get_fname -  get function name
*
*Purpose:
*  returns the _matherr function name that corresponds to a
*  floating point opcode
*
*Entry:
*  _FP_OPERATION_CODE opcode
*
*Exit:
*   returns a pointer to a string
*
*Exceptions:
*
*******************************************************************************/
#define OP_NUM  27   /* number of fp operations */

static char *_get_fname(unsigned int opcode)
{

    static struct {
        unsigned int opcode;
        char *name;
    } _names[OP_NUM] = {
        { OP_EXP,   "exp" },
        { OP_POW,   "pow" },
        { OP_LOG,   "log" },
        { OP_LOG10, "log10"},
        { OP_SINH,  "sinh"},
        { OP_COSH,  "cosh"},
        { OP_TANH,  "tanh"},
        { OP_ASIN,  "asin"},
        { OP_ACOS,  "acos"},
        { OP_ATAN,  "atan"},
        { OP_ATAN2, "atan2"},
        { OP_SQRT,  "sqrt"},
        { OP_SIN,   "sin"},
        { OP_COS,   "cos"},
        { OP_TAN,   "tan"},
        { OP_CEIL,  "ceil"},
        { OP_FLOOR, "floor"},
        { OP_ABS,   "fabs"},
        { OP_MODF,  "modf"},
        { OP_LDEXP, "ldexp"},
        { OP_CABS,  "_cabs"},
        { OP_HYPOT, "_hypot"},
        { OP_FMOD,  "fmod"},
        { OP_FREXP, "frexp"},
        { OP_Y0,    "_y0"},
        { OP_Y1,    "_y1"},
        { OP_YN,    "_yn"}
    };

    int i;
    for (i=0;i<OP_NUM;i++) {
        if (_names[i].opcode == opcode)
            return _names[i].name;
    }
    return (char *)0;
}



/***
* _errcode - get _matherr error code
*
*Purpose:
*   returns matherr type that corresponds to exception flags
*
*Entry:
*   flags: exception flags
*
*Exit:
*   returns matherr type
*
*Exceptions:
*
*******************************************************************************/

int _errcode(unsigned int flags)
{
    unsigned int errcode;

    if (flags & FP_TLOSS) {
        errcode = _TLOSS;
    }
    else if (flags & FP_I) {
        errcode = _DOMAIN;
    }
    else if (flags & FP_Z) {
        errcode = _SING;
    }
    else if (flags & FP_O) {
        errcode = _OVERFLOW;
    }
    else if (flags & FP_U) {
        errcode = _UNDERFLOW;
    }
    else {

        // FP_P

        errcode = 0;
    }
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\log.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    log.c

Abstract:
    
    logarithmic functions
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/


#include <math.h>
#include <trans.h>

static double _log_hlp( double x, int flag);

/* constants */
static double const c0 =  0.70710678118654752440;   /* sqrt(0.5) */
static double const c1 =  0.69335937500000000000;
static double const c2 = -2.121944400546905827679e-4;
static double const c3 =  0.43429448190325182765;

/* coefficients for rational approximation */
static double const a0 = -0.64124943423745581147e2 ;
static double const a1 =  0.16383943563021534222e2 ;
static double const a2 = -0.78956112887491257267e0 ;
static double const b0 = -0.76949932108494879777e3 ;
static double const b1 =  0.31203222091924532844e3 ;
static double const b2 = -0.35667977739034646171e2 ;
/* b3=1.0  is not used -avoid multiplication by 1.0 */

#define A(w) (((w) * a2 + a1) * (w) + a0)
#define B(w) ((((w) + b2) * (w) + b1) * (w) + b0)


/***
*double log(double x) -  natural logarithm
*double log10(double x) - base-10 logarithm
*
*Purpose:
*   Compute the natural and base-10 logarithm of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P Z
*******************************************************************************/

double Proxylog10(double x)
{
    return(_log_hlp(x,OP_LOG10));
}

double Proxylog(double x)
{
    return(_log_hlp(x,OP_LOG));
}

static double _log_hlp(double x, int opcode)
{
    unsigned int savedcw;
    int n;
    double f,result;
    double z,w,znum,zden;
    double rz,rzsq;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
        RETURN(savedcw, x);
    case T_QNAN:
        return _handle_qnan1(opcode, x, savedcw);
    case T_SNAN:
        return _except1(FP_I, opcode, x, _s2qnan(x), savedcw);
    }
    /* NINF will be handled in the x<0 case */
    }

    if (x <= 0.0) {
    double qnan;
    if (x == 0.0) {
        return _except1(FP_Z,opcode,x,-D_INF,savedcw);
    }
    qnan = (opcode == OP_LOG ? QNAN_LOG : QNAN_LOG10);
    return _except1(FP_I,opcode,x,qnan,savedcw);
    }

    if (x == 1.0) {
    // no precision ecxeption
    RETURN(savedcw, 0.0);
    }

    f = _decomp(x, &n);

    if (f > c0) {
    znum = (f - 0.5) - 0.5;
    zden = f * 0.5 + 0.5;
    }
    else {
    n--;
    znum = f - 0.5;
    zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z; 

    rzsq = w * A(w)/B(w) ;
    rz = z + z*rzsq;

    result = (n * c2 + rz) + n * c1;
    if (opcode == OP_LOG10) {
    result *= c3;
    }

    RETURN_INEXACT1(opcode,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\atan.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    atan.c

Abstract:
    
    This module implements arithmatic tan function used in wow.
    
Author:


Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>

static double _atanhlp(double x);

static double const a[4] = {
    0.0,
    0.52359877559829887308,   /* pi/6 */
    1.57079632679489661923,   /* pi/2 */
    1.04719755119659774615    /* pi/3 */
};

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI_OVER_TWO = 1.57079632679489661923;
static double const PI      = 3.14159265358979323846;
static double const TWO_M_SQRT3 = 0.26794919243112270647;
static double const SQRT3_M_ONE = 0.73205080756887729353;
static double const SQRT3   = 1.73205080756887729353;

/* chose MAX_ARG s.t. 1/MAX_ARG does not underflow */
static double const MAX_ARG = 4.494232837155790e+307;

/* constants for rational approximation */
static double const p0 = -0.13688768894191926929e+2;
static double const p1 = -0.20505855195861651981e+2;
static double const p2 = -0.84946240351320683534e+1;
static double const p3 = -0.83758299368150059274e+0;
static double const q0 =  0.41066306682575781263e+2;
static double const q1 =  0.86157349597130242515e+2;
static double const q2 =  0.59578436142597344465e+2;
static double const q3 =  0.15024001160028576121e+2;
static double const q4 =  0.10000000000000000000e+1;


#define Q(g)  (((((g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define R(g)  ((((p3 * (g) + p2) * (g) + p1) * (g) + p0) * (g)) / Q(g)


/***
*double atan(double x) - arctangent
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
\*******************************************************************************/
double Proxyatan(double x)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch(_sptype(x)) {
    case T_PINF:
        result = PI_OVER_TWO;
        break;
    case T_NINF:
        result = -PI_OVER_TWO;
        break;
    case T_QNAN:
        return _handle_qnan1(OP_ATAN,x,savedcw);
    default: //T_SNAN
        return _except1(FP_I,OP_ATAN,x,_s2qnan(x),savedcw);
    }
    }

    if (x == 0.0)
    RETURN(savedcw,x);

    result = _atanhlp(x);
    RETURN_INEXACT1(OP_ATAN,x,result,savedcw);
}

/***
*double atan2(double x, double y) - arctangent (x/y)
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN or both args 0: DOMAIN error
*******************************************************************************/
double Proxyatan2(double v, double u)
{
    unsigned int savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(v) || IS_D_SPECIAL(u)){
    if (IS_D_SNAN(v) || IS_D_SNAN(u)){
        return _except2(FP_I,OP_ATAN2,v,u,_d_snan2(v,u),savedcw);
    }
    if (IS_D_QNAN(v) || IS_D_QNAN(u)){
        return _handle_qnan2(OP_ATAN2,v,u,savedcw);
    }
    if ((IS_D_INF(v) || IS_D_MINF(v)) &&
        (IS_D_INF(u) || IS_D_MINF(u))){
        return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
    }
    /* the other combinations of infinities will be handled
     * later by the division v/u
     */
    }


    if (u == 0) {
    if (v == 0) {
        return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
    }
    else {
        result = PI_OVER_TWO;
    }
    }
    else if (INTEXP(v) - INTEXP(u) > MAXEXP - 3) {
    /* v/u overflow */
    result = PI_OVER_TWO;
    }
    else {
    double arg = v/u;


    if (ABS(arg) < D_MIN) {

        if (v == 0.0 || IS_D_INF(u) || IS_D_MINF(u)) {
        result = (u < 0) ? PI : 0;
        if (v < 0) {
            result = -result;
        }
        if (result == 0) {
             RETURN(savedcw,  result);
        }
        else {
             RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
        }
        }
        else {

        double v1, u1;
        int vexp, uexp;
        int exc_flags;

        //
        // in this case an underflow has occurred
        // re-compute the result in order to raise
        // an IEEE underflow exception
        //

        if (u < 0) {
            result = v < 0 ? -PI: PI;
            RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
        }

        v1 = _decomp(v, &vexp);
        u1 = _decomp(u, &uexp);
        result = _add_exp(v1/u1, vexp-uexp+IEEE_ADJUST);
        result = ABS(result);

        if (v < 0) {
            result = -result;
        }

        // this is not a perfect solution. In the future
        // we may want to have a way to let the division
        // generate an exception and propagate the IEEE result
        // to the user's handler

        exc_flags = FP_U;
        if (_statfp() & ISW_INEXACT) {
            exc_flags  |= FP_P;
        }
        return _except2(exc_flags,OP_ATAN2,v,u,result,savedcw);

        }
    }

    else {
       result = _atanhlp( ABS(arg) );
    }

    }

    /* set sign of the result */
    if (u < 0) {
    result = PI - result;
    }
    if (v < 0) {
    result = -result;
    }


    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
}





/***
*double _atanhlp(double x) - arctangent helper
*
*Purpose:
*   Compute arctangent of x, assuming x is a valid, non infinite
*   number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
static double _atanhlp(double x)
{
    double f,g,result;
    int n;


    f = ABS(x);
    if (f > MAX_ARG) {
    // if this step is ommited, 1.0/f might underflow in the
    // following block
    return x > 0.0 ? PI_OVER_TWO : -PI_OVER_TWO;
    }
    if (f > 1.0) {
    f = 1.0/f;
    n = 2;
    }
    else {
    n = 0;
    }

    if (f > TWO_M_SQRT3) {
    f = (((SQRT3_M_ONE * f - .5) - .5) + f) / (SQRT3 + f);
    n++;
    }  

    if (ABS(f) < EPS) {
    result = f;
    }
    else {
    g = f*f;
    result = f + f * R(g);
    }

    if (n > 1)
    result = -result;

    result += a[n];

    if (x < 0.0)
    result = -result;


    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\modf.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

   modf.c 

Abstract:
    
   modf()  function
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>
#include <float.h> 

extern double _frnd(double);
extern double _copysign (double x, double y);

/***
*double modf(double x, double *intptr)
*
*Purpose:
*   Split x into fractional and integer part
*   The signed fractional portion is returned
*   The integer portion is stored as a floating point value at intptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I
*******************************************************************************/
static  unsigned int newcw = (ICW & ~IMCW_RC) | (IRC_CHOP & IMCW_RC);

double modf(double x, double *intptr)
{
    unsigned int savedcw;
    double result,intpart;

    /* save user fp control word */
    savedcw = _ctrlfp(0, 0);     /* get old control word */
    _ctrlfp(newcw,IMCW);    /* round towards 0 */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    *intptr = QNAN_MODF;
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        *intptr = x;
        result = _copysign(0, x);
        RETURN(savedcw,result);
    case T_QNAN:
        *intptr = x;
        return _handle_qnan1(OP_MODF, x, savedcw);
    default: //T_SNAN
        result = _s2qnan(x);
        *intptr = result;
        return _except1(FP_I, OP_MODF, x, result, savedcw);
    }
    }

    if (x == 0.0) {
    *intptr = x;
    result = x;
    }

    else {
    intpart = _frnd(x); //fix needed: this may set the P exception flag
            //and pollute the fp status word

    *intptr = intpart;
    result = x - intpart;
    }

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\ldexp.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    ldexp.c

Abstract:
    
    multiply by a power of two
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/
 
#include <math.h>
#include <float.h>
#include <trans.h>
#include <limits.h>
  
/***
*double ldexp(double x, int exp)
*
*Purpose:
*   Compute x * 2^exp
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I  U  O  P
*
*******************************************************************************/
double ldexp(double x, int exp)
{
    unsigned int savedcw;
    int oldexp;
    long newexp; /* for checking out of bounds exponents */
    double result, mant;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
    switch (_sptype(x)) {
    case T_PINF:
    case T_NINF:
        RETURN(savedcw,x);
    case T_QNAN:
        return _handle_qnan2(OP_LDEXP, x, (double)exp, savedcw);
    default: //T_SNAN
        return _except2(FP_I,OP_LDEXP,x,(double)exp,_s2qnan(x),savedcw);
    }
    }


    if (x == 0.0) {
    RETURN(savedcw,x);
    }

    mant = _decomp(x, &oldexp);

    if (ABS(exp) > INT_MAX)
    newexp = exp; // avoid possible integer overflow
    else
    newexp = oldexp + exp;


    /* out of bounds cases */
    if (newexp > MAXEXP + IEEE_ADJUST) {
    return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,_copysign(D_INF,mant),savedcw);
    }
    if (newexp > MAXEXP) {
    result = _set_exp(mant, newexp-IEEE_ADJUST);
    return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }
    if (newexp < MINEXP - IEEE_ADJUST) {
    return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,mant*0.0,savedcw);
    }
    if (newexp < MINEXP) {
    result = _set_exp(mant, newexp+IEEE_ADJUST);
    return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }

    result = _set_exp(mant, (int)newexp);

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\tan.c ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    tan.c

Abstract:
    
    This module implement tan function used in the wow64 mscpu.
    
Author:


Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/

#include <math.h>
#include <trans.h>

/* constants */
static double const TWO_OVER_PI = 0.63661977236758134308;
static double const EPS  = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const YMAX = 2.98156826864790199324e8; /* 2^(53/2)*PI/2 */

//
// The sum of C1 and C2 is a representation of PI/2 with 66 bits in the
// significand (same as x87). (PI/2 = 2 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x3ff921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3dd0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the rational approximation */
/* p0 = 1.0  is not used (avoid mult by 1) */
static double const p1 = -0.13338350006421960681e+0;
static double const p2 =  0.34248878235890589960e-2;
static double const p3 = -0.17861707342254426711e-4;
static double const q0 =  0.10000000000000000000e+1;
static double const q1 = -0.46671683339755294240e+0;
static double const q2 =  0.25663832289440112864e-1;
static double const q3 = -0.31181531907010027307e-3;
static double const q4 =  0.49819433993786512270e-6;


#define Q(g)   ((((q4 * (g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define P(g,f)  (((p3 * (g) + p2) * (g) + p1) * (g) * (f) + (f))

#define ISODD(i) ((i)&0x1)


/***
*double tan(double x) - tangent
*
*Purpose:
*   Compute the tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I, U
*   if x is denormal: raise underflow
*******************************************************************************/
double Proxytan(double x)
{
    unsigned int savedcw;
    unsigned long n;
    double xn,xnum,xden;
    double f,g,result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
    switch(_sptype(x)) {
    case T_PINF:
    case T_NINF:
        return _except1(FP_I,OP_TAN,x,QNAN_TAN1,savedcw);
    case T_QNAN:
        return _handle_qnan1(OP_TAN, x, savedcw);
    default: //T_SNAN
        return _except1(FP_I,OP_TAN,x,_s2qnan(x),savedcw);
    }
    }

    if (x == 0.0)
    RETURN(savedcw, x);

    if (ABS(x) > YMAX) {

    // The argument is too large to produce a meaningful result,
    // so this is treated as an invalid operation.
    // We also set the (extra) FP_TLOSS flag for matherr
    // support

    return _except1(FP_TLOSS | FP_I,OP_TAN,x,QNAN_TAN2,savedcw);
    }

    xn = _frnd(x * TWO_OVER_PI);
    n = (unsigned long) fabs(xn);


    /* assume there is a guard digit for addition */
    f = (x - xn * C1) - xn * C2;
    if (ABS(f) < EPS) {
    xnum = f;
    xden = 1;
    if (IS_D_DENORM(f)) {
        return _except1(FP_U | FP_P,OP_TAN,x,_add_exp(f, IEEE_ADJUST),savedcw);
    }
    }
    else {
    g = f*f;
    xnum = P(g,f);
    xden = Q(g);
    }

    if (ISODD(n)) {
    xnum = -xnum;
    result = xden/xnum;
    }
    else
    result = xnum/xden;

    RETURN_INEXACT1(OP_TAN,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\util.c ===
/***
*util.c - utilities for fp transcendentals
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   _set_exp and _add_exp are as those defined in Cody & Waite
*
*Revision History:
*   08-15-91	GDP	written
*   10-20-91	GDP	removed _rint, unsafe_intrnd
*   02-05-92	GDP	added _fpclass
*   03-27-92	GDP	added _d_min
*   06-23-92	GDP	added _d_mzero
*
*******************************************************************************/
#include "trans.h"

/* define special values */

_dbl _d_inf = {SET_DBL (0x7ff00000, 0x0) };	  //positive infinity
_dbl _d_ind = {SET_DBL (D_IND_HI, D_IND_LO)};	  //real indefinite
_dbl _d_max = {SET_DBL (0x7fefffff, 0xffffffff)}; //max double
_dbl _d_min = {SET_DBL (0x00100000, 0x00000000)}; //min normalized double
_dbl _d_mzero = {SET_DBL (0x80000000, 0x00000000)}; //negative zero



double _set_exp(double x, int exp)
/* does not check validity of exp */
{
    double retval;
    int biased_exp;
    retval = x;
    biased_exp = exp + D_BIASM1;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));
    return retval;
}


int _get_exp(double x)
{
    signed short exp;
    exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
    exp -= D_BIASM1; //unbias
    return (int) exp;
}


double _add_exp(double x, int exp)
{
    return _set_exp(x, INTEXP(x)+exp);
}


double _set_bexp(double x, int bexp)
/* does not check validity of bexp */
{
    double retval;
    retval = x;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (bexp << 4));
    return retval;
}


int _sptype(double x)
{
    if (IS_D_INF(x))
	return T_PINF;
    if (IS_D_MINF(x))
	return T_NINF;
    if (IS_D_QNAN(x))
	return T_QNAN;
    if (IS_D_SNAN(x))
	return T_SNAN;
    return 0;
}



/***
*double _decomp(double x, double *expptr)
*
*Purpose:
*   decompose a number to a normalized mantisa and exponent
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _decomp(double x, int *pexp)
{
    int exp;
    double man;

    if (x == 0) {
	man = 0;
	exp = 0;
    }
    else if (IS_D_DENORM(x)) {
	int neg;

	exp = 1-D_BIASM1;
	neg = x < 0.0;
	while((*D_EXP(x) & 0x0010) == 0) {
	    /* shift mantissa to the left until bit 52 is 1 */
	    (*D_HI(x)) <<= 1;
	    if (*D_LO(x) & 0x80000000)
		(*D_HI(x)) |= 0x1;
	    (*D_LO(x)) <<= 1;
	    exp--;
	}
	(*D_EXP(x)) &= 0xffef; /* clear bit 52 */
	if (neg) {
	    (*D_EXP(x)) |= 0x8000; /* set sign bit */
	}
	man = _set_exp(x,0);
    }
    else {
	man = _set_exp(x,0);
	exp = INTEXP(x);
    }

    *pexp = exp;
    return man;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\mscpu\math\trans.h ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    trans.h

Abstract:
    
    Header file for math functions.
    
Author:



Revision History:

    29-sept-1999 ATM Shafiqul Khalid [askhalid] copied from rtl library.
--*/


#ifndef _INC_TRANS

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

//#include <cruntime.h>

void
SetMathError ( 
              int Code 
              );

#define OP_UNSPEC    0
#define OP_ADD       1
#define OP_SUB       2
#define OP_MUL       3
#define OP_DIV       4
#define OP_SQRT      5
#define OP_REM       6
#define OP_COMP      7
#define OP_CVT       8
#define OP_RND       9
#define OP_TRUNC     10
#define OP_FLOOR     11
#define OP_CEIL      12
#define OP_ACOS      13
#define OP_ASIN      14
#define OP_ATAN      15
#define OP_ATAN2     16
#define OP_CABS      17
#define OP_COS       18
#define OP_COSH      19
#define OP_EXP       20
#define OP_ABS       21         /* same as OP_FABS */
#define OP_FABS      21         /* same as OP_ABS  */
#define OP_FMOD      22
#define OP_FREXP     23
#define OP_HYPOT     24
#define OP_LDEXP     25
#define OP_LOG       26
#define OP_LOG10     27
#define OP_MODF      28
#define OP_POW       29
#define OP_SIN       30
#define OP_SINH      31
#define OP_TAN       32
#define OP_TANH      33
#define OP_Y0        34
#define OP_Y1        35
#define OP_YN        36
#define OP_LOGB       37
#define OP_NEXTAFTER  38
#define OP_NEG       39

/* Define __cdecl for non-Microsoft compilers */

#if ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <fpieee.h>

#define D_BIASM1 0x3fe /* off by one to compensate for the implied bit */

#ifdef B_END
/* big endian */
#define D_EXP(x) ((unsigned short *)&(x))
#define D_HI(x) ((unsigned long *)&(x))
#define D_LO(x) ((unsigned long *)&(x)+1)
#else
#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))
#endif

/* return the int representation of the exponent
 * if x = .f * 2^n, 0.5<=f<1, return n (unbiased)
 * e.g. INTEXP(3.0) == 2
 */
#define INTEXP(x) ((signed short)((*D_EXP(x) & 0x7ff0) >> 4) - D_BIASM1)


/* check for infinity, NAN */
#define D_ISINF(x) ((*D_HI(x) & 0x7fffffff) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_SPECIAL(x) ((*D_EXP(x) & 0x7ff0) == 0x7ff0)
#define IS_D_NAN(x) (IS_D_SPECIAL(x) && !D_ISINF(x))

#ifdef  _M_MRX000

#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
             (*D_HI(x) << 13 || *D_LO(x)))
#else

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
             (*D_HI(x) << 13 || *D_LO(x)))
#endif

#define IS_D_DENORM(x)  ((*D_EXP(x) & 0x7ff0) == 0  && \
             (*D_HI(x) << 12 || *D_LO(x)))


#define IS_D_INF(x)  (*D_HI(x) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_MINF(x) (*D_HI(x) == 0xfff00000 && *D_LO(x) == 0)


#ifdef  _M_MRX000
#define D_IND_HI 0x7ff7ffff
#define D_IND_LO 0xffffffff
#else
#define D_IND_HI 0xfff80000
#define D_IND_LO 0x0
#endif


typedef union   {
    long lng[2];
    double dbl;
    } _dbl;


#ifndef DEFINE_EXTERN_HERE
extern _dbl _d_inf;
extern _dbl _d_ind;
extern _dbl _d_max;
extern _dbl _d_min;
extern _dbl _d_mzero;
#else
_dbl _d_inf;
_dbl _d_ind;
_dbl _d_max;
_dbl _d_min;
_dbl _d_mzero;
#endif

#define D_INF  (_d_inf.dbl)
#define D_IND  (_d_ind.dbl)
#define D_MAX  (_d_max.dbl)
#define D_MIN  (_d_min.dbl)
#define D_MZERO (_d_mzero.dbl)       /* minus zero */

/* min and max exponents for normalized numbers in the
 * form: 0.xxxxx... * 2^exp (NOT 1.xxxx * 2^exp !)
 */
#define MAXEXP 1024
#define MINEXP -1021

#endif  /* #ifndef __assembler */


#if defined(_M_IX86)

/* Control word for computation of transcendentals */
#define ICW    0x133f

#define IMCW       0xffff

#define IMCW_EM     0x003f      /* interrupt Exception Masks */
#define IEM_INVALID 0x0001      /*   invalid */
#define IEM_DENORMAL    0x0002      /*   denormal */
#define IEM_ZERODIVIDE  0x0004      /*   zero divide */
#define IEM_OVERFLOW    0x0008      /*   overflow */
#define IEM_UNDERFLOW   0x0010      /*   underflow */
#define IEM_INEXACT 0x0020      /*   inexact (precision) */


#define IMCW_RC 0x0c00          /* Rounding Control */
#define IRC_CHOP    0x0c00      /*   chop */
#define IRC_UP      0x0800      /*   up */
#define IRC_DOWN    0x0400      /*   down */
#define IRC_NEAR    0x0000      /*   near */

#define ISW_INVALID 0x0001      /* invalid */
#define ISW_DENORMAL    0x0002      /* denormal */
#define ISW_ZERODIVIDE  0x0004      /* zero divide */
#define ISW_OVERFLOW    0x0008      /* overflow */
#define ISW_UNDERFLOW   0x0010      /* underflow */
#define ISW_INEXACT 0x0020      /* inexact (precision) */

#define IMCW_PC     0x0300      /* Precision Control */
#define IPC_24      0x0000      /*    24 bits */
#define IPC_53      0x0200      /*    53 bits */
#define IPC_64      0x0300      /*    64 bits */

#define IMCW_IC     0x1000      /* Infinity Control */
#define IIC_AFFINE  0x1000      /*   affine */
#define IIC_PROJECTIVE  0x0000      /*   projective */


#elif defined(_M_MRX000)


#define ICW     0x00000f80      /* Internal CW for transcendentals */
#define IMCW        0xffffff83      /* Internal CW Mask */

#define IMCW_EM     0x00000f80      /* interrupt Exception Masks */
#define IEM_INVALID 0x00000800      /*   invalid */
#define IEM_ZERODIVIDE  0x00000400      /*   zero divide */
#define IEM_OVERFLOW    0x00000200      /*   overflow */
#define IEM_UNDERFLOW   0x00000100      /*   underflow */
#define IEM_INEXACT 0x00000080      /*   inexact (precision) */


#define IMCW_RC     0x00000003      /* Rounding Control */
#define IRC_CHOP    0x00000001      /*   chop */
#define IRC_UP      0x00000002      /*   up */
#define IRC_DOWN    0x00000003      /*   down */
#define IRC_NEAR    0x00000000      /*   near */


#define ISW_INVALID (1<<6)  /* invalid */
#define ISW_ZERODIVIDE  (1<<5)  /* zero divide */
#define ISW_OVERFLOW    (1<<4)  /* overflow */
#define ISW_UNDERFLOW   (1<<3)  /* underflow */
#define ISW_INEXACT (1<<2)  /* inexact (precision) */


#elif defined(_M_ALPHA)

//
// ICW is the Internal Control Word for transcendentals: all five exceptions
// are masked and round to nearest mode is set. IMCW is the mask: all bits
// are set, except for the ISW bits.
//

#define ICW (IEM_INEXACT | IEM_UNDERFLOW | IEM_OVERFLOW | IEM_ZERODIVIDE | IEM_INVALID | IRC_NEAR)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID)
#define IMCW (0xffffffff ^ ISW)

//
// The defines for the internal control word match the format of the Alpha
// AXP software FPCR except for the rounding mode which is obtained from the
// Alpha AXP hardware FPCR and shifted right 32 bits.
//

//
// Internal Exception Mask bits.
// Each bit _disables_ an exception (they are not _enable_ bits).
//

#define IMCW_EM     0x0000003e  /* interrupt Exception Masks */

#define IEM_INEXACT 0x00000020  /*   inexact (precision) */
#define IEM_UNDERFLOW   0x00000010  /*   underflow */
#define IEM_OVERFLOW    0x00000008  /*   overflow */
#define IEM_ZERODIVIDE  0x00000004  /*   zero divide */
#define IEM_INVALID 0x00000002  /*   invalid */

//
// Internal Rounding Control values.
//

#define IMCW_RC     (0x3 << 26) /* Rounding Control */

#define IRC_CHOP    (0x0 << 26) /*   chop */
#define IRC_DOWN    (0x1 << 26) /*   down */
#define IRC_NEAR    (0x2 << 26) /*   near */
#define IRC_UP      (0x3 << 26) /*   up */

//
// Internal Status Word bits.
//

#define ISW_INEXACT 0x00200000  /* inexact (precision) */
#define ISW_UNDERFLOW   0x00100000  /* underflow */
#define ISW_OVERFLOW    0x00080000  /* overflow */
#define ISW_ZERODIVIDE  0x00040000  /* zero divide */
#define ISW_INVALID 0x00020000  /* invalid */


#elif defined(_M_PPC)

#define IMCW_EM         0x000000f8  /* Exception Enable Mask    */

#define IEM_INVALID     0x00000080  /*   invalid                */
#define IEM_OVERFLOW    0x00000040  /*   overflow               */
#define IEM_UNDERFLOW   0x00000020  /*   underflow              */
#define IEM_ZERODIVIDE  0x00000010      /*   zero divide            */
#define IEM_INEXACT     0x00000008  /*   inexact (precision)    */


#define IMCW_RC         0x00000003      /* Rounding Control Mask    */

#define IRC_NEAR        0x00000000      /*   near                   */
#define IRC_CHOP        0x00000001      /*   chop                   */
#define IRC_UP          0x00000002      /*   up                     */
#define IRC_DOWN        0x00000003      /*   down                   */


#define IMCW_SW     0x3E000000  /* Status Mask              */

#define ISW_INVALID     0x20000000      /*   invalid summary        */
#define ISW_OVERFLOW    0x10000000      /*   overflow               */
#define ISW_UNDERFLOW   0x08000000      /*   underflow              */
#define ISW_ZERODIVIDE  0x04000000      /*   zero divide            */
#define ISW_INEXACT     0x02000000      /*   inexact (precision)    */


#define IMCW_VX         0x01F80700      /* Invalid Cause Mask       */

#define IVX_SNAN        0x01000000      /*   SNaN                   */
#define IVX_ISI         0x00800000      /*   infinity - infinity    */
#define IVX_IDI         0x00400000      /*   infinity / infinity    */
#define IVX_ZDZ         0x00200000      /*   zero / zero            */
#define IVX_IMZ         0x00100000      /*   infinity * zero        */
#define IVX_VC          0x00080000      /*   inv flpt compare       */
#define IVX_SOFT        0x00000400      /*   software request       */
#define IVX_SQRT        0x00000200      /*   sqrt of negative       */
#define IVX_CVI         0x00000100      /*   inv integer convert    */


/* Internal CW for transcendentals */

#define ICW             (IMCW_EM)

/* Internal CW Mask (non-status bits) */

#define IMCW           (0xffffffff & (~(IMCW_SW|IMCW_VX)))


#elif defined(_M_M68K)

#include "mac\m68k\trans.a"


/* LATER -- we don't handle exception until Mac OS has better support on it */

#define _except1(flags, op, arg1, res, cw) _errcode(flags), _rstorfp(cw), \
                        _set_statfp(cw),(res)

#define _except2(flags, op, arg1, arg2, res, cw) _errcode(flags), _rstorfp(cw), \
                          _set_statfp(cw),(res)

#define _handle_qnan1(opcode, x, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x);
#define _handle_qnan2(opcode, x, y, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x+y);


#elif defined(_M_MPPC)

/* Mac control information - included as part of trans.h
   It is broken out to allow use with ASM68 files*/

/* Control word for computation of transcendentals */



#define ICW        (IPC_64 + IRC_NEAR + IMCW_EM)

#define IMCW      IMCW_RC +  IMCW_PC


#define IMCW_EM         0x000000f8  /* interrupt Exception Masks */
#define IEM_INVALID     0x00000080  /*   invalid */
#define IEM_ZERODIVIDE  0x00000010  /*   zero divide */
#define IEM_OVERFLOW    0x00000040  /*   overflow */
#define IEM_UNDERFLOW   0x00000020  /*   underflow */
#define IEM_INEXACT     0x00000008  /*   inexact (precision) */


#define IMCW_RC 0x00000003          /* Rounding Control */
#define IRC_CHOP        0x00000001  /*   chop */
#define IRC_UP          0x00000002  /*   up */
#define IRC_DOWN        0x00000003  /*   down */
#define IRC_NEAR        0x00000000  /*   near */

#define IMSW            0xffffff00  /* status bits mask */
#define ISW_INVALID     0x20000000  /* invalid */
#define ISW_ZERODIVIDE  0x04000000  /* zero divide */
#define ISW_OVERFLOW    0x10000000  /* overflow */
#define ISW_UNDERFLOW   0x08000000  /* underflow */
#define ISW_INEXACT     0x02000000  /* inexact (precision) */

#define IMCW_PC         0x0000  /* Precision Control */
#define IPC_24          0x0000  /*    24 bits */
#define IPC_53          0x0000  /*    53 bits */
#define IPC_64          0x0000  /*    64 bits */


/* LATER -- we don't handle exception until Mac OS has better support on it */

#define _except1(flags, op, arg1, res, cw) _errcode(flags), \
                        _set_statfp(cw),(res)

#define _except2(flags, op, arg1, arg2, res, cw) _errcode(flags), \
                          _set_statfp(cw),(res)

#define _handle_qnan1(opcode, x, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x);
#define _handle_qnan2(opcode, x, y, savedcw) _set_errno(_DOMAIN), _rstorfp(savedcw), (x+y);

#endif

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

#define RETURN(fpcw,result) return _rstorfp(fpcw),(result)

#define RETURN_INEXACT1(op,arg1,res,cw)         \
    if (cw & IEM_INEXACT) {             \
        _rstorfp(cw);               \
        return res;                 \
    }                       \
    else {                      \
        return _except1(FP_P, op, arg1, res, cw);   \
    }


#define RETURN_INEXACT2(op,arg1,arg2,res,cw)        \
    if (cw & IEM_INEXACT) {             \
        _rstorfp(cw);               \
        return res;                 \
    }                       \
    else {                      \
        return _except2(FP_P, op, arg1, arg2, res, cw); \
    }


#ifdef _M_ALPHA

//
// Since fp32 is not compiled in IEEE exception mode perform Alpha NaN
// propagation in software to avoid hardware/kernel trap involvement.
//

extern double _nan2qnan(double);

#define _d_snan2(x,y)   _nan2qnan(y)
#define _s2qnan(x)  _nan2qnan(x)

#else
//handle NaN propagation
#define _d_snan2(x,y)   ((x)+(y))
#define _s2qnan(x)  ((x)+1.0)
#endif


#define _maskfp() _ctrlfp(ICW, IMCW)
#ifdef  _M_ALPHA
#define _rstorfp(cw) 0
#else
#define _rstorfp(cw) _ctrlfp(cw, IMCW)
#endif


#define ABS(x) ((x)<0 ? -(x) : (x) )


int _d_inttype(double);

#endif  /* #ifndef __assembler */

#define _D_NOINT 0
#define _D_ODD 1
#define _D_EVEN 2


// IEEE exceptions
#define FP_O         0x01
#define FP_U         0x02
#define FP_Z         0x04
#define FP_I         0x08
#define FP_P         0x10

// An extra flag for matherr support
// Set together with FP_I from trig functions when the argument is too large
#define FP_TLOSS     0x20


#ifndef __assembler /* MIPS ONLY: Protect from assembler */
#ifdef B_END
#define SET_DBL(msw, lsw)     msw, lsw
#else
#define SET_DBL(msw, lsw)     lsw, msw
#endif
#endif  /* #ifndef __assembler */


// special types
#define T_PINF  1
#define T_NINF  2
#define T_QNAN  3
#define T_SNAN  4


// exponent adjustment for IEEE overflow/underflow exceptions
// used before passing the result to the trap handler

#define IEEE_ADJUST 1536

// QNAN values

#define INT_NAN     (~0)

#define QNAN_SQRT   D_IND
#define QNAN_LOG    D_IND
#define QNAN_LOG10  D_IND
#define QNAN_POW    D_IND
#define QNAN_SINH   D_IND
#define QNAN_COSH   D_IND
#define QNAN_TANH   D_IND
#define QNAN_SIN1   D_IND
#define QNAN_SIN2   D_IND
#define QNAN_COS1   D_IND
#define QNAN_COS2   D_IND
#define QNAN_TAN1   D_IND
#define QNAN_TAN2   D_IND
#define QNAN_ACOS   D_IND
#define QNAN_ASIN   D_IND
#define QNAN_ATAN2  D_IND
#define QNAN_CEIL   D_IND
#define QNAN_FLOOR  D_IND
#define QNAN_MODF   D_IND
#define QNAN_LDEXP  D_IND
#define QNAN_FMOD   D_IND
#define QNAN_FREXP  D_IND


/*
 * Function prototypes
 */

#ifndef __assembler /* MIPS ONLY: Protect from assembler */

double _set_exp(double x, int exp);
double _set_bexp(double x, int exp);
double _add_exp(double x, int exp);
double _frnd(double);
double _fsqrt(double);
#if !defined(_M_M68K) && !defined(_M_MPPC)
double _except1(int flags, int opcode, double arg, double res, unsigned int cw);
double _except2(int flags, int opcode, double arg1, double arg2, double res, unsigned int cw);
#endif
int _sptype(double);
int _get_exp(double);
double _decomp(double, int *);
int _powhlp(double x, double y, double * result);
extern unsigned int _fpstatus;
double _frnd(double);
double _exphlp(double, int *);
#if !defined(_M_M68K) && !defined(_M_MPPC)
double _handle_qnan1(unsigned int op, double arg, unsigned int cw);
double _handle_qnan2(unsigned int op,double arg1,double arg2,unsigned int cw);
#endif
unsigned int _clhwfp(void);
unsigned int _setfpcw(unsigned int);
int _errcode(unsigned int flags);
void _set_errno(int matherrtype);
int _handle_exc(unsigned int flags, double * presult, unsigned int cw);
unsigned int _clrfp(void);
unsigned int _ctrlfp(unsigned int,unsigned int);
unsigned int _statfp(void);
void _set_statfp(unsigned int);

#endif  /* #ifndef __assembler */

#ifdef __cplusplus
}
#endif

#define _INC_TRANS
#endif  /* _INC_TRANS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\ntvdm64\ntvdm64.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    ntvdm64.c

Abstract:

    Support for 16-bit process thunking on NT64

Author:

    12-Jan-1999 PeterHal

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wow64t.h>
#include <shlobj.h>
#include <stdio.h>


#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))

#if DBG
#define DEBUG_PRINT(args) DbgPrint args
#else
#define DEBUG_PRINT(args)
#endif

typedef struct {
    LPCWSTR Name;
    LPCWSTR Version;
    LPCWSTR ProdName;
    LPCWSTR InternalName;
    LPCWSTR CmdLine;
    LPCWSTR MappedExe;
} NTVDM64_ENTRY;
typedef CONST NTVDM64_ENTRY *PNTVDM64_ENTRY;

CONST NTVDM64_ENTRY NtVdm64Entries[] = {
    {L"ACMSETUP301", L"3.01", L"Microsoft Setup for Windows", L"*", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP30",  L"3.0",  L"Microsoft Setup for Windows", L"*", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP30K", L"3.0",  L"Microsoft Windows*", L"bootstrp", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP30G", L"3.0",  L"Microsoft Setup*", L"bootstrp", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP30F", L"3.0",  L"Programme d'installation Microsoft pour Windows", L"bootstrp", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP26",  L"2.6",  L"Microsoft Setup for Windows", L"*", L"-m \"%m\" %c", L"setup16.exe"},
    {L"ACMSETUP12",  L"1.2",  L"Microsoft Setup for Windows", L"*", L"-m \"%m\" %c", L"setup16.exe"},
    {L"INSTALLSHIELD5", L"5*", L"InstallShield*", L"*", L"-isw64\"%m\" %c", L"InstallShield\\setup.exe"}
};

#if !_WIN64
CONST int CsidlList[] = {
    CSIDL_COMMON_STARTMENU,
    CSIDL_COMMON_PROGRAMS,
    CSIDL_COMMON_STARTUP,
    CSIDL_COMMON_DESKTOPDIRECTORY,
    CSIDL_COMMON_APPDATA,
    CSIDL_COMMON_TEMPLATES,
    CSIDL_COMMON_DOCUMENTS,
    CSIDL_COMMON_ADMINTOOLS,
    CSIDL_COMMON_FAVORITES
};
#endif

LONG
CreateNtvdm64Entry(
    HKEY hKeyVdm,
    PNTVDM64_ENTRY Entry
    )
/*++

Routine Description:

    Write a registry entry for a single entry in the table

Arguments:

    hKeyVdm     - key to write the entry to
    Entry       - the entry to write

Return Value:

    LONG - a return code from a Registry API, 0 for success

--*/
{
    LONG l;
    HKEY h;
    WCHAR Path[MAX_PATH];

    if (!GetSystemWindowsDirectoryW(Path, sizeof(Path)/sizeof(Path[0]))) {
            return 1;
    }

    if ((lstrlenW(Path) + (sizeof (L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\") / sizeof(WCHAR))) >= (sizeof(Path)/sizeof(Path[0]))) {
        return 1;
    }

    wcscat(Path, L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\");

    if ((lstrlenW(Path) + lstrlenW(Entry->MappedExe)) >= (sizeof(Path)/sizeof(Path[0]))) {
        return 1;
    }

    wcscat(Path, Entry->MappedExe);

    l = RegCreateKeyW(hKeyVdm, Entry->Name, &h);
    if (l) {
        return l;
    }

    l = RegSetValueExW(h, L"CommandLine", 0, REG_SZ, (BYTE *)Entry->CmdLine, (wcslen(Entry->CmdLine)+1)*sizeof(WCHAR));
    if (l) goto exit;

    l = RegSetValueExW(h, L"ProductName", 0, REG_SZ, (BYTE *)Entry->ProdName, (wcslen(Entry->ProdName)+1)*sizeof(WCHAR));
    if (l) {
        return l;
    }
    l = RegSetValueExW(h, L"InternalName", 0, REG_SZ, (BYTE *)Entry->InternalName, (wcslen(Entry->InternalName)+1)*sizeof(WCHAR));
    if (l) {
        return l;
    }
    l = RegSetValueExW(h, L"ProductVersion", 0, REG_SZ, (BYTE *)Entry->Version, (wcslen(Entry->Version)+1)*sizeof(WCHAR));
    if (l) goto exit;
    
    l = RegSetValueExW(h, L"MappedExeName", 0, REG_SZ, (BYTE *)Path, (wcslen(Path)+1)*sizeof(WCHAR));

exit:   RegCloseKey (h);   //askhalid fix resource leak Adding RegCloseKey
        return l;
}

STDAPI
DllInstall(
    BOOL bInstall,
    LPCWSTR pszCmdLine
    )
/*++

Routine Description:

    Routine called during guimode setup to register ntvdm64.dll

Arguments:

    bInstall    - TRUE if registering, FALSE if unregistering
    pszCmdLine  - command-line

Return Value:

    HRESULT

--*/
{
    HKEY hKeyVdm;
    LONG l;
    SIZE_T i;
    WCHAR Path[MAX_PATH];
    BOOL bResult;

    UNREFERENCED_PARAMETER(pszCmdLine);

    if (!bInstall) {
        // There is no uninstall for ntvdm64
        return NOERROR;
    }

    l = RegCreateKeyW(HKEY_LOCAL_MACHINE,
                      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NtVdm64",
                      &hKeyVdm);
    if (l) {
        return E_FAIL;
    }
    for (i=0; i<ARRAYSIZE(NtVdm64Entries); ++i) {
        l = CreateNtvdm64Entry(hKeyVdm, &NtVdm64Entries[i]);
        if (l) {
            break;
        }
    }
    RegCloseKey(hKeyVdm);
    if (l) {
        return E_FAIL;
    }

#if !_WIN64
    //
    // Call shell32, asking for some common CSIDL_ values.  This forces
    // shell32 to create values under HKLM\Software\Microsoft\Windows\
    // Explorere\Shell Folders.  Some apps (VB, VC, MSDN) expect these
    // values to be present in the registry, but they are created on-demand
    // as a side-effect of calling the shell APIs to query for them.  On x86
    // NT, guimode setup itself calls shell32 several times, while creating
    // the Start Menu, etc. so several values are always present when apps
    // run for the first time.
    //
    for (i=0; i<sizeof(CsidlList)/sizeof(CsidlList[0]); ++i) {
        bResult = SHGetSpecialFolderPathW(NULL, Path, CsidlList[i], TRUE);
        if (!bResult) {
            return E_FAIL;
        }
    }
#endif

    return NOERROR;
}



//-----------------------------------------------------------------------
// This section is ripped off from mvdm\wow32\wkman.c

//
// MyVerQueryValue checks several popular code page values for the given
// string.  This may need to be extended ala WinFile's wfdlgs2.c to search
// the translation table.  For now we only need a few.
//

BOOL
MyVerQueryValue(
    const LPVOID pBlock,
    LPWSTR lpName,
    LPVOID * lplpBuffer,
    PUINT puLen
    )
{
    DWORD dwDefaultLanguage[] = {0x04E40409, 0x00000409};
    WCHAR szSubBlock[128];
    PDWORD pdwTranslation;
    DWORD uLen;
    BOOL fRet;
    int i;


    if(!VerQueryValue(pBlock, "\\VarFileInfo\\Translation", (PVOID*)&pdwTranslation, &uLen)) {

        pdwTranslation = dwDefaultLanguage;
        uLen = sizeof (dwDefaultLanguage);
    }

    fRet = FALSE;
    while ((uLen > 0) && !fRet) {

        swprintf(szSubBlock, L"\\StringFileInfo\\%04X%04X\\%ws",
                 LOWORD(*pdwTranslation),
                 HIWORD(*pdwTranslation),
                 lpName);

        fRet = VerQueryValueW(pBlock, szSubBlock, lplpBuffer, puLen);


        pdwTranslation++;
        uLen -= sizeof (DWORD);
    }

    if (!fRet) {
        DEBUG_PRINT(("NtVdm64: Failed to get resource %ws.\n", lpName));
    }

    return fRet;
}


//
// Utility routine to fetch the Product Name and Product Version strings
// from a given EXE.
//

BOOL
WowGetProductNameVersion(
    LPCWSTR pszExePath,
    LPWSTR pszProductName,
    DWORD cbProductName,
    LPWSTR pszInternalName,
    DWORD cbInternalName,
    LPWSTR pszProductVersion,
    DWORD cbProductVersion
    )
{
    DWORD dwZeroMePlease;
    DWORD cbVerInfo;
    LPVOID lpVerInfo = NULL;
    LPWSTR pName;
    DWORD cbName;
    LPWSTR pIntName;
    DWORD cbIntName;
    LPWSTR pVersion;
    DWORD cbVersion;

    *pszProductName = 0;
    *pszInternalName = 0;
    *pszProductVersion = 0;

    cbVerInfo = GetFileVersionInfoSizeW((LPWSTR)pszExePath, &dwZeroMePlease);
    if (!cbVerInfo) {
        return TRUE;
    }

    lpVerInfo = RtlAllocateHeap( RtlProcessHeap(), 0, (cbVerInfo));
    if (!lpVerInfo) {
        DEBUG_PRINT(("NtVdm64: Failed to allocate version info.\n"));
        return FALSE;
    }

    if (!GetFileVersionInfoW((LPWSTR)pszExePath, 0, cbVerInfo, lpVerInfo)) {
        DEBUG_PRINT(("NtVdm64: Failed to get version info. GLE %x\n", GetLastError()));
        return FALSE;
    }

    if (MyVerQueryValue(lpVerInfo, L"ProductName", &pName, &cbName)) {
        if (cbName <= cbProductName) {
            wcscpy(pszProductName, pName);
        } else {
            DEBUG_PRINT(("NtVdm64: ProductName resource too large %ws. Size %x\n", pName, cbName));
        }
    }

    if (MyVerQueryValue(lpVerInfo, L"InternalName", &pIntName, &cbIntName)) {
        if (cbIntName <= cbInternalName) {
            wcscpy(pszInternalName, pIntName);
        } else {
            DEBUG_PRINT(("NtVdm64: InternalName resource too large %ws. Sizw %x\n", pIntName, cbIntName));
        }
    }

    if (MyVerQueryValue(lpVerInfo, L"ProductVersion", &pVersion, &cbVersion)) {
        if (cbVersion <= cbProductVersion) {
            wcscpy(pszProductVersion, pVersion);
        } else {
            DEBUG_PRINT(("NtVdm64: ProductVersion resource too large %ws. Size %x\n", pVersion, cbVersion));
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, lpVerInfo);

    return TRUE;
}

//-----------------------------------------------------------------------

LPWSTR
GetDotExeEndPtr(
    LPCWSTR Path)
/*++

Routine Description:

    Returns a pointer to the end of .EXE in the path name, if exists

Arguments:

    Path - File path to an executable.
               
Return Value:

    Pointer to the end of the applicable ".EXE", otherwise NULL.
    cases:
    ""a:\foo.exe \foo.exe" /p xx" .exe should point to the last one.

--*/
{
    PWSTR pwsz = (PWSTR)Path;
    BOOL bQuteMatch = FALSE;
    PWSTR strGoodOccurance = NULL;

    if (pwsz == NULL) 
        return NULL;
    
    while (*pwsz != UNICODE_NULL) {

        if (*pwsz == L'"') {
                bQuteMatch = !bQuteMatch; // this must be false at the time of match.
                if (!bQuteMatch)
                    return pwsz++;
        }

            if (*pwsz == L'.') {
                if ( (pwsz[1] == L'e' || pwsz[1]==L'E') &&
                    (pwsz[1] == L'e' || pwsz[1]==L'E') &&
                    (pwsz[1] == L'e' || pwsz[1]==L'E')
                    ) {  // found an exe match
                        pwsz += 4;
                        if (*pwsz == L'"') {
                            bQuteMatch = !bQuteMatch;
                            pwsz++;  //skip double quote
                        }
                        if ( !bQuteMatch)  //quote matching is done
                            return pwsz;
                        else continue;
                    }
            }//if
            pwsz++;
    } // while loop
    return NULL;
}

BOOL
MapCommandLine(
    HKEY hkeyMapping,
    LPCWSTR lpWin16ApplicationName,
    LPCWSTR lpMappedApplicationName,
    BOOL    fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Maps the command line for a Win16 application.

Arguments:

    hkeyMapping - open registry keyfor the mapping entry
    lpWin16ApplicationName - Win16 file name (with path)
    lpMappedApplicationName - the ported version
               of lpWin16ApplicationName
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    WCHAR achBuffer[MAX_PATH+1];
    DWORD dwBufferLength;
    DWORD dwType;
    LPWSTR lpsz;
    LPWSTR lpMappedCommandLine;
    DWORD dwRequiredBufferLength;
    LONG result;
    LPCWSTR lpOriginalCommandLine;

    // set default command line to empty string
    if (NULL == lpCommandLine) {
        lpCommandLine = L"";
    }
    lpOriginalCommandLine = lpCommandLine;

    // get the command line map from the registry
    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"CommandLine", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: CommandLine failed to get REG_SZ value. Result %x Type %x\n", result, dwType));
        return FALSE;
    }

    // calculate mapped buffer size and allocate it
    dwRequiredBufferLength = 1;
    if (fPrefixMappedApplicationName) {
        dwRequiredBufferLength += wcslen(lpMappedApplicationName) + 1;
    } else {
        
        PWSTR pDotExeEndPtr;

        pDotExeEndPtr = GetDotExeEndPtr (lpCommandLine);
        if (pDotExeEndPtr != NULL) {
            ASSERT (pDotExeEndPtr > lpCommandLine);
            ASSERT (((ULONG_PTR)pDotExeEndPtr & 0x01) == 0);

            while (lpCommandLine != pDotExeEndPtr) {
                dwRequiredBufferLength++;
                lpCommandLine++;
            }
        } else {
        
            while (*lpCommandLine && *lpCommandLine != L' ') {
                dwRequiredBufferLength++;
                lpCommandLine++;
            }
        }

        // consume any extra spaces
        while (*lpCommandLine == L' ') {
            lpCommandLine++;
        }
        // account for one space in the output buffer
        dwRequiredBufferLength++;
    }
    lpsz = achBuffer;
    while (*lpsz) {
        if (*lpsz == L'%') {
            lpsz += 1;
            switch (*lpsz) {

            // %c : Insert Original Command Line
            case L'c':
            case L'C':
                lpsz += 1;
                dwRequiredBufferLength += wcslen(lpCommandLine);
                break;

            // %m : Insert Original Module Name
            case L'm':
            case L'M':
                lpsz += 1;
                dwRequiredBufferLength += wcslen(lpWin16ApplicationName);
                break;

            // %% : Insert a real %
            case L'%':
                lpsz += 1;
                dwRequiredBufferLength += 1;
                break;

            // %\0 : eat terminating %\0
            case 0:
                DEBUG_PRINT(("NtVdm64: ignoring trailing %% in CommandLine.\n"));
                break;

            // %x : undefined macro expands to nothing
            default:
                DEBUG_PRINT(("NtVdm64: ignoring unknown macro %%%wc in CommandLine.\n", *lpsz));
                lpsz += 1;
                break;
            }
        } else {
            lpsz += 1;
            dwRequiredBufferLength += 1;
        }
    }
    *lplpMappedCommandLine = RtlAllocateHeap(RtlProcessHeap(), 0, dwRequiredBufferLength * sizeof (WCHAR));
    if (!*lplpMappedCommandLine) {
        DEBUG_PRINT(("NtVdm64: failed to allocate CommandLine. GLE %x.\n", GetLastError()));
        return FALSE;
    }

    // map the buffer
    lpCommandLine = lpOriginalCommandLine;
    lpsz = achBuffer;
    lpMappedCommandLine = *lplpMappedCommandLine;
    if (fPrefixMappedApplicationName) {
        wcscpy(lpMappedCommandLine, lpMappedApplicationName);
        lpMappedCommandLine += wcslen(lpMappedApplicationName);
        *lpMappedCommandLine = L' ';
        lpMappedCommandLine += 1;
    } else {
        // copy in the first whitespace-delimited part of the old
        // command-line as it is the name of the app.
        
        PWSTR pDotExeEndPtr;

        pDotExeEndPtr = GetDotExeEndPtr (lpCommandLine);
        if (pDotExeEndPtr != NULL) {
            ASSERT (pDotExeEndPtr > lpCommandLine);
            ASSERT (((ULONG_PTR)pDotExeEndPtr & 0x01) == 0);

            while (lpCommandLine != pDotExeEndPtr) {
                *lpMappedCommandLine = *lpCommandLine;
                lpMappedCommandLine++;
                lpCommandLine++;
            }
        } else {
        
            while (*lpCommandLine && *lpCommandLine != L' ') {
                *lpMappedCommandLine = *lpCommandLine;
                lpMappedCommandLine++;
                lpCommandLine++;
            }
        }
        // add in a space of padding and skip over any spaces in the
        // original command line
        *lpMappedCommandLine++ = L' ';
        while (*lpCommandLine == L' ') {
            lpCommandLine++;
        }
    }
    while (*lpsz) {
        if (*lpsz == L'%') {
            lpsz += 1;
            switch (*lpsz) {

            // %c : Insert Original Command Line
            case L'c':
            case L'C':
                lpsz += 1;
                wcscpy(lpMappedCommandLine, lpCommandLine);
                lpMappedCommandLine += wcslen(lpCommandLine);
                break;

            // %m : Insert Original Module Name
            case L'm':
            case L'M':
                lpsz += 1;
                wcscpy(lpMappedCommandLine, lpWin16ApplicationName);
                lpMappedCommandLine += wcslen(lpWin16ApplicationName);
                break;

            // %% : Insert a real %
            case L'%':
                lpsz += 1;
                *lpMappedCommandLine = L'%';
                lpMappedCommandLine += 1;
                break;

            // %\0 : eat terminating %\0
            case 0:
                break;

            // %x : undefined macro expands to nothing
            default:
                lpsz += 1;
                break;
            }
        } else {
            *lpMappedCommandLine = *lpsz;
            lpMappedCommandLine += 1;
            lpsz += 1;
        }
    }
    *lpMappedCommandLine = L'\0';

    return TRUE;
}

int
CompareStrings(
    LPWSTR  lpRegString,
    LPCWSTR lpExeString
    )
/*++

Routine Description:

    Compares strings using a minimal wildcard support in addition
    to just a stock wcscmp.  The RegString can have an optional '*'
    which is used as a wildcard that matches any characters upto the
    end of the string.