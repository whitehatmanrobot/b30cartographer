 the specified
//     interface 
//
// Parameters:
//     [In]  hwndOwner - Owner window.  Ignored.
//     [In]  riid      - The interface to create.
//     [Out] ppvOut    - A pointer that receives the new object.
//
// Return:
//     S_OK if the requested object was successfully created.
//     E_NOINTERFACE if the object is not suppported.
//     E_OUTOFMEMORY if the pidl couldn't be cloned.
//     The return value from SHCreateShellFolderViewEx otherwise.
//
// Comments:
//     It is important to remember that the COM object created by
//     CreateViewObject must be a different object than the shell folder object.
//     The Explorer may call CreateViewObject more than once to create more than
//     one view object and expects them to behave as independent objects. A new
//     view object must be created for each call.
//
//     Request for IShellView return a default Shell implementation. 
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::CreateViewObject(
    HWND hwndOwner,
    REFIID riid,
    LPVOID* ppvOut
)
{
    ASSERT(ppvOut);

    //
    // This function is called when the cdf hasn't been parsed.  m_pcdfidl is
    // likely NULL in this case.  This doesn't appear to be a problem so the
    // ASSERT has been commented out.
    //

    // ASSERT(m_bCdfParsed);

    HRESULT hr;

    if (IID_IShellView == riid)
    {
        hr = CreateDefaultShellView((IShellFolder*)this,
                                    (LPITEMIDLIST)m_pidlPath,
                                    (IShellView**)ppvOut);
    }
    else
    {
        *ppvOut = NULL;

        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppvOut) || (FAILED(hr) && NULL == *ppvOut));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetAttributesOf ***
//
//
// Description:
//     Returns the common attributes of the given id lists.
//
// Parameters:
//     [In]  cidl            - The number of id lists passed in.
//     [In]  apidl           - An array of id list pointers.
//     [Out] pfAttributesOut - Address to receive the common attributes. These
//                             attributes are defined with the SFGAO_ prefix.
//                             For example SFGAO_FOLDER and SFGAO_CANDELETE.
//
// Return:
//     S_OK if the attributes of the given id lists could be determined.
//     E_FAIL otherwise.
//
// Comments:
//     The attributes of the given id lists are AND'ed to obtain the common
//     members.
//
//     Shell calls this on the root folder with cidl set to zero to get the
//     attributes of the root folder.  It also doesn't bother to check the
//     return value so make sure the attributes are set correctly for this
//     case.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::GetAttributesOf(
    UINT cidl,
    LPCITEMIDLIST* apidl,
    ULONG* pfAttributesOut
)
{
    ASSERT(apidl || cidl == 0);
    ASSERT(pfAttributesOut);

    ULONG fAttributeFilter = *pfAttributesOut;

    if (!m_bCdfParsed)
    {
        TraceMsg(TF_CDFPARSE, "IShellFolder GetAttributesOf %s",
                 PathFindFileName(m_szPath));
        ParseCdfFolder(NULL, PARSE_LOCAL);
    }

    if (m_pIXMLElementCollection)
    {
        if (cidl)
        {

            *pfAttributesOut = (ULONG)-1;

            while(cidl-- && *pfAttributesOut)
            {
                ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)apidl[cidl]));
                ASSERT(ILIsEmpty(_ILNext(apidl[cidl])));
                ASSERT(XML_IsCdfidlMemberOf(m_pIXMLElementCollection,
                                            (PCDFITEMIDLIST)apidl[cidl]));

                //
                // CDFIDL_GetAttributes returns zero on failure.
                //

                *pfAttributesOut &= CDFIDL_GetAttributes(
                                                   m_pIXMLElementCollection,
                                                   (PCDFITEMIDLIST)apidl[cidl],
                                                   fAttributeFilter);
            }
        }
        else
        {
            //
            // Return this folder's attributes.
            //

            *pfAttributesOut = SFGAO_FOLDER;

            if (XML_ContainsFolder(m_pIXMLElementCollection))
                *pfAttributesOut |= SFGAO_HASSUBFOLDER;
        }
    }
    else
    {
        //
        // m_pIXMLElementCollection == NULL in low memory situations.
        //

        *pfAttributesOut = 0;
    }

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetUIObjectOf ***
//
//
// Description:
//     Creates a COM object implemeneting the requested interface for the
//     specidied id lists.
//
// Parameters:
//     [In]  hwndOwner - The owner window.
//     [In]  cidl      - The number of idlist passed in.
//     [In]  apild     - An array of id list pointers.
//     [In]  riid      - The requested interface.  Can be IExtractIcon,
//                       IContextMenu, IDataObject or IDropTarget.
//     []    prgfInOut - Not used.
//     [Out] ppvOut    - The pointer to receive the requested COM object.
//
// Return:
//     S_OK if the interface was created.
//     E_OUTOFMEMORY if the COM object couldn't be created.
//     E_NOINTERFACE if the requested interface isn't supported.
//     E_FAIL if cidl is zero.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    REFIID riid,
    UINT* prgfInOut,
    LPVOID * ppvOut
)
{
    ASSERT(apidl || 0 == cidl);
    ASSERT(ppvOut);

    // ASSERT(m_bCdfParsed);  Called when cdf is not parsed.

    #ifdef DEBUG
        for(UINT i = 0; i < cidl; i++)
        {
            ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)apidl[i]));
            ASSERT(ILIsEmpty(_ILNext(apidl[i])));
            ASSERT(XML_IsCdfidlMemberOf(m_pIXMLElementCollection,
                                        (PCDFITEMIDLIST)apidl[i]));
        }
    #endif // DEBUG

    HRESULT hr;

    *ppvOut = NULL;

    if (cidl)
    {
        if (IID_IExtractIcon == riid
#ifdef UNICODE
            || IID_IExtractIconA == riid
#endif
            )
        {
            ASSERT(1 == cidl);

            if (!m_bCdfParsed)
            {
                TraceMsg(TF_CDFPARSE, "IShellFolder IExtractIcon %s",
                         PathFindFileName(m_szPath));
                ParseCdfFolder(NULL, PARSE_LOCAL);
            }

#ifdef UNICODE
            CExtractIcon *pxi = new CExtractIcon((PCDFITEMIDLIST)apidl[0],
                                                      m_pIXMLElementCollection);

            if (riid == IID_IExtractIconW)
                *ppvOut = (IExtractIconW *)pxi;
            else
                *ppvOut = (IExtractIconA *)pxi;
#else
            *ppvOut = (IExtractIcon*)new CExtractIcon((PCDFITEMIDLIST)apidl[0],
                                                      m_pIXMLElementCollection); 
#endif
            hr = *ppvOut ? S_OK : E_OUTOFMEMORY;
        }
        else if (IID_IContextMenu == riid)
        {

        #if USE_DEFAULT_MENU_HANDLER

            hr = CDefFolderMenu_Create((LPITEMIDLIST)m_pcdfidl, hwndOwner, cidl,
                                       apidl, (IShellFolder*)this, MenuCallBack,
                                       NULL, NULL, (IContextMenu**)ppvOut);
        #else // USE_DEFAULT_MENU_HANDLER

            *ppvOut = (IContextMenu*)new CContextMenu((PCDFITEMIDLIST*)apidl,
                                                      m_pidlPath, cidl);

            hr = *ppvOut ? S_OK : E_OUTOFMEMORY;

        #endif // USE_DEFAULT_MENU_HANDLER

        }
        else if (IID_IQueryInfo == riid)
        {
            ASSERT(1 == cidl);
            
            if (!m_bCdfParsed)
            {
                TraceMsg(TF_CDFPARSE, "IShellFolder IQueryInfo %s",
                         PathFindFileName(m_szPath));
                ParseCdfFolder(NULL, PARSE_LOCAL);
            }

            *ppvOut = (IQueryInfo*)new CQueryInfo((PCDFITEMIDLIST)apidl[0],
                                                   m_pIXMLElementCollection);

            hr = *ppvOut ? S_OK : E_OUTOFMEMORY;
        } 
        else if (IID_IShellLink  == riid || IID_IDataObject == riid
#ifdef UNICODE
                || IID_IShellLinkA == riid
#endif
                )
        {
            ASSERT(1 == cidl); // IDataObject should handle cidl > 1!

            hr = QueryInternetShortcut((PCDFITEMIDLIST)apidl[0], riid, ppvOut);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        ASSERT(0);  // Is this ever called with cidl == 0?

        hr = E_FAIL;
    }

    ASSERT((SUCCEEDED(hr) && *ppvOut) || (FAILED(hr) && NULL == *ppvOut));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetDisplayNameOf ***
//
//
// Description:
//     Returns the diaply name for the specified Id list.
//
// Parameters:
//     [In]  pidl   - A pointer to the id list.
//     [In]  uFlags - SHGDN_NORMAL, SHGN_INFOLDER or SHGDN_FORPARSING.
//     [Out] lpName - A pointer to a STRRET structure that receives the name.
//
// Return:
//     S_OK if the name can be determined.
//     E_FAIL otherwise.
//
// Comments:
//     This may be called on the root element in which case the pidl is a shell
//     id list and not a cdf id list.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName
)
{
    ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)pidl));
    ASSERT(ILIsEmpty(_ILNext(pidl)));
    ASSERT(XML_IsCdfidlMemberOf(m_pIXMLElementCollection,
                                (PCDFITEMIDLIST)pidl));
    ASSERT(lpName);

    return CDFIDL_GetDisplayName((PCDFITEMIDLIST)pidl, lpName);
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::SetNameOf ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpszName,
    DWORD uFlags,
    LPITEMIDLIST* ppidlOut
)
{
    return E_NOTIMPL;
}


//
// IPersistFolder method,
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::Initialize ***
//
//
// Description:
//     This function is called with the fully qualified id list (location) of
//     the selected cdf file.
//
// Parameters:
//     [In]  pidl - The pidl of the selected cdf file.  This pidl conatins the
//                  full path to the CDF.
//
// Return:
//     S_OK if content for the cdf file could be created.
//     E_OUTOFMEMORY otherwise.
//
// Comments:
//     This function can be called more than once for a given folder.  When a
//     CDFView is being instantiated from a desktop.ini file the shell calls
//     Initialize once before it calls GetUIObjectOf asking for IDropTarget.
//     After the GetUIObjectOf call the folder is Released.  It then calls
//     Initialize again on a new folder.  This time it keeps the folder and it
//     ends up being displayed.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::Initialize(
    LPCITEMIDLIST pidl
)
{
    ASSERT(pidl);

    HRESULT hr;

    ASSERT(NULL == m_pidlPath);

    m_pidlPath = ILClone(pidl);

    if (m_pidlPath)
    {
        hr = CPersist::Initialize(pidl);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//
// Helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::ParseCdf ***
//
//
// Description:
//     Parses the cdf file associated with this folder.
//
// Parameters:
//     [In]  hwndOwner    - The parent window of any dialogs that need to be
//                          displayed.
//     [In]  dwFParseType - PARSE_LOCAL, PARSE_NET and PARSE_REPARSE.
//
// Return:
//     S_OK if the cdf file was found and successfully parsed.
//     E_FAIL otherwise.
//
// Comments:
//     Uses the m_pidlRoot that was set during IPersistFolder::Initialize.
//     
////////////////////////////////////////////////////////////////////////////////
HRESULT
CCdfView::ParseCdfFolder(
    HWND hwndOwner,
    DWORD dwParseFlags
)
{
    HRESULT hr;

    //
    // Parse the file and get the first channel element.
    //

    IXMLDocument* pIXMLDocument = NULL;

    hr = CPersist::ParseCdf(hwndOwner, &pIXMLDocument, dwParseFlags);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        IXMLElement*    pIXMLElement;
        LONG            nIndex;

        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);
            //ASSERT(NULL == m_pcdfidl); Can be non-NULL on a reparse.

            if (m_pcdfidl)
                CDFIDL_Free(m_pcdfidl);

            if (m_pIXMLElementCollection)
                m_pIXMLElementCollection->Release();

            m_pcdfidl = CDFIDL_CreateFromXMLElement(pIXMLElement, nIndex);

            HRESULT hr2 = pIXMLElement->get_children(&m_pIXMLElementCollection);
            if(!m_pIXMLElementCollection)
            {
                ASSERT(hr2 != S_OK);
                hr = E_FAIL; 
            }
            ASSERT((S_OK == hr2 && m_pIXMLElementCollection) ||
                   (S_OK != hr2 && NULL == m_pIXMLElementCollection));

            pIXMLElement->Release();
        }
    }
    if (pIXMLDocument)
        pIXMLDocument->Release();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::QueryInternetShortcut ***
//
//
// Description:
//     Sets up an internet shorcut object for the given URL.
//
// Parameters:
//     [In]  pszURL  - The URL.
//     [In]  riid    - The requested interface on the shortcut object.
//     [Out] ppvOut  - A pointer that receives the interface.
//
// Return:
//     S_OK if the object is created and the interface is found.
//     A COM error code otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
QueryInternetShortcut(
    LPCTSTR pszURL,
    REFIID riid,
    void** ppvOut
)
{
    ASSERT(pszURL);
    ASSERT(ppvOut);

    HRESULT hr = E_FAIL;

    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

    if (SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL)))
    {
        BSTR bstrURL = SysAllocString(wszURL);

        if (bstrURL)
        {
            CDFITEM cdfi;

            cdfi.nIndex = 1;
            cdfi.cdfItemType = CDF_Folder;
            cdfi.bstrName = bstrURL;
            cdfi.bstrURL  = bstrURL;

            PCDFITEMIDLIST pcdfidl = CDFIDL_Create(&cdfi);

            if (pcdfidl)
            {
                hr = QueryInternetShortcut(pcdfidl, riid, ppvOut);

                CDFIDL_Free(pcdfidl);
            }

            SysFreeString(bstrURL);
        }
    }

    return hr;
}
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::QueryInternetShortcut ***
//
//
// Description:
//     Sets up an internet shorcut object for the given pidl.
//
// Parameters:
//     [In]  pcdfidl - The shortcut object is created for the URL stored in this
//                     cdf item id list.
//     [In]  riid    - The requested interface on the shortcut object.
//     [Out] ppvOut  - A pointer that receives the interface.
//
// Return:
//     S_OK if the object is created and the interface is found.
//     A COM error code otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
QueryInternetShortcut(
    PCDFITEMIDLIST pcdfidl,
    REFIID riid,
    void** ppvOut
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)pcdfidl)));
    ASSERT(ppvOut);

    HRESULT hr;

    *ppvOut = NULL;

    //
    // Only create a shell link object if the CDF contains an URL
    //
    if (*(CDFIDL_GetURL(pcdfidl)) != 0)
    {
        IShellLinkA * pIShellLink;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                              IID_IShellLinkA, (void**)&pIShellLink);


        BOOL bCoInit = FALSE;

        if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
            SUCCEEDED(CoInitialize(NULL)))
        {
            bCoInit = TRUE;
            hr = CoCreateInstance(CLSID_InternetShortcut, NULL,
                                  CLSCTX_INPROC_SERVER, IID_IShellLinkA,
                                  (void**)&pIShellLink);
        }

        if (SUCCEEDED(hr))
        {
            ASSERT(pIShellLink);

#ifdef UNICODE
            CHAR szUrlA[INTERNET_MAX_URL_LENGTH];

            SHTCharToAnsi(CDFIDL_GetURL(pcdfidl), szUrlA, ARRAYSIZE(szUrlA));
            hr = pIShellLink->SetPath(szUrlA);
#else
            hr = pIShellLink->SetPath(CDFIDL_GetURL(pcdfidl));
#endif

            if (SUCCEEDED(hr))
            {
                //
                // The description ends up being the file name created.
                //

                TCHAR szPath[MAX_PATH];
#ifdef UNICODE
                CHAR  szPathA[MAX_PATH];
#endif

                StrCpyN(szPath, CDFIDL_GetName(pcdfidl), ARRAYSIZE(szPath) - 5);
                StrCatBuff(szPath, TEXT(".url"), ARRAYSIZE(szPath));
#ifdef UNICODE
                SHTCharToAnsi(szPath, szPathA, ARRAYSIZE(szPathA));
                pIShellLink->SetDescription(szPathA);
#else
                pIShellLink->SetDescription(szPath);
#endif

                hr = pIShellLink->QueryInterface(riid, ppvOut);
            }

            pIShellLink->Release();
        }

        if (bCoInit)
            CoUninitialize();

    }
    else
    {
        hr = E_FAIL;
    }

    ASSERT((SUCCEEDED(hr) && *ppvOut) || (FAILED(hr) && NULL == *ppvOut));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\globals.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// globals.h 
//
//   Contains defines for all of the global variables used in cdfview.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _GLOBALS_H_

#define _GLOBALS_H_

//
// Extern global variable declarations.
//

extern DWORD               g_dwCacheCount;
extern HINSTANCE           g_msxmlInst;
#ifndef UNIX
/* Unix does not use webcheck */
extern HINSTANCE           g_webcheckInst;
#endif /* UNIX */
extern HINSTANCE           g_hinst;
extern ULONG               g_cDllRef;
extern PCACHEITEM          g_pCache;
extern CRITICAL_SECTION    g_csCache;
extern TCHAR               g_szModuleName[MAX_PATH];
extern BOOL                g_bRunningOnNT;

extern const GUID   CLSID_CDFVIEW;
extern const GUID   CLSID_CDFINI;
extern const GUID   CLSID_CDFICONHANDLER;
extern const GUID   CLSID_CDFMENUHANDLER;
extern const GUID   CLSID_CDFPROPPAGES;

extern const TCHAR c_szChannel[];
extern const TCHAR c_szCDFURL[];
extern const TCHAR c_szHotkey[];
extern const TCHAR c_szDesktopINI[];
extern const TCHAR c_szScreenSaverURL[];

extern const WCHAR c_szPropCrawlActualSize[];
extern const WCHAR c_szPropStatusString[];
extern const WCHAR c_szPropCompletionTime[];

extern const TCHAR c_szHICKey[];
extern const TCHAR c_szHICVal[];

//
// Trace flag definitions
//

#define TF_CDFPARSE       0x00000010
#define TF_CDFICON        0x00000020
#define TF_CDFLOGO        0x00000040
#define TF_CDFENUM        0x00000080
#define TF_OBJECTS        0x00000100
#define TF_GLEAM          0x00000200
#define TF_THUNK          0x00000400

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\iconhand.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// iconhand.h 
//
//   The class definition for the cdf icon handler.
//
//   History:
//
//       4/23/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _ICONHAND_H_

#define _ICONHAND_H_

//
// Defines
//

#define WSTR_DEFAULT    L"DefaultLogo"

#define LOGO_WIDTH      80
#define LOGO_WIDTH_WIDE 194

#define GLEAM_OFFSET    53


//
// The class definition for the icon handler.
//

class CIconHandler : public IExtractIcon,
#ifdef UNICODE
                     public IExtractIconA,
#endif
                     public IExtractImage,
                     public IRunnableTask,
                     public CPersist
{
//
// Methods.
//

public:

    // Constructor
    CIconHandler(void);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IExtractIcon methods.
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPTSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);

    STDMETHODIMP Extract(LPCTSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

#ifdef UNICODE
    // IExtractIconA methods.
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);

    STDMETHODIMP Extract(LPCSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);
#endif

    // IExtractImage
    STDMETHODIMP GetLocation(LPWSTR pszPathBuffer,
                             DWORD cch,
                             DWORD *pdwPriority,
                             const SIZE* pSize,
                             DWORD dwRecClrDepth,
                             DWORD *pdwFlags);

    STDMETHODIMP Extract(HBITMAP* phBmp);

    // IRunnable task
    STDMETHODIMP         Run(void);
    STDMETHODIMP         Kill(BOOL fWait);
    STDMETHODIMP         Suspend(void);
    STDMETHODIMP         Resume(void);
    STDMETHODIMP_(ULONG) IsRunning(void);

private:

    //Destructor
    ~CIconHandler(void);

    // check for default installed channel
    BOOL IsDefaultChannel(void);
    
    //Helper functions
    HRESULT ParseCdfIcon(void);
    HRESULT ParseCdfImage(BSTR* pbstrURL, BSTR* pbstrWURL);
    HRESULT ParseCdfShellLink();
    HRESULT ParseCdfInfoTip(void** ppv);
    HRESULT ExtractCustomImage(const SIZE* pSize,HBITMAP* phBmp);
    HRESULT ExtractDefaultImage(const SIZE* pSize,HBITMAP* phBmp);
    HRESULT GetBitmap(IImgCtx* pIImgCtx, const SIZE* pSize, HBITMAP* phBmp);

    HRESULT StretchBltCustomImage(IImgCtx* pIImgCtx,
                                  const SIZE* pSize,
                                  HDC hdcDst); 

    HRESULT StretchBltDefaultImage(const SIZE* pSize, HDC hdcDest);
    HRESULT DrawGleam(HDC hdcDst);
    HRESULT SynchronousDownload(IImgCtx* pIImgCtx, LPCWSTR pwszURL);

    inline BOOL UseWideLogo(int cx) {return cx >
                                         ((LOGO_WIDTH + LOGO_WIDTH_WIDE) >> 1);}

    //HRESULT QueryInternetShortcut(PCDFITEMIDLIST pcdfidl,
    //                              REFIID riid,
    //                              void** ppvOut);

//
// Member variables.
//

private:

    ULONG           m_cRef;
    IExtractIcon*   m_pIExtractIcon;
    BSTR            m_bstrImageURL;
    BSTR            m_bstrImageWideURL;
    PCDFITEMIDLIST  m_pcdfidl;
    BOOL            m_fDone;
    BOOL            m_fDrawGleam;
    DWORD           m_dwClrDepth;
    SIZE            m_rgSize;
    LPTSTR			m_pszErrURL;   // this is the res: URL that shows errors messages
};

#endif // _ICONHAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\iconhand.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// iconhand.cpp 
//
//   The registered icon handler for cdf files.  This handler returns icons for
//   .cdf files.
//
//   History:
//
//       3/21/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "resource.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "persist.h"
#include "iconhand.h"
#include "exticon.h"
#include "cdfview.h"
#include "tooltip.h"
#include "dll.h"
#include "chanapi.h"

#include <mluisupp.h>

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** MakeXMLErrorURL() ***
//
// Set the error based on the IXMLDocument * passed in
// Upon return CParseError will in an error state no matter what
// although it may not be in the CParseError::ERR_XML state
//
// This function returns the approriate URL to navigate to
//  given the current error. Always changes *ppsz, but *ppsz maybe NULL
//
////////////////////////////////////////////////////////////////////////////////


#define CDFERROR_MAX_FOUND      100  // max char length for xml error found string
#define CDFERROR_MAX_EXPECTED   100  // max char length for xml error expected string

// format string for wsprintf of res:// ... URL
const LPTSTR CDFERROR_URL_FORMAT_TRAILER = TEXT("#%u#%ls#%ls");

// this is the number or extra chars (incl null) that CDFERROR_URL_FORMAT_TRAILER
// may have in comparison to the output buffer of wsprinf
const unsigned int CDFERROR_URL_FORMAT_EXTRA = 6;

// upper char # bound on result of building res URL
const unsigned CDFERROR_MAX_URL_LENGTH =
                6 +                                         // "res://"
                MAX_PATH +                                  // path to resource DLL
                1 +                                         // "/"
                ARRAYSIZE(SZH_XMLERRORPAGE) +               // "xmlerror.htm"
                ARRAYSIZE(CDFERROR_URL_FORMAT_TRAILER) +
                _INTEGRAL_MAX_BITS +
                CDFERROR_MAX_EXPECTED +
                CDFERROR_MAX_FOUND;

// upper char # bound on result of InternetCanonicalizeUrl
//     with result from wsprintf with CDFERROR_URL_FORMAT
//  for each funky char in the found and expected substrs, might be encoded as "%xx"
const unsigned CDFERROR_MAX_URL_LENGTH_ENCODED =
  CDFERROR_MAX_URL_LENGTH + 2*(CDFERROR_MAX_EXPECTED + CDFERROR_MAX_FOUND);


HRESULT MakeXMLErrorURL( LPTSTR pszRet, DWORD dwRetLen, IXMLDocument *pXMLDoc )
{
    IXMLError *pXMLError = NULL;
    XML_ERROR xmle = { 0 };
    HRESULT hr;

    ASSERT(pXMLDoc);

    hr =
    ( pXMLDoc ? pXMLDoc->QueryInterface(IID_IXMLError, (void **)&pXMLError) :
        E_INVALIDARG );

    if ( SUCCEEDED(hr) )
    {
        ASSERT(pXMLError);
        hr = pXMLError->GetErrorInfo(&xmle);

        if ( SUCCEEDED(hr) )
        {
            TCHAR szTemp[CDFERROR_MAX_URL_LENGTH];
            WCHAR szExpected[CDFERROR_MAX_EXPECTED];
            WCHAR szFound[CDFERROR_MAX_FOUND];

            StrCpyNW( szExpected, xmle._pszExpected, ARRAYSIZE(szExpected) );
            StrCpyNW( szFound, xmle._pszFound, ARRAYSIZE(szFound) );

            // fill in the "res://<path>\cdfvwlc.dll" part of the res URL
            hr = MLBuildResURLWrap(TEXT("cdfvwlc.dll"),
                                   g_hinst,
                                   ML_CROSSCODEPAGE,
                                   SZH_XMLERRORPAGE,
                                   szTemp,
                                   ARRAYSIZE(szTemp),
                                   TEXT("cdfview.dll"));
            if (SUCCEEDED(hr))
            {
                int nCharsWritten;
                int count;

                nCharsWritten = lstrlen(szTemp);

                count = wnsprintf(szTemp+nCharsWritten, ARRAYSIZE(szTemp)-nCharsWritten,
                    CDFERROR_URL_FORMAT_TRAILER, xmle._nLine, szExpected, szFound );
                if ( count + CDFERROR_URL_FORMAT_EXTRA < ARRAYSIZE(CDFERROR_URL_FORMAT_TRAILER) )
                {
                    // not all the chars were successfully written
                    hr = E_FAIL;
                }
                else
                  if ( !InternetCanonicalizeUrl( szTemp, pszRet, &dwRetLen, 0 ) )
                    hr = E_FAIL;

                TraceMsg(TF_CDFPARSE, "Parse error string created: %s", pszRet );
            }

            SysFreeString(xmle._pszFound);
            SysFreeString(xmle._pszExpected);
            SysFreeString(xmle._pchBuf);
        }

        else
        {
            TraceMsg(TF_CDFPARSE, "Could not get IXMLError error info" );
        }

        pXMLError->Release();
    }
    else
    {
        TraceMsg(TF_CDFPARSE, "Could not get IXMLError" );
    }

    return hr;
}



//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::CIconHandler ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CIconHandler::CIconHandler (
    void
)
: m_cRef(1)
{
    ASSERT(NULL == m_pIExtractIcon);
    ASSERT(NULL == m_bstrImageURL);
    ASSERT(NULL == m_bstrImageWideURL);
    ASSERT(NULL == m_pszErrURL);

    TraceMsg(TF_OBJECTS, "+ handler object");

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::~CIconHandler ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CIconHandler::~CIconHandler (
    void
)
{
    ASSERT(0 == m_cRef);

    if (m_pIExtractIcon)
        m_pIExtractIcon->Release();

    if (m_bstrImageURL)
        SysFreeString(m_bstrImageURL);

    if (m_bstrImageWideURL)
        SysFreeString(m_bstrImageWideURL);

    if (m_pcdfidl)
        CDFIDL_Free(m_pcdfidl);

    if (m_pszErrURL)
        delete[] m_pszErrURL;

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- handler object");

    DllRelease();

    return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::QueryInterface ***
//
//    CIconHandler QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IExtractIcon == riid)
    {
        *ppv = (IExtractIcon*)this;
    }
#ifdef UNICODE
    else if (IID_IExtractIconA == riid) 
    {
        *ppv = (IExtractIconA*)this;
    }
#endif
    else if (IID_IPersistFile == riid || IID_IPersist == riid)
    {
        *ppv = (IPersistFile*)this;
    }
    else if (IID_IPersistFolder == riid)
    {
        *ppv = (IPersistFolder*)this;
    }
    else if (IID_IExtractImage == riid || IID_IExtractLogo == riid)
    {
        *ppv = (IExtractImage*)this;
    }
    else if (IID_IRunnableTask == riid)
    {
        *ppv = (IRunnableTask*)this;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }

    //
    // REVIEW:  QI on the following two objects doesn't come here.
    //

    else if (IID_IShellLink == riid
#ifdef UNICODE
        || IID_IShellLinkA == riid
#endif
        )

    {
        if (!m_bCdfParsed)
            ParseCdfShellLink();

        if (m_pcdfidl)
        {
            hr = QueryInternetShortcut(m_pcdfidl, riid, ppv);
        }
        else
        {
            if ( m_pszErrURL && *m_pszErrURL)
            {
                hr = QueryInternetShortcut(m_pszErrURL, riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else if (IID_IQueryInfo == riid)
    {
        hr = ParseCdfInfoTip(ppv);
    }
    else 
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::AddRef ***
//
//    CExtractIcon AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CIconHandler::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Release ***
//
//    CIconHandler Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CIconHandler::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IExtractIcon methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::GetIconLocation ***
//
//
// Description:
//     Returns a name index pair for the icon associated with this cdf item.
//
// Parameters:
//     [In]  uFlags     - GIL_FORSHELL, GIL_OPENICON.
//     [Out] szIconFile - The address of the buffer that receives the associated
//                        icon name.  It can be a filename, but doesn't have to
//                        be.
//     [In]  cchMax     - Size of the buffer that receives the icon location.
//     [Out] piIndex    - A pointer that receives the icon's index.
//     [Out] pwFlags    - A pointer the receives flags about the icon.
//
// Return:
//     S_OK if an was found.
//     S_FALSE if the shell should supply a default icon.
//
// Comments:
//     
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::GetIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    ASSERT(szIconFile);
    ASSERT(piIndex);
    ASSERT(pwFlags);

    HRESULT hr;

    TraceMsg(TF_CDFICON, "<IN > CIconHandler::GetIconLocation (Icon) tid:0x%x",
             GetCurrentThreadId());

    if (uFlags & GIL_ASYNC)
    {
        hr = E_PENDING;
    }
    else
    {
        hr = E_FAIL;

        if ( IsDefaultChannel())
        {
            m_bstrImageURL = CPersist::ReadFromIni( TSTR_INI_ICON );
            if ( m_bstrImageURL )
            {
                ASSERT( !m_pIExtractIcon );
                m_pIExtractIcon = (IExtractIcon*)new CExtractIcon( m_bstrImageURL );
            }
        }
        if (!m_pIExtractIcon && !m_bCdfParsed)
            ParseCdfIcon();

        if (m_pIExtractIcon)
        {
            hr = m_pIExtractIcon->GetIconLocation(uFlags, szIconFile, cchMax,
                                                  piIndex, pwFlags);
        }

        if (FAILED(hr) ||
            (StrEql(szIconFile, g_szModuleName) &&
            -IDI_CHANNEL == *piIndex)  )
        {
            //
            // Try and get the icon out of the desktop.ini file.
            //

            m_bstrImageURL = CPersist::ReadFromIni(TSTR_INI_ICON);

            if (m_bstrImageURL)
            {
                BOOL bRemovePrefix =
                                (0 == StrCmpNIW(L"file://", m_bstrImageURL, 7));

                if (SHUnicodeToTChar(
                            bRemovePrefix ? m_bstrImageURL + 7 : m_bstrImageURL,
                            szIconFile, cchMax))
                {
                    LPTSTR pszExt = PathFindExtension(szIconFile);

                    if (*pszExt != TEXT('.') ||
                        0 != StrCmpI(pszExt, TSTR_ICO_EXT))
                    {
                        *piIndex = INDEX_IMAGE;
                        MungePath(szIconFile);
                    }
                    else
                    {
                        *piIndex = 0;
                        *pwFlags = 0;
                    }

                    hr = S_OK;
                }
            }
        }

        if (FAILED(hr))
        {
            //
            // Try to return the default channel icon.
            //

            *pwFlags = 0;

            StrCpyN(szIconFile, g_szModuleName, cchMax);

            if (*szIconFile)
            {
                *piIndex = -IDI_CHANNEL;

                hr = S_OK;
            }
            else
            {
                *piIndex = 0;

                hr = S_FALSE;  // The shell will use a default icon.
            }
        }

        //
        // If this a generated icon and it should contain a gleam prepend
        // the string with a 'G'.
        //

        if (S_OK == hr && m_fDrawGleam)
        {
            TCHAR* pszBuffer = new TCHAR[cchMax];
            
            if (m_pIExtractIcon)
            {
                CExtractIcon *pExtract = (CExtractIcon *)m_pIExtractIcon;
                pExtract->SetGleam(m_fDrawGleam);
            }
            
            if (pszBuffer)
            {
                StrCpyN(pszBuffer, szIconFile, cchMax);

                *szIconFile = TEXT('G');
                cchMax--;

                StrCpyN(szIconFile+1, pszBuffer, cchMax);

                delete [] pszBuffer;
            }
        }

        *pwFlags = (m_fDrawGleam || INDEX_IMAGE == *piIndex) ? GIL_NOTFILENAME :
                                                               0;

        if (m_fDrawGleam)
            *piIndex += GLEAM_OFFSET;

        TraceMsg(TF_GLEAM, "%c Icon Location %s,%d", m_fDrawGleam ? '+' : '-',
                 SUCCEEDED(hr) ? szIconFile : TEXT("FAILED"), *piIndex);

        ASSERT((S_OK == hr && *szIconFile) ||
               (S_FALSE == hr && 0 == *szIconFile));
    }

    TraceMsg(TF_CDFICON, "<OUT> CIconHandler::GetIconLocation (Icon) %s",
             szIconFile);
    return hr;
}
#ifdef UNICODE
STDMETHODIMP
CIconHandler::GetIconLocation(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    ASSERT(szIconFile);
    ASSERT(piIndex);
    ASSERT(pwFlags);

    HRESULT hr;

    TraceMsg(TF_CDFICON, "<IN > CIconHandler::GetIconLocationA (Icon) tid:0x%x",
             GetCurrentThreadId());

    WCHAR* pszIconFileW = new WCHAR[cchMax];
    if (pszIconFileW == NULL)
        return ERROR_OUTOFMEMORY;
    hr = GetIconLocation(uFlags, pszIconFileW, cchMax, piIndex, pwFlags);
    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(pszIconFileW, szIconFile, cchMax);

    delete [] pszIconFileW;
    return hr;
}
#endif

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Extract ***
//
//
// Description:
//     Return an icon given the name index pair returned from GetIconLocation.
//
// Parameters:
//     [In]  pszFile     - A pointer to the name associated with the requested
//                         icon.
//     [In]  nIconIndex  - An index associated with the requested icon.
//     [Out] phiconLarge - Pointer to the variable that receives the handle of
//                         the large icon.
//     [Out] phiconSmall - Pointer to the variable that receives the handle of
//                         the small icon.
//     [Out] nIconSize   - Value specifying the size, in pixels, of the icon
//                         required. The LOWORD and HIWORD specify the size of
//                         the large and small icons, respectively.
//
// Return:
//     S_OK if the icon was extracted.
//     S_FALSE if the shell should extract the icon assuming the name is a
//     filename and the index is the icon index.
//
// Comments:
//     The shell may cache the icon returned from this function.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Extract(
    LPCTSTR pszFile,
    UINT nIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
)
{
    HRESULT hr;

    TraceMsg(TF_CDFICON, "<IN > CIconHandler::Extract (Icon) tid:0x%x",
             GetCurrentThreadId());

    DWORD dwType;
    DWORD dwVal;    //  Bits per pixel
    DWORD cbVal = sizeof(DWORD);
    
    if ((SHGetValue(HKEY_CURRENT_USER, c_szHICKey, c_szHICVal, &dwType, &dwVal, 
                   &cbVal) != ERROR_SUCCESS) 
                   ||
                   (REG_DWORD != dwType))
                   
    {
        dwVal = 0;
    }

    //  Convert bits per pixel to # colors
    m_dwClrDepth = (dwVal == 16) ? 256 : 16;

    if (m_fDrawGleam)
        nIconIndex -= GLEAM_OFFSET;
    
    if (m_pIExtractIcon)
    {
        hr = m_pIExtractIcon->Extract(pszFile, nIconIndex, phiconLarge,
                                      phiconSmall, nIconSize);

        //
        // If an icon couldn't be extracted, try and display the default icon.
        //

        if (FAILED(hr))
        {
            hr = Priv_SHDefExtractIcon(g_szModuleName, -IDI_CHANNEL, 0, 
                        phiconLarge, phiconSmall, nIconSize);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    TraceMsg(TF_GLEAM, "%c Icon Extract  %s %s", m_fDrawGleam ? '+' : '-',
             pszFile, (S_OK == hr) ? TEXT("SUCCEEDED") : TEXT("FAILED"));

    TraceMsg(TF_CDFICON, "<OUT> CIconHandler::Extract (Icon) tid:0x%x",
             GetCurrentThreadId());

    return hr;
}

#ifdef UNICODE
STDMETHODIMP
CIconHandler::Extract(
    LPCSTR pszFile,
    UINT nIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
)
{
    HRESULT hr;

    TraceMsg(TF_CDFICON, "<IN > CIconHandler::ExtractA (Icon) tid:0x%x",
             GetCurrentThreadId());

    int    cch = lstrlenA(pszFile) + 1; 
    WCHAR* pszFileW = new WCHAR[cch];
    if (pszFileW == NULL)
        return ERROR_OUTOFMEMORY;
    SHAnsiToUnicode(pszFile, pszFileW, cch);

    hr = Extract(pszFileW, nIconIndex, phiconLarge, phiconSmall, nIconSize);

    delete [] pszFileW;
    return hr;
}
#endif

//
// IExtractImage methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::GetLocation ***
//
//
// Description:
//     Returns a string to associate with this files image.
//
// Parameters:
//     [Out] pszPathBuffer - A buffer that receives this items string.
//     [In]  cch           - The size of the buffer.
//     [Out] pdwPriority   - The priority of this item's image.
//     [In/Out] pdwFlags   - Flags associated with this call.
//
// Return:
//     S_OK if a string is returned.
//     E_FAIL otherwise.
//
// Comments:
//     IExtractImage uses the returned value to share images accross multiple
//     items.  If three items in the same directory return "Default" all three
//     would use the same image.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::GetLocation(
    LPWSTR pszPathBuffer,
    DWORD cch,
    DWORD* pdwPriority,
    const SIZE * prgSize,
    DWORD dwRecClrDepth,
    DWORD* pdwFlags
)
{
    LPWSTR pstrURL = NULL;
    
    ASSERT(pszPathBuffer || 0 == cch);
    ASSERT(pdwFlags);

    HRESULT hr = E_FAIL;
    
    TraceMsg(TF_CDFLOGO, "<IN > CIconHandler::GetIconLocation (Logo) tid:0x%x",
             GetCurrentThreadId());

    if ( !prgSize )
    {
        return E_INVALIDARG;
    }
    
    m_rgSize = *prgSize;
    m_dwClrDepth = dwRecClrDepth;

    if ( IsDefaultChannel() && !UseWideLogo(prgSize->cx))
    {
        // avoid having to partse the CDF if possible by
        // pulling the entry from the desktop.ini file...
        pstrURL = m_bstrImageURL = CPersist::ReadFromIni(TSTR_INI_LOGO);
    }
    
    if (pstrURL == NULL && !m_bCdfParsed)
        ParseCdfImage(&m_bstrImageURL, &m_bstrImageWideURL);

    pstrURL = (UseWideLogo(prgSize->cx) && m_bstrImageWideURL) ?
                                           m_bstrImageWideURL :
                                           m_bstrImageURL;

    if (pstrURL)
    {
        ASSERT(0 != *m_bstrImageURL);

        if (m_fDrawGleam && cch > 0)
        {
            *pszPathBuffer++ = L'G';
            cch--;
        }

        if (StrCpyNW(pszPathBuffer, pstrURL, cch))
        {
            hr = S_OK;
        }
        else
        {
            if (m_bstrImageURL)
            {
                SysFreeString(m_bstrImageURL);
                m_bstrImageURL = NULL;
            }

            if (m_bstrImageWideURL)
            {
                SysFreeString(m_bstrImageWideURL);
                m_bstrImageWideURL = NULL;
            }
        }
    }

    if (FAILED(hr))
    {
        m_bstrImageURL     = CPersist::ReadFromIni(TSTR_INI_LOGO);
        m_bstrImageWideURL = CPersist::ReadFromIni(TSTR_INI_WIDELOGO);

        pstrURL = (UseWideLogo(prgSize->cx) && m_bstrImageWideURL) ?
                                                            m_bstrImageWideURL :
                                                            m_bstrImageURL;

        if (pstrURL)
        {
            if (m_fDrawGleam && cch > 0)
            {
                *pszPathBuffer++ = L'G';
                cch--;
            }

            if (StrCpyNW(pszPathBuffer, pstrURL, cch))
                hr = S_OK;
        }
    }

    BOOL bAsync = *pdwFlags & IEIFLAG_ASYNC;

    //
    // REVIEW: Long URLs truncated in pszPathBuffer.
    //

    //TSTRToWideChar(m_szPath, pszPathBuffer, cch);

    if (pdwPriority)
        *pdwPriority = ITSAT_DEFAULT_PRIORITY; //0x10000;  // Low priority since this could hit the net.

    *pdwFlags = m_fDrawGleam ? IEIFLAG_GLEAM : 0;

    TraceMsg(TF_GLEAM, "%c Logo Location %S", m_fDrawGleam ? '+' : '-',
             SUCCEEDED(hr) ? pszPathBuffer : L"FAILED");

    //
    // REVIEW: Proper IEIFLAG_ASYNC handling.
    //

    TraceMsg(TF_CDFLOGO, "<OUT> CIconHandler::GetIconLocation (Logo) tid:0x%x",
             GetCurrentThreadId());

    return (SUCCEEDED(hr) && bAsync) ? E_PENDING : hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Extract ***
//
//
// Description:
//     Returns a hbitmap for use as a logo for this cdf file.
//
// Parameters:
//     [Out] phBmp         - The returned bitmap.
//
// Return:
//     S_OK if an image was extracted.
//     E_FAIL if an image couldn't be extracted.
//
// Comments:
//     The returned bitmap is stretched to pSize.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Extract(
    HBITMAP * phBmp
)
{
    ASSERT(phBmp);

    HRESULT hr = E_FAIL;

    TraceMsg(TF_CDFLOGO, "<IN > CIconHandler::Extract (Logo) tid:0x%x",
             GetCurrentThreadId());

    if (m_bstrImageURL)
    {
        hr = ExtractCustomImage(&m_rgSize, phBmp);
    }
 
    // Let the extractor build a default logo.
    //if (FAILED(hr))
    //    hr = ExtractDefaultImage(pSize, phBmp);

    TraceMsg(TF_CDFLOGO, "<OUT> CIconHandler::Extract (Logo) tid:0x%x",
             GetCurrentThreadId());

    return hr;
}


//
// Helper functions.
//


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::IsDefaultChannel***
//
//
// Description:
//     Checks to see if the channel we are dealing with is a default one.
//
// Parameters:
//     None.
//
// Return:
//     TRUE if it is a default channel.
//     FALSE otherwise.
//
// Comments:
//     This is used in an attempt to avoid parsing the CDF if the only
//     information we need is already in the desktop.ini file.
//     
////////////////////////////////////////////////////////////////////////////////

BOOL CIconHandler::IsDefaultChannel()
{
    BOOL fDefault = FALSE;
    
    // get the desktop.ini path and see if it points to the systemdir\web
    BSTR pstrURL = CPersist::ReadFromIni( TSTR_INI_URL );
    if ( pstrURL )
    {
        fDefault = Channel_CheckURLMapping( pstrURL );
        SysFreeString( pstrURL );
    }
    return fDefault;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::ParseCdfIcon ***
//
//
// Description:
//     Parses the cdf file associated with this folder.
//
// Parameters:
//     None.
//
// Return:
//     S_OK if the cdf file was found and successfully parsed.
//     E_FAIL otherwise.
//
// Comments:
//     This parse function gets the root channel item and uses it to create
//     a CExtractIcon object.  The CExtractIcon object is later called to get
//     the icon location and extract the icon.
//     
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::ParseCdfIcon(
    void
)
{
    HRESULT hr;

    //
    // Parse the file and get back the root channel element.
    //

    IXMLDocument* pIXMLDocument = NULL;

    TraceMsg(TF_CDFICON, "Extracting icon URL for %s",
             PathFindFileName(m_szPath));
    TraceMsg(TF_CDFPARSE, "Extracting icon URL for %s",
             PathFindFileName(m_szPath));

    hr = CPersist::ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        m_fDrawGleam = CPersist::IsUnreadCdf();

        IXMLElement*    pIXMLElement;
        LONG            nIndex;

        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            PCDFITEMIDLIST pcdfidl = CDFIDL_CreateFromXMLElement(pIXMLElement,
                                                                 nIndex);

            if (pcdfidl)
            {
                //
                // Create a CExtractIcon object for the root channel.
                //

                m_pIExtractIcon = (IExtractIcon*)new CExtractIcon(pcdfidl,
                                                    pIXMLElement);

                hr = m_pIExtractIcon ? S_OK : E_OUTOFMEMORY;

                CDFIDL_Free(pcdfidl);
            }

            pIXMLElement->Release();
        }
    }

    if (pIXMLDocument)
        pIXMLDocument->Release();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::ParseCdfImage ***
//
//
// Description:
//     Parses the cdf file associated with this folder.
//
// Parameters:
//     [In]  pbstrURL - A pointer that receives the URL for the image associated
//                      with the root channel.
//
// Return:
//     S_OK if the URL was found.
//     E_FAIL if the URL wasn't found.
//
// Comments:
//     This function parses the cdf file and returns an URL to the image
//     associated with this cdf file.
//     
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::ParseCdfImage(
    BSTR* pbstrURL,
    BSTR* pbstrWURL
)
{
    ASSERT(pbstrURL);

    HRESULT hr;

    *pbstrURL = NULL;

    IXMLDocument* pIXMLDocument = NULL;

    //
    // Parse the file.
    //

    TraceMsg(TF_CDFPARSE, "Extracting logo URL for %s",
             PathFindFileName(m_szPath));
    TraceMsg(TF_CDFLOGO, "Extracting logo URL for %s",
             PathFindFileName(m_szPath));

    hr = CPersist::ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        m_fDrawGleam = CPersist::IsUnreadCdf();

        //
        // Get the first channel element.
        //

        IXMLElement*    pIXMLElement;
        LONG            nIndex;

        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            //
            // Get the logo URL of the first channel element.
            //

            *pbstrURL = XML_GetAttribute(pIXMLElement, XML_LOGO);

            hr = *pbstrURL ? S_OK : E_FAIL;

            *pbstrWURL = XML_GetAttribute(pIXMLElement, XML_LOGO_WIDE);

            pIXMLElement->Release();
        }
    }

    if (pIXMLDocument)
        pIXMLDocument->Release();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::ParseCdfShellLink(
    void
)
{
    //
    // Parse the file and get back the root channel element.
    //

    IXMLDocument* pIXMLDocument = NULL;

    TraceMsg(TF_CDFPARSE, "Extracting IShellLink for %s",
             PathFindFileName(m_szPath));

    HRESULT hr = CPersist::ParseCdf(NULL, &pIXMLDocument,
                                    PARSE_LOCAL | PARSE_REMOVEGLEAM);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        IXMLElement*    pIXMLElement;
        LONG            nIndex;

        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            m_pcdfidl = CDFIDL_CreateFromXMLElement(pIXMLElement,
                                                    nIndex);

            pIXMLElement->Release();
        }
    }
    else if (OLE_E_NOCACHE == hr)
    {
        //
        // If it wasn't in the cache pass the url of the cdf so it gets reloaded.
        //

        BSTR bstrURL = CPersist::ReadFromIni(TSTR_INI_URL);

        if (bstrURL)
        {
            if (InternetGetConnectedState(NULL, 0))
            {
                int cch = StrLenW(bstrURL) + 1;
                m_pszErrURL = new TCHAR[cch];

                if (m_pszErrURL)
                {
                    if (!SHUnicodeToTChar(bstrURL, m_pszErrURL, cch))
                    {
                        delete []m_pszErrURL;
                        m_pszErrURL = NULL;
                    }
                }
            }
            else
            {
                TCHAR   szResURL[INTERNET_MAX_URL_LENGTH];

                ASSERT(NULL == m_pszErrURL);

                if (SUCCEEDED(MLBuildResURLWrap(TEXT("cdfvwlc.dll"),
                                                g_hinst,
                                                ML_CROSSCODEPAGE,
                                                TEXT("cacheerr.htm#"),
                                                szResURL,
                                                ARRAYSIZE(szResURL),
                                                TEXT("cdfview.dll"))))
                {
                    int cchPrefix = StrLen(szResURL);

                    int cch = StrLenW(bstrURL) + cchPrefix + 1;

                    m_pszErrURL = new TCHAR[cch];

                    if (m_pszErrURL && 
                        (!StrCpyN(m_pszErrURL, szResURL, cch) ||
                         !SHUnicodeToTChar(bstrURL, m_pszErrURL + cchPrefix, cch - cchPrefix)))
                    {
                            delete []m_pszErrURL;
                            m_pszErrURL = NULL;
                    }
                }
            }
             
            SysFreeString(bstrURL);
        }

    }
    else
    {
        DWORD dwSize = sizeof(TCHAR[CDFERROR_MAX_URL_LENGTH_ENCODED]);  // count in bytes
        if (NULL==m_pszErrURL)
          m_pszErrURL = new TCHAR[CDFERROR_MAX_URL_LENGTH_ENCODED];
        if (m_pszErrURL)
        {
            if (pIXMLDocument)
            {
                if ( FAILED(MakeXMLErrorURL(m_pszErrURL, dwSize / sizeof(TCHAR), pIXMLDocument)) )
                {
                    delete[] m_pszErrURL;
                    m_pszErrURL = NULL;
                }
            }
        }
    }

    if (pIXMLDocument)
        pIXMLDocument->Release();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::ParseCdfInfoTip(
    void** ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    //
    // Parse the file and get back the root channel element.
    //

    IXMLDocument* pIXMLDocument = NULL;

    TraceMsg(TF_CDFPARSE, "Extracting IQueryInfo for %s",
             PathFindFileName(m_szPath));

    hr = CPersist::ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        IXMLElement*    pIXMLElement;
        LONG            nIndex;

        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            *ppv = (IQueryInfo*)new CQueryInfo(pIXMLElement, XML_IsFolder(pIXMLElement));

            hr = *ppv ? S_OK : E_FAIL;

            pIXMLElement->Release();
        }
    }
    else
    {
        //
        // Even if the cdf isn't in the cache, return a IQueryInfo interface.
        // The caller can stil call GetInfoFlags.
        //

        *ppv = (IQueryInfo*)new CQueryInfo(NULL, FALSE);

        hr = *ppv ? S_OK : E_FAIL;
    }

    if (pIXMLDocument)
        pIXMLDocument->Release();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::ExtractCustomImage ***
//
//
// Description:
//     Extract an image from an URL.
//
// Parameters:
//     [In]  pSize - The requested size of the image.
//     [Out] phBmp - The returned bitmap.
//
// Return:
//     S_OK if the bitmap was successfully extracted.
//     E_FAIL otherwise.
//
// Comments:
//     The URL of the image is in m_bstrImageURL and was set when the cdf
//     file was parsed.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::ExtractCustomImage(
    const SIZE* pSize,
    HBITMAP* phBmp
)
{
    ASSERT(pSize);
    ASSERT(phBmp);

    HRESULT hr;

    IImgCtx* pIImgCtx;

    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                              IID_IImgCtx, (void**)&pIImgCtx);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIImgCtx);

        hr = SynchronousDownload(pIImgCtx,
                                (UseWideLogo(pSize->cx) && m_bstrImageWideURL) ?
                                                            m_bstrImageWideURL :
                                                            m_bstrImageURL);

        //
        // If the load of the wide logo failed try and use the regular logo.
        //

        if (FAILED(hr) && UseWideLogo(pSize->cx) && m_bstrImageWideURL &&
            m_bstrImageURL)
        {
            hr = SynchronousDownload(pIImgCtx, m_bstrImageURL);

            SysFreeString(m_bstrImageWideURL);
            m_bstrImageWideURL = NULL;
        }

        if (SUCCEEDED(hr))
        {
            hr = GetBitmap(pIImgCtx, pSize, phBmp);
            
            if (FAILED(hr))
                *phBmp = NULL;
        }

        pIImgCtx->Release();
    }

    if (bCoInit)
        CoUninitialize();

    ASSERT((SUCCEEDED(hr) && *phBmp) || (FAILED(hr) && NULL == *phBmp));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::ExtractDefaultImage ***
//
//
// Description:
//     Returns the default channel bitmap.
//
//     [In]  pSize - The requested size of the image.
//     [Out] phBmp - The returned bitmap.
//
// Return:
//     S_OK if the bitmap was successfully extracted.
//     E_FAIL otherwise.
//
// Comments:
//     If a cdf doesn't specify a logo image or the logo image couldn't be
//     downloaded a default image is used.
//
////////////////////////////////////////////////////////////////////////////////
/*HRESULT
CIconHandler::ExtractDefaultImage(
    const SIZE* pSize,
    HBITMAP* phBmp
)
{
    ASSERT(pSize);
    ASSERT(phBmp);

    HRESULT hr;

    hr = GetBitmap(NULL, pSize, phBmp);

    if (FAILED(hr))
        *phBmp = NULL;

    ASSERT((SUCCEEDED(hr) && *phBmp) || (FAILED(hr) && NULL == *phBmp));

    return hr;
}*/

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::GetBitmap ***
//
//
// Description:
//     Gets the requested bitmap
//
// Parameters:
//     [In]  pIImgCtx - The ImgCtx of the image.  NULL if the default image is
//                      to be returned.
//     [In]  pSize    - The requested size of the image.
//     [Out] phBmp    - A pointer that receives the returned image.
//
// Return:
//     S_OK if the image was extracted.
//     E_FAIL otherwise.
//
// Comments:
//     This function conatins code that is shared by the custom image extractor
//     and the default image extractor.  The pIImhCtx parameter is used as a
//     flag indicating which image - default or custom - is to be extracted.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::GetBitmap(
    IImgCtx* pIImgCtx,
    const SIZE* pSize,
    HBITMAP* phBmp
)
{
    ASSERT(pSize);
    ASSERT(phBmp);

    HRESULT hr = E_FAIL;

    //
    // REVIEW: Pallete use for 8bpp DCs?
    //

    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        HDC hdcDst = CreateCompatibleDC(NULL);

        if (hdcDst)
        {
            LPVOID lpBits;
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
            dib.bi.biWidth           = pSize->cx;
            dib.bi.biHeight          = pSize->cy;
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) m_dwClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = 0;
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = ( m_dwClrDepth <= 8 ) ? (1 << m_dwClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            if ( m_dwClrDepth <= 8 )
            {
                HPALETTE hpal = NULL;
                // need to get the right palette....
                hr = pIImgCtx->GetPalette( & hpal );
                if ( SUCCEEDED( hr ) && hpal )
                {
                    GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }
            
            *phBmp = CreateDIBSection(hdcDst, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &lpBits, NULL, 0);

            HBITMAP hOld = (HBITMAP) SelectObject( hdcDst, *phBmp );
            if (*phBmp && hOld)
            {
                RECT rc;
                rc.top = rc.left = 0;
                rc.bottom = pSize->cy;
                rc.right = pSize->cx;

                // black background...
                HBRUSH hbr = (HBRUSH) GetStockObject( BLACK_BRUSH );
                
                FillRect( hdcDst, &rc, hbr );
                DeleteObject( hbr );
        
                if (pIImgCtx)
                {
                    hr = StretchBltCustomImage(pIImgCtx, pSize, hdcDst);
                }
                else
                {
                    hr = E_FAIL; //StretchBltDefaultImage(pSize, hdcDst);
                }
                SelectObject( hdcDst, hOld );
            }

            DeleteDC(hdcDst);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    ASSERT((SUCCEEDED(hr) && *phBmp) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::StretchBltCustomImage ***
//
//
// Description:
//     Stretches the image associated with IImgCtx to the given size and places
//     the result in the given DC.
//
// Parameters:
//     [In]  pIImgCtx  - The image context for the image.
//     [In]  pSize     - The size of the resultant image.
//     [In/Out] hdcDst - The destination DC of the stretch blt.
//
// Return:
//     S_OK if the image was successfully resized into the destination DC.
//     E_FAIL otherwise.
//
// Comments:
//     The destination DC already a bitmap of pSize selected into it.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::StretchBltCustomImage(
    IImgCtx* pIImgCtx,
    const SIZE* pSize,
    HDC hdcDst
)
{
    ASSERT(pIImgCtx);
    ASSERT(hdcDst);

    HRESULT hr;

    SIZE    sz;
    ULONG   fState;

    hr = pIImgCtx->GetStateInfo(&fState, &sz, FALSE);

    if (SUCCEEDED(hr))
    {
        HPALETTE hpal = NULL;
        HPALETTE hpalOld;

        hr = pIImgCtx->GetPalette( &hpal );
        if (hpal)
        {
            hpalOld = SelectPalette( hdcDst, hpal, TRUE );
            RealizePalette( hdcDst );
        }

        if (UseWideLogo(pSize->cx) && NULL == m_bstrImageWideURL)
        {
            hr = pIImgCtx->StretchBlt(hdcDst, 0, 0, LOGO_WIDTH, pSize->cy, 0, 0,
                                      sz.cx, sz.cy, SRCCOPY);

            if (SUCCEEDED(hr))
            {
                //
                // Color fill the logo.
                //

                COLORREF clr = GetPixel(hdcDst, 0, 0);

                if (m_dwClrDepth <= 8)
                     clr = PALETTEINDEX(GetNearestPaletteIndex(hpal, clr));

                HBRUSH hbr = CreateSolidBrush(clr);

                if (hbr)
                {
                    RECT rc;
                    
                    rc.top    = 0;
                    rc.bottom = pSize->cy;
                    rc.left   = LOGO_WIDTH;
                    rc.right  = pSize->cx;

                    FillRect(hdcDst, &rc, hbr);

                    DeleteObject(hbr);
                }
            }
        }
        else
        {
            hr = pIImgCtx->StretchBlt(hdcDst, 0, 0, pSize->cx, pSize->cy, 0, 0,
                                      sz.cx, sz.cy, SRCCOPY);
        }

        if (SUCCEEDED(hr) && m_fDrawGleam)
            DrawGleam(hdcDst);

        if ( hpal )
        {
            SelectPalette( hdcDst, hpalOld, TRUE );
            RealizePalette( hdcDst );
        }
    }

    return hr;
}    

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::StretchBltDefaultImage ***
//
//
// Description:
//     Stretches the deafult channel image to fit the requested size.
//
// Parameters:
//     [In]  pSize      - The requested size of the image.
//     [In/Out] hdcDest - The destination DC for the resized image.
//
// Return:
//     S_OK if the image is successfully resized into the destination DC.
//     E_FAIL otherwise.
//
// Comments:
//     This function creates a source DC, copies the deafult bitmap into the
//     the source DC, then strch blts the source DC into the destination DC.
//
////////////////////////////////////////////////////////////////////////////////
/*HRESULT
CIconHandler::StretchBltDefaultImage(
    const SIZE* pSize,
    HDC hdcDst
)
{
    ASSERT(hdcDst);

    HRESULT hr = E_FAIL;

    HBITMAP hBmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_DEFAULT));

    if (hBmp)
    {
        HDC hdcSrc = CreateCompatibleDC(NULL);

        if (hdcSrc && SelectObject(hdcSrc, hBmp))
        {
            BITMAP bmp;

            if (GetObject(hBmp, sizeof(BITMAP), (void*)&bmp))
            {
                if (StretchBlt(hdcDst, 0, 0, pSize->cx, pSize->cy,
                               hdcSrc, 0, 0, bmp.bmWidth, bmp.bmHeight,
                               SRCCOPY))
                {
                    hr = S_OK;
                }
            }

            DeleteDC(hdcSrc);
        }

        DeleteObject(hBmp);
    }

    return hr;
}*/

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::DrawGleam ***
//
//
// Description:
//
// Parameters:
//
// Return:
//
// Comments:
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::DrawGleam(
    HDC hdcDst
)
{
    ASSERT(hdcDst)

    HRESULT hr = E_FAIL;

    HICON hGleam = (HICON)LoadImage(g_hinst, TEXT("LOGOGLEAM"),
                                    IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

    if (hGleam)
    {
        if (DrawIcon(hdcDst, 1, 1, hGleam))
            hr = S_OK;

        DestroyIcon(hGleam);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::SynchronousDownload ***
//
//
// Description:
//     Synchronously downloads the image associated with the image context.
//
// Parameters:
//     [In]  pIImgCtx - A pointer to the image context.
//
// Return:
//     S_OK if the image was successfully downloaded.
//     E_FAIL if the image wasn't downloaded.
//
// Comments:
//     The image context object doesn't directly support synchronous download.
//     Here a message loop is used to make sure ulrmon keeps geeting messages
//     and the download progresses.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CIconHandler::SynchronousDownload(
    IImgCtx* pIImgCtx,
    LPCWSTR pwszURL
)
{
    ASSERT(pIImgCtx);

    HRESULT hr;

    TCHAR szLocalFile[MAX_PATH];
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL));

    hr = URLGetLocalFileName(szURL, szLocalFile, ARRAYSIZE(szLocalFile), NULL);

    TraceMsg(TF_GLEAM, "%c Logo Extract  %s", m_fDrawGleam ? '+' : '-',
             szLocalFile);    

    if (SUCCEEDED(hr))
    {
        TraceMsg(TF_CDFLOGO, "[URLGetLocalFileName %s]", szLocalFile);

#ifdef UNIX
        unixEnsureFileScheme(szLocalFile);
#endif /* UNIX */

        WCHAR szLocalFileW[MAX_PATH];

        SHTCharToUnicode(szLocalFile, szLocalFileW, ARRAYSIZE(szLocalFileW));

        hr = pIImgCtx->Load(szLocalFileW, 0);

        if (SUCCEEDED(hr))
        {
            ULONG fState;
            SIZE  sz;

            pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

            if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
            {
                m_fDone = FALSE;

                hr = pIImgCtx->SetCallback(ImgCtx_Callback, &m_fDone);

                if (SUCCEEDED(hr))
                {
                    hr = pIImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);

                    if (SUCCEEDED(hr))
                    {
                        MSG msg;
                        BOOL fMsg;

                        // HACK: restrict the message pump to those messages we know that URLMON and
                        // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                        // HACK: windows we shouldn't be pumping right now...
                        while(!m_fDone )
                        {
                            fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                            if (!fMsg)
                            {
                                fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                            }

                            if (!fMsg)
                            {
                                // go to sleep until we get a new message....
                                WaitMessage();
                                continue;
                            }

                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                    }
                }

                pIImgCtx->Disconnect();
            }

            hr = pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

            if (SUCCEEDED(hr))
                hr = (fState & IMGLOAD_COMPLETE) ? S_OK : E_FAIL;
        }
    }
    else
    {
        TraceMsg(TF_CDFLOGO, "[URLGetLocalFileName %s FAILED]",szURL);
    }

    TraceMsg(TF_CDFPARSE, "[IImgCtx downloading logo %s %s]", szLocalFile,
             SUCCEEDED(hr) ? TEXT("SUCCEEDED") : TEXT("FAILED"));
    TraceMsg(TF_CDFLOGO, "[IImgCtx downloading logo %s %s]", szLocalFile,
             SUCCEEDED(hr) ? TEXT("SUCCEEDED") : TEXT("FAILED"));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Run *** 
//
//   IRunnableTask method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Run(
    void
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Kill *** 
//
//   IRunnableTask method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Kill(
    BOOL fWait
)
{
    m_fDone = TRUE;

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Suspend *** 
//
//   IRunnableTask method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Suspend(
    void
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::Resume *** 
//
//   IRunnableTask method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIconHandler::Resume(
    void
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CIconHandler::IsRunning *** 
//
//   IRunnableTask method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CIconHandler::IsRunning(
    void
)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\itemmenu.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// itemmenu.cpp 
//
//   IConextMenu for folder items.
//
//   History:
//
//       3/26/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "itemmenu.h"
#include "dll.h"
#include "resource.h"

#include <mluisupp.h>

//  In Shdocvw: shbrowse.cpp
#ifndef UNIX
extern HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);
#else
extern "C" HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);
#endif /* UNIX */
//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::CContextMenu ***
//
//    Constructor for IContextMenu.
//
////////////////////////////////////////////////////////////////////////////////
CContextMenu::CContextMenu (
	PCDFITEMIDLIST* apcdfidl,
    LPITEMIDLIST pidlPath,
    UINT nCount
)
: m_cRef(1)
{
    //
    // Copy the pcdfidls.
    //

    ASSERT(apcdfidl || 0 == nCount);

    ASSERT(NULL == m_apcdfidl);
    ASSERT(NULL == m_pidlPath);

    //
    // In low memory situations pidlPath may be NULL.
    //

    if (pidlPath)
        m_pidlPath = ILClone(pidlPath);

    IMalloc* pIMalloc;

    if (SUCCEEDED(SHGetMalloc(&pIMalloc)))
    {
        ASSERT(pIMalloc);

        m_apcdfidl = (PCDFITEMIDLIST*)pIMalloc->Alloc(
                                               nCount * sizeof(PCDFITEMIDLIST));

        if (m_apcdfidl)
        {
            for (UINT i = 0, bOutOfMem = FALSE; (i < nCount) && !bOutOfMem; i++)
            {
                ASSERT(CDFIDL_IsValid(apcdfidl[i]));
                ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)apcdfidl[i])));

                m_apcdfidl[i] = (PCDFITEMIDLIST)ILClone(
                                                     (LPITEMIDLIST)apcdfidl[i]);

                if (bOutOfMem = (NULL == m_apcdfidl[i]))
                {
                    while (i--)
                        pIMalloc->Free(m_apcdfidl[i]);

                    pIMalloc->Free(m_apcdfidl);
                    m_apcdfidl = NULL;
                }
                else
                {
                    ASSERT(CDFIDL_IsValid(m_apcdfidl[i]));
                }
            }
        }

        pIMalloc->Release();
    }

    m_nCount = m_apcdfidl ? nCount : 0;

    //
    // Don't allow the DLL to unload.
    //

    TraceMsg(TF_OBJECTS, "+ IContextMenu");

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::~CContextMenu ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CContextMenu::~CContextMenu (
	void
)
{
    ASSERT(0 == m_cRef);

    //
    // Free the locally stored cdfidls.
    //

    if (m_apcdfidl)
    {
        IMalloc* pIMalloc;

        if (SUCCEEDED(SHGetMalloc(&pIMalloc)))
        {
            ASSERT(pIMalloc);

            while (m_nCount--)
            {
                ASSERT(CDFIDL_IsValid(m_apcdfidl[m_nCount]));
                ASSERT(pIMalloc->DidAlloc(m_apcdfidl[m_nCount]));

                pIMalloc->Free(m_apcdfidl[m_nCount]);
            }

            ASSERT(pIMalloc->DidAlloc(m_apcdfidl));

            pIMalloc->Free(m_apcdfidl);

            pIMalloc->Release();
        }
    }

    if (m_pidlPath)
        ILFree(m_pidlPath);

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IContextMenu");

    DllRelease();

	return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::CContextMenu ***
//
//    CExtractIcon QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CContextMenu::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IContextMenu2 == riid)
    {
        *ppv = (IContextMenu2*)this;
    }
    else if (IID_IContextMenu == riid)
    {
        *ppv = (IContextMenu*)this;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    
    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::AddRef ***
//
//    CContextMenu AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CContextMenu::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::Release ***
//
//    CContextMenu Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CContextMenu::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IContextMenu methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::QueryContextMenu ***
//
//
// Description:
//     Adds menu items to the given item's context menu.
//
// Parameters:
//     [In Out]  hmenu      - A handle to the menu.  New items are inserted into
//                            this menu  
//     [In]      indexMenu  - Zero-based position at which to insert the first
//                            menu item.
//     [In]      idCmdFirst - Minimum value that can be used for a new menu item
//                            identifier. 
//     [In]      idCmdLast  - Maximum value the can be used for a menu item id.
//     [In]      uFlags     - CMF_DEFAULTONLY, CMF_EXPLORE, CMF_NORMAL or
//                            CMF_VERBSONLY.
//
// Return:
//     On success the scode contains the the menu identifier offset of the last
//     menu item added plus one.
//
// Comments:
//     CMF_DEFAULTONLY flag indicates the user double-clicked on the item.  In
//     this case no menu is displayed.  The shell is simply querying for the ID
//     of the default action.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CContextMenu::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
)
{
    ASSERT(hmenu);
    ASSERT(idCmdFirst < idCmdLast);

    HRESULT hr;

    if (CMF_DEFAULTONLY & uFlags)
    {
        ASSERT(idCmdFirst + IDM_OPEN < idCmdLast);

        InsertMenu(hmenu, indexMenu, MF_BYPOSITION, idCmdFirst + IDM_OPEN,
                   TEXT(""));

        SetMenuDefaultItem(hmenu, idCmdFirst + IDM_OPEN, FALSE);

        hr = S_OK;
    }
    else
    {
        ASSERT(idCmdFirst + IDM_PROPERTIES < idCmdLast);

        HMENU hmenuParent = LoadMenu(MLGetHinst(),
                                     MAKEINTRESOURCE(IDM_CONTEXTMENU));

        if (hmenuParent)
        {
            HMENU hmenuContext = GetSubMenu(hmenuParent, 0);

            if (hmenuContext)
            {
                ULONG idNew = Shell_MergeMenus(hmenu, hmenuContext, indexMenu,
                                               idCmdFirst, idCmdLast,
                                               MM_ADDSEPARATOR |
                                               MM_SUBMENUSHAVEIDS);

                SetMenuDefaultItem(hmenu, idCmdFirst + IDM_OPEN, FALSE);

                hr = 0x000ffff & idNew;

                DestroyMenu(hmenuContext);
            }
            else
            {
                hr = E_FAIL;
            }

            DestroyMenu(hmenuParent);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::InvokeCommand ***
//
//
// Description:
//     Carries out the command for the given menu item id.
//
// Parameters:
//     [In]  lpici - Structure containing the verb, hwnd, menu id, etc.
//
// Return:
//     S_OK if the command was successful.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CContextMenu::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
)
{
    ASSERT(lpici);

    HRESULT hr;

    if (HIWORD(lpici->lpVerb))
    {
        hr = E_NOTIMPL;
    }
    else
    {
        WORD wCmd = LOWORD(lpici->lpVerb);

        switch(wCmd)
        {
        case IDM_OPEN:
            hr = DoOpen(lpici->hwnd, lpici->nShow);
            break;

        case IDM_PROPERTIES:
            hr = DoProperties(lpici->hwnd);
            break;

        default:
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::GetCommandString ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//      note -- return an ANSI command string
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CContextMenu::GetCommandString(
    UINT_PTR idCommand,
    UINT uFlags,
    UINT *pwReserved,
    LPSTR pszName,
    UINT cchMax
)
{
    HRESULT hr = E_FAIL;

    if ((uFlags == GCS_VERB) && (idCommand == IDM_OPEN))
    {
        StrCpyN((LPTSTR)pszName, TEXT("open"), cchMax);
        hr = NOERROR;
    }
#ifdef UNICODE
    else if ((uFlags == GCS_VERBA) && (idCommand == IDM_OPEN))
    {
        StrCpyNA(pszName, "open", cchMax);
        hr = NOERROR;
    }
#endif

    return hr;
}


//
// IContextMenu2 methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::HandleMenuMsg ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CContextMenu::HandleMenuMsg(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    return S_OK;
}


//
// Helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::DoOpen ***
//
//
// Description:
//     Command handler for IDM_OPEN.
//
// Parameters:
//     [In]  hwnd  - Parent window.  Used for dialogs etc.
//     [In]  nShow - ShowFlag use in ShowWindow command.
//
// Return:
//     S_OK if the command executed.
//     E_FAIL if the command iddn't execute.
//     E_OUTOFMEMORY if there wasn't enough memory to execute the command.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CContextMenu::DoOpen(
    HWND hwnd,
    int  nShow
)
{
    HRESULT hr;

    if (m_apcdfidl)
    {
        ASSERT(CDFIDL_IsValid(m_apcdfidl[0]));
        ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)m_apcdfidl[0])));

        if (CDFIDL_IsFolder(m_apcdfidl[0]))
        {
            hr = DoOpenFolder(hwnd, nShow);
        }
        else
        {
            hr = DoOpenStory(hwnd, nShow);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::DoOpenFolder ***
//
//
// Description:
//     Open command for folders.
//
// Parameters:
//     [In]  hwnd  - Parent window.  Used for dialogs etc.
//     [In]  nShow - ShowFlag use in ShowWindow command.
//
// Return:
//     S_OK if the command executed.
//     E_FAIL if the command iddn't execute.
//     E_OUTOFMEMORY if there wasn't enough memory to execute the command.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CContextMenu::DoOpenFolder(
    HWND hwnd,
    int  nShow
)
{
    HRESULT hr;

    if (m_pidlPath)
    {
        ASSERT(m_apcdfidl);
        ASSERT(CDFIDL_IsValid(m_apcdfidl[0]));
        ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)m_apcdfidl[0])));

        LPITEMIDLIST pidlFull = ILCombine(m_pidlPath,
                                          (LPITEMIDLIST)m_apcdfidl[0]);

        if (pidlFull)
        {
            SHELLEXECUTEINFO ei = {0};

            ei.cbSize   = sizeof(SHELLEXECUTEINFO);
            ei.fMask    = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
            ei.hwnd     = hwnd;
            ei.lpVerb   = TEXT("Open");
            ei.nShow    = nShow;
            ei.lpIDList = (LPVOID)pidlFull;
            ei.lpClass  = TEXT("Folder");

            hr = ShellExecuteEx(&ei) ? S_OK : E_FAIL;

            ILFree(pidlFull);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::DoOpenStory ***
//
//
// Description:
//     Open command for stories (internet links).
//
// Parameters:
//     [In]  hwnd  - Parent window.  Used for dialogs etc.
//     [In]  nShow - ShowFlag use in ShowWindow command.
//
// Return:
//     S_OK if ShellExecuteEx succeeded.
//     E_FAIL if ShellExecuteEx didn't succeed.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CContextMenu::DoOpenStory(
    HWND hwnd,
    int  nShow
)
{
    ASSERT(m_apcdfidl);
    ASSERT(CDFIDL_IsValid(m_apcdfidl[0]));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)m_apcdfidl[0])));

    HRESULT hr = E_FAIL;

    LPTSTR pszURL = CDFIDL_GetURL(m_apcdfidl[0]); 

    if (PathIsURL(pszURL))
    {
    
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
        HWND hwndTemp = (HWND)-1;
        BSTR bstrURL;

        SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
        bstrURL = SysAllocString(wszURL);
        if (bstrURL)
        {
            hr = CDDEAuto_Navigate(bstrURL, &hwndTemp, 0);
            SysFreeString(bstrURL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::DoProperties ***
//
//
// Description:
//     Command handler for IDM_PROPERTIES.
//
// Parameters:
//     [In]  hwnd  - Parent window.  Used for dialogs etc.
//
// Return:
//     S_OK if the command executed.
//     E_FAIL if the command iddn't execute.
//     E_OUTOFMEMORY if there wasn't enough memory to execute the command.
//
// Comments:
//     Uses the property pages of the InternetShortcut object.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CContextMenu::DoProperties(
    HWND hwnd
)
{
    HRESULT hr;

    if (m_apcdfidl)
    {
        ASSERT(CDFIDL_IsValid(m_apcdfidl[0]));
        ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)m_apcdfidl[0])));

        IShellPropSheetExt* pIShellPropSheetExt;

        hr = QueryInternetShortcut(m_apcdfidl[0], IID_IShellPropSheetExt,
                                   (void**)&pIShellPropSheetExt);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIShellPropSheetExt);

            PROPSHEETHEADER psh = {0};
            HPROPSHEETPAGE  ahpage[MAX_PROP_PAGES];

            psh.dwSize     = sizeof(PROPSHEETHEADER);
            psh.dwFlags    = PSH_NOAPPLYNOW;
            psh.hwndParent = hwnd;
            psh.hInstance  = MLGetHinst();
            psh.pszCaption = CDFIDL_GetName(m_apcdfidl[0]);
            psh.phpage     = ahpage;

            hr = pIShellPropSheetExt->AddPages(AddPages_Callback, (LPARAM)&psh);

            if (SUCCEEDED(hr))
            {
                //
                // Property sheets are currently disabled.  This is the only
                // API called in comctl32.dll so remove it to avoid a
                //dependency.

                //hr = (-1 == PropertySheet(&psh)) ? E_FAIL : S_OK;
            }

            pIShellPropSheetExt->Release();
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** AddPages_Callback ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK
AddPages_Callback(
    HPROPSHEETPAGE hpage,
    LPARAM lParam
)
{
    ASSERT(hpage);
    ASSERT(lParam);

    BOOL                bRet;
    PROPSHEETHEADER*    ppsh = (PROPSHEETHEADER*)lParam;

    if (ppsh->nPages < MAX_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

//
//
//

HRESULT CALLBACK
MenuCallBack(
    IShellFolder* pIShellFolder,
    HWND hwndOwner,
    LPDATAOBJECT pdtobj,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::QueryInternetShortcut ***
//
//
// Description:
//     Sets up an internet shorcut object for the given pidl.
//
// Parameters:
//     [In]  pcdfidl - The shortcut object is created for the URL stored in this
//                     cdf item id list.
//     [In]  riid    - The requested interface on the shortcut object.
//     [Out] ppvOut  - A pointer that receives the interface.
//
// Return:
//     S_OK if the object is created and the interface is found.
//     A COM error code otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CContextMenu::QueryInternetShortcut(
    PCDFITEMIDLIST pcdfidl,
    REFIID riid,
    void** ppvOut
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)pcdfidl)));
    ASSERT(ppvOut);

    HRESULT hr;

    *ppvOut = NULL;

    //
    // Only create a shell link object if the CDF contains an URL
    //
    if (*(CDFIDL_GetURL(pcdfidl)) != 0)
    {
        IShellLinkA * pIShellLink;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                              IID_IShellLinkA, (void**)&pIShellLink);
        if (SUCCEEDED(hr))
        {
            ASSERT(pIShellLink);

#ifdef UNICODE
            CHAR szUrlA[INTERNET_MAX_URL_LENGTH];

            SHTCharToAnsi(CDFIDL_GetURL(pcdfidl), szUrlA, ARRAYSIZE(szUrlA));
            hr = pIShellLink->SetPath(szUrlA);
#else
            hr = pIShellLink->SetPath(CDFIDL_GetURL(pcdfidl));
#endif
            if (SUCCEEDED(hr))
            {
                //
                // The description ends up being the file name created.
                //

                TCHAR szPath[MAX_PATH];
#ifdef UNICODE
                CHAR  szPathA[MAX_PATH];
#endif

                StrCpyN(szPath, CDFIDL_GetName(pcdfidl), ARRAYSIZE(szPath) - 5);
                StrCatBuff(szPath, TEXT(".url"), ARRAYSIZE(szPath));
#ifdef UNICODE
                SHTCharToAnsi(szPath, szPathA, ARRAYSIZE(szPathA));
                pIShellLink->SetDescription(szPathA);
#else
                pIShellLink->SetDescription(szPath);
#endif
                hr = pIShellLink->QueryInterface(riid, ppvOut);
            }

            pIShellLink->Release();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    ASSERT((SUCCEEDED(hr) && *ppvOut) || (FAILED(hr) && NULL == *ppvOut));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\globals.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// globals.cpp 
//
//   Contains *all* of the global variables used in cdfview.  Globals shouldn't
//   be declared elsewhere.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"

//
// Global variables.
//

// Remove shared memory segment.  This must be removed so w2k can get a c2
// security rating.  It should no longer be rquired because the cache is 
// going to be limited to one item.
//
//#pragma data_seg("SharedData")
DWORD               g_dwCacheCount = 0;
//#pragma data_seg()

HINSTANCE           g_msxmlInst = NULL;
#ifndef UNIX
/* Unix does not use webcheck */
HINSTANCE           g_webcheckInst = NULL;
#endif /* UNIX */
HINSTANCE           g_hinst   = NULL;
ULONG               g_cDllRef = 0;
PCACHEITEM          g_pCache  = NULL;
CRITICAL_SECTION    g_csCache;
TCHAR               g_szModuleName[MAX_PATH];

const GUID  CLSID_CDFVIEW =
{0xf39a0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x33}};
// {f39a0dc0-9cc8-11d0-a599-00c04fd64433}

const GUID  CLSID_CDFINI =
{0xf3aa0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x34}};
// {f3aa0dc0-9cc8-11d0-a599-00c04fd64434}

const GUID  CLSID_CDFICONHANDLER =
{0xf3ba0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x35}};
// {f3ba0dc0-9cc8-11d0-a599-00c04fd64435}

const GUID  CLSID_CDFMENUHANDLER =
{0xf3da0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x37}};
// {f3da0dc0-9cc8-11d0-a599-00c04fd64437}

const GUID  CLSID_CDFPROPPAGES =
{0xf3ea0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x38}};
// 

const TCHAR c_szChannel[] = TEXT("Channel");
const TCHAR c_szCDFURL[] = TEXT("CDFURL");
const TCHAR c_szHotkey[] = TEXT("Hotkey");
const TCHAR c_szDesktopINI[] = TEXT("desktop.ini");
const TCHAR c_szScreenSaverURL[] = TEXT("ScreenSaverURL");
const WCHAR c_szPropCrawlActualSize[] = L"ActualSizeKB";
const WCHAR c_szPropStatusString[] = L"StatusString";
const WCHAR c_szPropCompletionTime[] = L"CompletionTime";

//  From Plus! tab code
const TCHAR c_szHICKey[] = TEXT("Control Panel\\Desktop\\WindowMetrics"); // show icons using highest possible colors
const TCHAR c_szHICVal[] = TEXT("Shell Icon BPP"); // (4 if the checkbox is false, otherwise 16, don't set it to anything else)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\itemmenu.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// itemmenu.h 
//
//   Conext menu interface for items.
//
//   History:
//
//       3/26/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _ITEMMENU_H_

#define _ITEMMENU_H_

//
// Function prototypes.
//

//
// REVIEW: Prototype for DoFileDownloadEx
//         This function is exported from shdocvw, but doesn't have a prototype
//         defined in any .h file.
// 

HRESULT WINAPI DoFileDownloadEx(LPCWSTR pwszURL, BOOL fSaveAs);

//
// Use a flag to conditionally compile code that uses the default context menu
// handler implemented in shell32.dll.
//

#define USE_DEFAULT_MENU_HANDLER        0

#if USE_DEFAULT_MENU_HANDLER

//
//
//

HRESULT CALLBACK MenuCallBack(IShellFolder* pIShellFolder,
                              HWND hwndOwner,
                              LPDATAOBJECT pdtobj,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#else // USE_DEFAULT_MENU_HANDLER

//
// Defines
//

#define     MAX_PROP_PAGES  5

//
// Function prototypes
//

BOOL CALLBACK AddPages_Callback(HPROPSHEETPAGE hpage, LPARAM ppsh);

//
// Class definition for the item context menu class.
//

class CContextMenu : public IContextMenu2
{
//
// Methods
//

public:

    // Constructor
    CContextMenu(PCDFITEMIDLIST* apcdfidl,
                 LPITEMIDLIST pidlPath, UINT nCount);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu methods.
    STDMETHODIMP QueryContextMenu(HMENU hmenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCommand,
                                  UINT uFLags,
                                  UINT *pwReserved,
                                  LPSTR pszName,
                                  UINT cchMax);

    // IContextMenu2 methods.
    STDMETHODIMP HandleMenuMsg(UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam);

private:

    // Destructor.
    ~CContextMenu(void);

    // Helper functions.
    HRESULT DoOpen(HWND hwnd, int nShow);
    HRESULT DoOpenFolder(HWND hwnd, int nShow);
    HRESULT DoOpenStory(HWND hwnd, int nShow);
    HRESULT DoProperties(HWND hwnd);

    HRESULT QueryInternetShortcut(PCDFITEMIDLIST pcdfidl, REFIID riid,
                                  void** ppvOut);

//
// Member variables.
//

private:

    ULONG           m_cRef;
    UINT            m_nCount;
    PCDFITEMIDLIST* m_apcdfidl;
    LPITEMIDLIST    m_pidlPath;
};

#endif // USE_DEFAULT_MENU_HANDLER


#endif // _ITEMMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\oleobj.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// oleobj.cpp 
//
//   IOleObject Implementation.  IOleObject is required for for downloading
//   cdf files from within the browser.
//
//   History:
//
//       6/18/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "chanapi.h"
#include "chanenum.h"
#include "persist.h"
#include "resource.h"
#include <shguidp.h>
#include <htiface.h>   // IID_ITargetEmbedding
#define _SHDOCVW_
#include <shdocvw.h>

#include <mluisupp.h>

STDMETHODIMP CPersist::SetClientSite(IOleClientSite *pIOleClientSite)
{
#ifdef IMP_CLIENTSITE

    if (NULL != m_pOleClientSite)
        m_pOleClientSite->Release();

    m_pOleClientSite = pIOleClientSite;

    if (m_pOleClientSite)
        m_pOleClientSite->AddRef();

#endif

    if (pIOleClientSite && NULL == m_pIWebBrowser2)
    {
        IOleWindow *pIOleWindow;

        HRESULT hr = pIOleClientSite->QueryInterface(IID_IOleWindow,
                                                     (void**)&pIOleWindow);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pIOleWindow);
            pIOleWindow->GetWindow(&m_hwnd);
            pIOleWindow->Release();
        }

        IServiceProvider* pIServiceProvider;

        hr = pIOleClientSite->QueryInterface(IID_IServiceProvider,
                                             (void**)&pIServiceProvider);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIServiceProvider);

            IServiceProvider* pIServiceProvider2;

            hr = pIServiceProvider->QueryService(SID_STopLevelBrowser,
                                                 IID_IServiceProvider,
                                                 (void**)&pIServiceProvider2);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIServiceProvider2);

                hr = pIServiceProvider2->QueryService(SID_SWebBrowserApp,
                                                      IID_IWebBrowser2,
                                                      (void**)&m_pIWebBrowser2);

                //
                // REVIEW: Determine if the current browser is IE
                //
                // New check if the browser is IE.  IE will fail on a QI of
                // IWebBrowserApp for ITargetEmbedding.  Anyone else hosting
                // the browser OC must support this interface.
                //

                IWebBrowserApp* pIWebBrowserApp;

                hr = m_pIWebBrowser2->QueryInterface(IID_IWebBrowserApp,
                                                     (void**)&pIWebBrowserApp);

                if (SUCCEEDED(hr))
                {
                    ASSERT(pIWebBrowserApp);

                    ITargetEmbedding* pITargetEmbedding;

                    hr = pIWebBrowserApp->QueryInterface(IID_ITargetEmbedding,
                                                    (void**)&pITargetEmbedding); 

                    if (SUCCEEDED(hr))
                    {
                        ASSERT(pITargetEmbedding);

                        //
                        // This isn't IE.  So release m_IWebBrowser2.  IE
                        // will be CoCreated later if m_IWebBrowser2 == NULL.
                        //

                        m_pIWebBrowser2->Release();
                        m_pIWebBrowser2 = NULL;

                        pITargetEmbedding->Release();
                    }

                    pIWebBrowserApp->Release();
                }

                pIServiceProvider2->Release();
            }

            pIServiceProvider->Release();
        }


    }

    return S_OK;
}

STDMETHODIMP CPersist::GetClientSite(IOleClientSite **ppClientSite)
{
#ifdef IMP_CLIENTSITE

    ASSERT(ppClientSite);

    if (NULL != m_pOleClientSite)
    {
        *ppClientSite = m_pOleClientSite;
        return S_OK;
    }
    else
        return E_UNEXPECTED;
#else

    return E_NOTIMPL;

#endif
}

STDMETHODIMP CPersist::SetHostNames(LPCOLESTR szContainerApp,
                          LPCOLESTR szContainerObj)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::Close(DWORD dwSaveOption)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                        IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::InitFromData(IDataObject *pDataObject, BOOL fCreation,
                          DWORD dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite,
                              LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT hr;

    if (OLEIVERB_PRIMARY == iVerb)
    {
        ASSERT(m_pIXMLDocument);

        XMLDOCTYPE xdt = XML_GetDocType(m_pIXMLDocument);

        switch(xdt)
        {
        case DOC_CHANNEL:
        case DOC_SOFTWAREUPDATE:
            // Admins can disallow adding channels and limit
            // the number of installed channels.
            if (1 /*(dwFlags & STC_CHANNEL)*/ &&
                !SHRestricted2W(REST_NoAddingChannels, m_polestrURL, 0) &&
                (!SHRestricted2W(REST_MaxChannelCount, NULL, 0) ||
                (CountChannels() < SHRestricted2W(REST_MaxChannelCount, NULL, 0))))
            {
                XML_DownloadLogo(m_pIXMLDocument);

                //
                // In case the SELF tag is different than the URL get the
                // subscribed URL from SubscriptionHelper.
                //

                BSTR bstrSubscribedURL = NULL;

                if (SubscriptionHelper(m_pIXMLDocument, m_hwnd,
                                       SUBSTYPE_CHANNEL,
                                       SUBSACTION_ADDADDITIONALCOMPONENTS,
                                       m_polestrURL, xdt, &bstrSubscribedURL))
                {
                    TCHAR szSubscribedURL[INTERNET_MAX_URL_LENGTH];

                    if (bstrSubscribedURL &&
                        SHUnicodeToTChar(bstrSubscribedURL, szSubscribedURL,
                                       ARRAYSIZE(szSubscribedURL)))
                    {
                        FILETIME ftLastMod;
                        URLGetLastModTime(szSubscribedURL, &ftLastMod);

                        Cache_AddItem(szSubscribedURL, m_pIXMLDocument,
                                      PARSE_NET, ftLastMod, g_dwCacheCount);
                    }

                    OpenChannel(bstrSubscribedURL);

                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }

                if (bstrSubscribedURL)
                    SysFreeString(bstrSubscribedURL);
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
            break;

        case DOC_DESKTOPCOMPONENT:
#ifndef UNIX
            if (m_hwnd && WhichPlatform() != PLATFORM_INTEGRATED)
#else
            if (0)
#endif /* UNIX */
            {
                TCHAR szText[MAX_PATH];
                TCHAR szTitle[MAX_PATH];

                MLLoadString(IDS_BROWSERONLY_DLG_TEXT,  szText,
                           ARRAYSIZE(szText)); 
                MLLoadString(IDS_BROWSERONLY_DLG_TITLE, szTitle,
                            ARRAYSIZE(szTitle));

                MessageBox(m_hwnd, szText, szTitle, MB_OK); 
            }
            else if (1 /*dwFlags & STC_DESKTOPCOMPONENT*/)
            {
                COMPONENT Info;
                hr = XML_GetDesktopComponentInfo(m_pIXMLDocument, &Info);
                if(SUCCEEDED(hr))
                {
                    if(!Info.wszSubscribedURL[0])
                    {
                        if(m_polestrURL)
                        {
                            StrCpyNW(Info.wszSubscribedURL, m_polestrURL, ARRAYSIZE(Info.wszSubscribedURL));
                        }
                        else
                        {
                            TraceMsg(TF_GENERAL, "CPersist::DoVerb : COMPONENT::wszSubscribedURL is not set.");
                            hr = S_FALSE;
                        }
                    }
#ifndef UNIX
                    /* No Active Desktop on Unix */
                    if (SUCCEEDED(hr))
                    {
                    
                        IActiveDesktop* pIActiveDesktop;
                        hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IActiveDesktop, (void**)&pIActiveDesktop);
                        if (SUCCEEDED(hr))
                        {
                            ASSERT(pIActiveDesktop);

                            hr = pIActiveDesktop->AddDesktopItemWithUI(m_hwnd, &Info, DTI_ADDUI_DISPSUBWIZARD);

                            // Note: Do not call pIActiveDesktop->ApplyChanges() here. AddDesktopItemWithUI() itself creates
                            // one instance of ActiveDesktop object, adds the component and calls ApplyChanges() for us. 
                            // Calling ApplyChanges() again here causes the second instance US to overwrite with stale data.
                            // Bug #404153. Fixed by Sankar. 29th May 2001.

                            pIActiveDesktop->Release();
                        }
                        else
                        {
                            TraceMsg(TF_GENERAL, "CPersist::DoVerb : CoCreateInstance for CLSID_ActiveDesktop failed.");
                        }
                    }
#endif /* !UNIX */
                }
                if(SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
            break;

        case DOC_UNKNOWN:
        default:
            hr = E_FAIL;
            break;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

STDMETHODIMP CPersist::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::Update(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::IsUpToDate(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::GetUserClassID(CLSID *pClsid)
{
    return E_FAIL;
}

STDMETHODIMP CPersist::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::Unadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersist::SetColorScheme(LOGPALETTE *pLogpal)
{
    return E_NOTIMPL;
}

//
// Helper functions.
//

HRESULT
CPersist::OpenChannel(
    LPCWSTR pszSubscribedURL                   
)
{
    ASSERT(m_pIXMLDocument);

    HRESULT hr;

    if (NULL == m_pIWebBrowser2)
    {
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL, 
                                                  CLSCTX_LOCAL_SERVER,
                                                  IID_IWebBrowser2, 
                                                  (void**)&m_pIWebBrowser2);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    
    //m_pIWebBrowser2->put_TheaterMode(-1); Moved to worker window
    //m_pIWebBrowser2->put_Visible(-1);

    //ShowChannelPane(m_pIWebBrowser2);


    IXMLElement*    pIXMLElement;
    LONG            nIndex;

    hr = XML_GetFirstChannelElement(m_pIXMLDocument,
                                    &pIXMLElement, &nIndex);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_HREF);

        if (bstrURL)
        {
            VARIANT vNull = {0};
            VARIANT vFlags = {0};

            //
            // check for null string
            //
            if (*bstrURL != 0)
            {
                HWND hwnd = CreateNavigationWorkerWindow(m_hwnd,
                                                         m_pIWebBrowser2);

                if (hwnd)
                {
                    LPOLESTR pszPath = Channel_GetChannelPanePath(
                                                              pszSubscribedURL);

                    if (pszPath)
                        PostMessage(hwnd, WM_NAVIGATE_PANE, 0, (LPARAM)pszPath);

                    PostMessage(hwnd, WM_NAVIGATE, 0, (LPARAM)bstrURL);                    
                    PostMessage(hwnd, WM_CLOSE, 0, 0);
                }
                else
                {
                    SysFreeString(bstrURL);
                }

            }
            else
            {
                 SysFreeString(bstrURL);
            }

        }

        pIXMLElement->Release();
    }

    return hr;
}

HWND
CPersist::CreateNavigationWorkerWindow(
    HWND hwndParent,
    IWebBrowser2* pIWebBrowser2
)
{
    ASSERT(pIWebBrowser2);

    HWND        hwnd;
    static BOOL fRegistered = FALSE;

    if (!fRegistered) {

        WNDCLASS wc = {0};

        wc.lpfnWndProc      = NavigateWndProc;
        wc.cbWndExtra       = SIZEOF(IWebBrowser2*);
        wc.hInstance        = g_hinst;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH) (COLOR_BTNFACE + 1);
        wc.lpszClassName    = TEXT("NavigationWorker");

        fRegistered = (BOOL)RegisterClass(&wc);
    }

    hwnd = CreateWindow(TEXT("NavigationWorker"), NULL, WS_CHILD, 0, 0, 0, 0,
                        hwndParent, (HMENU)0xED, g_hinst, NULL);

    if (hwnd) {

        ASSERT(sizeof(IWebBrowser2*) == sizeof(LONG));
        
        pIWebBrowser2->AddRef();
        SetWindowLongPtr(hwnd, 0, (LRESULT)pIWebBrowser2);
    }

    return hwnd;
}

LRESULT
CALLBACK
NavigateWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT         lRet = 0;
    IWebBrowser2*   pIWebBrowser2;

    switch (msg)
    {
    case WM_NAVIGATE:
        ASSERT(lParam);

        pIWebBrowser2 = (IWebBrowser2*)GetWindowLongPtr(hwnd, 0);
        
        if (pIWebBrowser2)
        {
            //pIWebBrowser2->put_TheaterMode(-1);
            pIWebBrowser2->put_Visible(-1);

            VARIANT varNull = {0};
            VARIANT varURL;

            varURL.vt      = VT_BSTR;
            varURL.bstrVal = (BSTR)lParam;

            pIWebBrowser2->Navigate2(&varURL, &varNull, &varNull, &varNull,
                                     &varNull);
        }

        SysFreeString((BSTR)lParam);
        break;

    case WM_NAVIGATE_PANE:
        ASSERT(lParam);

        pIWebBrowser2 = (IWebBrowser2*)GetWindowLongPtr(hwnd, 0);
        
        if (pIWebBrowser2)
        {
            if (SUCCEEDED(ShowChannelPane(pIWebBrowser2)))
                NavigateChannelPane(pIWebBrowser2, (LPWSTR)lParam);
        }

        CoTaskMemFree((LPOLESTR)lParam);
        break;

    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:
        pIWebBrowser2 = (IWebBrowser2*)GetWindowLongPtr(hwnd, 0);
        
        if (pIWebBrowser2)
        {
            SetWindowLongPtr(hwnd, 0, 0);
            pIWebBrowser2->Release();
        }
        // Fall through

    default:
        lRet = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\persist.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// persist.cpp 
//
//   IPersistFolder for the cdfview class.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "persist.h"
#include "xmlutil.h"
#include "cdfview.h"
#include "bindstcb.h"
#include "chanapi.h"
#include "resource.h"
#include <winineti.h>  // MAX_CACHE_ENTRY_INFO_SIZE
#include "dll.h"
#define _SHDOCVW_
#include <shdocvw.h>

#include <mluisupp.h>

//
// Constructor and destructor

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::CPersist ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CPersist::CPersist(
    void
)
: m_bCdfParsed(FALSE)
{
    ASSERT(0 == *m_szPath);
    ASSERT(NULL == m_polestrURL);
    ASSERT(NULL == m_pIWebBrowser2);
    ASSERT(NULL == m_hwnd);
    ASSERT(NULL == m_pIXMLDocument);
    ASSERT(FALSE == m_fPendingNavigation);
    ASSERT(IT_UNKNOWN == m_rgInitType);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::CPersist ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CPersist::CPersist(
    BOOL bCdfParsed
)
: m_bCdfParsed(bCdfParsed)
{
    ASSERT(0 == *m_szPath);
    ASSERT(NULL == m_polestrURL);
    ASSERT(NULL == m_pIWebBrowser2);
    ASSERT(NULL == m_hwnd);
    ASSERT(NULL == m_pIXMLDocument);
    ASSERT(FALSE == m_fPendingNavigation);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::CPersist ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CPersist::~CPersist(
    void
)
{
    if (m_fPendingNavigation && m_pIWebBrowser2 && m_pIXMLDocument)
    {
    }

    if (m_polestrURL)
        CoTaskMemFree(m_polestrURL);

    if (m_pIWebBrowser2)
        m_pIWebBrowser2->Release();

    if (m_pIXMLDocument)
        m_pIXMLDocument->Release();

    return;
}


//
// IPersist methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetClassID ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::GetClassID(
    LPCLSID lpClassID
)
{
    ASSERT(lpClassID);

    //
    // REVIEW:  Two possible class IDs CLSID_CDFVIEW & CLSID_CDF_INI
    //

    *lpClassID = CLSID_CDFVIEW;

    return S_OK;
}


//
// IPersistFile methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::IsDirty ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::IsDirty(
    void
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::Load ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::Load(
    LPCOLESTR pszFileName,
    DWORD dwMode
)
{
    ASSERT(pszFileName);

    HRESULT hr;

    if (SHUnicodeToTChar(pszFileName, m_szPath, ARRAYSIZE(m_szPath)))
    {
        hr = S_OK;

        QuickCheckInitType();
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

void CPersist::QuickCheckInitType( void )
{
    // if the path is a directory then
    // it has to be a Shellfolder we were initialised for.
    // we are calculating this here so that we can avoid hitting the disk
    // in GetInitType if at all possible.

    if (PathIsDirectory(m_szPath))
    {
        m_rgInitType = IT_INI;
    }
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::Save ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::Save(
    LPCOLESTR pszFileName,
    BOOL fRemember
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::SaveCompleted ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::SaveCompleted(
    LPCOLESTR pszFileName
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetCurFile ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::GetCurFile(
    LPOLESTR* ppszFileName
)
{
    return E_NOTIMPL;
}


//
// IPersistFolder methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::Initialize ***
//
//
// Description:
//     This function is called with the fully qualified id list (location) of
//     the selected cdf file.
//
// Parameters:
//     [In]  pidl - The pidl of the selected cdf file.  This pidl conatins the
//                  full path to the CDF.
//
// Return:
//     S_OK if content for the cdf file could be created.
//     E_OUTOFMEMORY otherwise.
//
// Comments:
//     This function can be called more than once for a given folder.  When a
//     CDFView is being instantiated from a desktop.ini file the shell calls
//     Initialize once before it calls GetUIObjectOf asking for IDropTarget.
//     After the GetUIObjectOf call the folder is Released.  It then calls
//     Initialize again on a new folder.  This time it keeps the folder and it
//     ends up being displayed.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPersist::Initialize(
    LPCITEMIDLIST pidl
)
{
    ASSERT(pidl);
    ASSERT(0 == *m_szPath);
    HRESULT hr = SHGetPathFromIDList(pidl, m_szPath) ? S_OK : E_FAIL;

    QuickCheckInitType();
    
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::Parse ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPersist::Parse(
    LPTSTR szURL,
    IXMLDocument** ppIXMLDocument
)
{
    ASSERT(szURL);

    HRESULT hr;

    DLL_ForcePreloadDlls(PRELOAD_MSXML);
    
    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDocument, (void**)ppIXMLDocument);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                              IID_IXMLDocument, (void**)ppIXMLDocument);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(*ppIXMLDocument);

        hr = XML_SynchronousParse(*ppIXMLDocument, szURL);
    }

    if (bCoInit)
        CoUninitialize();

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::ParseCdf ***
//
//
// Description:
//     Parses the cdf file associated with this folder.
//
// Parameters:
//     [In]  hwndOwner      - The parent window of any dialogs that need to be
//                            displayed.
//     [Out] ppIXMLDocument - A pointer that receives the xml document.
//
// Return:
//     S_OK if the cdf file was found and successfully parsed.
//     E_FAIL otherwise.
//
// Comments:
//     Uses the m_pidlRoot that was set during IPersistFolder::Initialize.
//     
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPersist::ParseCdf(
    HWND hwndOwner,
    IXMLDocument** ppIXMLDocument,
    DWORD dwParseFlags
)
{
    ASSERT(ppIXMLDocument);

    HRESULT hr;

    if (*m_szPath)
    {
        INITTYPE it = GetInitType(m_szPath);

        switch(it)
        {
        case IT_FILE:
            hr = InitializeFromURL(m_szPath, ppIXMLDocument, dwParseFlags);
            break;

        case IT_INI:
            {
                TCHAR szURL[INTERNET_MAX_URL_LENGTH];

                if (ReadFromIni(TSTR_INI_URL, szURL, ARRAYSIZE(szURL)))
                {
                    hr = InitializeFromURL(szURL, ppIXMLDocument, dwParseFlags);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            break;

        case IT_SHORTCUT:
        case IT_UNKNOWN:
            hr = E_FAIL;
            break;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // REVIEW: Properly notify user on failure to init.
    //

    if (FAILED(hr) && hwndOwner)
    {
        TCHAR szText[MAX_PATH];
        TCHAR szTitle[MAX_PATH];

        MLLoadString(IDS_ERROR_DLG_TEXT,  szText, ARRAYSIZE(szText)); 
        MLLoadString(IDS_ERROR_DLG_TITLE, szTitle, ARRAYSIZE(szTitle));

        MessageBox(hwndOwner, szText, szTitle, MB_OK | MB_ICONWARNING); 
    }

    ASSERT((SUCCEEDED(hr) && *ppIXMLDocument) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::GetInitType ***
//
//
// Description:
//     Determines the method being used to designate the cdf file.
//
// Parameters:
//     [In]  szPath - The path passed in to IPersistFolder::Initialize.
//
// Return:
//     IT_INI if this instance is being created from a desktop.ini file
//     located in a right protected directory.
//     IT_FILE if this instance is being created from opening a cdf file.
//     IT_UNKNOWN if the method can not be determined.
//
// Comments:
//      
//
////////////////////////////////////////////////////////////////////////////////
INITTYPE
CPersist::GetInitType(
    LPTSTR szPath
)
{
    if ( m_rgInitType != IT_UNKNOWN )
    {
        return m_rgInitType;
    }
    
    ASSERT(szPath);

    INITTYPE itRet;

    if (PathIsDirectory(szPath))
    {
        itRet = IT_INI;
    }
    else
    {
        itRet = IT_FILE;
    }

    m_rgInitType = itRet;
    
    return itRet;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::InitializeFromURL ***
//
//
// Description:
//     Given an URL to a cdf an attempt is made to parse the cdf and initialize
//     the current (root) folder.
//
// Parameters:
//     [In]  szURL          - The URL of the cdf file.
//     [Out] ppIXMLDocument - A pointer that receives the xml document.
//
// Return:
//     S_OK if initializtion succeeded.
//     E_FAIL otherwise.
//
// Comments:
//     All other initialize methods eventually resolve to an URL and call this
//     methhod.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPersist::InitializeFromURL(
    LPTSTR pszURL,
    IXMLDocument** ppIXMLDocument,
    DWORD dwParseFlags
)
{
    ASSERT(pszURL);
    ASSERT(ppIXMLDocument);

    HRESULT hr;

    TCHAR szCanonicalURL[INTERNET_MAX_URL_LENGTH];

    if (PathIsURL(pszURL))
    {
        ULONG cch = ARRAYSIZE(szCanonicalURL);

        if (InternetCanonicalizeUrl(pszURL, szCanonicalURL, &cch, 0))
            pszURL = szCanonicalURL;
    }

    //
    // Get an XML document object from the cache if it's there.  Otherwise
    // parse it and place it in the cache.
    //

    if (PARSE_REPARSE & dwParseFlags)
    {
        (void)Cache_RemoveItem(pszURL); 
        hr = E_FAIL;
    }
    else
    {
        hr = Cache_QueryItem(pszURL, ppIXMLDocument, dwParseFlags);

        if (SUCCEEDED(hr))
            TraceMsg(TF_CDFPARSE, "[XML Document Cache]"); 
    }

    if (FAILED(hr))
    {
        DWORD    dwCacheCount = g_dwCacheCount;
        FILETIME ftLastMod;

        if (dwParseFlags & PARSE_LOCAL)
        {
            TCHAR szLocalFile[MAX_PATH];

            hr = URLGetLocalFileName(pszURL, szLocalFile,
                                     ARRAYSIZE(szLocalFile), &ftLastMod);

            if (SUCCEEDED(hr))
            {
                hr = Parse(szLocalFile, ppIXMLDocument);
            }
            else
            {
                hr = OLE_E_NOCACHE;
            }
        }
        else
        {
            TraceMsg(TF_CDFPARSE, "[*** CDF parse enabled to hit net!!! ***]");

            hr = Parse(pszURL, ppIXMLDocument);


            URLGetLastModTime(pszURL, &ftLastMod);

            //
            // Stuff the images files into the cache.
            //

            if (SUCCEEDED(hr))
            {
                ASSERT(*ppIXMLDocument);

                XML_DownloadImages(*ppIXMLDocument);
            }
        }

        if (SUCCEEDED(hr))
        {
            Cache_AddItem(pszURL, *ppIXMLDocument, dwParseFlags, ftLastMod,
                          dwCacheCount);
        }
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(*ppIXMLDocument);

        m_bCdfParsed = TRUE;

        if (dwParseFlags & PARSE_REMOVEGLEAM)
            ClearGleamFlag(pszURL, m_szPath);
    }
    
    ASSERT((SUCCEEDED(hr) && m_bCdfParsed && *ppIXMLDocument) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::ReadFromIni ***
//
//
// Description:
//     Reads a string from the channel desktop.ini file.
//
// Parameters:
//     pszKey - The key to read.
//     szOut  - The result.
//     cch    - The size of the szout Buffer
//
// Return:
//     A bstr containing the value associated with the key.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CPersist::ReadFromIni(
    LPCTSTR pszKey,
    LPTSTR  szOut,
    int     cch
)
{
    ASSERT(pszKey);
    ASSERT(szOut || 0 == cch);

    BOOL fRet = FALSE;

    if (m_szPath && *m_szPath)
    {
        INITTYPE it = GetInitType(m_szPath);

        if (it == IT_INI)
        {
            LPCTSTR szFile    = TSTR_INI_FILE;
            LPCTSTR szSection = TSTR_INI_SECTION;
            LPCTSTR szKey     = pszKey;
            TCHAR   szPath[MAX_PATH];

            StrCpyN(szPath, m_szPath, ARRAYSIZE(szPath) - StrLen(szFile));
            StrCatBuff(szPath, szFile, ARRAYSIZE(szPath));

            if (GetPrivateProfileString(szSection, szKey, TEXT(""), szOut, cch,
                                        szPath))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::ReadFromIni ***
//
//
// Description:
//     Reads a string from the channel desktop.ini file.
//
// Parameters:
//     pszKey - The key to read.
//
// Return:
//     A bstr containing the value associated with the key.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BSTR
CPersist::ReadFromIni(
    LPCTSTR pszKey
)
{
    ASSERT(pszKey);

    BSTR bstrRet = NULL;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if (ReadFromIni(pszKey, szURL, ARRAYSIZE(szURL)))
    {
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

        if (SHTCharToUnicode(szURL, wszURL, ARRAYSIZE(wszURL)))
            bstrRet = SysAllocString(wszURL);
    }

    return bstrRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::IsUnreadCdf ***
//
//
// Description:
//
// Parameters:
//
// Return:
//
// Comments:
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CPersist::IsUnreadCdf(
    void
)
{
    BOOL fRet = FALSE;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if (ReadFromIni(TSTR_INI_URL, szURL, ARRAYSIZE(szURL)))
    {
        fRet = IsRecentlyChangedURL(szURL);
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPersist::IsNewContent ***
//
//
// Description:
//
// Parameters:
//
// Return:
//
// Comments:
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CPersist::IsRecentlyChangedURL(
    LPCTSTR pszURL
)
{
    ASSERT(pszURL);

    BOOL fRet = FALSE;

    HRESULT hr;
    IPropertySetStorage* pIPropertySetStorage;

    hr = QueryInternetShortcut(pszURL, IID_IPropertySetStorage,
                               (void**)&pIPropertySetStorage);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIPropertySetStorage);

        IPropertyStorage* pIPropertyStorage;

        hr = pIPropertySetStorage->Open(FMTID_InternetSite, STGM_READWRITE,
                                        &pIPropertyStorage);
        
        if (SUCCEEDED(hr))
        {
            ASSERT(pIPropertyStorage);

            PROPSPEC propspec = { PRSPEC_PROPID, PID_INTSITE_FLAGS };
            PROPVARIANT propvar;

            PropVariantInit(&propvar);

            hr = pIPropertyStorage->ReadMultiple(1, &propspec, &propvar);

            if (SUCCEEDED(hr) && (VT_UI4 == propvar.vt))
            {
                fRet = propvar.ulVal & PIDISF_RECENTLYCHANGED;
            }
            else
            {
                PropVariantClear(&propvar);
            }

            pIPropertyStorage->Release();
        }

        pIPropertySetStorage->Release();
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** ClearGleamFlag ***
//
//
// Description:
//
// Parameters:
//
// Return:
//
// Comments:
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
ClearGleamFlag(
    LPCTSTR pszURL,
    LPCTSTR pszPath
)
{
    ASSERT(pszURL);
    ASSERT(pszPath);

    HRESULT hr;

    IPropertySetStorage* pIPropertySetStorage;

    hr = QueryInternetShortcut(pszURL, IID_IPropertySetStorage,
                               (void**)&pIPropertySetStorage);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIPropertySetStorage);

        IPropertyStorage* pIPropertyStorage;

        hr = pIPropertySetStorage->Open(FMTID_InternetSite, STGM_READWRITE,
                                        &pIPropertyStorage);
        
        if (SUCCEEDED(hr))
        {
            ASSERT(pIPropertyStorage);

            PROPSPEC propspec = { PRSPEC_PROPID, PID_INTSITE_FLAGS };
            PROPVARIANT propvar;

            PropVariantInit(&propvar);

            hr = pIPropertyStorage->ReadMultiple(1, &propspec, &propvar);

            if (SUCCEEDED(hr) && (VT_UI4 == propvar.vt) &&
                (propvar.ulVal & PIDISF_RECENTLYCHANGED))
            {
                TCHAR  szHash[MAX_PATH];
                int   iIndex;
                UINT  uFlags;
                int   iImageIndex;
                
                HRESULT hr2 = PreUpdateChannelImage(pszPath, szHash, &iIndex,
                                                    &uFlags, &iImageIndex);

                propvar.ulVal &=  ~PIDISF_RECENTLYCHANGED;

                hr = pIPropertyStorage->WriteMultiple(1, &propspec, &propvar,
                                                      0);
                if (SUCCEEDED(hr))
                    hr = pIPropertyStorage->Commit(STGC_DEFAULT);

                TraceMsg(TF_GLEAM, "- Gleam Cleared %s", pszURL);

                if (SUCCEEDED(hr) && SUCCEEDED(hr2))
                {
                    WCHAR wszHash[MAX_PATH];
                    SHTCharToUnicode(szHash, wszHash, ARRAYSIZE(wszHash));

                    UpdateChannelImage(wszHash, iIndex, uFlags, iImageIndex);
                }

            }
            else
            {
                PropVariantClear(&propvar);
            }

            pIPropertyStorage->Release();
        }

        pIPropertySetStorage->Release();
    }

    return hr;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** URLGetLocalFileName ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
URLGetLocalFileName(
    LPCTSTR pszURL,
    LPTSTR szLocalFile,
    int cch,
    FILETIME* pftLastMod
)
{
    ASSERT(pszURL);
    ASSERT(szLocalFile || 0 == cch);

    HRESULT hr = E_FAIL;

    if (pftLastMod)
    {
        pftLastMod->dwLowDateTime  = 0;
        pftLastMod->dwHighDateTime = 0;
    }

    // by using the internal shlwapi function, we avoid loading WININET 
    // unless we really really need it...
    if (PathIsURL(pszURL))
    {
        PARSEDURL rgCrackedURL = {0};

        rgCrackedURL.cbSize = sizeof( rgCrackedURL );
        
        if ( SUCCEEDED( ParseURL( pszURL, &rgCrackedURL )))
        {
            switch(rgCrackedURL.nScheme)
            {
            case URL_SCHEME_HTTP:
            case URL_SCHEME_FTP:
            case URL_SCHEME_GOPHER:
                {
                    ULONG cbSize  = MAX_CACHE_ENTRY_INFO_SIZE;

                    INTERNET_CACHE_ENTRY_INFO* piceiAlloced = 
                    (INTERNET_CACHE_ENTRY_INFO*) new BYTE[cbSize];

                    if (piceiAlloced)
                    {
                        piceiAlloced->dwStructSize =
                                          sizeof(INTERNET_CACHE_ENTRY_INFO);

                        if (GetUrlCacheEntryInfoEx(pszURL, piceiAlloced,
                                                   &cbSize, NULL, NULL,
                                                   NULL, 0))
                        {
                            if (StrCpyN(szLocalFile,
                                        piceiAlloced->lpszLocalFileName, cch))
                            {
                                if (pftLastMod)
                                {
                                    *pftLastMod =
                                                 piceiAlloced->LastModifiedTime;
                                }

                                hr = S_OK;
                            }
                        }

                        delete [] piceiAlloced;
                    }
                }
                break;

            case URL_SCHEME_FILE:
                hr = PathCreateFromUrl(pszURL, szLocalFile, (LPDWORD)&cch, 0);
                break;

            }

        }
    }
    else
    {
        if (StrCpyN(szLocalFile, pszURL, cch))
            hr = S_OK;
    }

    return hr;
}

//
//  Get the last modified time of the URL.
//

HRESULT
URLGetLastModTime(
    LPCTSTR pszURL,
    FILETIME* pftLastMod
)
{
    ASSERT(pszURL);
    ASSERT(pftLastMod);

    pftLastMod->dwLowDateTime  = 0;
    pftLastMod->dwHighDateTime = 0;

    ULONG cbSize  = 0;

    if (!GetUrlCacheEntryInfoEx(pszURL, NULL, &cbSize, NULL, NULL, NULL, 0)
        && cbSize > 0)
    {
        INTERNET_CACHE_ENTRY_INFO* piceiAlloced =
                                  (INTERNET_CACHE_ENTRY_INFO*) new BYTE[cbSize];

        if (piceiAlloced)
        {
            piceiAlloced->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

            if (GetUrlCacheEntryInfoEx(pszURL, piceiAlloced, &cbSize, NULL,
                                       NULL, NULL, 0))
            {
                *pftLastMod = piceiAlloced->LastModifiedTime;
            }

            delete [] piceiAlloced;
        }
    }

    return S_OK;
}

/*STDMETHODIMP
CPersist::IsDirty(
    void
)
{
    return E_NOTIMPL;
}*/

STDMETHODIMP
CPersist::Load(
    BOOL fFullyAvailable,
    IMoniker* pIMoniker,
    IBindCtx* pIBindCtx,
    DWORD grfMode
)
{
    ASSERT(pIMoniker);
    ASSERT(pIBindCtx);

    HRESULT hr;

    ASSERT(NULL == m_polestrURL);

    hr = pIMoniker->GetDisplayName(pIBindCtx, NULL, &m_polestrURL);

    if (SUCCEEDED(hr))
    {
        ASSERT(m_polestrURL);

        ASSERT(NULL == m_pIXMLDocument)

        DLL_ForcePreloadDlls(PRELOAD_MSXML);
        
        hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                              IID_IXMLDocument, (void**)&m_pIXMLDocument);

        if (SUCCEEDED(hr))
        {
            ASSERT(m_pIXMLDocument);

            CBindStatusCallback* pCBindStatusCallback = new CBindStatusCallback(
                                                                m_pIXMLDocument,
                                                                m_polestrURL);

            if (pCBindStatusCallback)
            {
                IBindStatusCallback* pPrevIBindStatusCallback;

                hr = RegisterBindStatusCallback(pIBindCtx,
                                     (IBindStatusCallback*)pCBindStatusCallback,
                                     &pPrevIBindStatusCallback, 0);

                if (SUCCEEDED(hr))
                {
                    pCBindStatusCallback->Init(pPrevIBindStatusCallback);

                    IPersistMoniker* pIPersistMoniker;

                    hr = m_pIXMLDocument->QueryInterface(IID_IPersistMoniker,
                                                     (void**)&pIPersistMoniker);

                    if (SUCCEEDED(hr))
                    {
                        ASSERT(pIPersistMoniker);

                        hr = pIPersistMoniker->Load(fFullyAvailable, pIMoniker,
                                                    pIBindCtx, grfMode);
                        pIPersistMoniker->Release();
                    }
                }

                pCBindStatusCallback->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP
CPersist::Save(
    IMoniker* pIMoniker,
    IBindCtx* pIBindCtx,
    BOOL fRemember
)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CPersist::SaveCompleted(
    IMoniker* pIMoniker,
    IBindCtx* pIBindCtx
)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CPersist::GetCurMoniker(
    IMoniker** ppIMoniker
)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\proppgs.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// proppgs.cpp 
//
//   IShellPropSheetExt for channel shortcuts.
//
//   History:
//
//       6/12/97  edwardp   Created.
//
//   Note: The hotkey stuff is comment out, the shell/windows doesn't make it 
//         possible to persist hotkey settings across sessions and it isn't 
//         worth kicking off another thread at boot to enable this feature.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "persist.h"
#include "cdfview.h"
#include "proppgs.h"
#include "xmlutil.h"
#include "dll.h"
#include "iconhand.h"
#include "resource.h"
#include "winineti.h"
#include <iehelpid.h>

#include <mluisupp.h>

#pragma warning(disable:4800)

//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPropertyPages::CPropertyPages ***
//
//    Constructor for CPropertyPages.
//
////////////////////////////////////////////////////////////////////////////////
CPropertyPages::CPropertyPages (
    void
)
: m_cRef(1)
{
    ASSERT(NULL == m_pSubscriptionMgr2);
    ASSERT(NULL == m_pInitDataObject);

    TraceMsg(TF_OBJECTS, "+ IShellPropSheetExt");

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPropertyPages::~CPropertyPages ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CPropertyPages::~CPropertyPages (
    void
)
{
    if (m_pSubscriptionMgr2)
        m_pSubscriptionMgr2->Release();

    if (m_pInitDataObject)
        m_pInitDataObject->Release();

    ASSERT(0 == m_cRef);

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IShellPropSheetExt");

    DllRelease();

    return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPropertyPages::QueryInterface ***
//
//    CPropertyPages QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPropertyPages::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IShellPropSheetExt == riid)
    {
        *ppv = (IShellPropSheetExt*)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppv = (IShellExtInit*)this;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPropertyPages::AddRef ***
//
//    CPropertyPages AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPropertyPages::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CPropertyPages::Release ***
//
//    CContextMenu Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CPropertyPages::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
//  IShellPropSheetExt methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPropertyPages::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
)
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance = MLGetHinst();
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CHANNEL_PROP);
    psp.hIcon = NULL;
    psp.pszTitle = NULL;
    psp.pfnDlgProc = PropSheetDlgProc;
    psp.lParam = (LPARAM)(CPropertyPages *)this;
    psp.pfnCallback = PropSheetCallback;

    HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);

    if (hpage)
    {
        //  Release() happens in PropSheetCallback.
        AddRef();

        //  Assume the mess below doesn't work, we want the default page to be us.
        hr = 1;

        //  HACKHACK: This code attempts to remove the Folder property pages such as
        //  General and Sharing (it will also whack any 3rd party pages which were
        //  unfortunate enough to have been loaded before use :)
        PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

        //  First make sure we can safely access the memory as if it were a
        //  PROPSHEETHEADER structure.
        if (!IsBadReadPtr(ppsh, PROPSHEETHEADER_V1_SIZE) &&
            !IsBadWritePtr(ppsh, PROPSHEETHEADER_V1_SIZE))
        {
            //  Now see if the module matches shell32
            if (ppsh->hInstance == GetModuleHandle(TEXT("shell32.dll")))
            {
                //  looks good so rip 'em out

                for (UINT i = 0; i < ppsh->nPages; i++)
                {
                    //  At least be a good citizen and delete their pages so we
                    //  don't leak
                    DestroyPropertySheetPage(ppsh->phpage[i]);
                }
                ppsh->nPages = 0;

                //  Now we shouldn't need to mess with the default page.  If someone
                //  loads after us, we may not win.
                hr = 0;
            }
        }

        if (lpfnAddPage(hpage, lParam))
        {
            WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

            SHTCharToUnicode(m_szURL, wszURL, ARRAYSIZE(wszURL));

            if (SUCCEEDED(InitializeSubsMgr2()))
            {
                m_pSubscriptionMgr2->IsSubscribed(wszURL, &m_bStartSubscribed);

                if (m_bStartSubscribed)
                {
                    IShellPropSheetExt *pspse;

                    if (SUCCEEDED(m_pSubscriptionMgr2->QueryInterface(IID_IShellPropSheetExt,
                                                                      (void **)&pspse)))
                    {
                        pspse->AddPages(lpfnAddPage, lParam);
                        pspse->Release();
                    }
                }
            }
        }
        else
        {
            DestroyPropertySheetPage(hpage);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPropertyPages::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
)
{
    return E_NOTIMPL; 
}


//
// IShellExtInit methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CPropertyPages::Initialize(
    LPCITEMIDLIST pidl,
    LPDATAOBJECT pIDataObject,
    HKEY hkey
)
{
    HRESULT hr;

    STGMEDIUM stgmed;
    FORMATETC fmtetc = {CF_HDROP, NULL, DVASPECT_CONTENT, -1,
                        TYMED_HGLOBAL};

    if (m_pInitDataObject)
        m_pInitDataObject->Release();

    m_pInitDataObject = pIDataObject;
    m_pInitDataObject->AddRef();

    hr = pIDataObject->GetData(&fmtetc, &stgmed);

    if (SUCCEEDED(hr))
    {
        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, m_szPath, 
                          ARRAYSIZE(m_szPath)))
        {       
            TCHAR szDesktopINI[MAX_PATH];

            if (PathCombine(szDesktopINI, m_szPath, c_szDesktopINI))
            {
                GetPrivateProfileString(c_szChannel, c_szCDFURL, TEXT(""), m_szURL, 
                                        ARRAYSIZE(m_szURL), szDesktopINI);
            }
            else
            {
                hr = E_FAIL;
            }

            //m_wHotkey = GetPrivateProfileInt(c_szChannel, c_szHotkey, 0, szDesktopINI);
        }
        else
        {
            hr = E_FAIL;
        }

        ReleaseStgMedium(&stgmed);
    }

    return hr;
}


//
// Helper functions
//

HRESULT CPropertyPages::InitializeSubsMgr2()
{
    HRESULT hr = E_FAIL;

#ifndef UNIX
    if (NULL != m_pSubscriptionMgr2)
    {
        hr = S_OK;
    }
    else
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            DLL_ForcePreloadDlls(PRELOAD_WEBCHECK);

            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2,
                                  (void**)&m_pSubscriptionMgr2);

            if (SUCCEEDED(hr))
            {
                IShellExtInit* pIShellExtInit;

                hr = m_pSubscriptionMgr2->QueryInterface(IID_IShellExtInit, 
                                                         (void **)&pIShellExtInit);
                if (SUCCEEDED(hr))
                {
                    hr = pIShellExtInit->Initialize(NULL, m_pInitDataObject, NULL);
                    pIShellExtInit->Release();
                }
            }
        }
        CoUninitialize();
    }
#endif /* !UNIX */

    return hr;
}

void CPropertyPages::ShowOfflineSummary(HWND hdlg, BOOL bShow)
{
    static const int offSumIDs[] =
    {
        IDC_SUMMARY,
        IDC_LAST_SYNC_TEXT,
        IDC_LAST_SYNC,
        IDC_DOWNLOAD_SIZE_TEXT,
        IDC_DOWNLOAD_SIZE,
        IDC_DOWNLOAD_RESULT,
        IDC_DOWNLOAD_RESULT_TEXT,
        IDC_FREE_SPACE_TEXT
    };

    if (bShow)
    {
        TCHAR szLastSync[128];
        TCHAR szDownloadSize[128];
        TCHAR szDownloadResult[128];
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

        MLLoadString(IDS_VALUE_UNKNOWN, szLastSync, ARRAYSIZE(szLastSync));
        StrCpyN(szDownloadSize, szLastSync, ARRAYSIZE(szDownloadSize));
        StrCpyN(szDownloadResult, szLastSync, ARRAYSIZE(szDownloadResult));

        SHTCharToUnicode(m_szURL, wszURL, ARRAYSIZE(wszURL));

        ASSERT(NULL != m_pSubscriptionMgr2);

        if (NULL != m_pSubscriptionMgr2)
        {
            ISubscriptionItem *psi;
            
            if (SUCCEEDED(m_pSubscriptionMgr2->GetItemFromURL(wszURL, &psi)))
            {
                enum { spLastSync, spDownloadSize, spDownloadResult };

                static const LPCWSTR pProps[] =
                { 
                    c_szPropCompletionTime,
                    c_szPropCrawlActualSize,
                    c_szPropStatusString
                };
                VARIANT vars[ARRAYSIZE(pProps)];

                if (SUCCEEDED(psi->ReadProperties(ARRAYSIZE(pProps), pProps, vars)))
                {
                    if (VT_DATE == vars[spLastSync].vt)
                    {
                        FILETIME ft, ft2;
                        DWORD dwFlags = FDTF_DEFAULT;
                        SYSTEMTIME st;

                        VariantTimeToSystemTime(vars[spLastSync].date, &st);
                        SystemTimeToFileTime(&st, &ft);
                        LocalFileTimeToFileTime(&ft, &ft2);
                        SHFormatDateTime(&ft2, &dwFlags, szLastSync, ARRAYSIZE(szLastSync));
                    }

                    if (VT_I4 == vars[spDownloadSize].vt)
                    {
                        StrFormatByteSize(vars[spDownloadSize].lVal * 1024, 
                                          szDownloadSize, ARRAYSIZE(szDownloadSize));
                    }

                    if (VT_BSTR == vars[spDownloadResult].vt)
                    {
                    #ifdef UNICODE
                        wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                                  TEXT("%s"), vars[spDownloadResult].bstrVal);
                    #else
                        wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                                  TEXT("%S"), vars[spDownloadResult].bstrVal);
                    #endif
                    }

                    for (int i = 0; i < ARRAYSIZE(pProps); i++)
                    {
                        VariantClear(&vars[i]);
                    }
                }
                psi->Release();
            }
        }

        SetDlgItemText(hdlg, IDC_LAST_SYNC, szLastSync);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_SIZE, szDownloadSize);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_RESULT, szDownloadResult);
    }

    for (int i = 0; i < ARRAYSIZE(offSumIDs); i++)
    {
        ShowWindow(GetDlgItem(hdlg, offSumIDs[i]), bShow ? SW_SHOW : SW_HIDE);
    }
}

BOOL CPropertyPages::OnInitDialog(HWND hdlg)
{
    TCHAR szName[MAX_PATH];
    HICON hicon = NULL;
    HRESULT hr;

    CIconHandler *pIconHandler = new CIconHandler;

    if (pIconHandler)
    {
        if (SUCCEEDED(pIconHandler->Load(m_szPath, 0)))
        {
            TCHAR szIconFile[MAX_PATH];
            int iIndex;
            UINT wFlags;
            
            if (SUCCEEDED(pIconHandler->GetIconLocation(0, szIconFile, ARRAYSIZE(szIconFile),
                                                        &iIndex, &wFlags)))
            {
                HICON hiconScrap = NULL;
                
                hr = pIconHandler->Extract(szIconFile, iIndex, &hicon, &hiconScrap, 
                                           MAKELONG(GetSystemMetrics(SM_CXICON), 
                                                    GetSystemMetrics(SM_CXSMICON)));

                if (S_FALSE == hr)
                {
                    //  Do it ourselves
                    hicon = ExtractIcon(g_hinst, szIconFile, iIndex);

                }
                else if ((NULL != hiconScrap) && (hicon != hiconScrap))
                {
                    //  Otherwise cleanup unwanted little icon
                    DestroyIcon(hiconScrap);
                }
            }

        }
        pIconHandler->Release();
    }

    if (NULL == hicon)
    {
        hicon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_CHANNEL));
    }
    
    BOOL bEnableMakeOffline = TRUE;

    SendDlgItemMessage(hdlg, IDC_ICONEX2, STM_SETICON, (WPARAM)hicon, 0);
    StrCpyN(szName, m_szPath, ARRAYSIZE(szName));
    PathStripPath(szName);

    SetDlgItemText(hdlg, IDC_NAME, szName);
    SetDlgItemText(hdlg, IDC_URL, m_szURL);

    TCHAR szVisits[256];

    szVisits[0] = 0;

    CCdfView* pCCdfView = new CCdfView;

    if (pCCdfView)
    {
        hr = pCCdfView->Load(m_szURL, 0);

        if (SUCCEEDED(hr))
        {
            IXMLDocument* pIXMLDocument;

            hr = pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

            if (SUCCEEDED(hr))
            {
                IXMLElement*    pIXMLElement;
                LONG            nIndex;

                hr = XML_GetFirstChannelElement(pIXMLDocument,
                                                &pIXMLElement, &nIndex);

                if (SUCCEEDED(hr))
                {
                    BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_HREF);

                    if (bstrURL && *bstrURL)
                    {
                        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
                        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
                        DWORD cbcei = MAX_CACHE_ENTRY_INFO_SIZE;

                        if (GetUrlCacheEntryInfoW(bstrURL, pcei, &cbcei))
                        {
                            wnsprintf(szVisits, ARRAYSIZE(szVisits), TEXT("%d"), 
                                      pcei->dwHitRate);
                        }
                    }
                    SysFreeString(bstrURL);

                    pIXMLElement->Release();
                }

                pIXMLDocument->Release();
            }
        }
        pCCdfView->Release();
    }
    
    if (0 == szVisits[0])

    {
        MLLoadString(IDS_VALUE_UNKNOWN, szVisits, 
                   ARRAYSIZE(szVisits));
    }
    SetDlgItemText(hdlg, IDC_VISITS, szVisits);
/*
    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETRULES,
                       (HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
                       (HOTKEYF_CONTROL | HOTKEYF_ALT));

    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETHOTKEY, m_wHotkey, 0);
*/
    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    SHTCharToUnicode(m_szURL, wszURL, ARRAYSIZE(wszURL));

    CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, m_bStartSubscribed ? 1 : 0);
    
    if (m_bStartSubscribed)
    {
        if (SHRestricted2(REST_NoRemovingSubscriptions, m_szURL, 0))
        {
            bEnableMakeOffline = FALSE;
        }
    }
    else
    {
        if (SHRestricted2(REST_NoAddingSubscriptions, m_szURL, 0))
        {
            bEnableMakeOffline = FALSE;
        }
    }

    if (!CanSubscribe(wszURL))
    {
        bEnableMakeOffline = FALSE;
    }

    if (!bEnableMakeOffline)
    {
        EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
    }

    ShowOfflineSummary(hdlg, m_bStartSubscribed);

    return TRUE;
}

BOOL AddSubsPropsCallback(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    return (bool) PropSheet_AddPage((HWND)lParam, hpage);
}

void CPropertyPages::AddRemoveSubsPages(HWND hdlg, BOOL bAdd)
{
    ASSERT(NULL != m_pSubscriptionMgr2);

    if (NULL != m_pSubscriptionMgr2)
    {
        if (bAdd)
        {
            IShellPropSheetExt *pspse;

            if (SUCCEEDED(m_pSubscriptionMgr2->QueryInterface(IID_IShellPropSheetExt,
                                                              (void **)&pspse)))
            {
                pspse->AddPages(AddSubsPropsCallback, (LPARAM)GetParent(hdlg));
                pspse->Release();
            }
        }
        else
        {
            ISubscriptionMgrPriv *psmp;

            if (SUCCEEDED(m_pSubscriptionMgr2->QueryInterface(IID_ISubscriptionMgrPriv,
                                                              (void **)&psmp)))
            {
                psmp->RemovePages(GetParent(hdlg));
                psmp->Release();
            }
        }

        ShowOfflineSummary(hdlg, bAdd);
    }
}

BOOL CPropertyPages::OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    switch (wID)
    {
        case IDC_MAKE_OFFLINE:
            if (wNotifyCode == BN_CLICKED)
            {
                AddRemoveSubsPages(hdlg, IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE));
                PropSheet_Changed(GetParent(hdlg), hdlg);
            }
            break;
/*
        case IDC_HOTKEY:
            if (wNotifyCode == EN_CHANGE)
            {
                PropSheet_Changed(GetParent(hdlg), hdlg);
            }
            break;
*/
        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

BOOL CPropertyPages::OnNotify(HWND hdlg, WPARAM idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = FALSE;

    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
        /*
            TCHAR szHotkey[32];
            TCHAR szDesktopINI[MAX_PATH];
            WORD wOldHotkey = m_wHotkey;

            m_wHotkey = (WORD)SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_GETHOTKEY, 0, 0);
            wnsprintf(szHotkey, ARRAYSIZE(szHotkey), TEXT("%d"), m_wHotkey);

            PathCombine(szDesktopINI, m_szPath, c_szDesktopINI);
            WritePrivateProfileString(c_szChannel, c_szHotkey, szHotkey, szDesktopINI);

            RegisterGlobalHotkey(wOldHotkey, m_wHotkey, m_szPath);
        */
            BOOL bIsSubscribed = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);

            if (!bIsSubscribed)
            {
                WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

                SHTCharToUnicode(m_szURL, wszURL, ARRAYSIZE(wszURL));
                
                if (NULL != m_pSubscriptionMgr2) 
                {
                    m_pSubscriptionMgr2->DeleteSubscription(wszURL, NULL);
                }
            }
            else
            {
                ISubscriptionMgrPriv *psmp;

                if ((NULL != m_pSubscriptionMgr2) &&
                    SUCCEEDED(m_pSubscriptionMgr2->QueryInterface(IID_ISubscriptionMgrPriv,
                                                                  (void **)&psmp)))
                {
                    psmp->SaveSubscription();
                    psmp->Release();
                }                
            }

            bHandled = TRUE;
            break;
        }
    }

    return bHandled;
}

void CPropertyPages::OnDestroy(HWND hdlg)
{
    if (!m_bStartSubscribed && 
        IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE) && 
        (NULL != m_pSubscriptionMgr2))
    {
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

        SHTCharToUnicode(m_szURL, wszURL, ARRAYSIZE(wszURL));

        m_pSubscriptionMgr2->UpdateSubscription(wszURL);
    }

    //  Ensure sys bit is still set
    SetFileAttributes(m_szPath, FILE_ATTRIBUTE_SYSTEM);
}

UINT CPropertyPages::PropSheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg)
    {
        case PSPCB_RELEASE:
            if (NULL != ppsp->lParam)
            {
                ((CPropertyPages *)ppsp->lParam)->Release();
            }
            break;
    }

    return 1;
}

TCHAR c_szHelpFile[] = TEXT("iexplore.hlp");

DWORD aHelpIDs[] = {
    IDC_NAME,                   IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME,
    IDC_URL_TEXT,               IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_URL,                    IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
//    IDC_HOTKEY_TEXT,            IDH_WEBDOC_HOTKEY,
//    IDC_HOTKEY,                 IDH_WEBDOC_HOTKEY,
    IDC_VISITS_TEXT,            IDH_WEBDOC_VISITS,
    IDC_VISITS,                 IDH_WEBDOC_VISITS,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    IDC_SUMMARY,                IDH_GROUPBOX,
    IDC_LAST_SYNC_TEXT,         IDH_SUBPROPS_SUBTAB_LAST,
    IDC_LAST_SYNC,              IDH_SUBPROPS_SUBTAB_LAST,
    IDC_DOWNLOAD_SIZE_TEXT,     IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_SIZE,          IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_RESULT_TEXT,   IDH_SUBPROPS_SUBTAB_RESULT,
    IDC_DOWNLOAD_RESULT,        IDH_SUBPROPS_SUBTAB_RESULT,
    0, 0
};


INT_PTR CPropertyPages::PropSheetDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR lrHandled = FALSE;
    CPropertyPages *pThis;
    
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE pPropSheetPage = (LPPROPSHEETPAGE)lParam;

            ASSERT(NULL != pPropSheetPage);
            if (NULL != pPropSheetPage)
            {
                SetWindowLongPtr(hdlg, DWLP_USER, pPropSheetPage->lParam);
            }
            
            pThis = GetThis(hdlg);

            if (NULL != pThis)
            {               
                lrHandled = pThis->OnInitDialog(hdlg);
            }

            break;
        }

        case WM_COMMAND:
            pThis = GetThis(hdlg);
            if (NULL != pThis)
            {               
                lrHandled = pThis->OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            }
            break;

        case WM_NOTIFY:
            pThis = GetThis(hdlg);

            if (NULL != pThis)
            {               
                lrHandled = pThis->OnNotify(hdlg, wParam, (LPNMHDR)lParam);
            }
            break;

        case WM_DESTROY:
            pThis = GetThis(hdlg);

            if (NULL != pThis)
            {
                pThis->OnDestroy(hdlg);
            }
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR) aHelpIDs);
            lrHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            lrHandled = TRUE;
            break;
    }
    
    return lrHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\runonnt.cpp ===
#include "stdinc.h"

//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

// First undefine everything that we are intercepting as to not forward back to us...
#undef PathCleanupSpec

#define THUNKMSG(psz)   TraceMsg(TF_THUNK, "shdv THUNK::%s", psz)


//
//  Now the thunks that allow us to run on Windows 95.
//
//
//
//  This thunks a unicode string to ANSI, but if it's an ordinal, then
//  we just leave it alone.
//

int _AorW_PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec)
{
    THUNKMSG(TEXT("PathCleanupSpec"));

    if (g_bRunningOnNT)
    {
        WCHAR wzDir[MAX_PATH];
        WCHAR wzSpec[MAX_PATH];
        LPWSTR pwszDir = wzDir;
        int iRet;

        if (pszDir)
            SHTCharToUnicode(pszDir, wzDir, ARRAYSIZE(wzDir));
        else
            pwszDir = NULL;

        SHTCharToUnicode(pszSpec, wzSpec, ARRAYSIZE(wzSpec));
        iRet = PathCleanupSpec((LPTSTR)pwszDir, (LPTSTR)wzSpec);

        SHUnicodeToTChar(wzSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir)
            SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        else
            pszDir2 = NULL;

        SHTCharToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));
        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        SHAnsiToTChar(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
}

STDAPI Priv_SHDefExtractIcon(LPCTSTR pszIconFile, int iIndex, UINT uFlags,
                          HICON *phiconLarge, HICON *phiconSmall,
                          UINT nIconSize)
{
    HRESULT hr;
    ASSERT(uFlags == 0);

    //
    // W95 integrated mode supports SHDefExtractIcon.  This supports
    // matching the icon ectracted to the icon color depth.  ExtractIcon
    // doesn't.
    //
#ifndef UNIX
    if ((WhichPlatform() == PLATFORM_INTEGRATED))
    {
#ifdef UNICODE
        if (g_bRunningOnNT) 
        {
            return SHDefExtractIconW(pszIconFile, iIndex, uFlags,
                          phiconLarge, phiconSmall, nIconSize);
        } 
        else 
#endif
        {
            char szIconFile[MAX_PATH];
            SHUnicodeToAnsi(pszIconFile, szIconFile, ARRAYSIZE(szIconFile));
            hr = SHDefExtractIconA(szIconFile, iIndex, uFlags,
                          phiconLarge, phiconSmall, nIconSize);
        }
    }
    else
#endif /* !UNIX */
    {
        char szIconFile[MAX_PATH];
        SHUnicodeToAnsi(pszIconFile, szIconFile, ARRAYSIZE(szIconFile));
        hr = ExtractIconExA(szIconFile, iIndex, phiconLarge,
                           phiconSmall, 1) ? S_OK : E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\runonnt.h ===
#define ILGetDisplayName        _AorW_ILGetDisplayName
#define PathCleanupSpec         _AorW_PathCleanupSpec

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define

// Define the prototypes for each of these forwarders...

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

extern BOOL _AorW_ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName);
extern int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);

//
//  This is the "RunOn95" section, which thunks UNICODE functions
//  back down to ANSI so we can run on Win95 in browser-only mode.
//

STDAPI Priv_SHDefExtractIcon(LPCTSTR pszIconFile, int iIndex, UINT uFlags,
                          HICON *phiconLarge, HICON *phiconSmall,
                          UINT nIconSize);

#ifdef __cplusplus
}

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\proppgs.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// proppgs.h 
//
//   IShellPropSheetExt menu interface for items.
//
//   History:
//
//       3/26/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _PROPPGS_H_

#define _PROPPGS_H_

//
// Class definition for the item context menu class.
//

class CPropertyPages : public IShellPropSheetExt,
                       public IShellExtInit
{
//
// Methods
//

public:

    // Constructor
    CPropertyPages(void);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage,
                             LPARAM lParam);
    
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl, LPDATAOBJECT pdobj, HKEY hkey);


private:

    // Destructor.
    ~CPropertyPages(void);

    // Helper functions.

    BOOL OnInitDialog(HWND hdlg);
    BOOL OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
    BOOL OnNotify(HWND hdlg, WPARAM idCtrl, LPNMHDR pnmh);
    void OnDestroy(HWND hdlg);
    void ShowOfflineSummary(HWND hdlg, BOOL bShow);
    void AddRemoveSubsPages(HWND hdlg, BOOL bAdd);
    HRESULT InitializeSubsMgr2();

    static INT_PTR PropSheetDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static UINT PropSheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

    inline static CPropertyPages *GetThis(HWND hdlg)
    {
        CPropertyPages *pThis = (CPropertyPages*) GetWindowLongPtr(hdlg, DWLP_USER);

        ASSERT(NULL != pThis);

        return pThis;
    }


//
// Member variables.
//

private:

    ULONG               m_cRef;
    ISubscriptionMgr2*  m_pSubscriptionMgr2;
    IDataObject*        m_pInitDataObject;
    TCHAR               m_szPath[MAX_PATH];
    TCHAR               m_szURL[INTERNET_MAX_URL_LENGTH];
    WORD                m_wHotkey;
    BOOL                m_bStartSubscribed;
};


#endif // _PROPPGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\resource.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// resource.h 
//
//   Defines for the resources used in cdf view.
//
//   History:
//
//       3/20/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Strings.
//

#define IDS_COLUMN_NAME             0x1000

#define IDS_ERROR_DLG_TEXT          0x1100
#define IDS_ERROR_DLG_TITLE         0x1101
#define IDS_ERROR_NO_CACHE_ENTRY    0x1102

#define IDS_CHANNEL_FOLDER          0x1200
#define IDS_SOFTWAREUPDATE_FOLDER   0x1201
#define IDS_CHANNEL_FILE            0x1202

#define IDS_SHARING                 0x1300
#define IDS_RENAME                  0x1301
#define IDS_SENDTO                  0x1302
#define IDS_PROPERTIES              0x1303

#define IDS_OVERWRITE_DLG_TEXT      0x1400
#define IDS_OVERWRITE_DLG_TITLE     0x1401

#define IDS_BROWSERONLY_DLG_TEXT    0x1500
#define IDS_BROWSERONLY_DLG_TITLE   0x1501

#define IDS_INFO_MUST_CONNECT       0x1600
#define IDS_INFO_DLG_TITLE          0x1601

#define IDS_VALUE_UNKNOWN           0x1700

//
// Icons.
//

#define IDI_FIRSTICON           0x2000
#define IDI_CHANNEL             0x2000
#define IDI_STORY               0x2001
#define IDI_OPENSUBCHANNEL      0x2002
#define IDI_CLOSESUBCHANNEL     0x2003
#define IDI_CHANNELFOLDER       0x2004
#define IDI_DESKTOP             0x2005

//
// Menu items.
//

#define IDM_CONTEXTMENU         0x3000
#define IDM_OPEN                0x0001
#define IDM_PROPERTIES          0x0002

#define IDM_SUBSCRIBEDMENU      0x3200
#define IDM_UNSUBSCRIBEDMENU    0x3300
#define IDM_NOSUBSCRIBEMENU     0x3400

#define IDM_UNSUBSCRIBE         0x0001
#define IDM_EDITSUBSCRIPTION    0x0002
#define IDM_UPDATESUBSCRIPTION  0x0003
#define IDM_REFRESHCHANNEL      0x0004
#define IDM_VIEWSOURCE          0x0005
#define IDM_SUBSCRIBE           0x0006


//
// AVI files
//

#define IDA_DOWNLOAD            0x4800

//
// Dialogs
//

#define IDD_CHANNELREFRESH          0x5000
#define IDC_DOWNLOADPROGRESS        0x0100
#define IDC_DOWNLOADMSG             0x0101
#define IDC_DOWNLOADANIMATE         0x0102

#define IDD_CHANNEL_PROP            0x5100
#define IDC_ICONEX2                 0x0103
#define IDC_NAME                    0x0104
#define IDC_URL_TEXT                0x0105
#define IDC_URL                     0x0106
#define IDC_HOTKEY_TEXT             0x0107
#define IDC_HOTKEY                  0x0108

#define IDC_VISITS_TEXT             0x1018
#define IDC_VISITS                  0x1019
#define IDC_MAKE_OFFLINE            0x1020
#define IDC_SUMMARY                 0x1021
#define IDC_LAST_SYNC_TEXT          0x1022
#define IDC_LAST_SYNC               0x1023
#define IDC_DOWNLOAD_SIZE_TEXT      0x1024
#define IDC_DOWNLOAD_SIZE           0x1025
#define IDC_DOWNLOAD_RESULT_TEXT    0x1026
#define IDC_DOWNLOAD_RESULT         0x1027
#define IDC_FREE_SPACE_TEXT         0x1028


//
// HTML files
//

// these pairs must match up (apart from the quotes)
#define IDH_XMLERRORPAGE     xmlerror.htm
#define SZH_XMLERRORPAGE     TEXT("xmlerror.htm")

#define IDH_HRERRORPAGE     hrerror.htm
#define SZH_HRERRORPAGE     TEXT("hrerror.htm")

#define IDH_CACHEERRORPAGE   cacheerr.htm
#define SZH_CACHEERRORPAGE   TEXT("cacheerr.htm")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\persist.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// persist.h 
//
//   The definitions for cdf IPersistFile and IPersistFolder interfaces.  This
//   class is used as a base class by the CCdfView and CIconHandler.
//
//   History:
//
//       4/23/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _PERSIST_H_

#define _PERSIST_H_

//
// Function prototypes.
//

HRESULT ClearGleamFlag(LPCTSTR pszURL, LPCTSTR pszPath);

HRESULT URLGetLocalFileName(LPCTSTR pszURL,
                            LPTSTR szLocalFile,
                            int cch,
                            FILETIME* pftLastMod);

HRESULT URLGetLastModTime(LPCTSTR pszURL, FILETIME* pftLastMod);

//
// Data types.
//

typedef enum _tagINITTYPE
{
    IT_UNKNOWN = 0,
    IT_FILE,
    IT_INI,
    IT_SHORTCUT
} INITTYPE;

//
// Parse flags.
//

#define PARSE_LOCAL                   0x00000001
#define PARSE_NET                     0x00000002
#define PARSE_REPARSE                 0x00000004
#define PARSE_REMOVEGLEAM             0x00000008

//
// Strings used by initialization helper functions.
//

#define TSTR_INI_FILE        TEXT(FILENAME_SEPARATOR_STR)##TEXT("desktop.ini")   // Must include leading \.
#define TSTR_INI_SECTION     TEXT("Channel")
#define TSTR_INI_URL         TEXT("CDFURL")
#define TSTR_INI_LOGO        TEXT("Logo")
#define TSTR_INI_WIDELOGO    TEXT("WideLogo")
#define TSTR_INI_ICON        TEXT("Icon")

//
// Function protoypes
//

#define WM_NAVIGATE         (WM_USER+1)
#define WM_NAVIGATE_PANE    (WM_USER+2)

LRESULT CALLBACK NavigateWndProc(HWND hwnd, UINT msg, WPARAM wParam,
                                 LPARAM lParam);


//
// Class definition for CPersist
//

class CPersist : public IPersistFile,
                 public IPersistFolder,
                 public IPersistMoniker,
                 public IOleObject
{
//
// Methods.
//

public:
    
    // Constructor and destructor.
    CPersist(void);
    CPersist(BOOL bCdfParsed);
    ~CPersist(void);

    //IUnknown - Pure virtual functions.
    // IUnknown
    virtual STDMETHODIMP         QueryInterface(REFIID, void **) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    //IPersist - Shared by IPersistFile and IPersistFolder.
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    //IPersistFile
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP GetCurFile(LPOLESTR* ppszFileName);

    // IPersistFolder
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistMoniker
    //STDMETHODIMP IsDirty(void);

    STDMETHODIMP Load(BOOL fFullyAvailable, IMoniker* pIMoniker,
                      IBindCtx* pIBindCtx, DWORD grfMode);

    STDMETHODIMP Save(IMoniker* pIMoniker, IBindCtx* pIBindCtx, BOOL fRemember);
    STDMETHODIMP SaveCompleted(IMoniker* pIMoniker, IBindCtx* pIBindCtx);
    STDMETHODIMP GetCurMoniker(IMoniker** ppIMoniker);

    // IOleObject.
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);
    STDMETHODIMP GetClientSite(IOleClientSite **ppClientSite);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp,
                              LPCOLESTR szContainerObj);
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk);
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker,
                            IMoniker **ppmk);
    STDMETHODIMP InitFromData(IDataObject *pDataObject, BOOL fCreation,
                              DWORD dwReserved);
    STDMETHODIMP GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject);
    STDMETHODIMP DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite,
                        LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    STDMETHODIMP EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHODIMP Update(void);
    STDMETHODIMP IsUpToDate(void);
    STDMETHODIMP GetUserClassID(CLSID *pClsid);
    STDMETHODIMP GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType);
    STDMETHODIMP SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHODIMP GetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHODIMP Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);
    STDMETHODIMP EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHODIMP SetColorScheme(LOGPALETTE *pLogpal);

//protected:

    //Helper functions derived classes can call.
    HRESULT  ParseCdf(HWND hwndOwner, IXMLDocument** ppIXMLDocument, 
                      DWORD dwParseFlags);

    BSTR     ReadFromIni(LPCTSTR pszKey);

    BOOL     IsUnreadCdf(void);
    BOOL     IsRecentlyChangedURL(LPCTSTR pszURL);

private:

    // Internal helper functions.
    HRESULT  Parse(LPTSTR szURL, IXMLDocument** ppIXMLDocument);
    INITTYPE GetInitType(LPTSTR szPath);
    BOOL     ReadFromIni(LPCTSTR pszKey, LPTSTR szOut, int cch);
    HRESULT  InitializeFromURL(LPTSTR szURL, IXMLDocument** ppIXMLDocument,
                               DWORD dwParseFlags);

    HRESULT  OpenChannel(LPCWSTR pszSubscribedURL);
    HWND     CreateNavigationWorkerWindow(HWND hwndParent,
                                          IWebBrowser2* pIWebBrowser2);

    void QuickCheckInitType( void );
//
// Member variables.
//

protected:

    BOOL            m_bCdfParsed;
    TCHAR           m_szPath[INTERNET_MAX_URL_LENGTH];
    LPOLESTR        m_polestrURL;
    IWebBrowser2*   m_pIWebBrowser2;
    HWND            m_hwnd;
    IXMLDocument*   m_pIXMLDocument;
    BOOL            m_fPendingNavigation;
    INITTYPE        m_rgInitType;

#ifdef IMP_CLIENTSITE

    IOleClientSite* m_pOleClientSite;

#endif
};

#endif // _PERSIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\strutil.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// string.cpp 
//
//   String functions used by cdfview that are not in shlwapi.h.
//
//   History:
//
//       5/15/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** StrEqlA *** 
//
//   Compares two ANSI strings for equality.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
StrEqlA(LPCSTR p1, LPCSTR p2)
{
    ASSERT(p1);
    ASSERT(p2);

    while ((*p1 == *p2) && *p1 && *p2)
    {
        p1++; p2++;
    }

    return (*p1 == *p2);
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** StrEqlW *** 
//
//   Compares two WIDE strings for equality.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
StrEqlW(LPCWSTR p1, LPCWSTR p2)
{
    ASSERT(p1);
    ASSERT(p2);

    while ((*p1 == *p2) && *p1 && *p2)
    {
        p1++; p2++;
    }

    return (*p1 == *p2);
}
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** StrLocallyDisplayable *** 
//
//   Determines if the given wide char string can be displayed on the current
//   system.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
StrLocallyDisplayable(
    LPCWSTR pwsz
)
{
    ASSERT(pwsz);

    BOOL fRet = FALSE;

    if (0 == WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, &fRet))
        fRet = TRUE;

    return !fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\stdinc.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// Stdinc.h 
//
//   Contains the standard include files used by.cpp files in ineticon.  Most
//   of the ineticon files will include this file.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _STDINC_H_
#define _STDINC_H_

#ifdef UNICODE
// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif

#define _OLEAUT32_       // get DECLSPEC_IMPORT stuff right, we are defing these
#define _BROWSEUI_       // define bruiapi as functions exported instead of imported
#define _WINX32_         // get DECLSPEC_IMPORT stuff right for WININET API
#define _URLCACHEAPI     // get DECLSPEC_IMPORT stuff right for WININET CACHE API
#ifndef STRICT
#define STRICT
#endif

//
// Globaly defined includes.
//
//  
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  CWindowImplBase__DefWindowProcWrapW when you expected to see
//  CWindowImplBase__DefWindowProc.
//
#define POST_IE5_BETA // turn on post-split iedev stuff
#endif

#define _SHDOCVW_

#ifdef UNICODE
#include <w95wraps.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <debug.h>     // From shell\inc.
#ifdef UNICODE
#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
#endif
#include <wininet.h>   // INTERNET_MAX_URL_LENGTH.  Must be before shlobjp.h!
#include <shlobj.h>    // IShellFolder
#include <ieguidp.h>
#include <iepriv.h>
#include <ccstock.h>   // From shell\inc.
#ifdef UNICODE
#include <port32.h>
#endif

#include <urlmon.h>    // IPersistMoniker, IBindStatusCallback
#ifdef UNICODE
#include <winineti.h>    // Cache APIs & structures
#endif

#include <intshcut.h>  // IUniformResourceLocator
#include <msxml.h>
#include <iimgctx.h>   // IImgCtx interface.

#include "shlwapi.h"

#include <webcheck.h>  // ISubscriptionMgr
#include <mstask.h>    // TASK_TRIGGER
#include <chanmgr.h>   // Channel Mgr interface
#include <shdocvw.h>   // WhichPlatform


//
// Localy defined includes.
//

#include "debug.h"
#include "cache.h"
#include "runonnt.h"
#include "globals.h"
#include "strutil.h"
#include "utils.h"

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)


#ifdef UNIX

extern "C" void unixEnsureFileScheme(TCHAR *lpszFileScheme);

#undef DebugMsg
#undef TraceMsg
#undef ASSERT

#ifdef DEBUG
extern "C" void _DebugMsgUnix(int i, const char *s, ...);
#define DebugMsg _DebugMsgUnix
#define TraceMsg _DebugMsgUnix
extern "C" void _DebugAssertMsgUnix(char *msg, char *fileName, int line);
#define ASSERT(x) { if(!(x)) _DebugAssertMsgUnix(#x, __FILE__, __LINE__);}
#else
#define DebugMsg
#define TraceMsg
#define ASSERT(x)
#endif /* DEBUG */
#endif /* UNIX */

#endif // _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\tooltip.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// infotip.cpp 
//
//   IQueryInfo for folder items.
//
//   History:
//
//       4/21/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "tooltip.h"
#include "dll.h"

//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::CQueryInfo ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CQueryInfo::CQueryInfo(
    PCDFITEMIDLIST pcdfidl,
    IXMLElementCollection* pIXMLElementCollection
)
: m_cRef(1)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext(pcdfidl)));
    ASSERT(XML_IsCdfidlMemberOf(pIXMLElementCollection, pcdfidl));

    ASSERT(NULL == m_pIXMLElement);

    if (pIXMLElementCollection)
    {
        XML_GetElementByIndex(pIXMLElementCollection, CDFIDL_GetIndex(pcdfidl),
                              &m_pIXMLElement);
    }

    if (m_pIXMLElement)
        m_fHasSubItems = XML_IsFolder(m_pIXMLElement);
        
    TraceMsg(TF_OBJECTS, "+ IQueryInfo");

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::CQueryInfo ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CQueryInfo::CQueryInfo(
    IXMLElement* pIXMLElement,
    BOOL         fHasSubItems
)
: m_cRef(1)
{
    if (pIXMLElement)
    {
        pIXMLElement->AddRef();
        m_pIXMLElement = pIXMLElement;
    }

    m_fHasSubItems = fHasSubItems;
    
    TraceMsg(TF_OBJECTS, "+ IQueryInfo");

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::~CQueryInfo ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CQueryInfo::~CQueryInfo(
    void
)
{
    ASSERT(0 == m_cRef);

    if (m_pIXMLElement)
        m_pIXMLElement->Release();

    TraceMsg(TF_OBJECTS, "- IQueryInfo");

    DllRelease();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::QueryInterface ***
//
//    CQueryInfo QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CQueryInfo::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IQueryInfo == riid)
    {
        AddRef();
        *ppv = (IQueryInfo*)this;
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::AddRef ***
//
//    CQueryInfo AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CQueryInfo::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo::Release ***
//
//    CQueryInfo Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CQueryInfo::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CQueryInfo:: ***
//
//
// Description:
//     Returns an info tip for the current pidl.
//
// Parameters:
//     [In]  dwFlags   - 
//     [Out] ppwszText - A pointer to a text buffer.  MAX_PATH length assumed!
//
// Return:
//     S_OK if the tip was extracted and returned.
//     E_OUTOFMEMORY if not enough memory is available.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CQueryInfo::GetInfoTip(
    DWORD dwFlags,
    WCHAR** ppwszTip
)
{
    ASSERT(ppwszTip);

    *ppwszTip = NULL;

    HRESULT hr;

    if (m_pIXMLElement)
    {
        BSTR bstr;

        bstr = XML_GetAttribute(m_pIXMLElement, XML_ABSTRACT);

        if (bstr)
        {
            if (*bstr)
            {
                //
                // REVIEW:  SHAlloc correct allocator?
                //

                int cbSize = SysStringByteLen(bstr) + sizeof(WCHAR);

                *ppwszTip = (WCHAR*)SHAlloc(cbSize);

                if (*ppwszTip)
                {
                    StrCpyNW(*ppwszTip, bstr, cbSize / sizeof(WCHAR));

                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                //
                // REVIEW:  InfoTip when there is no abstract?
                //

                hr = E_FAIL;
            }

            SysFreeString(bstr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ASSERT((SUCCEEDED(hr) && *ppwszTip) || (FAILED(hr) && *ppwszTip == NULL));

    return hr;
}




HRESULT
CQueryInfo::GetInfoFlags(
    DWORD *pdwFlags
)
{
    ASSERT(pdwFlags);

    HRESULT hr = S_OK;

    if(!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags = QIF_CACHED; // Assume cached by default
    if (!m_fHasSubItems)
        *pdwFlags |= QIF_DONTEXPANDFOLDER;

    if (m_pIXMLElement)
    {
        BSTR bstrURL = XML_GetAttribute(m_pIXMLElement, XML_HREF); 


        if (bstrURL)
        {
            if (*bstrURL)
            {
                BOOL fCached;
                //
                // REVIEW:  SHAlloc correct allocator?
                //
                fCached = CDFIDL_IsCachedURL(bstrURL);
                if(!fCached)
                    *pdwFlags &= ~QIF_CACHED;
            }

            SysFreeString(bstrURL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        //
        // If m_pIXMLElement is NULL either its a low memory situation, or
        // the corresponding cdf is not in the cache.
        // 

        *pdwFlags &= ~QIF_CACHED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\strutil.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// string.h 
//
//   String functions used by cdfview that are not in shlwapi.h.
//
//   History:
//
//       5/15/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _STRING_H_

#define _STRING_H_

//
// String function declarations.
//
#ifdef UNICODE
#define StrEql          StrEqlW
#else // UNICODE
#define StrEql          StrEqlA
#endif // UNICODE 

#define StrCpyA     lstrcpyA
#define StrCpyNA    lstrcpynA
#define StrCatA     lstrcatA

#define StrLen      lstrlen            // lstrlen works in W95.
#define StrLenA     lstrlenA
#define StrLenW     lstrlenW

//
// Function prototypes.
//

BOOL StrEqlA(LPCSTR p1, LPCSTR p2);
BOOL StrEqlW(LPCWSTR p1, LPCWSTR p2);

BOOL StrLocallyDisplayable(LPCWSTR pwsz);

#endif // _STRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\tooltip.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// tooltip.h 
//
//   Tool tip interface for items.
//
//   History:
//
//       4/21/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _TOOLTIP_H_

#define _TOOLTIP_H_

//
// Class definition for the item context menu class.
//

class CQueryInfo : public IQueryInfo
{
//
// Methods
//

public:

    // Constructor
    CQueryInfo(PCDFITEMIDLIST pcdfidl,
             IXMLElementCollection* pIXMLElementCollection);
    CQueryInfo(IXMLElement* pIXMLElement, BOOL fHasSubItems);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IQueryInfo methods.
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);
private:

    // Destructor.
    ~CQueryInfo(void);

//
// Member variables.
//

private:

    ULONG           m_cRef;
    IXMLElement*    m_pIXMLElement;
    BOOL            m_fHasSubItems;
};


#endif // _TOOLTIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\utils.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// utils.h 
//
//   Misc routines.
//
//   History:
//
//       6/25/97  tnoonan   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _UTILS_H_

#define _UTILS_H_

#define MAX_DEFCHANNELNAME  64

HRESULT GetURLFromIni(LPCTSTR pszPath, BSTR* pbstrURL);
HRESULT GetNameAndURLAndSubscriptionInfo(LPCTSTR pszPath, BSTR* pbstrName,
                                         BSTR* pbstrURL, SUBSCRIPTIONINFO* psi);
int CDFMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...);
BOOL DownloadCdfUI(HWND hwnd, LPCWSTR szURL, IXMLDocument* pIMLDocument);

BOOL IsGlobalOffline(void);
void SetGlobalOffline(BOOL fOffline);

BOOL CanSubscribe(LPCWSTR pwszURL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\view.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// view.h 
//
//   Definitions used by the IShellView helper functions.
//
//   History:
//
//       3/20/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _VIEW_H_

#define _VIEW_H_

//
// Function prototypes.
//

HRESULT CreateDefaultShellView(IShellFolder *pIShellFolder,
                               LPITEMIDLIST pidl,
                               IShellView** ppIShellView);

HRESULT CALLBACK IShellViewCallback(IShellView* pIShellViewOuter,
                                    IShellFolder* pIShellFolder,
                                    HWND hwnd,
                                    UINT msg,
                                    WPARAM wParam,
                                    LPARAM lParam);

HRESULT IShellView_GetDetails(UINT nColumn, PDETAILSINFO pDetails);



#endif // _VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\xmlutil.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// xmlutil.cpp 
//
//   XML item helper functions.
//
//   History:
//
//       4/1/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "winineti.h"
#include <ocidl.h>         // IPersistStreamInit.

//
// Function prototypes.
//


//
// XML helper functions.
//

////////////////////////////////////////////////////////////////////////////////
//
// *** XML_MarkCacheEntrySticky ***
//
// Description:
//     Marks the cache entry for the given URL as sticky by setting its
//     expiration delta to be very high
//
// Parameters:
//     [In]  lpszUrl       - url for cache entry to make sticky
//
// Return:
//     S_OK if the url entry was successfully marked sticky
//     E_FAIL otherwise.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT XML_MarkCacheEntrySticky(LPTSTR lpszURL)
{
    char chBuf[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    DWORD dwSize = sizeof(chBuf);
    lpInfo->dwStructSize = dwSize;

    if (GetUrlCacheEntryInfo(lpszURL, lpInfo, &dwSize))
    {
        lpInfo->dwExemptDelta = 0xFFFFFFFF; // make VERY sticky
        if (SetUrlCacheEntryInfo(lpszURL, lpInfo, CACHE_ENTRY_EXEMPT_DELTA_FC))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_SynchronousParse ***
//
//
// Description:
//     Synchronously parses the given URL.
//
// Parameters:
//     [In]  pIXMLDocument - An interface pointer to an XML document object.
//     [In]  pidl          - The pidl of the cdf file (contains the full path).
//
// Return:
//     S_OK if the object was parsed successfully.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_SynchronousParse(
    IXMLDocument* pIXMLDocument,
    LPTSTR szPath
)
{
    ASSERT(pIXMLDocument);
    ASSERT(szPath);

    HRESULT hr;

    IPersistStreamInit* pIPersistStreamInit;

    hr = pIXMLDocument->QueryInterface(IID_IPersistStreamInit,
                                       (void**)&pIPersistStreamInit);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIPersistStreamInit);

        IStream* pIStream;

        //
        // URLOpenBlockingStream pumps window messages!  Don't use it!
        //

        //hr = URLOpenBlockingStream(NULL, szPath, &pIStream, 0, NULL);

        hr = SHCreateStreamOnFile(szPath, STGM_READ, &pIStream);

        TraceMsg(TF_CDFPARSE, "[%s SHCreateStreamOnFileW %s %s %s]",
                 PathIsURL(szPath) ? TEXT("*** ") : TEXT(""), szPath,
                 SUCCEEDED(hr) ? TEXT("SUCCEEDED") : TEXT("FAILED"),
                 PathIsURL(szPath) ? TEXT("***") : TEXT(""));

        if (SUCCEEDED(hr))
        {
            ASSERT(pIStream);

            //
            // Load loads and parses the file.  If this call succeeds the cdf
            // will be displayed.  If it fails none of the cdf is displayed.
            //

            hr = pIPersistStreamInit->Load(pIStream);

            TraceMsg(TF_CDFPARSE, "[XML Parser %s]", 
                     SUCCEEDED(hr) ? TEXT("SUCCEEDED") : TEXT("FAILED"));

            pIStream->Release();

            //
            // If CDFVIEW is downloading a CDF from the net mark it as sticky
            // in the cache
            //
            if (PathIsURL(szPath))
            {
                XML_MarkCacheEntrySticky(szPath);
            }
        }

        pIPersistStreamInit->Release();
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_DownloadImages ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_DownloadLogo(
    IXMLDocument *pIXMLDocument
)
{
    ASSERT(pIXMLDocument);

    HRESULT hr;

    IXMLElement* pIXMLElement;
    LONG         nIndex;

    hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);
        
        BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_LOGO);

        if (bstrURL)
        {
            hr = XML_DownloadImage(bstrURL);

            SysFreeString(bstrURL);
        }

        //
        // Download the wide logo also.
        //

        bstrURL = XML_GetAttribute(pIXMLElement, XML_LOGO_WIDE);

        if (bstrURL)
        {
            hr = XML_DownloadImage(bstrURL);

            SysFreeString(bstrURL);
        }


        pIXMLElement->Release();
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_DownloadImages ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_DownloadImages(
    IXMLDocument *pIXMLDocument
)
{
    ASSERT(pIXMLDocument);

    HRESULT hr;

    IXMLElement* pIXMLElement;
    LONG         nIndex;

    hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);
        
        hr = XML_RecursiveImageDownload(pIXMLElement);

        pIXMLElement->Release();
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_RecuriveImageDownload ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_RecursiveImageDownload(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    HRESULT hr = S_OK;

    BSTR bstrTagName;

    HRESULT hr2 = pIXMLElement->get_tagName(&bstrTagName);

    if (SUCCEEDED(hr2) && bstrTagName)
    {
        if (StrEqlW(bstrTagName, WSTR_LOGO))
        {
            BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_HREF);

            if (bstrURL && *bstrURL != 0)
            {
                hr = XML_DownloadImage(bstrURL);

                SysFreeString(bstrURL);
            }
        }
        else if (XML_IsCdfDisplayable(pIXMLElement))
        {
            IXMLElementCollection* pIXMLElementCollection;

            hr2 = pIXMLElement->get_children(&pIXMLElementCollection);

            if (SUCCEEDED(hr2) && pIXMLElementCollection)
            {
                ASSERT(pIXMLElementCollection);

                LONG nCount;

                hr2 = pIXMLElementCollection->get_length(&nCount);

                ASSERT(SUCCEEDED(hr2) || (FAILED(hr2) && 0 == nCount));

                for (int i = 0; i < nCount; i++)
                {
                    IXMLElement* pIXMLElementChild;

                    hr2 = XML_GetElementByIndex(pIXMLElementCollection, i,
                                                &pIXMLElementChild);

                    if (SUCCEEDED(hr2))
                    {
                        ASSERT (pIXMLElementChild);

                        XML_RecursiveImageDownload(pIXMLElementChild);

                        pIXMLElementChild->Release();
                    }
                }

                pIXMLElementCollection->Release();
            }
        }

        SysFreeString(bstrTagName);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_DownloadImage ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_DownloadImage(
    LPCWSTR pwszURL
)
{
    ASSERT (pwszURL);

    HRESULT hr;

    WCHAR szFileW[MAX_PATH];

    hr = URLDownloadToCacheFileW(NULL, pwszURL, szFileW,
                                 ARRAYSIZE(szFileW), 0, NULL);

    //
    // Mark the logo in the cache as sticky
    //

    if (SUCCEEDED(hr))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL));

        XML_MarkCacheEntrySticky(szURL);
    }

    #ifdef DEBUG

        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL));

        TraceMsg(TF_CDFPARSE,
                 "[*** Image URLDownloadToCacheFileW %s %s ***]",
                  szURL, SUCCEEDED(hr) ? TEXT("SUCCEEDED") :
                                         TEXT("FAILED"));

    #endif // DEBUG

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetDocType ***
//
//
// Description:
//     Returns the type of the given xml document.
//
// Parameters:
//     [In]  pIXMLDocument - A pointer to the xml document.
//
// Return:
//     DOC_CHANNEL, DOC_DESKTOPCOMPONENT, DOC_SOFTWAREUPDATE, or DOC_UNKNOWN.
//
// Comments:
//     If at the root level of a channel an ITEM contains a USAGE type of
//     DesktopComponent then the document is a Desktop Component otherwise
//     it is a channel.
//
////////////////////////////////////////////////////////////////////////////////
XMLDOCTYPE
XML_GetDocType(IXMLDocument* pIXMLDocument)
{
    ASSERT(pIXMLDocument);

    XMLDOCTYPE xdtRet;

    IXMLElement* pIXMLElement;
    LONG         nIndex;

    HRESULT hr = XML_GetFirstDesktopComponentElement(pIXMLDocument,
                                                     &pIXMLElement,
                                                     &nIndex);
    
    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        xdtRet = DOC_DESKTOPCOMPONENT;

        pIXMLElement->Release();
    }
    else
    {
        hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement,
                                        &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            BSTR bstr = XML_GetAttribute( pIXMLElement, XML_USAGE_SOFTWAREUPDATE );

            if (bstr)
            {
                SysFreeString(bstr);
                xdtRet = DOC_SOFTWAREUPDATE;
            }
            else
            {
                xdtRet = DOC_CHANNEL;
            }


            pIXMLElement->Release();
        }
        else
        {
            xdtRet = DOC_UNKNOWN;
        }
    }

    return xdtRet;
}



//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetChildElementCollection ***
//
//
// Description:
//     Returns an element collection given the parent collection and an index.
//
// Parameters:
//     [In]  pParentIXMLElementCollection - The parent collection.
//     [In]  nIndex                       - Index to the requested collection.
//     [Out] ppIXMLElementCollection      - A pointer that receives the
//                                          requested collection.
//
// Return:
//     S_OK if the collection is returned.
//     E_FAIL otherwise.
//
// Comments:
//     The caller is responsible for calling Release() on the returned interface
//     pointer.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetChildElementCollection(
    IXMLElementCollection *pParentIXMLElementCollection,
    LONG nIndex,
    IXMLElementCollection** ppIXMLElementCollection
)
{
    ASSERT(pParentIXMLElementCollection);
    ASSERT(ppIXMLElementCollection);

    HRESULT hr;

    IXMLElement* pIXMLElement;

    hr = XML_GetElementByIndex(pParentIXMLElementCollection, nIndex,
                               &pIXMLElement);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        hr = pIXMLElement->get_children(ppIXMLElementCollection);
        if(SUCCEEDED(hr) && !(*ppIXMLElementCollection))
            hr = E_FAIL;

        pIXMLElement->Release();
    }

    ASSERT((SUCCEEDED(hr) && (*ppIXMLElementCollection)) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetElementByIndex ***
//
//
// Description:
//     Returns the nIndex'th element of the given collection.
//
// Parameters:
//     [In]  pIXMLElementCollection - A pointer to the collection.
//     [In]  nIndex                 - The index of the item to retrieve.
//     [Out] ppIXMLElement          - A pointer that receives the item.
//
// Return:
//     S_OK if the item was retrieved.
//     E_FAIL otherwise.
//
// Comments:
//     The caller is responsible for calling Release() on the returned interface
//     pointer.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetElementByIndex(
    IXMLElementCollection* pIXMLElementCollection,
    LONG nIndex,
    IXMLElement** ppIXMLElement
)
{
    ASSERT(pIXMLElementCollection);
    ASSERT(ppIXMLElement);

    HRESULT hr;

    VARIANT var1, var2;

    VariantInit(&var1);
    VariantInit(&var2);

    var1.vt   = VT_I4;
    var1.lVal = nIndex;

    IDispatch* pIDispatch;

    hr = pIXMLElementCollection->item(var1, var2, &pIDispatch);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIDispatch);

        hr = pIDispatch->QueryInterface(IID_IXMLElement, (void**)ppIXMLElement);

        pIDispatch->Release();
    }
    else
    {
        *ppIXMLElement = NULL;
    }

    ASSERT((SUCCEEDED(hr) && *ppIXMLElement) || 
           (FAILED(hr) && NULL == *ppIXMLElement));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetElementByName ***
//
//
// Description:
//     Returns the first element with the given tag name.
//
// Parameters:
//     [In]  pIXMLElementCollection - A pointer to the collection.
//     [In]  nszNameW               - The tag name of the item to retrieve.
//     [Out] ppIXMLElement          - A pointer that receives the item.
//
// Return:
//     S_OK if the item was retrieved.
//     E_OUTOFMEMORY if a sys string could not be allocated.
//     E_FAIL otherwise.
//
// Comments:
//     The caller is responsible for calling Release() on the returned interface
//     pointer.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetElementByName(
    IXMLElementCollection* pIXMLElementCollection,
    LPWSTR szNameW,
    IXMLElement** ppIXMLElement
)
{
    ASSERT(pIXMLElementCollection);
    ASSERT(ppIXMLElement);

    HRESULT hr = E_FAIL;

    LONG nCount;

    HRESULT hr2 = pIXMLElementCollection->get_length(&nCount);

    ASSERT(SUCCEEDED(hr2) || (FAILED(hr2) && 0 == nCount));

    for (int i = 0, bElement = FALSE; (i < nCount) && !bElement; i++)
    {
        IXMLElement* pIXMLElement;

        hr2 = XML_GetElementByIndex(pIXMLElementCollection, i, &pIXMLElement);

        if (SUCCEEDED(hr2))
        {
            ASSERT(pIXMLElement);

            BSTR pStr;

            hr2 = pIXMLElement->get_tagName(&pStr);

            if (SUCCEEDED(hr2) && pStr)
            {
                ASSERT(pStr);

                if (bElement = StrEqlW(pStr, szNameW))
                {
                    pIXMLElement->AddRef();
                    *ppIXMLElement = pIXMLElement;
                    
                    hr = S_OK;
                }

                SysFreeString(pStr);
            }

            pIXMLElement->Release();
        }
    }

    hr = FAILED(hr2) ? hr2 : hr;

    /* Enable this when pIXMLElementCollection->item works with VT_BSTR

    VARIANT var1, var2;

    VariantInit(&var1);
    VariantInit(&var2);

    var1.vt      = VT_BSTR;
    var1.bstrVal = SysAllocString(szNameW);

    var2.vt      = VT_I4
    var2.lVal    = 1;

    if (var1.bstrVal)
    {

        IDispatch* pIDispatch;

        hr = pIXMLElementCollection->item(var1, var2, &pIDispatch);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIDispatch);

            hr = pIDispatch->QueryInterface(IID_IXMLElement,
                                            (void**)ppIXMLElement);

            pIDispatch->Release();
        }

        SysFreeString(var1.bstrVal);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    */

    ASSERT((SUCCEEDED(hr) && ppIXMLElement) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetFirstChannelElement ***
//
//
// Description:
//     Returns the IXMLElement of the first channel in the XML document.
//
// Parameters:
//     [In]  pIXMLDocument - A pointer to the XML document object.
//     [Out] ppIXMLElement - The pointer that receives the element.
//     [Out] pnIndex       - The index of the element.
//
// Return:
//     S_OK if the first channel element was returned.
//     E_FAIL if the element couldn't be returned.
//
// Comments:
//     This function can't call XML_GetElementByName to find the first channel.
//     XML channels can have a tag name of "Channel" or "CHAN".
//     XML_GetElementByName wouldn't be able to determine which of the items
//     came first if both where present in the XML doc.
//
//     The caller is responsible for calling Release() on the returned interface
//     pointer.  The return pointer is not NULL'ed out on error.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetFirstChannelElement(
    IXMLDocument* pIXMLDocument,
    IXMLElement** ppIXMLElement,
    PLONG pnIndex)
{
    ASSERT(pIXMLDocument);
    ASSERT(ppIXMLElement);
    ASSERT(pnIndex);
    IXMLElement *pRootElem = NULL;
    HRESULT hr = E_FAIL;

    *pnIndex = 0;
    hr = pIXMLDocument->get_root(&pRootElem);

    if (SUCCEEDED(hr) && pRootElem)
    {
        ASSERT(pRootElem);

        if (XML_IsChannel(pRootElem))
        {
            *ppIXMLElement = pRootElem;
            hr = S_OK;
        }
        else
        {
            pRootElem->Release();
            hr = E_FAIL;
        }
            
    }
    else
    {
        hr = E_FAIL;
    }

    ASSERT((SUCCEEDED(hr) && (*ppIXMLElement)) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetDesktopElementFromChannelElement ***
//
//
// Description:
//     Returns the IXMLElement of the first dekstop component in the channel.
//
// Parameters:
//     [In]  pChannelIXMLElement - A pointer to the XML channel element.
//     [Out] ppIXMLElement       - The pointer that receives the element.
//     [Out] pnIndex             - The index of the element.
//
// Return:
//     S_OK if the first desktop element was returned.
//     E_FAIL if the element couldn't be returned.
//
// Comments:
//     This looks for the first ITEM with a usage of DesktopComponent.
//
////////////////////////////////////////////////////////////////////////////////

HRESULT
XML_GetDesktopElementFromChannelElement(
    IXMLElement* pChannelIXMLElement,
    IXMLElement** ppIXMLElement,
    PLONG pnIndex)
{
    ASSERT(pChannelIXMLElement);
    ASSERT(ppIXMLElement);
    ASSERT(pnIndex);

    HRESULT hr;

    IXMLElementCollection* pIXMLElementCollection;

    hr = pChannelIXMLElement->get_children(&pIXMLElementCollection);

    if (SUCCEEDED(hr) && pIXMLElementCollection)
    {
        ASSERT(pIXMLElementCollection);

        LONG nCount;

        hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        hr = E_FAIL;

        for (int i = 0, bComponent = FALSE; (i < nCount) && !bComponent;
             i++)
        {
            IXMLElement* pIXMLElement;

            HRESULT hr2 = XML_GetElementByIndex(pIXMLElementCollection, i,
                                                &pIXMLElement);

            if (SUCCEEDED(hr2))
            {
                ASSERT(pIXMLElement);

                if (bComponent = XML_IsDesktopComponent(pIXMLElement))
                {
                    pIXMLElement->AddRef();
                    *ppIXMLElement = pIXMLElement;
                    *pnIndex = i;

                    hr = S_OK;
                }

                pIXMLElement->Release();
            }

            hr = FAILED(hr2) ? hr2 : hr;
        }

        pIXMLElementCollection->Release();
    }        
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetFirstDesktopComponentElement ***
//
//
// Description:
//     Returns the IXMLElement of the first dekstop component in the channel.
//
// Parameters:
//     [In]  pIXMLDocument - A pointer to the XML document object.
//     [Out] ppIXMLElement - The pointer that receives the element.
//     [Out] pnIndex       - The index of the element.
//
// Return:
//     S_OK if the first channel element was returned.
//     E_FAIL if the element couldn't be returned.
//
// Comments:
//     This function gets the first channel and then looks for the first
//     top-level ITEM with a usage of DesktopComponent.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetFirstDesktopComponentElement(
    IXMLDocument* pIXMLDocument,
    IXMLElement** ppIXMLElement,
    PLONG pnIndex)
{
    ASSERT(pIXMLDocument);
    ASSERT(ppIXMLElement);
    ASSERT(pnIndex);

    HRESULT hr;

    IXMLElement* pChannelIXMLElement;
    LONG         nIndex;

    hr = XML_GetFirstChannelElement(pIXMLDocument, &pChannelIXMLElement,
                                    &nIndex);

    if (SUCCEEDED(hr))
    {
        ASSERT(pChannelIXMLElement);

        hr = XML_GetDesktopElementFromChannelElement(pChannelIXMLElement, 
                                                     ppIXMLElement, 
                                                     pnIndex);

        pChannelIXMLElement->Release();
    }

    ASSERT((SUCCEEDED(hr) && *ppIXMLElement) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetFirstDesktopComponentUsageElement ***
//
//
// Description:
//     Returns the first USAGE VALUE="DesktopComponent" element of the first
//     desktop component.
//
// Parameters:
//     [In]  pIXMLDocument - A pointer to the the document.
//     [Out] pIXMLElement  - A pointer the receives the element.
//
// Return:
//     S_OK if the element was found.
//     E_FAIL if the element wasn't found.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetFirstDesktopComponentUsageElement(
    IXMLDocument* pIXMLDocument,
    IXMLElement** ppIXMLElement
)
{
    ASSERT(pIXMLDocument);
    ASSERT(ppIXMLElement);

    HRESULT hr;

    IXMLElement* pParentIXMLElement;
    LONG         nIndex;

    hr = XML_GetFirstDesktopComponentElement(pIXMLDocument, &pParentIXMLElement,
                                             &nIndex);

    if (SUCCEEDED(hr))
    {
        IXMLElementCollection* pIXMLElementCollection;

        hr = pParentIXMLElement->get_children(&pIXMLElementCollection);

        if (SUCCEEDED(hr) && pIXMLElementCollection)
        {
            ASSERT(pIXMLElementCollection);

            LONG nCount;

            hr = pIXMLElementCollection->get_length(&nCount);

            ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

            hr = E_FAIL;

            for (int i = 0, bUsage = FALSE; (i < nCount) && !bUsage; i++)
            {
                IXMLElement* pIXMLElement;

                HRESULT hr2 = XML_GetElementByIndex(pIXMLElementCollection, i,
                                                    &pIXMLElement);

                if (SUCCEEDED(hr2))
                {
                    ASSERT(pIXMLElement);

                    if (bUsage = XML_IsDesktopComponentUsage(pIXMLElement))
                    {
                        pIXMLElement->AddRef();
                        *ppIXMLElement = pIXMLElement;
                        //*pnIndex = i;

                        hr = S_OK;
                    }

                    pIXMLElement->Release();
                }

                hr = FAILED(hr2) ? hr2 : hr;
            }

            pIXMLElementCollection->Release();
        } 
        else
        {
            hr = E_FAIL;
        }

        pParentIXMLElement->Release();
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetDesktopComponentInfo ***
//
//
// Description:
//     Fills in the desktop component information structure.
//
// Parameters:
//     [In]  pIXMLDocument - A ponter to the document.
//     [Out] pInfo         - A desktop component information structure.
//
// Return:
//     S_OK if the given document is desktop component document.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetDesktopComponentInfo(
    IXMLDocument* pIXMLDocument,
    COMPONENT* pInfo
)
{
    ASSERT(pIXMLDocument);
    ASSERT(pInfo);

    HRESULT hr;

    IXMLElement* pIXMLElement;

    hr = XML_GetFirstDesktopComponentUsageElement(pIXMLDocument, &pIXMLElement);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        ZeroMemory(pInfo, sizeof(COMPONENT));

        pInfo->dwSize        = sizeof(COMPONENT);
        pInfo->fChecked      = TRUE;
        pInfo->fDirty        = TRUE;
        pInfo->fNoScroll     = FALSE;
        pInfo->cpPos.dwSize  = sizeof(COMPPOS);
        pInfo->cpPos.izIndex = COMPONENT_TOP;
        pInfo->dwCurItemState = IS_NORMAL;

        BSTR bstrValue;

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_OPENAS))
        {
            if (!(0 == StrCmpIW(bstrValue, WSTR_IMAGE)))
            {
                pInfo->iComponentType = COMP_TYPE_WEBSITE;
            }
            else
            {
                pInfo->iComponentType = COMP_TYPE_PICTURE;
            }

            SysFreeString(bstrValue);
        }

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_WIDTH))
        {
            pInfo->cpPos.dwWidth = StrToIntW(bstrValue);
            SysFreeString(bstrValue);
        }

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_HEIGHT))
        {
            pInfo->cpPos.dwHeight = StrToIntW(bstrValue);
            SysFreeString(bstrValue);
        }

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_ITEMSTATE))
        {
            if(!StrCmpIW(bstrValue, WSTR_NORMAL))
                pInfo->dwCurItemState = IS_NORMAL;
            else
            {
                if(!StrCmpIW(bstrValue, WSTR_FULLSCREEN))
                    pInfo->dwCurItemState = IS_FULLSCREEN;
                else
                    pInfo->dwCurItemState = IS_SPLIT;
            }
            SysFreeString(bstrValue);
        }
        
        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_CANRESIZE))
        {
            pInfo->cpPos.fCanResize = StrEqlW(bstrValue, WSTR_YES);
            SysFreeString(bstrValue);
        }
        else
        {
            if (bstrValue = XML_GetAttribute(pIXMLElement, XML_CANRESIZEX))
            {
                pInfo->cpPos.fCanResizeX = StrEqlW(bstrValue, WSTR_YES);
                SysFreeString(bstrValue);
            }

            if (bstrValue = XML_GetAttribute(pIXMLElement, XML_CANRESIZEY))
            {
                pInfo->cpPos.fCanResizeY = StrEqlW(bstrValue, WSTR_YES);
                SysFreeString(bstrValue);
            }
        }

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_PREFERREDLEFT))
        {
            if (StrChrW(bstrValue, L'%'))
            {
                pInfo->cpPos.iPreferredLeftPercent = StrToIntW(bstrValue);
            }
            else
            {
                pInfo->cpPos.iLeft = StrToIntW(bstrValue);
            }

            SysFreeString(bstrValue);
        }

        if (bstrValue = XML_GetAttribute(pIXMLElement, XML_PREFERREDTOP))
        {
            if (StrChrW(bstrValue, L'%'))
            {
                pInfo->cpPos.iPreferredTopPercent = StrToIntW(bstrValue);
            }
            else
            {
                pInfo->cpPos.iTop = StrToIntW(bstrValue);
            }

            SysFreeString(bstrValue);        
        }

        IXMLElement *pIXMLElementParent;

        hr = pIXMLElement->get_parent(&pIXMLElementParent);
        if(!pIXMLElementParent)
            hr = E_FAIL;
        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElementParent);

            if (bstrValue = XML_GetAttribute(pIXMLElementParent, XML_TITLE))
            {
                StrCpyNW(pInfo->wszFriendlyName, bstrValue,
                         ARRAYSIZE(pInfo->wszFriendlyName));
                SysFreeString(bstrValue);
            }

            if (bstrValue = XML_GetAttribute(pIXMLElementParent, XML_HREF))
            {
                if (*bstrValue)
                {
                    StrCpyNW(pInfo->wszSource, bstrValue,
                             ARRAYSIZE(pInfo->wszSource));
                    SysFreeString(bstrValue);
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (SUCCEEDED(hr))
            {
                IXMLElement *pIXMLChannel;
                LONG nIndex;

                hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLChannel,
                                                &nIndex);
                if (SUCCEEDED(hr))
                {
                    ASSERT(pIXMLChannel);
                    if (bstrValue = XML_GetAttribute(pIXMLChannel, XML_SELF))
                    {
                        StrCpyNW(pInfo->wszSubscribedURL, bstrValue,
                                 ARRAYSIZE(pInfo->wszSubscribedURL));
                        SysFreeString(bstrValue);
                    }

                    pIXMLChannel->Release();
                }
            }

            pIXMLElementParent->Release();
        }

        pIXMLElement->Release();
    }

    return hr;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetAttribute ***
//
//
// Description:
//     Returns a bstr representing the requested attribute of the given element.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the XML element.
//     [In]  attribute    - The requested attribute.
//
// Return:
//     A bstr with the attribute value.
//     NULL if there wasn't enough memory to allocated the bstr.
//
// Comments:
//     This function keeps a table of attributes and their properties.  It bases
//     attribute look up on this table.
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_GetAttribute(
    IXMLElement* pIXMLElement,
    XML_ATTRIBUTE attrIndex
)
{
    //
    // A table is used to read values associated with a given xml element.  The
    // xml element can have attributes (values inside the elements tag) or child
    // elements (elements between tags).
    //
    // Rules:
    //        1) If child is NULL. Read the Attribute from the current item.
    //        2) If child is not NULL, read the Attribute from the child
    //           item.
    //        3) If AttributeType is NULL, use the Attribute value to read the
    //           attribute.
    //        4) If AttributeType is not NULL, verify that the item contains
    //           the AttributeType attribute before using Attribute to read
    //           the value.
    //        5) If the value is not found use Default as the return value.
    //

    static const struct _tagXML_ATTRIBUTE_ARRAY
    {
        LPWSTR                  szChildW;
        LPWSTR                  szAttributeW;
        LPWSTR                  szQualifierW;
        LPWSTR                  szQualifierValueW;
        XML_ATTRIBUTE           attrSecondary;
        LPWSTR                  szDefaultW;
        BOOL                    fUseBaseURL;
        XML_ATTRIBUTE           attribute;  // Only used in ASSERT.
    }
    aAttribTable[] =
    {
/*
Child           Attribute      Qualifier   Qual. Value   Secondary Lookup   Default     Base URL Enum Check
--------------  -------------- ----------- ------------  -----------------  ----------  -------- -----------------*/
{WSTR_TITLE,    NULL,          NULL,       NULL,         XML_TITLE_ATTR,    WSTR_EMPTY, FALSE,   XML_TITLE        },
{NULL,          WSTR_TITLE,    NULL,       NULL,         XML_HREF,          WSTR_EMPTY, FALSE,   XML_TITLE_ATTR   },
{NULL,          WSTR_HREF,     NULL,       NULL,         XML_A_HREF,        WSTR_EMPTY, TRUE,    XML_HREF         },
{WSTR_ABSTRACT, NULL,          NULL,       NULL,         XML_ABSTRACT_ATTR, WSTR_EMPTY, FALSE,   XML_ABSTRACT     },
{NULL,          WSTR_ABSTRACT, NULL,       NULL,         XML_HREF,          WSTR_EMPTY, FALSE,   XML_ABSTRACT_ATTR},
{WSTR_LOGO,     WSTR_HREF,     WSTR_STYLE, WSTR_ICON,    XML_NULL,          NULL,       TRUE,    XML_ICON         },
{WSTR_LOGO,     WSTR_HREF,     WSTR_STYLE, WSTR_IMAGE,   XML_LOGO_DEFAULT,  NULL,       TRUE,    XML_LOGO         },
{WSTR_LOGO,     WSTR_HREF,     NULL,       NULL,         XML_NULL,          NULL,       TRUE,    XML_LOGO_DEFAULT },
{NULL,          WSTR_SELF,     NULL,       NULL,         XML_SELF_OLD,      NULL,       TRUE,    XML_SELF         },
{WSTR_SELF,     WSTR_HREF,     NULL,       NULL,         XML_NULL,          NULL,       TRUE,    XML_SELF_OLD     },
{NULL,          WSTR_BASE,     NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_BASE         },
{WSTR_USAGE,    WSTR_VALUE,    NULL,       NULL,         XML_SHOW,          NULL,       FALSE,   XML_USAGE        },
{WSTR_USAGE,    WSTR_VALUE,    WSTR_VALUE, WSTR_CHANNEL, XML_SHOW_CHANNEL,  NULL,       FALSE,   XML_USAGE_CHANNEL},
{WSTR_USAGE,    WSTR_VALUE,    WSTR_VALUE, WSTR_DSKCMP,  XML_SHOW_DSKCMP,   NULL,       FALSE,   XML_USAGE_DSKCMP },
{WSTR_WIDTH,    WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_ZERO,  FALSE,   XML_WIDTH        },
{WSTR_HEIGHT,   WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_ZERO,  FALSE,   XML_HEIGHT       },
{WSTR_RESIZE,   WSTR_VALUE,    NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_CANRESIZE    },
{WSTR_RESIZEX,  WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_YES,   FALSE,   XML_CANRESIZEX   },
{WSTR_RESIZEY,  WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_YES,   FALSE,   XML_CANRESIZEY   },
{WSTR_PREFLEFT, WSTR_VALUE,    NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_PREFERREDLEFT},
{WSTR_PREFTOP,  WSTR_VALUE,    NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_PREFERREDTOP },
{WSTR_OPENAS,   WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_HTML,  FALSE,   XML_OPENAS       },
{NULL,          WSTR_SHOW,     NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_SHOW         },
{NULL,          WSTR_SHOW,     WSTR_SHOW,  WSTR_CHANNEL, XML_NULL,          NULL,       FALSE,   XML_SHOW_CHANNEL },
{NULL,          WSTR_SHOW,     WSTR_SHOW,  WSTR_DSKCMP,  XML_NULL,          NULL,       FALSE,   XML_SHOW_DSKCMP  },
{WSTR_A,        WSTR_HREF,     NULL,       NULL,         XML_INFOURI,       WSTR_EMPTY, TRUE,    XML_A_HREF       },
{NULL,          WSTR_INFOURI,  NULL,       NULL,         XML_NULL,          WSTR_EMPTY, TRUE,    XML_INFOURI      },
{WSTR_LOGO,     WSTR_HREF,     WSTR_STYLE, WSTR_IMAGEW,  XML_NULL,          NULL,       TRUE,    XML_LOGO_WIDE    },
{WSTR_LOGIN,    NULL,          NULL,       NULL,         XML_NULL,          NULL,       FALSE,   XML_LOGIN        },

{WSTR_USAGE,    WSTR_VALUE,    WSTR_VALUE, WSTR_SOFTWAREUPDATE, XML_SHOW_SOFTWAREUPDATE,  NULL,       FALSE,   XML_USAGE_SOFTWAREUPDATE},
{NULL,          WSTR_SHOW,     WSTR_SHOW,  WSTR_SOFTWAREUPDATE, XML_NULL,                 NULL,       FALSE,   XML_SHOW_SOFTWAREUPDATE },
{WSTR_ITEMSTATE,WSTR_VALUE,    NULL,       NULL,         XML_NULL,          WSTR_NORMAL,FALSE,   XML_ITEMSTATE   },
    };

    ASSERT(pIXMLElement);

    //
    // REVIEW: aAttribTable attribute field only used in debug builds.
    //

    ASSERT(attrIndex == aAttribTable[attrIndex].attribute);

    BSTR bstrRet = NULL;

    if (NULL == aAttribTable[attrIndex].szAttributeW)
    {
        bstrRet = XML_GetGrandChildContent(pIXMLElement,
                                      aAttribTable[attrIndex].szChildW);
    
    }
    else if (NULL != aAttribTable[attrIndex].szChildW)
    {
        bstrRet = XML_GetChildAttribute(pIXMLElement,
                                     aAttribTable[attrIndex].szChildW,
                                     aAttribTable[attrIndex].szAttributeW, 
                                     aAttribTable[attrIndex].szQualifierW,
                                     aAttribTable[attrIndex].szQualifierValueW);
    }
    else
    {
        bstrRet = XML_GetElementAttribute(pIXMLElement,
                                     aAttribTable[attrIndex].szAttributeW,
                                     aAttribTable[attrIndex].szQualifierW,
                                     aAttribTable[attrIndex].szQualifierValueW);
    }

    //
    // If the title or tooltip aren't displayable on the local system use the
    // URL in their place.
    //

    if (bstrRet && (XML_TITLE == attrIndex || XML_TITLE_ATTR == attrIndex ||
                    XML_ABSTRACT == attrIndex))
    {
        if (!StrLocallyDisplayable(bstrRet))
        {
            SysFreeString(bstrRet);
            bstrRet = NULL;
        }
    }
    
    //
    // Special cases:
    //     TITLE can also be an attribute.
    //     ABSTRACT can also be an attribute.
    //     LOGO elements don't have to have the TYPE="IMAGE"
    //     SELF is now an attribute SELF_OLD can be removed in the future.
    //     USAGE can also be specified via the SHOW attribute.
    //     USAGE_CHANNEL should also check for SHOW="Channel".
    //     USAGE_DSKCMP should also check for SHOW="DesktopComponent"
    //

    if (NULL == bstrRet && XML_NULL != aAttribTable[attrIndex].attrSecondary)
    {
        bstrRet = XML_GetAttribute(pIXMLElement,
                                   aAttribTable[attrIndex].attrSecondary);
    }

    //
    // Combine URL if required.
    //

    if (bstrRet && aAttribTable[attrIndex].fUseBaseURL)
    {
        BSTR bstrBaseURL = XML_GetBaseURL(pIXMLElement);

        if (bstrBaseURL)
        {
            
            BSTR bstrCombinedURL = XML_CombineURL(bstrBaseURL, bstrRet);

            if (bstrCombinedURL)
            {
                SysFreeString(bstrRet);
                bstrRet = bstrCombinedURL;
            }

            SysFreeString(bstrBaseURL);
        }
    }

    /* The following prevents long urls from over-running the pidl buffer */

    if (bstrRet &&
        (attrIndex == XML_HREF) &&
        (SysStringLen(bstrRet) > INTERNET_MAX_URL_LENGTH))
    {
       SysReAllocStringLen(&bstrRet, bstrRet, INTERNET_MAX_URL_LENGTH-1);
    }

    /* The following prevents long names from over-running the pidl buffer */

    if (bstrRet &&
        (attrIndex == XML_TITLE) &&
        (SysStringLen(bstrRet) > MAX_PATH))
    {
       SysReAllocStringLen(&bstrRet, bstrRet, MAX_PATH-1);
    }

    //
    // Set default return value.
    //

    if (NULL == bstrRet && aAttribTable[attrIndex].szDefaultW)
        bstrRet = SysAllocString(aAttribTable[attrIndex].szDefaultW);

    
    return bstrRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetFirstChildContent ***
//
// Description:
//     Returns a bstr value from first child of the given element.
//
// Parameters:
//     [In]  pIXMLElement     - A pointer to the element.
//     The caller is responsible for freeing the returned bstr.
//
// Comments:
//     If pIElement represents
//
//         <Title>Harvey is a Cool Cat<B>this will be ignored</B></Title>
//
//         Then this function will return
//
//             "Harvey is a Cool Cat"
//
// REVIEW THIS IS A TEMPORARY ROUTINE UNTIL THE XML PARSER SUPPORTS THIS DIRECTLY
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_GetFirstChildContent(
    IXMLElement* pIXMLElement
)
{    
    ASSERT(pIXMLElement);

    BSTR bstrRet = NULL;

    IXMLElementCollection* pIXMLElementCollection;

    if ((SUCCEEDED(pIXMLElement->get_children(&pIXMLElementCollection)))
            && pIXMLElementCollection)
    {
        ASSERT(pIXMLElementCollection);

        LONG nCount;

        HRESULT hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        if (nCount >= 1)
        {
            IXMLElement* pChildIXMLElement;

            if (SUCCEEDED(XML_GetElementByIndex(pIXMLElementCollection, 0,
                                                &pChildIXMLElement)))
            {
                ASSERT(pChildIXMLElement);

                if (FAILED(pChildIXMLElement->get_text(&bstrRet)))
                {
                    bstrRet = NULL;
                }

                pChildIXMLElement->Release();
            }
        }

        pIXMLElementCollection->Release();
    }
    
    return bstrRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetGrandChildContent ***
//
// Description:
//     Returns a bstr value from the requested child of the given element.
//
// Parameters:
//     [In]  pIXMLElement     - A pointer to the element.
//     [In]  szChildW         - The name of the child element.
//     The caller is responsible for freeing the returned bstr.
//
// Comments:
//     If pIElement represents
//
//             <Channel>
//                 <Title>Harvey is a Cool Cat</Title>
//             </Channel>
//
//         Then this function will return
//
//             "Harvey is a Cool Cat" for "TITLE",  
//
////////////////////////////////////////////////////////////////////////////////

BSTR
XML_GetGrandChildContent(
    IXMLElement* pIXMLElement,
    LPWSTR szChildW
)
{    
    ASSERT(pIXMLElement);
    ASSERT(szChildW);    

    BSTR bstrRet = NULL;

    IXMLElementCollection* pIXMLElementCollection;

    if ((SUCCEEDED(pIXMLElement->get_children(&pIXMLElementCollection)))
         && pIXMLElementCollection)
    {
        ASSERT(pIXMLElementCollection);

        LONG nCount;

        HRESULT hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        for (int i = 0; (i < nCount) && !bstrRet; i++)
        {
            IXMLElement* pChildIXMLElement;

            if (SUCCEEDED(XML_GetElementByIndex(pIXMLElementCollection, i,
                                                &pChildIXMLElement)))
            {
                ASSERT(pChildIXMLElement);

                BSTR bstrTagName;

                if (SUCCEEDED(pChildIXMLElement->get_tagName(&bstrTagName)) && bstrTagName)
                {
                    ASSERT(bstrTagName);

                    if (StrEqlW(bstrTagName, szChildW))
                    {
                        bstrRet = XML_GetFirstChildContent(pChildIXMLElement);

                        //
                        // If the tag exists, but it is empty, return the empty
                        // string.
                        //

                        if (NULL == bstrRet)
                            bstrRet = SysAllocString(L"");
                    }

                    SysFreeString(bstrTagName);
                }


                pChildIXMLElement->Release();
            }
        }

        pIXMLElementCollection->Release();
    }
    
    return bstrRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetChildAttribute ***
//
//
// Description:
//     Returns a bstr value from the requested child of the given element.
//
// Parameters:
//     [In]  pIXMLElement      - A pointer to the element.
//     [In]  szChildW          - The name of the child element.
//     [In]  szAttributeW      - The name of the attribute.
//     [In]  szQualifierW      - The name of the attribute qualifier.
//     [In]  szQualifierValueW - The required value of the qaulifier.
//
// Return:
//     A bstr of the value contained in the child element if it is found.
//     NULL if the child element or its value isn't found.
//
// Comments:
//     This function will return atributes found in the child elements of the
//     given element.  For example:
//
//         If pIElement represents
//
//             <Channel>
//                 <Title VALUE="foo">
//                 <Author VALUE="bar">
//                 <Logo HRREF="url" TYPE="ICON">
//             </Channel>
//
//         Then this function will return
//
//             "foo" for "TITLE",  "VALUE", "", ""
//             "bar" for "AUTHOR", "VALUE", "", ""
//             "url" for "LOGO",   "HREF",  "TYPE", "ICON" 
//
//             NULL  when the names have any other values.
//
//     The caller is responsible for freeing the returned bstr.
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_GetChildAttribute(
    IXMLElement* pIXMLElement,
    LPWSTR szChildW,
    LPWSTR szAttributeW,
    LPWSTR szQualifierW,
    LPWSTR szQualifierValueW
)
{
    ASSERT(pIXMLElement);
    ASSERT(szChildW);
    ASSERT(szAttributeW);

    BSTR bstrRet = NULL;

    IXMLElementCollection* pIXMLElementCollection;

    if ((SUCCEEDED(pIXMLElement->get_children(&pIXMLElementCollection)))
        && pIXMLElementCollection)
    {
        ASSERT(pIXMLElementCollection);

        LONG nCount;

        //
        // REVIEW:  hr only used in debug builds.
        //

        HRESULT hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        for (int i = 0; (i < nCount) && !bstrRet; i++)
        {
            IXMLElement* pChildIXMLElement;

            if (SUCCEEDED(XML_GetElementByIndex(pIXMLElementCollection, i,
                                                &pChildIXMLElement)))
            {
                ASSERT(pChildIXMLElement);

                BSTR bstrTagName;

                if (SUCCEEDED(pChildIXMLElement->get_tagName(&bstrTagName)) && bstrTagName)
                {
                    ASSERT(bstrTagName);

                    if (StrEqlW(bstrTagName, szChildW))
                    {
                        bstrRet = XML_GetElementAttribute(pChildIXMLElement,
                                                          szAttributeW,
                                                          szQualifierW,
                                                          szQualifierValueW);
                    }

                    SysFreeString(bstrTagName);
                }


                pChildIXMLElement->Release();
            }
        }

        pIXMLElementCollection->Release();
    }
    
    return bstrRet;
}
    
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetElementAttribute ***
//
//
// Description:
//     Returns the bstr value of of the requested attribute if it is found.
//
// Parameters:
//     [In]  pIXMLElement      - The element that contains the attribute.
//     [In]  szAttributeW      - The name of the attribute.
//     [In]  szQualifierW      - The type qualifier for the atribute.
//     [In]  szQualifierValueW - The required value of the qaulifier.
//
// Return:
//     A bstr containig the attributes value if it was found.
//     NULL if the attribute wasn't found.
//
// Comments:
//     The function will return attributes found inside of tags.  For
//     example:
//
//         If pIXMLElement represents
//
//             <Channel HREF="foo" Cloneable="NO">
//             <USAGE VALUE="Channel">
//             <USAGE VALUE="Screen Saver">
//
//         Then this function will return
//
//             "foo"     for "HREF",      "",          ""
//             "NO"      for "Cloneable", "",          ""
//             "CHANNEL" for "VALUE",     "VALUE",     "CHANNEL"
//             NULL      for "VALUE",     "VALUE",     "NONE"
//             "foo"     for "HREF",      "CLONEABLE", "NO"
//
//     The caller is responsible for freeing the returned bstr.
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_GetElementAttribute(
    IXMLElement* pIXMLElement,
    LPWSTR szAttributeW,
    LPWSTR szQualifierW,
    LPWSTR szQualifierValueW
)
{
    ASSERT(pIXMLElement);
    ASSERT(szAttributeW);
    ASSERT((NULL == szQualifierW && NULL == szQualifierValueW) ||
           (szQualifierW && szQualifierValueW));

    BSTR bstrRet = NULL;

    VARIANT var;

    VariantInit(&var);

    if (NULL == szQualifierW)
    {
        if (SUCCEEDED(pIXMLElement->getAttribute(szAttributeW, &var)))
        {
            ASSERT(var.vt == VT_BSTR || NULL == var.bstrVal);

            bstrRet = var.bstrVal;
        }
    }
    else
    {
        if (SUCCEEDED(pIXMLElement->getAttribute(szQualifierW, &var)))
        {
            ASSERT(var.vt == VT_BSTR || NULL == var.bstrVal);

            if(var.bstrVal)
            {
                if (0 == StrCmpIW(var.bstrVal, szQualifierValueW))
                {
                    bstrRet = XML_GetElementAttribute(pIXMLElement, szAttributeW,
                                                      NULL, NULL);
                }
            }
            VariantClear(&var);
        }
    }

    return bstrRet;
}
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetScreenSaverURL ***
//
//
// Description:
//     Returns the screen saver URL of the first screen saver component in the channel.
//
// Parameters:
//     [In]  pXMLDocument  - An XML document
//     [Out] pbstrSSURL    - The pointer that receives the screen saver URL.
//
// Return:
//     S_OK if the screen saver URL was returned.
//     E_FAIL if the screen saver URL couldn't be returned.
//
// Comments:
//     This function gets the first screen saver element and then looks
//     for the first top-level ITEM with a usage of ScreenSaver.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetScreenSaverURL(
    IXMLDocument *  pXMLDocument,
    BSTR *          pbstrSSURL)
{
    HRESULT hr;

    ASSERT(pXMLDocument);
    ASSERT(pbstrSSURL);
    
    IXMLElement* pIXMLElement;
    LONG lDontCare;

    hr = XML_GetFirstChannelElement(pXMLDocument, &pIXMLElement, &lDontCare);
    if (SUCCEEDED(hr))
    {
        IXMLElement* pSSElement;

        ASSERT(pIXMLElement);

        hr = XML_GetScreenSaverElement(pIXMLElement, &pSSElement);

        if (SUCCEEDED(hr))
        {
            ASSERT(pSSElement);

            *pbstrSSURL = XML_GetAttribute(pSSElement, XML_HREF);

            hr = *pbstrSSURL ? S_OK : E_FAIL;
            
            pSSElement->Release();
        }
        pIXMLElement->Release();
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetScreenSaverElement ***
//
//
// Description:
//     Returns the IXMLElement of the first screen saver component in the channel.
//
// Parameters:
//     [In]  pXMLElemet    - An XML element
//     [Out] ppIXMLElement - The pointer that receives the screen saver element.
//
// Return:
//     S_OK if the first screen saver element was returned.
//     E_FAIL if the element couldn't be returned.
//
// Comments:
//     This function gets the first screen saver element and then looks
//     for the first top-level ITEM with a usage of ScreenSaver.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetScreenSaverElement(
    IXMLElement *   pXMLElement,
    IXMLElement **  ppScreenSaverElement)
{
    ASSERT(pXMLElement);
    ASSERT(ppScreenSaverElement);

    IXMLElementCollection * pIXMLElementCollection;
    HRESULT                 hr;

    hr = pXMLElement->get_children(&pIXMLElementCollection);
    if (SUCCEEDED(hr) && pIXMLElementCollection)
    {
        LONG nCount;

        hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        hr = E_FAIL;

        BOOL bScreenSaver = FALSE;
        for (int i = 0; (i < nCount) && !bScreenSaver; i++)
        {
            IXMLElement * pIXMLElement;

            HRESULT hr2 = XML_GetElementByIndex(pIXMLElementCollection,
                                                i,
                                                &pIXMLElement);

            if (SUCCEEDED(hr2))
            {
                ASSERT(pIXMLElement != NULL);

                if (bScreenSaver = XML_IsScreenSaver(pIXMLElement))
                {
                    pIXMLElement->AddRef();
                    *ppScreenSaverElement = pIXMLElement;

                    hr = S_OK;
                }

                pIXMLElement->Release();
            }

            hr = FAILED(hr2) ? hr2 : hr;
        }

        pIXMLElementCollection->Release();
    }        
    else
        hr = E_FAIL;

    ASSERT((SUCCEEDED(hr) && *ppScreenSaverElement) || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetSubscriptionInfo ***
//
//
// Description:
//     Fills a structure with the subscription info for the given element.
//
// Parameters:
//     [In]  pIXMLElement - An xml element.  The element doesn't have to be a
//                          subscription element.
//     [Out] psi          - The subscription info structure used by the
//                          subscription manager.
//
// Return:
//     S_OK if any information was obtained.
//
// Comments:
//     This function uses a webcheck API that fills a task trigger with
//     subscription information.
//
//     This function assumes that the psi->pTrigger points to a TASK_TRIGGER.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
XML_GetSubscriptionInfo(
    IXMLElement* pIXMLElement,
    SUBSCRIPTIONINFO* psi
)
{
    ASSERT(pIXMLElement);
    ASSERT(psi);
    ASSERT(psi->pTrigger);

    HRESULT hr = E_FAIL;

#ifndef UNIX
    HINSTANCE hinst = LoadLibrary(TEXT("webcheck.dll"));

    if (hinst)
    {
        typedef (*PFTRIGGERFUNCTION)(IXMLElement* pIXMLElement,
                                     TASK_TRIGGER* ptt);

        PFTRIGGERFUNCTION XMLSheduleElementToTaskTrigger;

        XMLSheduleElementToTaskTrigger = (PFTRIGGERFUNCTION)
                                         GetProcAddress(hinst,
                                             "XMLScheduleElementToTaskTrigger");

        if (XMLSheduleElementToTaskTrigger)
        {
            ((TASK_TRIGGER*)(psi->pTrigger))->cbTriggerSize = 
                                                           sizeof(TASK_TRIGGER);

            hr = XMLSheduleElementToTaskTrigger(pIXMLElement,
                                                (TASK_TRIGGER*)psi->pTrigger);

            if (FAILED(hr))
                psi->pTrigger = NULL;
        }

        FreeLibrary(hinst);
    }

    // See if there is a screen saver available.
    IXMLElement * pScreenSaverElement;
    if (SUCCEEDED(XML_GetScreenSaverElement(   pIXMLElement,
                                                    &pScreenSaverElement)))
    {
        psi->fUpdateFlags |= SUBSINFO_CHANNELFLAGS;
        psi->fChannelFlags |= CHANNEL_AGENT_PRECACHE_SCRNSAVER;
        pScreenSaverElement->Release();
    }

    BSTR bstrLogin = XML_GetAttribute(pIXMLElement, XML_LOGIN);

    if (bstrLogin)
    {
        psi->bNeedPassword = TRUE;
        psi->fUpdateFlags |= SUBSINFO_NEEDPASSWORD;     //this member is now valid
        SysFreeString(bstrLogin);
    }

#endif /* !UNIX */

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_GetBaseURL ***
//
//
// Description:
//     Returns the base url for the given collection.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to an XML element.
//
// Return:
//     A bstr containing the base URL if there is one.
//     NULL if ther isn't a base URL.
//
// Comments:
//     If the current element has a BASE attribute return this attributes value.
//     Else return the BASE attribute of its parent.
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_GetBaseURL(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BSTR bstrRet = XML_GetAttribute(pIXMLElement, XML_BASE);

    if (NULL == bstrRet)
    {
        IXMLElement* pParentIXMLElement;

        if (SUCCEEDED(pIXMLElement->get_parent(&pParentIXMLElement)) && pParentIXMLElement)
        {
            ASSERT(pParentIXMLElement);

            bstrRet = XML_GetBaseURL(pParentIXMLElement);

            pParentIXMLElement->Release();
        }
    }

    return bstrRet;
}
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_CombineURL ***
//
//
// Description:
//     Combine the given URL with the base URL.
//
// Parameters:
//     [In]  bstrBaseURL - The base URL.
//     [In]  bstrRelURL  - The relative URL.
//
// Return:
//     A combination of the base and relative URL.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BSTR
XML_CombineURL(
    BSTR bstrBaseURL,
    BSTR bstrRelURL
)
{
    ASSERT(bstrBaseURL);
    ASSERT(bstrRelURL);

    BSTR bstrRet = NULL;

    WCHAR wszCombinedURL[INTERNET_MAX_URL_LENGTH];
    DWORD cch = ARRAYSIZE(wszCombinedURL);

    if (InternetCombineUrlW(bstrBaseURL, bstrRelURL, wszCombinedURL, &cch, 0))
        bstrRet = SysAllocString(wszCombinedURL);

    return bstrRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsCdfDisplayable ***
//
//
// Description:
//     Determines if the given item should be displayed in the cdf view.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object should be displayed.
//     FALSE otherwise.
//
// Comments:
//     aCDFTypes contains the tag names of XML items that the cdf shell
//     shell extension displays.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsCdfDisplayable(
    IXMLElement* pIXMLElement
)
{
    #define     KEYWORDS  (sizeof(aCDFTypes) / sizeof(aCDFTypes[0]))

    static const LPWSTR aCDFTypes[] = { 
                                        WSTR_ITEM,
                                        WSTR_CHANNEL,
                                        WSTR_SOFTDIST
                                      };

    ASSERT(pIXMLElement);

    BOOL bRet = FALSE;

    BSTR pStr;

    HRESULT hr = pIXMLElement->get_tagName(&pStr);

    if (SUCCEEDED(hr) && pStr)
    {
        ASSERT(pStr);

        for(int i = 0; (i < KEYWORDS) && !bRet; i++)
            bRet = StrEqlW(pStr, aCDFTypes[i]);

        if (bRet)
            bRet = XML_IsUsageChannel(pIXMLElement);

        //
        // Special processing.
        //

        if (bRet && StrEqlW(pStr, WSTR_SOFTDIST))
            bRet = XML_IsSoftDistDisplayable(pIXMLElement);

        SysFreeString(pStr);
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsSoftDistDisplayable ***
//
//
// Description:
//     Determins if the given software distribution element should be displayed.
//
// Parameters:
//     [In]  pIXMLElement - Pointer to the software distribution xml element.
//
// Return:
//     TRUE if the element should be displayed.
//     FALSE if the element shouldn't be displayed.
//
// Comments:
//     This function asks the software disribution COM object if this software
//     distribution tag should be displayed on this users machine.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsSoftDistDisplayable(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    ISoftDistExt* pISoftDistExt;

    HRESULT hr = CoCreateInstance(CLSID_SoftDistExt, NULL, CLSCTX_INPROC_SERVER,
                                  IID_ISoftDistExt, (void**)&pISoftDistExt);

    if (SUCCEEDED(hr))
    {
        ASSERT(pISoftDistExt);

        hr = pISoftDistExt->ProcessSoftDist(NULL, pIXMLElement, 0);

        pISoftDistExt->Release();
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsUsageChannel ***
//
//
// Description:
//     Determines if this item should be displayed in channel view based on its
//     usage tag.
//
// Parameters:
//     [In]  pIXMLelement - A pointer to the element.
//
// Return:
//     TRUE if the item should be displayed in the channel view.
//     FALSE otherwise.
//
// Comments:
//     If an element doesn't have a USAGE tag then it gets displayed.  If an
//     element has any numberf of usage tags one of them must have a value of
//     CHANNEL or will not get displayed.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsUsageChannel(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet;

    //
    // First check if there are any USAGE elements.
    //

    BSTR bstrUsage = XML_GetAttribute(pIXMLElement, XML_USAGE);

    if (bstrUsage)
    {
        //
        // See if USAGE is CHANNEL.
        //

        if (StrEqlW(bstrUsage, WSTR_CHANNEL))
        {
            bRet = TRUE;
        }
        else
        {
            //
            // Check if there are any other USAGE tags with value CHANNEL.
            //

            BSTR bstrChannel = XML_GetAttribute(pIXMLElement,
                                                XML_USAGE_CHANNEL);

            if (bstrChannel)
            {
                SysFreeString(bstrChannel);
                bRet = TRUE;
            }
            else
            {
                bRet = FALSE;
            }
        }

        SysFreeString(bstrUsage);
    }
    else
    {
        bRet = TRUE;  // No USAGE tag defaults channel usage.
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsChannel ***
//
//
// Description:
//     Determines if the given XML item is a channel.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object is a channel.
//     FALSE otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsChannel(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet = FALSE;

    BSTR pStr;

    HRESULT hr = pIXMLElement->get_tagName(&pStr);

    if (SUCCEEDED(hr) && pStr)
    {
        ASSERT(pStr);

        bRet = StrEqlW(pStr, WSTR_CHANNEL);

        SysFreeString(pStr);
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsDesktopComponent ***
//
//
// Description:
//     Determines if the given XML item is a desktop component.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object is a desktop component.
//     FALSE otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsDesktopComponent(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet;

    BSTR bstr = XML_GetAttribute(pIXMLElement, XML_USAGE_DSKCMP);

    if (bstr)
    {
        SysFreeString(bstr);
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsScreenSaver ***
//
//
// Description:
//     Determines if the given XML item is a screen saver.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object is a screen saver
//     FALSE otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsScreenSaver(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet;

    BSTR bstrUsage = XML_GetAttribute(pIXMLElement, XML_USAGE);

    if (bstrUsage)
    {
        bRet =  (
                (StrCmpIW(bstrUsage, WSTR_SCRNSAVE) == 0)
                ||
                (StrCmpIW(bstrUsage, WSTR_SMARTSCRN) == 0)
                );

        SysFreeString(bstrUsage);
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsDesktopComponentUsage ***
//
//
// Description:
//     Determines if the given XML item is a desktop component usage element.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object is a desktop component usage element.
//     FALSE otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsDesktopComponentUsage(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet = FALSE;

    BSTR bstrName;

    if (SUCCEEDED(pIXMLElement->get_tagName(&bstrName)) && bstrName)
    {
        ASSERT(bstrName);

        if (StrEqlW(bstrName, WSTR_USAGE))
        {
            BSTR bstrValue = XML_GetElementAttribute(pIXMLElement, WSTR_VALUE, NULL,
                                                NULL);

            if (bstrValue)
            {
                bRet = (0 == StrCmpIW(bstrValue, WSTR_DSKCMP));

                SysFreeString(bstrValue);
            }
        }

        SysFreeString(bstrName);
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsFolder ***
//
//
// Description:
//     Determines if the given item is a folder.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the IXMLElement interface of an object.
//
// Return:
//     TRUE if the object contains other cdf displayable objects.
//     FALSE otherwise.
//
// Comments:
//     An item is a folder if at least one of its children is displayable as a
//     cdf item.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsFolder(
    IXMLElement* pIXMLElement
)
{
    ASSERT(pIXMLElement);

    BOOL bRet = FALSE;

    IXMLElementCollection* pIXMLElementCollection;

    HRESULT hr = pIXMLElement->get_children(&pIXMLElementCollection);

    if (SUCCEEDED(hr) && pIXMLElementCollection)
    {
        ASSERT(pIXMLElementCollection);

        LONG nCount;

        hr = pIXMLElementCollection->get_length(&nCount);

        ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

        for (int i = 0; (i < nCount) && !bRet; i++)
        {
            IXMLElement* pIXMLElementTemp;

            hr = XML_GetElementByIndex(pIXMLElementCollection, i, &pIXMLElementTemp);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIXMLElementTemp);

                if (XML_IsCdfDisplayable(pIXMLElementTemp))
                    bRet = TRUE;

                pIXMLElementTemp->Release();
            }
        }

        pIXMLElementCollection->Release();
    }

    return bRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_ContainsFolder ***
//
//
// Description:
//     Determines if there are any cdf folders in the given collection.
//
// Parameters:
//     [In]  pIXMLElementCollection - A pointer to the collection.
//
// Return:
//     TRUE if the collection contains a cf folder.
//     FALSE otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_ContainsFolder(
    IXMLElementCollection* pIXMLElementCollection
)
{
    ASSERT(pIXMLElementCollection);

    BOOL bContainsFolder = FALSE;

    LONG nCount;

    HRESULT hr = pIXMLElementCollection->get_length(&nCount);

    ASSERT(SUCCEEDED(hr) || (FAILED(hr) && 0 == nCount));

    for (int i = 0; (i < nCount) && !bContainsFolder; i++)
    {
        IXMLElement* pIXMLElement;

        hr = XML_GetElementByIndex(pIXMLElementCollection, i, &pIXMLElement);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            bContainsFolder = XML_IsFolder(pIXMLElement);

            pIXMLElement->Release();
        }
    }

    return bContainsFolder;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_ChildContainsFolder ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_ChildContainsFolder(
    IXMLElementCollection *pIXMLElementCollectionParent,
    ULONG nIndexChild
)
{
    BOOL bRet = FALSE;

    IXMLElement* pIXMLElement;

    HRESULT hr = XML_GetElementByIndex(pIXMLElementCollectionParent,
                                       nIndexChild, &pIXMLElement);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        IXMLElementCollection* pIXMLElementCollection;

        hr = pIXMLElement->get_children(&pIXMLElementCollection);

        if (SUCCEEDED(hr) && pIXMLElementCollection)
        {
            ASSERT(pIXMLElementCollection);

            bRet = XML_ContainsFolder(pIXMLElementCollection);

            pIXMLElementCollection->Release();
        }

        pIXMLElement->Release();
    }

    return bRet;
}

#ifdef DEBUG

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** XML_IsCdfidlMemberOf ***
//
//
// Description:
//     Checks if the cdf item id list is associated with a member of the given
//     element collection.
//
// Parameters:
//     [In]  pIXMLElementCollection - The element collection to check.
//     [In]  pcdfidl                - A pointer to cdf item id list
//
// Return:
//     TRUE if the given id list can be associated with an elemnt of the given 
//     collection.
//     FALSE otherwise.
//
// Comments:
//     This function checks if the last id in the list could have been
//     generated from its corresponding element in the element collection.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
XML_IsCdfidlMemberOf(
    IXMLElementCollection* pIXMLElementCollection,
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    BOOL bRet = FALSE;

    //
    // pIXMLElementCollection is NULL when a Folder hasn't been initialized.
    // It isn't always neccessary to parse the cdf to get pidl info from
    // the pidl.  pIXMLElement collection will be NULL in low memory situations
    // also.  Don't return FALSE for these cases.  Also check for special
    // pidls that aren't in element collections.
    //

    if (pIXMLElementCollection &&
        CDFIDL_GetIndexId(&pcdfidl->mkid) != INDEX_CHANNEL_LINK)
    {
        IXMLElement* pIXMLElement;

        HRESULT hr = XML_GetElementByIndex(pIXMLElementCollection,
                                           CDFIDL_GetIndexId(&pcdfidl->mkid),
                                           &pIXMLElement);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            PCDFITEMIDLIST pcdfidlElement;

            pcdfidlElement = CDFIDL_CreateFromXMLElement(pIXMLElement,
                                             CDFIDL_GetIndexId(&pcdfidl->mkid));

            if (pcdfidlElement)
            {
                ASSERT(CDFIDL_IsValid(pcdfidlElement));

                bRet = (0 == CDFIDL_CompareId(&pcdfidl->mkid,
                                              &pcdfidlElement->mkid));

                CDFIDL_Free(pcdfidlElement);
            }

            pIXMLElement->Release();
        }
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}

#endif //DEBUG

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//                                                           
// *** XML_IsStrEqualW ***
//
//
// Description:
//     Determines if two WCHAR strings are equal.
//
// Parameters:
//     [In]  p1 - The first string to compare.
//     [In]  p2 - The second string to compare.
//
// Return:
//     TRUE if the strings are equal.
//     FALSE otherwise.
//
// Comments:
//     lstrcmpW doesn't work on W95 so this function has its own strcmp logic.
//
////////////////////////////////////////////////////////////////////////////////
#if 0
inline
BOOL
XML_IsStrEqualW(
    LPWSTR p1,
    LPWSTR p2
)
{
    ASSERT(p1);
    ASSERT(p2);

    while ((*p1 == *p2) && *p1 && *p2)
    {
        p1++; p2++;
    }

    return (*p1 == *p2);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\resdll\makefile.inc ===
..\cdfvwlc.rc : ..\res\*.ico
..\cdfvwlc.rc : ..\res\strings.rcs
..\cdfvwlc.rc : ..\res\version.rcv
..\cdfvwlc.rc : ..\res\menus.rcm
..\cdfvwlc.rc : ..\res\cdfview.dlg
..\cdfvwlc.rc : ..\res\download.avi
..\cdfvwlc.rc : ..\res\*.gif
..\cdfvwlc.rc : ..\res\xmlerror.htm
..\cdfvwlc.rc : ..\res\hrerror.htm
..\cdfvwlc.rc : ..\res\cacheerr.htm
..\cdfvwlc.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\xmlutil.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// xmlutil.h 
//
//   XML item helper functions.
//
//   History:
//
//       4/1/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////


//
// Check for previous includes of this file.
//

#ifndef _XMLUTIL_H_

#define _XMLUTIL_H_

//
// Attribute enumeration.  Contains the attributes supported by
// the XML_GetAttribute function.
//

typedef enum _tagXML_ATTRIBUTE
{
    XML_TITLE           = 0,
    XML_TITLE_ATTR      = 1,
    XML_HREF            = 2,
    XML_ABSTRACT        = 3,
    XML_ABSTRACT_ATTR   = 4,
    XML_ICON            = 5,
    XML_LOGO            = 6,
    XML_LOGO_DEFAULT    = 7,
    XML_SELF            = 8,
    XML_SELF_OLD        = 9,
    XML_BASE            = 10,
    XML_USAGE           = 11,
    XML_USAGE_CHANNEL   = 12,
    XML_USAGE_DSKCMP    = 13,
    XML_WIDTH           = 14,
    XML_HEIGHT          = 15,
    XML_CANRESIZE       = 16,
    XML_CANRESIZEX      = 17,
    XML_CANRESIZEY      = 18,
    XML_PREFERREDLEFT   = 19,
    XML_PREFERREDTOP    = 20,
    XML_OPENAS          = 21,
    XML_SHOW            = 22,
    XML_SHOW_CHANNEL    = 23,
    XML_SHOW_DSKCMP     = 24,
    XML_A_HREF          = 25,
    XML_INFOURI         = 26,
    XML_LOGO_WIDE       = 27,
    XML_LOGIN           = 28,
    XML_USAGE_SOFTWAREUPDATE = 29,
    XML_SHOW_SOFTWAREUPDATE  = 30,
    XML_ITEMSTATE       = 31,
    XML_NULL            = 99
} XML_ATTRIBUTE;

//
// XML document types.
//

typedef enum _tagXMLDOCTYPE {
    DOC_CHANNEL,
    DOC_DESKTOPCOMPONENT,
    DOC_SOFTWAREUPDATE,
    DOC_UNKNOWN
} XMLDOCTYPE;



//
// Cdf string constants used in XML files.
//

#define WSTR_EMPTY          L""

// Elements
#define WSTR_A              L"A"
#define WSTR_ABSTRACT       L"ABSTRACT"
#define WSTR_RESIZE         L"CANRESIZE"
#define WSTR_RESIZEX        L"CANRESIZEX"
#define WSTR_RESIZEY        L"CANRESIZEY"
#define WSTR_CHANNEL        L"CHANNEL"
#define WSTR_DSKCMP         L"DESKTOPCOMPONENT"
#define WSTR_HEIGHT         L"HEIGHT"
#define WSTR_ITEM           L"ITEM"
#define WSTR_LOGIN          L"LOGIN"
#define WSTR_LOGO           L"LOGO"
#define WSTR_OPENAS         L"OPENAS"
#define WSTR_PREFLEFT       L"PREFERREDLEFT"
#define WSTR_PREFTOP        L"PREFERREDTOP"
#define WSTR_SCRNSAVE       L"SCREENSAVER"
#define WSTR_SELF           L"SELF"
#define WSTR_SHOW           L"SHOW"
#define WSTR_SMARTSCRN      L"SMARTSCREEN"
#define WSTR_SOFTDIST       L"SOFTPKG"
#define WSTR_TITLE          L"TITLE"
#define WSTR_USAGE          L"USAGE"
#define WSTR_WIDTH          L"WIDTH"
#define WSTR_SOFTWAREUPDATE L"SOFTWAREUPDATE"
#define WSTR_ITEMSTATE      L"ITEMSTATE"

// Attributes
#define WSTR_BASE           L"BASE"
#define WSTR_HREF           L"HREF"
#define WSTR_INFOURI        L"INFOURI"
#define WSTR_STYLE          L"STYLE"
#define WSTR_VALUE          L"VALUE"

// Attribute values.
#define WSTR_ICON           L"ICON"
#define WSTR_IMAGE          L"IMAGE"
#define WSTR_IMAGEW         L"IMAGE-WIDE"
#define WSTR_ZERO           L"0"
#define WSTR_YES            L"YES"
#define WSTR_HTML           L"HTML"
#define WSTR_NORMAL         L"NORMAL"
#define WSTR_SPLITSCREEN    L"SPLITSCREEN"
#define WSTR_FULLSCREEN     L"FULLSCREEN"


//
// Function protoypes.
//

HRESULT     XML_SynchronousParse(IXMLDocument* pIXMLDocument,
                                 LPTSTR szPath);

HRESULT     XML_DownloadLogo(IXMLDocument* pIXMLDocument);
HRESULT     XML_DownloadImages(IXMLDocument* pIXMLDocument);
HRESULT     XML_RecursiveImageDownload(IXMLElement* pIXMLElement);
HRESULT     XML_DownloadImage(LPCWSTR pwszURL);

XMLDOCTYPE  XML_GetDocType(IXMLDocument* pIXMLDocument);



HRESULT     XML_GetChildElementCollection(
                            IXMLElementCollection *pParentIXMLElementCollection,
                            LONG nIndex,
                            IXMLElementCollection** ppIXMLElementCollection);

HRESULT     XML_GetFirstChannelElement(IXMLDocument* pIXMLDocument,
                                       IXMLElement** ppIXMLElement,
                                       PLONG pnIndex);

HRESULT     XML_GetDesktopElementFromChannelElement(
                                        IXMLElement* pChannelIXMLElement,
                                        IXMLElement** ppIXMLElement,
                                        PLONG pnIndex);

HRESULT     XML_GetFirstDesktopComponentElement(IXMLDocument* pIXMLDocument,
                                                IXMLElement** ppIXMLElement,
                                                PLONG pnIndex);

HRESULT     XML_GetFirstDesktopComponentUsageElement(
                                                   IXMLDocument* pIXMLDocument,
                                                   IXMLElement** ppIXMLElement);

HRESULT     XML_GetDesktopComponentInfo(IXMLDocument* pIXMLDocument,
                                        COMPONENT* pInfo);


HRESULT     XML_GetElementByIndex(IXMLElementCollection* pIXMLElementCollection,
                       LONG nIndex,
                       IXMLElement** ppIXMLElement);

HRESULT     XML_GetElementByName(IXMLElementCollection* pIXMLElementCollection,
                       LPWSTR szNameW,
                       IXMLElement** ppIXMLElement);

BSTR        XML_GetAttribute(IXMLElement *pIXMLElement,
                             XML_ATTRIBUTE attribute);

BSTR        XML_GetChildAttribute(IXMLElement *pIXMLElement,
                                  LPWSTR szChildW,
                                  LPWSTR szAttributeW,
                                  LPWSTR szQualifierW,
                                  LPWSTR szQualifierValueW);

BSTR        XML_GetElementAttribute(IXMLElement *pIXMLElement,
                                    LPWSTR szAttributeW,
                                    LPWSTR szQualifierW,
                                    LPWSTR szQualifierValueW);

HRESULT     XML_GetSubscriptionInfo(IXMLElement* pIXMLElement,
                                    SUBSCRIPTIONINFO* psi);

HRESULT     XML_GetScreenSaverElement(IXMLElement* pIXMLElement,
                                      IXMLElement** ppScreenSaverElement);

BSTR        XML_GetBaseURL(IXMLElement* pIXMLElement);
BSTR        XML_CombineURL(BSTR bstrBaseURL, BSTR bstrRelURL);
BOOL        XML_IsCdfDisplayable(IXMLElement* pIXMLElement);
BOOL        XML_IsSoftDistDisplayable(IXMLElement* pIXMLEelement);
BOOL        XML_IsUsageChannel(IXMLElement* pIXMLElement);
BOOL        XML_IsScreenSaver(IXMLElement* pIXMLElement);
BOOL        XML_IsFolder(IXMLElement* pIXMLElement);
BOOL        XML_ContainsFolder(IXMLElementCollection* pIXMLElementCollection);

BOOL        XML_ChildContainsFolder(
                            IXMLElementCollection* pIXMLElementCollectionParent,
                            ULONG nIndexChild);

BOOL        XML_IsChannel(IXMLElement* pIXMLElement);
BOOL        XML_IsDesktopComponent(IXMLElement* pIXMLElement);
BOOL        XML_IsDesktopComponentUsage(IXMLElement* pIXMLElement);

BOOL        XML_IsCdfidlMemberOf(IXMLElementCollection* pIXMLElementCollection,
                                 PCDFITEMIDLIST pcdfidl);

BSTR        XML_GetGrandChildContent(IXMLElement* pIXMLElement,
                                 LPWSTR szChildW);


BOOL inline XML_IsStrEqualW(LPWSTR p1, LPWSTR p2);

HRESULT XML_MarkCacheEntrySticky(LPTSTR lpszURL);

HRESULT     XML_GetScreenSaverURL(IXMLDocument* pXMLDocument, BSTR* pbstrSSURL);

#endif // _XMLUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\utils.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// utils.cpp 
//
//   Misc routines.
//
//   History:
//
//       6/25/97  tnoonan   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "persist.h"
#include "cdfview.h"
#include "xmlutil.h"
#include "bindstcb.h"
#include "dll.h"
#include "resource.h"
#include "chanapi.h"

#include <mluisupp.h>

typedef struct _tagDialogData {
    LPCWSTR pszwURL;
    IXMLDocument* pIXMLDocument;
    int nProgress;
} DIALOGDATA;


HRESULT
GetURLFromIni(
    LPCTSTR pszPath, 
    BSTR* pbstrURL
)
{
    ASSERT(pszPath);
    ASSERT(pbstrURL);

    HRESULT hr = E_FAIL;

    LPTSTR szFile    = TSTR_INI_FILE;
    LPTSTR szSection = TSTR_INI_SECTION;
    LPTSTR szKey     = TSTR_INI_URL;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szPath[MAX_PATH];

    StrCpyN(szPath, pszPath, ARRAYSIZE(szPath) - ARRAYSIZE(TSTR_INI_FILE));
    StrCatBuff(szPath, szFile, ARRAYSIZE(szPath));

    if (GetPrivateProfileString(szSection, szKey, TEXT(""), szURL,
                                ARRAYSIZE(szURL), szPath))
    {
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
        if (SHTCharToUnicode(szURL, wszURL, ARRAYSIZE(wszURL)))
        {
            *pbstrURL = SysAllocString(wszURL);
            hr = S_OK;
        }       
    }

    return hr;

}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
GetNameAndURLAndSubscriptionInfo(
    LPCTSTR pszPath,
    BSTR* pbstrName,
    BSTR* pbstrURL,
    SUBSCRIPTIONINFO* psi
)
{
    ASSERT(pszPath);
    ASSERT(pbstrName);
    ASSERT(pbstrURL);

    HRESULT hr;

    *pbstrName = NULL;
    *pbstrURL  = NULL;

    CCdfView* pCCdfView = new CCdfView;

    if (pCCdfView)
    {
        WCHAR wszPath[MAX_PATH];

        if (SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath)))
        {
            hr = pCCdfView->Load(wszPath, 0);

            if (SUCCEEDED(hr))
            {
                IXMLDocument* pIXMLDocument;

                hr = pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

                if (SUCCEEDED(hr))
                {
                    ASSERT(pIXMLDocument);

                    IXMLElement* pIXMLElement;
                    LONG         nIndex;

                    hr = XML_GetFirstChannelElement(pIXMLDocument,
                                                    &pIXMLElement, &nIndex);

                    if (SUCCEEDED(hr))
                    {
                        ASSERT(pIXMLElement);

                        *pbstrName = XML_GetAttribute(pIXMLElement, XML_TITLE);

                        if (*pbstrName && 0 == **pbstrName)
                        {
                            SysFreeString(*pbstrName);
                            *pbstrName = NULL;
                        }

                        *pbstrURL  = XML_GetAttribute(pIXMLElement, XML_SELF);

                        if (*pbstrURL && 0 == **pbstrURL)
                        {
                            SysFreeString(*pbstrName);
                            *pbstrURL = NULL;
                        }

                        if (psi)
                            XML_GetSubscriptionInfo(pIXMLElement, psi);

                        pIXMLElement->Release();
                    }

                    pIXMLDocument->Release();
                }
            }
        }

        if (NULL == *pbstrName)
        {
            TCHAR szName[MAX_PATH];
            WCHAR wszName[MAX_PATH];

            StrCpyN(szName, pszPath, ARRAYSIZE(szName));
            PathStripPath(szName);
           
            if (SHTCharToUnicode(szName, wszName, ARRAYSIZE(wszName)))
                *pbstrName = SysAllocString(wszName);
        }

        if (NULL == *pbstrURL)
        {
            GetURLFromIni(pszPath, pbstrURL);
        }

        hr = (NULL != *pbstrName) && (NULL != **pbstrName) &&
             (NULL != *pbstrURL) && (NULL != **pbstrURL) ? S_OK : E_FAIL;
             
        if (FAILED(hr))
        {
            if (NULL != *pbstrName)
            {
                SysFreeString(*pbstrName);
                *pbstrName = NULL;
            }
            if (NULL != *pbstrURL)
            {
                SysFreeString(*pbstrURL);
                *pbstrURL = NULL;
            }
        }
        pCCdfView->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

int CDFMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...)
{
    TCHAR szCaption[80];
    TCHAR szTextFmt[256];
    LPTSTR pszText;
    int result;
    va_list va;
    
    va_start(va, uType);

    MLLoadString(idTextFmt, szTextFmt, ARRAYSIZE(szTextFmt));
    MLLoadString(idCaption, szCaption, ARRAYSIZE(szCaption));

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                      szTextFmt, 0, 0, (LPTSTR)&pszText, 0, &va))
    {
        result = MessageBox(hwnd, pszText, szCaption, uType);

        LocalFree((HLOCAL)pszText);
    }
    else
    {
        result = IDOK;
    }

    return result;
}

INT_PTR RefreshDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;
    DIALOGDATA* pdd = (DIALOGDATA*) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdd = (DIALOGDATA*)lParam;

        IMoniker* pIMoniker;

        if (SUCCEEDED(CreateURLMoniker(NULL, pdd->pszwURL, &pIMoniker)))
        {
            ASSERT(pIMoniker);

            IBindCtx* pIBindCtx;

            IBindStatusCallback* pIBindStatusCallback =
                          (IBindStatusCallback*) new CBindStatusCallback2(hDlg);

            if (pIBindStatusCallback)
            {
                if (SUCCEEDED(CreateBindCtx(0, &pIBindCtx)) )
                {
                    ASSERT(pIBindCtx);

                    if (SUCCEEDED(RegisterBindStatusCallback(pIBindCtx,
                                                           pIBindStatusCallback,
                                                           NULL, 0)))
                    {
                        IPersistMoniker* pIPersistMoniker;

                        if (SUCCEEDED(pdd->pIXMLDocument->QueryInterface(
                                                           IID_IPersistMoniker,
                                                    (void**)&pIPersistMoniker)))
                        {
                            ASSERT(pIPersistMoniker);

                            pIPersistMoniker->Load(FALSE, pIMoniker, pIBindCtx,
                                                   0);

                            pIPersistMoniker->Release();
                        }
                    }

                    pIBindCtx->Release();
                }

                pIBindStatusCallback->Release();
            }

            pIMoniker->Release();
        }

        Animate_Open(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), IDA_DOWNLOAD);
        Animate_Play(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), 0, -1, -1);

        //SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETRANGE32, 0, 100);
        pdd->nProgress = 0;

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case DOWNLOAD_PROGRESS:
            SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_DELTAPOS,
                        pdd->nProgress += 2, 0);
            break;

        case DOWNLOAD_COMPLETE:
            if (lParam)
            {
                SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETPOS,
                            100, 0);

                XML_DownloadImages(pdd->pIXMLDocument);
            }
            EndDialog(hDlg, lParam);
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, FALSE);
        break;

    case WM_DESTROY:
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}


BOOL DownloadCdfUI(HWND hwnd, LPCWSTR pszwURL, IXMLDocument* pIXMLDocument)
{
    BOOL fRet = FALSE;

    DIALOGDATA dd;

    dd.pszwURL = pszwURL;
    dd.pIXMLDocument = pIXMLDocument;

    if (hwnd)
    {
        DWORD dwCacheCount = g_dwCacheCount;

        INT_PTR nRes = DialogBoxParam(MLGetHinst(),
                                    (LPWSTR)MAKEINTRESOURCE(IDD_CHANNELREFRESH),
                                    hwnd,
                                    RefreshDlgProc,
                                    (LPARAM)&dd);

        if (-1 == nRes)
        {
            int err = GetLastError();
        }
        else if (TRUE == nRes)
        {
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];

            if (SHUnicodeToTChar(pszwURL, szURL, ARRAYSIZE(szURL)))
            {
                FILETIME ftLastMod;

                URLGetLastModTime(szURL, &ftLastMod);
                Cache_EnterWriteLock();

                Cache_RemoveItem(szURL);

                if (SUCCEEDED(Cache_AddItem(szURL, pIXMLDocument, PARSE_NET,
                                            ftLastMod, dwCacheCount)))
                    fRet = TRUE;

                Cache_LeaveWriteLock();
            }

            BSTR bstrSSUrl;

            if (SUCCEEDED(XML_GetScreenSaverURL(pIXMLDocument, &bstrSSUrl)))
            {
                Channel_WriteScreenSaverURL(pszwURL, bstrSSUrl);
                SysFreeString(bstrSSUrl);
            }

        }
    }

    return fRet;
}

//  Checks if global state is offline
//  Stolen from webcheck utils.cpp

BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, 
            dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
        
    if (InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    ZeroMemory(&ci, sizeof(ci));

    if (fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    }
    else 
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

//
// Can the given url be subscribed?
//

BOOL
CanSubscribe(
    LPCWSTR pwszURL
)
{
    ASSERT(pwszURL);

    BOOL fRet = FALSE;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if (SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL)))
    {
        TCHAR szCanonicalURL[INTERNET_MAX_URL_LENGTH];
        DWORD dwSize = ARRAYSIZE(szCanonicalURL);

        URL_COMPONENTS uc = {0};
        uc.dwStructSize = sizeof(URL_COMPONENTS);

        if (InternetCanonicalizeUrl(szURL, szCanonicalURL, &dwSize, ICU_DECODE)
            &&
            InternetCrackUrl(szCanonicalURL, 0, 0, &uc) 
            &&
            ((INTERNET_SCHEME_HTTP == uc.nScheme) ||
             (INTERNET_SCHEME_HTTPS == uc.nScheme)))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\view.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// view.cpp 
//
//   IShellView helper functions.  Cdf view uses the default IShellView and
//   relies on a callback to supply specific information.
//
//   History:
//
//       3/20/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "view.h"
#include "cdfidl.h"
#include "resource.h"

#include <mluisupp.h>

#include <shellp.h>     // SHCreateShellFolderViewEx


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CreateDefaultShellView ***
//
//
// Description:
//     Creates a shell implemented default IShellView object for the given
//     folder.
//
// Parameters:
//     [In]  pIShellFolder - The folder for which the default IShellView is
//                           created.
//     [In]  pidl          - The id list for the given folder.
//     [Out] ppIShellView  - A pointer to receive the IShellView interface.
//
// Return:
//     The result from the private shell function SHCreateShellFolderViewEx.
//
// Comments:
//     The default IShellView object communicates with its associated folder
//     via a callback function.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CreateDefaultShellView(
    IShellFolder *pIShellFolder,
    LPITEMIDLIST pidl,
    IShellView** ppIShellView
)
{
    ASSERT(pIShellFolder);
    ASSERT(ppIShellView);

    CSFV csfv;

    csfv.cbSize      = sizeof(CSFV);
    csfv.pshf        = pIShellFolder;
    csfv.psvOuter    = NULL;
    csfv.pidl        = pidl;
    csfv.lEvents     = 0; //SHCNE_DELETE | SHCNE_CREATE;
    csfv.pfnCallback = IShellViewCallback;
    csfv.fvm         = (FOLDERVIEWMODE)0; // FVM_ICON, FVM_DETAILS, etc.

    return SHCreateShellFolderViewEx(&csfv, ppIShellView);
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** IShellViewCallback ***
//
//
// Description:
//     The callback function used by the default ISHellView to request
//     inforamtion.
//
// Parameters:
//     [In]  pIShellViewOuter - Always NULL.
//     [In]  pIShellFolder    - The folder associated with this view.
//     [In]  hwnd             - The hwnd of the shell view.
//     [In]  msg              - The callback message.
//     [InOut] wParam         - Message specific parameter.
//     [InOut] lParam         - Message specific parameter.
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CALLBACK IShellViewCallback(
    IShellView* pIShellViewOuter,
    IShellFolder* pIShellFolder,
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT hr;

    switch (msg)
    {
    case DVM_GETDETAILSOF:
        hr = IShellView_GetDetails((UINT)wParam, (PDETAILSINFO)lParam);
        break;

    //
    // Background enumeration only works for default shell view.
    //

    //case SFVM_BACKGROUNDENUM:
    //    hr = S_OK;
    //    TraceMsg(TF_CDFENUM, "Enum Background thread callback tid:0x%x",
    //             GetCurrentThreadId());
    //    break;
    
    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** IShellView_GetDetails ***
//
//
// Description:
//     The IShellView callback DVM_GETDETAILSOF message handler.
//
// Parameters:
//     [In]  nColumn    - The column for wich information is requested.
//     [InOut] pDetails - For column headings the pidl param is NULL and the
//                        columns format, width, and title are returned.  For
//                        items the pidl member conatins the id list of the
//                        requested item and the string value of the requested
//                        item is returned.
//
// Return:
//     S_OK if nColumn is supported.
//     E_FAIL if nColumn is greater than the number of supported columns.
//
// Comments:
//     The default shell view calls this function with successively higher
//     column numbers until an E_FAIL is returned.
//
//     The first (0) column is the display name.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
IShellView_GetDetails(
    UINT nColumn,
    PDETAILSINFO pDetails
)
{
    //
    // Column information.
    //

    #define     COLUMNS  (sizeof(aColumnInfo) / sizeof(aColumnInfo[0]))

    static const struct _tagCOLUMNINFO
    {
        UINT   idsName;
        UINT   cchWidth;
        USHORT uFormat;
    }
    aColumnInfo[] = {
                      {IDS_COLUMN_NAME, 50, LVCFMT_LEFT}
                    };
    
    HRESULT hr;

    if (nColumn < COLUMNS)
    {
        if (NULL != pDetails->pidl) {

            //
            // Get item information from the pidl.
            //

            switch (aColumnInfo[nColumn].idsName)
            {
            case IDS_COLUMN_NAME:
                //pDetails->str.uType = STRRET_CSTR;
                CDFIDL_GetDisplayName((PCDFITEMIDLIST)pDetails->pidl,
                                      &pDetails->str);
                break;
            }

        }
        else
        {
            //
            // Get column heading information.
            //

            pDetails->fmt       = aColumnInfo[nColumn].uFormat;
            pDetails->cxChar    = aColumnInfo[nColumn].cchWidth;
            pDetails->str.uType = STRRET_CSTR;

            //
            // REVIEW:  Using MLLoadStringA.
            //
            
            MLLoadStringA(aColumnInfo[nColumn].idsName,
                          pDetails->str.cStr, sizeof(pDetails->str.cStr));
        }

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\test\chandir\chandir.cpp ===
//
// test code for chanmgr
//
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <ole2.h>
#include <chanmgr.h>

//
// Macros
//
#define ASSERT(x)   //if(!(x)) printf("ASSERT:line %d: %s", __line__, ##x);

int _cdecl main()
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        IChannelMgr* pIChannelMgr;

        hr = CoCreateInstance(CLSID_ChannelMgr, NULL,  CLSCTX_INPROC_SERVER, 
                              IID_IChannelMgr, (void**)&pIChannelMgr);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIChannelMgr);

            IEnumChannels* pIEnumChannels;
            
            hr = pIChannelMgr->EnumChannels(CHANENUM_ALL, NULL, &pIEnumChannels);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIEnumChannels);

                CHANNELENUMINFO ci;

                while (S_OK == pIEnumChannels->Next(1, &ci, NULL))
                {
                    printf("Channel      : %S\n"
                           "Url          : %S\n"
                           "Path         : %S\n"
                           "Subscription : %s\n\n",
                           ci.pszTitle, ci.pszURL, ci.pszPath,
                           ci.stSubscriptionState == SUBSTATE_NOTSUBSCRIBED ?
                               "Not Subscribed" :
                           (ci.stSubscriptionState == SUBSTATE_FULLSUBSCRIPTION ?
                               "Full Subscription" :
                               "Partial Subscription")
                           );

                    CoTaskMemFree(ci.pszTitle);
                    CoTaskMemFree(ci.pszURL);
                    CoTaskMemFree(ci.pszPath);
                }

                pIEnumChannels->Release();
            }
       
            pIChannelMgr->Release();
        }
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\ccinline.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ccinline.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCVIEW_CCINLINE_H
#define _INC_CSCVIEW_CCINLINE_H
///////////////////////////////////////////////////////////////////////////////
/*  File: ccinline.h

    Description: Inline functions for sending messages to windows controls.
        Provides functionality similar to the macros defined in windowsx.h
        for those messages that don't have macros in windowsx.h.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/16/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_COMMCTRL
#   include "commctrl.h"
#endif

inline bool
StatusBar_SetText(
    HWND hCtl, 
    int iPart, 
    UINT uType, 
    LPCTSTR psz
    )
{
    return boolify(SendMessage(hCtl, SB_SETTEXT, MAKEWPARAM(iPart, uType), (LPARAM)psz));
}

inline bool
StatusBar_SetParts(
    HWND hCtl,
    int cParts,
    int *prgWidths
    )
{
    return boolify(SendMessage(hCtl, SB_SETPARTS, (WPARAM)cParts, (LPARAM)prgWidths));
}

inline bool
StatusBar_GetRect(
    HWND hCtl,
    int iPart,
    RECT *prc
    )
{
    return boolify(SendMessage(hCtl, SB_GETRECT, (WPARAM)iPart, (LPARAM)prc));
}


inline void
ToolBar_AutoSize(
    HWND hCtl
    )
{
    SendMessage(hCtl, TB_AUTOSIZE, 0, 0);
}


inline bool
ToolBar_GetItemRect(
    HWND hCtl,
    int iItem,
    RECT *prcItem
    )
{
    return boolify(SendMessage(hCtl, TB_GETITEMRECT, iItem, (LPARAM)prcItem));
}

inline bool
ToolBar_DeleteButton(
    HWND hCtl,
    int iBtn
    )
{
    return boolify(SendMessage(hCtl, TB_DELETEBUTTON, (WPARAM)iBtn, 0));
}


inline int
ProgressBar_SetPos(
    HWND hCtl,
    int iPos
    )
{
    return (int)SendMessage(hCtl, PBM_SETPOS, (WPARAM)iPos, 0);
}

inline DWORD
ProgressBar_SetRange(
    HWND hCtl,
    short iMin,
    short iMax
    )
{
    return (DWORD)SendMessage(hCtl, PBM_SETRANGE, 0, MAKELPARAM(iMin, iMax));
}

inline int
ProgressBar_SetStep(
    HWND hCtl,
    int iStep
    )
{
    return (int)SendMessage(hCtl, PBM_SETSTEP, (WPARAM)iStep, 0);
}

inline void
ProgressBar_StepIt(
    HWND hCtl
    )
{
    SendMessage(hCtl, PBM_STEPIT, 0, 0);
}


inline int
ProgressBar_GetRange(
    HWND hCtl,
    bool fWhichLimit,
    PBRANGE *pRange
    )
{
    return (int)SendMessage(hCtl, PBM_GETRANGE, (WPARAM)fWhichLimit, (LPARAM)pRange);
}

inline void
TrackBar_SetPos(
    HWND hCtl,
    int iPos,
    bool bRedraw
    )
{
    SendMessage(hCtl, TBM_SETPOS, (WPARAM)bRedraw, (LPARAM)iPos);
}


inline int
TrackBar_GetPos(
    HWND hCtl
    )
{
    return (int)SendMessage(hCtl, TBM_GETPOS, 0, 0);
}

inline void
TrackBar_SetRange(
    HWND hCtl,
    int iMin,
    int iMax,
    bool bRedraw
    )
{
    SendMessage(hCtl, TBM_SETRANGEMIN, (WPARAM)FALSE, (LPARAM)iMin);
    SendMessage(hCtl, TBM_SETRANGEMAX, (WPARAM)bRedraw, (LPARAM)iMax);
}

inline void
TrackBar_SetTicFreq(
    HWND hCtl,
    int iFreq
    )
{
    SendMessage(hCtl, TBM_SETTICFREQ, (WPARAM)iFreq, 0);
}

inline void
TrackBar_SetPageSize(
    HWND hCtl,
    int iPageSize
    )
{
    SendMessage(hCtl, TBM_SETPAGESIZE, 0, (LPARAM)iPageSize);
}

#endif //_INC_CSCVIEW_CCINLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\admin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       admin.cpp
//
//  Authors;
//    Jeff Saathoff (jeffreys)
//
//  Notes;
//    Support for Administratively pinned folders
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "strings.h"

DWORD WINAPI _PinAdminFoldersThread(LPVOID);


//*************************************************************
//
//  ApplyAdminFolderPolicy
//
//  Purpose:    Pin the admin folder list
//
//  Parameters: none
//
//  Return:     none
//
//  Notes:      
//
//*************************************************************
void
ApplyAdminFolderPolicy(void)
{
    BOOL bNoNet = FALSE;
    CSCIsServerOffline(NULL, &bNoNet);
    if (!bNoNet)
    {
        SHCreateThread(_PinAdminFoldersThread, NULL, CTF_COINIT | CTF_FREELIBANDEXIT, NULL);
    }
}

//
// Does a particular path exist in the DPA of path strings?
//
BOOL
ExistsAPF(
    HDPA hdpa, 
    LPCTSTR pszPath
    )
{
    const int cItems = DPA_GetPtrCount(hdpa);
    for (int i = 0; i < cItems; i++)
    {
        LPCTSTR pszItem = (LPCTSTR)DPA_GetPtr(hdpa, i);
        if (pszItem && (0 == lstrcmpi(pszItem, pszPath)))
            return TRUE;
    }
    return FALSE;
}


BOOL
ReadAPFFromRegistry(HDPA hdpaFiles)
{
    const HKEY rghkeyRoots[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER };

    for (int i = 0; i < ARRAYSIZE(rghkeyRoots); i++)
    {
        HKEY hKey;

        // Read in the Administratively pinned folder list.
        if (ERROR_SUCCESS == RegOpenKeyEx(rghkeyRoots[i], c_szRegKeyAPF, 0, KEY_QUERY_VALUE, &hKey))
        {
            TCHAR szName[MAX_PATH];
            DWORD dwIndex = 0, dwSize = ARRAYSIZE(szName);

            while (ERROR_SUCCESS == _RegEnumValueExp(hKey, dwIndex, szName, &dwSize, NULL, NULL, NULL, NULL))
            {
                if (!ExistsAPF(hdpaFiles, szName))
                {
                    LPTSTR pszDup;
                    if (LocalAllocString(&pszDup, szName))
                    {
                        if (-1 == DPA_AppendPtr(hdpaFiles, pszDup))
                        {
                            LocalFreeString(&pszDup);
                        }
                    }
                }

                dwSize = ARRAYSIZE(szName);
                dwIndex++;
            }    
            RegCloseKey(hKey);
        }
    }

    return TRUE;
}


BOOL
BuildFRList(HDPA hdpaFiles)
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szName[MAX_PATH];
        DWORD cchName = ARRAYSIZE(szName);
        TCHAR szValue[MAX_PATH];
        DWORD cbValue = sizeof(szValue);
        DWORD dwIndex = 0;

        while (ERROR_SUCCESS == RegEnumValue(hKey,
                                             dwIndex,
                                             szName,
                                             &cchName,
                                             NULL,
                                             NULL,
                                             (LPBYTE)szValue,
                                             &cbValue))
        {
            LPTSTR pszUNC = NULL;

            GetRemotePath(szValue, &pszUNC);

            if (pszUNC)
            {
                if (-1 == DPA_AppendPtr(hdpaFiles, pszUNC))
                {
                    LocalFreeString(&pszUNC);
                }
            }

            cchName = ARRAYSIZE(szName);
            cbValue = sizeof(szValue);
            dwIndex++;
        }    
        RegCloseKey(hKey);
    }

    return TRUE;
}


BOOL
ReconcileAPF(HDPA hdpaPin, HDPA hdpaUnpin)
{
    HKEY hKey;
    int cItems;
    int i;

    //
    // First, try to convert everything to UNC
    //
    cItems = DPA_GetPtrCount(hdpaPin);
    for (i = 0; i < cItems; i++)
    {
        LPTSTR pszItem = (LPTSTR)DPA_GetPtr(hdpaPin, i);
        if (!PathIsUNC(pszItem))
        {
            LPTSTR pszUNC = NULL;

            GetRemotePath(pszItem, &pszUNC);
            if (pszUNC)
            {
                DPA_SetPtr(hdpaPin, i, pszUNC);
                LocalFree(pszItem);
            }
        }
    }

    // Read in the previous Administratively pinned folder list for this user.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyAPFResult, 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szName[MAX_PATH];
        DWORD dwIndex = 0, dwSize = ARRAYSIZE(szName);

        while (ERROR_SUCCESS == _RegEnumValueExp(hKey, dwIndex, szName, &dwSize, NULL, NULL, NULL, NULL))
        {
            if (!ExistsAPF(hdpaPin, szName))
            {
                LPTSTR pszDup = NULL;

                // This one is not in the new list, save it in the Unpin list
                if (LocalAllocString(&pszDup, szName))
                {
                    if (-1 == DPA_AppendPtr(hdpaUnpin, pszDup))
                    {
                        LocalFreeString(&pszDup);
                    }
                }
            }

            dwSize = ARRAYSIZE(szName);
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    // Save out the new admin pin list for this user
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                        c_szRegKeyAPFResult,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_SET_VALUE,
                                        NULL,
                                        &hKey,
                                        NULL))
    {
        // Add reg entries from the Pin list
        cItems = DPA_GetPtrCount(hdpaPin);
        for (i = 0; i < cItems; i++)
        {
            DWORD dwValue = 0;
            RegSetValueEx(hKey, (LPCTSTR)DPA_GetPtr(hdpaPin, i), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
        }

        // Remove reg entries from the Unpin list
        cItems = DPA_GetPtrCount(hdpaUnpin);
        for (i = 0; i < cItems; i++)
        {
            RegDeleteValue(hKey, (LPCTSTR)DPA_GetPtr(hdpaUnpin, i));
        }

        RegCloseKey(hKey);
    }

    return TRUE;
}


DWORD WINAPI
_AdminFillCallback(LPCTSTR             /*pszName*/,
                   DWORD               /*dwStatus*/,
                   DWORD               /*dwHintFlags*/,
                   DWORD               /*dwPinCount*/,
                   LPWIN32_FIND_DATA   /*pFind32*/,
                   DWORD               /*dwReason*/,
                   DWORD               /*dwParam1*/,
                   DWORD               /*dwParam2*/,
                   DWORD_PTR           /*dwContext*/)
{
    if (WAIT_OBJECT_0 == WaitForSingleObject(g_heventTerminate, 0))
        return CSCPROC_RETURN_ABORT;

    return CSCPROC_RETURN_CONTINUE;
}


void
_DoAdminPin(LPCTSTR pszItem, LPWIN32_FIND_DATA pFind32)
{
    DWORD dwHintFlags = 0;

    TraceEnter(TRACE_ADMINPIN, "_DoAdminPin");

    if (!pszItem || !*pszItem)
        TraceLeaveVoid();

    TraceAssert(PathIsUNC(pszItem));

    // This may fail, for example if the file is not in the cache
    CSCQueryFileStatus(pszItem, NULL, NULL, &dwHintFlags);

    // Is the admin flag already turned on?
    if (!(dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN))
    {
        //
        // Pin the item
        //
        if (CSCPinFile(pszItem,
                       dwHintFlags | FLAG_CSC_HINT_PIN_ADMIN,
                       NULL,
                       NULL,
                       &dwHintFlags))
        {
            ShellChangeNotify(pszItem, pFind32, FALSE);
        }
    }

    //
    // Make sure files are filled.
    //
    // Yes, this takes longer, and isn't necessary if you stay logged
    // on, since the CSC agent fills everything in the background.
    //
    // However, JDP's are using this with laptop pools, and for
    // people who logon just to get the latest stuff, then immediately
    // disconnect their laptop and hit the road.  They need to have
    // everything filled right away.
    //
    if (!pFind32 || !(pFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        CSCFillSparseFiles(pszItem, FALSE, _AdminFillCallback, 0);
    }

    Trace((TEXT("AdminPin %s"), pszItem));

    TraceLeaveVoid();
}


void
_PinLinkTarget(LPCTSTR pszLink)
{
    LPTSTR pszTarget = NULL;

    TraceEnter(TRACE_ADMINPIN, "_PinLinkTarget");
    TraceAssert(pszLink);

    // We only want to pin a link target if it's a file (not a directory).
    // GetLinkTarget does this check and only returns files.
    GetLinkTarget(pszLink, &pszTarget, NULL);

    if (pszTarget)
    {
        WIN32_FIND_DATA fd = {0};
        fd.dwFileAttributes = 0;
        StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), PathFindFileName(pszTarget));

        // Pin the target
        _DoAdminPin(pszTarget, &fd);

        LocalFree(pszTarget);
    }

    TraceLeaveVoid();
}

// export this from shell32.dll

BOOL PathIsShortcut(LPCTSTR pszItem, DWORD dwAttributes)
{
    BOOL bIsShortcut = FALSE;

    SHFILEINFO sfi;
    sfi.dwAttributes = SFGAO_LINK;

    if (SHGetFileInfo(pszItem, dwAttributes, &sfi, sizeof(sfi), SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED | SHGFI_USEFILEATTRIBUTES))
    {
        bIsShortcut = (sfi.dwAttributes & SFGAO_LINK);
    }
    return bIsShortcut;
}


DWORD WINAPI
_PinAdminFolderCallback(LPCTSTR             pszItem,
                        ENUM_REASON         eReason,
                        LPWIN32_FIND_DATA   pFind32,
                        LPARAM              /*lpContext*/)
{
    TraceEnter(TRACE_ADMINPIN, "_PinAdminFolderCallback");
    TraceAssert(pszItem);

    if (WAIT_OBJECT_0 == WaitForSingleObject(g_heventTerminate, 0))
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    if (!pszItem || !*pszItem)
        TraceLeaveValue(CSCPROC_RETURN_SKIP);

    if (eReason == ENUM_REASON_FILE || eReason == ENUM_REASON_FOLDER_BEGIN)
    {
        // If it's a link, pin the target
        if (PathIsShortcut(pszItem, pFind32 ? pFind32->dwFileAttributes : 0))
            _PinLinkTarget(pszItem);

        // Pin the item
        if (PathIsUNC(pszItem))
            _DoAdminPin(pszItem, pFind32);
    }

    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}


void
_UnpinLinkTarget(LPCTSTR pszLink)
{
    LPTSTR pszTarget = NULL;

    TraceEnter(TRACE_ADMINPIN, "_UnpinLinkTarget");
    TraceAssert(pszLink);

    // We only want to unpin a link target if it's a file (not a directory).
    // GetLinkTarget does this check and only returns files.
    GetLinkTarget(pszLink, &pszTarget, NULL);

    if (pszTarget)
    {
        DWORD dwStatus = 0;
        DWORD dwPinCount = 0;
        DWORD dwHintFlags = 0;

        if (CSCQueryFileStatus(pszTarget, &dwStatus, &dwPinCount, &dwHintFlags)
            && (dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN))
        {
            // Unpin the target
            CSCUnpinFile(pszTarget,
                         FLAG_CSC_HINT_PIN_ADMIN,
                         &dwStatus,
                         &dwPinCount,
                         &dwHintFlags);

            if (0 == dwPinCount && 0 == dwHintFlags
                && !(dwStatus & FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY))
            {
                WIN32_FIND_DATA fd = {0};
                fd.dwFileAttributes = 0;
                StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), PathFindFileName(pszTarget));

                CscDelete(pszTarget);
                ShellChangeNotify(pszTarget, &fd, FALSE);
            }
        }

        LocalFree(pszTarget);
    }

    TraceLeaveVoid();
}


DWORD WINAPI
_UnpinAdminFolderCallback(LPCTSTR             pszItem,
                          ENUM_REASON         eReason,
                          DWORD               dwStatus,
                          DWORD               dwHintFlags,
                          DWORD               dwPinCount,
                          LPWIN32_FIND_DATA   pFind32,
                          LPARAM              /*dwContext*/)
{
    BOOL bDeleteItem = FALSE;
    TraceEnter(TRACE_ADMINPIN, "_UnpinAdminFolderCallback");

    if (WAIT_OBJECT_0 == WaitForSingleObject(g_heventTerminate, 0))
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    if (!pszItem || !*pszItem)
        TraceLeaveValue(CSCPROC_RETURN_SKIP);

    TraceAssert(PathIsUNC(pszItem));

    if (eReason == ENUM_REASON_FILE)
    {
        if (PathIsShortcut(pszItem, pFind32 ? pFind32->dwFileAttributes : 0))
        {
            _UnpinLinkTarget(pszItem);
        }
    }

    if ((eReason == ENUM_REASON_FILE || eReason == ENUM_REASON_FOLDER_BEGIN)
        && (dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN))
    {
        // Unpin the item
        CSCUnpinFile(pszItem,
                     FLAG_CSC_HINT_PIN_ADMIN,
                     &dwStatus,
                     &dwPinCount,
                     &dwHintFlags);
                     
        //
        // If it's a file, delete it below on this pass
        //
        bDeleteItem = (ENUM_REASON_FILE == eReason);

        Trace((TEXT("AdminUnpin %s"), pszItem));
    }
    else if (ENUM_REASON_FOLDER_END == eReason)
    {
        //
        // Delete any unused folders in the post-order part of the traversal.
        //
        // Note that dwPinCount and dwHintFlags are always 0 in the
        // post-order part of the traversal, so fetch them here.
        //
        bDeleteItem = CSCQueryFileStatus(pszItem, &dwStatus, &dwPinCount, &dwHintFlags);
    }            

    //
    // Delete items that are no longer pinned and have no offline changes
    //
    if (bDeleteItem
        && 0 == dwPinCount && 0 == dwHintFlags
        && !(dwStatus & FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY))
    {
        CscDelete(pszItem);
        ShellChangeNotify(pszItem, pFind32, FALSE);
    }

    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}


//
// Determines if a path is a "special" file pinned by the folder
// redirection code.
//
BOOL
_IsSpecialRedirectedFile(
    LPCTSTR pszPath,
    HDPA hdpaFRList
    )
{
    TraceAssert(NULL != pszPath);

    if (hdpaFRList)
    {
        const int cchPath = lstrlen(pszPath);
        int i;

        for (i = 0; i < DPA_GetPtrCount(hdpaFRList); i++)
        {
            LPCTSTR pszThis = (LPCTSTR)DPA_GetPtr(hdpaFRList, i);
            int cchThis     = lstrlen(pszThis);

            if (cchPath >= cchThis)
            {
                //
                // Path being examined is the same length or longer than
                // current path from the table.  Possible match.
                //
                if (0 == StrCmpNI(pszPath, pszThis, cchThis))
                {
                    //
                    // Path being examined is either the same as,
                    // or a child of, the current path from the table.
                    //
                    if (TEXT('\0') == *(pszPath + cchThis))
                    {
                        //
                        // Path is same as this path from the table.
                        //
                        return TRUE;
                    }
                    else if (0 == lstrcmpi(pszPath + cchThis + 1, L"desktop.ini"))
                    {
                        //
                        // Path is for a desktop.ini file that exists in the
                        // root of one of our special folders.
                        //
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


DWORD WINAPI
_ResetPinCountsCallback(LPCTSTR             pszItem,
                        ENUM_REASON         eReason,
                        DWORD               dwStatus,
                        DWORD               dwHintFlags,
                        DWORD               dwPinCount,
                        LPWIN32_FIND_DATA   /*pFind32*/,
                        LPARAM              dwContext)
{
    TraceEnter(TRACE_ADMINPIN, "_ResetPinCountsCallback");

    if (WAIT_OBJECT_0 == WaitForSingleObject(g_heventTerminate, 0))
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    if (!pszItem || !*pszItem)
        TraceLeaveValue(CSCPROC_RETURN_SKIP);

    TraceAssert(PathIsUNC(pszItem));

    if (eReason == ENUM_REASON_FILE || eReason == ENUM_REASON_FOLDER_BEGIN)
    {
        DWORD dwCurrentPinCount = dwPinCount;
        DWORD dwDesiredPinCount = _IsSpecialRedirectedFile(pszItem, (HDPA)dwContext) ? 1 : 0;

        while (dwCurrentPinCount-- > dwDesiredPinCount)
        {
            CSCUnpinFile(pszItem,
                         FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                         &dwStatus,
                         &dwPinCount,
                         &dwHintFlags);
        }
    }

    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}


int CALLBACK _LocalFreeCallback(LPVOID p, LPVOID)
{
    // OK to pass NULL to LocalFree
    LocalFree(p);
    return 1;
}


DWORD WINAPI
_PinAdminFoldersThread(LPVOID)
{
    TraceEnter(TRACE_ADMINPIN, "_PinAdminFoldersThread");
    TraceAssert(IsCSCEnabled());

    HANDLE rghSyncObj[] = { g_heventTerminate,
                            g_hmutexAdminPin };

    UINT wmAdminPin = RegisterWindowMessage(c_szAPFMessage);

    //
    // Wait until we either own the "admin pin" mutex OR the
    // "terminate" event is set.
    //
    // If the wait fails for some reason, e.g. we failed to
    // allocate one of these handles, we will abort immediately.
    // Is that OK?
    //
    TraceMsg("Waiting for 'admin-pin' mutex or 'terminate' event...");
    DWORD dwWait = WaitForMultipleObjects(ARRAYSIZE(rghSyncObj),
                                          rghSyncObj,
                                          FALSE,
                                          INFINITE);
    if (1 == (dwWait - WAIT_OBJECT_0))
    {
        HKEY hkCSC = NULL;
        FILETIME ft = {0};

        RegCreateKeyEx(HKEY_CURRENT_USER,
                       c_szCSCKey,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       NULL,
                       &hkCSC,
                       NULL);

        if (hkCSC)
        {
            GetSystemTimeAsFileTime(&ft);
            RegSetValueEx(hkCSC, c_szAPFStart, 0, REG_BINARY, (LPBYTE)&ft, sizeof(ft));
            RegDeleteValue(hkCSC, c_szAPFEnd);
        }
        if (wmAdminPin)
            SendNotifyMessage(HWND_BROADCAST, wmAdminPin, 0, 0);

        TraceMsg("Thread now owns 'admin-pin' mutex.");
        //
        // We own the "admin pin" mutex.  OK to perform admin pin.
        //
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_IDLE);

        //
        // Get the Admin Folders list from the registry
        //
        HDPA hdpaFiles = DPA_Create(10);
        HDPA hdpaUnpin = DPA_Create(4);

        if (NULL != hdpaFiles && NULL != hdpaUnpin)
        {
            DWORD dwResult = CSCPROC_RETURN_CONTINUE;
            int cFiles;
            int i;

            //
            // NTRAID#NTBUG9-376185-2001/04/24-jeffreys
            // NTRAID#NTBUG9-379736-2001/04/24-jeffreys
            //
            // Unless directed by policy, pin all redirected special folders.
            //
            if (!CConfig::GetSingleton().NoAdminPinSpecialFolders())
            {
                BuildFRList(hdpaFiles);
            }
            ReadAPFFromRegistry(hdpaFiles);
            ReconcileAPF(hdpaFiles, hdpaUnpin);

            //
            // Iterate through the unpin list and unpin the items
            //
            //
            cFiles = DPA_GetPtrCount(hdpaUnpin);
            for (i = 0; i < cFiles; i++)
            {
                LPTSTR pszItem = (LPTSTR)DPA_GetPtr(hdpaUnpin, i);

                DWORD dwStatus = 0;
                DWORD dwPinCount = 0;
                DWORD dwHintFlags = 0;

                // If this fails, then it's not cached and there's nothing to do
                if (CSCPROC_RETURN_CONTINUE == dwResult &&
                    CSCQueryFileStatus(pszItem, &dwStatus, &dwPinCount, &dwHintFlags))
                {
                    // Unpin this item
                    dwResult = _UnpinAdminFolderCallback(pszItem, ENUM_REASON_FILE, dwStatus, dwHintFlags, dwPinCount, NULL, 0);

                    if (CSCPROC_RETURN_CONTINUE == dwResult
                        && PathIsUNC(pszItem))
                    {
                        // Unpin everything under this folder (if it's a folder)
                        dwResult = _CSCEnumDatabase(pszItem, TRUE, _UnpinAdminFolderCallback, 0);

                        // Delete this item if it's no longer used (won't cause any
                        // harm if it's not a folder).
                        _UnpinAdminFolderCallback(pszItem, ENUM_REASON_FOLDER_END, 0, 0, 0, NULL, 0);
                    }
                }

                if (CSCPROC_RETURN_ABORT == dwResult)
                {
                    // We failed to clean this one up completely, so remember it for next time
                    SHSetValue(HKEY_CURRENT_USER, c_szRegKeyAPFResult, pszItem, REG_DWORD, &dwResult, sizeof(dwResult));
                }
            }

            //
            // Iterate through the list and pin the items
            //
            cFiles = DPA_GetPtrCount(hdpaFiles);
            for (i = 0; i < cFiles && CSCPROC_RETURN_CONTINUE == dwResult; i++)
            {
                LPTSTR pszItem = (LPTSTR)DPA_GetPtr(hdpaFiles, i);

                // Pin this item
                dwResult = _PinAdminFolderCallback(pszItem, ENUM_REASON_FILE, NULL, 0);

                // Pin everything under this folder (if it's a folder)
                if (CSCPROC_RETURN_CONTINUE == dwResult
                    && PathIsUNC(pszItem))
                {
                    dwResult = _Win32EnumFolder(pszItem, TRUE, _PinAdminFolderCallback, 0);
                }
            }
        }

        if (NULL != hdpaFiles)
        {
            DPA_DestroyCallback(hdpaFiles, _LocalFreeCallback, 0);
        }
        if (NULL != hdpaUnpin)
        {
            DPA_DestroyCallback(hdpaUnpin, _LocalFreeCallback, 0);
        }

        //
        // Reduce pin counts on everything since we don't use them anymore.
        // This is a one time (per user) cleanup.
        //
        DWORD dwCleanupDone = 0;
        DWORD dwSize = sizeof(dwCleanupDone);
        if (hkCSC)
        {
            RegQueryValueEx(hkCSC, c_szPinCountsReset, 0, NULL, (LPBYTE)&dwCleanupDone, &dwSize);
        }
        if (0 == dwCleanupDone)
        {
            HDPA hdpaFRList = DPA_Create(4);
            if (hdpaFRList)
            {
                BuildFRList(hdpaFRList);
            }

            TraceMsg("Doing pin count cleanup.");
            if (CSCPROC_RETURN_ABORT != _CSCEnumDatabase(NULL, TRUE, _ResetPinCountsCallback, (LPARAM)hdpaFRList)
                && hkCSC)
            {
                dwCleanupDone = 1;
                RegSetValueEx(hkCSC, c_szPinCountsReset, 0, REG_DWORD, (LPBYTE)&dwCleanupDone, sizeof(dwCleanupDone));
            }

            if (hdpaFRList)
            {
                DPA_DestroyCallback(hdpaFRList, _LocalFreeCallback, 0);
            }
        }

        if (hkCSC)
        {
            GetSystemTimeAsFileTime(&ft);
            RegSetValueEx(hkCSC, c_szAPFEnd, 0, REG_BINARY, (LPBYTE)&ft, sizeof(ft));
            RegCloseKey(hkCSC);
        }
        if (wmAdminPin)
            SendNotifyMessage(HWND_BROADCAST, wmAdminPin, 1, 0);

        TraceMsg("Thread releasing 'admin-pin' mutex.");
        ReleaseMutex(g_hmutexAdminPin);            
    }            

    TraceMsg("_PinAdminFoldersThread exiting");
    TraceLeaveValue(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\common.inc ===
USE_MSVCRT=1

C_DEFINES = $(C_DEFINES) -DSTRICT -DUNICODE -D_UNICODE -DSTRSAFE_NO_CB_FUNCTIONS

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

!IF "$(ICEPICK)" == "1"
USE_PDB=1
LINKER_FLAGS=$(LINKER_FLAGS) /DEBUGTYPE:CV,FIXUP /DBGIMPLIB /DEBUG /OPT:REF
USER_C_FLAGS=$(USER_C_FLAGS) /Zi
!ENDIF

!IF "$(PROFILE)" == "1"
C_DEFINES=$(C_DEFINES) -DPROFILE
USER_C_FLAGS=$(USER_C_FLAGS) /Gh /Zi
!ENDIF

CONDITIONAL_INCLUDES=$(CONDITIONAL_INCLUDES) \
    macocidl.h  \
    winwlm.h    \
    rpcerr.h    \
    rpcmac.h    \
    macname1.h  \
    macpub.h    \
    macapi.h    \
    macname2.h  \
    new         \
    atlbase.h   \
    atlconv.cpp \
    ifs.h       \
    defs.h      \
    vmm.h       \

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES=$(INCLUDES); \
    ..\lib\$(O); \
    ..\.; \
    $(BASE_INC_PATH); \
    $(TERMSRV_INC_PATH); \
    $(DS_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\cscuiext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       update.h
//
//--------------------------------------------------------------------------
#ifndef __INCLUDE_CSCUIEXT_H
#define __INCLUDE_CSCUIEXT_H
//
// Semi-public header for CSCUI.DLL.
// CSCUI.DLL provides the user interface for client-side caching.
// The code interacts with the CSC agent, Sync Manager (mobsync),
// winlogon, the shell, and the system tray (systray.exe).  
//
// 
STDAPI_(HWND) CSCUIInitialize(HANDLE hToken, DWORD dwFlags);
STDAPI_(LRESULT) CSCUISetState(UINT uMsg, WPARAM wParam, LPARAM lParam);
typedef HWND (*PFNCSCUIINITIALIZE)(HANDLE hToken, DWORD dwFlags);
//
// Flags for CSCUIInitialize
//
#define CI_INITIALIZE     0x0001
#define CI_TERMINATE      0x0002
#define CI_CREATEWINDOW   0x0004
#define CI_DESTROYWINDOW  0x0008
//
// These values are returned by CSCUISetState().
//
#define LRESULT_CSCWORKOFFLINE          1011   
#define LRESULT_CSCFAIL                 1012
#define LRESULT_CSCRETRY                1016
//
// These values are passed to CSCUISetState() as the uMsg arg.
//
#define STWM_CSCNETUP                   (WM_USER + 209)
#define STWM_CSCQUERYNETDOWN            (WM_USER + 210)
#define STWM_CSCCLOSEDIALOGS            (WM_USER + 212)
#define STWM_CSCNETDOWN                 (WM_USER + 213)
#define STWM_CACHE_CORRUPTED            (WM_USER + 214)
//
// These values are passed to CSCUISetState() as the wParam arg.
//
#define CSCUI_NO_AUTODIAL                   0
#define CSCUI_AUTODIAL_FOR_UNCACHED_SHARE   1
#define CSCUI_AUTODIAL_FOR_CACHED_SHARE     2
//
// These messages are private for the CSCUI hidden notification 
// window in systray.exe.
//
#define CSCWM_DONESYNCING               (WM_USER + 300)
#define CSCWM_UPDATESTATUS              (WM_USER + 301)
#define CSCWM_RECONNECT                 (WM_USER + 302)
#define CSCWM_SYNCHRONIZE               (WM_USER + 303)
#define CSCWM_ISSERVERBACK              (WM_USER + 304)
#define CSCWM_VIEWFILES                 (WM_USER + 305)
#define CSCWM_SETTINGS                  (WM_USER + 306)
#define CSCWM_GETSHARESTATUS            (WM_USER + 307)

//
// These constants are obtained by sending a CSCWM_GETSHARESTATUS
// message to the CSCUI hidden window.  They correspond to the 
// OfflineFolderStatus enumeration constants defined in shldisp.h.  
// These must remain in sync for the shell folder webview to work properly.
//
#define CSC_SHARESTATUS_INACTIVE    -1   // Same as OFS_INACTIVE
#define CSC_SHARESTATUS_ONLINE       0   // Same as OFS_ONLINE
#define CSC_SHARESTATUS_OFFLINE      1   // Same as OFS_OFFLINE
#define CSC_SHARESTATUS_SERVERBACK   2   // Same as OFS_SERVERBACK
#define CSC_SHARESTATUS_DIRTYCACHE   3   // Same as OFS_DIRTYCACHE

//
// Class name and title for the CSCUI hidden notification window.
//
#define STR_CSCHIDDENWND_CLASSNAME TEXT("CSCHiddenWindow")
#define STR_CSCHIDDENWND_TITLE TEXT("CSC Notifications Window")

//
// Function for deleting folders & contents from the cache.
//
//   pszFolder -- UNC path of folder to remove
//   pfnCB -- optional, may be NULL. Return FALSE to abort, TRUE to continue.
//   lParam -- passed to pfnCB
//
typedef BOOL (CALLBACK *PFN_CSCUIRemoveFolderCallback)(LPCWSTR, LPARAM);
STDAPI CSCUIRemoveFolderFromCache(LPCWSTR pszFolder, DWORD dwReserved, PFN_CSCUIRemoveFolderCallback pfnCB, LPARAM lParam);

//
// One of these is returned in the *pdwTsMode
// argument to CSCUI_IsTerminalServerCompatibleWithCSC API.
//
// CSCTSF_ = "CSC Terminal Server Flag"
//
#define CSCTSF_UNKNOWN       0  // Can't obtain TS status.
#define CSCTSF_CSC_OK        1  // OK to use CSC.
#define CSCTSF_APP_SERVER    2  // TS is configured as an app server.
#define CSCTSF_MULTI_CNX     3  // Multiple connections are allowed.
#define CSCTSF_REMOTE_CNX    4  // There are currently remote connections active.
#define CSCTSF_FUS_ENABLED   5  // Fast User Switching is enabled.
#define CSCTSF_COUNT         6
//
// Returns:
//    S_OK    - Terminal Server is in a mode that is compatible with CSC.
//    S_FALSE - Not OK to use CSC.  Inspect *pdwTsMode for reason.
//    other   - Failure.  *pdwTsMode contains CSCTSF_UNKNOWN.
//
HRESULT CSCUIIsTerminalServerCompatibleWithCSC(DWORD *pdwTsMode);

#endif // __INCLUDE_CSCUIEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\test\chanmgr\chanmgr.cpp ===
//
// test code for chanmgr
//
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <ole2.h>
#include <chanmgr.h>

//
// Macros
//
#define ASSERT(x)   if(!(x)) printf("ASSERT:line %d: %s", __line__, ##x);
#define CHECK(x)    printf("%s %s\n", #x, (SUCCEEDED((x)) || (x) == S_FALSE) ? "SUCCEEDED" : "FAILED" );

int _cdecl main()
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    IChannelMgr *pChannelMgr = NULL;
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL,  CLSCTX_INPROC_SERVER, 
            IID_IChannelMgr, (void**)&pChannelMgr);

    if (SUCCEEDED(hr))
    {
        {
            //
            // Add the sports category
            //
            CHANNELCATEGORYINFO cci = {0};
            cci.cbSize = sizeof(cci);
            cci.pszURL   = L"http://www.jiggins.com";
            cci.pszTitle = L"Sports";
            cci.pszLogo  = L"\\\\ohserv\\users\\julianj\\sports.gif";
            cci.pszIcon  = L"\\\\ohserv\\users\\julianj\\sports.ico";

            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = L"http://www.espn.com";
            csi.pszTitle = L"Sports\\Espn";
            csi.pszLogo  = L"\\\\ohserv\\users\\julianj\\news.gif";
            csi.pszIcon  = L"\\\\ohserv\\users\\julianj\\news.ico";

            CHECK(pChannelMgr->DeleteChannelShortcut(csi.pszTitle));
            CHECK(pChannelMgr->DeleteCategory(cci.pszTitle));

            CHECK(pChannelMgr->AddCategory(&cci));
            CHECK(pChannelMgr->AddChannelShortcut(&csi));
        }

        {
            //
            // Add the News category
            //
            CHANNELCATEGORYINFO cci = {0};
            cci.cbSize = sizeof(cci);
            cci.pszURL   = L"http://www.jiggins.com";
            cci.pszTitle = L"Recent News";
            cci.pszLogo  = L"\\\\ohserv\\users\\julianj\\sports.gif";
            cci.pszIcon  = L"\\\\ohserv\\users\\julianj\\sports.ico";

            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = L"http://www.espn.com";
            csi.pszTitle = L"Recent News\\New York Times";
            csi.pszLogo  = L"\\\\ohserv\\users\\julianj\\news.gif";
            csi.pszIcon  = L"\\\\ohserv\\users\\julianj\\news.ico";


            CHANNELSHORTCUTINFO csi2 = {0};
            csi2.cbSize   = sizeof(csi2);
            csi2.pszURL   = L"http://www.espn.com";
            csi2.pszTitle = L"Recent News\\Seattle Times";
            csi2.pszLogo  = L"\\\\ohserv\\users\\julianj\\news.gif";
            csi2.pszIcon  = L"\\\\ohserv\\users\\julianj\\news.ico";

            CHECK(pChannelMgr->DeleteChannelShortcut(csi.pszTitle));
            CHECK(pChannelMgr->DeleteChannelShortcut(csi2.pszTitle));
            CHECK(pChannelMgr->DeleteCategory(cci.pszTitle));

            CHECK(pChannelMgr->AddCategory(&cci));
            CHECK(pChannelMgr->AddChannelShortcut(&csi));
            CHECK(pChannelMgr->AddChannelShortcut(&csi2));
        }

        {
            // Add the test category
            CHANNELCATEGORYINFO cci = {0};
            cci.cbSize = sizeof(cci);
            cci.pszURL   = L"http://www.jiggins.com";
            cci.pszTitle = L"Test Category -/:*?\"<>|";
            cci.pszLogo  = L"\\\\ohserv\\users\\julianj\\sports.gif";
            cci.pszIcon  = L"\\\\ohserv\\users\\julianj\\sports.ico";

            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = L"http://www.espn.com";
            csi.pszTitle = L"Test Category -/:*?\"<>|\\Test Shortcut 1 -/:*?\"<>|";
            csi.pszLogo  = L"\\\\ohserv\\users\\julianj\\news.gif";
            csi.pszIcon  = L"\\\\ohserv\\users\\julianj\\news.ico";

            CHECK(pChannelMgr->DeleteChannelShortcut(csi.pszTitle));
            CHECK(pChannelMgr->DeleteCategory(cci.pszTitle));

            CHECK(pChannelMgr->AddCategory(&cci));
            CHECK(pChannelMgr->AddChannelShortcut(&csi));
        }


        {
            // Add another test category
            CHANNELCATEGORYINFO cci = {0};
            cci.cbSize = sizeof(cci);
            cci.pszURL   = L"http://www.jiggins.com";
            cci.pszTitle = L"Test Category -/:*?\"<>|\\Tests";
            cci.pszLogo  = L"\\\\ohserv\\users\\julianj\\sports.gif";
            cci.pszIcon  = L"\\\\ohserv\\users\\julianj\\sports.ico";

            CHANNELSHORTCUTINFO csi = {0};
            csi.cbSize   = sizeof(csi);
            csi.pszURL   = L"http://www.espn.com";
            csi.pszTitle = L"Test Category -/:*?\"<>|\\Tests\\Test Shortcut 2 -/:*?\"<>|";
            csi.pszLogo  = L"\\\\ohserv\\users\\julianj\\news.gif";
            csi.pszIcon  = L"\\\\ohserv\\users\\julianj\\news.ico";

            CHECK(pChannelMgr->DeleteChannelShortcut(csi.pszTitle));
            CHECK(pChannelMgr->DeleteCategory(cci.pszTitle));

            CHECK(pChannelMgr->AddCategory(&cci));
            CHECK(pChannelMgr->AddChannelShortcut(&csi));
        }

        pChannelMgr->Release();
    }

    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\cscentry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscentry.cpp
//
//--------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "cscentry.h"
#include "strings.h"

// Default location in the registry:
// HKLM\Software\Microsoft\Windows\CurrentVersion\NetCache\<logname>
//      Entry Key Name
//          - <GUID value> 


//------------------------------------------------------
int CALLBACK CSCEntry_CompareGuid(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = -1;
    CSCEntry *pEntry1 = reinterpret_cast<CSCEntry*>(p1);
    CSCEntry *pEntry2 = reinterpret_cast<CSCEntry*>(p2);
    GUID guid1 = GUID_NULL;
    GUID guid2 = GUID_NULL;

    if (pEntry1)
        guid1 = pEntry1->Guid();
    else if (lParam)
        guid1 = *(const GUID*)lParam;

    if (pEntry2)
        guid2 = pEntry2->Guid();

    if (IsEqualGUID(guid1, guid2))
        nResult = 0;

    return nResult;
}

//------------------------------------------------------
int CALLBACK CSCEntry_CompareName(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    int nResult = 0;
    CSCEntry *pEntry1 = reinterpret_cast<CSCEntry*>(p1);
    CSCEntry *pEntry2 = reinterpret_cast<CSCEntry*>(p2);
    LPCTSTR pszName1 = NULL;
    LPCTSTR pszName2 = NULL;

    if (pEntry1)
        pszName1 = pEntry1->Name();
    else if (lParam)
        pszName1 = reinterpret_cast<LPCTSTR>(lParam);

    if (pEntry2)
        pszName2 = pEntry2->Name();

    if (pszName1 == NULL)
        nResult = -1;
    else if (pszName2 == NULL)
        nResult = 1;
    else
        nResult = lstrcmpi(pszName1, pszName2);

    return nResult;
}

///////////////////////////////////////////////////////////////////
// CSCEntryLog
//
// 

HRESULT CSCEntryLog::Initialize(HKEY hkRoot, LPCTSTR pszSubkey)
{
    HRESULT hr = E_FAIL;
    DWORD dwErr;

    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::Initialize");

    m_bCSInited = InitializeCriticalSectionAndSpinCount(&m_csDPA, 0);
    if (m_bCSInited)
    {
        DWORD dwDisp;
        dwErr = RegCreateKeyEx(hkRoot,
                               pszSubkey,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ENUMERATE_SUB_KEYS | KEY_CREATE_SUB_KEY,
                               NULL,
                               &m_hkRoot,
                               &dwDisp);
        if (ERROR_SUCCESS == dwErr)
        {
            m_hdpa = DPA_Create(8);
            if (m_hdpa)
            {
                hr = ReadRegKeys();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    TraceLeaveResult(hr);
}

//------------------------------------------------------
int CALLBACK FreeCSCEntry(LPVOID p, LPVOID)
{
    CSCEntry *pcsce = reinterpret_cast<CSCEntry*>(p);
    delete pcsce;
    return 1;
}

CSCEntryLog::~CSCEntryLog()
{
    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::~CSCEntryLog");

    if (m_bCSInited)
    {
        DeleteCriticalSection(&m_csDPA);
    }
    DPA_DestroyCallback(m_hdpa, FreeCSCEntry, 0);

    if (m_hkRoot)
        RegCloseKey(m_hkRoot);

    TraceLeave();
}

//------------------------------------------------------
CSCEntry* CSCEntryLog::Get(REFGUID rguid)
{
    CSCEntry *pcscEntry = NULL;
    int iEntry = -1;

    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::Get");

    EnterCriticalSection(&m_csDPA);

    iEntry = DPA_Search(m_hdpa,
                        NULL,
                        0,
                        CSCEntry_CompareGuid,
                        (LPARAM)&rguid,
                        0);

    if (iEntry != -1)
        pcscEntry = (CSCEntry*)DPA_FastGetPtr(m_hdpa, iEntry);

    LeaveCriticalSection(&m_csDPA);

    TraceLeaveValue(pcscEntry);
}

//------------------------------------------------------
CSCEntry* CSCEntryLog::Get(LPCTSTR pszName)
{
    CSCEntry *pcscEntry = NULL;
    int iEntry = -1;

    if (!pszName || !*pszName)
        return NULL;

    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::Get");

    EnterCriticalSection(&m_csDPA);

    iEntry = DPA_Search(m_hdpa,
                        NULL,
                        0,
                        CSCEntry_CompareName,
                        (LPARAM)pszName,
                        DPAS_SORTED);

    if (iEntry != -1)
        pcscEntry = (CSCEntry*)DPA_FastGetPtr(m_hdpa, iEntry);

    LeaveCriticalSection(&m_csDPA);

    TraceLeaveValue(pcscEntry);
}

//------------------------------------------------------
CSCEntry* CSCEntryLog::Add(LPCTSTR pszName)
{
    CSCEntry *pcscEntry;

    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::Add");
    TraceAssert(pszName);

    // Look for an existing entry
    pcscEntry = Get(pszName);

    if (!pcscEntry)
    {
        LPTSTR pszTemp = NULL;

        // Make a copy of the name string so OpenKeyInternal can
        // munge it if necessary.
        if (LocalAllocString(&pszTemp, pszName))
        {
            pcscEntry = CreateFromKey(pszTemp);
            if (pcscEntry)
            {
                EnterCriticalSection(&m_csDPA);
                DPA_AppendPtr(m_hdpa, pcscEntry);
                DPA_Sort(m_hdpa, CSCEntry_CompareName, 0);
                LeaveCriticalSection(&m_csDPA);
            }
            LocalFreeString(&pszTemp);
        }
    }

    TraceLeaveValue(pcscEntry);
}

//------------------------------------------------------
HKEY CSCEntryLog::OpenKey(LPCTSTR pszSubkey, REGSAM samDesired)
{
    HKEY hkEntry = NULL;
    LPTSTR pszTemp = NULL;

    if (!pszSubkey || !*pszSubkey)
        return NULL;

    // Make a copy of the name string so OpenKeyInternal can
    // munge it if necessary.
    if (LocalAllocString(&pszTemp, pszSubkey))
    {
        hkEntry = OpenKeyInternal(pszTemp, samDesired);
        LocalFreeString(&pszTemp);
    }

    return hkEntry;
}

//------------------------------------------------------
HKEY CSCEntryLog::OpenKeyInternal(LPTSTR pszSubkey, REGSAM samDesired)
{
    HKEY hkEntry = NULL;
    LPTSTR pszSlash;
    DWORD dwDisp;

    if (!m_hkRoot)
        return NULL;

    // Registry keys can't have backslashes in their names.
    // Replace backslashes with forward slashes.
    pszSlash = pszSubkey;
    while (pszSlash = StrChr(pszSlash, TEXT('\\')))
        *pszSlash++ = TEXT('/');

    RegCreateKeyEx(m_hkRoot,
                   pszSubkey,
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   samDesired,
                   NULL,
                   &hkEntry,
                   &dwDisp);

    // Restore backslashes
    pszSlash = pszSubkey;
    while (pszSlash = StrChr(pszSlash, TEXT('/')))
        *pszSlash++ = TEXT('\\');

    return hkEntry;
}

//------------------------------------------------------
CSCEntry* CSCEntryLog::CreateFromKey(LPTSTR pszSubkey)
{
    CSCEntry *pEntry = NULL;
    HKEY hkEntry;

    hkEntry = OpenKeyInternal(pszSubkey, KEY_QUERY_VALUE | KEY_SET_VALUE);

    if (hkEntry)
    {
        HRESULT hr = S_OK;
        GUID guid = GUID_NULL;
        DWORD dwSize = sizeof(guid);
        DWORD dwType;

        if (ERROR_SUCCESS != RegQueryValueEx(hkEntry,
                                             c_szEntryID,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&guid,
                                             &dwSize)
            || dwType != REG_BINARY || dwSize != sizeof(guid))
        {
            // Doesn't exist, create a new GUID
            hr = CoCreateGuid(&guid);
            if (SUCCEEDED(hr))
            {
                DWORD dwErr = RegSetValueEx(hkEntry,
                                            c_szEntryID,
                                            0,
                                            REG_BINARY,
                                            (LPBYTE)&guid,
                                            sizeof(guid));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }

        if (SUCCEEDED(hr))
        {
            pEntry = new CSCEntry(guid);
            if (pEntry && !pEntry->Initialize(pszSubkey))
            {
                delete pEntry;
                pEntry = NULL;
                // Leave the registry entry for next time
            }
        }

        RegCloseKey(hkEntry);
    }

    return pEntry;
}

//------------------------------------------------------
HRESULT CSCEntryLog::ReadRegKeys()
{
    HRESULT hRes = S_OK;
    DWORD dwIndex = 0;
    TCHAR szKeyname[MAX_PATH];
    DWORD dwcbSize;

    TraceEnter(TRACE_CSCENTRY, "CSCEntryLog::ReadRegKeys");

    if (!m_hkRoot || !m_hdpa)
        TraceLeaveResult(E_UNEXPECTED);

    EnterCriticalSection(&m_csDPA);

    // Read all existing records from the Registry
    for (dwIndex=0; ; dwIndex++)
    {
        dwcbSize = ARRAYSIZE(szKeyname);
        if (ERROR_SUCCESS != RegEnumKeyEx(m_hkRoot,
                                          dwIndex,
                                          szKeyname,
                                          &dwcbSize,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL))
        {
            break;
        }

        CSCEntry *pcsce = CreateFromKey(szKeyname);
        if (pcsce)
            DPA_AppendPtr(m_hdpa, pcsce);
    }
    DPA_Sort(m_hdpa, CSCEntry_CompareName, 0);

    LeaveCriticalSection(&m_csDPA);

    TraceLeaveResult(hRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\config.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       config.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shlwapi.h>
#include "config.h"
#include "util.h"
#include "strings.h"


LPCTSTR CConfig::s_rgpszSubkeys[] = { REGSTR_KEY_OFFLINEFILES,
                                      REGSTR_KEY_OFFLINEFILESPOLICY };

LPCTSTR CConfig::s_rgpszValues[]  = { REGSTR_VAL_DEFCACHESIZE,
                                      REGSTR_VAL_CSCENABLED,
                                      REGSTR_VAL_GOOFFLINEACTION,
                                      REGSTR_VAL_NOCONFIGCACHE,
                                      REGSTR_VAL_NOCACHEVIEWER,
                                      REGSTR_VAL_NOMAKEAVAILABLEOFFLINE,
                                      REGSTR_VAL_SYNCATLOGOFF,
                                      REGSTR_VAL_SYNCATLOGON,
                                      REGSTR_VAL_SYNCATSUSPEND,
                                      REGSTR_VAL_NOREMINDERS,
                                      REGSTR_VAL_REMINDERFREQMINUTES,
                                      REGSTR_VAL_INITIALBALLOONTIMEOUTSECONDS,
                                      REGSTR_VAL_REMINDERBALLOONTIMEOUTSECONDS,
                                      REGSTR_VAL_EVENTLOGGINGLEVEL,
                                      REGSTR_VAL_PURGEATLOGOFF,
                                      REGSTR_VAL_PURGEONLYAUTOCACHEATLOGOFF,
                                      REGSTR_VAL_FIRSTPINWIZARDSHOWN,
                                      REGSTR_VAL_SLOWLINKSPEED,
                                      REGSTR_VAL_ALWAYSPINSUBFOLDERS,
                                      REGSTR_VAL_ENCRYPTCACHE,
                                      REGSTR_VAL_NOFRADMINPIN
                                      };

//
// Returns the single instance of the CConfig class.
// Note that by making the singleton instance a function static 
// object it is not created until the first call to GetSingleton.
//
CConfig& CConfig::GetSingleton(
    void
    )
{
    static CConfig TheConfig;
    return TheConfig;
}



//
// This is the workhorse of the CSCUI policy code for scalar values.  
// The caller passes in a value (iVAL_XXXXXX) identifier from the eValues 
// enumeration to identify the policy/preference value of interest.  
// Known keys in the registry are scanned until a value is found.  
// The scanning order enforces the precedence of policy vs. default vs.
// preference and machine vs. user.
//
DWORD CConfig::GetValue(
    eValues iValue,
    bool *pbSetByPolicy
    ) const
{
    //
    // This table identifies each DWORD policy/preference item used by CSCUI.  
    // The entries MUST be ordered the same as the eValues enumeration.
    // Each entry describes the possible sources for data and a default value
    // to be used if no registry entries are present or if there's a problem reading
    // the registry.
    //
    static const struct Item
    {
        DWORD fSrc;      // Mask indicating the reg locations to read.
        DWORD dwDefault; // Hard-coded default.

    } rgItems[] =  {

//  Value ID                               eSRC_PREF_CU | eSRC_PREF_LM | eSRC_POL_CU | eSRC_POL_LM   Default value
// --------------------------------------  ------------   ------------   -----------   ----------- -------------------
/* iVAL_DEFCACHESIZE                  */ {                                             eSRC_POL_LM, 1000             },
/* iVAL_CSCENABLED                    */ {                                             eSRC_POL_LM, 1                },  
/* iVAL_GOOFFLINEACTION               */ { eSRC_PREF_CU |                eSRC_POL_CU | eSRC_POL_LM, eGoOfflineSilent },
/* iVAL_NOCONFIGCACHE                 */ {                               eSRC_POL_CU | eSRC_POL_LM, 0                },
/* iVAL_NOCACHEVIEWER                 */ {                               eSRC_POL_CU | eSRC_POL_LM, 0                },
/* iVAL_NOMAKEAVAILABLEOFFLINE        */ {                               eSRC_POL_CU | eSRC_POL_LM, 0                },
/* iVAL_SYNCATLOGOFF                  */ { eSRC_PREF_CU |                eSRC_POL_CU | eSRC_POL_LM, eSyncFull        },
/* iVAL_SYNCATLOGON                   */ { eSRC_PREF_CU |                eSRC_POL_CU | eSRC_POL_LM, eSyncNone        },
/* iVAL_SYNCATSUSPEND                 */ {                               eSRC_POL_CU | eSRC_POL_LM, eSyncNone        },
/* iVAL_NOREMINDERS                   */ { eSRC_PREF_CU |                eSRC_POL_CU | eSRC_POL_LM, 0                },
/* iVAL_REMINDERFREQMINUTES           */ { eSRC_PREF_CU |                eSRC_POL_CU | eSRC_POL_LM, 60               },
/* iVAL_INITIALBALLOONTIMEOUTSECONDS  */ {                               eSRC_POL_CU | eSRC_POL_LM, 30               },
/* iVAL_REMINDERBALLOONTIMEOUTSECONDS */ {                               eSRC_POL_CU | eSRC_POL_LM, 15               },
/* iVAL_EVENTLOGGINGLEVEL             */ { eSRC_PREF_CU | eSRC_PREF_LM | eSRC_POL_CU | eSRC_POL_LM, 0                },
/* iVAL_PURGEATLOGOFF                 */ {                                             eSRC_POL_LM, 0                },
/* iVAL_PURGEONLYAUTOCACHEATLOGOFF    */ {                                             eSRC_POL_LM, 0                },
/* iVAL_FIRSTPINWIZARDSHOWN           */ { eSRC_PREF_CU                                           , 0                },
/* iVAL_SLOWLINKSPEED                 */ { eSRC_PREF_CU | eSRC_PREF_LM | eSRC_POL_CU | eSRC_POL_LM, 640              },
/* iVAL_ALWAYSPINSUBFOLDERS           */ {                                             eSRC_POL_LM, 0                },
/* iVAL_ENCRYPTCACHE                  */ {                eSRC_PREF_LM |               eSRC_POL_LM, 0                },
/* iVAL_NOFRADMINPIN                  */ {                               eSRC_POL_CU | eSRC_POL_LM, 0                }
                                         };

    //
    // This table maps registry keys and subkey names to our 
    // source mask values.  The array is ordered with the highest
    // precedence sources first.  A policy level mask is also
    // associated with each entry so that we honor the "big switch"
    // for enabling/disabling CSCUI policies.
    // 
    static const struct Source
    {
        eSources    fSrc;         // Source for reg data.
        HKEY        hkeyRoot;     // Root key in registry (hkcu, hklm).
        eSubkeys    iSubkey;      // Index into s_rgpszSubkeys[]

    } rgSrcs[] = { { eSRC_POL_LM,  HKEY_LOCAL_MACHINE, iSUBKEY_POL  },
                   { eSRC_POL_CU,  HKEY_CURRENT_USER,  iSUBKEY_POL  },
                   { eSRC_PREF_CU, HKEY_CURRENT_USER,  iSUBKEY_PREF },
                   { eSRC_PREF_LM, HKEY_LOCAL_MACHINE, iSUBKEY_PREF }
                 };


    const Item& item  = rgItems[iValue];
    DWORD dwResult    = item.dwDefault;    // Set default return value.
    bool bSetByPolicy = false;

    //
    // Iterate over all of the sources until we find one that is specified
    // for this item.  For each iteration, if we're able to read the value, 
    // that's the one we return.  If not we drop down to the next source
    // in the precedence order (rgSrcs[]) and try to read it's value.  If 
    // we've tried all of the sources without a successful read we return the 
    // hard-coded default.
    //
    for (int i = 0; i < ARRAYSIZE(rgSrcs); i++)
    {
        const Source& src = rgSrcs[i];

        //
        // Is this source valid for this item?
        //
        if (0 != (src.fSrc & item.fSrc))
        {
            //
            // This source is valid for this item.  Read it.
            //
            DWORD cbResult = sizeof(dwResult);
            DWORD dwType;
    
            if (ERROR_SUCCESS == SHGetValue(src.hkeyRoot,
                                            s_rgpszSubkeys[src.iSubkey],
                                            s_rgpszValues[iValue],
                                            &dwType,
                                            &dwResult,
                                            &cbResult))
            {
                //
                // We read a value from the registry so we're done.
                //
                bSetByPolicy = (0 != (eSRC_POL & src.fSrc));
                break;
            }
        }
    }
    if (NULL != pbSetByPolicy)
        *pbSetByPolicy = bSetByPolicy;

    return dwResult;
}


//
// Save a custom GoOfflineAction list to the registry.
// See comments for LoadCustomGoOfflineActions for formatting details.
//
HRESULT 
CConfig::SaveCustomGoOfflineActions(
    HKEY hkey,
    HDPA hdpaGOA
    )
{
    if (NULL == hdpaGOA)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = NOERROR;
    TCHAR szServer[MAX_PATH];
    TCHAR szAction[20];
    const int cGOA = DPA_GetPtrCount(hdpaGOA);
    for (int i = 0; i < cGOA; i++)
    {
        //
        // Write each sharename-action pair to the registry.
        // The action value must be converted to ASCII to be
        // compatible with the values generated by poledit.
        //
        CustomGOA *pGOA = (CustomGOA *)DPA_GetPtr(hdpaGOA, i);
        if (NULL != pGOA)
        {
            wnsprintf(szAction, ARRAYSIZE(szAction), TEXT("%d"), DWORD(pGOA->GetAction()));
            pGOA->GetServerName(szServer, ARRAYSIZE(szServer));
            DWORD dwResult = RegSetValueEx(hkey,
                                           szServer,
                                           0,
                                           REG_SZ,
                                           (CONST BYTE *)szAction,
                                           (lstrlen(szAction)+1) * sizeof(szAction[0]));
                                           
            hr = HRESULT_FROM_WIN32(dwResult);                                           
            if (FAILED(hr))
            {
                Trace((TEXT("Error 0x%08X saving GoOfflineAction for \"%s\" to registry."), 
                         hr, szServer));
                break;
            }
        }
    }
    return hr;
}



bool
CConfig::CustomGOAExists(
    HDPA hdpaGOA,
    const CustomGOA& goa
    )
{
    if (NULL != hdpaGOA)
    {
        const int cEntries = DPA_GetPtrCount(hdpaGOA);
        for (int i = 0; i < cEntries; i++)
        {
            CustomGOA *pGOA = (CustomGOA *)DPA_GetPtr(hdpaGOA, i);
            if (NULL != pGOA)
            {
                if (0 == goa.CompareByServer(*pGOA))
                    return true;
            }
        }
    }
    return false;
}
        

//
// Builds an array of Go-offline actions.
// Each entry is a server-action pair.
//
void
CConfig::GetCustomGoOfflineActions(
    HDPA hdpa,
    bool *pbSetByPolicy         // optional.  Can be NULL.
    )
{
    TraceAssert(NULL != hdpa);

    static const struct Source
    {
        eSources    fSrc;         // Source for reg data.
        HKEY        hkeyRoot;     // Root key in registry (hkcu, hklm).
        eSubkeys    iSubkey;      // Index into s_rgpszSubkeys[]

    } rgSrcs[] = { { eSRC_POL_LM,   HKEY_LOCAL_MACHINE, iSUBKEY_POL  },
                   { eSRC_POL_CU,   HKEY_CURRENT_USER,  iSUBKEY_POL  },
                   { eSRC_PREF_CU,  HKEY_CURRENT_USER,  iSUBKEY_PREF }
                 };

    ClearCustomGoOfflineActions(hdpa);

    bool bSetByPolicyAny = false;
    bool bSetByPolicy    = false;

    //
    // Iterate over all of the possible sources.
    //
    for (int i = 0; i < ARRAYSIZE(rgSrcs); i++)
    {
        const Source& src = rgSrcs[i];
        HKEY hkey;
        DWORD dwResult = RegOpenKeyEx(src.hkeyRoot,
                                      s_rgpszSubkeys[src.iSubkey],
                                      0,
                                      KEY_READ,
                                      &hkey);
        if (ERROR_SUCCESS == dwResult)
        {
            HKEY hkeyGOA;
            dwResult = RegOpenKeyEx(hkey,
                                    REGSTR_SUBKEY_CUSTOMGOOFFLINEACTIONS,
                                    0,
                                    KEY_READ,
                                    &hkeyGOA);
                                    
            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szName[MAX_PATH];
                TCHAR szValue[20];
                DWORD dwIndex = 0;
                do
                {
                    DWORD dwType;
                    DWORD cbValue = sizeof(szValue);
                    DWORD cchName = ARRAYSIZE(szName);
                    
                    dwResult = RegEnumValue(hkeyGOA,
                                            dwIndex,
                                            szName,
                                            &cchName,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szValue,
                                            &cbValue);
                                            
                    if (ERROR_SUCCESS == dwResult)                                            
                    {                                                          
                        dwIndex++;
                        if (REG_SZ == dwType)
                        {
                            //
                            // Convert from "0","1","2" to 0,1,2
                            //
                            DWORD dwValue = szValue[0] - TEXT('0');
                            if (IsValidGoOfflineAction(dwValue))
                            {
                                //
                                // Only add if value is of proper type and value.
                                // Protects against someone manually adding garbage
                                // to the registry.
                                //
                                // Server names can also be entered into the registry
                                // using poledit (and winnt.adm).  This entry mechanism
                                // can't validate format so we need to ensure the entry
                                // doesn't have leading '\' or space characters.
                                //
                                LPCTSTR pszServer = szName;
                                while(*pszServer && (TEXT('\\') == *pszServer || TEXT(' ') == *pszServer))
                                    pszServer++;

                                bSetByPolicy    = (0 != (src.fSrc & eSRC_POL));
                                bSetByPolicyAny = bSetByPolicyAny || bSetByPolicy;
                                CustomGOA *pGOA = new CustomGOA(pszServer,
                                                               (CConfig::OfflineAction)dwValue,
                                                                bSetByPolicy);
                                if (NULL != pGOA)
                                {
                                    if (CustomGOAExists(hdpa, *pGOA) || -1 == DPA_AppendPtr(hdpa, pGOA))
                                    {
                                        delete pGOA;
                                    }
                                }
                            }
                            else
                            {
                                Trace((TEXT("GoOfflineAction value %d invalid for \"%s\""),
                                          dwValue, szName));
                            }
                        }
                        else
                        {
                            Trace((TEXT("GoOfflineAction for \"%s\" has invalid reg type %d"),
                                      szName, dwType));
                        }
                    }
                }
                while(ERROR_SUCCESS == dwResult);
                RegCloseKey(hkeyGOA);
            }
            RegCloseKey(hkey);
        }
    }
    if (NULL != pbSetByPolicy)
        *pbSetByPolicy = bSetByPolicyAny;
}   


//
// Delete all CustomGOA blocks attached to a DPA.
// When complete, the DPA is empty.
//
void 
CConfig::ClearCustomGoOfflineActions(  // [static]
    HDPA hdpaGOA
    )
{
    if (NULL != hdpaGOA)
    {
        const int cEntries = DPA_GetPtrCount(hdpaGOA);
        for (int i = cEntries - 1; 0 <= i; i--)
        {
            CustomGOA *pGOA = (CustomGOA *)DPA_GetPtr(hdpaGOA, i);
            delete pGOA;
            DPA_DeletePtr(hdpaGOA, i);
        }
    }
}



//
// Retrieve the go-offline action for a specific server.  If the server
// has a "customized" action defined by either system policy or user
// setting, that action is used.  Otherwise, the "default" action is
// used.
//
int
CConfig::GoOfflineAction(
    LPCTSTR pszServer
    ) const
{
    int iAction = GoOfflineAction(); // Get default action.

    if (NULL == pszServer)
        return iAction;

    TraceAssert(NULL != pszServer);

    //
    // Skip passed any leading backslashes for comparison.
    // The values we store in the registry don't have a leading "\\".
    //
    while(*pszServer && TEXT('\\') == *pszServer)
        pszServer++;

    HRESULT hr;
    CConfig::OfflineActionInfo info;
    CConfig::OfflineActionIter iter = CreateOfflineActionIter();
    while(S_OK == (hr = iter.Next(&info)))
    {
        if (0 == lstrcmpi(pszServer, info.szServer))
        {
            iAction = info.iAction;  // Return custom action.
            break;
        }
    }
    //
    // Guard against bogus reg data.
    //
    if (eNumOfflineActions <= iAction || 0 > iAction)
        iAction = eGoOfflineSilent;

    return iAction;
}



//-----------------------------------------------------------------------------
// CConfig::CustomGOA
// "GOA" is "Go Offline Action"
//-----------------------------------------------------------------------------
bool 
CConfig::CustomGOA::operator < (
    const CustomGOA& rhs
    ) const
{
    int diff = CompareByServer(rhs);
    if (0 == diff)
        diff = m_action - rhs.m_action;

    return diff < 0;
}


//
// Compare two CustomGoOfflineAction objects by their
// server names.  Comparison is case-insensitive.
// Returns:  <0 = *this < rhs
//            0 = *this == rhs
//           >0 = *this > rhs
//
int 
CConfig::CustomGOA::CompareByServer(
    const CustomGOA& rhs
    ) const
{
    return lstrcmpi(GetServerName(), rhs.GetServerName());
}


//-----------------------------------------------------------------------------
// CConfig::OfflineActionIter
//-----------------------------------------------------------------------------
CConfig::OfflineActionIter::OfflineActionIter(
    const CConfig *pConfig
    ) : m_pConfig(const_cast<CConfig *>(pConfig)),
        m_iAction(-1),
        m_hdpaGOA(DPA_Create(4)) 
{ 
}


CConfig::OfflineActionIter::~OfflineActionIter(
    void
    )
{
    if (NULL != m_hdpaGOA)
    {
        CConfig::ClearCustomGoOfflineActions(m_hdpaGOA);
        DPA_Destroy(m_hdpaGOA);
    }
}



HRESULT
CConfig::OfflineActionIter::Next(
    OfflineActionInfo *pInfo
    )
{
    if (NULL == m_hdpaGOA)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_FALSE;

    if (-1 == m_iAction)
    {
        m_pConfig->GetCustomGoOfflineActions(m_hdpaGOA);
        m_iAction = 0;
    }
    if (m_iAction < DPA_GetPtrCount(m_hdpaGOA))
    {
        CustomGOA *pGOA = (CustomGOA *)DPA_GetPtr(m_hdpaGOA, m_iAction);
        if (NULL != pGOA)
        {
            hr = StringCchCopy(pInfo->szServer, ARRAYSIZE(pInfo->szServer), pGOA->GetServerName());
            pInfo->iAction = (DWORD)pGOA->GetAction();
            m_iAction++;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\config.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       config.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCVIEW_CONFIG_H
#define _INC_CSCVIEW_CONFIG_H

#ifndef _INC_CSCVIEW_UTILS_H
#   include "util.h"
#endif


class CConfig
{
    public:
        ~CConfig(void) { }

        enum SyncAction 
        {
            eSyncNone = -1,      // No sync.
            eSyncPartial,        // Sync only transient files at logoff.
            eSyncFull,           // Sync all files at logoff.
            eNumSyncActions
        };

        enum OfflineAction 
        { 
            //
            // These MUST match the order of the IDS_GOOFFLINE_ACTION_XXXXX
            // string resource IDs.
            //
            eGoOfflineSilent = 0, // Silently transition share to offline mode.
            eGoOfflineFail,       // Fail the share (NT4 behavior).
            eNumOfflineActions
        };

        //
        // Represents one custom go-offline action.
        //
        struct OfflineActionInfo
        {
            TCHAR szServer[MAX_PATH];   // Name of the associated server.
            int iAction;                // Action code.  One of enum OfflineAction.
        };

        //
        // Represents one entry in the customized server list.
        // "GOA" is "GoOfflineAction".
        //
        class CustomGOA
        {
            public:
                CustomGOA(void)
                    : m_action(eGoOfflineSilent),
                      m_bSetByPolicy(false) { m_szServer[0] = TEXT('\0'); }

                CustomGOA(LPCTSTR pszServer, OfflineAction action, bool bSetByPolicy)
                    : m_action(action),
                      m_bSetByPolicy(bSetByPolicy) { StringCchCopy(m_szServer, ARRAYSIZE(m_szServer), pszServer); }

                bool operator == (const CustomGOA& rhs) const
                    { return (m_action == rhs.m_action &&
                              0 == CompareByServer(rhs)); }

                bool operator != (const CustomGOA& rhs) const
                    { return !(*this == rhs); } 

                bool operator < (const CustomGOA& rhs) const;

                int CompareByServer(const CustomGOA& rhs) const;

                void SetServerName(LPCTSTR pszServer)
                    { StringCchCopy(m_szServer, ARRAYSIZE(m_szServer), pszServer); }

                void SetAction(OfflineAction action)
                    { m_action = action; }

                void GetServerName(LPTSTR pszServer, UINT cchServer) const
                    { StringCchCopy(pszServer, cchServer, m_szServer); }

                const LPCTSTR GetServerName(void) const
                    { return m_szServer; }

                OfflineAction GetAction(void) const
                    { return m_action; }

                bool SetByPolicy(void) const
                    { return m_bSetByPolicy; }

            private:
                TCHAR         m_szServer[MAX_PATH]; // The name of the server.
                OfflineAction m_action;             // The action code.
                bool          m_bSetByPolicy;       // Was action set by policy?
        };

        //
        // Iterator for enumerating custom go-offline actions.
        //
        class OfflineActionIter
        {
            public:
                OfflineActionIter(const CConfig *pConfig = NULL);

                ~OfflineActionIter(void);

                HRESULT Next(OfflineActionInfo *pInfo);

                void Reset(void)
                    { m_iAction = 0; }

            private:
                CConfig *m_pConfig;
                HDPA     m_hdpaGOA;
                int      m_iAction;
        };


        static CConfig& GetSingleton(void);

        bool CscEnabled(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_CSCENABLED, pbSetByPolicy)); }

        DWORD DefaultCacheSize(bool *pbSetByPolicy = NULL) const
            { return GetValue(iVAL_DEFCACHESIZE, pbSetByPolicy); }

        int EventLoggingLevel(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_EVENTLOGGINGLEVEL, pbSetByPolicy)); }

        bool FirstPinWizardShown(void) const
            { return boolify(GetValue(iVAL_FIRSTPINWIZARDSHOWN)); }

        void GetCustomGoOfflineActions(HDPA hdpaGOA, bool *pbSetByPolicy = NULL);

        int GoOfflineAction(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_GOOFFLINEACTION, pbSetByPolicy)); }

        int GoOfflineAction(LPCTSTR pszServer) const;

        int InitialBalloonTimeoutSeconds(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_INITIALBALLOONTIMEOUTSECONDS, pbSetByPolicy)); }

        bool NoCacheViewer(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_NOCACHEVIEWER, pbSetByPolicy)); }

        bool NoConfigCache(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_NOCONFIGCACHE, pbSetByPolicy)); }

        bool NoMakeAvailableOffline(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_NOMAKEAVAILABLEOFFLINE, pbSetByPolicy)); }

        bool NoReminders(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_NOREMINDERS, pbSetByPolicy)); }

        bool PurgeAtLogoff(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_PURGEATLOGOFF, pbSetByPolicy)); }

        bool PurgeOnlyAutoCachedFilesAtLogoff(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_PURGEONLYAUTOCACHEATLOGOFF, pbSetByPolicy)); }

        bool AlwaysPinSubFolders(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_ALWAYSPINSUBFOLDERS, pbSetByPolicy)); }

        bool NoAdminPinSpecialFolders(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_NOFRADMINPIN, pbSetByPolicy)); }

        bool EncryptCache(bool *pbSetByPolicy = NULL) const
            { return boolify(GetValue(iVAL_ENCRYPTCACHE, pbSetByPolicy)); }

        int ReminderBalloonTimeoutSeconds(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_REMINDERBALLOONTIMEOUTSECONDS, pbSetByPolicy)); }

        int ReminderFreqMinutes(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_REMINDERFREQMINUTES, pbSetByPolicy)); }

        int SyncAtLogoff(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_SYNCATLOGOFF, pbSetByPolicy)); }

        int SyncAtLogon(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_SYNCATLOGON, pbSetByPolicy)); }

        int SyncAtSuspend(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_SYNCATSUSPEND, pbSetByPolicy)); }

        int SlowLinkSpeed(bool *pbSetByPolicy = NULL) const
            { return int(GetValue(iVAL_SLOWLINKSPEED, pbSetByPolicy)); }

        OfflineActionIter CreateOfflineActionIter(void) const
            { return OfflineActionIter(this); }

        static HRESULT SaveCustomGoOfflineActions(HKEY hkey, HDPA hdpaGOA);

        static void ClearCustomGoOfflineActions(HDPA hdpaGOA);

    private:
        //
        // Indexes into s_rgpszSubkeys[].
        //
        enum eSubkeys 
        { 
            iSUBKEY_PREF,
            iSUBKEY_POL,
            MAX_SUBKEYS 
        };
        //
        // Indexes into s_rgpszValues[].
        //
        enum eValues 
        { 
            iVAL_DEFCACHESIZE,
            iVAL_CSCENABLED,
            iVAL_GOOFFLINEACTION,
            iVAL_NOCONFIGCACHE,
            iVAL_NOCACHEVIEWER,
            iVAL_NOMAKEAVAILABLEOFFLINE,
            iVAL_SYNCATLOGOFF,
            iVAL_SYNCATLOGON,
            iVAL_SYNCATSUSPEND,
            iVAL_NOREMINDERS,
            iVAL_REMINDERFREQMINUTES,
            iVAL_INITIALBALLOONTIMEOUTSECONDS,
            iVAL_REMINDERBALLOONTIMEOUTSECONDS,
            iVAL_EVENTLOGGINGLEVEL,
            iVAL_PURGEATLOGOFF,
            iVAL_PURGEONLYAUTOCACHEATLOGOFF,
            iVAL_FIRSTPINWIZARDSHOWN,
            iVAL_SLOWLINKSPEED,
            iVAL_ALWAYSPINSUBFOLDERS,
            iVAL_ENCRYPTCACHE,
            iVAL_NOFRADMINPIN,
            MAX_VALUES 
        };
        //
        // Mask to specify source of a config value.
        //
        enum eSources 
        { 
            eSRC_PREF_CU = 0x00000001,
            eSRC_PREF_LM = 0x00000002,
            eSRC_POL_CU  = 0x00000004,
            eSRC_POL_LM  = 0x00000008,
            eSRC_POL     = eSRC_POL_LM  | eSRC_POL_CU,
            eSRC_PREF    = eSRC_PREF_LM | eSRC_PREF_CU 
        };

        static LPCTSTR s_rgpszSubkeys[MAX_SUBKEYS];
        static LPCTSTR s_rgpszValues[MAX_VALUES];

        DWORD GetValue(eValues iValue, bool *pbSetByPolicy = NULL) const;

        bool CustomGOAExists(HDPA hdpaGOA, const CustomGOA& goa);

        static bool IsValidGoOfflineAction(DWORD dwAction)
            { return ((OfflineAction)dwAction == eGoOfflineSilent ||
                      (OfflineAction)dwAction == eGoOfflineFail); }

        static bool IsValidSyncAction(DWORD dwAction)
            { return ((SyncAction)dwAction == eSyncPartial ||
                      (SyncAction)dwAction == eSyncFull); }

        //
        // Enforce use of GetSingleton() for instantiation.
        //
        CConfig(void) { }
        //
        // Prevent copy.
        //
        CConfig(const CConfig& rhs);
        CConfig& operator = (const CConfig& rhs);
};


#endif // _INC_CSCVIEW_CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\cscentry.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscentry.h
//
//--------------------------------------------------------------------------

#ifndef __cscentry_h
#define __cscentry_h

#include <comctrlp.h>   // DPA
#include "util.h"       // LocalAllocString, LocalFreeString

///////////////////////////////////////////////////////////////////
// CSCEntry
// 
//
class CSCEntry
{
public:
    CSCEntry(REFGUID rguid) : m_pszName(NULL), m_Guid(rguid)  {}
    ~CSCEntry()                         { LocalFreeString(&m_pszName); }

    BOOL Initialize(LPCTSTR pszName)    { return LocalAllocString(&m_pszName, pszName); }

    LPCTSTR Name() const                { return m_pszName; }
    REFGUID Guid() const                { return m_Guid; }

private:
    LPTSTR  m_pszName;                  // E.g. full pathname or sharename
    GUID    m_Guid;                     // GUID used to identify this entry
};

///////////////////////////////////////////////////////////////////
// CSCEntryLog
//
// 
class CSCEntryLog
{
public:
    CSCEntryLog() : m_hdpa(NULL), m_hkRoot(NULL), m_bCSInited(FALSE) {}
    ~CSCEntryLog();

    HRESULT Initialize(HKEY hkRoot, LPCTSTR pszSubkey);

    // Access entries
    CSCEntry* Get(LPCTSTR pszName);
    CSCEntry* Get(REFGUID rguid);

    // Add Entries
    CSCEntry* Add(LPCTSTR pszName);     // Returns existing entry or creates new entry

    // Access Registry
    HKEY OpenKey(LPCTSTR pszSubkey, REGSAM samDesired);
    
private:    
    HKEY m_hkRoot;                      // KEY_ENUMERATE_SUB_KEYS | KEY_CREATE_SUB_KEY
    HDPA m_hdpa;                        // Holds the entry log in memory
    CRITICAL_SECTION m_csDPA;           // Protect access to m_hdpa
    BOOL m_bCSInited;

    HKEY OpenKeyInternal(LPTSTR pszSubkey, REGSAM samDesired);
    CSCEntry* CreateFromKey(LPTSTR pszSubkey);
    HRESULT ReadRegKeys();              // fills m_hdpa
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\cscst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscst.h
//
//--------------------------------------------------------------------------

#ifndef _CSCST_H_
#define _CSCST_H_

// Private messages to the CSC Hidden Window
#define PWM_STDBGOUT              (WM_USER + 400)
#define PWM_STATUSDLG             (WM_USER + 401)
#define PWM_TRAYCALLBACK          (WM_USER + 402)
#define PWM_RESET_REMINDERTIMER   (WM_USER + 403)
#define PWM_REFRESH_SHELL         (WM_USER + 406)
#define PWM_QUERY_UISTATE         (WM_USER + 407)
#define PWM_HANDLE_LOGON_TASKS    (WM_USER + 408)
#define PWM_HANDLE_POLICY_CHANGE  (WM_USER + 409)

//
// Custom private message defined for the notification window.
// Initiates a status check of the cache and update of the systray
// UI if appropriate.
//
#define STWM_STATUSCHECK        (STWM_CSCCLOSEDIALOGS + 10) 

//
// Enumeration of unique systray UI states.
//
typedef enum { STS_INVALID = 0,
               STS_ONLINE,        // All servers online.
               STS_DIRTY,         // One server has dirty files.
               STS_MDIRTY,        // Multiple servers have dirty files.
               STS_SERVERBACK,    // One server is ready for connection.
               STS_MSERVERBACK,   // Multiple servers ready for connection
               STS_OFFLINE,       // One server is offline.
               STS_MOFFLINE,      // Multiple servers are offline.
               STS_NONET          // No net interface available.
               } eSysTrayState;


// Function for finding the hidden window
HWND _FindNotificationWindow();
LRESULT SendToSystray(UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL PostToSystray(UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT SendCopyDataToSystray(DWORD dwData, DWORD cbData, PVOID pData);


#if DBG
//
// Use STDBOUT to output text to the CSC "hidden" window when it
// is not hidden.  To make it visible, build a checked version and 
// set the following reg DWORD value to a number 1-5.
// 1 = least verbose output, 5 = most verbose.
// If the value is not present or is 0, the systray window will be
// created hidden.
//
// HKLM\Software\Microsoft\Windows\CurrentVersion\NetCache\SysTrayOutput
//
// The STDBGOUT macro should be used like this.
//
// STDBGOUT((<level>,<fmt string>,arg,arg,arg));
//
// STDBGOUT((1, TEXT("Function foo failed with error %d"), dwError));
//
// Note that no newline is required in the fmt string.
// Entire macro arg set must be enclosed in separate set of parens.
// STDBGOUT stands for "SysTray Debug Output".
//
void STDebugOut(int iLevel, LPCTSTR pszFmt, ...);
#define STDBGOUT(x) STDebugOut x

#else

#define STDBGOUT(x)

#endif

#endif _CSCST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\cscst.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscst.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shellp.h>     // STR_DESKTOPCLASS
#ifdef REPORT_DEVICE_CHANGES
#   include <dbt.h>        // Device change notifications.
#endif // REPORT_DEVICE_CHANGES
#include <sddl.h>       // For ConvertStringSidToSid
#include "cscst.h"
#include "options.h"
#include "statdlg.h"    // CStatusDlg
#include "folder.h"
#include "eventlog.h"
#include "msg.h"
#include "purge.h"
#include "security.h"
#include "syncmgr.h"
#include "strings.h"
#include "termserv.h"


#if DBG
//
// This code is used to manage the hidden window when we 
// unhide it and display debug output to it via STDBGOUT().
//
#include <commdlg.h>
#include <stdarg.h>
const TCHAR c_szSysTrayOutput[] = TEXT("SysTrayOutput");
int STDebugLevel(void);
void STDebugOnLogEvent(HWND hwndList, LPCTSTR pszText);
void STDebugSaveListboxContent(HWND hwndParent);
DWORD STDebugOpenNetCacheKey(DWORD dwAccess, HKEY *phkey);

#endif // DBG

//
// Size of systray icons.
//
#define CSC_ICON_CX             16
#define CSC_ICON_CY             16
//
// Timer IDs are arbitrary.
//
#define ID_TIMER_FLASHICON    2953
#define ID_TIMER_REMINDER     2954
#define ID_TIMER_STATECHANGE  2955


// Prototypes
void ApplyAdminFolderPolicy(void);   // in admin.cpp

void _RefreshAllExplorerWindows(LPCTSTR pszServer);

// Globals
static HWND g_hWndNotification = NULL;

extern HWND g_hwndStatusDlg;    // in statdlg.cpp

HANDLE g_hToken = NULL;


#ifdef REPORT_DEVICE_CHANGES
HDEVNOTIFY g_hDevNotify = NULL;
#endif // REPORT_DEVICE_CHANGES

//
// RAS Autodial API.
//
typedef BOOL (WINAPI * PFNHLPNBCONNECTION)(LPCTSTR);



#if DBG
//
// Provide some text-form names for state and input values
// to support debug output.  The order of these corresponds 
// to the STS_XXXXX enumeration.
//
LPCTSTR g_pszSysTrayStates[] =      { TEXT("STS_INVALID"),
                                      TEXT("STS_ONLINE"),
                                      TEXT("STS_DIRTY"),
                                      TEXT("STS_MDIRTY"),
                                      TEXT("STS_SERVERBACK"),
                                      TEXT("STS_MSERVERBACK"),
                                      TEXT("STS_OFFLINE"),
                                      TEXT("STS_MOFFLINE"),
                                      TEXT("STS_NONET") };
//
// A simple function to translate a state value to a string.
//
LPCTSTR SysTrayStateStr(eSysTrayState s)
{
    return g_pszSysTrayStates[int(s)];
}

#endif




//
// A simple dynamic list of server names.  A name can be provided
// as either a "\\server" or "\\server\share" and only the server
// part "\\server" is stored.
//
class CServerList
{
public:
    CServerList(void)
        : m_hdpa(DPA_Create(10)) { }

    ~CServerList(void);

    bool Add(LPCTSTR pszServer);

    void Remove(LPCTSTR pszServer);

    void Clear(void);

    int Find(LPCTSTR pszServer);

    int Count(void) const;

    LPCTSTR Get(int iItem) const;

    bool Exists(LPCTSTR pszServer)
        { return -1 != Find(pszServer); }

private:
    HDPA m_hdpa;

    void GetServerFromPath(LPCTSTR pszPath, LPTSTR pszServer, int cchServer);
    //
    // Prevent copy.
    //
    CServerList(const CServerList& rhs);
    CServerList& operator = (const CServerList& rhs);
};


//
// The class that translates CSC agent input and cache status into a subsequent
// systray UI state.  Originally this was a table-driven state machine
// (hence the name).  It later proved sufficient to do a simple scan of cache
// status and determine UI state based on the statistics obtained.  The name
// has been retained for lack of something better.
//
class CStateMachine
{
public:
    CStateMachine(bool bNoNet) : m_bNoNet(bNoNet) { }

    //
    // This is THE function for converting CSC agent input (or a 
    // simple status check) into a systray icon state.
    //
    eSysTrayState TranslateInput(UINT uMsg, LPTSTR pszShare, UINT cchShare);

    void PingServers();

    bool ServerPendingReconnection(LPCTSTR pszServer)
        { return m_PendingReconList.Add(pszServer); }

    void ServerReconnected(LPCTSTR pszServer)
        { m_PendingReconList.Remove(pszServer); }

    void ServerUnavailable(LPCTSTR pszServer)
        { m_PendingReconList.Remove(pszServer); }

    void AllServersUnavailable(void)
        { m_PendingReconList.Clear(); }

    bool IsServerPendingReconnection(LPCTSTR pszServer)
        { return m_PendingReconList.Exists(pszServer); }

private:
    CServerList m_PendingReconList;
    bool        m_bNoNet;

    //
    // Some helper functions for decoding CSC share status values.
    //
    bool ShareIsOffline(DWORD dwCscStatus) const
    {
        return (0 != (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwCscStatus));
    }

    bool ShareHasFiles(LPCTSTR pszShare, bool *pbModified = NULL, bool *pbOpen = NULL) const;

    //
    // Prevent copy.
    //
    CStateMachine(const CStateMachine& rhs);
    CStateMachine& operator = (const CStateMachine& rhs);
};



//
// The CSysTrayUI class encapsulates the manipulation of the systray icon
// so that the rest of the CSCUI code is exposed to only a narrow interface
// to the systray.  It also maintains state information to control flashing
// of the systray icon.   All flashing processing is provided by this class.
//
class CSysTrayUI
{
public:
    ~CSysTrayUI(void);
    //
    // Set the state of the systray icon.  This will only change the
    // icon if the state has changed.  Therefore this function can be
    // called without worrying about excessive redundant updates to 
    // the display.
    //
    bool SetState(eSysTrayState state, LPCTSTR pszServer = NULL);
    //
    // Retrieve the current "state" of the systray UI.  The state
    // is one of the STS_XXXXX codes.
    //
    eSysTrayState GetState(void) const
        { return m_state; }
    //
    // Retrieve the server name to be used in CSCUI elements.
    // If the server name string is empty, that means there are
    // multiple servers in the given state.
    //
    LPCTSTR GetServerName(void) const
        { return m_szServer; }
    //
    // Show the balloon text for the current systray state.
    //
    void ShowReminderBalloon(void);
    //
    // Reset the reminder timer.
    //
    void ResetReminderTimer(bool bRestart);
    //
    // Make any adjustments when a WM_WININICHANGE is received.
    //
    void OnWinIniChange(LPCTSTR pszSection);
    //
    //
    // Get a reference to THE singleton instance.
    //
    static CSysTrayUI& GetInstance(void);

private:
    //
    // A minimal autoptr class to ensure the singleton instance
    // is deleted.
    //
    class autoptr
    {
        public:
            autoptr(void)
                : m_ptr(NULL) { }
            ~autoptr(void)
                { delete m_ptr; }
            CSysTrayUI* Get(void) const
                { return m_ptr; }
            void Set(CSysTrayUI *p)
                { delete m_ptr; m_ptr = p; }

        private:
            CSysTrayUI *m_ptr;
            autoptr(const autoptr& rhs);
            autoptr& operator = (const autoptr& rhs);
    };
    //
    // Icon info maintained for each UI state.
    //
    struct IconInfo 
    {
        HICON hIcon;           // Handle to icon to display in this state.
        UINT  idIcon;          // ID of icon to display in this state.
        int   iFlashTimeout;   // 0 == No icon flash.  Time is in millisec.
    };
    //
    // Info maintained to describe the various balloon text messages.
    // Combination of state and dwTextFlags are the table keys.
    //
    struct BalloonInfo
    {
        eSysTrayState state;     // SysTray state value.
        DWORD dwTextFlags;       // BTF_XXXXX flags.
        DWORD dwInfoFlags;       // NIIF_XXXXX flag.
        UINT  idHeader;          // Res id for header part.
        UINT  idStatus;          // Res id for status part.
        UINT  idBody;            // Res id for body part.
        UINT  idDirective;       // Res id for directive part.
    };
    //
    // Info maintained to describe the various tooltip text messages.
    //
    struct TooltipInfo
    {
        eSysTrayState state;     // SysTray state value.
        UINT idTooltip;          // Tooltip text resource ID.
    };
    //
    // Info maintained for special-case supression of systray balloons.
    // There are some state transitions that shouldn't generate a balloon.
    // This structure describes each entry in an array of supression info.
    //
    struct BalloonSupression
    {
        eSysTrayState stateFrom; // Transitioning from this state.
        eSysTrayState stateTo;   // Transitioning to this state.
    };
    //
    // Enumeration for controlling what's done to the systray on update.
    //
    enum eUpdateFlags { UF_ICON      = 0x00000001,   // Update the icon.
                        UF_FLASHICON = 0x00000002,   // Flash the icon.
                        UF_BALLOON   = 0x00000004,   // Show the balloon.
                        UF_REMINDER  = 0x00000008 }; // Balloon is a reminder.
    //
    // These flags relate a cache state to balloon text message.
    // They fit into an encoded mask where the lowest 4 bits
    // contain the eSysTrayState (STS_XXXXXX) code.
    //
    //      (STS_OFFLINE | BTF_INITIAL) 
    //
    // would indicate the condition where the state is "offline" for 
    // a single server and the text to be displayed is for the initial
    // notification.
    //
    enum eBalloonTextFlags { 
                             BTF_INITIAL = 0x00000010, // Initial notification
                             BTF_REMIND  = 0x00000020  // Reminder
                           };

    static IconInfo    s_rgIconInfo[];       // The icon info
    static BalloonInfo s_rgBalloonInfo[];    // Balloon configuration info.
    static TooltipInfo s_rgTooltipInfo[];    // Tooltip configuration info.
    static BalloonSupression s_rgBalloonSupression[];
    static const int   s_iMinStateChangeInterval;
    UINT_PTR           m_idFlashingTimer;    // Flash timer id.
    UINT_PTR           m_idReminderTimer;    // Timer for showing reminder balloons.
    UINT_PTR           m_idStateChangeTimer; // Timer for queued state changes.
    UINT               m_iIconFlashTime;     // Period of icon flashes (ms).
    HICON&             m_hIconNoOverlay;     // Icon used for flashing.
    HWND               m_hwndNotify;         // Notification window.
    DWORD              m_dwFlashingExpires;  // Tick count when flash timer expires.
    DWORD              m_dwNextStateChange;  // Tick count for next queued state change.
    TCHAR              m_szServer[MAX_PATH]; // Servername for balloon messages.
    TCHAR              m_szServerQueued[MAX_PATH];
    eSysTrayState      m_state;              // Remember current state.
    eSysTrayState      m_statePrev;
    eSysTrayState      m_stateQueued;        
    bool               m_bFlashOverlay;      // Alternates 0,1 (1 == display overlay, 0 == don't)
    bool               m_bActive;            // 1 == we have an active icon in systray.

    //
    // Enforce singleton existance by making construction
    // and copy operations private.
    //
    CSysTrayUI(HWND hwndNotify);
    CSysTrayUI(const CSysTrayUI& rhs);
    CSysTrayUI& operator = (const CSysTrayUI& rhs);

    void UpdateSysTray(eUpdateFlags uFlags, LPCTSTR pszServer = NULL);

    int GetBalloonInfoIndex(eSysTrayState state, DWORD dwTextFlags);

    bool StateHasBalloonText(eSysTrayState state, DWORD dwTextFlags);

    void GetBalloonInfo(eSysTrayState state,
                        DWORD dwTextFlags,
                        LPTSTR pszTextHdr,
                        int cchTextHdr,
                        LPTSTR pszTextBody,
                        int cchTextBody,
                        DWORD *pdwInfoFlags,
                        UINT *puTimeout);
    
    bool SupressBalloon(eSysTrayState statePrev, eSysTrayState state);

    LPTSTR GetTooltipText(eSysTrayState state,
                          LPTSTR pszText,
                          int cchText);

    bool IconFlashedLongEnough(void);

    void KillIconFlashTimer(void);

    void HandleFlashTimer(void);

    void OnStateChangeTimerExpired(void);

    static VOID CALLBACK FlashTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    static VOID CALLBACK ReminderTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
    static VOID CALLBACK StateChangeTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
};


#define ICONFLASH_FOREVER     (UINT(-1))
#define ICONFLASH_NONE        0
//
// These rows must stay in the same order as the STS_XXXXX enumeration members.
// For flash timeout values, 0 == no flash, -1 == never stop.
// Everything else is a timeout in milliseconds.
//
CSysTrayUI::IconInfo
CSysTrayUI::s_rgIconInfo[] = {
    { NULL, 0,                  ICONFLASH_NONE    },  /* STS_INVALID     */
    { NULL, 0,                  ICONFLASH_NONE    },  /* STS_ONLINE      */ 
    { NULL, IDI_CSCWARNING,     ICONFLASH_FOREVER },  /* STS_DIRTY       */ 
    { NULL, IDI_CSCWARNING,     ICONFLASH_FOREVER },  /* STS_MDIRTY      */ 
    { NULL, IDI_CSCINFORMATION, ICONFLASH_NONE    },  /* STS_SERVERBACK  */ 
    { NULL, IDI_CSCINFORMATION, ICONFLASH_NONE    },  /* STS_MSERVERBACK */ 
    { NULL, IDI_CSCNORMAL,      ICONFLASH_NONE    },  /* STS_OFFLINE     */ 
    { NULL, IDI_CSCNORMAL,      ICONFLASH_NONE    },  /* STS_MOFFLINE    */ 
    { NULL, IDI_CSCNORMAL,      ICONFLASH_NONE    }}; /* STS_NONET       */

//
// This table describes all information related to displaying the systray balloons.
// The first two columns are the keys to each record; those being a systray UI state
// and a mask of balloon-text flags.
// Notes:
//        1. There's no balloon for STS_NONET.  We found that the user's response is
//           duh, I know I have no net.  
//
//
CSysTrayUI::BalloonInfo
CSysTrayUI::s_rgBalloonInfo[] = {
    { STS_INVALID,    BTF_INITIAL, NIIF_NONE,    0,                 0,                   0,                        0,                   },
    { STS_INVALID,    BTF_REMIND,  NIIF_NONE,    0,                 0,                   0,                        0,                   },
    { STS_OFFLINE,    BTF_INITIAL, NIIF_INFO,    IDS_BTHDR_INITIAL, IDS_BTSTA_OFFLINE,   IDS_BTBOD_OFFLINE,        IDS_BTDIR_VIEWSTATUS },
    { STS_MOFFLINE,   BTF_INITIAL, NIIF_INFO,    IDS_BTHDR_INITIAL, IDS_BTSTA_OFFLINE,   IDS_BTBOD_OFFLINE_M,      IDS_BTDIR_VIEWSTATUS },
    { STS_OFFLINE,    BTF_REMIND,  NIIF_INFO,    IDS_BTHDR_REMIND,  IDS_BTSTA_OFFLINE,   IDS_BTBOD_STILLOFFLINE,   IDS_BTDIR_VIEWSTATUS },
    { STS_MOFFLINE,   BTF_REMIND,  NIIF_INFO,    IDS_BTHDR_REMIND,  IDS_BTSTA_OFFLINE,   IDS_BTBOD_STILLOFFLINE_M, IDS_BTDIR_VIEWSTATUS },
//    { STS_SERVERBACK, BTF_INITIAL, NIIF_INFO,    IDS_BTHDR_INITIAL, IDS_BTSTA_SERVERBACK,IDS_BTBOD_SERVERBACK,     IDS_BTDIR_RECONNECT  },
//    { STS_MSERVERBACK,BTF_INITIAL, NIIF_INFO,    IDS_BTHDR_INITIAL, IDS_BTSTA_SERVERBACK,IDS_BTBOD_SERVERBACK_M,   IDS_BTDIR_RECONNECT  },
    { STS_SERVERBACK, BTF_REMIND,  NIIF_INFO,    IDS_BTHDR_REMIND,  IDS_BTSTA_SERVERBACK,IDS_BTBOD_STILLBACK,      IDS_BTDIR_RECONNECT  },
    { STS_MSERVERBACK,BTF_REMIND,  NIIF_INFO,    IDS_BTHDR_REMIND,  IDS_BTSTA_SERVERBACK,IDS_BTBOD_STILLBACK_M,    IDS_BTDIR_RECONNECT  },
    { STS_DIRTY,      BTF_INITIAL, NIIF_WARNING, IDS_BTHDR_INITIAL, IDS_BTSTA_DIRTY,     IDS_BTBOD_DIRTY,          IDS_BTDIR_SYNC       },
    { STS_MDIRTY,     BTF_INITIAL, NIIF_WARNING, IDS_BTHDR_INITIAL, IDS_BTSTA_DIRTY,     IDS_BTBOD_DIRTY_M,        IDS_BTDIR_SYNC       },
    { STS_DIRTY,      BTF_REMIND,  NIIF_WARNING, IDS_BTHDR_REMIND,  IDS_BTSTA_DIRTY,     IDS_BTBOD_STILLDIRTY,     IDS_BTDIR_SYNC       },
    { STS_MDIRTY,     BTF_REMIND,  NIIF_WARNING, IDS_BTHDR_REMIND,  IDS_BTSTA_DIRTY,     IDS_BTBOD_STILLDIRTY_M,   IDS_BTDIR_SYNC       }
};

//
// This table lists all of the state transitions that do not generate balloons.
// Ideally, I would have a true state machine to control the UI for any given state transition.
// However, since we have quite a few states and since you can transition from any state
// to almost any other state, the state transition table would be large and confusing
// to read.  Instead, I've taken the position to assume all state transitions generate
// the balloon UI associated with the "to" state unless the transition is listed
// in this table.
//
CSysTrayUI::BalloonSupression
CSysTrayUI::s_rgBalloonSupression[] = {
    { STS_MOFFLINE, STS_OFFLINE  },
    { STS_NONET,    STS_OFFLINE  },
    { STS_NONET,    STS_MOFFLINE }
    };

//
// This table describes all information related to displaying tooltip text
// for the systray icon.
//
CSysTrayUI::TooltipInfo
CSysTrayUI::s_rgTooltipInfo[] = {
    { STS_INVALID,     0                   },
    { STS_OFFLINE,     IDS_TT_OFFLINE      },
    { STS_MOFFLINE,    IDS_TT_OFFLINE_M    },
    { STS_SERVERBACK,  IDS_TT_SERVERBACK   },
    { STS_MSERVERBACK, IDS_TT_SERVERBACK_M },
    { STS_DIRTY,       IDS_TT_DIRTY        },
    { STS_MDIRTY,      IDS_TT_DIRTY_M      },
    { STS_NONET,       IDS_TT_NONET        }
};




//-----------------------------------------------------------------------------
// CServerList member functions.
//-----------------------------------------------------------------------------
CServerList::~CServerList(
    void
    )
{
    if (NULL != m_hdpa)
    {
        int cEntries = DPA_GetPtrCount(m_hdpa);
        LPTSTR pszEntry;
        for (int i = 0; i < cEntries; i++) 
        {
            pszEntry = (LPTSTR)DPA_GetPtr(m_hdpa, i);
            if (NULL != pszEntry)
                LocalFree(pszEntry);
        }
        DPA_Destroy(m_hdpa);
    }
}


void
CServerList::GetServerFromPath(
    LPCTSTR pszPath,
    LPTSTR pszServer,
    int cchServer
    )
{
    TCHAR szServer[MAX_PATH];
    // Truncation is probably OK here since we're stripping down to "\\server",
    // which can only be at most 17 chars (see UNCLEN in lmcons.h).
    StringCchCopy(szServer, ARRAYSIZE(szServer), pszPath);
    PathAddBackslash(szServer);
    PathStripToRoot(szServer);
    LPTSTR pszLastBackslash = StrRChr(szServer, szServer + lstrlen(szServer), TEXT('\\'));
    if (NULL != pszLastBackslash && pszLastBackslash > (szServer + 2))
        *pszLastBackslash = TEXT('\0');
    StringCchCopy(pszServer, cchServer, szServer);
}
    

bool
CServerList::Add(
    LPCTSTR pszServer
    )
{
    if (NULL != m_hdpa)
    {
        if (!Exists(pszServer))
        {
            int cchEntry = lstrlen(pszServer) + 1;
            LPTSTR pszEntry = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchEntry);
            if (NULL != pszEntry)
            {
                GetServerFromPath(pszServer, pszEntry, cchEntry);
                if (-1 != DPA_AppendPtr(m_hdpa, pszEntry))
                    return true;
                //
                // Addition to DPA failed.  Delete the string buffer.
                //
                LocalFree(pszEntry);
            }
        }
    }
    return false;
}

void
CServerList::Remove(
    LPCTSTR pszServer
    )
{
    int iEntry = Find(pszServer);
    if (-1 != iEntry)
    {
        LPTSTR pszEntry = (LPTSTR)DPA_DeletePtr(m_hdpa, iEntry);
        if (NULL != pszEntry)
            LocalFree(pszEntry);
    }
}

LPCTSTR
CServerList::Get(
    int iItem
    ) const
{
    if (NULL != m_hdpa)
        return (LPCTSTR)DPA_GetPtr(m_hdpa, iItem);
    return NULL;
}


int
CServerList::Count(
    void
    ) const
{
    if (NULL != m_hdpa)
        return DPA_GetPtrCount(m_hdpa);
    return 0;
}

                
//
// Locate a server name in the "pending reconnection" list.
// pszServer can either be "\\server" or "\\server\share".
//
// Returns:  Index of entry if found.  -1 if not found.
//
int
CServerList::Find(
    LPCTSTR pszServer
    )
{
    TCHAR szServer[MAX_PATH];
    GetServerFromPath(pszServer, szServer, ARRAYSIZE(szServer));
    if (NULL != m_hdpa)
    {
        int cEntries = DPA_GetPtrCount(m_hdpa);
        LPTSTR pszEntry;
        for (int i = 0; i < cEntries; i++) 
        {
            pszEntry = (LPTSTR)DPA_GetPtr(m_hdpa, i);
            if (NULL != pszEntry)
            {
                if (0 == lstrcmpi(pszEntry, szServer))
                    return i;
            }
        }
    }
    return -1;        
}


void
CServerList::Clear( 
    void
    )
{
    if (NULL != m_hdpa)
    {
        int cEntries = DPA_GetPtrCount(m_hdpa);
        LPTSTR pszEntry;
        for (int i = 0; i < cEntries; i++) 
        {
            pszEntry = (LPTSTR)DPA_DeletePtr(m_hdpa, i);
            if (NULL != pszEntry)
            {
                LocalFree(pszEntry);
            }
        }
    }
}


//-----------------------------------------------------------------------------
// CStateMachine member functions.
//-----------------------------------------------------------------------------
//
// Translates a STWM_XXXXX message from the CSC agent into a systray UI state
// code.  The caller also provides a buffer to a server name.  If we find
// a "single server" condition in the cache (i.e. one server is dirty, one
// server is offline etc), then we write the name of this server to this
// buffer.  Otherwise, the buffer remains unchanged.  The goal here is to 
// end up with a buffer containing the name of the applicable server when
// we have one of these one-server conditions.  Ultimately, the server name
// is included in the tray balloon text message.
//
// The function returns one of the STS_XXXXX UI status codes.
//
// This function is rather long.  Much longer than I like a function to be.
// I've tried to break it up into smaller pieces but any chunks were pretty
// much arbitrary.  Without a good logical breakdown, that doesn't make much
// sense.  Even with it's length, it's not a complex function.  It merely 
// enumerates shares in the cache gathering statistics along the way.  From
// these statistics, it decides what the next UI state should be.
//
eSysTrayState
CStateMachine::TranslateInput(
    UINT uMsg,
    LPTSTR pszServer,
    UINT cchServer
    )
{
    //
    // Since this cscui code is running all the time, we don't want to keep 
    // a handle to the event log open.  Therefore, we use this CscuiEventLog
    // object to automatically close the log for us.  The ReportEvent member
    // of CscuiEventLog handles all initialization of the log and determining
    // if the event should actually be logged (depending upon the current CSCUI
    // event logging level).
    //
    CscuiEventLog log;
    bool bServerIsBack = false;
  
    if (STWM_CSCNETUP == uMsg)
    {
        m_bNoNet = false;
        if (TEXT('\0') != *pszServer)
        {
            STDBGOUT((1, TEXT("Translating STWM_CSCNETUP for server \"%s\""), pszServer));
            //
            // Server reported back by the CSC agent.
            // Add it's name to a persistent (in memory) list of
            // servers available for reconnection.
            // Also clear the "no net" flag.
            //
            bServerIsBack = true;
            ServerPendingReconnection(pszServer);
            if (log.LoggingEnabled())
            {
                log.Push(pszServer);
                log.ReportEvent(EVENTLOG_INFORMATION_TYPE, MSG_I_SERVER_AVAILABLE, 1);
            }
        }
        else
        {
            STDBGOUT((1, TEXT("Translating STWM_CSCNETUP (no associated server)")));
            if (log.LoggingEnabled())
            {
                log.ReportEvent(EVENTLOG_INFORMATION_TYPE, MSG_I_NET_STARTED, 2);
            }
        }
    }
    else if (STWM_CSCNETDOWN == uMsg)
    {
        //
        // This is the only place where transitions from online to
        // offline state are noted in the shell process. (CSCUISetState
        // and OnQueryNetDown execute in WinLogon's process).
        //
        if (TEXT('\0') != *pszServer)
        {
            STDBGOUT((1, TEXT("Translating STWM_CSCNETDOWN for server \"%s\""), pszServer));
            if (!m_bNoNet)
            {
                LPTSTR pszTemp;
                if (LocalAllocString(&pszTemp, pszServer))
                {
                    PostToSystray(PWM_REFRESH_SHELL, 0, (LPARAM)pszTemp);
                }
            }
            //
            // Server reported down by the CSC agent.
            // Remove it's name from the persistent (in memory) list
            // of servers available for reconnection.
            //
            ServerUnavailable(pszServer);
            if (log.LoggingEnabled())
            {
                log.Push(pszServer);
                log.ReportEvent(EVENTLOG_INFORMATION_TYPE, MSG_I_SERVER_OFFLINE, 1);
            }
        }
        else
        {
            STDBGOUT((1, TEXT("Translating STWM_CSCNETDOWN (no associated server)")));
            //
            // Entire network reported down by the CSC agent.
            // Remove all names from the persistent (in memory) list
            // of servers available for reconnection.  m_bNoNet is the only persistent
            // state we have.  Once it is set, the only thing that can reset it
            // is a STWM_CSCNETUP message from the CSC agent.
            //

            if (!m_bNoNet)
                PostToSystray(PWM_REFRESH_SHELL, 0, 0);

            m_bNoNet = true;
            AllServersUnavailable();
            if (log.LoggingEnabled())
            {
                log.ReportEvent(EVENTLOG_INFORMATION_TYPE, MSG_I_NET_STOPPED, 2);
            }
        }
    }
    else if (STWM_STATUSCHECK == uMsg)
    {
        STDBGOUT((1, TEXT("Translating STWM_STATUSCHECK")));
    }
    else if (STWM_CACHE_CORRUPTED == uMsg)
    {
        //
        // Note:  No check for LoggingEnabled().  We always log corrupted cache
        //        regardless of logging level.
        //
        STDBGOUT((1, TEXT("Translating STWM_CACHE_CORRUPTED")));
        log.ReportEvent(EVENTLOG_ERROR_TYPE, MSG_E_CACHE_CORRUPTED, 0);
    }

    //
    // If CSC is disabled or the cache is empty, the default UI state
    // is "online".
    //
    eSysTrayState state = STS_ONLINE;
    if (IsCSCEnabled())
    {
        DWORD dwStatus;
        DWORD dwPinCount;
        DWORD dwHintFlags;
        WIN32_FIND_DATA fd;
        FILETIME ft;
        CCscFindHandle hFind;

        hFind = CacheFindFirst(NULL, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft);
        if (hFind.IsValid())
        {
            //
            // We need these three temporary name lists to reconcile a problem with
            // the way the CSC cache and RDR are designed.  When we enumerate the cache,
            // we enumerate individual shares in the cache.  Each share has some condition
            // (i.e. dirty, offline etc) associated with it.  The problem is that the
            // redirector handles things on a server basis.  So when a particular share
            // is offline, in reality the entire server is offline.  We've decided that
            // the UI should reflect things on a server (computer) basis so we need to 
            // avoid including the states of multiple shares from the same server in
            // our totals.  These three lists are used to store the names of servers
            // with shares in one of the three states (offline, dirty, pending recon).
            // If we enumerate a share with one of these states and find it already
            // exists in the corresponding list, we don't include this share in the
            // statistics.
            // 
            int cShares = 0;
            CServerList OfflineList;
            CServerList DirtyList;
            CServerList BackList;
            //
            // If a server is back, assume we can auto-reconnect it.
            //
            bool bAutoReconnectServer = bServerIsBack;
            TCHAR szAutoReconnectShare[MAX_PATH] = {0};
            DWORD dwPathSpeed = 0;

            do
            {
                bool bShareIsOnServer       = boolify(PathIsPrefix(pszServer, fd.cFileName));
                bool bShareHasModifiedFiles = false;
                bool bShareHasOpenFiles     = false;

                //
                // A share participates in the systray UI calculations only if the 
                // share contains files OR the share is currently "offline".  
                // Because of the CSC database design, CSC doesn't remove a share 
                // entry after all it's files have been removed from the cache. 
                // Therefore we need this extra check to avoid including empty shares in the UI.
                //
                if (ShareHasFiles(fd.cFileName, &bShareHasModifiedFiles, &bShareHasOpenFiles) ||
                    ShareIsOffline(dwStatus))
                {
                    cShares++;

                    if (bShareIsOnServer && (bShareHasModifiedFiles || bShareHasOpenFiles))
                    {
                        //
                        // Auto-reconnect isn't allowed if one or more shares on the server
                        // have open files or files modified offline.  Auto-reconnection
                        // would put the cache into a dirty state.
                        //
                        bAutoReconnectServer = false;
                    }

                    //
                    // A share can be in one of 4 states:
                    //     Online
                    //       Dirty
                    //     Offline
                    //       Pending reconnection ('back')
                    //
                    // Note that our definition of Dirty implies Online, and Pending
                    // Reconnection implies Offline.  That is, an offline share is
                    // never dirty and an online share is never pending reconnection.
                    //

                    //---------------------------------------------------------------------
                    // Is the share online?
                    //---------------------------------------------------------------------
                    if (!ShareIsOffline(dwStatus))
                    {
                        //---------------------------------------------------------------------
                        // Is the share dirty? (online + offline changes)
                        //---------------------------------------------------------------------
                        if (bShareHasModifiedFiles)
                        {
                            STDBGOUT((3, TEXT("Share \"%s\" is dirty (0x%08X)"), fd.cFileName, dwStatus));
                            DirtyList.Add(fd.cFileName);
                        }
                        else
                        {
                            STDBGOUT((3, TEXT("Share \"%s\" is online (0x%08X)"), fd.cFileName, dwStatus));
                        }
                    }
                    else    // Offline
                    {
                        //---------------------------------------------------------------------
                        // Is the server back?
                        //---------------------------------------------------------------------
                        if (IsServerPendingReconnection(fd.cFileName))
                        {
                            STDBGOUT((3, TEXT("Share \"%s\" is pending reconnection (0x%08X)"), fd.cFileName, dwStatus));
                            BackList.Add(fd.cFileName);
                        }
                        else
                        {
                            STDBGOUT((3, TEXT("Share \"%s\" is OFFLINE (0x%08X)"), fd.cFileName, dwStatus));
                            OfflineList.Add(fd.cFileName);
                        }
                    }
                }

                if (!ShareIsOffline(dwStatus))
                {
                    // It's online, so it can't be pending reconnection.
                    ServerReconnected(fd.cFileName);

                    // ...and there's no need to reconnect it.
                    if (bShareIsOnServer)
                        bAutoReconnectServer = false;
                }

                if (FLAG_CSC_SHARE_STATUS_PINNED_OFFLINE & dwStatus)
                {
                    //
                    // Finally... if the user has 'forced' the share offline
                    // we don't allow auto-reconnection.  This allows the
                    // user to 'tag' a share as "always offline" from an 
                    // auto-reconnect perspective.  One might do this for a 
                    // RAS connection.
                    //
                    bAutoReconnectServer = false;
                }

                if (bAutoReconnectServer && bShareIsOnServer && TEXT('\0') == szAutoReconnectShare[0])
                {
                    //
                    // Remember the share name for possible auto-reconnection.
                    // The transition API is TransitionServerOnline but it takes a share name.
                    // Bad choice of names (IMO) but that's the way Shishir did it in the
                    // CSC APIs. It can be any share on the server.
                    //
                    // However, it's possible to have defunct shares in the
                    // database. Try to find one that's connectable.
                    //
                    if (CSCCheckShareOnlineEx(fd.cFileName, &dwPathSpeed))
                    {
                        STDBGOUT((3, TEXT("Share \"%s\" alive at %d00 bps"), fd.cFileName, dwPathSpeed));
                        StringCchCopy(szAutoReconnectShare, ARRAYSIZE(szAutoReconnectShare), fd.cFileName);
                    }
                    else
                    {
                        STDBGOUT((3, TEXT("Share \"%s\" unreachable, error = %d"), fd.cFileName, GetLastError()));
                    }
                }
            }
            while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft));

            if (bAutoReconnectServer)
            {
                //---------------------------------------------------------------------
                // Handle auto-reconnection.
                //---------------------------------------------------------------------
                //
                if (TEXT('\0') != szAutoReconnectShare[0])
                {
                    //
                    // Server was reported "BACK" by the CSC agent and it has no open files
                    // nor files modified offline and it's not on a slow link.  
                    // This makes it a candidate for automatic reconnection.  Try it.
                    //
                    STDBGOUT((1, TEXT("Attempting to auto-reconnect \"%s\""), szAutoReconnectShare));
                    if (TransitionShareOnline(szAutoReconnectShare, TRUE, TRUE, dwPathSpeed))
                    {
                        //
                        // The server has been reconnected.  Remove it's name from the 
                        // "pending reconnection" list.
                        //
                        ServerReconnected(pszServer);
                        //
                        // Remove this server from the temporary lists we've been keeping.
                        //
                        DirtyList.Remove(pszServer);
                        BackList.Remove(pszServer);
                        OfflineList.Remove(pszServer);

                        if (log.LoggingEnabled())
                        {
                            log.Push(pszServer);
                            log.ReportEvent(EVENTLOG_INFORMATION_TYPE, MSG_I_SERVER_AUTORECONNECT, 3);
                        }
                    }
                }
            }

            int cDirty   = DirtyList.Count();
            int cBack    = BackList.Count();
            int cOffline = OfflineList.Count();

            STDBGOUT((2, TEXT("Cache check server results: cShares = %d, cDirty = %d, cBack = %d, cOffline = %d"), 
                     cShares, cDirty, cBack, cOffline));

            //
            // This code path is a waterfall where lower-priority states are overwritten
            // by higher-priority states as they are encountered. The order of this array
            // is important.  It's ordered by increasing priority (no net is 
            // highest priority for systray UI).
            //
            CServerList *pServerList = NULL;
            struct Criteria
            {
                int           cnt;     // Number of applicable servers found.
                eSysTrayState state;   // Single-item UI state.
                eSysTrayState mstate;  // Multi-item UI state.
                CServerList *pList;    // Ptr to applicable list with server names.

            } rgCriteria[] = { 
                 { cOffline,                    STS_OFFLINE,    STS_MOFFLINE,    &OfflineList },
                 { cBack,                       STS_SERVERBACK, STS_MSERVERBACK, &BackList    },
                 { cDirty,                      STS_DIRTY,      STS_MDIRTY,      &DirtyList   },
                 { cShares && m_bNoNet ? 1 : 0, STS_NONET,      STS_NONET,       NULL         }
                 };

            for (int i = 0; i < ARRAYSIZE(rgCriteria); i++)
            {
                Criteria& c = rgCriteria[i];
                if (0 < c.cnt)
                {
                    state = c.mstate;
                    if (1 == c.cnt)
                    {
                        state = c.state;
                        pServerList = NULL;
                        if (NULL != c.pList && 1 == c.pList->Count())
                        {
                            pServerList = c.pList;
                        }
                    }
                }
            }
            if (NULL != pServerList)
            {
                //
                // We had a single-server condition so write the server name
                // to the caller's server name buffer.
                // If we didn't have a single-server condition, the buffer
                // remains unchanged.
                //
                StringCchCopy(pszServer, cchServer, pServerList->Get(0));
            }
        }
    }

    STDBGOUT((1, TEXT("Translated to SysTray UI state %s"), SysTrayStateStr(state)));
    return state;
}

//
// Ping offline servers. If any are alive, update status and
// auto-reconnect them if possible.  This is typically done
// after a sync operation has completed.
//
DWORD WINAPI
_PingServersThread(LPVOID /*pThreadData*/)
{
    DWORD dwStatus;
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    hFind = CacheFindFirst(NULL, &fd, &dwStatus, NULL, NULL, NULL);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        CServerList BackList;

        do
        {
            // If the tray state becomes Online or NoNet, we can quit
            eSysTrayState state = (eSysTrayState)SendToSystray(PWM_QUERY_UISTATE, 0, 0);
            if (STS_ONLINE == state || STS_NONET == state)
                break;

            // Call BackList.Exists here to avoid extra calls to
            // CSCCheckShareOnline. (Add also calls Exists)
            if ((FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwStatus) &&
                !BackList.Exists(fd.cFileName))
            {
                if (!CSCCheckShareOnline(fd.cFileName))
                {
                    DWORD dwErr = GetLastError();
                    if (ERROR_ACCESS_DENIED != dwErr &&
                        ERROR_LOGON_FAILURE != dwErr)
                    {
                        // The share is not reachable
                        continue;
                    }
                    // Access denied or logon failure means the server is
                    // reachable, but we don't have valid credentials.
                }

                // The share is offline but available again.
                STDBGOUT((1, TEXT("Detected server back: %s"), fd.cFileName));
                BackList.Add(fd.cFileName);

                // Get the \\server name (minus the sharename) and
                // tell ourselves that it's back.
                LPCTSTR pszServer = BackList.Get(BackList.Count() - 1);
                if (pszServer)
                {
                    CSCUISetState(STWM_CSCNETUP, 0, (LPARAM)pszServer);
                }
            }
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, NULL, NULL, NULL));

        CSCFindClose(hFind);
    }

    DllRelease();
    FreeLibraryAndExitThread(g_hInstance, 0);
    return 0;
}

void
CStateMachine::PingServers()
{
    // Don't bother trying if there's no net.
    if (!m_bNoNet)
    {
        DWORD dwThreadID;

        // Give the thread a reference to the DLL
        HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
        DllAddRef();

        HANDLE hThread = CreateThread(NULL,
                                      0,
                                      _PingServersThread,
                                      NULL,
                                      0,
                                      &dwThreadID);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            // CreateThread failed, cleanup
            DllRelease();
            FreeLibrary(hInstThisDll);
        }
    }
}

//
// Determine if a given share has files cached in the CSC cache.
// 
//
bool
CStateMachine::ShareHasFiles(
    LPCTSTR pszShare,
    bool *pbModified,
    bool *pbOpen
    ) const
{
    //
    // Exclude the following:
    //   1. Directories.
    //   2. Files marked as "locally deleted".
    //
    // NOTE:  The filtering done by this function must be the same as 
    //        in several other places throughout the CSCUI code.
    //        To locate these, search the source for the comment
    //        string CSCUI_ITEM_FILTER.
    //
    const DWORD fExclude = SSEF_LOCAL_DELETED | 
                           SSEF_DIRECTORY;
    //
    // Stop stats enumeration when we've found all of the following:
    //   1. At least one file.
    //   2. At least one modified file.
    //   3. At least one file with either USER access OR GUEST access.
    //
    const DWORD fUnity   = SSUF_TOTAL | 
                           SSUF_MODIFIED | 
                           SSUF_ACCUSER | 
                           SSUF_ACCGUEST | 
                           SSUF_ACCOR;

    CSCSHARESTATS ss;
    CSCGETSTATSINFO si = { fExclude, fUnity, true, false };
    _GetShareStatisticsForUser(pszShare, // Share name.
                               &si,
                               &ss);     // Destination buffer.

    if (NULL != pbModified)
    {
        *pbModified = (0 < ss.cModified);
    }
    if (NULL != pbOpen)
    {
        *pbOpen = ss.bOpenFiles;
    }

    return 0 < ss.cTotal;
}



//-----------------------------------------------------------------------------
// CSysTrayUI member functions.
//-----------------------------------------------------------------------------
//
// This is the minimum interval (in ms) allowed between state changes of
// the systray UI.  A value of 0 would result in immediate updates as 
// notifications are received from the CSC agent.  A value of 60000 would
// cause any state changes received less than 60 seconds after the previous
// state change to be queued.  60 seconds after the previous state change, 
// if a state change is queued it is applied to the systray UI.
// Something to consider is dynamically adjusting 
//
const int CSysTrayUI::s_iMinStateChangeInterval = 10000; // 10 seconds.


CSysTrayUI::CSysTrayUI(
    HWND hwndNotify
    ) : m_idFlashingTimer(0),
        m_idReminderTimer(0),
        m_idStateChangeTimer(0),
        m_iIconFlashTime(GetCaretBlinkTime()),
        m_hIconNoOverlay(s_rgIconInfo[int(STS_OFFLINE)].hIcon), // The offline icon is used
                                                                // as the non-overlay icon for 
                                                                // flashing.
        m_hwndNotify(hwndNotify),
        m_dwFlashingExpires(0),
        m_dwNextStateChange(0),
        m_state(STS_ONLINE),
        m_statePrev(STS_INVALID),
        m_stateQueued(STS_INVALID),
        m_bFlashOverlay(false),
        m_bActive(false)
{
    //
    // Load up the required icons.
    //
    for (int i = 0; i < ARRAYSIZE(s_rgIconInfo); i++)
    {
        IconInfo& sti = s_rgIconInfo[i];
        if (NULL == sti.hIcon && 0 != sti.idIcon)
        {
            sti.hIcon = (HICON)LoadImage(g_hInstance, 
                                         MAKEINTRESOURCE(sti.idIcon),
                                         IMAGE_ICON, 
                                         CSC_ICON_CX, 
                                         CSC_ICON_CY, 
                                         LR_LOADMAP3DCOLORS);
                        
            if (NULL == sti.hIcon)
            {
                Trace((TEXT("CSCUI ERROR %d loading Icon ID = %d"), GetLastError(), sti.idIcon));
            }
        }
    }
    m_szServer[0] = TEXT('\0');
    m_szServerQueued[0] = TEXT('\0');

    UpdateSysTray(UF_ICON);
}


CSysTrayUI::~CSysTrayUI(
    void
    )
{
    if (0 != m_idStateChangeTimer)
        KillTimer(m_hwndNotify, m_idStateChangeTimer);
}

//
// Singleton instance access.
//
CSysTrayUI& 
CSysTrayUI::GetInstance(
    void
    )
{
    static CSysTrayUI TheUI(_FindNotificationWindow());
    return TheUI;
}


//
// Change the current state of the UI to a new state.
// Returns:
//      true    = state was changed.
//      false   = state was not changed.
//
bool
CSysTrayUI::SetState(
    eSysTrayState state,
    LPCTSTR pszServer      // Optional.  Default is NULL.
    )
{
    bool bResult = false;
    //
    // Apply a state change only if the state has actually changed.
    //
    if (state != m_state)
    {
        //
        // Apply a state change only if there's not a sync in progress.
        // If there is a sync in progress, we'll receive a CSCWM_DONESYNCING
        // message when the sync is finished which will trigger a UI update.
        //
        if (!::IsSyncInProgress())
        {
            if (0 == m_idStateChangeTimer)
            {
                //
                // The state change timer is not active.  That means it's OK
                // to update the tray UI.
                //
                STDBGOUT((1, TEXT("Changing SysTray UI state %s -> %s"), 
                                    SysTrayStateStr(m_state),
                                    SysTrayStateStr(state)));

                m_statePrev = m_state;
                m_state     = state;
                UpdateSysTray(eUpdateFlags(UF_ICON | UF_BALLOON), pszServer);

                //
                // Reset the state change timer so that we will not produce a
                // visible change in the tray UI for at least another 
                // s_iMinStateChangeInterval milliseconds.
                // Also invalidate the queued state info so that if the update timer
                // expires before we queue a state change, it will be a no-op.
                //
                STDBGOUT((2, TEXT("Setting state change timer")));

                m_stateQueued = STS_INVALID;
                m_idStateChangeTimer = SetTimer(m_hwndNotify,
                                                ID_TIMER_STATECHANGE,
                                                s_iMinStateChangeInterval,
                                                StateChangeTimerProc);
                bResult  = true;
            }
            else
            {
                //
                // The state change timer is active so we can't update the tray
                // UI right now.  We'll queue up the state information so when the
                // timer expires this state will be applied.  Note that the "queue"
                // is only ONE item deep.  Each successive addition to the queue
                // overwrites the current content.
                //
                STDBGOUT((2, TEXT("Queueing state change to %s."), SysTrayStateStr(state)));
                m_stateQueued = state;
                if (NULL != pszServer)
                {
                    StringCchCopy(m_szServerQueued, ARRAYSIZE(m_szServerQueued), pszServer);
                }
                else
                {
                    m_szServerQueued[0] = TEXT('\0');
                }
            }
        }
        else
        {
            STDBGOUT((2, TEXT("Sync in progress.  SysTray state not changed.")));
        }
    }
    return bResult;
}



//
// Called each time the state change timer expires.
//
VOID CALLBACK 
CSysTrayUI::StateChangeTimerProc(
    HWND hwnd, 
    UINT uMsg, 
    UINT_PTR idEvent, 
    DWORD dwTime
    )
{
    //
    // Call a non-static function of the singleton instance so
    // we have access to private members.
    //
    CSysTrayUI::GetInstance().OnStateChangeTimerExpired();
}


void
CSysTrayUI::OnStateChangeTimerExpired(
    void
    )
{
    STDBGOUT((2, TEXT("State change timer expired. Queued state = %s"), 
             SysTrayStateStr(m_stateQueued)));

    //
    // Kill the timer and set it's ID to 0.
    // This will let SetState() know that the timer has expired and
    // it's OK to update the tray UI.
    //
    if (0 != m_idStateChangeTimer)
    {
        KillTimer(m_hwndNotify, m_idStateChangeTimer);
        m_idStateChangeTimer = 0;
    }

    if (int(m_stateQueued) != int(STS_INVALID))
    {
        //
        // Call SetState ONLY if queued info is valid; meaning
        // there was something in the queue.
        //
        SetState(m_stateQueued, m_szServerQueued);
    }
}



//
// On WM_WININICHANGED update the icon flash timer.
//
void
CSysTrayUI::OnWinIniChange(
    LPCTSTR pszSection
    )
{
    m_iIconFlashTime = GetCaretBlinkTime();
    KillIconFlashTimer();
    UpdateSysTray(UF_FLASHICON);
}


//
// Show the reminder balloon associated with the current UI state.
//
void 
CSysTrayUI::ShowReminderBalloon(
    void
    )
{
    UpdateSysTray(eUpdateFlags(UF_BALLOON | UF_REMINDER));
}


   
//
// All roads lead here.
// This function is the kitchen sink for updating the systray.
// It's kind of a long function but it centralizes all changes to 
// the systray.  It's divided into 3 basic parts:
//
//  1. Change the tray icon.           (UF_ICON)
//  2. Flash the tray icon.            (UF_FLASHICON)
//  3. Display a notification balloon. (UF_BALLOON)
//  
// Part or all of these can be performed in a single call depending
// upon the content of the uFlags argument.
//
void 
CSysTrayUI::UpdateSysTray(
    eUpdateFlags uFlags,
    LPCTSTR pszServer       // optional.  Default is NULL.
    )
{
    NOTIFYICONDATA nid = {0};

    if (!IsWindow(m_hwndNotify))
        return;
    //
    // If an icon is active, we're modifying it.
    // If none active, we're adding one.
    //        
    DWORD nimsg = NIM_MODIFY;

    nid.cbSize           = sizeof(NOTIFYICONDATA);
    nid.uID              = PWM_TRAYCALLBACK;
    nid.uFlags           = NIF_MESSAGE;
    nid.uCallbackMessage = PWM_TRAYCALLBACK;
    nid.hWnd             = m_hwndNotify;

    IconInfo& sti = s_rgIconInfo[int(m_state)];

    if (NULL != pszServer && TEXT('\0') != *pszServer)
    {
        //
        // Copy the name of the server to a member variable.
        // Skip passed the leading "\\".
        //
        while(*pszServer && TEXT('\\') == *pszServer)
            pszServer++;

        StringCchCopy(m_szServer, ARRAYSIZE(m_szServer), pszServer);
    }

    //
    // Change the icon --------------------------------------------------------
    //
    if (UF_ICON & uFlags)
    {
        nid.uFlags |= NIF_ICON;
        if (0 == sti.idIcon)
        {
            //
            // This state doesn't have an icon.  Delete from systray.
            //
            nimsg = NIM_DELETE;
        }
        else
        {
            if (!m_bActive)
                nimsg = NIM_ADD;

            nid.hIcon = sti.hIcon;
            //
            // If applicable, always flash icon when first showing it.
            //
            uFlags = eUpdateFlags(uFlags | UF_FLASHICON);
            //
            // Set the tooltip.
            //
            nid.uFlags |= NIF_TIP;
            GetTooltipText(m_state, nid.szTip, ARRAYSIZE(nid.szTip));
        }
        m_bFlashOverlay = false;
        KillIconFlashTimer();
    }

    //
    // Flash the icon ---------------------------------------------------------
    //
    if (UF_FLASHICON & uFlags)
    {
        if (0 != sti.iFlashTimeout)
        {
            nid.uFlags |= NIF_ICON; // Flashing is actually displaying a new icon.
            //
            // This icon is a flashing icon.
            //
            if (0 == m_idFlashingTimer)
            {
                //
                // No timer started yet.  Start one.
                //
                STDBGOUT((2, TEXT("Starting icon flash timer.  Time = %d ms"), m_iIconFlashTime));
                m_idFlashingTimer = SetTimer(m_hwndNotify, 
                                             ID_TIMER_FLASHICON, 
                                             m_iIconFlashTime,
                                             FlashTimerProc);
                if (0 != m_idFlashingTimer)
                {
                    //
                    // Set the tick-count when the timer expires.
                    // An expiration time of (-1) means it never expires.
                    //
                    if (ICONFLASH_FOREVER != sti.iFlashTimeout)
                        m_dwFlashingExpires = GetTickCount() + sti.iFlashTimeout;
                    else
                        m_dwFlashingExpires = ICONFLASH_FOREVER;
                }
            }
            nid.hIcon = m_bFlashOverlay ? sti.hIcon : m_hIconNoOverlay;

            m_bFlashOverlay = !m_bFlashOverlay; // Toggle flash state.
        }
    }

    //
    // Update or hide the balloon ---------------------------------------------
    //
    if (UF_BALLOON & uFlags)
    {
        //
        // If there's no balloon text mapped to the current UI state and these
        // balloon flags, any current balloon will be destroyed.  This is because
        // the tray code destroys the current balloon before displaying the new one
        // and it doesn't display a new one if it's passed a blank string.
        //
        nid.uFlags |= NIF_INFO;
        DWORD dwBalloonFlags = (UF_REMINDER & uFlags) ? BTF_REMIND : BTF_INITIAL;
        GetBalloonInfo(m_state, 
                       dwBalloonFlags, 
                       nid.szInfoTitle,
                       ARRAYSIZE(nid.szInfoTitle),
                       nid.szInfo, 
                       ARRAYSIZE(nid.szInfo), 
                       &nid.dwInfoFlags,
                       &nid.uTimeout);
        //
        // Any time we show a balloon, we reset the reminder timer.  
        // This is so that we don't get a balloon resulting from a state change
        // immediately followed by a reminder balloon because the reminder
        // timer expired.
        //
        bool bRestartReminderTimer = (BTF_REMIND == dwBalloonFlags && TEXT('\0') != nid.szInfo[0]) ||
                                     StateHasBalloonText(m_state, BTF_REMIND);

        ResetReminderTimer(bRestartReminderTimer);
    }
    //
    // Notify the systray -----------------------------------------------------
    //
    if (NIM_DELETE == nimsg)
        m_bActive = false;

    if (Shell_NotifyIcon(nimsg, &nid))
    {
        if (NIM_ADD == nimsg)
            m_bActive = true;
    }
}

//
// Get the balloon text associated with a given systray UI state and with
// a given set of BTF_XXXXX (Balloon Text Flag) flags.  The information 
// is stored in the table s_rgBalloonInfo[].  The text and balloon timeout
// are returned in caller-provided buffers.
//
// The balloon text follows this format:
//
//    <Header> <Status> \n
// 
//    <Body>
//
//    <Directive>
//
// An example would be:
//
//    Offline Files - Network Connection Lost
//
//    The network connection to '\\worf' has been lost.
//
//    Click here to view status.
//
// state is one of the STS_XXXXX flags.
// dwTextFlags is a mask of BTF_XXXXX flag bits.
//
void
CSysTrayUI::GetBalloonInfo(
    eSysTrayState state,
    DWORD dwTextFlags,
    LPTSTR pszTextHdr,
    int cchTextHdr,
    LPTSTR pszTextBody,
    int cchTextBody,
    DWORD *pdwInfoFlags,
    UINT *puTimeout
    )
{
    *pszTextHdr  = TEXT('\0');
    *pszTextBody = TEXT('\0');

    if (SupressBalloon(m_statePrev, state))
    {
        STDBGOUT((3, TEXT("Balloon supressed")));
        return;
    }

    int i = GetBalloonInfoIndex(state, dwTextFlags);
    if (-1 != i)
    {
        BalloonInfo& bi = s_rgBalloonInfo[i];

        TCHAR szHeader[80];
        TCHAR szStatus[80];
        TCHAR szDirective[80];
        TCHAR szBody[MAX_PATH];
        TCHAR szFmt[MAX_PATH];
          
        if (STS_OFFLINE == state || STS_DIRTY == state || STS_SERVERBACK == state)
        {
            //
            // State has only one server associated with it so that means we'll
            // be including it in the balloon text body.  Load the format
            // string from a text resource and embed the server name in it.
            //
            LPTSTR rgpstr[] = { m_szServer };
            LoadString(g_hInstance, bi.idBody, szFmt, ARRAYSIZE(szFmt));
            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFmt,
                          0,0,
                          szBody,
                          ARRAYSIZE(szBody),
                          (va_list *)rgpstr);
        }
        else
        {
            //
            // State has multiple servers associated with it so that means
            // there's no name embedded in the body.  It's just a simple string
            // loaded from a text resource.
            //
            LoadString(g_hInstance, bi.idBody, szBody, ARRAYSIZE(szBody));
        }

        //
        // Create the header text.
        //
        LoadString(g_hInstance, IDS_BALLOONHDR_FORMAT, szFmt, ARRAYSIZE(szFmt));
        LoadString(g_hInstance, bi.idHeader, szHeader, ARRAYSIZE(szHeader));
        LoadString(g_hInstance, bi.idStatus, szStatus, ARRAYSIZE(szStatus));

        LPTSTR rgpstrHdr[] = { szHeader,
                               szStatus };

        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szFmt,
                      0,0,
                      pszTextHdr,
                      cchTextHdr,
                      (va_list *)rgpstrHdr);
        //
        // Create the body text.
        //
        LoadString(g_hInstance, IDS_BALLOONBODY_FORMAT, szFmt, ARRAYSIZE(szFmt));
        LoadString(g_hInstance, bi.idDirective, szDirective, ARRAYSIZE(szDirective));
        LPTSTR rgpstrBody[] = { szBody,
                                szDirective };

        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szFmt,
                      0,0,
                      pszTextBody,
                      cchTextBody,
                      (va_list *)rgpstrBody);

        if (NULL != pdwInfoFlags)
        {
            *pdwInfoFlags = bi.dwInfoFlags;
        }

        if (NULL != puTimeout)
        {
            CConfig& config = CConfig::GetSingleton();
            //
            // Balloon timeout is stored in the registry.
            //
            UINT uTimeout = (BTF_INITIAL & dwTextFlags) ? config.InitialBalloonTimeoutSeconds() :
                                                          config.ReminderBalloonTimeoutSeconds();
            *puTimeout = uTimeout * 1000;
        }
    }
}

//
// Find the index in s_rgBalloonInfo[] for a given state
// and BTF_XXXXXX flag.
// Returns -1 if no match in array.
//
int
CSysTrayUI::GetBalloonInfoIndex(
    eSysTrayState state,
    DWORD dwTextFlags
    )
{
    //
    // Scan the balloon info table until we find a record for the 
    // specified systray UI state and BTF flags.
    //
    for (int i = 0; i < ARRAYSIZE(s_rgBalloonInfo); i++)
    {
        BalloonInfo& bi = s_rgBalloonInfo[i];
        if (bi.state == state && 
            bi.dwTextFlags == dwTextFlags &&
            0 != bi.idHeader &&
            0 != bi.idStatus &&
            0 != bi.idBody &&
            0 != bi.idDirective)
        {
            return i;
        }
    }
    return -1;
}


    
//
// Determine if a balloon should not be displayed for a particular
// UI state transition.
//
bool
CSysTrayUI::SupressBalloon(
    eSysTrayState statePrev,
    eSysTrayState state
    )
{
    for (int i = 0; i < ARRAYSIZE(s_rgBalloonSupression); i++)
    {
        if (statePrev == s_rgBalloonSupression[i].stateFrom &&
            state     == s_rgBalloonSupression[i].stateTo)
        {
            return true;
        }
    }
    return false;
}



//
// Do we have balloon text for a given state and balloon style?
// state is one of the STS_XXXXX flags.
// dwTextFlags is a mask of BTF_XXXXX flag bits.
//
bool 
CSysTrayUI::StateHasBalloonText(
    eSysTrayState state,
    DWORD dwTextFlags
    )
{
    return (-1 != GetBalloonInfoIndex(state, dwTextFlags));
}



LPTSTR 
CSysTrayUI::GetTooltipText(
    eSysTrayState state,
    LPTSTR pszText,
    int cchText
    )
{
    *pszText = TEXT('\0');
    //
    // Scan the tooltip info table until we find a record for the 
    // specified systray UI state.
    //
    for (int i = 0; i < ARRAYSIZE(s_rgTooltipInfo); i++)
    {
        TooltipInfo& tti = s_rgTooltipInfo[i];
        if (tti.state == state && 0 != tti.idTooltip)
        {
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = TEXT('\0');
            int cchHeader = LoadString(g_hInstance, IDS_TT_HEADER, szTemp, ARRAYSIZE(szTemp));
            if (STS_OFFLINE == state || STS_DIRTY == state || STS_SERVERBACK == state)
            {
                //
                // State has only one server associated with it so that means we'll
                // be including it in the tooltip text.  Embed the server name in it.
                //
                TCHAR szFmt[160];
                LPTSTR rgpstr[] = { m_szServer };
                LoadString(g_hInstance, tti.idTooltip, szFmt, ARRAYSIZE(szFmt));
                FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                              FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              szFmt,
                              0,0,
                              szTemp + cchHeader,
                              ARRAYSIZE(szTemp) - cchHeader,
                              (va_list *)rgpstr);
            }
            else
            {
                //
                // State has multiple servers associated with it so that means
                // there's no name embedded in the tooltip.  It's just a simple string
                // loaded from a text resource.
                //
                LoadString(g_hInstance, 
                           tti.idTooltip, 
                           szTemp + cchHeader, 
                           ARRAYSIZE(szTemp) - cchHeader);
            }
            StringCchCopy(pszText, cchText, szTemp);
        }
    }
    return pszText;
}


//
// Stop the flashing icon by killing the timer.
//
void 
CSysTrayUI::KillIconFlashTimer(
    void
    )
{
    //
    // Force a final update so we're displaying the proper icon then
    // kill the timer.
    //
    if (0 != m_idFlashingTimer)
    {
        KillTimer(m_hwndNotify, m_idFlashingTimer);
        m_idFlashingTimer = 0;
    }
}

//
// Called by the OS each time the icon flash timer period expires.
// I use this rather than handling a WM_TIMER message so that
// timer processing is contained within the CSysTrayUI class.
//
VOID CALLBACK 
CSysTrayUI::FlashTimerProc(
    HWND hwnd,
    UINT uMsg, 
    UINT_PTR idEvent, 
    DWORD dwTime
    )
{
    CSysTrayUI::GetInstance().HandleFlashTimer();
}


void
CSysTrayUI::HandleFlashTimer(
    void
    )
{
    if (IconFlashedLongEnough())
    {
        //
        // Kill the icon flashing timer and the icon will stop flashing.
        // This doesn't actually kill the timer yet.
        //
        STDBGOUT((2, TEXT("Killing icon flash timer")));
        m_bFlashOverlay = true;
        UpdateSysTray(UF_FLASHICON);
        KillIconFlashTimer();
    }
    else
    {
        //
        // The CSysTrayUI instance maintains all information
        // needed to cycle the icon.  Just tell it to update
        // the icon and it'll do the right thing.
        //
        UpdateSysTray(UF_FLASHICON);
    }
}


//
// Determine if the flashing icon has flashed enough.
//
bool 
CSysTrayUI::IconFlashedLongEnough(
    void
    )
{
    return ICONFLASH_FOREVER != m_dwFlashingExpires && 
           GetTickCount() >= m_dwFlashingExpires;
}


//
// Stop and restart the reminder timer.
// If bRestart is false, the timer is killed and not restarted.
// If bRestart is true, the timer is killed and a new one restarted.
//
void 
CSysTrayUI::ResetReminderTimer(
    bool bRestart
    )
{
    CConfig& config = CConfig::GetSingleton();
    if (!config.NoReminders())
    {
        int cReminderInterval = (config.ReminderFreqMinutes() * 1000 * 60);
        //
        // Force a final update so we're displaying the proper icon then
        // kill the timer.
        //
        if (0 != m_idReminderTimer)
        {
            KillTimer(m_hwndNotify, m_idReminderTimer);
            m_idReminderTimer = 0;
        }
        //
        // No timer started yet.  Start one.
        //
        if (bRestart && 0 < cReminderInterval)
        {
            STDBGOUT((2, TEXT("Starting reminder timer.  Timeout = %d ms"), cReminderInterval));
            m_idReminderTimer = SetTimer(m_hwndNotify, 
                                        ID_TIMER_REMINDER, 
                                        cReminderInterval, 
                                        ReminderTimerProc);
        }
    }
}


//
// Called by the OS each time the reminder timer period expires.
// I use this rather than handling a WM_TIMER message so that
// timer processing is contained within the CSysTrayUI class.
//
VOID CALLBACK 
CSysTrayUI::ReminderTimerProc(
    HWND hwnd, 
    UINT uMsg, 
    UINT_PTR idEvent, 
    DWORD dwTime
    )
{
    STDBGOUT((2, TEXT("Showing reminder balloon")));
    CSysTrayUI::GetInstance().ShowReminderBalloon();
}


//
// Called by the systray WndProc whenever the state of the systray should be
// updated.
//
// hWnd   - HWND of the systray notification window.
//
// stwmMsg - STWM_CSCNETUP     (Net or server is available for reconnect)
//           STWM_CSCNETDOWN   (Net or server is unavailable)
//           STWM_STATUSCHECK  (Check cache state and update systray)
//
// pszServer - non-NULL means CSC agent passed a server name
//      associated with the STWM_XXXX message.
//      This means there was a single server associated with the event
//      rather than multiple servers or the entire net interface.
//
void 
UpdateStatus(
    CStateMachine *pSM,
    HWND hWnd, 
    UINT stwmMsg,
    LPTSTR pszServer
    )
{
    TraceEnter(TRACE_CSCST, "UpdateStatus");
    TraceAssert(NULL != hWnd);

    TCHAR szServerName[MAX_PATH] = { 0 };

    if (pszServer)
    {
        StringCchCopy(szServerName, ARRAYSIZE(szServerName), pszServer);
    }

    //
    // Translate the CSC agent inputs into a new systray UI state.
    //
    eSysTrayState state = pSM->TranslateInput(stwmMsg, szServerName, ARRAYSIZE(szServerName));

    //
    // Get reference to the singleton UI object and tell it to set the state.
    // Note that it remembers all current UI state and will only actually
    // update the systray if the UI state has changed.  Here we can 
    // blindly tell it to update state.  It will only do what's necessary.
    //
    CSysTrayUI::GetInstance().SetState(state, szServerName);
    TraceLeaveVoid();
}



///////////////////////////////////////////////////////////////////////////////
// _CreateMenu()
//
// Create context menu
//
HMENU _CreateMenu()
{
    HMENU hmenu = NULL;
    
    TraceEnter(TRACE_CSCST, "_CreateMenu");

    hmenu = CreatePopupMenu();
    if (NULL != hmenu)
    {
        CConfig& config = CConfig::GetSingleton();     
        TCHAR szTemp[MAX_PATH];
        //
        // Add the "Status" verb.
        //
        LoadString(g_hInstance, IDS_CSC_CM_STATUS, szTemp, ARRAYSIZE(szTemp));
        AppendMenu(hmenu, MF_STRING, PWM_STATUSDLG, szTemp);

        //
        // Add the "Synchronize" verb
        //
        LoadString(g_hInstance, IDS_CSC_CM_SYNCHRONIZE, szTemp, ARRAYSIZE(szTemp));
        AppendMenu(hmenu, MF_STRING, CSCWM_SYNCHRONIZE, szTemp);
        if (!config.NoCacheViewer())
        {
            //
            // Add the "View files" verb
            //
            LoadString(g_hInstance, IDS_CSC_CM_SHOWVIEWER, szTemp, ARRAYSIZE(szTemp));
            AppendMenu(hmenu, MF_STRING, CSCWM_VIEWFILES, szTemp);
        }
        if (!config.NoConfigCache())
        {
            //
            // Add the "Settings" verb
            //
            LoadString(g_hInstance, IDS_CSC_CM_SETTINGS, szTemp, ARRAYSIZE(szTemp));
            AppendMenu(hmenu, MF_STRING, CSCWM_SETTINGS, szTemp);
        }
        //
        // Left clicking the systray icon invokes the status dialog.
        // Therefore, the "Status" verb is our default and must be in bold text.
        //
        SetMenuDefaultItem(hmenu, PWM_STATUSDLG, MF_BYCOMMAND);
    }

    TraceLeaveValue(hmenu);
}

///////////////////////////////////////////////////////////////////////////////
// _ShowMenu()
//
UINT _ShowMenu(HWND hWnd, UINT uMenuNum, UINT uButton)
{
    UINT    iCmd = 0;
    HMENU   hmenu;

    TraceEnter(TRACE_CSCST, "_ShowMenu");

    hmenu = _CreateMenu();
    if (hmenu)
    {
        POINT   pt;

        GetCursorPos(&pt);
        SetForegroundWindow(hWnd);
        iCmd = TrackPopupMenu(hmenu,
                              uButton | TPM_RETURNCMD | TPM_NONOTIFY,
                              pt.x,
                              pt.y,
                              0,
                              hWnd,
                              NULL);
        DestroyMenu(hmenu);
    }

    TraceLeaveValue(iCmd);
}


//
// This function is used to ensure that we don't try to process 
// a WM_RBUTTONUP and WM_LBUTTONUP message at the same time.
// May be a little paranoid.
//
LRESULT
OnTrayIconSelected(
    HWND hWnd,
    UINT uMsg
    )
{
    static LONG bHandling = 0;
    LRESULT lResult = 0;

    if (0 == InterlockedCompareExchange(&bHandling, 1, 0))
    {
        UINT iCmd = 0;
        switch (uMsg)
        {
            case WM_RBUTTONUP:
                //
                // Context menu
                //
                iCmd = _ShowMenu(hWnd, 1, TPM_RIGHTBUTTON);
                break;

            case WM_LBUTTONUP:
                iCmd = PWM_STATUSDLG;
                break;

            default:
                break;

        }
        if (iCmd)
        {
            PostMessage(hWnd, iCmd, 0, 0);
            lResult = 1;
        }

        bHandling = 0;
    }
    return lResult;
}


///////////////////////////////////////////////////////////////////////////////
// _Notify() -- systray notification handler
//
LRESULT _Notify(HWND hWnd, WPARAM /*wParam*/, LPARAM lParam)
{
    LRESULT lResult = 0;
    switch (lParam)
    {
        case WM_RBUTTONUP:
        case WM_LBUTTONUP:
            lResult = OnTrayIconSelected(hWnd, (UINT)lParam);
            break;

        default:
            break;

    }
    return lResult;
}



bool IsServerBack(CStateMachine *pSM, LPCTSTR pszServer)
{
    TCHAR szServer[MAX_PATH];
    if (!PathIsUNC(pszServer))
    {
        //
        // Ensure servername uses UNC format.
        //
        szServer[0] = TEXT('\\');
        szServer[1] = TEXT('\\');
        StringCchCopy(szServer+2, ARRAYSIZE(szServer)-2, pszServer);
        pszServer = szServer;
    }
    return pSM->IsServerPendingReconnection(pszServer);
}


//
// Query CSC policy for the sync-at-logoff (quick vs. full)
// setting. If the policy is set, we enable SyncMgr's sync-at-logoff
// setting.  Without this the CSC policy could be set, the SyncMgr
// setting NOT set and the user wouldn't get sync-at-logoff as the 
// admin had anticipated.
//
void
ApplyCscSyncAtLogonAndLogoffPolicies(
    void
    )
{
    bool bSetByPolicy = false;
    CConfig& config = CConfig::GetSingleton();
    config.SyncAtLogoff(&bSetByPolicy);
    if (bSetByPolicy)
    {
        RegisterForSyncAtLogonAndLogoff(SYNCMGRREGISTERFLAG_PENDINGDISCONNECT,
                                        SYNCMGRREGISTERFLAG_PENDINGDISCONNECT);
    }
    config.SyncAtLogon(&bSetByPolicy);
    if (bSetByPolicy)
    {
        RegisterForSyncAtLogonAndLogoff(SYNCMGRREGISTERFLAG_CONNECT,
                                        SYNCMGRREGISTERFLAG_CONNECT);
    }
}

//
// Encryption/Decryption callback from CSC.
//
//  dwReason                  dwParam1           dwParam2
//  ------------------------- ------------------ --------------------------
//  CSCPROC_REASON_BEGIN      1 == Encrypting    0
//  CSCPROC_REASON_MORE_DATA  0                  Win32 error code
//  CSCPROC_REASON_END        1 == Completed     dwParam1 == 1 ? 0
//                                               dwParam1 == 0 ? GetLastError()
//
DWORD CALLBACK
EncryptDecryptCallback(
    LPCWSTR lpszName,
    DWORD dwStatus,
    DWORD dwHintFlags,
    DWORD dwPinCount,
    WIN32_FIND_DATAW *pFind32,
    DWORD dwReason,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD_PTR dwContext
    )
{
    DWORD dwResult      = CSCPROC_RETURN_CONTINUE;
    const DWORD dwError = dwParam2;
    //
    // Some static data that needs to persist across callback calls.
    //
    static bool  bEncrypting;         // Encrypting or decrypting?
    static bool  bLoggingOff = false; // User logging off?
    static int   cFileErrors = 0;     // How many file-specific errors reported?
    static DWORD dwLastError;
    static TCHAR szLastFile[MAX_PATH];

    //
    // If we've already detected the g_heventTerminate event
    // no sense in continuing.  
    //
    if (bLoggingOff)
        return CSCPROC_RETURN_ABORT;

    //
    // If the wait fails for some reason, e.g. g_heventTerminate
    // is NULL, then we will continue.  Is that OK?
    //
    if (WAIT_OBJECT_0 == WaitForSingleObject(g_heventTerminate, 0))
    {
        //
        // User is logging off.  Need to end this now!
        // Log an event so admin knows why encryption was incomplete.
        //
        // LOGGING LEVEL = 0 (always)
        //
        CscuiEventLog log;
        log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 
                        bEncrypting ? MSG_I_ENCRYPT_USERLOGOFF : MSG_I_DECRYPT_USERLOGOFF,
                        0);

        dwResult    = CSCPROC_RETURN_ABORT;
        bLoggingOff = true;
    }
    else 
    {
        switch(dwReason)
        {
            case CSCPROC_REASON_BEGIN:
                //
                // Reset static variables.
                //
                bEncrypting   = boolify(dwParam1);
                bLoggingOff   = false;
                cFileErrors   = 0;
                dwLastError   = ERROR_SUCCESS;
                szLastFile[0] = TEXT('\0');
                break;

            case CSCPROC_REASON_MORE_DATA:
                if (ERROR_SUCCESS != dwError)
                {
                    //
                    // An error occurred for this file.
                    //
                    CscuiEventLog log;
                    LPTSTR pszError = NULL;
    
                    FormatSystemError(&pszError, dwError);

                    if (0 == cFileErrors++)
                    {
                        //
                        // On the first error, log an error at level 0.
                        // By default, this is the only error the admin will see.
                        // They'll need to increase the event log level to level
                        // 2 in order to get events for each individual file.  The
                        // event text describes this.
                        //
                        // LOGGING_LEVEL = 0
                        // 
                        log.ReportEvent(EVENTLOG_ERROR_TYPE,
                                        bEncrypting ? MSG_E_ENCRYPTFILE_ERRORS : MSG_E_DECRYPTFILE_ERRORS,
                                        0);
                    }                        

                    //
                    // Log the error for this file.
                    //
                    // LOGGING LEVEL = 2
                    //
                    log.Push(HRESULT(dwError), CEventLog::eFmtDec);
                    log.Push(lpszName);
                    log.Push(pszError ? pszError : TEXT(""));
                    if (S_OK == log.ReportEvent(EVENTLOG_ERROR_TYPE, 
                                                bEncrypting ? MSG_E_ENCRYPTFILE_FAILED : MSG_E_DECRYPTFILE_FAILED,
                                                2))
                    {
                        //
                        // We logged this event.
                        // Clear out the last error code and last filename so that
                        // we don't report this error again in response to CSCPROC_REASON_END.
                        //
                        szLastFile[0] = TEXT('\0');
                        dwLastError   = ERROR_SUCCESS;
                    }
                    else
                    {
                        //
                        // Event was not logged because...
                        // 
                        //   a) ... an error occurred while logging the event.
                        //   b) ... EventLoggingLevel policy is too low for this event.
                        //
                        // Save this error code and file name.
                        // We may need to report it in response to CSCPROC_REASON_END.
                        //
                        dwLastError = dwError;
                        StringCchCopy(szLastFile, ARRAYSIZE(szLastFile), lpszName);
                    }

                    if (pszError)
                        LocalFree(pszError);
                }
                break;

            case CSCPROC_REASON_END:
            {
                const DWORD fCompleted = dwParam1;
                CscuiEventLog log;

                if (fCompleted)
                {
                    //
                    // Add an event log entry that the encryption/decryption
                    // completed successfully.
                    //
                    // LOGGING LEVEL = 1
                    //
                    log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 
                                    bEncrypting ? MSG_I_ENCRYPT_COMPLETE : MSG_I_DECRYPT_COMPLETE,
                                    1);
                }
                else
                {
                    LPTSTR pszError = NULL;
                    if (ERROR_SUCCESS != dwError)
                    {
                        //
                        // Some general error with the process.
                        //
                        // LOGGING LEVEL = 0
                        //
                        FormatSystemError(&pszError, dwError);

                        log.Push(HRESULT(dwError), CEventLog::eFmtDec);
                        log.Push(pszError ? pszError : TEXT(""));
                        log.ReportEvent(EVENTLOG_ERROR_TYPE, 
                                        bEncrypting ? MSG_E_ENCRYPT_FAILED : MSG_E_DECRYPT_FAILED,
                                        0);
                    }
                    else if (ERROR_SUCCESS != dwLastError)
                    {
                        if (0 == cFileErrors++)
                        {
                            //
                            // On the first error, log an error at level 0.
                            // By default, this is the only error the admin will see.
                            // They'll need to increase the event log level to level
                            // 2 in order to get events for each individual file.  The
                            // event text describes this.
                            //
                            // LOGGING_LEVEL = 0
                            // 
                            log.ReportEvent(EVENTLOG_ERROR_TYPE,
                                            bEncrypting ? MSG_E_ENCRYPTFILE_ERRORS : MSG_E_DECRYPTFILE_ERRORS,
                                            0);
                        }                        
                        //
                        // Encryption/decryption of some file failed and we did not
                        // log it in the "more data" callback.
                        //
                        // LOGGING LEVEL = 2
                        //
                        FormatSystemError(&pszError, dwLastError);

                        log.Push(HRESULT(dwLastError), CEventLog::eFmtDec);
                        log.Push(szLastFile);
                        log.Push(pszError ? pszError : TEXT(""));
                        log.ReportEvent(EVENTLOG_ERROR_TYPE, 
                                        bEncrypting ? MSG_E_ENCRYPTFILE_FAILED : MSG_E_DECRYPTFILE_FAILED,
                                        2);
                    }
                    if (pszError)
                        LocalFree(pszError);
                }
                break;
            }

            default:
                break;
        }
    }
    return dwResult;
}



DWORD 
CacheEncryptionThreadProc(
    LPVOID pvParams
    )
{
    const DWORD fEncrypt = (DWORD)(DWORD_PTR)pvParams;

    HINSTANCE hmodCSCUI = LoadLibrary(c_szDllName);
    if (NULL != hmodCSCUI)
    {
        //
        // Try to get the encryption mutex.
        //
        HANDLE hMutex = RequestPermissionToEncryptCache();
        if (NULL != hMutex)
        {
            //
            // Ensure release of the mutex.
            //
            CMutexAutoRelease auto_release_mutex(hMutex);

            STDBGOUT((1, TEXT("%s started."),
                         fEncrypt ? TEXT("Encryption") : TEXT("Decryption")));
            //
            // Do the encryption/decryption.  Do it at a low thread priority so
            // we don't steal CPU time from the UI.
            //
            SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
            CSCEncryptDecryptDatabase(fEncrypt, EncryptDecryptCallback, (DWORD_PTR)0);

            STDBGOUT((1, TEXT("%s complete."),
                         fEncrypt ? TEXT("Encryption") : TEXT("Decryption")));
        }
        else
        {
            //
            // Someone else (probably the UI) is currently encrypting/decrypting
            // the cache.  We don't allow concurrent operations so we abort this
            // one.
            //
            STDBGOUT((1, TEXT("%s aborted.  Already in progress."),
                         fEncrypt ? TEXT("Encryption") : TEXT("Decryption")));
        }

        FreeLibraryAndExitThread(hmodCSCUI, 0);
    }

    return 0;
}




//
// Encrypt/Decrypt the cache according to system policy.
// This function will also correct a partial (encrypt/decrypt)
// state in the cache if necessary.
//
void
ApplyCacheEncryptionPolicy(
    void
    )
{
    //
    // Do a quick check to see if an encryption process is already in progress.
    // This doesn't take the mutex but checks to see if someone else has
    // it.  Once we actually start the encryption on the background thread
    // we'll take the mutex.  Of course, if someone else sneeked in and grabbed
    // the mutex between now and then we'll have to abort.
    //
    if (!IsEncryptionInProgress())
    {
        //
        // Encrypt/Decrypt the cache files.  Will provide progress info through
        // the callback EncryptDecryptCallback.  Errors are handled in the callback
        // reason handlers.
        //
        CConfig& config = CConfig::GetSingleton();
        bool bShouldBeEncrypted = config.EncryptCache();
        BOOL bPartial;
        const BOOL bIsEncrypted = IsCacheEncrypted(&bPartial);

        if (bPartial || (boolify(bIsEncrypted) != bShouldBeEncrypted))
        {
            if (CscVolumeSupportsEncryption())
            {
                //
                // Either we have a partially encrypted/decrypted cache or
                // current encryption state is different from what policy wants.
                // Encrypt/decrypt to rectify the situation.
                // Run this on a separate thread so we don't block any processing
                // on the tray UI thread (i.e. volume control).
                //
                DWORD dwThreadId;

                HANDLE hThread = CreateThread(NULL,    // Default security.
                                              0,       // Default stack size.
                                              CacheEncryptionThreadProc,
                                              (VOID *)(DWORD_PTR)bShouldBeEncrypted,
                                              0,       // Run immediately
                                              &dwThreadId);
                if (NULL != hThread)
                {
                    CloseHandle(hThread);
                }
            }
            else
            {
                //
                // The CSC volume doesn't support encryption.  Log an event so
                // the admin will know why the cache wasn't encrypted by policy.
                // Note that we won't hit this path in the "partial" case.  Only
                // if policy says to encrypt.  The event log message is 
                // tailored for this specific scenario.
                //
                TraceAssert(!bIsEncrypted && bShouldBeEncrypted);

                CscuiEventLog log;
                log.ReportEvent(EVENTLOG_WARNING_TYPE, MSG_W_NO_ENCRYPT_VOLUME, 0);
            }

        }
    }
    else
    {
        STDBGOUT((1, TEXT("Encryption/decryption not allowed.  Already in progress.")));
    }
}



//
// Handles policy change in response to a WM_WININICHANGE 
// message with lParam == "policy".
//
LRESULT OnPolicyChange(
    void
    )
{
    ApplyCacheEncryptionPolicy();
    ApplyCscSyncAtLogonAndLogoffPolicies();
    ApplyAdminFolderPolicy();
    return 0;
}



//
// Display the CSCUI status dialog.  Invoked when user either
// left-clicks the systray icon or selects the "Show Status" option
// from the systray context menu.
//
void
ShowCSCUIStatusDlg(
    HWND hwndParent
    )
{
    LPTSTR pszText = NULL;

    const struct
    {
        eSysTrayState state;  // SysTray UI state code.
        UINT idsText;         // Text for status dialog body.

    } rgMap[] = {{ STS_OFFLINE,      IDS_STATUSDLG_OFFLINE      },
                 { STS_MOFFLINE,     IDS_STATUSDLG_OFFLINE_M    },
                 { STS_SERVERBACK,   IDS_STATUSDLG_SERVERBACK   },
                 { STS_MSERVERBACK,  IDS_STATUSDLG_SERVERBACK_M },
                 { STS_DIRTY,        IDS_STATUSDLG_DIRTY        },
                 { STS_MDIRTY,       IDS_STATUSDLG_DIRTY_M      },
                 { STS_NONET,        IDS_STATUSDLG_NONET        }};

    CSysTrayUI& stui = CSysTrayUI::GetInstance();
    eSysTrayState state = stui.GetState();

    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        if (state == rgMap[i].state)
        {
            LoadStringAlloc(&pszText, g_hInstance, rgMap[i].idsText); 
            if (STS_DIRTY == state || STS_OFFLINE == state || STS_SERVERBACK == state)
            {
                LPCTSTR pszServerName = stui.GetServerName();
                if (NULL != pszServerName && TEXT('\0') != *pszServerName)
                {
                    //
                    // Current SysTray UI state has a single server associated
                    // with it.  The message will have the name embedded in
                    // it in 2 places.  Create a temp working buffer and 
                    // re-create the original string with the server name
                    // embedded.  If any of this fails, the string will just
                    // be displayed with the %1, %2 formatting characters rather
                    // than the server names.  Not a fatal problem IMO.
                    //
                    LPTSTR pszTemp = NULL;
                    FormatString(&pszTemp, pszText, pszServerName, pszServerName);
                    if (NULL != pszTemp)
                    {
                        LocalFree(pszText);
                        pszText = pszTemp;
                    }
                }
            }
            break; // Break out of loop.  We have what we need.
        }
    }
    if (NULL != pszText)
    {
        //
        // Display the dialog.
        //
        CStatusDlg::Create(hwndParent, pszText, state);
        LocalFree(pszText);
    }
}


//
// PWM_RESET_REMINDERTIMER handler.
//
void
OnResetReminderTimer(
    void
    )
{
    CSysTrayUI::GetInstance().ResetReminderTimer(true);
}


//
// Whenever we reboot, it's possible that the CSCUI cache has been
// reformatted or that the cache-size policy has been set/changed.
// When reformatted, the CSC agent uses the default size of 10%.  We 
// need to ensure that the size reflects system policy when policy
// is defined.  
//
void
InitCacheSize(
    void
    )
{
    bool bSetByPolicy = false;
    DWORD dwPctX10000 = CConfig::GetSingleton().DefaultCacheSize(&bSetByPolicy);

    if (bSetByPolicy)
    {
        ULARGE_INTEGER ulCacheSize;
        CSCSPACEUSAGEINFO sui;

        GetCscSpaceUsageInfo(&sui);

        if (10000 < dwPctX10000)
        {
            //
            // If value in registry is greater than 10000, it's
            // invalid.  Default to 10% of total disk space.
            //
            dwPctX10000 = 1000;  // Default to 10% (0.10 * 10,000)
        }
        ulCacheSize.QuadPart = (sui.llBytesOnVolume * dwPctX10000) / 10000i64;

        if (!CSCSetMaxSpace(ulCacheSize.HighPart, ulCacheSize.LowPart))
        {
            STDBGOUT((1, TEXT("Error %d setting cache size"), GetLastError()));
        }
    }
}


//
// Handler for CSCWM_SYNCHRONIZE.  Called when user clicks "Synchronize"
// option on systray context menu.  Also invoked when user selects the
// "Synchronize" button in a folder's web view pane.
//
HRESULT
OnSynchronize(
    void
    )
{
    //
    // This will create a status dialog hidden, invoke a synchronization of
    // servers that would be "checked" in the dialog then close the dialog
    // when the synchronization is complete.
    //
    CStatusDlg::Create(g_hWndNotification, 
                       TEXT(""), 
                       CSysTrayUI::GetInstance().GetState(), 
                       CStatusDlg::MODE_AUTOSYNC);
    return NOERROR;
}


LRESULT
OnQueryUIState(
    void
    )
{
    return CSysTrayUI::GetInstance().GetState();
}





//
// When a user profile has been removed from the local machine,
// the delete-profile code in userenv.dll will write the user's SID
// as a text string in the following reg key:
// 
// HKLM\Software\Microsoft\Windows\CurrentVersion\NetCache\PurgeAtNextLogoff
//
// Each SID is a value name under this key.
// At logoff, we enumerate all values under this key.  For each SID we
// instantiate a CCachePurger object and delete all files cached for this
// user.  Once the operation is complete, the "PurgeAtNextLogoff" key
// is deleted from the registry.
//
void
DeleteFilesCachedForObsoleteProfiles(
    void
    )
{
    HKEY hkeyNetcache;
    //
    // Open the "HKLM\...\NetCache" key.
    //
    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                c_szCSCKey,
                                0,
                                KEY_READ,
                                &hkeyNetcache);

    if (ERROR_SUCCESS == lResult)
    {
        HKEY hkey;
        //
        // Open the "PurgeAtNextLogoff" subkey.
        //
        lResult = RegOpenKeyEx(hkeyNetcache,
                               c_szPurgeAtNextLogoff,
                               0,
                               KEY_READ,
                               &hkey);

        if (ERROR_SUCCESS == lResult)
        {
            //
            // Enumerate all the SID strings.
            //
            int iValue = 0;
            TCHAR szValue[MAX_PATH];
            DWORD cchValue = ARRAYSIZE(szValue);
            while(ERROR_SUCCESS == SHEnumValue(hkey,
                                               iValue,
                                               szValue,
                                               &cchValue,
                                               NULL,
                                               NULL,
                                               NULL))
            {
                //
                // Convert each SID string to a SID and delete
                // all cached files accessed by this SID.
                // Purge files ONLY if the SID is NOT for the current
                // user.  Here's the deal...
                // While a user is NOT logged onto a system, their 
                // profile can be removed and their SID recorded in 
                // the PurgeAtNextLogoff key.  The next time they log on they
                // get new profile data.  If they're the next person to
                // logon following the removal of their profile, without 
                // this check, their new profile data would be purged during
                // the subsequent logoff.  That's bad.  Therefore, we never 
                // purge data for the user who is logging off.
                //
                PSID psid;
                if (ConvertStringSidToSid(szValue, &psid))
                {
                    if (!IsSidCurrentUser(psid))
                    {
                        CCachePurgerSel sel;
                        sel.SetFlags(PURGE_FLAG_ALL);
                        if (sel.SetUserSid(psid))
                        {
                            CCachePurger purger(sel, NULL, NULL);
                            purger.Delete();
                        }
                    }                        
                    LocalFree(psid);
                }
                iValue++;
                cchValue = ARRAYSIZE(szValue);
            }
            RegCloseKey(hkey);
            RegDeleteKey(hkeyNetcache, c_szPurgeAtNextLogoff);
        }
        RegCloseKey(hkeyNetcache);
    }
}



//
// This is called when the CSC hidden window is first created
// which occurs at logon.  It's just a general bucket to group the
// things that need to happen each logon.
//
void
HandleLogonTasks(
    void
    )
{   
    InitCacheSize();
    //
    // Apply any necessary policies.
    //
    ApplyCacheEncryptionPolicy();
    ApplyCscSyncAtLogonAndLogoffPolicies();
    ApplyAdminFolderPolicy();
}


//
// This is called when the CSC Agent (running in the winlogon process)
// tells us to uninitialize the CSC UI.  This happens when the user
// is logging off.
//
void
HandleLogoffTasks(
    void
    )
{
    CConfig& config = CConfig::GetSingleton();
    
    DeleteFilesCachedForObsoleteProfiles();

    if (config.PurgeAtLogoff())
    {
        //
        // If policy says to "purge all files cached by this user" 
        // delete offline-copy of all files cached by the current user.
        // Respects access bits in files so that we don't delete something
        // that is only used by some other user.  This is the same
        // behavior obtained via the "Delete Files..." button or the
        // disk cleaner.  Note that the UI callback ptr arg to the purger
        // ctor is NULL and we don't run through a "scan" phase.  This code
        // is run while the user is logging off so we don't display any
        // UI.  
        //
        // Note that the policy can also indicate if this purge operation
        // is for auto-cached files only.
        //
        DWORD dwPurgeFlags = PURGE_FLAG_UNPINNED;
        if (!config.PurgeOnlyAutoCachedFilesAtLogoff())
        {
            dwPurgeFlags |= PURGE_FLAG_PINNED;
        }
        CCachePurgerSel sel;
        sel.SetFlags(dwPurgeFlags);
        CCachePurger purger(sel, NULL, NULL);
        purger.Delete();
    }

    //
    // IMPORTANT:  We do any purging before registering for sync-at-logon/logoff.
    //             This is because we only register if we have something in 
    //             the cache.  Purging might remove all our cached items negating
    //             the need to register for synchronization.
    //
    ApplyCscSyncAtLogonAndLogoffPolicies();
        
    //
    // Is this the first time this user has used run CSCUI?
    //
    if (!IsSyncMgrInitialized())
    {
        CSCCACHESTATS cs;
        CSCGETSTATSINFO si = { SSEF_NONE, SSUF_TOTAL, false, false };
        if (_GetCacheStatisticsForUser(&si, &cs) && 0 < cs.cTotal)
        {
            //
            // This is the first time this user has logged off with
            // something in the cache.  Since SyncMgr doesn't turn on sync-at-logon/logoff
            // out of the box, we do it here.  This is because we want people to sync
            // if they have unknowingly cached files from an autocache share.
            // If successful the SyncMgrInitialized reg value is set to 1.
            //
            RegisterSyncMgrHandler(TRUE);
            const DWORD dwFlags = SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT;
            if (SUCCEEDED(RegisterForSyncAtLogonAndLogoff(dwFlags, dwFlags)))
            {
                SetSyncMgrInitialized();
            }
        }
    }
}


//
// Determines the status of a share for controlling the display of the
// webview in a shell folder.
//
// Returns one of the following codes (defined in cscuiext.h):
//
// CSC_SHARESTATUS_INACTIVE
// CSC_SHARESTATUS_ONLINE
// CSC_SHARESTATUS_OFFLINE
// CSC_SHARESTATUS_SERVERBACK
// CSC_SHARESTATUS_DIRTYCACHE
//
LRESULT
GetShareStatusForWebView(
    CStateMachine *pSM,
    LPCTSTR pszShare
    )
{
    LRESULT lResult = CSC_SHARESTATUS_INACTIVE;

    if (NULL != pszShare && IsCSCEnabled())
    {
        DWORD dwStatus;
        if (CSCQueryFileStatus(pszShare, &dwStatus, NULL, NULL))
        {
            if ((dwStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) != FLAG_CSC_SHARE_STATUS_NO_CACHING)
            {
                const DWORD fExclude = SSEF_LOCAL_DELETED | 
                                       SSEF_DIRECTORY;

                CSCSHARESTATS stats;
                CSCGETSTATSINFO gsi = { fExclude, SSUF_MODIFIED, true, false };

                lResult = CSC_SHARESTATUS_ONLINE;

                if (_GetShareStatisticsForUser(pszShare, &gsi, &stats))
                {
                    if (stats.bOffline)
                    {
                        if (IsServerBack(pSM, pszShare))
                            lResult = CSC_SHARESTATUS_SERVERBACK;
                        else
                            lResult = CSC_SHARESTATUS_OFFLINE;
                    }
                    else
                    {
                        if (0 < stats.cModified)
                            lResult = CSC_SHARESTATUS_DIRTYCACHE;
                    }
                }
            }
        }
    }
    return lResult;
}


//-----------------------------------------------------------------------------
// Sync at Suspend/Hibernate.
//
// We synchronize the cache on a separate thread.  Why use a separate
// thread?
//
// 1. We respond to WM_POWERBROADCAST.
//
// 2. WM_POWERBROADCAST is sent by win32k.sys using SendMessage.
//
// 3. As part of the sync we invoke SyncMgr which involves some 
//    COM operations.  COM doesn't allow certain operations if they occur 
//    on a thread that is currently inside an interprocess SendMessage.  
//    This causes a call to CoCreateInstance inside mobsync.dll to fail 
//    with the error RPC_E_CANTCALLOUT_ININPUTSYNCCALL.
//
// 4. The solution is to place the synchronization (and COM) activity
//    on a separate thread and to allow the thread servicing WM_POWERBROADCAST
//    to process messages.
//
// When suspending, the main thread servicing WM_POWERBROADCAST blocks
// until the entire synchronization is complete.  This is necessary to ensure 
// the synchronization completes before the machine is shut down.
//
// 

//
// The synchronization thread procedure for syncing on suspend/hibernate.
//
DWORD WINAPI
SuspendSync_ThreadProc(
    LPVOID pvParam  // DWORD_PTR holding CSC update flags.
    )
{
    TraceEnter(TRACE_CSCST, "SuspendSync_ThreadProc");

    const DWORD dwFlags = PtrToUint(pvParam);

    Trace((TEXT("Calling CscUpdateCache with flags 0x%08X"), dwFlags));

    const HRESULT hr = CscUpdateCache(dwFlags);

    TraceLeaveResult(hr);
}


//
// Waits on a single object while handling thread messages during the wait.
// Returns the result from MsgWaitForMultipleObjectsEx.
//
DWORD 
WaitAndProcessThreadMessages(
    HANDLE hObject            // Handle for a Win32 synchronization object.
    )
{
    TraceEnter(TRACE_CSCST, "WaitAndProcessThreadMessages");

    DWORD dwResult = WAIT_FAILED;
    BOOL bQuit     = FALSE;

    while(!bQuit)
    {
        TraceMsg("Waiting for message or signaled object...");
        dwResult = MsgWaitForMultipleObjectsEx(1, 
                                               &hObject, 
                                               INFINITE, 
                                               QS_ALLEVENTS, 
                                               MWMO_INPUTAVAILABLE);
        //
        // A message was received.  Handle it.
        //
        if (WAIT_OBJECT_0 + 1 == dwResult)
        {
            MSG msg;
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                Trace((TEXT("Rcvd message %d"), msg.message));
                if (WM_QUIT == msg.message)
                {
                    bQuit = TRUE;
                }
                else
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
        else
        {
            //
            // Any other result ends the loop.
            //
            bQuit = TRUE;
            if (WAIT_OBJECT_0 == dwResult)
            {
                TraceMsg("Object signaled");
            }
            else if (WAIT_FAILED == dwResult)
            {
                Trace((TEXT("Wait failed with error %d"), GetLastError()));
            }
        }
    }
    TraceLeaveValue(dwResult);
}


//
// Gets the sync action (quick vs. full) from user preference and/or
// system policy. If either there is no preference/policy defined
// or we found an invalid preference/policy value in the registry,
// we return eSyncNone as a default.
//
// Returns:
//      CConfig::eSyncPartial   - quick sync.
//      CConfig::eSyncFull      - full sync.
//      CConfig::eSyncNone      - invalid or missing reg info.
//
CConfig::SyncAction
GetSuspendSyncAction(
    void
    )
{
    TraceEnter(TRACE_CSCST, "GetSuspendSyncAction");

    CConfig::SyncAction action = CConfig::eSyncNone;

    HRESULT hr = TS_MultipleSessions();
    if (S_FALSE == hr)
    {
        action = (CConfig::SyncAction)CConfig::GetSingleton().SyncAtSuspend();
        if (CConfig::eSyncPartial != action && CConfig::eSyncFull != action)
        {
            //
            // Either someone poked an invalid value into the registry
            // or there is no preference/policy registered for this parameter.
            // Either way, we want to NOT sync.
            //
            action = CConfig::eSyncNone;
        }
    }
    else if (S_OK == hr)
    {
        Trace((TEXT("Multiple sessions prevent synchronization.")));
    }
    Trace((TEXT("Action = %d"), int(action)));
    TraceLeaveValue(action);
}


//
// Retrieves the set of flags to pass to CscUpdateCache configured
// for a given suspend operation.
//
// Returns:
//      true   - Ok to sync.  CscUpdateCache flags are in *pdwFlags.
//      false  - Don't sync.  Sync action is eSyndNone.
//
bool
IsSuspendSyncRequired(
    bool bOkToPromptUser,
    DWORD *pdwCscUpdateFlags // optional.  Can be NULL.
    )
{
    TraceEnter(TRACE_CSCST, "IsSuspendSyncRequired");
    DWORD dwFlags = 0;
    const CConfig::SyncAction action = GetSuspendSyncAction();
    if (bOkToPromptUser && CConfig::eSyncNone != action)
    {
        dwFlags = CSC_UPDATE_STARTNOW | CSC_UPDATE_FILL_QUICK;
        if (CConfig::eSyncFull == action)
        {
            dwFlags |= (CSC_UPDATE_REINT | CSC_UPDATE_FILL_ALL);
        }
        Trace((TEXT("%s sync is required.  CscUpdate flags = 0x%08X"), 
               CConfig::eSyncFull == action ? TEXT("FULL") : TEXT("QUICK"),
               dwFlags));
    }
    else
    {
        TraceMsg("No sync is required");
    }
    if (NULL != pdwCscUpdateFlags)
    {
        *pdwCscUpdateFlags = dwFlags;
    }
    TraceLeaveValue(0 != dwFlags);
}



//
// This function creates the sync thread, and waits for the sync operation
// to complete if required.  It returns the result returned by CscUpdateCache.
//
LRESULT
SyncOnSuspend(
    DWORD dwCscUpdateFlags
    )
{
    TraceEnter(TRACE_CSCST, "SyncOnSuspend");

    HRESULT hrSyncResult = E_FAIL;
    //
    // Run the synchronization on a separate thread.
    // See the comment above SuspendSync_ThreadProc for details.
    //
    // Need to create the event object BEFORE we create the sync thread
    // so that the object exists before the sync starts.  Only if this
    // named event object exists will the CCscUpdate code signal the
    // event when the operation is complete.
    //
    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, c_szSyncCompleteEvent);
    if (NULL != hEvent)
    {
        HANDLE hThread = CreateThread(NULL,
                                      0,
                                      SuspendSync_ThreadProc,
                                      UIntToPtr(dwCscUpdateFlags),
                                      0,
                                      NULL);
        if (NULL != hThread)
        {
            //
            // Wait for the sync thread to complete.  This just means the call
            // to CscUpdateCache has completed.  We need to wait so we can 
            // retrieve the result from CscUpdateCache through the thread's 
            // exit code.
            // SyncMgr will continue the sync from the mobsync.exe process 
            // after the thread has terminated.
            //
            TraceMsg("Waiting for CscUpdateCache to complete...");
            WaitAndProcessThreadMessages(hThread);
            //
            // The thread's exit code is the HRESULT returned by CscUpdateCache.
            //
            DWORD dwThreadExitCode = (DWORD)E_FAIL;
            GetExitCodeThread(hThread, &dwThreadExitCode);
            hrSyncResult = dwThreadExitCode;
            //
            // We're done with the thread object.
            //
            CloseHandle(hThread);
            hThread = NULL;

            if (SUCCEEDED(hrSyncResult))
            {
                //
                // The sync was successfully started and we're syncing prior to a 
                // suspend operation.  Need to wait 'til the sync is complete so that
                // we block the return to WM_POWERBROADCAST (PBT_APMQUERYSUSPEND).
                //
                TraceMsg("Waiting for sync (mobsync.exe) to complete...");
                WaitAndProcessThreadMessages(hEvent);
            }
        }
        else
        {
            const DWORD dwErr = GetLastError();
            hrSyncResult = HRESULT_FROM_WIN32(dwErr);
            Trace((TEXT("Sync thread creation failed with error %d"), dwErr));
        }
        CloseHandle(hEvent);
        hEvent = NULL;
    }
    else
    {
        const DWORD dwErr = GetLastError();
        hrSyncResult = HRESULT_FROM_WIN32(dwErr);
        Trace((TEXT("Sync event creation failed with error %d"), dwErr));
    }

    if (FAILED(hrSyncResult))
    {
        CscuiEventLog log;
        log.Push(hrSyncResult, CEventLog::eFmtHex);
        log.ReportEvent(EVENTLOG_ERROR_TYPE, 
                        MSG_E_SUSPEND_SYNCFAILED, 0);
    }
    TraceLeaveResult(hrSyncResult);
}


//
// Handles synchronization on suspend/hibernate.
// Note that we do not support sync on resume.  We've
// determined that the behavior is not compelling.  It is
// better to resume and let our normal UI processing 
// handle any network reconnections in the normal way.
//
LRESULT
HandleSuspendSync(
    CStateMachine *pSysTraySM,
    HWND hWnd, 
    bool bOkToPromptUser
    )
{
    TraceEnter(TRACE_CSCST, "HandleSuspendSync");
    Trace((TEXT("\tbOkToPromptUser = %d"), bOkToPromptUser));
 
    LRESULT lResult = ERROR_SUCCESS;
    BOOL bNoNet     = FALSE;

    CSCIsServerOffline(NULL, &bNoNet);
    if (bNoNet)
    {
        TraceMsg("No sync performed.  Network not available.");

        CscuiEventLog log;
        log.ReportEvent(EVENTLOG_INFORMATION_TYPE, 
                        MSG_I_SUSPEND_NONET_NOSYNC, 2);
    }
    else
    {
        //
        // Determine if we're supposed to sync or not.
        // If so, we get the flags to pass to CscUpdateCache that control the
        // sync behavior.
        //
        DWORD dwFlags = 0;
        if (IsSuspendSyncRequired(bOkToPromptUser, &dwFlags))
        {
            lResult = SyncOnSuspend(dwFlags);
        }
    }
    TraceLeaveValue(lResult);
}


//
// Handle any tasks that occur when the computer hibernates or is suspended.
//
LRESULT
HandleSuspendTasks(
    CStateMachine *pSysTraySM,
    HWND hWnd, 
    bool bOkToPromptUser
    )
{
    return HandleSuspendSync(pSysTraySM, hWnd, bOkToPromptUser);
}



#ifdef DEBUG
//
// Returns address of string corresponding to a PBT_XXXXXXX code
// sent in a WM_POWERBROADCAST message.
// Used for debug output only.
//
LPCTSTR ApmCodeName(WPARAM code)
{
    static const TCHAR szUnknown[] = TEXT("<unknown PBT code>");
    static const struct
    {
        WPARAM code;
        LPCTSTR pszName;

    } rgMap[] = {
        { PBT_APMBATTERYLOW,         TEXT("PBT_APMBATTERYLOW")         },
        { PBT_APMOEMEVENT,           TEXT("PBT_APMOEMEVENT")           },
        { PBT_APMPOWERSTATUSCHANGE,  TEXT("PBT_APMPOWERSTATUSCHANGE")  },
        { PBT_APMQUERYSUSPEND,       TEXT("PBT_APMQUERYSUSPEND")       },
        { PBT_APMQUERYSUSPENDFAILED, TEXT("PBT_APMQUERYSUSPENDFAILED") },
        { PBT_APMRESUMEAUTOMATIC,    TEXT("PBT_APMRESUMEAUTOMATIC")    },
        { PBT_APMRESUMECRITICAL,     TEXT("PBT_APMRESUMECRITICAL")     },
        { PBT_APMRESUMESUSPEND,      TEXT("PBT_APMRESUMESUSPEND")      },
        { PBT_APMSUSPEND,            TEXT("PBT_APMSUSPEND")            }
        };

    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        if (rgMap[i].code == code)
        {
            return rgMap[i].pszName;
        }
    }
    return szUnknown;
}

#endif


//
// Handle WM_POWERBROADCAST message.
// We handle this message so that we can synchronize when the computer
// hibernates/suspends.
//      
LRESULT
OnPowerBroadcast(
    CStateMachine *pSysTraySM,
    HWND hWnd, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    Trace((TEXT("OnPowerBroadcast %s (%d), lParam = 0x%08X"), ApmCodeName(wParam), wParam, lParam));
    LRESULT lResult = TRUE;

    switch(wParam)
    {
        case PBT_APMQUERYSUSPEND:        // Ok to suspend/hibernate?
        {
            const bool bOkToPromptUser = (0 != (1 & lParam));
            HandleSuspendTasks(pSysTraySM, hWnd, bOkToPromptUser);
            //
            // Note that we never return BROADCAST_QUERY_DENY.
            // Therefore, we always approve the suspend.
            //
        }
        break;

        //
        // The remaining PBT_APMXXXXX codes are included here to show that 
        // all were considered and explicitly not handled.
        //
        case PBT_APMRESUMESUSPEND:       // Resuming from a previous suspend/hibernate..
        case PBT_APMBATTERYLOW:          // Battery getting low.
        case PBT_APMOEMEVENT:            // Special OEM events.
        case PBT_APMPOWERSTATUSCHANGE:   // Power switched (i.e. from AC -> battery)
        case PBT_APMQUERYSUSPENDFAILED:  // Some process denied a suspend request.
        case PBT_APMRESUMEAUTOMATIC:     // Resuming.  Likely no user available.
        case PBT_APMRESUMECRITICAL:      // Resuming from critical event (i.e. low battery).
        case PBT_APMSUSPEND:             // System is suspending now.
        default:
            break;
    }
    return lResult;
}


//
// This device-change code is an experiment to see what 
// WM_DEVICECHANGE activity we can receive while docking and
// undocking a portable machine.  If we decide to not use
// any of this, just delete it.  Note there are several 
// sections of code that use this conditional compilation.
// [brianau - 12/23/98]
//
#ifdef REPORT_DEVICE_CHANGES

DWORD
RegisterForDeviceNotifications(
    HWND hwndNotify
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    DEV_BROADCAST_DEVICEINTERFACE dbdi;

    ZeroMemory(&dbdi, sizeof(dbdi));
    dbdi.dbcc_size       = sizeof(dbdi);
    dbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    dbdi.dbcc_classguid  = GUID_DEVNODE_CHANGE;
    g_hDevNotify = RegisterDeviceNotification(hwndNotify, &dbdi, DEVICE_NOTIFY_WINDOW_HANDLE);
    if (NULL == g_hDevNotify)
        dwResult = GetLastError();

    return dwResult;
}


void
UnregisterForDeviceNotifications(
    void
    )
{
    if (NULL != g_hDevNotify)
    {
        UnregisterDeviceNotification(g_hDevNotify);
        g_hDevNotify = NULL;
    }
}


void
OnDeviceChange(
    WPARAM wParam,
    LPARAM lParam
    )
{
    PDEV_BROADCAST_DEVICEINTERFACE pdbdi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
    TCHAR szNull[] = TEXT("<null>");
    LPCTSTR pszName = pdbdi ? pdbdi->dbcc_name : szNull;

    switch(wParam)
    {
        case DBT_DEVICEARRIVAL:
            STDBGOUT((3, TEXT("Device Arrival for : \"%s\""), pszName));
            break;
        case DBT_DEVICEREMOVEPENDING:
            STDBGOUT((3, TEXT("Device Remove pending for \"%s\""), pszName));
            break;
        case DBT_DEVICEREMOVECOMPLETE:
            STDBGOUT((3, TEXT("Device Removal complete for \"%s\""), pszName));
            break;
        case DBT_DEVICEQUERYREMOVE:
            STDBGOUT((3, TEXT("Device query remove for \"%s\""), pszName));
            break;
        case DBT_DEVICEQUERYREMOVEFAILED:
            STDBGOUT((3, TEXT("Device query remove FAILED for \"%s\""), pszName));
            break;
        case DBT_DEVICETYPESPECIFIC:
            STDBGOUT((3, TEXT("Device type specific for \"%s\""), pszName));
            break;
        case DBT_QUERYCHANGECONFIG:
            STDBGOUT((3, TEXT("Query change config for \"%s\""), pszName));
            break; 
        case DBT_CONFIGCHANGED:
            STDBGOUT((3, TEXT("Config changed for \"%s\""), pszName));
            break; 
        default:
            STDBGOUT((3, TEXT("Unknown device notification %d"), wParam));
            break;
    }
}

#endif // REPORT_DEVICE_CHANGES



LRESULT CALLBACK _HiddenWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CStateMachine *pSysTraySM = (CStateMachine*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CSCST, "_HiddenWndProc");

    switch(uMsg)
    {
    case WM_CREATE:
        DllAddRef();
#if DBG
        CreateWindow(TEXT("listbox"),
                     NULL,
                     WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | 
                        LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT,
                     0,0,0,0,
                     hWnd,
                     (HMENU)IDC_DEBUG_LIST,
                     g_hInstance,
                     NULL);
#endif
#ifdef REPORT_DEVICE_CHANGES
        RegisterForDeviceNotifications(hWnd);
#endif
        {
            BOOL bNoNet = FALSE;
            // Check whether the entire net is offline or not
            if (!CSCIsServerOffline(NULL, &bNoNet))
                bNoNet = TRUE; // RDR is dead, so net is down
                
            pSysTraySM = new CStateMachine(boolify(bNoNet));
            if (!pSysTraySM)
                TraceLeaveValue((LRESULT)-1);
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pSysTraySM);

            if (bNoNet)
            {
                // Set initial status to NoNet
                PostMessage(hWnd, CSCWM_UPDATESTATUS, STWM_CSCNETDOWN, 0);
            }
            else
            {
                //
                // Calculate initial status as if the logon sync has just
                // completed.
                //
                // There's a race condition, so we can't count on getting
                // this message from the logon sync. If logon sync is still
                // proceeding, we will get another CSCWM_DONESYNCING which
                // is OK.
                //
                PostMessage(hWnd, CSCWM_DONESYNCING, 0, 0);
            }
        }
        //
        // Handle several things that happen at logon.
        //
        PostMessage(hWnd, PWM_HANDLE_LOGON_TASKS, 0, 0);

        //
        // This event is used to terminate any threads when the 
        // hidden notification window is destroyed.
        //
        // If CreateEvent fails, the cache encryption thread will still run
        // (non-interruptable), but the admin-pin thread won't run at all.
        //
        if (NULL == g_heventTerminate)
            g_heventTerminate = CreateEvent(NULL, TRUE, FALSE, NULL);

        //
        // This mutex is used to ensure only one admin-pin operation
        // is running at a time.
        //
        // If CreateMutex fails, the admin-pin code won't run.
        //
        if (NULL == g_hmutexAdminPin)
            g_hmutexAdminPin = CreateMutex(NULL, FALSE, NULL);

        break;

    case PWM_TRAYCALLBACK:
        STDBGOUT((4, TEXT("PWM_TRAYCALLBACK, wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
        lResult = _Notify(hWnd, wParam, lParam);
        break;

#ifdef REPORT_DEVICE_CHANGES
    case WM_DEVICECHANGE:
        OnDeviceChange(wParam, lParam);
        break;
#endif // REPORT_DEVICE_CHANGES

    case WM_ENDSESSION:
        TraceMsg("_HiddenWndProc: Received WM_ENDSESSION.");
        if (NULL != g_heventTerminate)
        {
            //
            // This will tell any threads that they should
            // exit asap.
            //
            SetEvent(g_heventTerminate);
        }
        break;

    case WM_DESTROY:
        TraceMsg("_HiddenWndProc: hidden window destroyed");
#ifdef REPORT_DEVICE_CHANGES
        UnregisterForDeviceNotifications();
#endif
        delete pSysTraySM;
        pSysTraySM = NULL;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
        if (NULL != g_heventTerminate)
        {
            //
            // This will tell any threads that they should
            // exit asap.
            //
            SetEvent(g_heventTerminate);
        }
        DllRelease();
        break;

    case WM_COPYDATA:
        {
            // Warning: STDBGOUT here (inside WM_COPYDATA, outside the switch
            // statement) would cause an infinite loop of WM_COPYDATA messages
            // and blow the stack.
            PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;
            if (pcds)
            {
                switch (pcds->dwData)
                {
                case STWM_CSCNETUP:
                case STWM_CSCNETDOWN:
                case STWM_CACHE_CORRUPTED:
                    {
                        LPTSTR pszServer = NULL;
                        //
                        // WM_COPYDATA is always sent, not posted, so copy the data
                        // and post a message to do the work asynchronously.
                        // This allocated string will be freed by the CSCWM_UPDATESTATUS
                        // handler UpdateStatus().  No need to free it here.
                        //
                        STDBGOUT((3, TEXT("Rcvd WM_COPYDATA, uMsg = 0x%08X, server = \"%s\""), pcds->dwData, pcds->lpData));
                        LocalAllocString(&pszServer, (LPTSTR)pcds->lpData);
                        PostMessage(hWnd, CSCWM_UPDATESTATUS, pcds->dwData, (LPARAM)pszServer);
                    }
                    break;

                case CSCWM_GETSHARESTATUS:
                    // This one comes from outside of cscui.dll, and
                    // is always UNICODE.
                    if (pcds->lpData)
                    {
                        STDBGOUT((3, TEXT("Rcvd CSCWM_GETSHARESTATUS for \"%s\""), (LPWSTR)pcds->lpData));
                        lResult = GetShareStatusForWebView(pSysTraySM, (LPWSTR)pcds->lpData);
                    }
                    break;
                   
                case PWM_REFRESH_SHELL:
                    STDBGOUT((3, TEXT("Rcvd WM_COPYDATA, PWM_REFRESH_SHELL, server = \"%s\""), pcds->lpData));
                    if (pcds->lpData)
                    {
                        LPTSTR pszServer = NULL;
                        LocalAllocString(&pszServer, (LPTSTR)pcds->lpData);
                        PostMessage(hWnd, PWM_REFRESH_SHELL, 0, (LPARAM)pszServer);
                    }
                    break;
#if DBG
                //
                // The following messages in the "#if DBG" block are to support the
                // monitoring feature of the hidden systray window.
                //
                case PWM_STDBGOUT:
                    // Warning: no STDBGOUT here
                    STDebugOnLogEvent(GetDlgItem(hWnd, IDC_DEBUG_LIST), (LPCTSTR)pcds->lpData);
                    break;
#endif // DBG
                }
            }
        }
        break;

    case CSCWM_ISSERVERBACK:
        STDBGOUT((2, TEXT("Rcvd CSCWM_ISSERVERBACK")));
        lResult = IsServerBack(pSysTraySM, (LPCTSTR)lParam);
        break;

    case CSCWM_DONESYNCING:
        STDBGOUT((1, TEXT("Rcvd CSCWM_DONESYNCING. wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
        pSysTraySM->PingServers();
        UpdateStatus(pSysTraySM, hWnd, STWM_STATUSCHECK, NULL);
        break;

    case CSCWM_UPDATESTATUS:
        UpdateStatus(pSysTraySM, hWnd, (UINT)wParam, (LPTSTR)lParam);
        if (lParam)
            LocalFree((LPTSTR)lParam);  // We make a copy when we get WM_COPYDATA
        break;

    case PWM_RESET_REMINDERTIMER:
        STDBGOUT((2, TEXT("Rcvd PWM_RESET_REMINDERTIMER")));
        OnResetReminderTimer();
        break;

    case PWM_HANDLE_LOGON_TASKS:
        HandleLogonTasks();
        break;

    case PWM_REFRESH_SHELL:
        STDBGOUT((3, TEXT("Rcvd PWM_REFRESH_SHELL, server = \"%s\""), (LPCTSTR)lParam));
        _RefreshAllExplorerWindows((LPCTSTR)lParam);
        //
        // lParam is a server name allocated with LocalAlloc.
        //
        if (lParam)
            LocalFree((LPTSTR)lParam);
        break;

    case CSCWM_VIEWFILES:
        COfflineFilesFolder::Open();
        break;

    case PWM_STATUSDLG:
        ShowCSCUIStatusDlg(hWnd);
        break;

    case PWM_QUERY_UISTATE:
        lResult = OnQueryUIState();
        break;

    case CSCWM_SYNCHRONIZE:
        STDBGOUT((1, TEXT("Rcvd CSCWM_SYNCHRONIZE")));
        OnSynchronize();
        break;

    case CSCWM_SETTINGS:
        COfflineFilesSheet::CreateAndRun(g_hInstance, GetDesktopWindow(), &g_cRefCount);
        break;

    case WM_WININICHANGE:
        STDBGOUT((1, TEXT("Rcvd WM_WININICHANGE.  wParam = %d, lParam = \"%s\""),
                     wParam, lParam ? (LPCTSTR)lParam : TEXT("<null>")));

        //
        // Let the tray UI thread respond to a possible change in caret
        // blink rate.
        //
        CSysTrayUI::GetInstance().OnWinIniChange((LPCTSTR)lParam);

        if (!lstrcmpi((LPTSTR)lParam, c_szPolicy))
        {
            //
            // Post a message to ourselves so we get the policy processing off 
            // of the calling thread.  Otherwise COM will fail because this 
            // message is SENT by userenv as an inter-process SendMessage.
            // 
            PostMessage(hWnd, PWM_HANDLE_POLICY_CHANGE, 0, 0);
        }
        break;

    case PWM_HANDLE_POLICY_CHANGE:
        OnPolicyChange();
        break;

    case WM_POWERBROADCAST:
        lResult = OnPowerBroadcast(pSysTraySM, hWnd, wParam, lParam);
        break;

#if DBG
        //
        // The following messages in the "#if DBG" block are to support the
        // monitoring feature of the hidden systray window.
        //
        case WM_GETDLGCODE:
            lResult = DLGC_WANTALLKEYS;
            break;

        case WM_VKEYTOITEM:
            wParam = LOWORD(wParam); // Extract the virtual key code.
            //
            // Fall through.
            //
        case WM_KEYDOWN:
            if (0x8000 & GetAsyncKeyState(VK_CONTROL))
            {
                if (TEXT('S') == wParam || TEXT('s') == wParam)
                {
                    //
                    // Ctrl-S saves the contents to a file.
                    //
                    STDebugSaveListboxContent(hWnd);
                }
                else if (TEXT('U') == wParam || TEXT('u') == wParam)
                {
                    //
                    // Ctrl-U forces an update to match the current cache state.
                    //
                    UpdateStatus(pSysTraySM, hWnd, STWM_STATUSCHECK, NULL);
                }
                else if (TEXT('B') == wParam || TEXT('b') == wParam)
                {
                    //
                    // Ctrl-B pings offline servers to see if they are back.
                    //
                    pSysTraySM->PingServers();
                }
                else if (TEXT('P') == wParam || TEXT('p') == wParam)
                {
                    //
                    // Ctrl-P triggers the policy code
                    //
                    PostMessage(hWnd, PWM_HANDLE_POLICY_CHANGE, 0, 0);
                }
            }
            else if (VK_DELETE == wParam)
            {
                //
                // [Delete] clears the contents of the listbox.
                //
                if (IDOK == MessageBox(hWnd,
                                       TEXT("Clear the list?"),
                                       STR_CSCHIDDENWND_TITLE,
                                       MB_OKCANCEL))
                {
                    SendDlgItemMessage(hWnd, IDC_DEBUG_LIST, LB_RESETCONTENT, 0, 0);
                }
            }
            lResult = (WM_VKEYTOITEM == uMsg) ? -1 : 0;
            break;

        case WM_SIZE:
        {
            RECT rc;
            GetClientRect(hWnd, &rc);
            SetWindowPos(GetDlgItem(hWnd, IDC_DEBUG_LIST),
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top,
                         SWP_NOZORDER);
        }
        break;
#endif // DBG

    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
        break;
    }

    TraceLeaveValue(lResult);
}


HWND _CreateHiddenWnd(void)
{
    WNDCLASS wc;
    HWND hwnd;
    DWORD dwStyle = WS_OVERLAPPED;

    TraceEnter(TRACE_CSCST, "_CreateHiddenWnd");

    GetClassInfo(NULL, WC_DIALOG, &wc);
    wc.style         |= CS_NOCLOSE;
    wc.lpfnWndProc   = _HiddenWndProc;
    wc.hInstance     = g_hInstance;
    wc.lpszClassName = STR_CSCHIDDENWND_CLASSNAME;
    RegisterClass(&wc);

#if DBG
    if (0 < STDebugLevel())
    {
        // This includes WS_CAPTION, which turns on theming, so we
        // only want this when the window is visible.
        dwStyle = WS_OVERLAPPEDWINDOW;
    }
#endif // DBG

    //
    // Note that we can't use HWND_MESSAGE as the parent since we need
    // to receive certain broadcast messages.
    //
    hwnd = CreateWindow(STR_CSCHIDDENWND_CLASSNAME,
                        NULL,
                        dwStyle,
                        CW_USEDEFAULT, CW_USEDEFAULT,
                        CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hInstance,
                        NULL);
    if (hwnd)
    {
#if DBG
        //
        // In debug builds, if registry is set up to display 
        // systray debug output, create the CSCUI "hidden" window
        // as visible.
        //
        if (0 < STDebugLevel())
        {
            ShowWindow(hwnd, SW_NORMAL);
            UpdateWindow(hwnd);
        }
#endif // DBG
    }
    else
    {
        Trace((TEXT("CSCSysTrayThreadProc: CreateWindow failed GLE: %Xh"), GetLastError()));
    }

    TraceLeaveValue(hwnd);
}


HWND _FindNotificationWindow()
{
    g_hWndNotification = FindWindow(STR_CSCHIDDENWND_CLASSNAME, NULL);
    return g_hWndNotification;
}


BOOL _CheckNotificationWindow()
{
    SetLastError(ERROR_SUCCESS);
    if (!IsWindow(g_hWndNotification))
    {
        // Search for the window and try again
        _FindNotificationWindow();
        if (!IsWindow(g_hWndNotification))
        {
            SetLastError(ERROR_INVALID_WINDOW_HANDLE);
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
PostToSystray(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (_CheckNotificationWindow())
    {
        return PostMessage(g_hWndNotification, uMsg, wParam, lParam);
    }

    return FALSE;
}

#define SYSTRAY_MSG_TIMEOUT     10000

LRESULT
SendToSystray(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD_PTR dwResult = 0;

    if (_CheckNotificationWindow())
    {
        SendMessageTimeout(g_hWndNotification,
                           uMsg,
                           wParam,
                           lParam,
                           SMTO_ABORTIFHUNG,
                           SYSTRAY_MSG_TIMEOUT,
                           &dwResult);
    }

    return dwResult;
}


LRESULT SendCopyDataToSystray(DWORD dwData, DWORD cbData, PVOID pData)
{
    COPYDATASTRUCT cds;
    cds.dwData = dwData;
    cds.cbData = cbData;
    cds.lpData = pData;
    return SendToSystray(WM_COPYDATA, 0, (LPARAM)&cds);
}

STDAPI_(HWND) CSCUIInitialize(HANDLE hToken, DWORD dwFlags)
{
    TraceEnter(TRACE_CSCST, "CSCUIInitialize");

    _FindNotificationWindow();

    //
    // We get initialization and shutdown messages from cscdll and also
    // from the systray code in stobject.dll.
    //
    // Cscdll calls from within the winlogon process, at logon and logoff.
    // At logon, cscdll provides us with the user's token, which we duplicate
    // for accessing HKEY_CURRENT_USER (in OnQueryNetDown and at logoff).
    //
    // The systray code calls from within the explorer process, at explorer
    // load and unload (usually just after logon and just before logoff).
    // This is where we create and destroy our hidden window.
    //
    // Note: At one time we kept certain registry keys open (cached). This
    // caused problems at logoff since the profile couldn't be saved until
    // all reg keys were closed. Think carefully before deciding to hold
    // any reg keys open.
    //
    if (dwFlags & CI_INITIALIZE)
    {
        if (hToken)
        {
            DuplicateToken(hToken, SecurityImpersonation, &g_hToken);
            Trace((TEXT("CSCUIInitialize: Using new token handle:%Xh"), g_hToken));
        }

        if (dwFlags & CI_CREATEWINDOW)
        {
            BOOL bCSCEnabled = IsCSCEnabled();
            //
            // The CI_CREATEWINDOW bit is set by systray/explorer
            //
            if (!bCSCEnabled || CConfig::GetSingleton().NoCacheViewer())
            {
                //
                // If CSC is currently disabled, or system policy prevents the
                // user from viewing the cache contents, remove the Offline Files
                // folder shortcut from the user's desktop.
                //
                DeleteOfflineFilesFolderLink_PerfSensitive();
            }

            if (g_hWndNotification)
            {
                Trace((TEXT("CSCUIInitialize: returning existing hWnd:%Xh"), g_hWndNotification));
            }
            else if (!bCSCEnabled)
            {
                ExitGracefully(g_hWndNotification, NULL, "CSCUIInitialize: CSC not enabled");
            }
            else
            {
                g_hWndNotification = _CreateHiddenWnd();
                Trace((TEXT("CSCUIInitialize: Created new hWnd:%Xh"), g_hWndNotification));
            } 
        }    
    }    
    else if (dwFlags & CI_TERMINATE)
    {
        if (dwFlags & CI_DESTROYWINDOW)
        {
            //
            // The CI_DESTROYWINDOW bit is set by systray.exe
            //
            if (g_hWndNotification)
            {
                TraceMsg("CSCUIInitialize: Destroying hidden window");
                DestroyWindow(g_hWndNotification);
                g_hWndNotification = NULL;
            }
            UnregisterClass(STR_CSCHIDDENWND_CLASSNAME, g_hInstance);
        }    
        else
        {
            //
            // This call is a result of a logoff notification from the
            // CSC agent running within winlogon.exe.  
            //
            if (g_hToken)
            {
                if (ImpersonateLoggedOnUser(g_hToken))
                {
                    HandleLogoffTasks();
                    RevertToSelf();
                }
            }
        }
        if (g_hToken)
        {
            TraceMsg("CSCUIInitialize: Freeing token handle");
            CloseHandle(g_hToken);
            g_hToken = NULL;
        }
    }

exit_gracefully:

    TraceLeaveValue(g_hWndNotification);
}


LRESULT 
AttemptRasConnect(
    LPCTSTR pszServer
    )
{
    LRESULT lRes = LRESULT_CSCFAIL;
    HMODULE hMod = LoadLibrary(TEXT("rasadhlp.dll"));

    if (hMod)
    {
        PFNHLPNBCONNECTION pfn;
        pfn = (PFNHLPNBCONNECTION)GetProcAddress(hMod, (LPCSTR)"AcsHlpNbConnection");

        STDBGOUT((1, TEXT("Attempting RAS connection to \"%s\""), pszServer ? pszServer : TEXT("<null>")));
       
        if (pfn)
        {
            if ((*pfn)(pszServer))
            {
                STDBGOUT((1, TEXT("RAS connection successful. Action is LRESULT_CSCRETRY.")));
                lRes = LRESULT_CSCRETRY;
            }    
            else
            {
                STDBGOUT((2, TEXT("AttemptRasConnect: AcsHlpNbConnection() failed.")));
            }
        }
        else
        {
            STDBGOUT((2, TEXT("AttemptRasConnect: Error %d getting addr of AcsHlpNbConnection()"), GetLastError()));
        }
        FreeLibrary(hMod);    
    }
    else 
    {
        STDBGOUT((2, TEXT("AttemptRasConnect: Error %d loading rasadhlp.dll.  Action is LRESULT_CSCFAIL"), GetLastError()));
    }
    if (LRESULT_CSCFAIL == lRes)
    {
        STDBGOUT((1, TEXT("RAS connection failed.")));
    }

    return lRes;
}


//////////////////////////////////////////////////////////////////////////////
// _OnQueryNetDown
//
// Handler for STWM_CSCQUERYNETDOWN
//
// Returns:
//
//    LRESULT_CSCFAIL         - Fail the connection NT4-style.
//    LRESULT_CSCWORKOFFLINE  - Transition this server to "offline" mode.
//    LRESULT_CSCRETRY        - We have a RAS connection.  Retry.
//
LRESULT OnQueryNetDown(
    DWORD dwAutoDialFlags,
    LPCTSTR pszServer
    )
{
    LRESULT lResult = LRESULT_CSCFAIL;

    if (CSCUI_NO_AUTODIAL != dwAutoDialFlags)
    {
        //
        // The server is not in the CSC database and CSCDLL wants us
        // to offer the USER a RAS connection.
        //
        lResult = AttemptRasConnect(pszServer);
    }
    //
    // CSC is not available on 'Personal' SKU.
    //
    if (!IsOS(OS_PERSONAL))
    {
        //
        // lResult will be LRESULT_CSCFAIL under two conditions:
        //
        // 1. dwAutoDialFlags is CSCUI_NO_AUTODIAL so lResult has it's initial value.
        // 2. AttemptRasConnect() failed and returned LRESULT_CSCFAIL.
        //    In this case we now want to determine if we really want to
        //    fail the request or if we should transition offline.
        //
        // Also, only execute this if the server is in the cache.  If not,
        // we don't want to go offline on the server; we just want to fail
        // it.
        //
        if ((LRESULT_CSCFAIL == lResult) &&
            (CSCUI_AUTODIAL_FOR_UNCACHED_SHARE != dwAutoDialFlags))
        {
            //
            // This code is called from within the winlogon process.  Because
            // it's winlogon, there's some funky stuff going on with user tokens
            // and registry keys.  In order to read the user preference for
            // "offline action" we need to temporarily impersonate the currently
            // logged on user.  
            //
            int iAction = CConfig::eGoOfflineSilent; // default if impersonation fails.

            if (g_hToken)
            {
                if (ImpersonateLoggedOnUser(g_hToken))
                {
                    iAction = CConfig::GetSingleton().GoOfflineAction(pszServer);
                    RevertToSelf();
                }
            }

            switch(iAction)
            {
                case CConfig::eGoOfflineSilent:
                    STDBGOUT((1, TEXT("Action is LRESULT_CSCWORKOFFLINE")));
                    lResult = LRESULT_CSCWORKOFFLINE;
                    break;

                case CConfig::eGoOfflineFail:
                    STDBGOUT((1, TEXT("Action is LRESULT_CSCFAIL")));
                    lResult = LRESULT_CSCFAIL;
                    break;

                default:
                    STDBGOUT((1, TEXT("Invalid action (%d), defaulting to LRESULT_CSCWORKOFFLINE"), iAction));
                    //
                    // An invalid action code defaults to "work offline".
                    //
                    lResult = LRESULT_CSCWORKOFFLINE;
                    break;
            }
        }
    }
    return lResult;
}


//
// This function is typically called from the CSC Agent (cscdll) in winlogon.
// The Agent asks us whether to transition offline or not, and also notifies
// us of status changes (net-up, net-down, etc.). Status changes are passed
// on to the hidden systray window.
//
// Special care must be taken to not call SendMessage back to the UI thread,
// since it is possible, although unlikely, that the UI thread is hitting
// the net and blocked waiting for a response from this function (deadlock).
//
// The debug-only STDBGOUT is exempted from the SendMessage ban. If you hit
// a deadlock due to STDBGOUT, reboot and turn off SysTrayOutput.
//
STDAPI_(LRESULT) CSCUISetState(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    LPTSTR pszServer = (LPTSTR)lParam;

    if (pszServer && !*pszServer)
        pszServer = NULL;

    switch(uMsg)
    {
    case STWM_CSCQUERYNETDOWN:
        STDBGOUT((1, TEXT("Rcvd STWM_CSCQUERYNETDOWN, wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
        lRes = OnQueryNetDown((DWORD)wParam, pszServer);
        //
        // HACK!  This is a hack to handle the way the redirector and the CSC
        //        agent work in the "net down" case.  The CSC agent tells us 
        //        about "no net" in a CSCQUERYNETDOWN rather than a CSCNETDOWN 
        //        like I would prefer it.  The problem is that the redirector 
        //        doesn't actually transition the servers to offline until 
        //        a server is touched.  Therefore, when lParam == 0 
        //        we need to first handle the "query" case to determine what to tell
        //        the CSC agent (fail, work offline, retry etc).  Then, if the
        //        result is not "retry", we need to continue processing the message 
        //        as if it were STWM_CSCNETDOWN. [brianau]
        //
        if (LRESULT_CSCRETRY == lRes || NULL != pszServer)
            return lRes;
        uMsg = STWM_CSCNETDOWN;
        //
        // Fall through...
        //
        case STWM_CSCNETDOWN:
            STDBGOUT((1, TEXT("Rcvd STWM_CSCNETDOWN, wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
            break;

        case STWM_CSCNETUP:
            STDBGOUT((1, TEXT("Rcvd STWM_CSCNETUP, wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
            break;

        case STWM_CACHE_CORRUPTED:
            STDBGOUT((1, TEXT("Rcvd STWM_CACHE_CORRUPTED, wParam = 0x%08X, lParam = 0x%08X"), wParam, lParam));
            break;
    }

    //
    // If we have a server name, use WM_COPYDATA to get the data
    // into explorer's process.
    //
    if (pszServer)
    {
        SendCopyDataToSystray(uMsg, StringByteSize(pszServer), pszServer);
    }
    else
    {
        PostToSystray(CSCWM_UPDATESTATUS, uMsg, 0);
    }

    return lRes;
}    


const TCHAR c_szExploreClass[]  = TEXT("ExploreWClass");
const TCHAR c_szIExploreClass[] = TEXT("IEFrame");
const TCHAR c_szCabinetClass[]  = TEXT("CabinetWClass");
const TCHAR c_szDesktopClass[]  = TEXT(STR_DESKTOPCLASS);


BOOL IsExplorerWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    if ( (lstrcmp(szClass, c_szCabinetClass) == 0) 
       ||(lstrcmp(szClass, c_szIExploreClass) == 0)
       ||(lstrcmp(szClass, c_szExploreClass) == 0))
       return TRUE;

    return FALSE;   
}


//
// IsWindowBrowsingServer determines if a given window is browsing a particular
// server. The function assumes that the window is an explorer window.
// If pszServer == NULL, return TRUE if the window is browsing a remote path
// even if the window is not browsing this particular server.
//
BOOL IsWindowBrowsingServer(
    HWND hwnd,
    LPCTSTR pszServer
    )
{
    BOOL bResult = FALSE;
    DWORD_PTR dwResult;
    DWORD dwPID = GetCurrentProcessId();
    const UINT uFlags = SMTO_NORMAL | SMTO_ABORTIFHUNG;
    if (SendMessageTimeout(hwnd,
                           CWM_CLONEPIDL,
                           (WPARAM)dwPID,
                           0L,
                           uFlags,
                           5000,
                           &dwResult))
    {
        HANDLE hmem = (HANDLE)dwResult;
        if (NULL != hmem)
        {
            LPITEMIDLIST pidl = (LPITEMIDLIST)SHLockShared(hmem, dwPID);
            if (NULL != pidl)
            {
                TCHAR szPath[MAX_PATH];
                if (SHGetPathFromIDList(pidl, szPath))
                {
                    LPTSTR pszRemotePath;
                    if (S_OK == GetRemotePath(szPath, &pszRemotePath))
                    {
                        if (NULL == pszServer)
                        {
                            bResult = TRUE;
                        }                            
                        else
                        {
                            PathStripToRoot(pszRemotePath);
                            PathRemoveFileSpec(pszRemotePath);
                            bResult = (0 == lstrcmpi(pszServer, pszRemotePath));
                        }
                        LocalFreeString(&pszRemotePath);
                    }
                }
                SHUnlockShared(pidl);
            }
            SHFreeShared(hmem, dwPID);
        }
    }
    return bResult;
}

BOOL CALLBACK _RefreshEnum(HWND hwnd, LPARAM lParam)
{
    LPCTSTR pszServer = (LPCTSTR)lParam;
    if (IsExplorerWindow(hwnd) && IsWindowBrowsingServer(hwnd, pszServer))
    {
        STDBGOUT((2, TEXT("Refreshing explorer wnd 0x%08X for \"%s\""), hwnd, pszServer));
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);
    }        
    return(TRUE);
}

//
// _RefreshAllExplorerWindows is called by the CSC tray wnd proc
// in response to a PWM_REFRESH_SHELL message.  The pszServer argument
// is the name of the server (i.e. "\\scratch") that has transitioned
// either online or offline.  The function refreshes windows that are 
// currently browsing the server.
//
// If pszServer is NULL, the function refreshes all windows browsing the net.
//
void _RefreshAllExplorerWindows(LPCTSTR pszServer)
{
    //
    // Without initializing COM, we hit a "com not initialized" assertion
    // in shdcocvw when calling SHGetPathFromIDList in IsWindowBrowsingServer.
    // 
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        //
        // Note that the enumeration doesn't catch the desktop window,
        // but we don't care.  Change notifications are working now, so
        // content is updated properly.  We're only doing this refresh stuff
        // to keep WebView up-to-date with respect to online/offline state.
        // The desktop doesn't have that, so no need to refresh it.
        //
        EnumWindows(_RefreshEnum, (LPARAM)pszServer);
        CoUninitialize();
    }        
}


STDAPI_(BOOL) CSCUIMsgProcess(LPMSG pMsg)
{
    return IsDialogMessage(g_hwndStatusDlg, pMsg);
}


//-----------------------------------------------------------------------------
// SysTray debug monitoring code.
//
//
// This function can run in either winlogon, systray or mobsync processes.
// That's why we use WM_COPYDATA to communicate the text information.
//
#if DBG
void STDebugOut(
    int iLevel,
    LPCTSTR pszFmt,
    ...
    )
{
    if (STDebugLevel() >= iLevel)
    {
        TCHAR szText[1024];
        SYSTEMTIME t;
        GetLocalTime(&t);

        wnsprintf(szText, ARRAYSIZE(szText), TEXT("[pid %d] %02d:%02d:%02d.%03d  "),
                  GetCurrentProcessId(),
                  t.wHour,
                  t.wMinute,
                  t.wSecond,
                  t.wMilliseconds);

        UINT cch = lstrlen(szText);

        va_list args;
        va_start(args, pszFmt);
        wvnsprintf(szText + cch, ARRAYSIZE(szText)-cch, pszFmt, args);
        va_end(args);

        COPYDATASTRUCT cds;
        cds.dwData = PWM_STDBGOUT;
        cds.cbData = StringByteSize(szText);
        cds.lpData = szText;
        SendToSystray(WM_COPYDATA, 0, (LPARAM)&cds);
    }
}


int STDebugLevel(void)
{
    static DWORD dwMonitor = (DWORD)-1;

    if ((DWORD)-1 == dwMonitor)
    {
        dwMonitor = 0;
        HKEY hkey;
        DWORD dwType;
        DWORD cbData = sizeof(DWORD);
        DWORD dwStatus = STDebugOpenNetCacheKey(KEY_QUERY_VALUE, &hkey);
        if (ERROR_SUCCESS == dwStatus)
        {
            RegQueryValueEx(hkey,
                            c_szSysTrayOutput,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwMonitor,
                            &cbData);
            RegCloseKey(hkey);
        }
    }
    return int(dwMonitor);
}

//
// Called in response to PWM_STDBGOUT.  This occurs in the systray process only.
//
void STDebugOnLogEvent(
    HWND hwndList,
    LPCTSTR pszText
    )
{
    if (pszText && *pszText)
    {
        int iTop = (int)SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)pszText);
        SendMessage(hwndList, LB_SETTOPINDEX, iTop - 5, 0);
    }
}


typedef BOOL (WINAPI * PFNGETSAVEFILENAME)(LPOPENFILENAME);

//
// This function will always run on the window's thread and in the systray process.
//
void STDebugSaveListboxContent(
    HWND hwndParent
    )
{
    static bool bSaving = false;  // Re-entrancy guard.
    if (bSaving)
        return;

    HMODULE hModComdlg = LoadLibrary(TEXT("comdlg32"));
    if (NULL == hModComdlg)
        return;

    PFNGETSAVEFILENAME pfnSaveFileName = (PFNGETSAVEFILENAME)GetProcAddress(hModComdlg, "GetSaveFileNameW");
    if (NULL != pfnSaveFileName)
    {
        bSaving = true;
        TCHAR szFile[MAX_PATH] = TEXT("C:\\CSCUISystrayLog.txt");
        OPENFILENAME ofn = {0};
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner   = hwndParent;
        ofn.hInstance   = g_hInstance;
        ofn.lpstrFile   = szFile;
        ofn.nMaxFile    = ARRAYSIZE(szFile);
        ofn.lpstrDefExt = TEXT("txt");
        if ((*pfnSaveFileName)(&ofn))
        {
            HANDLE hFile = CreateFile(szFile,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                int n = (int)SendDlgItemMessage(hwndParent, IDC_DEBUG_LIST, LB_GETCOUNT, 0, 0);
                TCHAR szText[MAX_PATH];
                for (int i = 0; i < n; i++)
                {
                    //
                    // WARNING:  This could potentially overwrite the szText[] buffer.
                    //           However, since the text should be of a readable length
                    //           in a listbox I doubt if it will exceed MAX_PATH.
                    //
                    SendDlgItemMessage(hwndParent, IDC_DEBUG_LIST, LB_GETTEXT, i, (LPARAM)szText);
                    StringCchCat(szText, ARRAYSIZE(szText), TEXT("\r\n"));
                    DWORD dwWritten = 0;
                    WriteFile(hFile, szText, lstrlen(szText) * sizeof(TCHAR), &dwWritten, NULL);
                }

                CloseHandle(hFile);
            }
            else
            {
                TCHAR szMsg[MAX_PATH];
                wnsprintf(szMsg, ARRAYSIZE(szMsg), TEXT("Error %d creating file \"%s\""), GetLastError(), szFile);
                MessageBox(hwndParent, szMsg, STR_CSCHIDDENWND_TITLE, MB_ICONERROR | MB_OK);
            }
        }
    }
    bSaving = false;
    FreeLibrary(hModComdlg);
}



DWORD STDebugOpenNetCacheKey(
    DWORD dwAccess,
    HKEY *phkey
    )
{
    DWORD dwDisposition;
    return RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                          REGSTR_KEY_OFFLINEFILES,
                          0,
                          NULL,
                          0,
                          dwAccess,
                          NULL,
                          phkey,
                          &dwDisposition);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.cpp
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
/ Title;
/   debug.cpp
/
/ Authors;
/   Jeffrey Saathoff (jeffreys)
/
/ Notes;
/   Provides printf style debug output
/----------------------------------------------------------------------------*/
#include "pch.h"
#include <stdio.h>
#include <comctrlp.h>
#pragma hdrstop


#ifdef DEBUG

DWORD g_dwTraceMask = 0;
DWORD g_tlsDebug = 0xffffffffL;

#define MAX_CALL_DEPTH  64


class CDebugStack
{
private:
    DWORD m_dwThreadID;
    LONG m_cDepth;
    struct
    {
        BOOL    fTracedYet;
        LPCTSTR pszFunctionName;
        DWORD   dwMask;
    }
    m_CallStack[MAX_CALL_DEPTH];

public:
    CDebugStack() : m_dwThreadID(GetCurrentThreadId()), m_cDepth(-1)
    { ZeroMemory(&m_CallStack, sizeof(m_CallStack)); }

public:
    void _Indent(LONG iDepth, LPCTSTR pszFormat, ...);
    void _vIndent(LONG iDepth, LPCTSTR pszFormat, va_list *pva);
    BOOL _TraceProlog(LONG iDepth, BOOL fForce);
    void _TraceEnter(DWORD dwMask, LPCTSTR pName);
    void _TraceLeave(void);
    void _Trace(BOOL bForce, LPCTSTR pszFormat, ...);
    void _vTrace(BOOL bForce, LPCTSTR pszFormat, va_list *pva);
    void _TraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
    void _TraceAssert(int iLine, LPTSTR pFilename, LPTSTR pCondition);
};
typedef CDebugStack *PDEBUGSTACK;

class CDebugStackHolder
{
private:
    HDPA m_hDebugStackList;
    CRITICAL_SECTION m_csStackList;
    BOOL m_bCSInited;

public:
    CDebugStackHolder() : m_hDebugStackList(NULL), m_bCSInited(FALSE) {}
    ~CDebugStackHolder();

public:
    BOOL Initialize() { m_bCSInited = InitializeCriticalSectionAndSpinCount(&m_csStackList, 0); return m_bCSInited;}
    void Add(PDEBUGSTACK pDebugStack);
    void Remove(PDEBUGSTACK pDebugStack);
};
typedef CDebugStackHolder *PDEBUGSTACKHOLDER;

PDEBUGSTACKHOLDER g_pStackHolder = NULL;


/*-----------------------------------------------------------------------------
/ _Indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pszFormat -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void CDebugStack::_Indent(LONG iDepth, LPCTSTR pszFormat, ...)
{
    va_list va;
    va_start(va, pszFormat);
    _vIndent(iDepth, pszFormat, &va);
    va_end(va);
}


void CDebugStack::_vIndent(LONG iDepth, LPCTSTR pszFormat, va_list *pva)
{
    TCHAR szStringBuffer[2048];
    szStringBuffer[0] = TEXT('\0');

    wnsprintf(szStringBuffer, ARRAYSIZE(szStringBuffer), TEXT("%08x "), m_dwThreadID);

    iDepth = min(iDepth, MAX_CALL_DEPTH - 1);
    for ( ; iDepth > 0 ; iDepth-- )
        StringCchCat(szStringBuffer, ARRAYSIZE(szStringBuffer), TEXT("  "));

    LONG cch = lstrlen(szStringBuffer);
    wvnsprintf(szStringBuffer + cch, ARRAYSIZE(szStringBuffer) - cch, pszFormat, *pva);
    StringCchCat(szStringBuffer + cch, ARRAYSIZE(szStringBuffer) - cch, TEXT("\n"));

    OutputDebugString(szStringBuffer);
}


/*-----------------------------------------------------------------------------
/ _TraceProlog
/ -------------
/   Handle the prolog to a prefix string, including outputting the
/   function name if we haven't already.
/
/ In:
/   iDepth = depth in the call stack
/   fForce = ignore flags
/
/ Out:
/   BOOL if trace output should be made
/----------------------------------------------------------------------------*/
BOOL CDebugStack::_TraceProlog(LONG iDepth, BOOL fForce)
{
    if ( iDepth < 0 || iDepth >= MAX_CALL_DEPTH )
        return FALSE;

    if  ( (g_dwTraceMask & m_CallStack[iDepth].dwMask) || fForce )
    {
        if ( !m_CallStack[iDepth].fTracedYet )
        {
            if ( iDepth > 0 )
                _TraceProlog(iDepth-1, TRUE);

            _Indent(iDepth, m_CallStack[iDepth].pszFunctionName);
            m_CallStack[iDepth].fTracedYet = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
/ _TraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceEnter(DWORD dwMask, LPCTSTR pName)
{
    m_cDepth++;

    if ( m_cDepth < MAX_CALL_DEPTH )
    {
        if ( !pName )    
            pName = TEXT("<no name>");         // no function name given

        m_CallStack[m_cDepth].fTracedYet = FALSE;
        m_CallStack[m_cDepth].pszFunctionName = pName;
        m_CallStack[m_cDepth].dwMask = dwMask;

        //if ( m_cDepth > 0 )
        //    _TraceProlog(m_cDepth-1, FALSE);
    }
}


/*-----------------------------------------------------------------------------
/ _TraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceLeave(void)
{
    //_TraceProlog(m_cDepth, FALSE);

    //if ( !m_cDepth && m_CallStack[0].fTracedYet )
    //    OutputDebugString(TEXT("\n"));
    
    m_cDepth = max(m_cDepth-1, -1);         // account for underflow
}


/*-----------------------------------------------------------------------------
/ _Trace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_Trace(BOOL bForce, LPCTSTR pszFormat, ...)
{
    va_list va;
    va_start(va, pszFormat);
    _vTrace(bForce, pszFormat, &va);
    va_end(va);
}


void CDebugStack::_vTrace(BOOL bForce, LPCTSTR pszFormat, va_list *pva)
{
    if ( _TraceProlog(m_cDepth, bForce) || bForce )
        _vIndent(m_cDepth+1, pszFormat, pva);
}


/*-----------------------------------------------------------------------------
/ _TraceGUID
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#define MAP_GUID(x)     &x, TEXT(#x)
#define MAP_GUID2(x,y)  MAP_GUID(x), MAP_GUID(y)

const struct 
{
    const GUID* m_pGUID;
    LPCTSTR     m_pName;
}
_guid_map[] = 
{
    MAP_GUID(IID_IUnknown),
    MAP_GUID(IID_IClassFactory),
    MAP_GUID(IID_IDropTarget),
    MAP_GUID(IID_IDataObject),
    MAP_GUID(IID_IPersist),
    MAP_GUID(IID_IOleWindow),

    MAP_GUID2(IID_INewShortcutHookA, IID_INewShortcutHookW),
    MAP_GUID(IID_IShellBrowser),
    MAP_GUID(IID_IShellView),
    MAP_GUID(IID_IContextMenu),
    MAP_GUID(IID_IShellIcon),
    MAP_GUID(IID_IShellFolder),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID(IID_IPersistFolder),  
    MAP_GUID2(IID_IExtractIconA, IID_IExtractIconW),
    MAP_GUID2(IID_IShellLinkA, IID_IShellLinkW),
    MAP_GUID2(IID_IShellCopyHookA, IID_IShellCopyHookW),
    MAP_GUID2(IID_IFileViewerA, IID_IFileViewerW),
    MAP_GUID(IID_ICommDlgBrowser),
    MAP_GUID(IID_IEnumIDList),
    MAP_GUID(IID_IFileViewerSite),
    MAP_GUID(IID_IContextMenu2),
    MAP_GUID2(IID_IShellExecuteHookA, IID_IShellExecuteHookW),
    MAP_GUID(IID_IPropSheetPage),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IUniformResourceLocator),
};

void CDebugStack::_TraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    TCHAR szGUID[40];
    LPCTSTR pName = NULL;
    int i;
    
    for ( i = 0 ; i < ARRAYSIZE(_guid_map); i++ )
    {
        if ( IsEqualGUID(rGUID, *_guid_map[i].m_pGUID) )
        {
            pName = _guid_map[i].m_pName;
            break;
        }
    }

    if ( !pName )
    {
        SHStringFromGUID(rGUID, szGUID, ARRAYSIZE(szGUID));
        pName = szGUID;
    }

    _Trace(FALSE, TEXT("%s %s"), pPrefix, pName);
}


/*-----------------------------------------------------------------------------
/ _TraceAssert
/ -------------
/   Our assert handler, always prints messages but only breaks if enabled
/   in the trace mask.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/   pCondition -> assert condition that failed
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void CDebugStack::_TraceAssert(int iLine, LPTSTR pFilename, LPTSTR pCondition)
{
    // nb: TRUE --> asserts always displayed
    _Trace(TRUE, TEXT("Assert failed: \"%s\""), pCondition);
    _Trace(TRUE, TEXT("File: %s, Line %d"), pFilename, iLine);

    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
        DebugBreak();
}


/*-----------------------------------------------------------------------------
/ ~CDebugStackHolder
/ ------------------
/   Free any DebugStack objects that exist
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
int CALLBACK
_DeleteCB(LPVOID pVoid, LPVOID /*pData*/)
{
    PDEBUGSTACK pDebugStack = (PDEBUGSTACK)pVoid;
    if (pDebugStack)
    {
        //pDebugStack->_Trace(TRUE, TEXT("~CDebugStackHolder destroying DebugStack"));
        delete pDebugStack;
    }
    return 1;
}

CDebugStackHolder::~CDebugStackHolder()
{
    if (m_bCSInited)
    {
        EnterCriticalSection(&m_csStackList);

        if (NULL != m_hDebugStackList)
        {
            DPA_DestroyCallback(m_hDebugStackList, _DeleteCB, NULL);
            m_hDebugStackList = NULL;
        }

        LeaveCriticalSection(&m_csStackList);
        DeleteCriticalSection(&m_csStackList);
    }
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Add
/ ----------------------
/   Saves the DebugStack object in a list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Add(PDEBUGSTACK pDebugStack)
{
    if (m_bCSInited)
    {
        EnterCriticalSection(&m_csStackList);

        if (NULL == m_hDebugStackList)
            m_hDebugStackList = DPA_Create(4);

        if (NULL != m_hDebugStackList)
            DPA_AppendPtr(m_hDebugStackList, pDebugStack);

        LeaveCriticalSection(&m_csStackList);
    }
}


/*-----------------------------------------------------------------------------
/ CDebugStackHolder::Remove
/ -------------------------
/   Removes the DebugStack object from the list
/
/ In:
/   PDEBUGSTACK pointer to the thread's debug stack object
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void
CDebugStackHolder::Remove(PDEBUGSTACK pDebugStack)
{
    if (m_bCSInited)
    {
        EnterCriticalSection(&m_csStackList);

        if (NULL != m_hDebugStackList)
        {
            int iStack = DPA_GetPtrIndex(m_hDebugStackList, pDebugStack);

            if (-1 != iStack)
                DPA_DeletePtr(m_hDebugStackList, iStack);
        }

        LeaveCriticalSection(&m_csStackList);
    }
}


/*-----------------------------------------------------------------------------
/ GetThreadStack
/ --------------
/   Create (if necessary) and return the per-thread debug stack object.
/
/ In:
/   -
/
/ Out:
/   PDEBUGSTACK pointer to the thread's debug stack object
/----------------------------------------------------------------------------*/
PDEBUGSTACK GetThreadStack()
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return NULL;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (!pDebugStack)
    {
        pDebugStack = new CDebugStack;
        TlsSetValue(g_tlsDebug, pDebugStack);

        if (!g_pStackHolder)
        {
            g_pStackHolder = new CDebugStackHolder;
            if (!g_pStackHolder->Initialize())
            {
                delete g_pStackHolder;
                g_pStackHolder = NULL;
            }
        }

        if (g_pStackHolder)
            g_pStackHolder->Add(pDebugStack);
    }

    return pDebugStack;
}
    

/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask)
{
    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromRegKey
/ ------------------------
/   Pick up the TraceMask value from the given registry key and
/   set the trace mask using that.
/
/ In:
/   hkRoot = handle of open key
/   pszSubKey = name of subkey to open
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey)
{
    DWORD dwTraceMask = 0;
    DWORD cbTraceMask = sizeof(dwTraceMask);
    SHRegGetValue(hkRoot, pszSubKey, TEXT("TraceMask"), SRRF_RT_DWORD, NULL, &dwTraceMask, &cbTraceMask);
    DoTraceSetMask(dwTraceMask);
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromCLSID
/ -----------------------
/   Pick up the TraceMask value from the given CLSID value and
/   set the trace mask using that.
/
/ In:
/   rCLSID = CLSID to query the value from
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID)
{
    TCHAR szClsidKey[48] = TEXT("CLSID\\");
    if (SHStringFromGUID(rCLSID, szClsidKey + 6, ARRAYSIZE(szClsidKey) - 6))
        DoTraceSetMaskFromRegKey(HKEY_CLASSES_ROOT, szClsidKey);
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceEnter(dwMask, pName);
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceLeave(void)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceLeave();
}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pszFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTrace(LPCTSTR pszFormat, ...)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();
    va_list va;

    if (pDebugStack)
    {
        va_start(va, pszFormat);
        pDebugStack->_vTrace(FALSE, pszFormat, &va);
        va_end(va);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceGUID(pPrefix, rGUID);
}


/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceAssert(int iLine, LPTSTR pFilename, LPTSTR pCondition)
{
    PDEBUGSTACK pDebugStack = GetThreadStack();

    if (pDebugStack)
        pDebugStack->_TraceAssert(iLine, pFilename, pCondition);
}


/*-----------------------------------------------------------------------------
/ DebugThreadDetach
/ DebugProcessAttach
/ DebugProcessDetach
/ -------------
/   These must be called from DllMain
/
/ In:
/   -
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DebugThreadDetach(void)
{
    PDEBUGSTACK pDebugStack;

    if (0xffffffffL == g_tlsDebug)
        return;

    pDebugStack = (PDEBUGSTACK)TlsGetValue(g_tlsDebug);

    if (pDebugStack)
    {
        if (g_pStackHolder)
            g_pStackHolder->Remove(pDebugStack);

        delete pDebugStack;
        TlsSetValue(g_tlsDebug, NULL);
    }
}

void DebugProcessAttach(void)
{
    g_tlsDebug = TlsAlloc();
}

void DebugProcessDetach(void)
{
    DebugThreadDetach();

    if (NULL != g_pStackHolder)
    {
        delete g_pStackHolder;
        g_pStackHolder = NULL;
    }

    if (0xffffffffL != g_tlsDebug)
    {
        TlsFree(g_tlsDebug);
        g_tlsDebug = 0xffffffffL;
    }
}


#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __debug_h
#define __debug_h

/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at build time).
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask);
void DoTraceSetMaskFromRegKey(HKEY hkRoot, LPCTSTR pszSubKey);
void DoTraceSetMaskFromCLSID(REFCLSID rCLSID);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename, LPTSTR pCondition);


/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#ifdef DEBUG

void DebugThreadDetach(void);           // optional
void DebugProcessAttach(void);          // required
void DebugProcessDetach(void);          // required

#define TraceSetMask(dwMask)            DoTraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz) DoTraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)   DoTraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)          DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave                      DoTraceLeave

#define Trace(x)                        DoTrace x
#define TraceMsg(s)                     DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)             DoTraceGUID(TEXT(s), rGUID)

#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__), TEXT(#x)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = (hr); if (FAILED(__hr)) Trace((TEXT("Failed (%08x)"), __hr)); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return (value); }

#else   // !DEBUG

#define DebugThreadDetach()
#define DebugProcessAttach()
#define DebugProcessDetach()

#define TraceSetMask(dwMask)
#define TraceSetMaskFromRegKey(hk, psz)
#define TraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)
#define TraceLeave()

#define Trace(x)
#define TraceMsg(s)
#define TraceGUID(s, rGUID)

#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return (hr); }
#define TraceLeaveVoid()        { return; }
#define TraceLeaveValue(value)  { return (value); }

#endif  // DEBUG


#endif  // __debug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\eventlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       eventlog.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "eventlog.h"

CEventLog::~CEventLog(
    void
    )
{
    Close();
}

//
// Register the specified event source.
// Note that the registry entries must already exist.
// HKLM\System\CurrentControlSet\Services\EventLog\Application\<pszEventSource>
//     Requires values "EventMessageFile" and "TypesSupported".
//        
HRESULT
CEventLog::Initialize(
    LPCTSTR pszEventSource
    )
{
    if (NULL != m_hLog)
    {
        return S_FALSE;
    }

    HRESULT hr = NOERROR;
    m_hLog = RegisterEventSource(NULL, pszEventSource);
    if (NULL == m_hLog)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//
// Deregister the event source.
//
void
CEventLog::Close(
    void
    )
{
    if (NULL != m_hLog)
    {
        DeregisterEventSource(m_hLog);
        m_hLog = NULL;
    }
}


//
// Report an event.  No replaceable parameters explicitly specified.
// If msg string contains replaceable parameters, use Push() to 
// build list of replacement strings.
//
HRESULT
CEventLog::ReportEvent(
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,    // [optional]
    LPVOID pvRawData,  // [optional]
    DWORD cbRawData    // [optional]
    )
{
    if (NULL == m_hLog)
        return E_FAIL;

    BOOL bResult = FALSE;
    HRESULT hr = NOERROR;

    if (!::ReportEvent(m_hLog,
                       wType,
                       wCategory,
                       dwEventID,
                       lpUserSid,
                       (WORD)m_rgstrText.Count(),
                       cbRawData,
                       m_rgstrText,
                       pvRawData))
    {
        //
        // Special-case ERROR_IO_PENDING.  ::ReportEvent will fail with
        // this error code even when it succeeds.  Don't know exactly why
        // but it does.  Treat this as success so we don't get unnecessary
        // debugger output.
        //
        DWORD dwError = GetLastError();
        if (ERROR_IO_PENDING != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    m_rgstrText.Clear();

    return hr;
}


            

//
// Push an HRESULT value onto the stack of replacment strings.
//
void 
CEventLog::Push(
    HRESULT hr, 
    eFmt fmt
    )
{
    if (eFmtSysErr == fmt)
    {
        LPTSTR pszBuffer = NULL;
        int cchLoaded = ::FormatSystemError(&pszBuffer, HRESULT_CODE(hr));
        if (NULL != pszBuffer)
        {
            if (0 != cchLoaded)
            {
                m_rgstrText.Append(pszBuffer);
            }
            LocalFree(pszBuffer);
        }
    }
    else
    {
        TCHAR szNumber[40];
        wnsprintf(szNumber, ARRAYSIZE(szNumber), eFmtDec == fmt ? TEXT("%d") : TEXT("0x%08X"), hr);
        m_rgstrText.Append(szNumber);
    }     
}

//
// Push a string onto the stack of replacement strings.
//
void 
CEventLog::Push(
    LPCTSTR psz
    )
{
    m_rgstrText.Append(psz);
}


CEventLog::CStrArray::CStrArray(
    void
    ) : m_cEntries(0)
{
    ZeroMemory(m_rgpsz, sizeof(m_rgpsz));
}


LPCTSTR
CEventLog::CStrArray::Get(
    int iEntry
    ) const
{
    TraceAssert(iEntry < m_cEntries);

    if (iEntry < m_cEntries)
        return m_rgpsz[iEntry];

    return NULL;
}


bool
CEventLog::CStrArray::Append(
    LPCTSTR psz
    )
{
    TraceAssert(m_cEntries < (ARRAYSIZE(m_rgpsz) - 1));

    if (m_cEntries < (ARRAYSIZE(m_rgpsz) - 1))
    {
        LONG cch = lstrlen(psz) + 1;
        LPTSTR pszNew = new TCHAR[cch];
        if (NULL != pszNew)
        {
            StringCchCopy(pszNew, cch, psz);
            m_rgpsz[m_cEntries++] = pszNew;
            return true;
        }
    }
    return false;
}


void
CEventLog::CStrArray::Destroy(
    void
    )
{
    for (int i = 0; i < ARRAYSIZE(m_rgpsz); i++)
    {
        delete[] m_rgpsz[i];
        m_rgpsz[i] = NULL;
    }
    m_cEntries = 0;
}



//-----------------------------------------------------------------------------
// CscuiEventLog member functions.
//-----------------------------------------------------------------------------
HRESULT 
CscuiEventLog::ReportEvent(
    WORD wType,
    DWORD dwEventID,
    int iMinLevel,
    PSID lpUserSid,
    LPVOID pvRawData,
    DWORD cbRawData
    )
{
    int iLevel = CConfig::GetSingleton().EventLoggingLevel();
    if (SUCCEEDED(m_log.Initialize(TEXT("Offline Files"))))
    {
        if (iLevel >= iMinLevel)
        {
            return m_log.ReportEvent(wType, 
                                     0, 
                                     dwEventID, 
                                     lpUserSid, 
                                     pvRawData, 
                                     cbRawData);
        }
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\dll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dll.cpp
//
//  Authors;
//    Jeff Saathoff (jeffreys)
//
//  Notes;
//    Core entry points for the DLL
//--------------------------------------------------------------------------
#include "pch.h"
#include <advpub.h>     // REGINSTALL
#include <shfusion.h>
#include "msgbox.h"


STDAPI COfflineFilesFolder_CreateInstance(REFIID riid, void **ppv);
STDAPI COfflineFilesOptions_CreateInstance(REFIID riid, void **ppv);


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG            g_cRefCount = 0;
HINSTANCE       g_hInstance = NULL;
CLIPFORMAT      g_cfShellIDList = 0;
HANDLE          g_heventTerminate = NULL;
HANDLE          g_hmutexAdminPin  = NULL;


typedef HRESULT (WINAPI *PFNCREATEINSTANCE)(REFIID, void **);

class CClassFactory : IClassFactory
{
    LONG m_cRef;
    PFNCREATEINSTANCE m_pfnCreateInstance;

public:
    CClassFactory(PFNCREATEINSTANCE pfnCreate) : m_cRef(1), m_pfnCreateInstance(pfnCreate) 
    {
        DllAddRef();
    }
    ~CClassFactory()
    {
        DllRelease();
    }

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#ifndef DEBUG
        DisableThreadLibraryCalls(hInstance);
#endif
        g_hInstance = hInstance; // instance handle...
        SHFusionInitializeFromModuleID(hInstance, 124);
        g_cfShellIDList = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        DebugProcessAttach();
        TraceSetMaskFromCLSID(CLSID_CscShellExt);
        break;

    case DLL_PROCESS_DETACH:
        DebugProcessDetach();
        
        if (NULL != g_heventTerminate)
            CloseHandle(g_heventTerminate);

        if (NULL != g_hmutexAdminPin)
            CloseHandle(g_hmutexAdminPin);

        SHFusionUninitialize();   
        break;

    case DLL_THREAD_DETACH:
        DebugThreadDetach();
        break;
    }

    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr;
    PFNCREATEINSTANCE pfnCreateInstance = NULL;

    *ppv = NULL;

    if (IsOS(OS_PERSONAL))
    {
        //
        // Offline Files is not available on 'Personal' SKU
        //
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (IsEqualCLSID(rclsid, CLSID_OfflineFilesOptions))
    {
        //
        // Post Win2000:
        // The Offline Files options page is always available
        // even if TS is in a mode incompatible with CSC.  In such
        // cases we'll display the Options page but replace the controls
        // with static text telling the user to place TS in a CSC-
        // compatible mode.  Once they do this, the text will be replaced
        // with the normal controls to manage CSC.
        //
        pfnCreateInstance = COfflineFilesOptions_CreateInstance;
    }
    else
    {
        //
        // The objects at the top here can be created even
        // when CSC is disabled. 
        //
        if (IsEqualCLSID(rclsid, CLSID_OfflineFilesFolder))
        {
            if (CConfig::GetSingleton().NoCacheViewer())
            {
                //
                // Policy can specify that the user not have access to the
                // Offline Files folder (aka viewer).  If this policy is set,
                // the user should have no way to get to this point through
                // the UI.  This check is a small dose of paranoia.
                //
                return CLASS_E_CLASSNOTAVAILABLE;
            }            
            pfnCreateInstance = COfflineFilesFolder_CreateInstance;
        }
        else
        {
            //
            // The objects below here require CSC.  That is, it
            // makes no sense for them to be created when CSC
            // is disabled.
            //
            if (!IsCSCEnabled())
                return E_FAIL;

            if (IsEqualCLSID(rclsid, CLSID_CscShellExt))
                pfnCreateInstance = CCscShellExt::CreateInstance;
            else if (IsEqualCLSID(rclsid, CLSID_CscUpdateHandler))
                pfnCreateInstance = CCscUpdate::CreateInstance;
            else if (IsEqualCLSID(rclsid, CLSID_CscVolumeCleaner))
                pfnCreateInstance = CCscVolumeCleaner::CreateInstance;
            else if (IsEqualCLSID(rclsid, CLSID_CscVolumeCleaner2))
                pfnCreateInstance = CCscVolumeCleaner::CreateInstance2;
            else
                return CLASS_E_CLASSNOTAVAILABLE;
        }
    }

    CClassFactory *pClassFactory = new CClassFactory(pfnCreateInstance);
    if (pClassFactory)
    {
        hr = pClassFactory->QueryInterface(riid, ppv);
        pClassFactory->Release();   // release initial ref
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefCount == 0 ? S_OK : S_FALSE);
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefCount);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefCount);
}

HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnRegInstall = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);
        if (pfnRegInstall)
            hr = pfnRegInstall(hModule, pszSection, NULL);
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultInstall");
}

STDAPI DllUnregisterServer(void)
{
    return CallRegInstall(g_hInstance, "DefaultUninstall");
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CClassFactory, IClassFactory),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_UNEXPECTED;

    *ppv = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if (m_pfnCreateInstance)
        hr = m_pfnCreateInstance(riid, ppv);

    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\enum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       enum.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shlwapip.h>   // QITAB, QISearch
#include <shsemip.h>    // ILFree(), etc

#include "folder.h"
#include "security.h"

//
// Create a single entry in the server status cache.
//
CServerStatusCache::CEntry::CEntry(
    LPCTSTR pszServer,
    DWORD dwStatus
    ) : m_pszServer(StrDup(pszServer)),
        m_dwStatus(dwStatus)
{
}


//
// Destroy a single entry in the server status cache.
//
CServerStatusCache::CEntry::~CEntry(
    void
    )
{
    if (NULL != m_pszServer)
    {
        LocalFree(m_pszServer);
    }
}



//
// Destroy the server status cache.
//
CServerStatusCache::~CServerStatusCache(
    void
    )
{
    if (NULL != m_hdpa)
    {
        //
        // Delete each entry in the DPA then destroy the
        // DPA itself.
        //
        int cEntries = DPA_GetPtrCount(m_hdpa);
        for (int i = 0; i < cEntries; i++)
        {
            delete (CEntry *)DPA_GetPtr(m_hdpa, i);
        }
        DPA_Destroy(m_hdpa);
    }
}

//
// Add a share's status to the cache.  We strip the UNC path to it's
// bare server name then add the status to the cache.  If there's
// no existing entry we just add it.  If there is an existing entry,
// we bitwise OR the status bits in with the existing entry.  This way
// the status of the server is the summation of the status of all
// it's shares.
//
bool 
CServerStatusCache::AddShareStatus(
    LPCTSTR pszShare, 
    DWORD dwShareStatus
    )
{
    bool bResult = true;
    TCHAR szServer[MAX_PATH];
    CEntry *pEntry = FindEntry(ServerFromUNC(pszShare, szServer, ARRAYSIZE(szServer)));

    if (NULL != pEntry)
    {
        //
        // Found existing server entry for this share.  Merge in the
        // status bits for this share.
        //
        pEntry->AddStatus(dwShareStatus);
    }
    else
    {
        //
        // No existing entry for this share's server.
        //
        if (NULL == m_hdpa)
        {
            //
            // No DPA exists yet.  Create one.
            // We delay creation of the DPA until we really need one.
            //
            m_hdpa = DPA_Create(8);
        }
        if (NULL != m_hdpa)
        {
            //
            // We have a DPA.  Create a new entry for this share's server
            // and add it to the DPA.
            //

            pEntry = new CEntry(szServer, dwShareStatus);
            if (NULL != pEntry)
            {
                if (!pEntry->IsValid() || -1 == DPA_AppendPtr(m_hdpa, pEntry))
                {
                    //
                    // One of the following happened:
                    //      1. Failure allocating server name in CEntry obj.
                    //      2. Failure adding CEntry obj ptr to DPA.
                    //
                    delete pEntry;
                    bResult = false;
                }
            }
        }
        else
        {
            bResult = false; // DPA creation failed.
        }
    }
    return bResult;
}


//
// Obtain the CSC status bits for a given server.
// This function assumes the pszUNC arg is a valid UNC path.
//
DWORD 
CServerStatusCache::GetServerStatus(
    LPCTSTR pszUNC
    )
{
    TCHAR szServer[MAX_PATH];
    
    CEntry *pEntry = FindEntry(ServerFromUNC(pszUNC, szServer, ARRAYSIZE(szServer)));
    if (NULL == pEntry)
    {
        //
        // No entry for this server.  Scan the CSC cache and pick up any new
        // servers added.  Since the lifetime of this server cache is only for a single
        // enumeration, we should have to do this only once.  However, if for some
        // reason, something gets added to the CSC cache while we're opening the viewer, 
        // this code path will pick up the new server entry.
        // 
        WIN32_FIND_DATA fd;
        DWORD dwStatus = 0;
        CCscFindHandle hFind = CacheFindFirst(NULL, &fd, &dwStatus, NULL, NULL, NULL);
        if (hFind.IsValid())
        {
            do
            {
                AddShareStatus(fd.cFileName, dwStatus);
            }
            while(CacheFindNext(hFind, &fd, &dwStatus, NULL, NULL, NULL));
        }
        //
        // Now that we have rescanned the CSC cache, try it again.
        //
        pEntry = FindEntry(szServer);
    }
    return pEntry ? pEntry->GetStatus() : 0;
}


//
// Find a single entry in the server cache.
// Assumes pszServer is a raw server name (not UNC).
// Returns NULL if no match found.
//
CServerStatusCache::CEntry *
CServerStatusCache::FindEntry(
    LPCTSTR pszServer
    )
{
    CEntry *pEntry = NULL;
    if (NULL != m_hdpa)
    {
        int cEntries = DPA_GetPtrCount(m_hdpa);
        for (int i = 0; i < cEntries; i++)
        {
            CEntry *pe = (CEntry *)DPA_GetPtr(m_hdpa, i);
            if (NULL != pe && 0 == lstrcmpi(pe->GetServer(), pszServer))
            {
                pEntry = pe;
                break;
            }
        }
    }
    return pEntry;
}


LPTSTR 
CServerStatusCache::ServerFromUNC(
    LPCTSTR pszShare, 
    LPTSTR pszServer, 
    UINT cchServer
    )
{
    LPTSTR pszReturn = pszServer; // Remember for return.

    cchServer--;  // Leave room for terminating nul.

    while(*pszShare && TEXT('\\') == *pszShare)
        pszShare++;

    while(*pszShare && TEXT('\\') != *pszShare && cchServer--)
        *pszServer++ = *pszShare++;

    *pszServer = TEXT('\0');
    return pszReturn;
}



STDMETHODIMP COfflineFilesEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(COfflineFilesEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) COfflineFilesEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) COfflineFilesEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

COfflineFilesEnum::COfflineFilesEnum(DWORD grfFlags, COfflineFilesFolder *pfolder)
{
    _cRef = 1;

    //
    // The minimum size of the buffer must be MAX_PATH.
    // The enumeration code is designed to grow it as needed.
    //
    _cchPathBuf = MAX_PATH;
    _pszPath    = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * _cchPathBuf);
    if (NULL != _pszPath)
        *_pszPath = TEXT('\0');
    else
        _cchPathBuf = 0;

    _grfFlags = grfFlags,
    _pfolder = pfolder;
    _pfolder->AddRef();
    _dwServerStatus = 0;

    _hdsaFolderPathInfo = DSA_Create(sizeof(FolderPathInfo), 10);

    //
    // Determine if we should be showing system and/or hidden files.
    //
    _bShowHiddenFiles      = boolify(ShowHidden());
    _bShowSuperHiddenFiles = boolify(ShowSuperHidden());
    _bUserIsAdmin          = boolify(IsCurrentUserAnAdminMember());

    DllAddRef();
}

COfflineFilesEnum::~COfflineFilesEnum()
{
    if (_pfolder)
        _pfolder->Release();

    Reset();
    if (_hdsaFolderPathInfo)
    {
        int cPaths = DSA_GetItemCount(_hdsaFolderPathInfo);
        FolderPathInfo fpi;
        for (int i = 0; i < cPaths; i++)
        {
            if (DSA_GetItem(_hdsaFolderPathInfo, i, &fpi) && NULL != fpi.pszPath)
                LocalFree(fpi.pszPath);
        }
        DSA_Destroy(_hdsaFolderPathInfo);
    }
    if (NULL != _pszPath)
        LocalFree(_pszPath);

    DllRelease();
}

//
// Since we're not throwing exceptions, clients must call this after ctor 
// to verify allocations succeeded.
// 
bool
COfflineFilesEnum::IsValid(
    void
    ) const
{
    return (NULL != _hdsaFolderPathInfo) && (NULL != _pszPath);
}


bool 
COfflineFilesEnum::PopFolderPathInfo(
    FolderPathInfo *pfpi
    )
{ 
    bool bResult = false;
    TraceAssert(NULL != _hdsaFolderPathInfo);

    int iItem = DSA_GetItemCount(_hdsaFolderPathInfo) - 1;
    if ((0 <= iItem) && DSA_GetItem(_hdsaFolderPathInfo, iItem, pfpi))
    {
        DSA_DeleteItem(_hdsaFolderPathInfo, iItem);
        bResult = true;
    }
    return bResult;
}


//
// Build complete path to folder in a heap allocation and push it onto
// stack of saved folder paths.
// Returns false if memory can't be allocated for path.
//
bool
COfflineFilesEnum::SaveFolderPath(
    LPCTSTR pszRoot,
    LPCTSTR pszFolder
    )
{
    bool bResult = false;

    FolderPathInfo fpi;
    //
    // Length is "root" + '\' + "folder" + <nul>
    //
    fpi.cchPath = lstrlen(pszRoot) + lstrlen(pszFolder) + 2;
    fpi.pszPath = (LPTSTR)LocalAlloc(LPTR, MAX(fpi.cchPath, DWORD(MAX_PATH)) * sizeof(TCHAR));

    if (NULL != fpi.pszPath)
    {
        if (PathCombine(fpi.pszPath, pszRoot, pszFolder) && PushFolderPathInfo(fpi))
            bResult = true;
        else
            LocalFree(fpi.pszPath);
    }

    return bResult;
}


//
// Increases the size of the _pszPath buffer by a specified amount.
// Original contents of buffer ARE NOT preserved.  
// Returns:
//      S_FALSE       - _pszPath buffer was large enough.  Not modified.
//      S_OK          - _pszPath points to new bigger buffer.
//      E_OUTOFMEMORY - _pszPath points to original unmodified buffer.
//
HRESULT
COfflineFilesEnum::GrowPathBuffer(
    INT cchRequired,
    INT cchExtra
    )
{
    HRESULT hres = S_FALSE;
    if (_cchPathBuf <= cchRequired)
    {
        LPTSTR pszNewBuf = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cchRequired + cchExtra));
        if (NULL != pszNewBuf)
        {
            if (NULL != _pszPath)
                LocalFree(_pszPath);
            _pszPath    = pszNewBuf;
            _cchPathBuf = cchRequired + cchExtra;
            hres = S_OK;
        }
        else
        {
            hres = E_OUTOFMEMORY; // Failure.  Orig buffer is left intact.
        }
    }
    return hres;
}


//
// Determine if user has access to view this file.
//
bool
COfflineFilesEnum::UserHasAccess(
    const CscFindData& cscfd
    )
{
    return _bUserIsAdmin || 
           CscAccessUser(cscfd.dwStatus) || 
           CscAccessGuest(cscfd.dwStatus);
}


//
// Centralize any item-exclusion logic in a single function.
//
bool 
COfflineFilesEnum::Exclude(
    const CscFindData& cscfd
    )
{
    return ((FILE_ATTRIBUTE_DIRECTORY & cscfd.fd.dwFileAttributes) ||
            (FLAG_CSC_COPY_STATUS_LOCALLY_DELETED & cscfd.dwStatus) ||
           ((FILE_ATTRIBUTE_HIDDEN & cscfd.fd.dwFileAttributes) && !_bShowHiddenFiles) ||
           (IsHiddenSystem(cscfd.fd.dwFileAttributes) && !_bShowSuperHiddenFiles) ||
           !UserHasAccess(cscfd));
}


//
// If a folder is hidden and the current shell setting says to not show hidden files,
// don't enumerate any children of a folder.  Likewise for super hidden files and the
// "show super hidden files" setting.
//
bool
COfflineFilesEnum::OkToEnumFolder(
    const CscFindData& cscfd
    )
{
    return (_bShowHiddenFiles || (0 == (FILE_ATTRIBUTE_HIDDEN & cscfd.fd.dwFileAttributes))) &&
           (_bShowSuperHiddenFiles || !IsHiddenSystem(cscfd.fd.dwFileAttributes));
}



HRESULT COfflineFilesEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, 
                                ULONG *pceltFetched)
{
    HRESULT hres;
    CscFindData cscfd;
    ULONG celtEnumed;

    //
    // If you've hit one of these asserts, you didn't call IsValid()
    // before using the enumerator.
    //
    TraceAssert(NULL != _pszPath);
    TraceAssert(NULL != _hdsaFolderPathInfo);

    //
    // This label is used to restart the enum if an item is excluded.
    //
enum_start:
    hres       = S_FALSE;
    celtEnumed = 0;
    ZeroMemory(&cscfd, sizeof(cscfd));

    if (!_hEnumShares.IsValid())
    {
        //
        // First time through.
        // Enumerate shares and files until we find a folder or file.
        //
        _hEnumShares = CacheFindFirst(NULL, &cscfd);
        if (_hEnumShares.IsValid())
        {
            _dwServerStatus = _ServerStatusCache.GetServerStatus(cscfd.fd.cFileName);
            do
            {
                //
                // Buffer attached to _pszPath is guaranteed to be at least
                // MAX_PATH so it's safe to copy cFileName[].
                //
                StringCchCopy(_pszPath, _cchPathBuf, cscfd.fd.cFileName);
                _hEnum = CacheFindFirst(_pszPath, &cscfd);
                if (_hEnum.IsValid())
                {
                    celtEnumed = 1;
                }
            }
            while(0 == celtEnumed && CacheFindNext(_hEnumShares, &cscfd));
        }
    }
    else
    {
        if (_hEnum.IsValid())
        {
            if (CacheFindNext(_hEnum, &cscfd))
            {
                //
                // Most common case.  Got next file in current folder.
                //
                celtEnumed = 1;
            }
            else
            {
                //
                // Enumeration exhausted for this folder.  If we have folder paths
                // saved on the stack, keep popping them until we find one containing
                // at least one file or folder.
                //
                FolderPathInfo fpi;
                while(SUCCEEDED(hres) && 0 == celtEnumed && PopFolderPathInfo(&fpi) && NULL != fpi.pszPath)
                {
                    _hEnum = CacheFindFirst(fpi.pszPath, &cscfd);
                    if (_hEnum.IsValid())
                    {
                        //
                        // The popped folder path is the only opportunity we have
                        // where a string could overflow the temp _pszPath buffer.
                        // If necesary, grow the buffer to hold the path.  Add
                        // room for an extra 100 chars to minimize re-growth.
                        // Buffer is not altered if required path length is 
                        // less than _cchPathBuf.
                        //
                        if (FAILED(GrowPathBuffer(fpi.cchPath, 100)))
                            hres = E_OUTOFMEMORY;

                        if (SUCCEEDED(hres))
                        {
                            StringCchCopy(_pszPath, _cchPathBuf, fpi.pszPath);
                            celtEnumed = 1;
                        }
                    }
                    LocalFree(fpi.pszPath);
                }
                if (SUCCEEDED(hres))
                {
                    while(0 == celtEnumed && CacheFindNext(_hEnumShares, &cscfd))
                    {
                        //
                        // No more saved folder paths.  This share is exhausted.
                        // Enumerate next share.  If next is empty, keep enumerating
                        // shares until we find one with content.  The buffer
                        // attached to _pszPath is guaranteed to be at least MAX_PATH
                        // so it's always safe to copy cFileName[].
                        //
                        _dwServerStatus = _ServerStatusCache.GetServerStatus(cscfd.fd.cFileName);
                        StringCchCopy(_pszPath, _cchPathBuf, cscfd.fd.cFileName);
                        _hEnum = CacheFindFirst(_pszPath, &cscfd);
                        if (_hEnum.IsValid())
                        {
                            celtEnumed = 1;
                        }
                    }
                }
            }
        }
    }

    if (celtEnumed)
    {
        if (FILE_ATTRIBUTE_DIRECTORY & cscfd.fd.dwFileAttributes)
        {
            if (OkToEnumFolder(cscfd))
            {
                //
                // Save the folder path on a stack.  This is how we enumerate
                // the cache item hierarcy as a flat list.  We'll pop these off
                // the stack on future calls to Next() when all children of the
                // current folder have been enumerated.
                //
                if (!SaveFolderPath(_pszPath, cscfd.fd.cFileName))
                {
                    //
                    // Path not saved.  Insufficient heap memory. 
                    // Abort the enumeration.
                    //
                    hres = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hres))
        {
            if (!Exclude(cscfd))
            {
                //
                // An IDList is composed of a fixed-length part and a variable-length
                // path+name buffer.
                // The path+name variable-length buffer is formatted as follows:
                //
                // dir1\dir2\dir3<nul>name<nul>
                //
                TCHAR szUNC[MAX_PATH];
                if (PathCombine(szUNC, _pszPath, cscfd.fd.cFileName))
                {
                    hres = COfflineFilesFolder::OLID_CreateFromUNCPath(szUNC,
                                                                       &cscfd.fd,
                                                                       cscfd.dwStatus,
                                                                       cscfd.dwPinCount,
                                                                       cscfd.dwHintFlags,
                                                                       _dwServerStatus,
                                                                       (LPOLID *)&rgelt[0]);

                }
            }
            else
            {
                //
                // This item is excluded from the enumeration.  Restart.
                // I normally don't like goto's but doing this with a loop
                // is just plain harder to understand.  The goto is quite
                // appropriate in this circumstance.
                //
                goto enum_start;
            }
        }
    }

    if (pceltFetched)
        *pceltFetched = celtEnumed;
    return hres;
}

HRESULT COfflineFilesEnum::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT COfflineFilesEnum::Reset()
{
    _hEnum.Close();
    _hEnumShares.Close();
    return S_OK;
}

HRESULT COfflineFilesEnum::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\filelist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filelist.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCVIEW_FILELIST_H
#define _INC_CSCVIEW_FILELIST_H
//////////////////////////////////////////////////////////////////////////////
/*  File: filelist.h

    Description: Simplifies the transmission of a list of share and 
        associated file names between components of the CSC UI.  See
        description further below for details.

        Classes:

            CscFilenameList
            CscFilenameList::HSHARE
            CscFilenameList::ShareIter
            CscFilenameList::FileIter

        Note:  This module was written to be used by any part of the CSCUI,
               not just the viewer.  Therefore, I don't assume that the
               new operator will throw an exception on allocation failures.
               I don't like all the added code to detect allocation failures
               but it's not reasonable to expect code in the other components
               to become exception-aware with respect to "new" failures.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    11/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif

//
// This set of classes is designed to transfer a list of network share
// names and network file names between components of the CSC UI
// (i.e. wizard, viewer, onestop etc).  Data is transferred through
// a formatted byte buffer that is essentially an opaque blob
// to both the sender and receiver.  The class CscFilenameList
// was created to prevent the sender and receiver from having
// to understand the buffer format.  The buffer is formatted as follows:
//
// +----------------+---------------------------------+
// | <namelist hdr> |  <share descriptors>            |
// +----------------+---------------------------------+
// |                                                  |
// |                                                  |
// |         <share and file names>                   |
// |                                                  |
// |                                                  |
// +--------------------------------------------------+
//
//
// Where: <namelist hdr> is a single block of type CSC_NAMELIST_HDR.
//              This block describes the size of the buffer and the
//              share count.
//
//        <share descriptors> is an array of type CSC_NAMELIST_SHARE_DESC,
//              one for each share in the buffer.  Each share descriptor
//              describes the offset to the share name, the offset
//              to the first file name and the number of file names
//              in the buffer.  All offsets are byte offsets from the
//              start of the buffer.
//
//        <share and file names> is an array of TCHARs containing the
//              names of the shares and files stored in the buffer.
//              Each name string is nul-terminated.
//
//
// The following outline describes how I see someone using this feature:
//
//  1. Instantiate a CscFilenameList object (no ctor arguments).
//  2. Call AddShare() whenever a share is to be added.
//  3. Call AddFile() whenever a file is to be added.  Note that
//     saving the HSHARE returned by AddShare() can make file name addition
//     more efficient as it eliminates the need for an internal lookup
//     of the associated share name each time a file name is added.
//
//      i.e.:  CscFilenameList fnl;
//             HSHARE hShare = fnl.AddShare("\\\\server\\share");
//             fnl.AddFile(hShare, "foo.txt");
//             fnl.AddFile(hShare, "bar.txt");
//
//             is more efficient than...
//
//             CscFilenameList fnl;
//             fnl.AddFile("\\\\server\\share", "foo.txt");
//             fnl.AddFile("\\\\server\\share", "bar.txt");
//
//             ...which is slightly more efficient than...
//
//             CscFilenameList fnl;
//             fnl.AddFile("\\\\server\\share\\foo.txt");
//             fnl.AddFile("\\\\server\\share\\bar.txt");
//
//             ...although all 3 methods are supported.
//
//  4. Once all shares and files are added, call CreateListBuffer() to retrieve
//     the information formatted in a byte buffer.  The buffer is allocated
//     on the heap.
//  5. Pass the buffer address to the desired program component.
//  6. The receiving component instantiates a CscFilenameList object passing
//     the address of the buffer to the ctor.  This initializes the namelist
//     so that it merely references the information in the buffer rather than
//     duplicating the name information in memory.  Note that the buffer must
//     remain in memory while this namelist object is in use.
//  7. The receiving component creates a Share Iterator by calling
//     CreateShareIterator().  The returned iterator enumerates each of the
//     shares contained in the namelist object.  
//  8. The receiving component enumerates the shares (receiving an HSHARE) for 
//     each.  To get a share's name string, call GetShareName() passing the
//     HSHARE for the desired share.
//  9. For each share, the recieving component creates a File Iterator by
//     calling CreateFileIterator() passing the HSHARE for the desired share.
//     The returned iterator enumerates each of the file names associated 
//     with the share.
// 10. Once the operation is complete, FreeListBuffer is called to delete
//     the byte buffer created by CreateListBuffer().
//
//
// The following example illustrates this process:
//
//
//  void Foo(void)
//  {
//      CscFilenameList         fnl;     // Namelist object.
//      CscFilenameList::HSHARE hShare;  // Share handle.
//
//      // Add a share and some files
//
//      fnl.AddShare(TEXT("\\\\worf\\ntspecs"), &hShare);
//      fnl.AddFile(hShare, TEXT("foo.txt"));
//      fnl.AddFile(hShare, TEXT("bar.txt"));
//
//      // Add another share and some files.
//
//      fnl.AddShare(TEXT("\\\\msoffice\\products"), &hShare);
//      fnl.AddFile(hShare, TEXT("word.doc"));
//      fnl.AddFile(hShare, TEXT("excel.doc"));
//      fnl.AddFile(hShare, TEXT("powerpoint.doc"));
//      fnl.AddFile(hShare, TEXT("access.doc"));
//
//      // Add another share and more files using the less-efficient
//      // method.  It's valid, just less efficient.
//
//      fnl.AddFile(TEXT("\\\\performance\\poor"), TEXT("turtle.doc"));
//      fnl.AddFile(TEXT("\\\\performance\\poor"), TEXT("snail.doc"));
//      fnl.AddFile(TEXT("\\\\performance\\poor"), TEXT("inchworm.doc"));
//
//      // Create the byte buffer from the namelist and pass it to
//      // the receiving component.
//
//      LPBYTE pbBuffer = fnl.CreateListBuffer();
//      Bar(pbBuffer);
//
//      // Delete the byte buffer when we're done.
//
//      FreeListBuffer(pbBuffer);
//  }
//
//
//  void Bar(LPBYTE pbBuffer)
//  {
//      // Create a new namelist object from the byte buffer.
//
//      CscFileNameList fnl(pbBuffer);
//
//      // Create a share iterator.
//      
//      CscFilenameList::ShareIter si = fnl.CreateShareIterator();
//      CscFilenameList::HSHARE hShare;
//
//      // Iterate over the shares in the namelist collection.
//
//      while(si.Next(&hShare))
//      {
//          _tprintf(TEXT("Share..: \"%s\"\n"), fnl.GetShareName(hShare));
//
//          // Create a file iterator for the share.
//
//          CscFilenameList::FileIter fi = fl.CreateFileIterator(hShare);
//          LPCTSTR pszFile;
//
//          // Iterate over the filenames associated with the share.
//
//          while(pszFile = fi.Next())
//          {
//              _tprintf(TEXT("\tFile..: \"%s\"\n"), pszFile);
//          }
//      }
//  }
//
//  [brianau - 11/28/97]
//

//
// Namelist byte buffer header block (offset 0).
//
typedef struct 
{
    DWORD cbSize;
    DWORD cShares;

} CSC_NAMELIST_HDR, *PCSC_NAMELIST_HDR;

//
// Namelist byte buffer share descriptor block.  Array (one per share)
// starting at offset 12 (immediately following the header block).
//
typedef struct
{
    DWORD cbOfsShareName;
    DWORD cbOfsFileNames;
    DWORD cFiles;

} CSC_NAMELIST_SHARE_DESC, *PCSC_NAMELIST_SHARE_DESC;



class CscFilenameList
{
    private:
        class Share;

    public:
        class ShareIter;
        class FileIter;
        class HSHARE;

        // --------------------------------------------------------------------
        // CscFilenameList::HSHARE
        //
        // Share "handle" to communicate the identity of an internal "share"
        // object with the client without exposing the share object directly.
        // The client just knows an HSHARE.  Clients get one as the return
        // value from AddShare().
        //
        class HSHARE
        {
            public:
                HSHARE(void);
                HSHARE(const HSHARE& rhs);
                HSHARE& operator = (const HSHARE& rhs);
                ~HSHARE(void) { }

                bool operator ! ()
                    { return NULL == m_pShare; }

            private:
                //
                // Private so only we can create meaninful HSHARE objects.
                //
                HSHARE(Share *pShare)
                    : m_pShare(pShare) { }

                Share *m_pShare;  // ptr to the actual share object.

                friend class CscFilenameList;
                friend class ShareIter;
        };

        // --------------------------------------------------------------------
        // CscFilenameList::FileIter
        //
        // Iterator for enumerating each file name associated with a 
        // particular share. Clients create one using CreateFileIterator().
        //
        class FileIter
        {
            public:
                FileIter(void);
                ~FileIter(void) { }
                FileIter(const FileIter& rhs);
                FileIter& operator = (const FileIter& rhs);

                LPCTSTR Next(void);
                void Reset(void);

            private:
                FileIter(const Share *pShare);

                const Share *m_pShare; // ptr to associated share object.
                int          m_iFile;  // current file iteration index.

                friend class CscFilenameList;
        };

        // --------------------------------------------------------------------
        // CscFilenameList::ShareIter
        //
        // Iterator for enumerating each share in the namelist collection.
        // Clients create one using CreateShareIterator().
        //
        class ShareIter
        {
            public:
                ShareIter(void);
                ShareIter(const CscFilenameList& fnl);
                ~ShareIter(void) { }
                ShareIter(const ShareIter& rhs);
                ShareIter& operator = (const ShareIter& rhs);

                bool Next(HSHARE *phShare);
                void Reset(void);

            private:
                const CscFilenameList *m_pfnl; // ptr to filename collection obj.
                int   m_iShare;                // current share iteration index.
        };

        // --------------------------------------------------------------------
        // Namelist object public interface.
        //
        // Create an empty namelist collection ready to accept share and
        // file names.
        //
        CscFilenameList(void);
        //
        // Create a namelist collection and initialize it with the contents
        // of a byte buffer created by CreateListBuffer().  
        // If bCopy is false, the subsequent namelist object merely references 
        // the data in the byte buffer rather than duplicating the namestrings 
        // in memory.  If bCopy is true, name strings are created as if the
        // names had been added using AddShare() and AddFile().  Note that
        // additional share and file name strings may be added at any time.
        // However, they are added to internal structures and not to the 
        // byte buffer.  Call CreateListBuffer() to add them to a new byte
        // buffer.  
        //
        CscFilenameList(PCSC_NAMELIST_HDR pbNames, bool bCopy);
        ~CscFilenameList(void);
        //
        // Add a share name to the collection.  Does not create a 
        // duplicate share entry if one already exists.  Returns a handle
        // the a share object.
        //
        bool AddShare(LPCTSTR pszShare, HSHARE *phShare, bool bCopy = true);
        //
        // Add a file for a share.  More efficient to use the first
        // version taking a share handle rather than a share name.
        //
        bool AddFile(HSHARE& hShare, LPCTSTR pszFile, bool bDirectory = false, bool bCopy = true);
        bool AddFile(LPCTSTR pszShare, LPCTSTR pszFile, bool bDirectory = false, bool bCopy = true);
        bool AddFile(LPCTSTR pszFullPath, bool bDirectory = false, bool bCopy = true);
        bool RemoveFile(HSHARE& hShare, LPCTSTR pszFile);
        bool RemoveFile(LPCTSTR pszShare, LPCTSTR pszFile);
        bool RemoveFile(LPCTSTR pszFullPath);
        //
        // Retrieve miscellaneous information about the collection.
        //
        int GetShareCount(void) const;
        int GetFileCount(void) const;
        LPCTSTR GetShareName(HSHARE& hShare) const;
        int GetShareFileCount(HSHARE& hShare) const;
        bool GetShareHandle(LPCTSTR pszShare, HSHARE *phShare) const;
        //
        // Determine if a given share or file exists in the collection.
        // For the FileExists() functions, if bExact is true (the default)
        // only exact character-for-character matches return true.  If
        // bExact is false, the filename "\\server\share\dirA\dirB\foo.txt"
        // will match if any of the following four entries exist in the
        // namelist:
        //
        //     "\\server\share\dirA\dirB\foo.txt"  (exact match)
        //     "\\server\share\*"                  (wildcard match)
        //     "\\server\share\dirA\*"             (wildcard match)
        //     "\\server\share\dirA\dirB\*"        (wildcard match)
        //
        bool ShareExists(LPCTSTR pszShare) const;
        bool FileExists(HSHARE& hShare, LPCTSTR pszFile, bool bExact = true) const;
        bool FileExists(LPCTSTR pszShare, LPCTSTR pszFile, bool bExact = true) const;
        bool FileExists(LPCTSTR pszFullPath, bool bExact = true) const;

        //
        // Create iterators for enumerating collection contents.
        //
        ShareIter CreateShareIterator(void) const;
        FileIter CreateFileIterator(HSHARE& hShare) const;
        //
        // Create/free a byte buffer containing the contents of the collection.
        //
        PCSC_NAMELIST_HDR CreateListBuffer(void) const;
        static void FreeListBuffer(PCSC_NAMELIST_HDR pbNames);
        //
        // Check after initializing object from byte buffer.
        //
        bool IsValid(void) const
            { return m_bValid; }

#ifdef FILELIST_TEST
        void Dump(void) const;
        void DumpListBuffer(PCSC_NAMELIST_HDR pbBuffer) const;
#endif // FILELIST_TEST


    private:
        // --------------------------------------------------------------------
        // CscFilenameList::NamePtr
        //
        // Simple wrapper around a string pointer to add a notion of "ownership".
        // This lets us store a string address as either a pointer to dynamic
        // heap memory (that later must be freed) or the address of a string
        // in a character buffer owned by someone else (owner frees it if 
        // necessary).
        //
        class NamePtr
        {
            public:
                NamePtr(void)
                    : m_pszName(NULL), 
                      m_bOwns(false) { }

                NamePtr(LPCTSTR pszName, bool bCopy);
                ~NamePtr(void);

                NamePtr(NamePtr& rhs);
                NamePtr& operator = (NamePtr& rhs);

                bool IsValid(void) const
                    { return NULL != m_pszName; }

                operator LPCTSTR () const
                    { return m_pszName; }

            private:
                LPCTSTR m_pszName; // address of string.
                bool    m_bOwns;   // do we need to free it on destruction?

                friend class CscFilenameList;
                friend class Share;
        };


        // --------------------------------------------------------------------
        // CscFilenameList::Share
        //
        // Represents a share in the namelist collection.  It's really just
        // a convenient container for a share name and a list of file names
        // associated with the share.
        //
        class Share
        {
            public:
                Share(LPCTSTR pszShare, bool bCopy = true);
                ~Share(void);

                bool AddFile(LPCTSTR pszFile, bool bDirectory = false, bool bCopy = true);
                bool RemoveFile(LPCTSTR pszFile);

                int FileCount(void) const
                    { return m_cFiles; }

                int ByteCount(void) const
                    { return (m_cchShareName + m_cchFileNames) * sizeof(TCHAR); }

                int Write(LPBYTE pbBufferStart, 
                          CSC_NAMELIST_SHARE_DESC *pDesc, 
                          LPTSTR pszBuffer, 
                          int cchBuffer) const;

#ifdef FILELIST_TEST
                void Dump(void) const;
#endif // FILELIST_TEST

            private:
                int    m_cFiles;          // Cnt of files in share.
                int    m_cAllocated;      // Cnt of share ptrs allocated.
                int    m_cchShareName;    // Bytes req'd to hold share name.
                int    m_cchFileNames;    // Bytes req'd to hold file names.
                NamePtr m_pszShareName;    // Address of share name string.
                NamePtr *m_rgpszFileNames; // Array of ptrs to file name strings
                static int m_cGrow;       // File name array growth increment.

                int WriteFileNames(LPTSTR pszBuffer, int cchBuffer, DWORD *pcFilesWritten) const;
                int WriteName(LPTSTR pszBuffer, int cchBuffer) const;
                bool GrowFileNamePtrList(void);

                friend class CscFilenameList;
                friend class FileIter;
        };

        // --------------------------------------------------------------------
        // Namelist object private members.
        //
        int     m_cShares;    // How many shares in collection.
        int     m_cAllocated; // Allocated size of m_rgpShares[].
        Share **m_rgpShares;  // Dynamic array of ptrs to Share objects.
        bool    m_bValid;     // Ctor completion check.
        static int m_cGrow;   // How much to grow array when necessary.

        //
        // Prevent copy.
        //
        CscFilenameList(const CscFilenameList& rhs);
        CscFilenameList& operator = (const CscFilenameList& rhs);

        bool GrowSharePtrList(void);
        bool LoadFromBuffer(PCSC_NAMELIST_HDR pbBuffer, bool bCopy);

        void ParseFullPath(LPTSTR pszFullPath, 
                           LPTSTR *ppszShare, 
                           LPTSTR *ppszFile) const;

        static bool Compare(LPCTSTR pszTemplate, LPCTSTR pszFile, bool *pbExact);

        friend class ShareIter;
        friend class Share;
};

#endif // _INC_CSCVIEW_FILELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\filesize.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesize.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "filesize.h"
#include "util.h"
#include <resource.h>

//-----------------------------------------------------------------------------
// class FileSize
//-----------------------------------------------------------------------------
//
// Static array of file size "order" string IDs.
// These IDs identify the "%1 KB", "%1 MB", "%1 GB" resource strings.
//
int FileSize::m_rgiOrders[IDS_ORDER_EB - IDS_ORDER_BYTES + 1];

FileSize::FileSize(
    ULONGLONG ullSize
    ) : m_ullSize(ullSize)
{
    TraceAssert(IDS_ORDER_BYTES != 0);
    if (0 == m_rgiOrders[0])
    {
        //
        // Initialize the static array of file size "order" string IDs.
        //
        for (int i = IDS_ORDER_BYTES; i <= IDS_ORDER_EB; i++)
        {
            m_rgiOrders[i - IDS_ORDER_BYTES] = i;
        }
    }
}


//
// FileSize assignment.
//
FileSize& 
FileSize::operator = (
    const FileSize& rhs
    )
{
    if (this != &rhs)
    {
        m_ullSize = rhs.m_ullSize;
    }
    return *this;
}


//
// The following code for converting a file size value to a text
// string (i.e. "10.5 MB") was taken from shell32.dll so that file size
// values would match those displayed in shell views.  The code isn't
// my normal style but I left it "as is" so I wouldn't break it. [brianau]
//
const int MAX_INT64_SIZE        = 30;
const int MAX_COMMA_NUMBER_SIZE = MAX_INT64_SIZE + 10;

//
// Convert a ULONGLONG file size value to a text string.
//
void 
FileSize::CvtSizeToText(
    ULONGLONG n, 
    LPTSTR pszBuffer
    ) const
{
    TCHAR     szTemp[MAX_INT64_SIZE];
    ULONGLONG iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = (TCHAR)(TEXT('0') + (TCHAR)(n % 10));
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *pszBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *pszBuffer++ = '\0';
}


//
// Convert a string to an integer (taken from shlwapi.dll).
//
int
FileSize::StrToInt(
    LPCTSTR lpSrc
    ) const
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (IsDigit(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}


//
// Add commas where necessary to a number with more than 3 digits.
//
LPTSTR 
FileSize::AddCommas(
    ULONGLONG n, 
    LPTSTR pszResult,
    int cchResult
    ) const
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    CvtSizeToText(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, cchResult) == 0)
        StringCchCopy(pszResult, cchResult, szTemp);

    return pszResult;
}


//
// Format a file size value as a text string suitable for viewing.
//
void
FileSize::Format(
    ULONGLONG ullSize,
    LPTSTR pszFS,
    UINT cchFS
    ) const
{
    TraceAssert(NULL != pszFS);
    TraceAssert(0 < cchFS);

    int i;
    ULONGLONG wInt;
    ULONGLONG dw64 = ullSize;
    UINT wLen, wDec;
    TCHAR szTemp[MAX_COMMA_NUMBER_SIZE], szFormat[5];

    if (dw64 < 1000) 
    {
        wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), (DWORD)(dw64));
        i = 0;
    }
    else
    {
        int cOrders = ARRAYSIZE(m_rgiOrders);
        for (i = 1; i < cOrders - 1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
            /* do nothing */

        wInt = dw64 >> 10;
        AddCommas(wInt, szTemp, ARRAYSIZE(szTemp));
        wLen = lstrlen(szTemp);
        if (wLen < 3)
        {
            wDec = ((DWORD)(dw64 - wInt * 1024L)) * 1000 / 1024;
            // At this point, wDec should be between 0 and 1000
            // we want get the top one (or two) digits.
            wDec /= 10;
            if (wLen == 2)
                wDec /= 10;

            // Note that we need to set the format before getting the
            // intl char.
            StringCchCopy(szFormat, ARRAYSIZE(szFormat), TEXT("%02d"));

            szFormat[2] = (TCHAR)(TEXT('0') + 3 - wLen);
            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                    szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
            wLen = lstrlen(szTemp);
            wLen += wnsprintf(szTemp+wLen, ARRAYSIZE(szTemp)-wLen, szFormat, wDec);
        }
    }
    *pszFS = TEXT('\0');
    LPTSTR pszText;
    if (0 < FormatStringID(&pszText, g_hInstance, m_rgiOrders[i], szTemp))
    {
        StringCchCopy(pszFS, cchFS, pszText);
        LocalFree(pszText);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\filelist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filelist.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
/*  File: filelist.cpp

    Description: Simplifies the transmission of a list of share and 
        associated file names between components of the CSC UI.  See
        description in filelist.h for details.

        Classes:

            CscFilenameList
            CscFilenameList::HSHARE
            CscFilenameList::ShareIter
            CscFilenameList::FileIter

        Note:  This module was written to be used by any part of the CSCUI,
               not just the viewer.  Therefore, I don't assume that the
               new operator will throw an exception on allocation failures.
               I don't like all the added code to detect allocation failures
               but it's not reasonable to expect code in the other components
               to become exception-aware with respect to "new" failures.
               

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    11/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "filelist.h"

#ifdef FILELIST_TEST
#include <stdio.h>
#include <tchar.h>
#endif


static LPTSTR DupStr(LPCTSTR psz)
{
    LONG cch = lstrlen(psz) + 1;
    LPTSTR pszNew = new TCHAR[cch];
    if (NULL != pszNew)
    {
        StringCchCopy(pszNew, cch, psz);
    }
    return pszNew;
}


int CscFilenameList::m_cGrow        =  4;
int CscFilenameList::Share::m_cGrow = 10;


CscFilenameList::CscFilenameList(
    void
    ) : m_cShares(0),
        m_cAllocated(0),
        m_rgpShares(NULL),
        m_bValid(true)
{
}


CscFilenameList::CscFilenameList(
    PCSC_NAMELIST_HDR pbNames,
    bool bCopy
    ) : m_cShares(0),
        m_cAllocated(0),
        m_rgpShares(NULL),
        m_bValid(true)
{
    m_bValid = LoadFromBuffer(pbNames, bCopy);
}


CscFilenameList::~CscFilenameList(
    void
    )
{
    for (int i = 0; i < m_cShares; i++)
    {
        delete m_rgpShares[i];
    }
    delete[] m_rgpShares;
}


bool
CscFilenameList::LoadFromBuffer(
    PCSC_NAMELIST_HDR pHdr,
    bool bCopy
    )
{
    LPBYTE pbBuffer = reinterpret_cast<LPBYTE>(pHdr);
    CSC_NAMELIST_SHARE_DESC *pShareDesc = (CSC_NAMELIST_SHARE_DESC *)(pbBuffer + sizeof(CSC_NAMELIST_HDR));
    for (UINT i = 0; i < pHdr->cShares; i++)
    {
        LPCTSTR pszShareName = (LPCTSTR)(pbBuffer + pShareDesc->cbOfsShareName);
        LPCTSTR pszFileName  = (LPCTSTR)(pbBuffer + pShareDesc->cbOfsFileNames);
        HSHARE hShare;
        
        if (!AddShare(pszShareName, &hShare, bCopy))
        {
            return false; // memory allocation failure.
        }
        else
        {
            for (UINT j = 0; j < pShareDesc->cFiles; j++)
            {
                //
                // Note that we always pass "false" for the bDirectory
                // argument to AddFile().  Passing true causes the
                // string "\*" to be appended to the filename stored
                // in the collection.  Since we're getting names from
                // an existing namelist buffer, directories will already
                // have the "\*" appended.  We don't want to append a 
                // second instance.
                //
                if (!AddFile(hShare, pszFileName, false, bCopy))
                {
                    return false; // memory allocation failure.
                }
                pszFileName += (lstrlen(pszFileName) + 1);
            }
        }
        pShareDesc++;
    }
    return true;
}



bool
CscFilenameList::AddShare(
    LPCTSTR pszShare,
    HSHARE *phShare,
    bool bCopy
    )
{
    bool bResult = true;
    if (m_cShares == m_cAllocated)
        bResult = GrowSharePtrList();

    if (bResult)
    {
        bResult = false;
        Share *pShare = new Share(pszShare, bCopy);
        if (NULL != pShare)
        {
            m_rgpShares[m_cShares++] = pShare;
            *phShare = HSHARE(pShare);
            bResult = true;
        }
    }
    return bResult;
}



bool
CscFilenameList::AddFile(
    HSHARE& hShare, 
    LPCTSTR pszFile,
    bool bDirectory,
    bool bCopy
    )
{
    return hShare.m_pShare->AddFile(pszFile, bDirectory, bCopy);
}


//
// Given a full UNC path name, separate the share and file names with
// a nul character and return the address of the share and file name
// parts.  Note that the buffer pointed to by pszFullPath is modified.
//
void
CscFilenameList::ParseFullPath(
    LPTSTR pszFullPath,
    LPTSTR *ppszShare,
    LPTSTR *ppszFile
    ) const
{
    *ppszShare = NULL;
    *ppszFile = pszFullPath;

    LPTSTR psz = pszFullPath;
    if (*psz && *psz == TEXT('\\'))
    {
        psz++;
        if (*psz && *psz == TEXT('\\'))
        {
            *ppszShare = pszFullPath; // Assume a share name.
            *ppszFile  = NULL;

            psz++;
            while(*psz && *psz != TEXT('\\'))
            {
                psz = CharNext(psz);
            }
            if (*psz)
                psz = CharNext(psz);
            while(*psz && *psz != TEXT('\\'))
            {
                psz = CharNext(psz);
            }
            if (*psz)
            {
                *ppszFile = CharNext(psz);
                *psz = TEXT('\0');
            }
        }
    }
}


bool
CscFilenameList::AddFile(
    LPCTSTR pszFullPath,
    bool bDirectory, 
    bool bCopy
    )
{
    bool bResult = false;
    LPTSTR pszShare      = NULL;
    LPTSTR pszFile       = NULL;
    LPTSTR pszParsedPath = DupStr(pszFullPath);

    if (NULL != pszParsedPath)
    {
        TCHAR szBackslash[] = TEXT("\\");
        ParseFullPath(pszParsedPath, &pszShare, &pszFile);
        if (NULL == pszFile || TEXT('\0') == *pszFile)
        {
            //
            // Path was just a share name with no file or subdirectory.
            //
            pszFile = szBackslash;
        }

        if (NULL != pszShare)
        {
            bResult = AddFile(pszShare, pszFile, bDirectory, bCopy);
        }
        delete[] pszParsedPath;
    }
    return bResult;
}


bool
CscFilenameList::AddFile(
    LPCTSTR pszShare, 
    LPCTSTR pszFile,
    bool bDirectory, 
    bool bCopy
    )
{
    HSHARE hShare;
    if (!GetShareHandle(pszShare, &hShare))
    {
        if (!AddShare(pszShare, &hShare, bCopy))
        {
            return false; // memory allocation failure.
        }
    }
    return AddFile(hShare, pszFile, bDirectory, bCopy);
}


bool
CscFilenameList::RemoveFile(
    HSHARE& hShare, 
    LPCTSTR pszFile
    )
{
    return hShare.m_pShare->RemoveFile(pszFile);
}


bool
CscFilenameList::RemoveFile(
    LPCTSTR pszFullPath
    )
{
    bool bResult = false;
    LPTSTR pszShare      = NULL;
    LPTSTR pszFile       = NULL;
    LPTSTR pszParsedPath = DupStr(pszFullPath);

    if (NULL != pszParsedPath)
    {
        TCHAR szBackslash[] = TEXT("\\");
        ParseFullPath(pszParsedPath, &pszShare, &pszFile);
        if (NULL == pszFile || TEXT('\0') == *pszFile)
        {
            //
            // Path was just a share name with no file or subdirectory.
            //
            pszFile = szBackslash;
        }

        if (NULL != pszShare)
        {
            bResult = RemoveFile(pszShare, pszFile);
        }
        delete[] pszParsedPath;
    }
    return bResult;
}


bool
CscFilenameList::RemoveFile(
    LPCTSTR pszShare, 
    LPCTSTR pszFile
    )
{
    HSHARE hShare;
    if (!GetShareHandle(pszShare, &hShare))
    {
        return false; // doesn't exist
    }
    return RemoveFile(hShare, pszFile);
}


LPCTSTR 
CscFilenameList::GetShareName(
    HSHARE& hShare
    ) const
{
    return static_cast<LPCTSTR>(hShare.m_pShare->m_pszShareName);
}


int 
CscFilenameList::GetShareCount(
    void
    ) const
{
    return m_cShares;
}



int 
CscFilenameList::GetFileCount(
    void
    ) const
{
    int cFiles = 0;
    ShareIter si = CreateShareIterator();
    HSHARE hShare;
    while(si.Next(&hShare))
    {
        cFiles += GetShareFileCount(hShare);
    }
    return cFiles;
}



int 
CscFilenameList::GetShareFileCount(
    HSHARE& hShare
    ) const
{
    return hShare.m_pShare->m_cFiles;
}



bool 
CscFilenameList::ShareExists(
    LPCTSTR pszShare
    ) const
{
    HSHARE hShare;
    return GetShareHandle(pszShare, &hShare);
}


//
// Replacement for lstrcmpi that adds a little twist for the
// filename list.
// If the *pbExact argument [in] is false AND if the s1 
// string argument is appended with "\*", it is assumed to be a 
// directory name and all descendents of that directory produce a 
// match.  *pbExact is modified to indicate if the match was
// an exact match or a wildcard match as just described.
// If *pbExact is false on entry, the function works just like
// lstrcmpi except that the return value is true/false instead
// of <0, 0, >0.
//
bool
CscFilenameList::Compare(
    LPCTSTR s1,
    LPCTSTR s2,
    bool *pbExact
    )
{
    LPCTSTR s1First = s1;
    bool bMatch = false;

    TraceAssert((NULL != pbExact));

    while(*s1 || *s2)
    {
        //
        // Do a case-insensitive comparison.
        //
        if (PtrToUlong(CharUpper((LPTSTR)(*s1))) == PtrToUlong(CharUpper((LPTSTR)(*s2))))
        {
            s1 = CharNext(s1);
            s2 = CharNext(s2);
        }
        else
        {
            if (!(*pbExact))
            {
                //
                // An exact match is not required.  Now check for 
                // wildcard match.
                //
                if (TEXT('\0') == *s2 &&
                    TEXT('\\') == *s1 &&
                    TEXT('*')  == *(s1+1))
                {
                    //
                    // At end of key string provided by user.
                    // We have a match if the string being tested
                    // contains "\*" at current test location.
                    //
                    // i.e. "foo\bar" matches "foo\bar\*"
                    // 
                    bMatch = true;
                    *pbExact = false;
                }
                else if (TEXT('*') == *s1)
                {
                    //
                    // We hit a '*' in the stored string.
                    // Since we've matched up to this point, the
                    // user's string is an automatic match.
                    // 
                    bMatch = TEXT('\0') == *(s1+1);
                    *pbExact = false;
                }
            }
            goto return_result;
        }
    }
    if (TEXT('\0') == *s1 && TEXT('\0') == *s2)
    {
        //
        // Exact match.
        //
        *pbExact = bMatch = true;
        goto return_result;
    }

return_result:
    return bMatch;
}


bool 
CscFilenameList::FileExists(
    HSHARE& hShare, 
    LPCTSTR pszFile,
    bool bExact     // Default == true
    ) const
{
    FileIter fi = CreateFileIterator(hShare);
    //
    // Skip past any leading backslashes for matching purposes.
    // File names (paths) stored in the filename list don't have
    // leading backslashes.  It's implied as the root directory.
    //
    while(*pszFile && TEXT('\\') == *pszFile)
        pszFile = CharNext(pszFile);

    LPCTSTR psz;
    while(NULL != (psz = fi.Next()))
    {
        bool bExactResult = bExact; 
        if (Compare(psz, pszFile, &bExactResult)) // Modifies bExactResult.
        {
            return !bExact || (bExact && bExactResult);
        }
    }
    return false;
}


bool 
CscFilenameList::FileExists(
    LPCTSTR pszShare, 
    LPCTSTR pszFile,
    bool bExact      // Default == true
    ) const
{
    HSHARE hShare;
    return (GetShareHandle(pszShare, &hShare) &&
            FileExists(hShare, pszFile, bExact));
}



bool
CscFilenameList::FileExists(
    LPCTSTR pszFullPath,
    bool bExact          // Default = true
    ) const
{
    bool bResult         = false;
    LPTSTR pszShare      = NULL;
    LPTSTR pszFile       = NULL;
    LPTSTR pszParsedPath = DupStr(pszFullPath);
    if (NULL != pszParsedPath)
    {
        ParseFullPath(pszParsedPath, &pszShare, &pszFile);
        if (NULL != pszShare && NULL != pszFile)
        {
            bResult = FileExists(pszShare, pszFile, bExact);
        }
        delete[] pszParsedPath;
    }
    return bResult;
}



CscFilenameList::FileIter 
CscFilenameList::CreateFileIterator(
    HSHARE& hShare
    ) const
{
    return FileIter(hShare.m_pShare);
}



CscFilenameList::ShareIter
CscFilenameList::CreateShareIterator(
    void
    ) const
{
    return ShareIter(*this);
}



bool
CscFilenameList::GetShareHandle(
    LPCTSTR pszShare,
    HSHARE *phShare
    ) const
{
    Share *pShare = NULL;
    for (int i = 0; i < m_cShares; i++)
    {
        pShare = m_rgpShares[i];
        if (pShare->m_pszShareName.IsValid() && 0 == lstrcmpi(pszShare, pShare->m_pszShareName))
        {
            *phShare = HSHARE(pShare);
            return true;
        }
    }
    return false;
}



bool
CscFilenameList::GrowSharePtrList(
    void
    )
{
    Share **rgpShares = new Share *[m_cAllocated + m_cGrow];
    if (NULL != rgpShares)
    {
        if (NULL != m_rgpShares) 
            CopyMemory(rgpShares, m_rgpShares, m_cAllocated * sizeof(Share *));
        delete[] m_rgpShares;
        m_rgpShares = rgpShares;
        m_cAllocated += m_cGrow;
    }
    return (NULL != rgpShares);
}


//
// Create a memory buffer to hold the contents of the name list.
// The buffer is formatted as described in the header of filelist.h.
// 
PCSC_NAMELIST_HDR
CscFilenameList::CreateListBuffer(
    void
    ) const
{
    int i;

    //
    // Calculate the required buffer size and allocate buffer.
    //
    int cbOfsNames = sizeof(CSC_NAMELIST_HDR) +
                     sizeof(CSC_NAMELIST_SHARE_DESC) * m_cShares;
    int cbBuffer = cbOfsNames;

    for (i = 0; i < m_cShares; i++)
    {
        cbBuffer += m_rgpShares[i]->ByteCount();
    }

    LPBYTE pbBuffer = new BYTE[cbBuffer];
    PCSC_NAMELIST_HDR pHdr = reinterpret_cast<PCSC_NAMELIST_HDR>(pbBuffer);
    if (NULL != pbBuffer)
    {
        LPTSTR pszNames = reinterpret_cast<LPTSTR>(pbBuffer + cbOfsNames);
        CSC_NAMELIST_SHARE_DESC *pShareDescs = reinterpret_cast<CSC_NAMELIST_SHARE_DESC *>(pbBuffer + sizeof(CSC_NAMELIST_HDR));
        int cchNames = (cbBuffer - cbOfsNames) / sizeof(TCHAR);
        //
        // Write the share and file name strings.
        //
        for (i = 0; i < m_cShares; i++)
        {
            CSC_NAMELIST_SHARE_DESC *pDesc = pShareDescs + i;
            Share *pShare = m_rgpShares[i];

            int cch = pShare->Write(pbBuffer, 
                                    pDesc,
                                    pszNames,
                                    cchNames);
            cchNames -= cch;
            pszNames += cch;
        }
        //
        // Fill in the buffer header.
        //
        pHdr->cbSize  = cbBuffer;
        pHdr->cShares = m_cShares;
    }

    return pHdr;
}


        
void
CscFilenameList::FreeListBuffer(
    PCSC_NAMELIST_HDR pbNames
    )
{
    delete[] pbNames;
}

#ifdef FILELIST_TEST
void
CscFilenameList::Dump(
    void
    ) const
{
    _tprintf(TEXT("Dump share name list at 0x%08X\n"), (DWORD)this);
    _tprintf(TEXT("\tm_cShares......: %d\n"), m_cShares);
    _tprintf(TEXT("\tm_cAllocated...: %d\n"), m_cAllocated);

   
    for (int i = 0; i < m_cShares; i++)
    {
        m_rgpShares[i]->Dump();
    }
}

void
CscFilenameList::DumpListBuffer(
    PCSC_NAMELIST_HDR pHdr
    ) const
{
    LPBYTE pbBuffer = (LPBYTE)pHdr;
    _tprintf(TEXT("Dump buffer at 0x%08X\n"), (DWORD)pbBuffer);
    _tprintf(TEXT("hdr.cbSize......: %d\n"), pHdr->cbSize); 
    _tprintf(TEXT("hdr.flags.......: %d\n"), pHdr->flags); 
    _tprintf(TEXT("hdr.cShares.....: %d\n"), pHdr->cShares);
    CSC_NAMELIST_SHARE_DESC *pDesc = (CSC_NAMELIST_SHARE_DESC *)(pbBuffer + sizeof(CSC_NAMELIST_HDR));
    for (UINT i = 0; i < pHdr->cShares; i++)
    {
        _tprintf(TEXT("\tShare [%d] header\n"), i);
        _tprintf(TEXT("\t\tcbOfsShareName..:%d\n"), pDesc->cbOfsShareName);
        _tprintf(TEXT("\t\tcbOfsFileNames..:%d\n"), pDesc->cbOfsFileNames);
        _tprintf(TEXT("\t\tcFiles..........:%d\n"), pDesc->cFiles);
        LPTSTR pszName = (LPTSTR)(pbBuffer + pDesc->cbOfsShareName);
        _tprintf(TEXT("\t\tShare name......: \"%s\"\n"), pszName);
        pszName += lstrlen(pszName) + 1;
        for (UINT j = 0; j < pDesc->cFiles; j++)
        {
            _tprintf(TEXT("\t\tFile[%3d] name...: \"%s\"\n"), j, pszName);
            pszName += lstrlen(pszName) + 1;
        }
        pDesc++;
    }
}

#endif // FILELIST_TEST

CscFilenameList::Share::Share(
    LPCTSTR pszShare,
    bool bCopy
    ) : m_pszShareName(pszShare, bCopy),
        m_cFiles(0),
        m_cAllocated(0),
        m_cchFileNames(0),
        m_cchShareName(lstrlen(pszShare) + 1),
        m_rgpszFileNames(NULL)
{


}



CscFilenameList::Share::~Share(
    void
    )
{
    delete[] m_rgpszFileNames;
}



bool
CscFilenameList::Share::AddFile(
    LPCTSTR pszFile,
    bool bDirectory,
    bool bCopy
    )
{
    bool bResult = true;

    TraceAssert((NULL != pszFile && TEXT('\0') != *pszFile));
    if (NULL == pszFile || TEXT('\0') == *pszFile)
        return false;

    if (m_cFiles == m_cAllocated)
        bResult = GrowFileNamePtrList();

    if (bResult)
    {
        LPTSTR pszFileCopy = NULL;
        if (bDirectory)
        {
            int cchFile = lstrlen(pszFile);
            pszFileCopy = new TCHAR[cchFile + 3]; // length + "\*" + nul
            if (NULL == pszFileCopy)
                return false; // memory alloc failure.
            //
            // Append "\*" to a directory entry.
            // This will allow us to do lookups on files that
            // are descendants of a directory.  See
            // CscFilenameList::FileExists() for details.
            //
            StringCchCopy(pszFileCopy, cchFile + 3, pszFile);
            if (TEXT('\\') == *(pszFileCopy + cchFile - 1))
            {
                //
                // Guard against pszFile already having a trailing backslash.
                //
                cchFile--;
            }
            StringCchCopy(pszFileCopy + cchFile, 3, TEXT("\\*"));
            pszFile = pszFileCopy;
        }

        //
        // Skip past any leading backslash.
        //
        while(*pszFile && TEXT('\\') == *pszFile)
            pszFile = CharNext(pszFile);

        NamePtr np(pszFile, bCopy);
        if (bResult = np.IsValid())
        {
            m_rgpszFileNames[m_cFiles++] = np;
            m_cchFileNames += (lstrlen(pszFile) + 1);
        }
        delete[] pszFileCopy;
    }
    return bResult;
}



bool
CscFilenameList::Share::RemoveFile(
    LPCTSTR pszFile
    )
{
    TraceAssert((NULL != pszFile && TEXT('\0') != *pszFile));
    if (NULL == pszFile || TEXT('\0') == *pszFile)
        return false;

    //
    // Skip past any leading backslashes for matching purposes.
    // File names (paths) stored in the filename list don't have
    // leading backslashes.  It's implied as the root directory.
    //
    while(*pszFile && TEXT('\\') == *pszFile)
        pszFile = CharNext(pszFile);

    for(int i = 0; i < m_cFiles; i++)
    {
        bool bExactResult = true; 
        if (Compare(m_rgpszFileNames[i], pszFile, &bExactResult)
            && bExactResult)
        {
            // Found an exact match. Move the last file into the
            // current array location and decrement the count.
            m_rgpszFileNames[i] = m_rgpszFileNames[--m_cFiles];
            return true;
        }
    }
    return false;
}



bool
CscFilenameList::Share::GrowFileNamePtrList(
    void
    )
{
    CscFilenameList::NamePtr *rgpsz = new CscFilenameList::NamePtr[m_cAllocated + m_cGrow];
    if (NULL != rgpsz)
    {
        m_cAllocated += m_cGrow;
        if (NULL != m_rgpszFileNames) 
        {
            for (int i = 0; i < m_cFiles; i++)
            {
                rgpsz[i] = m_rgpszFileNames[i];
            }
        }
        delete[] m_rgpszFileNames;
        m_rgpszFileNames = rgpsz;
    }
    return (NULL != rgpsz);
}


//
// Write the share name and file names to a text buffer.
//
int
CscFilenameList::Share::Write(
    LPBYTE pbBufferStart,             // Address of buffer start.
    CSC_NAMELIST_SHARE_DESC *pShare,  // Address of share descriptor.
    LPTSTR pszBuffer,                 // Address of name buffer
    int cchBuffer                     // Chars left in name buffer.
    ) const
{
    pShare->cbOfsShareName = (DWORD)((LPBYTE)pszBuffer - pbBufferStart);
    int cch = WriteName(pszBuffer, cchBuffer);
    cchBuffer -= cch;
    pszBuffer += cch;
    pShare->cbOfsFileNames = (DWORD)((LPBYTE)pszBuffer - pbBufferStart);
    cch += WriteFileNames(pszBuffer, cchBuffer, &pShare->cFiles);
    return cch;
}



//
// Write the share name to a text buffer.
//
int
CscFilenameList::Share::WriteName(
    LPTSTR pszBuffer,
    int cchBuffer
    ) const
{
    if (m_pszShareName.IsValid() && m_cchShareName <= cchBuffer)
    {
        StringCchCopy(pszBuffer, cchBuffer, m_pszShareName);
        return m_cchShareName;
    }
    return 0;
}



//
// Write the file names to a text buffer.
//
int
CscFilenameList::Share::WriteFileNames(
    LPTSTR pszBuffer, 
    int cchBuffer,
    DWORD *pcFilesWritten  // [out]. Count of files written.
    ) const
{
    int cchWritten = 0;
    DWORD cFilesWritten = 0;

    if (m_cchFileNames <= cchBuffer)
    {   
        for (int i = 0; i < m_cFiles; i++)
        {
            if (m_rgpszFileNames[i].IsValid())
            {
                StringCchCopy(pszBuffer, cchBuffer, m_rgpszFileNames[i]);
                int cch = (lstrlen(m_rgpszFileNames[i]) + 1);
                pszBuffer += cch;
                cchBuffer -= cch;
                cchWritten += cch;
                cFilesWritten++;
            }
        }
    }
    if (NULL != pcFilesWritten)
    {
        *pcFilesWritten = cFilesWritten;
    }
    return cchWritten;
}

#ifdef FILELIST_TEST

void
CscFilenameList::Share::Dump(
    void
    ) const
{
    _tprintf(TEXT("Share \"%s\"\n"), (LPCTSTR)m_pszShareName ? (LPCTSTR)m_pszShareName : TEXT("<null>"));
    _tprintf(TEXT("\tm_cFiles........: %d\n"), m_cFiles);
    _tprintf(TEXT("\tm_cAllocated....: %d\n"), m_cAllocated);
    _tprintf(TEXT("\tm_cchShareName..: %d\n"), m_cchShareName);
    _tprintf(TEXT("\tm_cchFileNames..: %d\n"), m_cchFileNames);
    for (int i = 0; i < m_cFiles; i++)
    {
        _tprintf(TEXT("\tFile[%3d].......: \"%s\"\n"), i, (LPCTSTR)m_rgpszFileNames[i] ? (LPCTSTR)m_rgpszFileNames[i] : TEXT("<null>"));
    }
}

#endif // FILELIST_TEST


CscFilenameList::FileIter::FileIter(
    const CscFilenameList::Share *pShare
    ) : m_pShare(pShare),
        m_iFile(0)
{

}



CscFilenameList::FileIter::FileIter(
    void
    ) : m_pShare(NULL),
        m_iFile(0)
{

}



CscFilenameList::FileIter::FileIter(
    const CscFilenameList::FileIter& rhs
    )
{
    *this = rhs;
}



CscFilenameList::FileIter& 
CscFilenameList::FileIter::operator = (
    const CscFilenameList::FileIter& rhs
    )
{
    if (this != &rhs)
    {
        m_pShare = rhs.m_pShare;
        m_iFile  = rhs.m_iFile;
    }
    return *this;
}



LPCTSTR 
CscFilenameList::FileIter::Next(
    void
    )
{
    if (0 < m_pShare->m_cFiles && m_iFile < m_pShare->m_cFiles)
        return m_pShare->m_rgpszFileNames[m_iFile++];
    return NULL;
}



void
CscFilenameList::FileIter::Reset(
    void
    )
{
    m_iFile = 0;
}



CscFilenameList::ShareIter::ShareIter(
    const CscFilenameList& fnl
    ) : m_pfnl(&fnl),
        m_iShare(0)
{

}



CscFilenameList::ShareIter::ShareIter(
    void
    ) : m_pfnl(NULL),
        m_iShare(0)
{

}



CscFilenameList::ShareIter::ShareIter(
    const CscFilenameList::ShareIter& rhs
    )
{
    *this = rhs;
}



CscFilenameList::ShareIter& 
CscFilenameList::ShareIter::operator = (
    const CscFilenameList::ShareIter& rhs
    )
{
    if (this != &rhs)
    {
        m_pfnl   = rhs.m_pfnl;
        m_iShare = rhs.m_iShare;
    }
    return *this;
}



bool
CscFilenameList::ShareIter::Next(
    HSHARE *phShare
    )
{
    if (0 < m_pfnl->m_cShares && m_iShare < m_pfnl->m_cShares)
    {
        *phShare = HSHARE(m_pfnl->m_rgpShares[m_iShare++]);
        return true;
    }
    return false;
}



void
CscFilenameList::ShareIter::Reset(
    void
    )
{
    m_iShare = 0;
}



CscFilenameList::NamePtr::NamePtr(
    LPCTSTR pszName,
    bool bCopy
    ) : m_pszName(pszName),
        m_bOwns(bCopy)
{
    if (bCopy)
    {
        m_pszName = DupStr(pszName);
        m_bOwns = true;
    }
}



CscFilenameList::NamePtr::~NamePtr(
    void
    )
{
    if (m_bOwns)
    {
        delete[] const_cast<LPTSTR>(m_pszName);
    }
}



CscFilenameList::NamePtr::NamePtr(
    CscFilenameList::NamePtr& rhs
    )
{
    *this = rhs;
}



CscFilenameList::NamePtr& 
CscFilenameList::NamePtr::operator = (
    CscFilenameList::NamePtr& rhs
    )
{
    if (this != &rhs)
    {
        if (m_bOwns)
            delete[] (LPTSTR)m_pszName;

        m_pszName = rhs.m_pszName;
        m_bOwns   = false;
        if (rhs.m_bOwns)
        {
            //
            // Assume ownership of the buffer.
            //
            rhs.m_bOwns = false;
            m_bOwns     = true;
        }
    }
    return *this;
}



CscFilenameList::HSHARE::HSHARE(
    void
    ) : m_pShare(NULL)
{

}



CscFilenameList::HSHARE::HSHARE(
    const HSHARE& rhs
    )
{
    *this = rhs;
}



CscFilenameList::HSHARE& 
CscFilenameList::HSHARE::operator = (
    const CscFilenameList::HSHARE& rhs
    )
{
    if (this != &rhs)
    {
        m_pShare = rhs.m_pShare;
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\eventlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       eventlog.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_EVENTLOG_H
#define _INC_CSCUI_EVENTLOG_H
#ifndef _WINDOWS_
#   include <windows.h>
#endif

//
// This class provides basic NT event logging capability.  It provides only
// a subset of the full capability provided by the NT event logging APIs.
// I wanted a simple way to write messages to the event log.  No reading
// of event log entries is supported.
//
class CEventLog
{
    public:
        //
        // Number conversion formats.
        //
        enum eFmt { 
                     eFmtDec,       // Display as decimal.
                     eFmtHex,       // Display as hex
                     eFmtSysErr     // Display as win32 error text string.
                  };

        class CStrArray
        {
            public:
                CStrArray(void);
                ~CStrArray(void)
                    { Destroy(); }

                bool Append(LPCTSTR psz);

                void Clear(void)
                    { Destroy(); }

                int Count(void) const
                    { return m_cEntries; }

                LPCTSTR Get(int iEntry) const;

                operator LPCTSTR* () const
                    { return (LPCTSTR *)m_rgpsz; }

            private:
                enum { MAX_ENTRIES = 8 };

                int    m_cEntries;
                LPTSTR m_rgpsz[MAX_ENTRIES];

                void Destroy(void);
                //
                // Prevent copy.
                //
                CStrArray(const CStrArray& rhs);
                CStrArray& operator = (const CStrArray& rhs);
        };


        CEventLog(void)
            : m_hLog(NULL) 
              { }

        ~CEventLog(void);

        HRESULT Initialize(LPCTSTR pszEventSource);

        bool IsInitialized(void)
            { return NULL != m_hLog; }

        void Close(void);

        HRESULT ReportEvent(WORD wType,
                            WORD wCategory,
                            DWORD dwEventID,
                            PSID lpUserSid = NULL,
                            LPVOID pvRawData = NULL,
                            DWORD cbRawData = 0);

        //
        // Push replacement data onto a stack to replace the
        // %1, %2 etc. parameters in the message strings.
        //
        void Push(HRESULT hr, eFmt = eFmtDec);
        void Push(LPCTSTR psz);

    private:
        HANDLE    m_hLog;
        CStrArray m_rgstrText;

        //
        // Prevent copy.
        //
        CEventLog(const CEventLog& rhs);
        CEventLog& operator = (const CEventLog& rhs);
};


//
// Wrap the CEventLog class so we can control log initialization
// and also filter events based on the CSCUI event logging level.
// The idea here is to create a CscuiEventLog object whenever you
// want to write to the event log.  The ReportEvent member has
// been designed to handle log initialization as well as filtering
// message output to respect the current CSCUI event logging level
// set in the registry/policy.  It's recommended that the 
// CscuiEventLog object be created as a local variable so that 
// once the reporting is complete, the object is destroyed and
// the system event log handle is closed.
//
class CscuiEventLog
{
public:
    CscuiEventLog(void)
    : m_iEventLoggingLevel(CConfig::GetSingleton().EventLoggingLevel()) { }

    ~CscuiEventLog(void) { }

    HRESULT ReportEvent(WORD wType,
                        DWORD dwEventID,
                        int iMinLevel,
                        PSID lpUserSid = NULL,
                        LPVOID pvRawData = NULL,
                        DWORD cbRawData = 0);

    bool LoggingEnabled(void) const
        { return 0 < m_iEventLoggingLevel; }

    void Push(HRESULT hr, CEventLog::eFmt fmt)
        { m_log.Push(hr, fmt); }

    void Push(LPCTSTR psz)
        { m_log.Push(psz); }

private:
    CEventLog m_log;
    int       m_iEventLoggingLevel;
};

#endif // _INC_CSCUI_EVENTLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\filesize.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesize.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCVIEW_FILESIZE_H
#define _INC_CSCVIEW_FILESIZE_H

//
// Simple class to convert a file size value to a string formatted for display.
// The display format is the same used by the shell (i.e. "10.5 MB")
//
class FileSize
{
    public:
        explicit FileSize(ULONGLONG ullSize = 0);
        ~FileSize(void) { }

        FileSize(const FileSize& rhs)
            { *this = rhs; }

        FileSize& operator = (const FileSize& rhs);

        int Compare(const FileSize& rhs) const
            { return *this > rhs ? 1 : (*this == rhs ? 0 : -1); }

        operator ULONGLONG() const
            { return m_ullSize; }

        ULONGLONG GetSize(void) const
            { return m_ullSize; }

        void GetString(LPTSTR pszOut, UINT cchOut) const
            { TraceAssert(NULL != pszOut); Format(m_ullSize, pszOut, cchOut); }

    private:
        ULONGLONG  m_ullSize;     // Size as a number.
        static int m_rgiOrders[]; // Array of format string res IDs.

        void Format(ULONGLONG ullSize, LPTSTR pszOut, UINT cchOut) const;
        void CvtSizeToText(ULONGLONG n, LPTSTR pszBuffer) const;
        int StrToInt(LPCTSTR lpSrc) const;
        LPTSTR AddCommas(ULONGLONG n, LPTSTR pszResult, int cchResult) const;

        bool IsDigit(TCHAR ch) const
            { return (ch >= TEXT('0') && ch <= TEXT('9')); }

        friend bool operator == (const FileSize& a, const FileSize& b);
        friend bool operator != (const FileSize& a, const FileSize& b);
        friend bool operator <  (const FileSize& a, const FileSize& b);
        friend bool operator <= (const FileSize& a, const FileSize& b);
        friend bool operator >  (const FileSize& a, const FileSize& b);
        friend bool operator >= (const FileSize& a, const FileSize& b);
};

//
// The various comparison operators for FileSize objects.
//
inline bool operator == (const FileSize& a, const FileSize& b)
{ 
    return a.m_ullSize == b.m_ullSize;
}

inline bool operator != (const FileSize& a, const FileSize& b)
{ 
    return !(a == b);
}

inline bool operator < (const FileSize& a, const FileSize& b)
{ 
    return a.m_ullSize < b.m_ullSize;
}

inline bool operator <= (const FileSize& a, const FileSize& b)
{ 
    return (a < b) || (a == b);
}

inline bool operator > (const FileSize& a, const FileSize& b)
{ 
    return !(a < b) && !(a == b);
}

inline bool operator >= (const FileSize& a, const FileSize& b)
{ 
    return (a > b) || (a == b);
}

#endif // _INC_CSCVIEW_FILESIZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\firstpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       firstpin.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_FIRSTPIN_H
#define _INC_CSCUI_FIRSTPIN_H

HRESULT ShowFirstPinWizard(HWND hwndParent);
bool FirstPinWizardCompleted(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\fmtetc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fmtetc.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "fmtetc.h"

CEnumFormatEtc::CEnumFormatEtc(
    UINT cFormats, 
    LPFORMATETC prgFormats
    ) : m_cRef(0),
        m_cFormats(0),
        m_iCurrent(0),
        m_prgFormats(NULL),
        m_hrCtor(NOERROR)
{
    m_hrCtor = AddFormats(cFormats, prgFormats);
}


CEnumFormatEtc::CEnumFormatEtc(
    const CEnumFormatEtc& ef
    ) : m_cRef(0),
        m_cFormats(0),
        m_iCurrent(0),
        m_prgFormats(NULL),
        m_hrCtor(NOERROR)
{
    m_hrCtor = AddFormats(ef.m_cFormats, ef.m_prgFormats);
}



CEnumFormatEtc::~CEnumFormatEtc(
    VOID
    )
{
    delete[] m_prgFormats;
}


STDMETHODIMP 
CEnumFormatEtc::QueryInterface(
    REFIID riid, 
    LPVOID *ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(CEnumFormatEtc, IEnumFORMATETC),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG) 
CEnumFormatEtc::AddRef(
    VOID
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) 
CEnumFormatEtc::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP
CEnumFormatEtc::Next(
    DWORD cFormats,
    LPFORMATETC pFormats,
    LPDWORD pcReturned
    )
{
    HRESULT hr = S_OK;
    DWORD iFormats = 0;
    if (NULL == pFormats)
        return E_INVALIDARG;

    while(cFormats-- > 0)
    {
        if (m_iCurrent < m_cFormats)
        {
            *(pFormats + iFormats++) = m_prgFormats[m_iCurrent++];
        }
        else
        {
            hr = S_FALSE;
            break;
        }
    }

    if (NULL != pcReturned)
        *pcReturned = iFormats;

    return hr;
}


STDMETHODIMP
CEnumFormatEtc::Skip(
    DWORD cFormats
    )
{
    while((cFormats-- > 0) && (m_iCurrent < m_cFormats))
        m_iCurrent++;

    return cFormats == 0 ? S_OK : S_FALSE;
}


STDMETHODIMP 
CEnumFormatEtc::Reset(
    VOID
    )
{
    m_iCurrent = 0;
    return S_OK;
}


STDMETHODIMP 
CEnumFormatEtc::Clone(
    IEnumFORMATETC **ppvOut
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CEnumFormatEtc *pNew = new CEnumFormatEtc(*this);
    if (NULL != pNew)
    {
        hr = pNew->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppvOut);
    }
    return hr;
}


HRESULT
CEnumFormatEtc::AddFormats(
    UINT cFormats,
    LPFORMATETC pFormats
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    LPFORMATETC pNew  = new FORMATETC[m_cFormats + cFormats];
    if (NULL != pNew)
    {
        FORMATETC *pSrc  = m_prgFormats;
        FORMATETC *pDest = pNew;
        int i;

        for (i = 0; i < m_cFormats; i++)
        {
            *pDest++ = *pSrc++;  // Copy original formats.
        }
        pSrc = pFormats;
        for (i = 0; i < int(cFormats); i++)
        {
            *pDest++ = *pSrc++;  // Add new formats.
        }
        delete[] m_prgFormats;
        m_cFormats += cFormats;
        m_prgFormats = pNew;
        hr = NOERROR;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\firstpin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       firstpin.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "firstpin.h"
#include "folder.h"
#include "msgbox.h"
#include "cscst.h"
#include "syncmgr.h"
#include "strings.h"
//
// Base class for all "first pin" wizard pages.
// Contains the single dialog proc used for all pages.  Specialization
// for individual pages is achieved through deriviation and implementing
// virtual functions.
//
class CWizardPage
{
    public:
        enum { WM_WIZARDFINISHED = (WM_USER + 1) };

        CWizardPage(HINSTANCE hInstance,
                    UINT idDlgTemplate,
                    UINT idsHdrTitle,
                    UINT idsHdrSubtitle,
                    DWORD dwPgFlags,
                    DWORD dwBtnFlags);

        virtual ~CWizardPage(void);

        UINT GetDlgTemplate(void) const
            { return m_idDlgTemplate; }
        UINT GetHeaderTitle(void) const
            { return m_idsHdrTitle; }
        UINT GetHeaderSubtitle(void) const
            { return m_idsHdrSubtitle; }
        DWORD GetPageFlags(void) const
            { return m_dwPgFlags; }
        DWORD GetBtnFlags(void) const
            { return m_dwBtnFlags; }
        DLGPROC GetDlgProc(void) const
            { return DlgProc; }

        virtual BOOL OnInitDialog(WPARAM wParam, LPARAM lParam)
            { return TRUE; }

        virtual BOOL OnPSNSetActive(void);

        virtual BOOL OnPSNWizFinish(void)
            { SetWindowLong(m_hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR); return FALSE; }

        virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam)
            { return FALSE; }

        virtual BOOL OnWizardFinished(void) { return FALSE; }

    protected:
        HINSTANCE m_hInstance;
        HWND      m_hwndDlg;
        HFONT     m_hTitleFont;       // Used only by cover and finish pages.
        UINT      m_cyTitleFontHt;    // Title font height in pts.

        int FontPtsToHt(HWND hwnd, int pts);
        BOOL FormatTitleFont(UINT idcTitle);

    private:
        UINT   m_idDlgTemplate;    // Dialog resource template.
        UINT   m_idsHdrTitle;      // String ID for pg header title.
        UINT   m_idsHdrSubtitle;   // String ID for pg header subtitle.
        DWORD  m_dwBtnFlags;       // PSB_WIZXXXXX flags.
        DWORD  m_dwPgFlags;        // PSP_XXXX flags.
        
        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};


//
// Welcome page.
//
class CWizardPgWelcome : public CWizardPage
{
    public:
        CWizardPgWelcome(HINSTANCE hInstance,
                         UINT idDlgTemplate, 
                         UINT idsHdrTitle, 
                         UINT idsHdrSubtitle,
                         DWORD dwPgFlags, 
                         DWORD dwBtnFlags
                         ) : CWizardPage(hInstance,
                                         idDlgTemplate,
                                         idsHdrTitle,
                                         idsHdrSubtitle,
                                         dwPgFlags,
                                         dwBtnFlags)
                                         { }


        BOOL OnInitDialog(WPARAM wParam, LPARAM lParam);
};

//
// Pinning page.
//
class CWizardPgPin : public CWizardPage
{
    public:
        CWizardPgPin(HINSTANCE hInstance,
                     UINT idDlgTemplate, 
                     UINT idsHdrTitle, 
                     UINT idsHdrSubtitle,
                     DWORD dwPgFlags, 
                     DWORD dwBtnFlags
                     ) : CWizardPage(hInstance, 
                                     idDlgTemplate,
                                     idsHdrTitle,
                                     idsHdrSubtitle,
                                     dwPgFlags,
                                     dwBtnFlags) { }

        BOOL OnInitDialog(WPARAM wParam, LPARAM lParam);
        BOOL OnWizardFinished(void);
};

//
// Offline page.
//
class CWizardPgOffline : public CWizardPage
{
    public:
        CWizardPgOffline(HINSTANCE hInstance,
                         UINT idDlgTemplate, 
                         UINT idsHdrTitle, 
                         UINT idsHdrSubtitle,
                         DWORD dwPgFlags, 
                         DWORD dwBtnFlags
                         ) : CWizardPage(hInstance,
                                         idDlgTemplate,
                                         idsHdrTitle,
                                         idsHdrSubtitle,
                                         dwPgFlags,
                                         dwBtnFlags) { }

        BOOL OnInitDialog(WPARAM wParam, LPARAM lParam);
        BOOL OnPSNWizFinish(void);
        BOOL OnWizardFinished(void);
};

//
// Class encapsulating the functionality of the entire wizard.
// It contains member instances of each of the page types.
//
class CFirstPinWizard
{
    public:
        CFirstPinWizard(HINSTANCE hInstance, HWND hwndParent);

        HRESULT Run(void);

    private:
        enum { PG_WELCOME, 
               PG_PIN, 
               PG_OFFLINE,
               PG_NUMPAGES };

        HINSTANCE         m_hInstance;
        HWND              m_hwndParent;
        CWizardPgWelcome  m_PgWelcome;
        CWizardPgPin      m_PgPin;
        CWizardPgOffline  m_PgOffline;
        CWizardPage      *m_rgpWizPages[PG_NUMPAGES];
};


//
// CWizardPage members --------------------------------------------------------
//
CWizardPage::CWizardPage(
    HINSTANCE hInstance,
    UINT idDlgTemplate,
    UINT idsHdrTitle,
    UINT idsHdrSubtitle,
    DWORD dwPgFlags,
    DWORD dwBtnFlags
    ) : m_hInstance(hInstance),
        m_idDlgTemplate(idDlgTemplate),
        m_idsHdrTitle(idsHdrTitle),
        m_idsHdrSubtitle(idsHdrSubtitle),
        m_dwPgFlags(dwPgFlags),
        m_dwBtnFlags(dwBtnFlags),
        m_cyTitleFontHt(12),
        m_hwndDlg(NULL),
        m_hTitleFont(NULL)
{
    //
    // Get the title font height from a resource string.  That way localizers can
    // play with the font dimensions if necessary.
    //
    TCHAR szFontHt[20];
    if (0 < LoadString(m_hInstance, IDS_FIRSTPIN_FONTHT_PTS, szFontHt, ARRAYSIZE(szFontHt)))
    {
        m_cyTitleFontHt = StrToInt(szFontHt);
    }
}


CWizardPage::~CWizardPage(
    void
    )
{
    if (NULL != m_hTitleFont)
    {
        DeleteObject(m_hTitleFont);
    }
}


//
// PSN_SETACTIVE handler.
//
BOOL 
CWizardPage::OnPSNSetActive(
    void
    )
{
    PropSheet_SetWizButtons(GetParent(m_hwndDlg), m_dwBtnFlags);
    return FALSE;
}

//
// Dialog proc used by all pages in this wizard.
//
INT_PTR CALLBACK 
CWizardPage::DlgProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CWizardPage *pPage = (CWizardPage *)GetWindowLongPtr(hwnd, DWLP_USER);

    BOOL bResult = FALSE;
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            PROPSHEETPAGE *ppsp = (PROPSHEETPAGE *)lParam;
            pPage = (CWizardPage *)ppsp->lParam;

            TraceAssert(NULL != pPage);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pPage);
            pPage->m_hwndDlg = hwnd;
            bResult = pPage->OnInitDialog(wParam, lParam);
            break;
        }

        case WM_COMMAND:
            if (NULL != pPage)
                bResult = pPage->OnCommand(wParam, lParam);
            break;

        case WM_NOTIFY:
            switch(((LPNMHDR)lParam)->code)
            {
                case PSN_SETACTIVE:
                    bResult = pPage->OnPSNSetActive();
                    break;

                case PSN_WIZFINISH:
                    bResult = pPage->OnPSNWizFinish();
                    break;
            }
            break;

        case PSM_QUERYSIBLINGS:
            if (CWizardPage::WM_WIZARDFINISHED == wParam)
                bResult = pPage->OnWizardFinished();
            break;

        default:
            break;
    }
    return bResult;
}



//
// Helper function to convert a font point size to a height value
// used in a LOGFONT structure.
//
int 
CWizardPage::FontPtsToHt(
    HWND hwnd, 
    int pts
    )
{
    int ht  = 10;
    HDC hdc = GetDC(hwnd);
    if (NULL != hdc)
    {
        ht = -MulDiv(pts, GetDeviceCaps(hdc, LOGPIXELSY), 72); 
        ReleaseDC(hwnd, hdc);
    }
    return ht;
}


//
// The title text on the cover and finish pages is enlarged and bold.
// This code modifies the text in the dialog accordingly.
// On return, m_hTitleFont contains the handle to the title font.
//
BOOL
CWizardPage::FormatTitleFont(
    UINT idcTitle
    )
{
    BOOL bResult   = FALSE;
    HWND hwndTitle = GetDlgItem(m_hwndDlg, idcTitle);
    HFONT hFont    = (HFONT)SendMessage(hwndTitle, WM_GETFONT, 0, 0);
    if (NULL != hFont)
    {
        if (NULL == m_hTitleFont)
        {
            LOGFONT lf;
            if (GetObject(hFont, sizeof(lf), &lf))
            {
                lf.lfHeight = FontPtsToHt(hwndTitle, m_cyTitleFontHt);
                m_hTitleFont = CreateFontIndirect(&lf);
            }
        }
        if (NULL != m_hTitleFont)
        {
            SendMessage(hwndTitle, WM_SETFONT, (WPARAM)m_hTitleFont, 0);
            bResult = TRUE;
        }
    }
    return bResult;
}


//
// CWizardPgWelcome members -----------------------------------------------------
//
//
// WM_INITDIALOG handler.
//
BOOL 
CWizardPgWelcome::OnInitDialog(
    WPARAM wParam, 
    LPARAM lParam
    )
{
    FormatTitleFont(IDC_TXT_FIRSTPIN_WELCOME_TITLE);
    return CWizardPage::OnInitDialog(wParam, lParam);
}


//
// CWizardPgPin members -------------------------------------------------------
//
//
// WM_INITDIALOG handler.
//
BOOL 
CWizardPgPin::OnInitDialog(
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HRESULT hr = IsRegisteredForSyncAtLogonAndLogoff();
    CheckDlgButton(m_hwndDlg, 
                   IDC_CBX_FIRSTPIN_AUTOSYNC, 
                   S_OK == hr ? BST_CHECKED : BST_UNCHECKED);

    return CWizardPage::OnInitDialog(wParam, lParam);
}

//
// PSN_WIZFINISH handler.
//
BOOL 
CWizardPgPin::OnWizardFinished(
    void
    )
{
    HRESULT hr;
    RegisterSyncMgrHandler(TRUE);
    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_FIRSTPIN_AUTOSYNC))
    {
        const DWORD dwFlags = SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT;
    
        hr = RegisterForSyncAtLogonAndLogoff(dwFlags, dwFlags);
        if (SUCCEEDED(hr))
        {
            SetSyncMgrInitialized();
        }
        else
        {
            CscMessageBox(m_hwndDlg,
                          MB_OK | MB_ICONERROR,
                          Win32Error(HRESULT_CODE(hr)),
                          m_hInstance,
                          IDS_ERR_REGSYNCATLOGONLOGOFF);
        }
    }
    return CWizardPage::OnWizardFinished();
}



//
// CWizardPgOffline members ---------------------------------------------------
//
//
// WM_INITDIALOG handler.
//
BOOL 
CWizardPgOffline::OnInitDialog(
    WPARAM wParam, 
    LPARAM lParam
    )
{
    //
    // If policy allows configuration of the reminders, check the "enable reminders"
    // checkbox.
    //
    CConfig& config = CConfig::GetSingleton();
    bool bNoConfigReminders;
    bool bNoCacheViewer = config.NoCacheViewer();

    config.NoReminders(&bNoConfigReminders);

    CheckDlgButton(m_hwndDlg, IDC_CBX_REMINDERS, !bNoConfigReminders);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_REMINDERS), !bNoConfigReminders);

    CheckDlgButton(m_hwndDlg, IDC_CBX_FIRSTPIN_FLDRLNK, BST_UNCHECKED);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_FIRSTPIN_FLDRLNK), !bNoCacheViewer);

    return CWizardPage::OnInitDialog(wParam, lParam);
}


//
// PSN_WIZFINISH handler.
//
BOOL 
CWizardPgOffline::OnPSNWizFinish(
    void
    )
{
    //
    // Send PSM_QUERYSIBLINGS to all of the pages with
    // wParam set to WM_WIZARDFINISHED.  This will trigger
    // a call to the virtual function OnWizardFinished()
    // allowing each page to respond to the successful completion
    // of the wizard.
    //
    PropSheet_QuerySiblings(GetParent(m_hwndDlg),
                            CWizardPage::WM_WIZARDFINISHED,
                            0);
    //
    // Now handle for this page.
    //
    OnWizardFinished();
    return CWizardPage::OnPSNWizFinish();
}




//
// PSN_WIZFINISH handler.
//
BOOL 
CWizardPgOffline::OnWizardFinished(
    void
    )
{
    bool bEnableReminders = (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_REMINDERS));
    DWORD dwValue;
    DWORD dwErr;
    
    dwValue = bEnableReminders ? 0 : 1;

    dwErr = SHSetValue(HKEY_CURRENT_USER, 
                       REGSTR_KEY_OFFLINEFILES,
                       REGSTR_VAL_NOREMINDERS, 
                       REG_DWORD,
                       &dwValue,
                       sizeof(dwValue));

    if (bEnableReminders)
    {
        PostToSystray(PWM_RESET_REMINDERTIMER, 0, 0);
    }

    if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_FIRSTPIN_FLDRLNK))
    {
        COfflineFilesFolder::CreateLinkOnDesktop(m_hwndDlg);
    }

    return CWizardPage::OnWizardFinished();
}


//
// CFirstPinWizard members ----------------------------------------------------
//
CFirstPinWizard::CFirstPinWizard(
    HINSTANCE hInstance,
    HWND hwndParent
    ) : m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_PgWelcome(hInstance,
            IDD_FIRSTPIN_WELCOME, 
            0,
            0,
            PSP_DEFAULT,
            PSWIZB_NEXT),
        m_PgPin(hInstance,
            IDD_FIRSTPIN_PIN, 
            0,
            0,
            PSP_DEFAULT,
            PSWIZB_NEXT | PSWIZB_BACK),
        m_PgOffline(hInstance,
            IDD_FIRSTPIN_OFFLINE,
            0,
            0,
            PSP_DEFAULT,
            PSWIZB_FINISH | PSWIZB_BACK)
{
    //
    // Store pointers to each page in an array.  Makes creating the
    // prop sheet easier in Run().
    //
    m_rgpWizPages[0] = &m_PgWelcome;
    m_rgpWizPages[1] = &m_PgPin;
    m_rgpWizPages[2] = &m_PgOffline;
}


//
// Creates the wizard and runs it.
// The wizard runs modally.
//
// Returns:  
//
//   S_OK    = User completed wizard and pressed "Finish".
//   S_FALSE = User pressed "Cancel" in wizard.
//   Other   = Error creating wizard.
//
HRESULT
CFirstPinWizard::Run(
    void
    )
{
    HRESULT hr = NOERROR;

    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE rghpage[ARRAYSIZE(m_rgpWizPages)];

    ZeroMemory(&psh, sizeof(psh));
    ZeroMemory(rghpage, sizeof(rghpage));

    psh.dwSize         = sizeof(psh);
    psh.dwFlags        = PSH_WIZARD_LITE;
    psh.hwndParent     = m_hwndParent;
    psh.hInstance      = m_hInstance;
    psh.nPages         = ARRAYSIZE(rghpage);
    psh.phpage         = rghpage;

    for (int i = 0; i < ARRAYSIZE(rghpage) && SUCCEEDED(hr); i++)
    {
        CWizardPage *pwp = m_rgpWizPages[i];
        ZeroMemory(&psp, sizeof(psp));

        psp.dwSize        = sizeof(psp);
        psp.dwFlags       |= pwp->GetPageFlags();
        psp.hInstance     = m_hInstance;
        psp.pszTemplate   = MAKEINTRESOURCE(pwp->GetDlgTemplate());
        psp.pfnDlgProc    = pwp->GetDlgProc();
        psp.lParam        = (LPARAM)pwp;

        rghpage[i] = CreatePropertySheetPage(&psp);
        if (NULL == rghpage[i])
        {
            while(0 <= --i)
            {
                DestroyPropertySheetPage(rghpage[i]);
            }
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        switch(PropertySheet(&psh))
        {
            case -1:
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;

            case 0:
                hr = S_FALSE; // User pressed "Cancel".
                break;

            case 1:
                hr = S_OK;    // User pressed "Finish".
                break;
        }
    }
            
    return hr;
}


//
// This is the function you call when you want to run the wizard.
// It merely creates a wizard object and tells it to run.
// If the user finishes the wizard, it records this fact in the
// registry.  Calling FirstPinWizardCompleted() will tell
// you later if the user has finished the wizard.
//
// Returns:
//
//  S_OK    = User completed wizard and pressed "Finish".
//  S_FALSE = User cancelled out of wizard.
//  Other   = Error creating wizard.
//
HRESULT
ShowFirstPinWizard(
    HWND hwndParent
    )
{
    HRESULT hr = NOERROR;
    CFirstPinWizard Wizard(g_hInstance, hwndParent);
    hr = Wizard.Run();
    if (S_OK == hr)
    {
        //
        // Only record "finished" in registry if user
        // pressed "finish".
        //
        DWORD dwValue = 1;
        SHSetValue(HKEY_CURRENT_USER, REGSTR_KEY_OFFLINEFILES, REGSTR_VAL_FIRSTPINWIZARDSHOWN, REG_DWORD, &dwValue, sizeof(dwValue));
    }
    return hr;
}

//
// Has user seen the wizard and pressed "finish"?
//
bool
FirstPinWizardCompleted(
    void
    )
{
    return CConfig::GetSingleton().FirstPinWizardShown();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\folder.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       folder.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shguidp.h>
#include <shdguid.h>
#include <shlapip.h>
#include <shlobjp.h>
#include <shsemip.h>
#include "folder.h"
#include "resource.h"
#include "idldata.h"
#include "items.h"
#include "strings.h"
#include "msgbox.h"
#include "sharecnx.h"
#include "msg.h"
#include "security.h"


//
// This module contains several classes.  Here's a summary list.
//
// COfflineFilesFolder - Implementation for IShellFolder
//
// COfflineDetails - Implementation for IShellDetails
//
// COfflineFilesViewCallback - Implementation for IShellFolderViewCB
//
// COfflineFilesDropTarget - Implementation for IDropTarget
//
// COfflineFilesViewEnum - Implementation for IEnumSFVViews
//
// CShellObjProxy<T> - Template class that encapsulates the attainment of a 
//     shell object and item ID list for a given OLID and interface
//     type.  Also ensures proper cleanup of the interface pointer
//     and ID list.
//
// CFolderCache - A simple cache of a bound shell object pointer
//     and item ID lists for associated OLIDs.  Reduces the number
//     of binds required in the shell namespace.  A singleton instance
//     is used for all cache accesses.
//
// CFolderDeleteHandler - Centralizes folder item deletion code.
//
// CFileTypeCache - Cache of file type descriptions.  This reduces the number
//     of calls to SHGetFileInfo.
//


// 
// Columns
//
enum {
    ICOL_NAME = 0,
    ICOL_TYPE,
    ICOL_SYNCSTATUS,
    ICOL_PINSTATUS,
    ICOL_ACCESS,
    ICOL_SERVERSTATUS,
    ICOL_LOCATION,
    ICOL_SIZE,
    ICOL_DATE,
    ICOL_MAX
};

typedef struct 
{
    short int icol;       // column index
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} COL_DATA;

const COL_DATA c_cols[] = {
    {ICOL_NAME,        IDS_COL_NAME,        20, LVCFMT_LEFT},
    {ICOL_TYPE,        IDS_COL_TYPE,        20, LVCFMT_LEFT},
    {ICOL_SYNCSTATUS,  IDS_COL_SYNCSTATUS,  18, LVCFMT_LEFT},
    {ICOL_PINSTATUS,   IDS_COL_PINSTATUS,   18, LVCFMT_LEFT},
    {ICOL_ACCESS,      IDS_COL_ACCESS,      18, LVCFMT_LEFT},
    {ICOL_SERVERSTATUS,IDS_COL_SERVERSTATUS,18, LVCFMT_LEFT},
    {ICOL_LOCATION,    IDS_COL_LOCATION,    18, LVCFMT_LEFT},
    {ICOL_SIZE,        IDS_COL_SIZE,        16, LVCFMT_RIGHT},
    {ICOL_DATE,        IDS_COL_DATE,        20, LVCFMT_LEFT}
};


//
// This is a special GUID used by the folder's delete handler to obtain
// the IShellFolderViewCB pointer from the COfflineFilesFolder.
// The delete handler QI's for this "interface".  If the folder knows
// about it (only the COfflineFilesFolder will) then it returns it's
// IShellFolderViewCB pointer.  See COfflineFilesFolder::QueryInterface()
// and CFolderDeleteHandler::InvokeCommand for usage.
//
// {47862305-0417-11d3-8BED-00C04FA31A66}
static const GUID IID_OfflineFilesFolderViewCB = 
{ 0x47862305, 0x417, 0x11d3, { 0x8b, 0xed, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66 } };

//
// Private message used to enable/disable redraw of the listview
// through the MessageSFVCB method of the folder view callback.
// See CFolderDeleteHandler::DeleteFiles and 
// COfflineFilesViewCallback::OnSFVMP_SetViewRedraw for usage.
//
const UINT SFVMP_SETVIEWREDRAW = 1234;
const UINT SFVMP_DELVIEWITEM   = 1235;

#if defined(ALIGNMENT_MACHINE)
LONG
__inline
static
uaCompareFileTime(
    IN FILETIME CONST UNALIGNED *UaFileTime1,
    IN FILETIME CONST UNALIGNED *UaFileTime2
    )
{
    FILETIME fileTime1;
    FILETIME fileTime2;

    fileTime1 = *UaFileTime1;
    fileTime2 = *UaFileTime2;

    return CompareFileTime( &fileTime1, &fileTime2 );
}
#else
#define uaCompareFileTime CompareFileTime
#endif

HRESULT StringToStrRet(LPCTSTR pString, STRRET *pstrret)
{
    HRESULT hr = SHStrDup(pString, &pstrret->pOleStr);
    if (SUCCEEDED(hr))
    {
        pstrret->uType = STRRET_WSTR;
    }
    return hr;
}


//---------------------------------------------------------------------------
// Shell view details
//---------------------------------------------------------------------------
class COfflineDetails : public IShellDetails
{
public:
    COfflineDetails(COfflineFilesFolder *pFav);
    
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void ** ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // IshellDetails
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails);
    STDMETHOD(ColumnClick)(UINT iColumn);

protected:
    ~COfflineDetails();
    COfflineFilesFolder *_pfolder;
    LONG _cRef;
};


//---------------------------------------------------------------------------
// Folder view callback
//---------------------------------------------------------------------------
class COfflineFilesViewCallback : public IShellFolderViewCB, IObjectWithSite
{
public:
    COfflineFilesViewCallback(COfflineFilesFolder *pfolder);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellFolderViewCB
    STDMETHOD(MessageSFVCB)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppv);

private:
    LONG _cRef;
    COfflineFilesFolder *_pfolder;
    IShellFolderView    *_psfv;
    HWND m_hwnd;
    CRITICAL_SECTION m_cs;    // Serialize change notify handling.

    ~COfflineFilesViewCallback();

    DWORD GetChangeNotifyEvents(void) const
        { return (SHCNE_UPDATEITEM | SHCNE_UPDATEDIR | SHCNE_RENAMEITEM | SHCNE_DELETE); }

    HRESULT OnSFVM_WindowCreated(HWND hwnd);
    HRESULT OnSFVM_AddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA *ppagedata);
    HRESULT OnSFVM_QueryFSNotify(SHChangeNotifyEntry *pfsne);
    HRESULT OnSFVM_FSNotify(LPCITEMIDLIST *ppidl, LONG lEvent);
    HRESULT OnSFVM_GetNotify(LPITEMIDLIST *ppidl, LONG *plEvents);
    HRESULT OnSFVM_GetViews(SHELLVIEWID *pvid, IEnumSFVViews **ppev);
    HRESULT OnSFVM_AlterDropEffect(DWORD *pdwEffect, IDataObject *pdtobj);
    HRESULT OnSFVMP_SetViewRedraw(BOOL bRedraw);
    HRESULT OnSFVMP_DelViewItem(LPCTSTR pszPath);
    HRESULT UpdateDir(LPCTSTR pszDir);
    HRESULT UpdateItem(LPCTSTR pszItem);
    HRESULT UpdateItem(LPCTSTR pszPath, const WIN32_FIND_DATA& fd, DWORD dwStatus, DWORD dwPinCount, DWORD dwHintFlags);
    HRESULT RemoveItem(LPCTSTR pszPath);
    HRESULT RemoveItem(LPCOLID polid);
    HRESULT RemoveItems(LPCTSTR pszDir);
    HRESULT RenameItem(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidl);

    UINT ItemIndexFromOLID(LPCOLID polid);
    HRESULT FindOLID(LPCTSTR pszPath, LPCOLID *ppolid);

    void Lock(void)
        { EnterCriticalSection(&m_cs); }

    void Unlock(void)
        { LeaveCriticalSection(&m_cs); }
};

//---------------------------------------------------------------------------
// Drop target
//---------------------------------------------------------------------------
class COfflineFilesDropTarget : public IDropTarget
{
    public:
        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // IDropTarget
        STDMETHODIMP DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
        STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
        STDMETHODIMP DragLeave(void);
        STDMETHODIMP Drop(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);

        static HRESULT CreateInstance(HWND hwnd, REFIID riid, void **ppv);

    private:
        COfflineFilesDropTarget(HWND hwnd);
        ~COfflineFilesDropTarget();

        bool IsOurDataObject(IDataObject *pdtobj);

        LONG m_cRef;
        HWND m_hwnd;
        LPCONTEXTMENU m_pcm;
        bool m_bIsOurData;
};


//---------------------------------------------------------------------------
// View type enumerator
//---------------------------------------------------------------------------
class COfflineFilesViewEnum : public IEnumSFVViews
{
    public:
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

        // *** IEnumSFVViews methods ***
        STDMETHOD(Next)(ULONG celt, SFVVIEWSDATA **ppData, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)(void);
        STDMETHOD(Clone)(IEnumSFVViews **ppenum);

        static HRESULT CreateInstance(IEnumSFVViews **ppEnum);
        
    protected:
        COfflineFilesViewEnum(void);
        ~COfflineFilesViewEnum(void);

        LONG           m_cRef;
        int            m_iAddView;
};


//-------------------------------------------------------------------------
// Shell object proxy
//
// A simple template class to package up the attainment of a 
// shell object pointer and item PIDL from our folder cache for a given OLID.  
// The caller can then easily call the appropriate shell object function
// through operator ->().  The object automates the release of the shell 
// object interface and freeing of the IDList.  Caller must call Result()
// to verify validity of contents prior to invoking operator ->().
//
// Usage:
//
//      CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, polid);
//      if (SUCCEEDED(hr = pxy.Result()))
//      {
//          hr = pxy->GetIconOf(pxy.ItemIDList(), gil, pnIcon);
//      }
//
//-------------------------------------------------------------------------
template <class T>
class CShellObjProxy
{
    public:
        CShellObjProxy(REFIID riid, LPCOLID polid)
            : m_hr(E_INVALIDARG),
              m_pObj(NULL),
              m_pidlFull(NULL),
              m_pidlItem(NULL)
            {
                if (NULL != polid)
                {
                    m_hr = CFolderCache::Singleton().GetItem(polid,
                                                             riid,
                                                             (void **)&m_pObj,
                                                             &m_pidlFull,
                                                             &m_pidlItem);
                }
            }

        ~CShellObjProxy(void)
            { 
                if (NULL != m_pidlFull)
                    ILFree(m_pidlFull);
                if (NULL != m_pObj)
                    m_pObj->Release();
            }

        HRESULT Result(void) const
            { return m_hr; }

        T* operator -> () const
            { return m_pObj; }

        LPCITEMIDLIST ItemIDList(void) const
            { return m_pidlItem; }

    private:
        HRESULT       m_hr;
        T            *m_pObj;
        LPITEMIDLIST  m_pidlFull;
        LPCITEMIDLIST m_pidlItem;
};



//-----------------------------------------------------------------------------------
// Folder cache
//
// The OfflineFiles folder IDList format (OLID) contains fully-qualified UNC paths.
// The folder may (most likely) contain OLIDs from multiple network shares.
// Therefore, when creating IDLists to hand off to the shell's filesystem 
// implementations we create fully-qualified IDLists (an expensive operation).
// The folder cache is used to cache these IDLists to reduce the number of calls 
// to SHBindToParent.  This also speeds up filling of the listview as 
// GetAttributesOf(), GetIconIndex() etc. are called many times as the view
// is opened.
//
// The implementation is a simple circular queue to handle aging of items.
// Only three public methods are exposed.  GetItem() is used to 
// retrieve the IShellFolder ptr and IDList associated with a particular OLID.
// If the item is not in the cache, the implementation obtains the shell folder
// ptr and IDList then caches them for later use.  Clear() is used to clear the 
// contents of the cache to reduce memory footprint when the Offline Files
// folder is no longer open. 
//
// The entries in the queue utilize a handle-envelope idiom to hide memory
// management of the entries from the caching code.  This way we can assign
// handle values without copying the actual use-counted entry.  Once a use-count
// drops to 0 the actual entry is deleted.
//
// A singleton instance is enforced through a private ctor.  Use the
// Singleton() method to obtain a reference to the singleton.
//
// Note that because of the shell's icon thread this cache must be thread-safe.
// A critical section is used for this.
//-----------------------------------------------------------------------------------
class CFolderCache 
{
    public:
        ~CFolderCache(void);

        //
        // Retrieve one item from the cache.  Item is added if not in cache.
        //
        HRESULT GetItem(
            LPCOLID polid, 
            REFIID riid, 
            void **ppv, 
            LPITEMIDLIST *ppidl, 
            LPCITEMIDLIST *ppidlChild);

        //
        // Clear the cache entry data.
        //
        void Clear(void);
        //
        // Return reference to the singleton instance.
        //
        static CFolderCache& Singleton(void);

    private:
        //
        // Enforce singleton existence.
        //
        CFolderCache(void);
        //
        // Prevent copy.
        //
        CFolderCache(const CFolderCache& rhs);
        CFolderCache& operator = (const CFolderCache& rhs);

        LPOLID           m_polid; // Key olid.
        IShellFolder    *m_psf;   // Cached IShellFolder ptr.
        LPITEMIDLIST     m_pidl;  // Cached shell pidl.
        CRITICAL_SECTION m_cs;    // For synchronizing cache access.

        void Lock(void)
            { EnterCriticalSection(&m_cs); }

        void Unlock(void)
            { LeaveCriticalSection(&m_cs); }
};


//----------------------------------------------------------------------------
// COfflineDetails
//----------------------------------------------------------------------------

STDMETHODIMP 
COfflineDetails::GetDetailsOf(
    LPCITEMIDLIST pidl, 
    UINT iColumn, 
    LPSHELLDETAILS pDetails
    )
{
    TCHAR szTemp[MAX_PATH];
    HRESULT hres;

    if (!pidl)
    {
        if (iColumn < ICOL_MAX)
        {
            pDetails->fmt    = c_cols[iColumn].iFmt;
            pDetails->cxChar = c_cols[iColumn].cchCol;

            LoadString(g_hInstance, c_cols[iColumn].ids, szTemp, ARRAYSIZE(szTemp));
            hres = StringToStrRet(szTemp, &pDetails->str);
        }
        else
        {
            pDetails->str.uType = STRRET_CSTR;
            pDetails->str.cStr[0] = 0;
            hres = E_NOTIMPL;
        }
    }
    else
    {
        LPCOLID polid = _pfolder->_Validate(pidl);
        if (polid)
        {
            hres = S_OK;

            // Need to fill in the details
            switch (iColumn)
            {
            case ICOL_TYPE:
                _pfolder->_GetTypeString(polid, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_SYNCSTATUS:
                _pfolder->_GetSyncStatusString(polid, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_PINSTATUS:
                _pfolder->_GetPinStatusString(polid, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_ACCESS:
                _pfolder->_GetAccessString(polid, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_SERVERSTATUS:
                _pfolder->_GetServerStatusString(polid, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_LOCATION:
                ualstrcpyn(szTemp, polid->szPath, ARRAYSIZE(szTemp));
                break;

            case ICOL_SIZE:
            {
                ULARGE_INTEGER ullSize = {polid->dwFileSizeLow, polid->dwFileSizeHigh};
                StrFormatKBSize(ullSize.QuadPart, szTemp, ARRAYSIZE(szTemp));
                break;
            }

            case ICOL_DATE:
                SHFormatDateTime(&polid->ft, NULL, szTemp, ARRAYSIZE(szTemp));
                break;

            default:
                hres = E_FAIL;
            }

            if (SUCCEEDED(hres))
                hres = StringToStrRet(szTemp, &pDetails->str);
        }
        else
            hres = E_INVALIDARG;
    }
    return hres;
}



STDMETHODIMP 
COfflineDetails::ColumnClick(
    UINT iColumn
    )
{
    return S_FALSE;     // bounce this to the IShellFolderViewCB handler
}


//----------------------------------------------------------------------------
// CFolderCache
//----------------------------------------------------------------------------
//
// This is a very simple cache of one entry.
// Originally I implemented a multi-item cache.  This of course had more
// overhead than a single-item cache.  The problem is that the access patterns
// in the folder are such that cache hits occur consecutively for the
// same item as the view is filling.  Rarely (or never) was there a hit
// for an item other than the most-recently-added item.  Therefore, items
// 1 through n-1 were just taking up space.  This is why I went back to using
// a single-item cache. [brianau - 5/27/99]
//

//
// Returns a reference to the global shell folder cache.
// Since the folder cache object is a function static it will not be created
// until this function is first called.  That also means it will not be
// destroyed until the module is unloaded.  That's why we have the Clear() method.
// The FolderViewCallback dtor clears the cache so that we don't have cached
// info laying around in memory while the Offline Files folder isn't open.
// The cache skeleton is very cheap so that's not a problem to leave in memory.
//
CFolderCache& 
CFolderCache::Singleton(
    void
    )
{
    static CFolderCache TheFolderCache;
    return TheFolderCache;
}


CFolderCache::CFolderCache(
    void
    ) : m_polid(NULL),
        m_pidl(NULL),
        m_psf(NULL)
{
    InitializeCriticalSection(&m_cs); 
}



CFolderCache::~CFolderCache(
    void
    )
{ 
    Clear();
    DeleteCriticalSection(&m_cs); 
}

//
// Clear the cache by deleting the queue array and
// resetting the head/tail indexes.  A subsequent call to
// GetItem() will re-initialize the queue.
//
void 
CFolderCache::Clear(
    void
    )
{
    Lock();

    if (m_polid)
    {
        ILFree((LPITEMIDLIST)m_polid);
        m_polid = NULL;
    }
    if (m_pidl)
    {
        ILFree(m_pidl);
        m_pidl = NULL;
    }
    if (m_psf)
    {
        m_psf->Release();
        m_psf = NULL;
    }

    Unlock();
}


//
// Retrieve an item from the cache. If not found, bind to
// and cache a new one.
//
HRESULT
CFolderCache::GetItem(
    LPCOLID polid, 
    REFIID riid,
    void **ppv,
    LPITEMIDLIST *ppidlParent, 
    LPCITEMIDLIST *ppidlChild
    )
{
    TraceAssert(NULL != polid);
    TraceAssert(NULL != ppv);
    TraceAssert(NULL != ppidlParent);
    TraceAssert(NULL != ppidlChild);

    HRESULT hr = NOERROR;

    *ppidlParent = NULL;
    *ppidlChild = NULL;
    *ppv = NULL;

    Lock();

    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    LPITEMIDLIST pidl;
    if (NULL == m_polid || !ILIsEqual((LPCITEMIDLIST)m_polid, (LPCITEMIDLIST)polid))
    {
        //
        // Cache miss.
        //
        Clear();
        hr = COfflineFilesFolder::OLID_Bind(polid, 
                                            IID_IShellFolder, 
                                            (void **)&psf, 
                                            (LPITEMIDLIST *)&pidl, 
                                            &pidlChild);
        if (SUCCEEDED(hr))
        {
            //
            // Cache the new item.
            //
            m_polid = (LPOLID)ILClone((LPCITEMIDLIST)polid);
            if (NULL != m_polid)
            {
                m_pidl  = pidl;      // Take ownership of pidl from Bind
                m_psf   = psf;       // Use ref count from Bind.
            }
            else
            {
                ILFree(pidl);
                m_psf->Release();
                hr = E_OUTOFMEMORY;
            }
        }
    }
        
    if (SUCCEEDED(hr))
    {
        //
        // Cache hit or we just bound and cached a new item.
        //
        *ppidlParent = ILClone(m_pidl);
        if (NULL != *ppidlParent)
        {
            *ppidlChild  = ILFindLastID(*ppidlParent);
            hr = m_psf->QueryInterface(riid, ppv);
        }
    }
    Unlock();
    return hr;
}


//----------------------------------------------------------------------------
// CFolderDeleteHandler
//----------------------------------------------------------------------------

CFolderDeleteHandler::CFolderDeleteHandler(
    HWND hwndParent,
    IDataObject *pdtobj,
    IShellFolderViewCB *psfvcb
    ) : m_hwndParent(hwndParent),
        m_pdtobj(pdtobj),
        m_psfvcb(psfvcb)
{
    TraceAssert(NULL != pdtobj);

    if (NULL != m_pdtobj)
        m_pdtobj->AddRef();

    if (NULL != m_psfvcb)
        m_psfvcb->AddRef();
}


CFolderDeleteHandler::~CFolderDeleteHandler(
    void
    )
{
    if (NULL != m_pdtobj)
        m_pdtobj->Release();

    if (NULL != m_psfvcb)
        m_psfvcb->Release();
}


//
// This function deletes files from the cache while also displaying
// standard shell progress UI.
//
HRESULT
CFolderDeleteHandler::DeleteFiles(
    void
    )
{
    HRESULT hr = E_FAIL;

    if (!ConfirmDeleteFiles(m_hwndParent))
        return S_FALSE;

    if (NULL != m_pdtobj)
    {
        //
        // Retrieve the selection as an HDROP.
        //
        FORMATETC fe = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium;

        hr = m_pdtobj->GetData(&fe, &medium);
        if (SUCCEEDED(hr))
        {
            LPDROPFILES pDropFiles = (LPDROPFILES)GlobalLock(medium.hGlobal);
            if (NULL != pDropFiles)
            {
                //
                // Create the progress dialog.
                //
                IProgressDialog *ppd;
                if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, 
                                               NULL, 
                                               CLSCTX_INPROC_SERVER, 
                                               IID_IProgressDialog, 
                                               (void **)&ppd)))
                {
                    //
                    // Init and start the progress dialog.
                    //
                    TCHAR szCaption[80];
                    TCHAR szLine1[80];
                    LPTSTR pszFileList = (LPTSTR)((LPBYTE)pDropFiles + pDropFiles->pFiles);
                    LPTSTR pszFile     = pszFileList;
                    int cFiles = 0;
                    int iFile  = 0;
                    bool bCancelled = false;
                    bool bNoToAll   = false;

                    //
                    // Count the number of files in the list.
                    //
                    while(TEXT('\0') != *pszFile && !bCancelled)
                    {
                        //
                        // Need to guard against deleting files that have offline
                        // changes but haven't been synchronized.  User may want
                        // to delete these but we give them lot's of warning.
                        //
                        if (FileModifiedOffline(pszFile) &&
                           (bNoToAll || !ConfirmDeleteModifiedFile(m_hwndParent, 
                                                                   pszFile, 
                                                                   &bNoToAll, 
                                                                   &bCancelled)))
                        {
                            //
                            // "Remove" this file from the list by replacing the
                            // first char with a '*'.  We'll use this as an indicator
                            // when scanning through the file list during the deletion
                            // phase below.
                            //
                            *pszFile = TEXT('*');
                            cFiles--;
                        }
                        while(*pszFile)
                            pszFile++;
                        pszFile++;
                        cFiles++;
                    }

                    if (!bCancelled)
                    {
                        LoadString(g_hInstance, IDS_APPLICATION, szCaption, ARRAYSIZE(szCaption));
                        LoadString(g_hInstance, IDS_DELFILEPROG_LINE1, szLine1, ARRAYSIZE(szLine1));
                        ppd->SetTitle(szCaption);
                        ppd->SetLine(1, szLine1, FALSE, NULL);
                        ppd->SetAnimation(g_hInstance, IDA_FILEDEL);
                        ppd->StartProgressDialog(m_hwndParent, 
                                                 NULL, 
                                                 PROGDLG_AUTOTIME | PROGDLG_MODAL, 
                                                 NULL);
                    }

                    //
                    // Process the files in the list.
                    //
                    CShareCnxStatusCache CnxStatus;

                    BOOL bUserIsAdmin = IsCurrentUserAnAdminMember();
                    //
                    // Disable redraw on the view to avoid flicker.
                    //
                    m_psfvcb->MessageSFVCB(SFVMP_SETVIEWREDRAW, 0, 0);
                    
                    pszFile = pszFileList;

                    while(TEXT('\0') != *pszFile && !bCancelled)
                    {
                        //
                        // If the file wasn't excluded from deletion above
                        // by replacing the first character with '*', delete it.
                        //
                        if (TEXT('*') != *pszFile)
                        {
                            DWORD dwErr = ERROR_ACCESS_DENIED;

                            ppd->SetLine(2, pszFile, FALSE, NULL);
                            if (bUserIsAdmin || !OthersHaveAccess(pszFile))
                            {
                                dwErr = CscDelete(pszFile);
                                if (ERROR_ACCESS_DENIED == dwErr)
                                {
                                    //
                                    // This is a little weird.  CscDelete
                                    // returns ERROR_ACCESS_DENIED if there's
                                    // a handle open on the file. Set the
                                    // code to ERROR_BUSY so we know to handle 
                                    // this as a special case below.
                                    //
                                    dwErr = ERROR_BUSY;
                                }
                            }
                            if (ERROR_SUCCESS == dwErr)
                            {
                                //
                                // File was deleted.
                                //
                                if (S_OK == CnxStatus.IsOpenConnectionPathUNC(pszFile))
                                {
                                    //
                                    // Post a shell chg "update" notify if there's
                                    // an open connection to the path.  Deleting
                                    // something from the cache will remove the 
                                    // "pinned" icon overlay in shell filesystem folders.
                                    //
                                    ShellChangeNotify(pszFile, NULL, iFile == cFiles, SHCNE_UPDATEITEM);
                                }
                                m_psfvcb->MessageSFVCB(SFVMP_DELVIEWITEM, 0, (LPARAM)pszFile);
                            }
                            else
                            {
                                //
                                // Error deleting file.
                                //
                                HWND hwndProgress = GetProgressDialogWindow(ppd);
                                INT iUserResponse = IDOK;
                                if (ERROR_BUSY == dwErr)
                                {
                                    //
                                    // Special handling for ERROR_BUSY.
                                    //
                                    iUserResponse = CscMessageBox(hwndProgress ? hwndProgress : m_hwndParent,
                                                                  MB_OKCANCEL | MB_ICONERROR,
                                                                  g_hInstance,
                                                                  IDS_FMT_ERR_DELFROMCACHE_BUSY, 
                                                                  pszFile);
                                }
                                else
                                {
                                    //
                                    // Hit an error deleting file.  Display message and 
                                    // give user a chance to cancel operation.
                                    //
                                    iUserResponse = CscMessageBox(hwndProgress ? hwndProgress : m_hwndParent,
                                                                  MB_OKCANCEL | MB_ICONERROR,
                                                                  Win32Error(dwErr),
                                                                  g_hInstance,
                                                                  IDS_FMT_DELFILES_ERROR,
                                                                  pszFile);
                                }                                                              
                                bCancelled = bCancelled || IDCANCEL == iUserResponse;
                            }
                            ppd->SetProgress(iFile++, cFiles);
                            bCancelled = bCancelled || ppd->HasUserCancelled();
                        }

                        while(*pszFile)
                            pszFile++;
                        pszFile++;
                    }
                    //
                    // Clean up the progress dialog.
                    //
                    ppd->StopProgressDialog();
                    ppd->Release();
                    m_psfvcb->MessageSFVCB(SFVMP_SETVIEWREDRAW, 0, 1);
                }
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}



//
// Inform user they're deleting only the offline copy of the
// selected file(s) and that the file(s) will no longer be
// available offline once they're deleted.  The dialog also
// provides a "don't bug me again" checkbox.  This setting
// is saved per-user in the registry.
//
// Returns:
//
//      true  = User pressed [OK] or had checked "don't show me
//              this again" at some time in the past.
//      false = User cancelled operation.
//
bool
CFolderDeleteHandler::ConfirmDeleteFiles(
    HWND hwndParent
    )
{
    //
    // See if user has already seen this dialog and checked 
    // the "don't bug me again" checkbox".
    //
    DWORD dwType  = REG_DWORD;
    DWORD cbData  = sizeof(DWORD);
    DWORD bNoShow = 0;
    SHGetValue(HKEY_CURRENT_USER,
               c_szCSCKey,
               c_szConfirmDelShown,
               &dwType,
               &bNoShow,
               &cbData);

    return bNoShow || IDOK == DialogBox(g_hInstance,
                                        MAKEINTRESOURCE(IDD_CONFIRM_DELETE),
                                        hwndParent,
                                        ConfirmDeleteFilesDlgProc);
}


INT_PTR
CFolderDeleteHandler::ConfirmDeleteFilesDlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
        {
            UINT idCmd = LOWORD(wParam);
            switch(LOWORD(idCmd))
            {
                case IDOK:
                {
                    //
                    // Save the "Don't bug me" value if the checkbox is 
                    // checked.  If it's not checked, no need to take up
                    // reg space with a 0 value.
                    //
                    if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CBX_CONFIRMDEL_NOSHOW))
                    {
                        DWORD dwNoShow = 1;
                        SHSetValue(HKEY_CURRENT_USER,
                                   c_szCSCKey,
                                   c_szConfirmDelShown,
                                   REG_DWORD,
                                   &dwNoShow,
                                   sizeof(dwNoShow));
                    }
                    EndDialog(hwnd, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hwnd, IDCANCEL);
                    break;

                default:
                    break;
            }
        }
        break;
    }
    return FALSE;
}


//
// Inform user that the file they're about to delete has been 
// modified offline and the changes haven't been synchronized.
// Ask if they still want to delete it.
// The choices are Yes, No, NoToAll, Cancel.
//
//
//  Arguments:
//
//      hwndParent - Dialog parent.
//
//      pszFile   - Address of filename string to embed in 
//                  dialog text.  Passed to dialog proc in the
//                  LPARAM of DialogBoxParam.
//
//      pbNoToAll - On return, indicates if the user pressed
//                  the "No To All" button.
//
//      pbCancel  - On return, indicates if the user pressed
//                  the "Cancel" button.
//  Returns:
//
//      true   = Delete it.
//      false  = Don't delete it.
//
bool
CFolderDeleteHandler::ConfirmDeleteModifiedFile(
    HWND hwndParent,
    LPCTSTR pszFile,
    bool *pbNoToAll,
    bool *pbCancel
    )
{
    TraceAssert(NULL != pszFile);
    TraceAssert(NULL != pbNoToAll);
    TraceAssert(NULL != pbCancel);

    INT_PTR iResult = DialogBoxParam(g_hInstance,
                                     MAKEINTRESOURCE(IDD_CONFIRM_DELETEMOD),
                                     hwndParent,
                                     ConfirmDeleteModifiedFileDlgProc,
                                     (LPARAM)pszFile);
    bool bResult = false;
    *pbNoToAll   = false;
    *pbCancel    = false;
    switch(iResult)
    {
        case IDYES:
            bResult = true;
            break;

        case IDCANCEL:
            *pbCancel = true;
            break;

        case IDIGNORE:
            *pbNoToAll = true;
            break;

        case IDNO:
        default:
            break;
    }
    return bResult;
}


INT_PTR
CFolderDeleteHandler::ConfirmDeleteModifiedFileDlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            //
            // lParam is the address of the filename string to be
            // embedded in the dialog text.  If the path is too long
            // to fit in the text control, shorten it with an embedded
            // ellipsis.
            //
            LPTSTR pszPath = NULL;
            if (LocalAllocString(&pszPath, (LPCTSTR)lParam))
            {
                LPTSTR pszText = NULL;
                RECT rc;

                GetWindowRect(GetDlgItem(hwnd, IDC_TXT_CONFIRM_DELETEMOD), &rc);
                PathCompactPath(NULL, pszPath, rc.right - rc.left);

                FormatStringID(&pszText,
                               g_hInstance,
                               IDS_CONFIRM_DELETEMOD,
                               pszPath);

                if (NULL != pszText)
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_TXT_CONFIRM_DELETEMOD), pszText);
                    LocalFree(pszText);
                }
                LocalFreeString(&pszPath);
            }
            return TRUE;
        }

        case WM_COMMAND:
            EndDialog(hwnd, LOWORD(wParam));
            break;

        default:
            break;
    }
    return FALSE;
}


//
// Determine if a particular file has been modified offline.
//
bool
CFolderDeleteHandler::FileModifiedOffline(
    LPCTSTR pszFile
    )
{
    TraceAssert(NULL != pszFile);

    DWORD dwStatus = 0;
    CSCQueryFileStatus(pszFile, &dwStatus, NULL, NULL);
    return 0 != (FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY & dwStatus);
}


//
// Determine if a particular file can be access by another
// user other than guest.
//
bool
CFolderDeleteHandler::OthersHaveAccess(
    LPCTSTR pszFile
    )
{
    TraceAssert(NULL != pszFile);

    DWORD dwStatus = 0;
    CSCQueryFileStatus(pszFile, &dwStatus, NULL, NULL);

    return CscAccessOther(dwStatus);
}


//----------------------------------------------------------------------------
// COfflineFilesFolder
//----------------------------------------------------------------------------

COfflineFilesFolder::COfflineFilesFolder(
    void
    ) : _cRef(1),
        _psfvcb(NULL),        // Non ref-counted interface ptr.
        m_FileTypeCache(101)  // Bucket count should be prime.
{ 
    DllAddRef(); 
    _pidl = NULL;
}

COfflineFilesFolder::~COfflineFilesFolder(
    void
    )
{ 
    if (_pidl)
        ILFree(_pidl);
    DllRelease(); 
}

// class factory constructor

STDAPI 
COfflineFilesFolder_CreateInstance(
    REFIID riid, 
    void **ppv
    )
{
    HRESULT hr;

    COfflineFilesFolder* polff = new COfflineFilesFolder();
    if (polff)
    {
        hr = polff->QueryInterface(riid, ppv);
        polff->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}



LPCOLID 
COfflineFilesFolder::_Validate(
    LPCITEMIDLIST pidl
    )
{
    LPCOLID polid = (LPCOLID)pidl;
    if (polid && (polid->cbFixed == sizeof(*polid)) && (polid->uSig == OLID_SIG))
        return polid;
    return NULL;
}


//
// External version of _Validate but returns only T/F.
//
bool 
COfflineFilesFolder::ValidateIDList(
    LPCITEMIDLIST pidl
    )
{
    return NULL != _Validate(pidl);
}


STDMETHODIMP 
COfflineFilesFolder::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineFilesFolder, IShellFolder),
        QITABENT(COfflineFilesFolder, IPersistFolder2),
        QITABENTMULTI(COfflineFilesFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(COfflineFilesFolder, IPersist, IPersistFolder2),
        QITABENT(COfflineFilesFolder, IShellIcon),
        QITABENT(COfflineFilesFolder, IShellIconOverlay),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        //
        // OK, this is a little slimy.  The "delete handler" needs to
        // get at the folder's IShellFolderViewCB interface so it can
        // update the view following a deletion (remember, we're only deleting
        // from the cache so no meaningful FS notification will occur).  
        // We define this secret IID that only our folder knows about.  This 
        // way the delete handler can safely QI any IShellFolder interface
        // and only our folder will respond with a view CB pointer.
        // [brianau - 5/5/99]
        //
        if (riid == IID_OfflineFilesFolderViewCB && NULL != _psfvcb)
        {
            _psfvcb->AddRef();
            *ppv = (void **)_psfvcb;
            hr = NOERROR;
        }
    }
    return hr;
}


STDMETHODIMP_ (ULONG) 
COfflineFilesFolder::AddRef(
    void
    )
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_ (ULONG) 
    COfflineFilesFolder::Release(
    void
    )
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IPersist methods
STDMETHODIMP 
COfflineFilesFolder::GetClassID(
    CLSID *pclsid
    )
{
    *pclsid = CLSID_OfflineFilesFolder;
    return S_OK;
}


HRESULT 
COfflineFilesFolder::Initialize(
    LPCITEMIDLIST pidl
    )
{
    if (_pidl)
        ILFree(_pidl);

    _pidl = ILClone(pidl);

    return _pidl ? S_OK : E_OUTOFMEMORY;
}


HRESULT 
COfflineFilesFolder::GetCurFolder(
    LPITEMIDLIST *ppidl
    )
{
    if (_pidl)
    {
        *ppidl = ILClone(_pidl);
        return *ppidl ? NOERROR : E_OUTOFMEMORY;
    }

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}


STDMETHODIMP 
COfflineFilesFolder::ParseDisplayName(
    HWND hwnd, 
    LPBC pbc,
    LPOLESTR pDisplayName, 
    ULONG* pchEaten,
    LPITEMIDLIST* ppidl, 
    ULONG *pdwAttributes
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP 
COfflineFilesFolder::EnumObjects(
    HWND hwnd, 
    DWORD grfFlags, 
    IEnumIDList **ppenum
    )
{
    *ppenum = NULL;

    HRESULT hr = E_FAIL;
    COfflineFilesEnum *penum = new COfflineFilesEnum(grfFlags, this);
    if (penum)
    {
        if (penum->IsValid())
            hr = penum->QueryInterface(IID_IEnumIDList, (void **)ppenum);
        penum->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP 
COfflineFilesFolder::BindToObject(
    LPCITEMIDLIST pidl, 
    LPBC pbc, 
    REFIID riid, 
    void **ppv
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP 
COfflineFilesFolder::BindToStorage(
    LPCITEMIDLIST pidl, 
    LPBC pbc, 
    REFIID riid, 
    void **ppv
    )
{
    return E_NOTIMPL;
}


void 
COfflineFilesFolder::_GetSyncStatusString(
    LPCOLID polid, 
    LPTSTR pszStatus, 
    UINT cchStatus
    )
{
    //
    // Translate a file status into a stale state code.
    // Note that the stale state codes are the same values as their
    // corresponding string resource IDs.  Order of this array is
    // important.  The first match is the message that is displayed.
    // In the case of multiple bits being set, we want to display a
    // message for the most "serious" reason.
    //
    static const struct
    {
        DWORD dwStatusMask;
        UINT idMsg;

    } rgStaleInfo[] = {
        { FLAG_CSC_COPY_STATUS_SUSPECT,                 IDS_STALEREASON_SUSPECT         },
        { FLAG_CSC_COPY_STATUS_ORPHAN,                  IDS_STALEREASON_ORPHAN          },
        { FLAG_CSC_COPY_STATUS_STALE,                   IDS_STALEREASON_STALE           },
        { FLAG_CSC_COPY_STATUS_LOCALLY_CREATED,         IDS_STALEREASON_LOCALLY_CREATED },
        { FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED,   IDS_STALEREASON_LOCALLY_MODDATA },
        { FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED,   IDS_STALEREASON_LOCALLY_MODTIME },
        { FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED, IDS_STALEREASON_LOCALLY_MODATTR },
        { FLAG_CSC_COPY_STATUS_SPARSE,                  IDS_STALEREASON_SPARSE          }
                      };

    int idStatusText = IDS_STALEREASON_NOTSTALE; // Default is "not stale".

    for (int i = 0; i < ARRAYSIZE(rgStaleInfo); i++)
    {
        if (0 != (rgStaleInfo[i].dwStatusMask & polid->dwStatus))
        {
            idStatusText = rgStaleInfo[i].idMsg;
            break;
        }
    }
    LoadString(g_hInstance, idStatusText, pszStatus, cchStatus);
}


void 
COfflineFilesFolder::_GetPinStatusString(
    LPCOLID polid, 
    LPTSTR pszStatus, 
    UINT cchStatus
    )
{
    LoadString(g_hInstance, 
               (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN) & polid->dwHintFlags ? IDS_FILE_PINNED : IDS_FILE_NOTPINNED,
               pszStatus, 
               cchStatus);
}


void 
COfflineFilesFolder::_GetServerStatusString(
    LPCOLID polid, 
    LPTSTR pszStatus, 
    UINT cchStatus
    )
{
    //
    // Only two possible status strings: "Online" and "Offline".
    //
    UINT idText = IDS_SHARE_STATUS_ONLINE;
    if (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & polid->dwServerStatus)
        idText = IDS_SHARE_STATUS_OFFLINE;

    LoadString(g_hInstance, idText, pszStatus, cchStatus);
}


void 
COfflineFilesFolder::_GetTypeString(
    LPCOLID polid, 
    LPTSTR pszType, 
    UINT cchType
    )
{
    PCTSTR pszName;

    //
    // We utilize a local cache of type name information to reduce
    // the number of calls to SHGetFileInfo.  This speeds things up
    // tremendously.  The shell does something similar in DefView.
    // Note that the filetype cache is a member of COfflineFilesFolder
    // so that it lives only while the folder is active.  The alternative
    // would be to make a local static object here in this function.
    // The problem with that is that once created the cache would remain
    // in memory until our DLL is unloaded; which in explorer.exe is NEVER.
    //

    TSTR_ALIGNED_STACK_COPY( &pszName,
                             polid->szPath + polid->cchNameOfs );

    m_FileTypeCache.GetTypeName(pszName,
                                polid->dwFileAttributes,
                                pszType,
                                cchType);
}


void 
COfflineFilesFolder::_GetAccessString(
    LPCOLID polid, 
    LPTSTR pszAccess, 
    UINT cchAccess
    )
{
    //
    // Three strings containing the replacement text for the rgFmts[i] template.
    // Note that the index value corresponds directly with the access values
    // obtained from the OLID's dwStatus member.  This makes the translation from
    // OLID access info to text string very fast.  These are small enough to 
    // cache.  Caching saves us three LoadStrings each time.
    //
    //  Index    String resource        (english)
    //  -------- ---------------------- ---------
    //    0      IDS_ACCESS_READ        "R"
    //    1      IDS_ACCESS_WRITE       "W"
    //    2      IDS_ACCESS_READWRITE   "R/W"
    //
    static TCHAR rgszAccess[3][4] = {0};
    //
    // This table lists the "mask" and "shift count" used to retrieve the access
    // information from the OLID dwStatus value.
    //
    static const struct
    {
        DWORD dwMask;
        DWORD dwShift;

    } rgAccess[] = {{ FLAG_CSC_USER_ACCESS_MASK,  FLAG_CSC_USER_ACCESS_SHIFT_COUNT  },
                    { FLAG_CSC_GUEST_ACCESS_MASK, FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT },
                    { FLAG_CSC_OTHER_ACCESS_MASK, FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT }};

    //
    // These IDs specify which format string to use for a given
    // item access value in the OLID's dwStatus member.
    // The index into this array is calculated below from the access bits
    // set for this OLID.  Note that these are "message" formats defined
    // in msg.mc and not resource strings.  This way we eliminate the 
    // need for a LoadString and do everything with FormatMessage.
    //
                                                                    // iFmt  (see below)
    static const UINT rgFmts[] = { 0,                               // 0x0000
                                   MSG_FMT_ACCESS_USER,             // 0x0001
                                   MSG_FMT_ACCESS_GUEST,            // 0x0002
                                   MSG_FMT_ACCESS_USERGUEST,        // 0x0003
                                   MSG_FMT_ACCESS_OTHER,            // 0x0004
                                   MSG_FMT_ACCESS_USEROTHER,        // 0x0005
                                   MSG_FMT_ACCESS_GUESTOTHER,       // 0x0006
                                   MSG_FMT_ACCESS_USERGUESTOTHER }; // 0x0007
    
    const DWORD dwAccess = polid->dwStatus & FLAG_CSC_ACCESS_MASK;
    int i;

    if (TEXT('\0') == rgszAccess[0][0])
    {
        //
        // First-time init for strings used in access text.
        // This stuff happens only once.
        //
        const UINT rgidStr[] = { IDS_ACCESS_READ,
                                 IDS_ACCESS_WRITE,
                                 IDS_ACCESS_READWRITE };
        //
        // Load up the "R", "W", "R/W" strings.
        //
        for (i = 0; i < ARRAYSIZE(rgidStr); i++)
        {
            TraceAssert(i < ARRAYSIZE(rgszAccess));
            LoadString(g_hInstance, rgidStr[i], rgszAccess[i], ARRAYSIZE(rgszAccess[i]));
        }
    }
    //
    // Build an index into rgFmts[] based on the access bits set on the olid.
    //
    int iFmt = 0;
    if (FLAG_CSC_USER_ACCESS_MASK & dwAccess)
        iFmt |= 0x0001;
    if (FLAG_CSC_GUEST_ACCESS_MASK & dwAccess)
        iFmt |= 0x0002;
    if (FLAG_CSC_OTHER_ACCESS_MASK & dwAccess)
        iFmt |= 0x0004;

    *pszAccess = TEXT('\0');
    if (0 != iFmt)
    {
        //
        // Fill in the argument array passed to FormatMessage.
        // Each of the elements will contain the address of one element in the 
        // rgszAccess[] string array.  
        //
        LPCTSTR rgpszArgs[ARRAYSIZE(rgszAccess)] = {0};
        int iArg = 0;
        for (i = 0; i < ARRAYSIZE(rgpszArgs); i++)
        {
            int a = dwAccess & rgAccess[i].dwMask;
            if (0 != a)
            {
                rgpszArgs[iArg++] = &rgszAccess[(a >> rgAccess[i].dwShift) - 1][0];
            }
        }
        //
        // Finally, format the message text.
        //
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      g_hInstance,
                      rgFmts[iFmt],
                      0,
                      pszAccess,
                      cchAccess,
                      (va_list *)rgpszArgs);
    }
}



STDMETHODIMP 
COfflineFilesFolder::CompareIDs(
    LPARAM lParam, 
    LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2
    )
{
    HRESULT hres;
    LPCOLID polid1 = _Validate(pidl1);
    LPCOLID polid2 = _Validate(pidl2);
    if (polid1 && polid2)
    {
        TCHAR szStr1[MAX_PATH], szStr2[MAX_PATH];

        switch (lParam & SHCIDS_COLUMNMASK)
        {
        case ICOL_NAME:
            hres = ResultFromShort(ualstrcmpi(polid1->szPath + polid1->cchNameOfs, 
                                              polid2->szPath + polid2->cchNameOfs));
            if (0 == hres)
            {
                //
                // Since we present a "flat" view of the CSC cache,
                // we can't compare only by name.  We have to include
                // path for items with the same name.  This is because the
                // shell uses column 0 as the unique identifying column for
                // an ID.
                //
                hres = ResultFromShort(ualstrcmpi(polid1->szPath, polid2->szPath));
            }
            break;

        case ICOL_TYPE:
            _GetTypeString(polid1, szStr1, ARRAYSIZE(szStr1));
            _GetTypeString(polid2, szStr2, ARRAYSIZE(szStr2));
            hres = ResultFromShort(lstrcmpi(szStr1, szStr2));
            break;

        case ICOL_SYNCSTATUS:
            _GetSyncStatusString(polid1, szStr1, ARRAYSIZE(szStr1));
            _GetSyncStatusString(polid2, szStr2, ARRAYSIZE(szStr2));
            hres = ResultFromShort(lstrcmpi(szStr1, szStr2));
            break;

        case ICOL_PINSTATUS:
            _GetPinStatusString(polid1, szStr1, ARRAYSIZE(szStr1));
            _GetPinStatusString(polid2, szStr2, ARRAYSIZE(szStr2));
            hres = ResultFromShort(lstrcmpi(szStr1, szStr2));
            break;

        case ICOL_ACCESS:
            _GetAccessString(polid1, szStr1, ARRAYSIZE(szStr1));
            _GetAccessString(polid2, szStr2, ARRAYSIZE(szStr2));
            hres = ResultFromShort(lstrcmpi(szStr1, szStr2));
            break;

        case ICOL_SERVERSTATUS:
            _GetServerStatusString(polid1, szStr1, ARRAYSIZE(szStr1));
            _GetServerStatusString(polid2, szStr2, ARRAYSIZE(szStr2));
            hres = ResultFromShort(lstrcmpi(szStr1, szStr2));
            break;

        case ICOL_LOCATION:
            hres = ResultFromShort(ualstrcmpi(polid1->szPath, polid2->szPath));
            break;

        case ICOL_SIZE:
            if (polid1->dwFileSizeLow > polid2->dwFileSizeLow)
                hres = ResultFromShort(1);
            else if (polid1->dwFileSizeLow < polid2->dwFileSizeLow)
                hres = ResultFromShort(-1);
            else
                hres = ResultFromShort(0);
            break;

        case ICOL_DATE:
            hres = ResultFromShort(uaCompareFileTime(&polid1->ft, &polid2->ft));
            break;
        }

        if (hres == S_OK && (lParam & SHCIDS_ALLFIELDS)) 
        {
            hres = CompareIDs(ICOL_PINSTATUS, pidl1, pidl2);
            if (hres == S_OK)
            {
                hres = CompareIDs(ICOL_SYNCSTATUS, pidl1, pidl2);
                if (hres == S_OK)
                {
                    hres = CompareIDs(ICOL_SIZE, pidl1, pidl2);
                    if (hres == S_OK)
                    {
                        hres = CompareIDs(ICOL_DATE, pidl1, pidl2);
                    }
                }
            }
        }
    }
    else
        hres = E_INVALIDARG;
    return hres;
}




STDMETHODIMP 
COfflineFilesFolder::CreateViewObject(
    HWND hwnd, 
    REFIID riid, 
    void **ppv
    )
{
    HRESULT hres;

    if (IsEqualIID(riid, IID_IShellView))
    {
        COfflineFilesViewCallback *pViewCB = new COfflineFilesViewCallback(this);
        if (pViewCB)
        {
            SFV_CREATE sSFV;
            sSFV.cbSize   = sizeof(sSFV);
            sSFV.psvOuter = NULL;
            sSFV.pshf     = this;
            sSFV.psfvcb   = pViewCB;
            hres = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);
            pViewCB->Release();

            if (SUCCEEDED(hres))
            {
                //
                // Save the view callback pointer so we can use it in our context menu
                // handler for view notifications.  Note we don't take a ref count as that
                // would create a ref count cycle.  The view will live as long as the
                // folder does.
                //
                _psfvcb = pViewCB; 
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else if (IsEqualIID(riid, IID_IShellDetails))
    {
        COfflineDetails *pDetails = new COfflineDetails(this);
        if (pDetails)
        {
            *ppv = (IShellDetails *)pDetails;
            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hres = COfflineFilesDropTarget::CreateInstance(hwnd, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hres = CreateOfflineFilesContextMenu(NULL, riid, (void **)ppv);
    }
    else 
    {
        *ppv = NULL;
        hres = E_NOINTERFACE;
    }
    return hres;
}



STDMETHODIMP 
COfflineFilesFolder::GetAttributesOf(
    UINT cidl, 
    LPCITEMIDLIST* apidl, 
    ULONG *rgfInOut
    )
{

    HRESULT hr             = NOERROR;
    IShellFolder *psf      = NULL;
    ULONG ulAttrRequested  = *rgfInOut;

    *rgfInOut = (ULONG)-1;

    for (UINT i = 0; i < cidl && SUCCEEDED(hr); i++)
    {
        CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, (LPCOLID)*apidl++);
        if (SUCCEEDED(hr = pxy.Result()))
        {
            ULONG ulThis           = ulAttrRequested;
            LPCITEMIDLIST pidlItem = pxy.ItemIDList();
            hr = pxy->GetAttributesOf(1, &pidlItem, &ulThis);
            if (SUCCEEDED(hr))
            {
                //
                // Build up the intersection of attributes for all items
                // in the IDList.  Note that we don't allow move.
                //
                *rgfInOut &= (ulThis & ~SFGAO_CANMOVE);
            }
        }
    }
    return hr;
}



HRESULT 
COfflineFilesFolder::GetAssociations(
    LPCOLID polid, 
    void **ppvQueryAssociations
    )
{
    TraceAssert(NULL != polid);
    TraceAssert(NULL != ppvQueryAssociations);

    HRESULT hr = NOERROR;
    *ppvQueryAssociations = NULL;

    CCoInit coinit;
    if (SUCCEEDED(hr = coinit.Result()))
    {
        CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, polid);
        if (SUCCEEDED(hr = pxy.Result()))
        {
            LPCITEMIDLIST pidlItem = pxy.ItemIDList();
            hr = pxy->GetUIObjectOf(NULL, 1, &pidlItem, IID_IQueryAssociations, NULL, ppvQueryAssociations);

            if (FAILED(hr))
            {
                //  this means that the folder doesnt support
                //  the IQueryAssociations.  so we will
                //  just check to see if this is a folder
                ULONG rgfAttrs = SFGAO_FOLDER | SFGAO_BROWSABLE;
                IQueryAssociations *pqa;
                if (SUCCEEDED(pxy->GetAttributesOf(1, &pidlItem, &rgfAttrs))
                    && (rgfAttrs & SFGAO_FOLDER | SFGAO_BROWSABLE)
                    && (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void **)&pqa))))
                {
                    hr = pqa->Init(0, L"Folder", NULL, NULL);

                    if (SUCCEEDED(hr))
                        *ppvQueryAssociations = (void *)pqa;
                    else
                        pqa->Release();
                }
            }
        }
    }
    return hr;
}


BOOL 
COfflineFilesFolder::GetClassKey(
    LPCOLID polid, 
    HKEY *phkeyProgID, 
    HKEY *phkeyBaseID
    )
{
    TraceAssert(NULL != polid);

    BOOL bRet = FALSE;
    IQueryAssociations *pqa;

    if (phkeyProgID)
        *phkeyProgID = NULL;

    if (phkeyBaseID)
        *phkeyBaseID = NULL;

    if (SUCCEEDED(GetAssociations(polid, (void **)&pqa)))
    {
        if (phkeyProgID)
            pqa->GetKey(ASSOCF_IGNOREBASECLASS, ASSOCKEY_CLASS, NULL, phkeyProgID);
        if (phkeyBaseID)
            pqa->GetKey(0, ASSOCKEY_BASECLASS, NULL, phkeyBaseID);
        pqa->Release();
        bRet = TRUE;
    }
    return bRet;
}



HRESULT
COfflineFilesFolder::ContextMenuCB(
    IShellFolder *psf, 
    HWND hwndOwner,
    IDataObject *pdtobj, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HRESULT hr = NOERROR;

    switch(uMsg)
    {
        case DFM_MERGECONTEXTMENU:
            //
            // Return NOERROR.
            // This causes the shell to add the default verbs
            // (i.e. Open, Print etc) to the menu.
            //
            break;
        
        case DFM_INVOKECOMMAND:
            switch(wParam)
            {
                case DFM_CMD_DELETE:
                {
                    IShellFolderViewCB *psfvcb = NULL;
                    if (SUCCEEDED(psf->QueryInterface(IID_OfflineFilesFolderViewCB, (void **)&psfvcb)))
                    {
                        CFolderDeleteHandler handler(hwndOwner, pdtobj, psfvcb);
                        handler.DeleteFiles();
                        psfvcb->Release();
                    }
                    break;
                }

                case DFM_CMD_COPY:
                    SetPreferredDropEffect(pdtobj, DROPEFFECT_COPY);
                    hr = S_FALSE;
                    break;

                case DFM_CMD_PROPERTIES:
                    SHMultiFileProperties(pdtobj, 0);
                    break;

                default:
                    hr = S_FALSE;  // Execute default code.
                    break;
            }
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }

    return hr;
}



/*
// Used for dumping out interface requests.  Uncomment if you want to use it.
//
//
LPCTSTR IIDToStr(REFIID riid, LPTSTR pszDest, UINT cchDest)
{
    struct
    {
        const IID *piid;
        LPCTSTR s;

    } rgMap[] = { { &IID_IDataObject,   TEXT("IID_IDataObject")       },
                  { &IID_IUnknown,      TEXT("IID_IUnknown")          },
                  { &IID_IContextMenu,  TEXT("IID_IContextMenu")      },
                  { &IID_IExtractIconA, TEXT("IID_IExtractIconA")     },
                  { &IID_IExtractIconW, TEXT("IID_IExtractIconW")     },
                  { &IID_IExtractImage, TEXT("IID_IExtractImage")     },
                  { &IID_IPersistFolder2, TEXT("IID_IPersistFolder2") },
                  { &IID_IQueryInfo,    TEXT("IID_IQueryInfo")        },
                  { &IID_IDropTarget,   TEXT("IID_IDropTarget")       },
                  { &IID_IQueryAssociations, TEXT("IID_IQueryAssociations") }
                };

    StringFromGUID2(riid, pszDest, cchDest);

    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        if (riid == *(rgMap[i].piid))
        {
            StringCchCopy(pszDest, cchDest, rgMap[i].s);
            break;
        }
    }
    return pszDest;
}
*/


STDMETHODIMP 
COfflineFilesFolder::GetUIObjectOf(
    HWND hwnd, 
    UINT cidl, 
    LPCITEMIDLIST *ppidl, 
    REFIID riid, 
    UINT* prgfReserved, 
    void **ppv
    )
{
    HRESULT hr;

    if (IID_IDataObject == riid)
    {
        LPITEMIDLIST pidlOfflineFiles;
        hr = COfflineFilesFolder::CreateIDList(&pidlOfflineFiles);
        if (SUCCEEDED(hr))
        {
            hr = COfflineItemsData::CreateInstance((IDataObject **)ppv, 
                                                    pidlOfflineFiles, 
                                                    cidl, 
                                                    ppidl,
                                                    hwnd);
            if (SUCCEEDED(hr))
            {
                SetPreferredDropEffect((IDataObject *)*ppv, DROPEFFECT_COPY);
            }                
            ILFree(pidlOfflineFiles);
        }
    }
    else if (riid == IID_IContextMenu)
    {
        HKEY hkeyBaseProgID = NULL;
        HKEY hkeyProgID     = NULL;
        HKEY hkeyAllFileSys = NULL;
        //
        // Get the hkeyProgID and hkeyBaseProgID from the first item.
        //
        GetClassKey((LPCOLID)*ppidl, &hkeyProgID, &hkeyBaseProgID);

        //
        // Pick up "Send To..."
        //
        RegOpenKeyEx(HKEY_CLASSES_ROOT,
                     TEXT("AllFilesystemObjects"),
                     0,
                     KEY_READ,
                     &hkeyAllFileSys);

        LPITEMIDLIST pidlOfflineFilesFolder;
        hr = COfflineFilesFolder::CreateIDList(&pidlOfflineFilesFolder);
        if (SUCCEEDED(hr))
        {
            HKEY rgClassKeys[] = { hkeyProgID, hkeyBaseProgID, hkeyAllFileSys };

            hr = CDefFolderMenu_Create2(pidlOfflineFilesFolder, 
                                        hwnd,
                                        cidl, 
                                        ppidl,
                                        this,
                                        COfflineFilesFolder::ContextMenuCB,
                                        ARRAYSIZE(rgClassKeys),
                                        rgClassKeys,
                                        (IContextMenu **)ppv);

            ILFree(pidlOfflineFilesFolder);
        }

        if (NULL != hkeyBaseProgID)
            RegCloseKey(hkeyBaseProgID);    
        if (NULL != hkeyProgID)
            RegCloseKey(hkeyProgID);
        if (NULL != hkeyAllFileSys)
            RegCloseKey(hkeyAllFileSys);
    }
    else if (1 == cidl)
    {
        CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, (LPCOLID)*ppidl);
        if (SUCCEEDED(hr = pxy.Result()))
        {
            //
            // Forward single-item selection to the filesystem implementation.
            //
            LPCITEMIDLIST pidlItem = pxy.ItemIDList();
            hr = pxy->GetUIObjectOf(hwnd, 1, &pidlItem, riid, prgfReserved, ppv);
        }
    }
    else if (0 == cidl)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP 
COfflineFilesFolder::GetDisplayNameOf(
    LPCITEMIDLIST pidl, 
    DWORD uFlags, 
    STRRET *pName
    )
{
    TraceAssert(NULL != pidl);

    HRESULT hres = E_INVALIDARG;
    LPCOLID polid = _Validate(pidl);
    if (polid)
    {
        if (uFlags & SHGDN_FORPARSING)
        {
            TCHAR szPath[MAX_PATH];
            hres = OLID_GetFullPath(polid, szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hres))
            {
                hres = StringToStrRet(szPath, pName);
            }
        }
        else
        {
            CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, polid);
            if (SUCCEEDED(hres = pxy.Result()))
            {
                hres = pxy->GetDisplayNameOf(pxy.ItemIDList(), uFlags, pName);
            }
        }
    }
    return hres;
}



STDMETHODIMP 
COfflineFilesFolder::SetNameOf(
    HWND hwnd, 
    LPCITEMIDLIST pidl, 
    LPCOLESTR pName, 
    DWORD uFlags, 
    LPITEMIDLIST *ppidlOut
    )
{
    HRESULT hr;
    CShellObjProxy<IShellFolder> pxy(IID_IShellFolder, _Validate(pidl));
    if (SUCCEEDED(hr = pxy.Result()))
    {
        hr = pxy->SetNameOf(hwnd, pxy.ItemIDList(), pName, uFlags, ppidlOut);
    }
    return hr;
}



//
// Forward IShellIcon methods to parent filesystem folder.
//
HRESULT 
COfflineFilesFolder::GetIconOf(
    LPCITEMIDLIST pidl, 
    UINT gil, 
    int *pnIcon
    )
{
    TraceAssert(NULL != pidl);

    HRESULT hr;
    CShellObjProxy<IShellIcon> pxy(IID_IShellIcon, _Validate(pidl));
    if (SUCCEEDED(hr = pxy.Result()))
    {
        hr = pxy->GetIconOf(pxy.ItemIDList(), gil, pnIcon);
    }
    return hr;
}



//
// Defer IShellIconOverlay methods to parent filesystem folder.
//
HRESULT 
COfflineFilesFolder::GetOverlayIndex(
    LPCITEMIDLIST pidl, 
    int *pIndex
    )
{
    TraceAssert(NULL != pidl);

    HRESULT hr;
    CShellObjProxy<IShellIconOverlay> pxy(IID_IShellIconOverlay, _Validate(pidl));
    if (SUCCEEDED(hr = pxy.Result()))
    {
        hr = pxy->GetOverlayIndex(pxy.ItemIDList(), pIndex);
    }
    return hr;
}


//
// Defer IShellIconOverlay methods to parent filesystem folder.
//
HRESULT
COfflineFilesFolder::GetOverlayIconIndex(
    LPCITEMIDLIST pidl, 
    int * pIconIndex
    )
{
    TraceAssert(NULL != pidl);

    HRESULT hr;
    CShellObjProxy<IShellIconOverlay> pxy(IID_IShellIconOverlay, _Validate(pidl));
    if (SUCCEEDED(hr = pxy.Result()))
    {
        hr = pxy->GetOverlayIconIndex(pxy.ItemIDList(), pIconIndex);
    }
    return hr;
}


//
// Static member function for creating and opening the offline files folder.
//
INT 
COfflineFilesFolder::Open(  // [static]
    void
    )
{
    INT iReturn = 0;
    if (CConfig::GetSingleton().NoCacheViewer())
    {
        CscMessageBox(NULL,
                      MB_OK | MB_ICONINFORMATION,
                      g_hInstance,
                      IDS_ERR_POLICY_NOVIEWCACHE);

        iReturn = -1;
    }
    else
    {
        SHELLEXECUTEINFO shei = { 0 };

        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST;
        shei.nShow      = SW_SHOWNORMAL;

        if (SUCCEEDED(COfflineFilesFolder::CreateIDList((LPITEMIDLIST *)(&shei.lpIDList))))
        {
            ShellExecuteEx(&shei);
            ILFree((LPITEMIDLIST)(shei.lpIDList));
        }
    }
    return iReturn;
}



//
// Static member function for creating the folder's IDList.
//
HRESULT 
COfflineFilesFolder::CreateIDList(  // [static]
    LPITEMIDLIST *ppidl
    )
{
    TraceAssert(NULL != ppidl);
    
    IShellFolder *psf;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {
            BIND_OPTS bo;
            memset(&bo, 0, sizeof(bo));
            bo.cbStruct = sizeof(bo);
            bo.grfFlags = BIND_JUSTTESTEXISTENCE;
            bo.grfMode  = STGM_CREATE;
            pbc->SetBindOptions(&bo);
            
            WCHAR wszPath[80] = L"::";
            StringFromGUID2(CLSID_OfflineFilesFolder, 
                            &wszPath[2], 
                            sizeof(wszPath) - (2 * sizeof(WCHAR)));

            hr = psf->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
            pbc->Release();
        } 
        psf->Release();
    }
    return hr;
}



//
// Static function for creating a link to the folder on the desktop.
//
HRESULT
COfflineFilesFolder::CreateLinkOnDesktop(  // [static]
    HWND hwndParent
    )
{
    IShellLink* psl;  
    CCoInit coinit;
    HRESULT hr = coinit.Result();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellLink, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IShellLink, 
                              (void **)&psl); 

        if (SUCCEEDED(hr)) 
        {
            LPITEMIDLIST pidl = NULL;
            hr = COfflineFilesFolder::CreateIDList(&pidl);
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(pidl);
                if (SUCCEEDED(hr))
                {
                    TCHAR szLinkTitle[80] = { 0 };
                    if (LoadString(g_hInstance, IDS_FOLDER_LINK_NAME, szLinkTitle, ARRAYSIZE(szLinkTitle)))
                    {
                        psl->SetDescription(szLinkTitle);  
                    }

                    IPersistFile* ppf;  
                    hr = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);          
                    if (SUCCEEDED(hr)) 
                    { 
                        TCHAR szLinkPath[MAX_PATH];
                        hr = SHGetSpecialFolderPath(hwndParent, szLinkPath, CSIDL_DESKTOPDIRECTORY, FALSE) ? S_OK : E_FAIL;
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szLinkFileName[80];
                            if (LoadStringW(g_hInstance, IDS_FOLDER_LINK_NAME, szLinkFileName, ARRAYSIZE(szLinkFileName)))
                            {
                                hr = StringCchCat(szLinkFileName, ARRAYSIZE(szLinkFileName), TEXT(".LNK"));
                                if (SUCCEEDED(hr))
                                {
                                    if (PathAppend(szLinkPath, szLinkFileName))
                                    {
                                        hr = ppf->Save(szLinkPath, TRUE); 
                                        if (SUCCEEDED(hr))
                                        {
                                            //
                                            // Record that we've created a folder shortcut on the
                                            // desktop.  This is used to minimize the number of 
                                            // times we look for the shortcut on the desktop.
                                            // DeleteOfflineFilesFolderLink_PerfSensitive() will look
                                            // for this value to avoid unnecessary scans of the desktop
                                            // when looking for our LINK file.
                                            //
                                            DWORD dwValue = 1;
                                            DWORD cbValue = sizeof(dwValue);
                                            SHSetValue(HKEY_CURRENT_USER,
                                                       REGSTR_KEY_OFFLINEFILES,
                                                       REGSTR_VAL_FOLDERSHORTCUTCREATED,
                                                       REG_DWORD,
                                                       &dwValue,
                                                       cbValue);
                                        }
                                    }
                                    else
                                    {
                                        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                                    }
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                        ppf->Release();         
                    } 
                }
                ILFree(pidl);
            }
            psl->Release();     
        }
    }
    return hr; 
} 


//
// Static function for determining if there's a link to the offline files
// folder sitting on the user's desktop.
//
HRESULT
COfflineFilesFolder::IsLinkOnDesktop(  // [static]
    HWND hwndParent,
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = SHGetSpecialFolderPath(hwndParent, szPath, CSIDL_DESKTOPDIRECTORY, FALSE) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;  // Assume not found.
        if (PathAppend(szPath, TEXT("*.LNK")))
        {
            WIN32_FIND_DATA fd;
            HANDLE hFind = FindFirstFile(szPath, &fd);
            if (INVALID_HANDLE_VALUE != hFind)
            {
                do
                {
                    if (!PathRemoveFileSpec(szPath) ||
                        !PathAppend(szPath, fd.cFileName))
                    {
                        // We can't be sure of the buffer contents anymore,
                        // so continuing could give bogus results.
                        break;
                    }

                    hr = IsOurLink(szPath);
                    if (S_OK == hr)
                    {
                        if (NULL != pszPathOut)
                        {
                            // We found the file using a MAX_PATH buffer and
                            // it's unlikely that callers are using smaller
                            // buffers, so don't worry about truncation.
                            StringCchCopy(pszPathOut, cchPathOut, szPath);
                        }
                        break;
                    }
                }
                while(FindNextFile(hFind, &fd));
                FindClose(hFind);
            }
        }
    }
    return hr;
}


//
// Given a link file path, determine if it's a link to the
// offline files folder.
//
HRESULT
COfflineFilesFolder::IsOurLink(  // [static]
    LPCTSTR pszFile
    )
{
    IShellLink *psl;
    CCoInit coinit;
    HRESULT hr = coinit.Result();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellLink, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IShellLink, 
                              (void **)&psl); 

        if (SUCCEEDED(hr)) 
        {
            IPersistFile *ppf;
            hr = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pszFile, STGM_DIRECT);
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlLink;
                    hr = psl->GetIDList(&pidlLink);
                    if (SUCCEEDED(hr))
                    {
                        hr = COfflineFilesFolder::IdentifyIDList(pidlLink);
                        ILFree(pidlLink);
                    }
                }
                ppf->Release();
            }
            psl->Release();
        }
    }
    return hr;
}


//
// Determines if a given IDList is the IDList of the
// offline files folder.
//
// Returns:
//
//      S_OK    = It's our IDList.
//      S_FALSE = It's not our IDList.
//
HRESULT
COfflineFilesFolder::IdentifyIDList(  // [static]
    LPCITEMIDLIST pidl
    )
{
    IShellFolder *psf;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {
            STRRET strret;
            BIND_OPTS bo;
            memset(&bo, 0, sizeof(bo));
            bo.cbStruct = sizeof(bo);
            bo.grfFlags = BIND_JUSTTESTEXISTENCE;
            bo.grfMode  = STGM_CREATE;
            pbc->SetBindOptions(&bo);
            hr = psf->GetDisplayNameOf(pidl,
                                       SHGDN_FORPARSING,
                                       &strret);
            if (SUCCEEDED(hr))
            {
                TCHAR szIDList[80];
                TCHAR szPath[80] = TEXT("::");
                StrRetToBuf(&strret, pidl, szIDList, ARRAYSIZE(szIDList));
                StringFromGUID2(CLSID_OfflineFilesFolder, 
                                &szPath[2], 
                                sizeof(szPath) - (2 * sizeof(TCHAR)));

                if (0 == lstrcmpi(szIDList, szPath))
                    hr = S_OK;
                else
                    hr = S_FALSE;
            }
            pbc->Release();
        } 
        psf->Release();
    }
    return hr;
}



HRESULT 
COfflineFilesFolder::GetFolder(   // [static]
    IShellFolder **ppsf
    )
{
    TraceAssert(NULL != ppsf);

    *ppsf = NULL;

    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
       LPITEMIDLIST pidlOfflineFiles;
       hr = COfflineFilesFolder::CreateIDList(&pidlOfflineFiles);
       if (SUCCEEDED(hr))
       {
            hr = psfDesktop->BindToObject(pidlOfflineFiles, NULL, IID_IShellFolder, (void **)ppsf);
            ILFree(pidlOfflineFiles);
       }
       psfDesktop->Release();
    }
    return hr;
}


//
// Generate a new OLID from a UNC path.
//
HRESULT
COfflineFilesFolder::OLID_CreateFromUNCPath(   // [static]
    LPCTSTR pszPath,
    const WIN32_FIND_DATA *pfd,
    DWORD dwStatus,
    DWORD dwPinCount,
    DWORD dwHintFlags,
    DWORD dwServerStatus,
    LPOLID *ppolid
    )
{
    HRESULT hr  = E_OUTOFMEMORY;
    int cchPath = lstrlen(pszPath) + 1;
    int cbIDL   = sizeof(OLID) + (cchPath * sizeof(TCHAR)) + sizeof(WORD);  // NULL terminator WORD
    WIN32_FIND_DATA fd;

    if (NULL == pfd)
    {
        //
        // Caller didn't provide a finddata block.  Use a default one
        // with all zeros.
        //
        ZeroMemory(&fd, sizeof(fd));
        pfd = &fd;
    }

    *ppolid = NULL;

    OLID *polid = (OLID *)SHAlloc(cbIDL);
    if (NULL != polid)
    {
        ZeroMemory(polid, cbIDL);
        polid->cb               = (USHORT)(cbIDL - sizeof(WORD));
        polid->uSig             = OLID_SIG;
        polid->cbFixed          = sizeof(OLID);
        polid->cchNameOfs       = (DWORD)(PathFindFileName(pszPath) - pszPath);
        polid->dwStatus         = dwStatus;
        polid->dwPinCount       = dwPinCount;
        polid->dwHintFlags      = dwHintFlags;
        polid->dwServerStatus   = dwServerStatus;
        polid->dwFileAttributes = pfd->dwFileAttributes;
        polid->dwFileSizeLow    = pfd->nFileSizeLow;
        polid->dwFileSizeHigh   = pfd->nFileSizeHigh;
        polid->ft               = pfd->ftLastWriteTime;
        hr = StringCchCopy(polid->szPath, cchPath, pszPath);
        if (SUCCEEDED(hr))
        {
            // Split the name from the path
            if (0 < polid->cchNameOfs)
                polid->szPath[polid->cchNameOfs - 1] = TEXT('\0');
            *ppolid = polid;
        }
        else
        {
            SHFree(polid);
        }
    }
    return hr;
}

void
COfflineFilesFolder::OLID_GetWin32FindData(   // [static]
    LPCOLID polid,
    WIN32_FIND_DATA *pfd
    )
{
    TraceAssert(NULL != polid);
    TraceAssert(NULL != pfd);

    ZeroMemory(pfd, sizeof(*pfd));
    pfd->dwFileAttributes = polid->dwFileAttributes;
    pfd->nFileSizeLow     = polid->dwFileSizeLow;
    pfd->nFileSizeHigh    = polid->dwFileSizeHigh;
    pfd->ftLastWriteTime  = polid->ft;
    OLID_GetFileName(polid, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
}


//
// Retrieve the full path (including filename) from an OLID.
//
HRESULT
COfflineFilesFolder::OLID_GetFullPath(   // [static]
    LPCOLID polid, 
    LPTSTR pszPath,
    UINT cchPath
    )
{
    HRESULT hr = S_OK;
    PCTSTR pszInPath;
    PCTSTR pszInName;

    TraceAssert(NULL != polid);
    TraceAssert(NULL != pszPath);

    TSTR_ALIGNED_STACK_COPY( &pszInPath, polid->szPath );
    TSTR_ALIGNED_STACK_COPY( &pszInName,
                             polid->szPath + polid->cchNameOfs );

    if (!PathCombine(pszPath, pszInPath, pszInName))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }
    return hr;
}

//
// Retrieve only the filename portion of the OLID.
//
LPCTSTR 
COfflineFilesFolder::OLID_GetFileName(   // [static]
    LPCOLID polid, 
    LPTSTR pszName,
    UINT cchName
    )
{
    TraceAssert(NULL != polid);
    TraceAssert(NULL != pszName);

    ualstrcpyn(pszName, polid->szPath + polid->cchNameOfs, cchName);
    return pszName;
}


//
// Given an OLID this function creates a fully-qualified simple
// IDList for use by the shell.  The returned IDList is relative to the
// desktop folder.
//
HRESULT
COfflineFilesFolder::OLID_CreateSimpleIDList(   // [static]
    LPCOLID polid,
    LPITEMIDLIST *ppidlOut
    )
{
    TraceAssert(NULL != polid);
    TraceAssert(NULL != ppidlOut);
    TraceAssert(COfflineFilesFolder::ValidateIDList((LPCITEMIDLIST)polid));

    TCHAR szFullPath[MAX_PATH];

    HRESULT hr = OLID_GetFullPath(polid, szFullPath, ARRAYSIZE(szFullPath));
    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATA fd;
        OLID_GetWin32FindData(polid, &fd);
        hr = SHSimpleIDListFromFindData(szFullPath, &fd, ppidlOut);
    }
    return hr;
}



HRESULT
COfflineFilesFolder::OLID_Bind(   // [static]
    LPCOLID polid,
    REFIID riid,
    void **ppv,
    LPITEMIDLIST *ppidlFull,
    LPCITEMIDLIST *ppidlItem
    )
{
    *ppidlFull = NULL;
    *ppidlItem = NULL;
    HRESULT hr = OLID_CreateSimpleIDList(polid, ppidlFull);
    if (SUCCEEDED(hr))
    {
        hr = ::SHBindToIDListParent((LPCITEMIDLIST)*ppidlFull, riid, ppv, ppidlItem);
    }
    return hr;
}


//-----------------------------------------------------------------------------
// COfflineFilesDropTarget
//-----------------------------------------------------------------------------

COfflineFilesDropTarget::COfflineFilesDropTarget(
    HWND hwnd
    ) : m_cRef(1),
        m_hwnd(hwnd),
        m_pcm(NULL),
        m_bIsOurData(false)
{

}



COfflineFilesDropTarget::~COfflineFilesDropTarget(
    void
    )
{
    DoRelease(m_pcm);
}


HRESULT
COfflineFilesDropTarget::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineFilesDropTarget, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG
COfflineFilesDropTarget::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


ULONG
COfflineFilesDropTarget::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



HRESULT
COfflineFilesDropTarget::DragEnter(
    IDataObject *pDataObject, 
    DWORD grfKeyState, 
    POINTL pt, 
    DWORD *pdwEffect
    )
{
    HRESULT hr;

    *pdwEffect = DROPEFFECT_NONE;

    // The context menu handler has logic to check whether
    // the selected files are cacheable, etc.  It only adds
    // verbs to the context menu when it makes sense to do so.
    // We can make use of this by calling QueryContextMenu
    // here and seeing whether anything is added to the menu.

    DoRelease(m_pcm);

    if (!(m_bIsOurData = IsOurDataObject(pDataObject)))
    {
        hr = CreateOfflineFilesContextMenu(pDataObject, IID_IContextMenu, (void **)&m_pcm);
        if (SUCCEEDED(hr))
        {
            HMENU hmenu = CreateMenu();
            if (hmenu)
            {
                hr = m_pcm->QueryContextMenu(hmenu, 0, 0, 100, 0);
                DestroyMenu(hmenu);
            }
            else
                hr = E_OUTOFMEMORY;

            // Did the context menu add anything?
            if (FAILED(hr) || ResultFromShort(0) == hr)
            {
                // No, release m_pcm and set it to NULL
                DoRelease(m_pcm);
            }
            else
            {
                // Yes
                *pdwEffect |= DROPEFFECT_COPY;
            }
        }
    }
    return NOERROR;
}


HRESULT
COfflineFilesDropTarget::DragOver(
    DWORD grfKeyState, 
    POINTL pt, 
    DWORD *pdwEffect
    )
{
    *pdwEffect = DROPEFFECT_NONE;
    if (m_pcm && !m_bIsOurData)
        *pdwEffect = DROPEFFECT_COPY;
    return NOERROR;
}


HRESULT
COfflineFilesDropTarget::DragLeave(
    void
    )
{
    DoRelease(m_pcm);
    return NOERROR;
}


HRESULT
COfflineFilesDropTarget::Drop(
    IDataObject *pDataObject, 
    DWORD grfKeyState,
    POINTL pt, 
    DWORD *pdwEffect
    )
{
    HRESULT hr = E_FAIL;
    *pdwEffect = DROPEFFECT_NONE;
    if (m_pcm && !m_bIsOurData)
    {
        CMINVOKECOMMANDINFO cmi;
        ZeroMemory(&cmi, sizeof(cmi));
        cmi.cbSize = sizeof(cmi);
        cmi.hwnd   = m_hwnd;
        cmi.lpVerb = STR_PIN_VERB;
        cmi.nShow  = SW_SHOWNORMAL;
        hr = m_pcm->InvokeCommand(&cmi);

        if (SUCCEEDED(hr))
        {
            *pdwEffect = DROPEFFECT_COPY;
        }
    }
    DoRelease(m_pcm);
    return hr;
}


HRESULT 
COfflineFilesDropTarget::CreateInstance(
    HWND hwnd,
    REFIID riid,
    void **ppv
    )
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    COfflineFilesDropTarget* pdt = new COfflineFilesDropTarget(hwnd);
    if (NULL != pdt)
    {
        hr = pdt->QueryInterface(riid, ppv);
        pdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


//
// If the source of the data is the Offline Files folder the data object
// will support the "Data Source Clsid" clipboard format and the CLSID
// will be CLSID_OfflineFilesFolder.
// Checking for this is how we keep from dropping our own data on ourselves.
//
bool
COfflineFilesDropTarget::IsOurDataObject(
    IDataObject *pdtobj
    )
{
    TraceAssert(NULL != pdtobj);

    bool bIsOurData = false;
    CLIPFORMAT cfSrcClsid = (CLIPFORMAT)RegisterClipboardFormat(c_szCFDataSrcClsid);
    FORMATETC fe = { cfSrcClsid, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM medium;

    HRESULT hr = pdtobj->GetData(&fe, &medium);
    if (SUCCEEDED(hr))
    {
        const CLSID *pclsid = (const CLSID *)GlobalLock(medium.hGlobal);
        if (pclsid)
        {
            bIsOurData = boolify(IsEqualCLSID(CLSID_OfflineFilesFolder, *pclsid));
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
    return bIsOurData;
}



//-----------------------------------------------------------------------------
// COfflineFilesViewCallback
//-----------------------------------------------------------------------------

COfflineFilesViewCallback::COfflineFilesViewCallback(
    COfflineFilesFolder *pfolder
    ) : _cRef(1)
{
    m_hwnd = NULL;
    _psfv = NULL;
    _pfolder = pfolder;
    _pfolder->AddRef();
    InitializeCriticalSection(&m_cs);
}


COfflineFilesViewCallback::~COfflineFilesViewCallback(
    void
    )
{
    _pfolder->Release();

    if (_psfv)
        _psfv->Release();

    //
    // Since the folder cache is global we don't want it taking up space while the
    // Offline Folders view isn't active.  Clear it when the view callback is 
    // destroyed.
    //
    CFolderCache::Singleton().Clear();
    DeleteCriticalSection(&m_cs);

}


STDMETHODIMP 
COfflineFilesViewCallback::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineFilesViewCallback, IShellFolderViewCB),    // IID_IShellFolderViewCB
        QITABENT(COfflineFilesViewCallback, IObjectWithSite),       // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_ (ULONG) 
COfflineFilesViewCallback::AddRef(
    void
    )
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_ (ULONG) 
COfflineFilesViewCallback::Release(
    void
    )
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT 
COfflineFilesViewCallback::SetSite(
    IUnknown *punkSite
    )
{
    if (_psfv)
    {
        _psfv->Release();
        _psfv = NULL;
    }

    if (punkSite)
        punkSite->QueryInterface(IID_IShellFolderView, (void **)&_psfv);

    return S_OK;
}


HRESULT 
COfflineFilesViewCallback::GetSite(
    REFIID riid, 
    void **ppv
    )
{
    if (_psfv)
        return _psfv->QueryInterface(riid, ppv);

    *ppv = NULL;
    return E_FAIL;
}


STDMETHODIMP 
COfflineFilesViewCallback::MessageSFVCB(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HRESULT hres = S_OK;

    switch (uMsg)
    {
        case SFVM_COLUMNCLICK:
            if (_psfv)
                return _psfv->Rearrange((int)wParam);
            break;

        case SFVM_WINDOWCREATED:
            OnSFVM_WindowCreated((HWND)wParam);
            break;

        case SFVM_ADDPROPERTYPAGES:
            OnSFVM_AddPropertyPages((DWORD)wParam, (SFVM_PROPPAGE_DATA *)lParam);
            break;

        case SFVM_GETHELPTOPIC:
            {
                SFVM_HELPTOPIC_DATA *phtd = (SFVM_HELPTOPIC_DATA*)lParam;
                hres = StringCchCopy(phtd->wszHelpFile, ARRAYSIZE(phtd->wszHelpFile), L"offlinefolders.chm > windefault");
            }
            break;

        case SFVM_QUERYFSNOTIFY:
            hres = OnSFVM_QueryFSNotify((SHChangeNotifyEntry *)lParam);
            break;

        case SFVM_GETNOTIFY:
            hres = OnSFVM_GetNotify((LPITEMIDLIST *)wParam, (LONG *)lParam);
            break;
            
        case SFVM_FSNOTIFY:
            hres = OnSFVM_FSNotify((LPCITEMIDLIST *)wParam, (LONG)lParam);
            break;

        case SFVM_GETVIEWS:
            hres = OnSFVM_GetViews((SHELLVIEWID *)wParam, (IEnumSFVViews **)lParam);
            break;

        case SFVM_ALTERDROPEFFECT:
            hres = OnSFVM_AlterDropEffect((DWORD *)wParam, (IDataObject *)lParam);
            break;
 
        case SFVMP_SETVIEWREDRAW:
            hres = OnSFVMP_SetViewRedraw(lParam != FALSE);
            break;

        case SFVMP_DELVIEWITEM:
            hres = OnSFVMP_DelViewItem((LPCTSTR)lParam);
            break;

        default:
            hres = E_NOTIMPL;
    }
    return hres;
}


HRESULT 
COfflineFilesViewCallback::OnSFVM_WindowCreated(
    HWND hwnd
    )
{
    m_hwnd = hwnd;
    return NOERROR;
}


HRESULT 
COfflineFilesViewCallback::OnSFVM_AddPropertyPages(
    DWORD pv, 
    SFVM_PROPPAGE_DATA *ppagedata
    )
{
    const CLSID *c_rgFilePages[] = {
        &CLSID_FileTypes,
        &CLSID_OfflineFilesOptions
    };
   
    IShellPropSheetExt * pspse;
    HRESULT hr;

    for (int i = 0; i < ARRAYSIZE(c_rgFilePages); i++)
    {
        hr = SHCoCreateInstance(NULL, 
                                c_rgFilePages[i], 
                                NULL, 
                                IID_IShellPropSheetExt, 
                                (void **)&pspse);
        if (SUCCEEDED(hr))
        {
            pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
            pspse->Release();
        }
    }
    return S_OK;
}


HRESULT 
COfflineFilesViewCallback::OnSFVM_GetViews(
    SHELLVIEWID *pvid,
    IEnumSFVViews **ppev
    )
{
    //
    // Offline files folder prefers details view.
    //
    *pvid = VID_Details;
    return COfflineFilesViewEnum::CreateInstance(ppev);
}


HRESULT
COfflineFilesViewCallback::OnSFVM_GetNotify(
    LPITEMIDLIST *ppidl,
    LONG *plEvents
    )
{
    *ppidl    = NULL;
    *plEvents = GetChangeNotifyEvents();
    return NOERROR;
}


HRESULT 
COfflineFilesViewCallback::OnSFVM_QueryFSNotify(
    SHChangeNotifyEntry *pfsne
    )
{
    //
    // Register to receive global events
    //
    pfsne->pidl       = NULL;
    pfsne->fRecursive = TRUE;

    return NOERROR;
}


HRESULT
COfflineFilesViewCallback::OnSFVMP_SetViewRedraw(
    BOOL bRedraw
    )
{
    if (_psfv)
        _psfv->SetRedraw(bRedraw);
    return NOERROR;
}


HRESULT
COfflineFilesViewCallback::OnSFVMP_DelViewItem(
    LPCTSTR pszPath
    )
{
    Lock();
    HRESULT hr = RemoveItem(pszPath);
    Unlock();
    return hr;
}

//
// This is called immediately before the shell calls DoDragDrop().
// It let's us turn off "move" after all of the other drop effect
// modifications have taken place.
//
HRESULT
COfflineFilesViewCallback::OnSFVM_AlterDropEffect(
    DWORD *pdwEffect,
    IDataObject *pdtobj // unused.
    )
{
    *pdwEffect &= ~DROPEFFECT_MOVE;  // Disable move.
    return NOERROR;
}



//
// Handler for shell change notifications.
//
// We handle SHCNE_UPDATEITEM, SHCNE_UPDATEDIR, SHCNE_DELETE
// and SHCNE_RENAMEITEM
//
HRESULT 
COfflineFilesViewCallback::OnSFVM_FSNotify(
    LPCITEMIDLIST *ppidl, 
    LONG lEvent
    )
{
    HRESULT hr = NOERROR;
    if (GetChangeNotifyEvents() & lEvent)
    {
        Lock();
        if (SHCNE_RENAMEITEM & lEvent)
        {
            hr = RenameItem(*ppidl, *(ppidl + 1));
        }
        else
        {
            //
            // Convert the full pidl to a UNC path.
            //
            TCHAR szPath[MAX_PATH];
            if (SHGetPathFromIDList(*ppidl, szPath))
            {
                if (SHCNE_UPDATEDIR & lEvent)
                    hr = UpdateDir(szPath);
                else if (SHCNE_UPDATEITEM & lEvent)
                    hr = UpdateItem(szPath);
                else if (SHCNE_DELETE & lEvent)
                    hr = RemoveItem(szPath);
            }
        }
        Unlock();
    }
    return hr;
}


//
// Handler for SHCNE_RENAMEITEM notifications.
//
HRESULT
COfflineFilesViewCallback::RenameItem(
    LPCITEMIDLIST pidlOld,
    LPCITEMIDLIST pidl
    )
{
    TraceAssert(NULL != pidlOld);
    TraceAssert(NULL != pidl);

    //
    // Get the full path for the original pidl.
    //
    TCHAR szPath[MAX_PATH];
    HRESULT hr = NOERROR;
    if (SHGetPathFromIDList(pidlOld, szPath))
    {
        //
        // Find the original OLID in the listview.
        //
        LPCOLID polid = NULL;
        hr = FindOLID(szPath, &polid);
        if (SUCCEEDED(hr))
        {
            //
            // Get the full path for the new renamed pidl.
            //
            if (SHGetPathFromIDList(pidl, szPath))
            {
                //
                // Create a new OLID for the newly renamed pidl.
                //
                LPOLID polidNew;
                WIN32_FIND_DATA fd;

                ZeroMemory(&fd, sizeof(fd));
                fd.nFileSizeHigh    = polid->dwFileSizeHigh;
                fd.nFileSizeLow     = polid->dwFileSizeLow;
                fd.ftLastWriteTime  = polid->ft;
                fd.dwFileAttributes = polid->dwFileAttributes;

                hr = COfflineFilesFolder::OLID_CreateFromUNCPath(szPath,
                                                                 &fd,
                                                                 polid->dwStatus,
                                                                 polid->dwPinCount,
                                                                 polid->dwHintFlags,
                                                                 polid->dwServerStatus,
                                                                 &polidNew);
                if (SUCCEEDED(hr))
                {
                    UINT iItem;
                    //
                    // Replace the old olid in the view with the new olid.
                    // DefView will free the old one if successful.
                    //
                    hr = _psfv->UpdateObject((LPITEMIDLIST)polid, 
                                             (LPITEMIDLIST)polidNew, 
                                             &iItem);
                    if (FAILED(hr))
                    {
                        //
                        // View wouldn't accept the new OLID so free it.
                        //
                        ILFree((LPITEMIDLIST)polidNew);
                    }
                }
            }
        }
    }

    return hr;
}


//
// Locates an OLID in the view and returns the address of the
// OLID.  The returned pointer is to a const object so the caller
// should not call ILFree on it.
//
HRESULT
COfflineFilesViewCallback::FindOLID(
    LPCTSTR pszPath,
    LPCOLID *ppolid
    )
{
    TraceAssert(NULL != pszPath);
    TraceAssert(NULL != ppolid);

    //
    // Create one of our OLIDs from the UNC path to use as a search key.
    //
    LPOLID polid = NULL;
    HRESULT hr = COfflineFilesFolder::OLID_CreateFromUNCPath(pszPath, NULL, 0, 0, 0, 0, &polid);
    if (SUCCEEDED(hr))
    {
        //
        // Lock so that index returned by IndexItemFromOLID() is
        // still valid in call to GetObject().
        //
        Lock();
        //
        // Get our item's index in the listview.
        //
        UINT iItem = ItemIndexFromOLID(polid);
        if ((UINT)-1 != iItem)
            hr = _psfv->GetObject((LPITEMIDLIST *)ppolid, iItem);
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        Unlock();
        ILFree((LPITEMIDLIST)polid);
        
    }
    return hr;
}



//
// Handler for SHCNE_UPDATEDIR notifications.
//
// Enumerates each immediate child of the directory and performs
// an update.
//
HRESULT
COfflineFilesViewCallback::UpdateDir(
    LPCTSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    HRESULT hr = NOERROR;
    //
    // First remove all items from the listview that are immediate children 
    // of this directory.  This in effect causes a refresh.
    //
    RemoveItems(pszPath);
    //
    // Now scan the CSC cache for all items in this directory and update/add
    // to the listview as appropriate.
    //
    WIN32_FIND_DATA fd;
    FILETIME ft;
    DWORD dwHintFlags;
    DWORD dwPinCount;
    DWORD dwStatus;

    CCscFindHandle hFind = CacheFindFirst(pszPath, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft);
    if (hFind.IsValid())
    {
        TCHAR szPath[MAX_PATH];
        do
        {
            if (0 == (FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes))
            {
                if (NULL != PathCombine(szPath, pszPath, fd.cFileName))
                    UpdateItem(szPath, fd, dwStatus, dwPinCount, dwHintFlags);
            }
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft));
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}


//
// Given a directory path, remove all immediate children from the listview.
//
HRESULT
COfflineFilesViewCallback::RemoveItems(
    LPCTSTR pszDir
    )
{
    TraceAssert(NULL != pszDir);

    UINT cItems;
    if (SUCCEEDED(_psfv->GetObjectCount(&cItems)))
    {
        LPCOLID polid;
        for (UINT i = 0; i < cItems; i++)
        {
            if (SUCCEEDED(_psfv->GetObject((LPITEMIDLIST *)&polid, i)))
            {
                if (0 == ualstrcmpi(pszDir, polid->szPath))
                {
                    //
                    // This item is from the "pszDir" directory.
                    // Remove it from the listview.
                    //
                    RemoveItem(polid);
                    //
                    // Adjust item count and loop variable for deleted
                    // item.
                    //
                    cItems--;
                    i--;
                }
            }
        }
    }
    return NOERROR;
}


//
// Given an OLID, remove an item from the view.
//
HRESULT
COfflineFilesViewCallback::RemoveItem(
    LPCOLID polid
    )
{
    TraceAssert(NULL != polid);

    HRESULT hr = E_FAIL;
    UINT iItem = ItemIndexFromOLID(polid);
    if ((UINT)-1 != iItem)
    {
        //
        // File is in the listview.  Remove it.
        //
        hr = _psfv->RemoveObject((LPITEMIDLIST)polid, &iItem);
    }
    return hr;
}



//
// Give a UNC path, remove an item from the view.
//
HRESULT
COfflineFilesViewCallback::RemoveItem(
    LPCTSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    LPOLID polid = NULL;
    HRESULT hr   = COfflineFilesFolder::OLID_CreateFromUNCPath(pszPath, NULL, 0, 0, 0, 0, &polid);
    if (SUCCEEDED(hr))
    {
        hr = RemoveItem(polid);
        ILFree((LPITEMIDLIST)polid);
    }
    return hr;
}


//
// Handler for SHCNE_UPDATEITEM notifications.
//
// Updates a single item in the viewer.  If the item no longer
// exists in the cache, it is removed from the view.
//
HRESULT
COfflineFilesViewCallback::UpdateItem(
    LPCTSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    HRESULT hr = NOERROR;

    DWORD dwAttr = ::GetFileAttributes(pszPath);
    if (DWORD(-1) != dwAttr)
    {
        if (0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr))
        {
            DWORD dwHintFlags = 0;
            DWORD dwPinCount = 0;
            DWORD dwStatus = 0;
            WIN32_FIND_DATA fd;
            FILETIME ft;

            CCscFindHandle hFind = CacheFindFirst(pszPath, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft);
            if (hFind.IsValid())
            {
                hr = UpdateItem(pszPath, fd, dwStatus, dwPinCount, dwHintFlags);
            }
            else
            {
                hr = RemoveItem(pszPath);
            }
        }
    }
    return hr;
}


//
// Update a single item in the cache.  This instance of UpdateItem()
// is called once we have information on the item from the CSC cache.
// If an item doesn't already exist in the viewer, it is added.
// If an item does exist, it is updated with the new CSC info.
//
// This function assumes the item is NOT a directory.
//
HRESULT
COfflineFilesViewCallback::UpdateItem(
    LPCTSTR pszPath,
    const WIN32_FIND_DATA& fd,
    DWORD dwStatus,
    DWORD dwPinCount,
    DWORD dwHintFlags
    )
{
    TraceAssert(NULL != pszPath);
    TraceAssert(0 == (FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes));

    HRESULT hr = NOERROR;
    UINT iItem = (UINT)-1;

    //
    // Now create one of our OLIDs from the UNC path.
    //
    LPOLID polid = NULL;
    hr = COfflineFilesFolder::OLID_CreateFromUNCPath(pszPath, NULL, 0, 0, 0, 0, &polid);
    if (SUCCEEDED(hr))
    {
        //
        // Get our item's index in the listview.
        //
        LPCITEMIDLIST pidlOld = NULL;
        //
        // Lock so that index returned by ItemIndexFromOLID() is
        // still valid in call to GetObject().
        //
        Lock();
        
        iItem = ItemIndexFromOLID(polid);
        if ((UINT)-1 != iItem)
        {
            //
            // Won't be using this olid.  We'll be cloning the one from the 
            // listview.
            //
            ILFree((LPITEMIDLIST)polid);
            polid = NULL; 
            //
            // Item is in the view.  Get the existing OLID and clone it.
            // IMPORTANT:  We DON'T call ILFree on pidlOld.  Despite the
            //             argument to GetObject being non-const, it's
            //             really returning a pointer to a const object.
            //             In actuality, it's the address of the listview
            //             item's LPARAM.
            //
            hr = _psfv->GetObject((LPITEMIDLIST *)&pidlOld, iItem);
            if (SUCCEEDED(hr))
            {
                polid = (LPOLID)ILClone(pidlOld);
                if (NULL == polid)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        Unlock();
        
        if (NULL != polid)
        {
            //
            // polid either points to the new partial OLID we created 
            // with OLID_CreateFromUNCPath() or a clone of the existing 
            // OLID in the listview.  Fill/update the file and
            // CSC information.
            //
            polid->dwFileSizeHigh   = fd.nFileSizeHigh;
            polid->dwFileSizeLow    = fd.nFileSizeLow;
            polid->ft               = fd.ftLastWriteTime;
            polid->dwFileAttributes = fd.dwFileAttributes;
            polid->dwStatus         = dwStatus;
            polid->dwHintFlags      = dwHintFlags;
            polid->dwPinCount       = dwPinCount;

            if ((UINT)-1 != iItem)
            {
                //
                // Replace the old olid in the view with the new olid.
                // DefView will free the old one if successful.
                //
                hr = _psfv->UpdateObject((LPITEMIDLIST)pidlOld, 
                                         (LPITEMIDLIST)polid, 
                                         &iItem);
            }
            else
            {
                //
                // Add the new olid to the view.
                //
                hr = _psfv->AddObject((LPITEMIDLIST)polid, &iItem);
            }
            if (SUCCEEDED(hr))
            {
                //
                // Added new OLID to the listview.  Null out the local
                // ptr so we don't free the IDList later.
                //
                polid = NULL;
            }
        }
        if (NULL != polid)
            ILFree((LPITEMIDLIST)polid);
    }

    return hr;
}



//
// Retrieve the listview index for a give OLID.
// Returns:  Index of item or -1 if not found.
//
UINT
COfflineFilesViewCallback::ItemIndexFromOLID(
    LPCOLID polid
    )
{
    TraceAssert(NULL != polid);

    UINT iItem = (UINT)-1;
    UINT cItems;
    //
    // Lock so that list remains consistent while we locate the item.
    //
    Lock();
    if (SUCCEEDED(_psfv->GetObjectCount(&cItems)))
    {
        for (UINT i = 0; i < cItems; i++)
        {
            LPCITEMIDLIST pidl;
            if (SUCCEEDED(_psfv->GetObject((LPITEMIDLIST *)&pidl, i)))
            {
                //
                // Do name comparison first since it is least likely to find a match.
                //
                if (S_OK == _pfolder->CompareIDs(ICOL_NAME, pidl, (LPCITEMIDLIST)polid) &&
                    S_OK == _pfolder->CompareIDs(ICOL_LOCATION, pidl, (LPCITEMIDLIST)polid))
                {
                    iItem = i;
                    break;
                }
            }
        }
    }
        
    Unlock();        
    return (UINT)iItem;
}



//-----------------------------------------------------------------------------
// COfflineFilesViewEnum
//-----------------------------------------------------------------------------
COfflineFilesViewEnum::COfflineFilesViewEnum(
    void
    ) 
    : m_cRef(1),
      m_iAddView(0)
{

}

COfflineFilesViewEnum::~COfflineFilesViewEnum(
    void
    )
{

}


HRESULT
COfflineFilesViewEnum::CreateInstance(
    IEnumSFVViews **ppenum
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    COfflineFilesViewEnum *pEnum = new COfflineFilesViewEnum;
    if (NULL != pEnum)
    {
        hr = pEnum->QueryInterface(IID_IEnumSFVViews, (void **)ppenum);
    }    
    return hr;
}



STDMETHODIMP 
COfflineFilesViewEnum::QueryInterface (
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineFilesViewEnum, IEnumSFVViews),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) 
COfflineFilesViewEnum::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) 
COfflineFilesViewEnum::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP 
COfflineFilesViewEnum::Next(
    ULONG celt, 
    SFVVIEWSDATA **ppData, 
    ULONG *pceltFetched
    )
{
    HRESULT hr = S_FALSE;
    ULONG celtFetched = 0;
    
    if (!celt || !ppData || (celt > 1 && !pceltFetched))
    {
        return E_INVALIDARG;
    }

    if (0 == m_iAddView)
    {
        //
        // All we add is Thumbnail view.
        //
        ppData[0] = (SFVVIEWSDATA *) SHAlloc(sizeof(SFVVIEWSDATA));
        if (ppData[0])
        {
            ppData[0]->idView         = CLSID_ThumbnailViewExt;
            ppData[0]->idExtShellView = CLSID_ThumbnailViewExt;
            ppData[0]->dwFlags        = SFVF_TREATASNORMAL | SFVF_NOWEBVIEWFOLDERCONTENTS;
            ppData[0]->lParam         = 0x00000011;
            ppData[0]->wszMoniker[0]  = 0;

            celtFetched++;
            m_iAddView++;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    if ( pceltFetched )
    {
        *pceltFetched = celtFetched;
    }
    
    return hr;
}

STDMETHODIMP 
COfflineFilesViewEnum::Skip(
    ULONG celt
    )
{
    if (celt && !m_iAddView)
    {
        m_iAddView++;
        celt--;
    }

    return (celt ? S_FALSE : S_OK );
}

STDMETHODIMP COfflineFilesViewEnum::Reset(
    void
    )
{
    m_iAddView = 0;
    return NOERROR;
}


STDMETHODIMP 
COfflineFilesViewEnum::Clone(
    IEnumSFVViews **ppenum
    )
{
    return CreateInstance(ppenum);
}


//-----------------------------------------------------------------------------
// COfflineDetails
//-----------------------------------------------------------------------------

COfflineDetails::COfflineDetails(
    COfflineFilesFolder *pfolder
    ) : _cRef (1)
{
    _pfolder = pfolder;
    _pfolder->AddRef();
}


COfflineDetails::~COfflineDetails()
{
    if (_pfolder)
        _pfolder->Release();

}


STDMETHODIMP 
COfflineDetails::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineDetails, IShellDetails),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG) 
COfflineDetails::AddRef(
    void
    )
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) 
COfflineDetails::Release(
    void
    )
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef); 
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



//-----------------------------------------------------------------------------
// CFileTypeCache
//
// Implements a simple hash table for storing file type strings keyed on
// file extension.
//
//-----------------------------------------------------------------------------
CFileTypeCache::CFileTypeCache(
    int cBuckets
    ) : m_cBuckets(cBuckets),
        m_prgBuckets(NULL)
{
    InitializeCriticalSection(&m_cs);
}


CFileTypeCache::~CFileTypeCache(
    void
    )
{
    Lock();
    if (NULL != m_prgBuckets)
    {
        for (int i = 0; i < m_cBuckets; i++)
        {
            while(NULL != m_prgBuckets[i])
            {
                CEntry *pDelThis = m_prgBuckets[i];
                m_prgBuckets[i]  = m_prgBuckets[i]->Next();
                delete pDelThis;
            }
        }
        delete[] m_prgBuckets;
        m_prgBuckets = NULL;
    }
    Unlock();
    DeleteCriticalSection(&m_cs);
}


CFileTypeCache::CEntry *
CFileTypeCache::Lookup(
    LPCTSTR pszExt
    )
{
    if (NULL != m_prgBuckets)
    {
        for (CEntry *pEntry = m_prgBuckets[Hash(pszExt)]; pEntry; pEntry = pEntry->Next())
        {
            if (0 == pEntry->CompareExt(pszExt))
                return pEntry;
        }
    }
    return NULL;
}



HRESULT
CFileTypeCache::Add(
    LPCTSTR pszExt,
    LPCTSTR pszTypeName
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL != m_prgBuckets)
    {
        CEntry *pNewEntry = new CEntry(pszExt, pszTypeName);
        if (NULL != pNewEntry && pNewEntry->IsValid())
        {
            //
            // Link new entry at the head of the bucket's linked list.
            //
            int iHash = Hash(pszExt);
            pNewEntry->SetNext(m_prgBuckets[iHash]);
            m_prgBuckets[iHash] = pNewEntry;
            hr = NOERROR;
        }
        else
        {
            delete pNewEntry;
        }
    }
    return hr;
}



HRESULT
CFileTypeCache::GetTypeName(
    LPCTSTR pszPath,          // Can be full path or only "filename.ext".
    DWORD dwFileAttributes,
    LPTSTR pszDest,
    int cchDest
    )
{
    HRESULT hr = S_OK;
    Lock();
    if (NULL == m_prgBuckets)
    {
        //
        // Create hash bucket array on-demand.  This way it's not
        // created until someone asks for something from the cache.
        // Simple "creation" of the cache object is therefore cheap.
        //
        m_prgBuckets = new CEntry* [m_cBuckets];
        if (NULL != m_prgBuckets)
        {
            ZeroMemory(m_prgBuckets, sizeof(m_prgBuckets[0]) * m_cBuckets);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        SHFILEINFO sfi;
        LPCTSTR pszTypeName = NULL;
        LPCTSTR pszExt      = ::PathFindExtension(pszPath);

        //
        // Note that Lookup will gracefully fail if the hash bucket array
        // creation failed.  In that case we'll get the info from 
        // SHGetFileInfo and return it directly to the caller.  This means
        // that failure to create the cache is not fatal.  It just means we
        // don't cache any data.
        //
        CEntry *pEntry = Lookup(pszExt);
        if (NULL != pEntry)
        {
            // Cache hit.
            pszTypeName = pEntry->TypeName();
        }
        if (NULL == pszTypeName)
        {
            // Cache miss.
            if (SHGetFileInfo(::PathFindFileName(pszPath), 
                              dwFileAttributes, 
                              &sfi, 
                              sizeof(sfi), 
                              SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES))
            {
                //
                // Add new entry to cache.  We're not concerned if the 
                // addition fails.  It just means we'll get a cache miss
                // on this item next time and repeat the SHGetFileInfo call.
                //
                pszTypeName = sfi.szTypeName;
                Add(pszExt, sfi.szTypeName);
            }
        }
        if (NULL != pszTypeName)
        {
            hr = StringCchCopy(pszDest, cchDest, pszTypeName);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    Unlock();
    return hr;
}



int
CFileTypeCache::Hash(
    LPCTSTR pszExt
    )
{
    int iSum = 0;
    while(*pszExt)
        iSum += int(*pszExt++);

    return iSum % m_cBuckets;
}



CFileTypeCache::CEntry::CEntry(
    LPCTSTR pszExt,
    LPCTSTR pszTypeName
    ) : m_pNext(NULL)
{
    m_pszExt      = StrDup(pszExt);
    m_pszTypeName = StrDup(pszTypeName);
}


CFileTypeCache::CEntry::~CEntry(
    void
    )
{
    if (NULL != m_pszExt)
    {
        LocalFree(m_pszExt);
    }
    if (NULL != m_pszTypeName)
    {
        LocalFree(m_pszTypeName);
    }
}


//
// This function creates our standard offline-files context menu.
// This is the one used by the shell that inserts the 
// "Make Available Offline" and "Synchronize" items.
//
HRESULT
CreateOfflineFilesContextMenu(
    IDataObject *pdtobj,
    REFIID riid,
    void **ppv
    )
{
    TraceAssert(NULL != ppv);

    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    CCscShellExt *pse = new CCscShellExt;
    if (NULL != pse)
    {
        IShellExtInit *psei;
        hr = pse->QueryInterface(IID_IShellExtInit, (void **)&psei);
        pse->Release();
        if (SUCCEEDED(hr))
        {
            if (NULL != pdtobj)
                hr = psei->Initialize(NULL, pdtobj, NULL);

            if (SUCCEEDED(hr))
            {
                hr = psei->QueryInterface(riid, ppv);
            }
            psei->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\fopendlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fopendlg.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "fopendlg.h"
#include "termserv.h"

INT_PTR CALLBACK 
OpenFilesWarningProc(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    switch(uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg,
                               IDC_DLGTYPEICON,
                               STM_SETICON,
                               (WPARAM)LoadIcon(NULL, IDI_WARNING),
                               0L);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
                    return TRUE;
            }
            break;

        default:
            break;
    }
    return FALSE;
}


int
OpenFilesWarningDialog(
    HWND hwndParent
    )
{
    UINT idDlgTemplate = IDD_OPEN_FILES_WARNING;
    if (S_OK == TS_MultipleSessions())
    {
        idDlgTemplate = IDD_OPEN_FILES_WARNING_MULTIUSER;
    }
    return (int)DialogBox(g_hInstance, 
                          MAKEINTRESOURCE(idDlgTemplate), 
                          hwndParent, 
                          OpenFilesWarningProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\fmtetc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fmtetc.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_FMTETC_H
#define _INC_CSCUI_FMTETC_H

class CEnumFormatEtc : public IEnumFORMATETC
{
    public:
        CEnumFormatEtc(UINT cFormats, LPFORMATETC prgFormats);
        CEnumFormatEtc(const CEnumFormatEtc& ef);
        ~CEnumFormatEtc(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvOut);
        STDMETHODIMP_(ULONG) AddRef(VOID);
        STDMETHODIMP_(ULONG) Release(VOID);

        //
        // IEnumFORMATETC methods.
        //
        STDMETHODIMP Next(DWORD, LPFORMATETC, LPDWORD);
        STDMETHODIMP Skip(DWORD);
        STDMETHODIMP Reset(VOID);
        STDMETHODIMP Clone(IEnumFORMATETC **);

        //
        // Called to add formats to the enumerator.  Used by ctors.
        //
        HRESULT AddFormats(UINT cFormats, LPFORMATETC prgFormats);
        //
        // For implementations non-exception throwing clients.
        //
        bool IsValid(void) const
            { return SUCCEEDED(m_hrCtor); }

    private:
        LONG        m_cRef;
        int         m_cFormats;
        int         m_iCurrent;
        LPFORMATETC m_prgFormats;
        HRESULT     m_hrCtor;

        //
        // Prevent assignment.
        //
        void operator = (const CEnumFormatEtc&);
};
        
#endif // _INC_CSCUI_FMTETC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\fopendlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fopendlg.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_FOPENDLG_H
#define _INC_CSCUI_FOPENDLG_H

int OpenFilesWarningDialog(HWND hwndParent = NULL);

#endif // _INC_CSCUI_FOPENDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\idldata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       idldata.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


#include "fmtetc.h"
#include "idldata.h"
#include "shsemip.h"


CLIPFORMAT CIDLData::m_rgcfGlobal[ICF_MAX] = { CF_HDROP, 0 };
const LARGE_INTEGER CIDLData::m_LargeIntZero;

//
// For those who prefer a function (rather than a ctor) to create an object,
// this static function will return a pointer to the IDataObject interface.
// If the function fails, no object is created.
//
HRESULT 
CIDLData::CreateInstance(
    IDataObject **ppOut,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST *apidl,
    IShellFolder *psfOwner,
    IDataObject *pdtInner
    )
{
    CIDLData *pidlData;
    HRESULT hr = CreateInstance(&pidlData, pidlFolder, cidl, apidl, psfOwner, pdtInner);
    if (SUCCEEDED(hr))
    {
        pidlData->AddRef();
        hr = pidlData->QueryInterface(IID_IDataObject, (void **)ppOut);
        pidlData->Release();
    }
    else
    {
        *ppOut = NULL;
    }
    return hr;
}


//
// For those who prefer a function (rather than a ctor) to create an object,
// this static function will return a pointer to the CIDLData object.
// If the function fails, no object is created.  Note that the returned object
// has a ref count of 0.  Therefore, it acts as a normal C++ object.  If you 
// want it to participate as a COM object, QI for IDataObject or use the 
// IDataObject version of CreateInstance() above.
//
HRESULT 
CIDLData::CreateInstance(
    CIDLData **ppOut,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST *apidl,
    IShellFolder *psfOwner,
    IDataObject *pdtInner
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CIDLData *pidlData = new CIDLData(pidlFolder, cidl, apidl, psfOwner, pdtInner);
    if (NULL != pidlData)
    {
        hr = pidlData->CtorResult();
        if (SUCCEEDED(hr))
        {
            *ppOut = pidlData;
        }
        else
        {
            delete pidlData;
        }
    }
    return hr;
}


CIDLData::CIDLData(
    LPCITEMIDLIST pidlFolder, 
    UINT cidl, 
    LPCITEMIDLIST *apidl, 
    IShellFolder *psfOwner,       // Optional.  Default is NULL.
    IDataObject *pdtobjInner      // Optional.  Default is NULL.
    ) : m_cRef(0),
        m_hrCtor(NOERROR),
        m_psfOwner(NULL),
        m_dwOwnerData(0),
        m_pdtobjInner(pdtobjInner),
        m_bEnumFormatCalled(false)
{
    //
    // Initialize the global clipboard formats.
    //
    InitializeClipboardFormats();

    ZeroMemory(m_rgMedium, sizeof(m_rgMedium));
    ZeroMemory(m_rgFmtEtc, sizeof(m_rgFmtEtc));

    if (NULL != m_pdtobjInner)
        m_pdtobjInner->AddRef();

    //
    // Empty array is valid input.
    //
    if (NULL != apidl)
    {
        HIDA hida = HIDA_Create(pidlFolder, cidl, apidl);
        if (NULL != hida)
        {
            m_hrCtor = DataObject_SetGlobal(static_cast<IDataObject *>(this), g_cfHIDA, hida);
            if (SUCCEEDED(m_hrCtor))
            {
                if (NULL != psfOwner)
                {
                    m_psfOwner = psfOwner;
                    m_psfOwner->AddRef();
                }
            }
        }
        else
        {
            m_hrCtor = E_OUTOFMEMORY;
        }
    }
}


CIDLData::~CIDLData(
    void
    )
{
    for (int i = 0; i < ARRAYSIZE(m_rgMedium); i++)
    {
        if (m_rgMedium[i].hGlobal)
            ReleaseStgMedium(&(m_rgMedium[i]));
    }

    if (NULL != m_psfOwner)
        m_psfOwner->Release();

    if (NULL != m_pdtobjInner)
        m_pdtobjInner->Release();
}



STDMETHODIMP 
CIDLData::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(CIDLData, IDataObject),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG)
CIDLData::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}



STDMETHODIMP_(ULONG) 
CIDLData::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT
CIDLData::GetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pMedium
    )
{
    HRESULT hr = E_INVALIDARG;

    pMedium->hGlobal        = NULL;
    pMedium->pUnkForRelease = NULL;

    for (int i = 0; i < ARRAYSIZE(m_rgFmtEtc); i++)
    {
        if ((m_rgFmtEtc[i].cfFormat == pFmtEtc->cfFormat) &&
            (m_rgFmtEtc[i].tymed & pFmtEtc->tymed) &&
            (m_rgFmtEtc[i].dwAspect == pFmtEtc->dwAspect))
        {
            *pMedium = m_rgMedium[i];

            if (NULL != pMedium->hGlobal)
            {
                //
                // Indicate that the caller should not release hmem.
                //
                if (TYMED_HGLOBAL == pMedium->tymed)
                {
                    InterlockedIncrement(&m_cRef);
                    pMedium->pUnkForRelease = static_cast<IUnknown *>(this);
                    return S_OK;
                }
                //
                // If the type is stream  then clone the stream.
                //
                if (TYMED_ISTREAM == pMedium->tymed)
                {
                    hr = CreateStreamOnHGlobal(NULL, TRUE, &(pMedium->pstm));

                    if (SUCCEEDED(hr))
                    {
                        STGMEDIUM& medium = m_rgMedium[i];
                        STATSTG stat;

                        //
                        // Get the Current Stream size
                        //
                        hr = medium.pstm->Stat(&stat, STATFLAG_NONAME);

                        if (SUCCEEDED(hr))
                        {
                            //
                            // Seek the source stream to the beginning.
                            //
                            medium.pstm->Seek(m_LargeIntZero, STREAM_SEEK_SET, NULL);
                            //
                            // Copy the entire source into the destination. 
                            // Since the destination stream is created using CreateStreamOnHGlobal, 
                            // it seek pointer is at the beginning.
                            //
                            hr = medium.pstm->CopyTo(pMedium->pstm, stat.cbSize, NULL, NULL);
                            //                            
                            // Before returning Set the destination seek pointer back at the beginning.
                            //
                            pMedium->pstm->Seek(m_LargeIntZero, STREAM_SEEK_SET, NULL);
                            return hr;
                         }
                         else
                         {
                             hr = E_OUTOFMEMORY;
                         }

                    }
                }
            }
        }
    }

    if (E_INVALIDARG == hr && NULL != m_pdtobjInner) 
    {
        hr = m_pdtobjInner->GetData(pFmtEtc, pMedium);
    }

    return hr;
}



STDMETHODIMP 
CIDLData::GetDataHere(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pMedium
    )
{
    HRESULT hr = E_NOTIMPL;

    if (NULL != m_pdtobjInner) 
    {
        hr = m_pdtobjInner->GetDataHere(pFmtEtc, pMedium);
    }

    return hr;
}



HRESULT
CIDLData::QueryGetData(
    FORMATETC *pFmtEtc
    )
{
    HRESULT hr = S_FALSE;

    for (int i = 0; i < ARRAYSIZE(m_rgFmtEtc); i++)
    {
        if ((m_rgFmtEtc[i].cfFormat == pFmtEtc->cfFormat) &&
            (m_rgFmtEtc[i].tymed & pFmtEtc->tymed) &&
            (m_rgFmtEtc[i].dwAspect == pFmtEtc->dwAspect))
        {
            return S_OK;
        }
    }

    if (NULL != m_pdtobjInner)
    {
        hr = m_pdtobjInner->QueryGetData(pFmtEtc);
    }
    return hr;
}



STDMETHODIMP 
CIDLData::GetCanonicalFormatEtc(
    FORMATETC *pFmtEtcIn, 
    FORMATETC *pFmtEtcOut
    )
{
    //
    // This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return DATA_S_SAMEFORMATETC;
}



STDMETHODIMP 
CIDLData::SetData(
    FORMATETC *pFmtEtc, 
    STGMEDIUM *pMedium, 
    BOOL fRelease
    )
{
    HRESULT hr;

    TraceAssert(pFmtEtc->tymed == pMedium->tymed);

    if (fRelease)
    {
        int i;
        //
        // First add it if that format is already present
        // on a NULL medium (render on demand)
        //
        for (i = 0; i < ARRAYSIZE(m_rgFmtEtc); i++)
        {
            if ((m_rgFmtEtc[i].cfFormat == pFmtEtc->cfFormat) &&
                (m_rgFmtEtc[i].tymed    == pFmtEtc->tymed) &&
                (m_rgFmtEtc[i].dwAspect == pFmtEtc->dwAspect))
            {
                //
                // We are simply adding a format, ignore.
                //
                if (NULL == pMedium->hGlobal) 
                {
                    return S_OK;
                }

                //
                // If we are set twice on the same object
                //
                if (NULL != m_rgMedium[i].hGlobal)
                    ReleaseStgMedium(&m_rgMedium[i]);

                m_rgMedium[i] = *pMedium;
                return S_OK;
            }
        }
        //
        // now look for a free slot
        //
        for (i = 0; i < ARRAYSIZE(m_rgFmtEtc); i++)
        {
            if (0 == m_rgFmtEtc[i].cfFormat)
            {
                //
                // found a free slot
                //
                m_rgMedium[i] = *pMedium;
                m_rgFmtEtc[i] = *pFmtEtc;
                return S_OK;
            }
        }
        //
        // fixed size table
        //
        hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


STDMETHODIMP 
CIDLData::EnumFormatEtc(
    DWORD dwDirection, 
    LPENUMFORMATETC *ppenumFormatEtc
    )
{
    HRESULT hr = NOERROR;
    //
    // If this is the first time, build the format list by calling
    // QueryGetData with each clipboard format.
    //
    if (!m_bEnumFormatCalled)
    {
        FORMATETC fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
        for (int i = 0; i < ARRAYSIZE(m_rgcfGlobal); i++)
        {
            fmte.cfFormat = m_rgcfGlobal[i];
            if (S_OK == QueryGetData(&fmte)) 
            {
                SetData(&fmte, &medium, TRUE);
            }
        }
        m_bEnumFormatCalled = true;
    }
    //
    // Get the number of formatetc
    //
    UINT cfmt;
    for (cfmt = 0; cfmt < ARRAYSIZE(m_rgFmtEtc); cfmt++)
    {
        if (0 == m_rgFmtEtc[cfmt].cfFormat)
            break;
    }
/*
    return SHCreateStdEnumFmtEtcEx(cfmt, m_rgFmtEtc, m_pdtobjInner, ppenumFormatEtc);
*/

    CEnumFormatEtc *pEnumFmtEtc = new CEnumFormatEtc(cfmt, m_rgFmtEtc);
    if (NULL != pEnumFmtEtc)
    {
        pEnumFmtEtc->AddRef();
        //
        // Ask derived classes to add their formats.
        //
        hr = ProvideFormats(pEnumFmtEtc);
        if (SUCCEEDED(hr))
        {
            hr = pEnumFmtEtc->QueryInterface(IID_IEnumFORMATETC, (void **)ppenumFormatEtc);
        }
        pEnumFmtEtc->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT 
CIDLData::ProvideFormats(
    CEnumFormatEtc *pEnumFmtEtc
    )
{
    //
    // Base class default does nothing.  Our formats are added to the enumerator
    // in EnumFormatEtc().
    //
    return NOERROR;
}


STDMETHODIMP 
CIDLData::DAdvise(
    FORMATETC *pFmtEtc, 
    DWORD advf, 
    LPADVISESINK pAdvSink, 
    DWORD *pdwConnection
    )
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP 
CIDLData::DUnadvise(
    DWORD dwConnection
    )
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP 
CIDLData::EnumDAdvise(
    LPENUMSTATDATA *ppenumAdvise
    )
{
    return OLE_E_ADVISENOTSUPPORTED;
}


IShellFolder *
CIDLData::GetFolder(
    void
    ) const
{ 
    return m_psfOwner; 
}



//
// Clone DataObject only for MOVE/COPY operation
//
HRESULT
CIDLData::Clone(
    UINT *acf, 
    UINT ccf, 
    IDataObject **ppdtobjOut
    )
{
    HRESULT hr = NOERROR;
    CIDLData *pidlData = new CIDLData(NULL, 0, NULL);
    if (NULL == pidlData)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        FORMATETC fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        for (UINT i = 0; i < ccf; i++)
        {
            HRESULT hrT;
            STGMEDIUM medium;
            fmte.cfFormat = (CLIPFORMAT) acf[i];
            hrT = GetData(&fmte, &medium);
            if (SUCCEEDED(hrT))
            {
                HGLOBAL hmem;
                if (NULL != medium.pUnkForRelease)
                {
                    //
                    // We need to clone the hGlobal.
                    //
                    SIZE_T cbMem =  GlobalSize(medium.hGlobal);
                    hmem = GlobalAlloc(GPTR, cbMem);
                    if (NULL != hmem)
                    {
                        hmemcpy((LPVOID)hmem, GlobalLock(medium.hGlobal), cbMem);
                        GlobalUnlock(medium.hGlobal);
                    }
                    ReleaseStgMedium(&medium);
                }
                else
                {
                    //
                    // We don't need to clone the hGlobal.
                    //
                    hmem = medium.hGlobal;
                }

                if (hmem)
                    DataObject_SetGlobal(*ppdtobjOut, (CLIPFORMAT)acf[i], hmem);
            }
        }
    }
    return hr;
}


HRESULT 
CIDLData::CloneForMoveCopy(
    IDataObject **ppdtobjOut
    )
{
    return E_NOTIMPL;
    /*
    UINT acf[] = { g_cfHIDA, g_cfOFFSETS, CF_HDROP, g_cfFileNameMapW, g_cfFileNameMap };

    return Clone(acf, ARRAYSIZE(acf), ppdtobjOut);
    */
}


#define RCF(x)  (CLIPFORMAT) RegisterClipboardFormat(x)

void 
CIDLData::InitializeClipboardFormats(
    void
    )
{
    if (g_cfHIDA == 0)
    {
        g_cfHIDA                 = RCF(CFSTR_SHELLIDLIST);
        g_cfOFFSETS              = RCF(CFSTR_SHELLIDLISTOFFSET);
        g_cfNetResource          = RCF(CFSTR_NETRESOURCES);
        g_cfFileContents         = RCF(CFSTR_FILECONTENTS);         // "FileContents"
        g_cfFileGroupDescriptorA = RCF(CFSTR_FILEDESCRIPTORA);      // "FileGroupDescriptor"
        g_cfFileGroupDescriptorW = RCF(CFSTR_FILEDESCRIPTORW);      // "FileGroupDescriptor"
        g_cfPrivateShellData     = RCF(CFSTR_SHELLIDLISTP);
        g_cfFileName             = RCF(CFSTR_FILENAMEA);            // "FileName"
        g_cfFileNameW            = RCF(CFSTR_FILENAMEW);            // "FileNameW"
        g_cfFileNameMap          = RCF(CFSTR_FILENAMEMAP);          // "FileNameMap"
        g_cfFileNameMapW         = RCF(CFSTR_FILENAMEMAPW);         // "FileNameMapW"
        g_cfPrinterFriendlyName  = RCF(CFSTR_PRINTERGROUP);
        g_cfHTML                 = RCF(TEXT("HTML Format"));
        g_cfPreferredDropEffect  = RCF(CFSTR_PREFERREDDROPEFFECT);  // "Preferred DropEffect"
        g_cfPerformedDropEffect  = RCF(CFSTR_PERFORMEDDROPEFFECT);  // "Performed DropEffect"
        g_cfLogicalPerformedDropEffect = RCF(CFSTR_LOGICALPERFORMEDDROPEFFECT);
        g_cfShellURL             = RCF(CFSTR_SHELLURL);             // "Uniform Resource Locator"
        g_cfInDragLoop           = RCF(CFSTR_INDRAGLOOP);           // "InShellDragLoop"
        g_cfDragContext          = RCF(CFSTR_DRAGCONTEXT);          // "DragContext"
        g_cfTargetCLSID          = RCF(TEXT("TargetCLSID"));        // who the drag drop went to
    }
}


//
// This is normally a private shell function.
//
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

CIDLData::HIDA
CIDLData::HIDA_Create(
    LPCITEMIDLIST pidlFolder, 
    UINT cidl, 
    LPCITEMIDLIST *apidl
    )
{
    HIDA hida;
#if _MSC_VER == 1100
//  Workaround code generate bug in VC5 X86 compiler (12/30 version).
    volatile
#endif
    UINT i;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbTotal = offset + ILGetSize(pidlFolder);
    for (i=0; i<cidl ; i++) {
        cbTotal += ILGetSize(apidl[i]);
    }

    hida = GlobalAlloc(GPTR, cbTotal);  // This MUST be GlobalAlloc!!!
    if (hida)
    {
        LPIDA pida = (LPIDA)hida;       // no need to lock

        LPCITEMIDLIST pidlNext;
        pida->cidl = cidl;

        for (i=0, pidlNext=pidlFolder; ; pidlNext=apidl[i++])
        {
            UINT cbSize = ILGetSize(pidlNext);
            pida->aoffset[i] = offset;
            MoveMemory(((LPBYTE)pida)+offset, pidlNext, cbSize);
            offset += cbSize;

            TraceAssert(ILGetSize(HIDA_GetPIDLItem(pida,i-1)) == cbSize);

            if (i==cidl)
                break;
        }

        TraceAssert(offset == cbTotal);
    }

    return hida;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\folder.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       folder.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_FOLDER_H
#define _INC_CSCUI_FOLDER_H

#include <shellp.h>     // IShellDetails
#include <shlguidp.h>   // IShellFolderViewCb
#include <shlwapip.h>   // QITAB, QISearch
#include <shsemip.h>    // ILFree(), etc
#include <sfview.h>
#include <comctrlp.h>
#include "util.h"

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define OLID_SIG    0x4444

#pragma pack(1)
// PIDL format for CSC cache non leaf items...
typedef struct
{
    USHORT      cb;                 // Total size of IDList.
    USHORT      uSig;               // IDList signature.
    DWORD       cbFixed;            // Fixed size of IDList.
    DWORD       dwFileAttributes;   // Win32 file attributes.
    DWORD       dwStatus;           // CSC file/folder status flags.
    DWORD       dwServerStatus;     // CSC server status flags.
    DWORD       dwPinCount;         // CSC pin count.
    DWORD       dwHintFlags;        // CSC "hint" flags.
    DWORD       dwFileSizeHigh;     // Win32 file size.
    DWORD       dwFileSizeLow;
    FILETIME    ft;                 // Last write time (from CSC).
    DWORD       cchNameOfs;         // Offset of name part from szPath[0].
    TCHAR       szPath[0];          // path<nul>name<nul>  (variable length).
} OLID;
typedef UNALIGNED OLID *LPOLID;
typedef const UNALIGNED OLID *LPCOLID;
#pragma pack()

class COfflineFilesEnum;    // forward
class COfflineFilesViewCallback;
class COfflineDetails;
class COfflineItemsData;
class COfflineItems;
class CFolderCache;



//----------------------------------------------------------------------------
// CFileTypeCache
//----------------------------------------------------------------------------

class CFileTypeCache
{
    public:
        explicit CFileTypeCache(int cBuckets);
        ~CFileTypeCache(void);

        HRESULT GetTypeName(
            LPCTSTR pszPath, 
            DWORD dwFileAttributes, 
            LPTSTR pszDest, 
            int cchDest);

    private:
        class CEntry
        {
            public:
                CEntry(LPCTSTR pszExt, LPCTSTR pszTypeName);
                ~CEntry(void);

                void SetNext(CEntry *pNext)
                    { m_pNext = pNext; }

                CEntry *Next(void) const
                    { return m_pNext; }

                int CompareExt(LPCTSTR pszExt) const
                    { return lstrcmpi(m_pszExt, pszExt); }

                LPCTSTR TypeName(void) const
                    { return m_pszTypeName; }

                bool IsValid(void) const
                    { return (NULL != m_pszExt) && (NULL != m_pszTypeName); }

            private:
                LPTSTR m_pszExt;
                LPTSTR m_pszTypeName;
                CEntry *m_pNext;       // Next in hash bucket.

                //
                // Prevent copy.
                //
                CEntry(const CEntry& rhs);
                CEntry& operator = (const CEntry& rhs);
        };

        int      m_cBuckets;
        CEntry **m_prgBuckets;
        CRITICAL_SECTION m_cs;

        int Hash(LPCTSTR pszExt);
        CEntry *Lookup(LPCTSTR pszExt);
        HRESULT Add(LPCTSTR pszExt, LPCTSTR pszTypeName);

        void Lock(void)
            { EnterCriticalSection(&m_cs); }

        void Unlock(void)
            { LeaveCriticalSection(&m_cs); }

        //
        // Prevent copy.
        //
        CFileTypeCache(const CFileTypeCache& rhs);
        CFileTypeCache& operator = (const CFileTypeCache& rhs);
};



STDAPI COfflineFilesFolder_CreateInstance(REFIID riid, void **ppv);




class COfflineFilesFolder : public IPersistFolder2, 
                                   IShellFolder, 
                                   IShellIcon, 
                                   IShellIconOverlay
{
public:
    static HRESULT WINAPI CreateInstance(REFIID riid, void **ppv);
    static INT Open(void);
    static HRESULT CreateIDList(LPITEMIDLIST *ppidl);
    static HRESULT IdentifyIDList(LPCITEMIDLIST pidl);
    static HRESULT CreateLinkOnDesktop(HWND hwndParent);
    static HRESULT IsLinkOnDesktop(HWND hwndParent, LPTSTR pszPathOut, UINT cchPathOut);
    static HRESULT GetFolder(IShellFolder **ppsf);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName,
                                ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST* ppidlOut);

    // IPersist
    STDMETHOD(GetClassID)(LPCLSID pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *pidl);

    // IShellIcon
    STDMETHOD(GetIconOf)(LPCITEMIDLIST pidl, UINT gil, int *pnIcon);

    // IShellIconOverlay
    STDMETHOD(GetOverlayIndex)(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHOD(GetOverlayIconIndex)(LPCITEMIDLIST pidl, int * pIconIndex);

    static bool ValidateIDList(LPCITEMIDLIST pidl);

private:

    friend COfflineFilesEnum;
    friend COfflineFilesViewCallback;
    friend COfflineDetails;
    friend COfflineItemsData;
    friend COfflineItems;
    friend CFolderCache;

    friend HRESULT COfflineFilesFolder_CreateInstance(REFIID riid, void **ppv);


    COfflineFilesFolder();
    ~COfflineFilesFolder();

    void _GetSyncStatusString(LPCOLID polid, LPTSTR pszStatus, UINT cchStatus);
    void _GetPinStatusString(LPCOLID polid, LPTSTR pszStatus, UINT cchStatus);
    void _GetServerStatusString(LPCOLID polid, LPTSTR pszStatus, UINT cchStatus);
    void _GetTypeString(LPCOLID polid, LPTSTR pszType, UINT cchType);
    void _GetAccessString(LPCOLID polid, LPTSTR pszAccess, UINT cchAccess);
    HRESULT GetAssociations(LPCOLID polid, void **ppvQueryAssociations);
    BOOL GetClassKey(LPCOLID polid, HKEY *phkeyProgID, HKEY *phkeyBaseID);
    static LPCOLID _Validate(LPCITEMIDLIST pidl);
    static HRESULT IsOurLink(LPCTSTR pszFile);
    static HRESULT _BindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
    static HRESULT ContextMenuCB(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static HRESULT OLID_GetFullPath(LPCOLID polid, LPTSTR pszPath, UINT cchPath);
    static LPCTSTR OLID_GetFileName(LPCOLID polid, LPTSTR pszName, UINT cchName);
    static HRESULT OLID_CreateFromUNCPath(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, DWORD dwStatus, DWORD dwPinCount, DWORD dwHintFlags, DWORD dwServerStatus, LPOLID *ppolid);
    static void    OLID_GetWin32FindData(LPCOLID polid, WIN32_FIND_DATA *pfd);
    static HRESULT OLID_Bind(LPCOLID polid, REFIID riid, void **ppv, LPITEMIDLIST *ppidlFull, LPCITEMIDLIST *ppidlItem);
    static HRESULT OLID_CreateSimpleIDList(LPCOLID polid, LPITEMIDLIST *ppidlOut);

    LONG _cRef;
    LPITEMIDLIST _pidl;
    IShellFolderViewCB *_psfvcb;
    CFileTypeCache m_FileTypeCache;
};


//
// This class represents a simple cache of CSC status bits for each 
// server in the CSC cache.  The reason we need this is sort of bogus
// but we have no control over it.  When enumerating shares in the CSC
// database, shares on the same server might not return the same online-offline
// status depending on if the share really has a connection or not.  The
// problem is that in the network redirector an entire server is either
// online or offline.  We display "server" status in the UI so we need to
// merge the status information from each share in the database so that
// we have status information for each server.  Clear as mud?  This cache
// implements that merging of information so that all a client (i.e. the
// enum code) has to do is call GetServerStatus() with a given UNC path and
// they'll get the status we should be reporting for that path's server.
//
class CServerStatusCache
{
    public:
        CServerStatusCache(void)
            : m_hdpa(NULL) { }

        ~CServerStatusCache(void);
        //
        // This is the only public API for this class.  When it's
        // called for the first time, the cache is populated.  Therefore,
        // you can create a cache object but you're not charged much
        // until you need to use it.
        //
        DWORD GetServerStatus(LPCTSTR pszUNC);

    private:
        //
        // A single entry in the cache.
        //
        class CEntry
        {
            public:
                CEntry(LPCTSTR pszServer, DWORD dwStatus);
                ~CEntry(void);

                void AddStatus(DWORD dwStatus)
                    { m_dwStatus |= dwStatus; }

                DWORD GetStatus(void) const
                    { return m_dwStatus; }

                LPCTSTR GetServer(void) const
                    { return m_pszServer; }

                bool IsValid(void) const
                    { return NULL != m_pszServer; }

            private:
                LPTSTR m_pszServer;
                DWORD  m_dwStatus;

                //
                // Prevent copy.
                //
                CEntry(const CEntry& rhs);
                CEntry& operator = (const CEntry& rhs);
        };

        HDPA m_hdpa;  // The DPA for holding entries.

        bool AddShareStatus(LPCTSTR pszShare, DWORD dwShareStatus);
        CEntry *FindEntry(LPCTSTR pszShare);
        LPTSTR ServerFromUNC(LPCTSTR pszShare, LPTSTR pszServer, UINT cchServer);

        //
        // Prevent copy.
        //
        CServerStatusCache(const CServerStatusCache& rhs);
        CServerStatusCache& operator = (const CServerStatusCache& rhs);
};



class COfflineFilesEnum : public IEnumIDList
{
public:
    COfflineFilesEnum(DWORD grfFlags, COfflineFilesFolder *pfolder);
    bool IsValid(void) const;
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods 
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    //
    // Element of the folder path stack. (_hdsaFolderPaths).
    // Includes length to reduce length calculations.
    //
    struct FolderPathInfo
    {
        DWORD cchPath;   // Chars in path including nul term.
        LPTSTR pszPath;  // Folder path string.
    };

    ~COfflineFilesEnum();

    LONG                _cRef;          // ref count
    COfflineFilesFolder *_pfolder;      // this is what we enumerate    
    UINT                _grfFlags;      // enumeration flags 
    CCscFindHandle      _hEnumShares;
    CCscFindHandle      _hEnum;
    HDSA                _hdsaFolderPathInfo; // A stack of FolderPathInfo.
    LPTSTR              _pszPath;            // Dynamic scratch buffer for paths.
    INT                 _cchPathBuf;         // Current length of _pszPath buffer. 
    DWORD               _dwServerStatus;     // dwStatus flags for current server.
    CServerStatusCache  _ServerStatusCache;
    bool                _bShowSuperHiddenFiles;
    bool                _bShowHiddenFiles;
    bool                _bUserIsAdmin;

private:
    bool PopFolderPathInfo(FolderPathInfo *pfpi);

    bool PushFolderPathInfo(const FolderPathInfo& fpi)
        { return (-1 != DSA_AppendItem(_hdsaFolderPathInfo, (LPVOID)&fpi)); }

    bool SaveFolderPath(LPCTSTR pszRoot, LPCTSTR pszFolder);

    bool Exclude(const CscFindData& cscfd);

    bool OkToEnumFolder(const CscFindData& cscfd);

    bool UserHasAccess(const CscFindData& cscfd);

    HRESULT GrowPathBuffer(INT cchRequired, INT cchExtra);

};


//----------------------------------------------------------------------------
// Delete handler
//
// This class packages up the operation of deleting a selection of files
// from the folder view.  These methods could easily be made members of
// the COfflineFilesFolder class.  I think the separation is reasonable.
//----------------------------------------------------------------------------
class CFolderDeleteHandler
{
    public:
        CFolderDeleteHandler(HWND hwndParent, IDataObject *pdtobj, IShellFolderViewCB *psfvcb);
        ~CFolderDeleteHandler(void);

        HRESULT DeleteFiles(void);

    private:
        HWND                  m_hwndParent;// Parent for any UI.
        IDataObject          *m_pdtobj;    // Data object containing IDArray.
        IShellFolderViewCB   *m_psfvcb;    // View callback for view notifications.

        static INT_PTR ConfirmDeleteFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static INT_PTR ConfirmDeleteModifiedFileDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        bool ConfirmDeleteFiles(HWND hwndParent);
        bool ConfirmDeleteModifiedFile(HWND hwndParent, LPCTSTR pszFile, bool *pbNoToAll, bool *pbCancel);
        bool FileModifiedOffline(LPCTSTR pszFile);
        bool OthersHaveAccess(LPCTSTR pszFile);
};



HRESULT
CreateOfflineFilesContextMenu(
    IDataObject *pdtobj,
    REFIID riid,
    void **ppv);



#endif // _INC_CSCUI_FOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\idldata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       idldata.h
//
//--------------------------------------------------------------------------

#ifndef _INC_SHELL_IDLDATA_H
#define _INC_SHELL_IDLDATA_H

#include "fmtetc.h"

//
// Clipboard Format for IDLData object.
//
#define ICFHDROP                        0
#define ICFFILENAME                     1
#define ICFNETRESOURCE                  2
#define ICFFILECONTENTS                 3
#define ICFFILEGROUPDESCRIPTORA         4
#define ICFFILENAMEMAPW                 5
#define ICFFILENAMEMAP                  6
#define ICFHIDA                         7
#define ICFOFFSETS                      8
#define ICFPRINTERFRIENDLYNAME          9
#define ICFPRIVATESHELLDATA             10
#define ICFHTML                         11
#define ICFFILENAMEW                    12
#define ICFFILEGROUPDESCRIPTORW         13
#define ICFPREFERREDDROPEFFECT          14
#define ICFPERFORMEDDROPEFFECT          15
#define ICFLOGICALPERFORMEDDROPEFFECT   16
#define ICFSHELLURL                     17
#define ICFINDRAGLOOP                   18
#define ICF_DRAGCONTEXT                 19
#define ICF_TARGETCLSID                 20
#define ICF_MAX                         21

#define g_cfNetResource                 CIDLData::m_rgcfGlobal[ICFNETRESOURCE]
#define g_cfHIDA                        CIDLData::m_rgcfGlobal[ICFHIDA]
#define g_cfOFFSETS                     CIDLData::m_rgcfGlobal[ICFOFFSETS]
#define g_cfPrinterFriendlyName         CIDLData::m_rgcfGlobal[ICFPRINTERFRIENDLYNAME]
#define g_cfFileName                    CIDLData::m_rgcfGlobal[ICFFILENAME]
#define g_cfFileContents                CIDLData::m_rgcfGlobal[ICFFILECONTENTS]
#define g_cfFileGroupDescriptorA        CIDLData::m_rgcfGlobal[ICFFILEGROUPDESCRIPTORA]
#define g_cfFileGroupDescriptorW        CIDLData::m_rgcfGlobal[ICFFILEGROUPDESCRIPTORW]
#define g_cfFileNameMapW                CIDLData::m_rgcfGlobal[ICFFILENAMEMAPW]
#define g_cfFileNameMapA                CIDLData::m_rgcfGlobal[ICFFILENAMEMAP]
#define g_cfPrivateShellData            CIDLData::m_rgcfGlobal[ICFPRIVATESHELLDATA]
#define g_cfHTML                        CIDLData::m_rgcfGlobal[ICFHTML]
#define g_cfFileNameW                   CIDLData::m_rgcfGlobal[ICFFILENAMEW]
#define g_cfPreferredDropEffect         CIDLData::m_rgcfGlobal[ICFPREFERREDDROPEFFECT]
#define g_cfPerformedDropEffect         CIDLData::m_rgcfGlobal[ICFPERFORMEDDROPEFFECT]
#define g_cfLogicalPerformedDropEffect  CIDLData::m_rgcfGlobal[ICFLOGICALPERFORMEDDROPEFFECT]
#define g_cfShellURL                    CIDLData::m_rgcfGlobal[ICFSHELLURL]
#define g_cfInDragLoop                  CIDLData::m_rgcfGlobal[ICFINDRAGLOOP]
#define g_cfDragContext                 CIDLData::m_rgcfGlobal[ICF_DRAGCONTEXT]
#define g_cfTargetCLSID                 CIDLData::m_rgcfGlobal[ICF_TARGETCLSID]

// Most places will only generate one so minimize the number of changes in the code (bad idea!)
#ifdef UNICODE
#define g_cfFileNameMap         g_cfFileNameMapW
#else
#define g_cfFileNameMap         g_cfFileNameMapA
#endif

class CIDLData : public IDataObject
{
    public:
        CIDLData(LPCITEMIDLIST pidlFolder, 
                 UINT cidl, 
                 LPCITEMIDLIST *apidl, 
                 IShellFolder *psfOwner = NULL,
                 IDataObject *pdtInner = NULL);

        virtual ~CIDLData(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        //
        // IDataObject methods.
        //
        STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHODIMP GetDataHere(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
        STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);
        STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFmtEtcIn, FORMATETC *pFmtEtcOut);
        STDMETHODIMP SetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm, BOOL fRelease);
        STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
        STDMETHODIMP DAdvise(FORMATETC *pFmtEtc, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection);
        STDMETHODIMP DUnadvise(DWORD dwConnection);
        STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);

        static HRESULT CreateInstance(IDataObject **ppOut,
                                      LPCITEMIDLIST pidlFolder,
                                      UINT cidl,
                                      LPCITEMIDLIST *apidl,
                                      IShellFolder *psfOwner = NULL,
                                      IDataObject *pdtInner = NULL);

        static HRESULT CreateInstance(CIDLData **ppOut,
                                      LPCITEMIDLIST pidlFolder,
                                      UINT cidl,
                                      LPCITEMIDLIST *apidl,
                                      IShellFolder *psfOwner = NULL,
                                      IDataObject *pdtInner = NULL);

        void InitializeClipboardFormats(void);

        HRESULT Clone(UINT *acf, UINT ccf, IDataObject **ppdtobjOut);

        HRESULT CloneForMoveCopy(IDataObject **ppdtobjOut);

        HRESULT CtorResult(void) const
            { return m_hrCtor; }

        virtual IShellFolder *GetFolder(void) const;

    protected:
        //
        // These are defined for compatibility with the original shell code.
        //
        enum { MAX_FORMATS = ICF_MAX };

        LONG          m_cRef;
        IShellFolder *m_psfOwner;
        DWORD         m_dwOwnerData;
        HRESULT       m_hrCtor;
        IDataObject  *m_pdtobjInner;
        FORMATETC     m_rgFmtEtc[MAX_FORMATS];
        STGMEDIUM     m_rgMedium[MAX_FORMATS];
        bool          m_bEnumFormatCalled;

        static CLIPFORMAT m_rgcfGlobal[ICF_MAX];
        static const LARGE_INTEGER m_LargeIntZero;

        virtual HRESULT ProvideFormats(CEnumFormatEtc *pEnumFormatEtc);

    private:
        typedef HGLOBAL HIDA;
        HIDA HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl);

        //
        // Prevent copy.
        //
        CIDLData(const CIDLData& rhs);
        CIDLData& operator = (const CIDLData& rhs);
};

#endif _INC_SHELL_IDLDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\items.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       items.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shlwapip.h>   // QITAB, QISearch
#include <shsemip.h>    // ILFree(), etc

#include "folder.h"
#include "items.h"
#include "strings.h"

CLIPFORMAT COfflineItemsData::m_cfHDROP;
CLIPFORMAT COfflineItemsData::m_cfFileContents;
CLIPFORMAT COfflineItemsData::m_cfFileDesc;
CLIPFORMAT COfflineItemsData::m_cfPreferedEffect;
CLIPFORMAT COfflineItemsData::m_cfPerformedEffect;
CLIPFORMAT COfflineItemsData::m_cfLogicalPerformedEffect;
CLIPFORMAT COfflineItemsData::m_cfDataSrcClsid;

COfflineItemsData::COfflineItemsData(
    LPCITEMIDLIST pidlFolder, 
    UINT cidl, 
    LPCITEMIDLIST *apidl, 
    HWND hwndParent,
    IShellFolder *psfOwner,    // Optional.  Default is NULL.
    IDataObject *pdtInner      // Optional.  Default is NULL.
    ) : CIDLData(pidlFolder,
                 cidl,
                 apidl,
                 psfOwner,
                 pdtInner),
        m_hwndParent(hwndParent),
        m_rgpolid(NULL),
        m_hrCtor(NOERROR),
        m_dwPreferredEffect(DROPEFFECT_COPY),
        m_dwPerformedEffect(DROPEFFECT_NONE),
        m_dwLogicalPerformedEffect(DROPEFFECT_NONE),
        m_cItems(0)
{
    if (0 == m_cfHDROP)
    {
        m_cfHDROP          = CF_HDROP;
        m_cfFileContents   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
        m_cfFileDesc       = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
        m_cfPreferedEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        m_cfPerformedEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        m_cfLogicalPerformedEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);
        m_cfDataSrcClsid   = (CLIPFORMAT)RegisterClipboardFormat(c_szCFDataSrcClsid);
    }

    m_hrCtor = CIDLData::CtorResult();
    if (SUCCEEDED(m_hrCtor))
    {
        m_rgpolid = new LPCOLID[cidl];
        if (m_rgpolid)
        {
            ZeroMemory(m_rgpolid, sizeof(LPCOLID) * cidl);
            m_cItems = cidl;
            for (UINT i = 0; i < cidl; i++)
            {
                m_rgpolid[i] = (LPCOLID)ILClone(apidl[i]);
                if (!m_rgpolid[i])
                {
                    m_hrCtor = E_OUTOFMEMORY;
                    break;
                }
            }
        }
        else
            m_hrCtor = E_OUTOFMEMORY;
    }
}

COfflineItemsData::~COfflineItemsData(
    void
    )
{
    delete[] m_rgpolid;
}


HRESULT 
COfflineItemsData::CreateInstance(
    COfflineItemsData **ppOut,
    LPCITEMIDLIST pidlFolder, 
    UINT cidl, 
    LPCITEMIDLIST *apidl, 
    HWND hwndParent,
    IShellFolder *psfOwner,
    IDataObject *pdtInner
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    COfflineItemsData *pNew = new COfflineItemsData(pidlFolder,
                                                    cidl,
                                                    apidl,
                                                    hwndParent,
                                                    psfOwner,
                                                    pdtInner);
    if (NULL != pNew)
    {
        hr = pNew->CtorResult();
        if (SUCCEEDED(hr))
            *ppOut = pNew;
        else
            delete pNew;
    }
    return hr;
}



HRESULT 
COfflineItemsData::CreateInstance(
    IDataObject **ppOut,
    LPCITEMIDLIST pidlFolder, 
    UINT cidl, 
    LPCITEMIDLIST *apidl, 
    HWND hwndParent,
    IShellFolder *psfOwner,
    IDataObject *pdtInner
    )
{
    COfflineItemsData *poid;
    HRESULT hr = CreateInstance(&poid,
                                pidlFolder,
                                cidl,
                                apidl,
                                hwndParent,
                                psfOwner,
                                pdtInner);
    if (SUCCEEDED(hr))
    {
        poid->AddRef();
        hr = poid->QueryInterface(IID_IDataObject, (void **)ppOut);
        poid->Release();
    }
    return hr;
}


HRESULT 
COfflineItemsData::GetData(
    FORMATETC *pFEIn, 
    STGMEDIUM *pstm
    )
{
    HRESULT hr;

    pstm->hGlobal = NULL;
    pstm->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == m_cfHDROP) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreateHDROP(pstm);
    else if ((pFEIn->cfFormat == m_cfFileDesc) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreateFileDescriptor(pstm);
    else if ((pFEIn->cfFormat == m_cfFileContents) && (pFEIn->tymed & TYMED_ISTREAM))
        hr = CreateFileContents(pstm, pFEIn->lindex);
    else if ((pFEIn->cfFormat == m_cfPreferedEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreatePrefDropEffect(pstm);
    else if ((pFEIn->cfFormat == m_cfPerformedEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreatePerformedDropEffect(pstm);
    else if ((pFEIn->cfFormat == m_cfLogicalPerformedEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreateLogicalPerformedDropEffect(pstm);
    else if ((pFEIn->cfFormat == m_cfDataSrcClsid) && (pFEIn->tymed & TYMED_HGLOBAL))
        hr = CreateDataSrcClsid(pstm);
    else
        hr = CIDLData::GetData(pFEIn, pstm);

    return hr;
}


DWORD COfflineItemsData::GetDataDWORD(
    FORMATETC *pfe, 
    STGMEDIUM *pstm, 
    DWORD *pdwOut
    )
{
    if (pfe->tymed == TYMED_HGLOBAL)
    {
        DWORD *pdw = (DWORD *)GlobalLock(pstm->hGlobal);
        if (pdw)
        {
            *pdwOut = *pdw;
            GlobalUnlock(pstm->hGlobal);
        }
    }
    return *pdwOut;
}



HRESULT
COfflineItemsData::SetData(
    FORMATETC *pFEIn, 
    STGMEDIUM *pstm, 
    BOOL fRelease
    )
{
    if (pFEIn->cfFormat == g_cfPerformedDropEffect)
    {
        GetDataDWORD(pFEIn, pstm, &m_dwPerformedEffect);
    }
    else if (pFEIn->cfFormat == g_cfLogicalPerformedDropEffect)
    {
        GetDataDWORD(pFEIn, pstm, &m_dwLogicalPerformedEffect);
    }
    else if (pFEIn->cfFormat == g_cfPreferredDropEffect)
    {
        GetDataDWORD(pFEIn, pstm, &m_dwPreferredEffect);
    }

    return CIDLData::SetData(pFEIn, pstm, fRelease);
}


HRESULT 
COfflineItemsData::QueryGetData(
    FORMATETC *pFEIn
    )
{
    if (pFEIn->cfFormat == m_cfHDROP ||
        pFEIn->cfFormat == m_cfFileDesc ||
        pFEIn->cfFormat == m_cfFileContents   ||
        pFEIn->cfFormat == m_cfPreferedEffect ||
        pFEIn->cfFormat == m_cfPerformedEffect ||
        pFEIn->cfFormat == m_cfLogicalPerformedEffect ||
        pFEIn->cfFormat == m_cfDataSrcClsid)
    {
        return S_OK;
    }
    return CIDLData::QueryGetData(pFEIn);
}


HRESULT 
COfflineItemsData::ProvideFormats(
    CEnumFormatEtc *pEnumFmtEtc
    )
{
    FORMATETC rgFmtEtc[] = {
        { m_cfHDROP,                  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        { m_cfFileContents,           NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
        { m_cfFileDesc,               NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        { m_cfPreferedEffect,         NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        { m_cfPerformedEffect,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        { m_cfLogicalPerformedEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        { m_cfDataSrcClsid,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
    };
    //
    // Add our formats to the CIDLData format enumerator.
    //
    return pEnumFmtEtc->AddFormats(ARRAYSIZE(rgFmtEtc), rgFmtEtc);
}

HRESULT 
COfflineItemsData::CreateFileDescriptor(
    STGMEDIUM *pstm
    )
{
    HRESULT hr;
    pstm->tymed = TYMED_HGLOBAL;
    pstm->pUnkForRelease = NULL;
    
    // render the file descriptor
    // we only allocate for m_cItems-1 file descriptors because the filegroup
    // descriptor has already allocated space for 1.
    FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTOR) + (m_cItems - 1) * sizeof(FILEDESCRIPTOR));
    if (pfgd)
    {
        pfgd->cItems = m_cItems;                     // set the number of items
        pfgd->fgd[0].dwFlags = FD_PROGRESSUI;       // turn on progress UI

        for (int i = 0; i < m_cItems; i++)
        {
            FILEDESCRIPTOR *pfd = &(pfgd->fgd[i]);
            COfflineFilesFolder::OLID_GetFileName(m_rgpolid[i], pfd->cFileName, ARRAYSIZE(pfd->cFileName));
        }

        pstm->hGlobal = pfgd;
        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;
    
    return hr;
}

HRESULT 
COfflineItemsData::CreatePrefDropEffect(
    STGMEDIUM *pstm
    )
{
    return CreateDWORD(pstm, m_dwPreferredEffect);
}

HRESULT 
COfflineItemsData::CreatePerformedDropEffect(
    STGMEDIUM *pstm
    )
{
    return CreateDWORD(pstm, m_dwPerformedEffect);
}

HRESULT 
COfflineItemsData::CreateLogicalPerformedDropEffect(
    STGMEDIUM *pstm
    )
{
    return CreateDWORD(pstm, m_dwLogicalPerformedEffect);
}


HRESULT
COfflineItemsData::CreateDWORD(
    STGMEDIUM *pstm,
    DWORD dwEffect
    )
{
    pstm->tymed = TYMED_HGLOBAL;
    pstm->pUnkForRelease = NULL;
    pstm->hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));
    if (pstm->hGlobal)
    {
        *((DWORD *)pstm->hGlobal) = dwEffect;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}

HRESULT 
COfflineItemsData::CreateFileContents(
    STGMEDIUM *pstm, 
    LONG lindex
    )
{
    // here's a partial fix for when ole sometimes passes in -1 for lindex
    if (lindex == -1)
    {
        if (m_cItems == 1)
            lindex = 0;
        else
            return E_FAIL;
    }
    
    pstm->tymed = TYMED_ISTREAM;
    pstm->pUnkForRelease = NULL;

    TCHAR szPath[MAX_PATH];
    HRESULT hr = COfflineFilesFolder::OLID_GetFullPath(m_rgpolid[lindex], szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        hr = SHCreateStreamOnFile(szPath, STGM_READ, &pstm->pstm);
    }

    return hr;
}


HRESULT 
COfflineItemsData::CreateHDROP(
    STGMEDIUM *pstm
    )
{
    HRESULT hr;

    int i;
    //
    // The extra MAX_PATH is so that the damned SHLWAPI functions (i.e.
    // PathAppend) won't complain about a too-small buffer.  They require
    // that the destination buffer be AT LEAST MAX_PATH.  So much for letting
    // code being smart about buffer sizes.
    //
    int cbHdrop = sizeof(DROPFILES) + (MAX_PATH * sizeof(TCHAR)) + sizeof(TEXT('\0'));
    TCHAR szPath[MAX_PATH];

    pstm->tymed = TYMED_HGLOBAL;
    pstm->pUnkForRelease = NULL;

    //
    // Calculate required buffer size.
    //
    for (i = 0; i < m_cItems; i++)
    {
        szPath[0] = TEXT('\0');
        hr = COfflineFilesFolder::OLID_GetFullPath(m_rgpolid[i], szPath, ARRAYSIZE(szPath));
        if (FAILED(hr))
        {
            return hr;
        }
        cbHdrop += (lstrlen(szPath) + 1) * sizeof(TCHAR);
    }
    pstm->hGlobal = GlobalAlloc(GPTR, cbHdrop);
    if (NULL != pstm->hGlobal)
    {
        //
        // Fill out the header and append the file paths in a 
        // double-nul term list.
        //
        LPDROPFILES pdfHdr = (LPDROPFILES)pstm->hGlobal;
        pdfHdr->pFiles = sizeof(DROPFILES);
        pdfHdr->fWide  = TRUE;

        LPTSTR pszWrite = (LPTSTR)((LPBYTE)pdfHdr + sizeof(DROPFILES));
        LPTSTR pszEnd   = (LPTSTR)((LPBYTE)pstm->hGlobal + cbHdrop - sizeof(TCHAR));
        for (i = 0; i < m_cItems; i++)
        {
            // We allocated enough, so this should never fail
            if (SUCCEEDED(COfflineFilesFolder::OLID_GetFullPath(m_rgpolid[i], pszWrite, (UINT)(pszEnd - pszWrite))))
            {
                pszWrite += lstrlen(pszWrite) + 1;
            }
        }
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;    
}


HRESULT
COfflineItemsData::CreateDataSrcClsid(
    STGMEDIUM *pstm
    )
{
    HRESULT hr = E_OUTOFMEMORY;

    pstm->tymed = TYMED_HGLOBAL;
    pstm->pUnkForRelease = NULL;
    pstm->hGlobal = GlobalAlloc(GPTR, sizeof(CLSID));
    if (pstm->hGlobal)
    {
        *((CLSID *)pstm->hGlobal) = CLSID_OfflineFilesFolder;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}


COfflineItems::COfflineItems(
    COfflineFilesFolder *pFolder, 
    HWND hwnd
    ) : m_cRef(1),
        m_hwndBrowser(hwnd),
        m_pFolder(pFolder),
        m_ppolid(NULL),
        m_cItems(0)
{
    DllAddRef();
    if (m_pFolder)
        m_pFolder->AddRef();
}        

COfflineItems::~COfflineItems()
{
    if (m_pFolder)
        m_pFolder->Release();

    if (m_ppolid)
    {
        for (UINT i = 0; i < m_cItems; i++) 
        {
            if (m_ppolid[i])
                ILFree((LPITEMIDLIST)m_ppolid[i]);
        }
        LocalFree((HLOCAL)m_ppolid);
    }
    
    DllRelease();
}


HRESULT 
COfflineItems::Initialize(
    UINT cidl, 
    LPCITEMIDLIST *ppidl
    )
{
    HRESULT hr;
    m_ppolid = (LPCOLID *)LocalAlloc(LPTR, cidl * sizeof(LPCOLID));
    if (m_ppolid)
    {
        m_cItems = cidl;
        hr = S_OK;
        for (UINT i = 0; i < cidl; i++)
        {
            m_ppolid[i] = (LPCOLID)ILClone(ppidl[i]);
            if (!m_ppolid[i])
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}        



HRESULT 
COfflineItems::CreateInstance(
    COfflineFilesFolder *pfolder, 
    HWND hwnd,
    UINT cidl, 
    LPCITEMIDLIST *ppidl, 
    REFIID riid, 
    void **ppv)
{
    HRESULT hr;

    *ppv = NULL;                 // null the out param

    COfflineItems *pitems = new COfflineItems(pfolder, hwnd);
    if (pitems)
    {
        hr = pitems->Initialize(cidl, ppidl);
        if (SUCCEEDED(hr))
        {
            hr = pitems->QueryInterface(riid, ppv);
        }
        pitems->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT 
COfflineItems::QueryInterface(
    REFIID iid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(COfflineItems, IContextMenu),
        QITABENT(COfflineItems, IQueryInfo),
         { 0 },
    };
    return QISearch(this, qit, iid, ppv);
}


ULONG 
COfflineItems::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}


ULONG 
COfflineItems::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//
// IQueryInfo Methods -------------------------------------------------------
//
HRESULT 
COfflineItems::GetInfoTip(
    DWORD dwFlags, 
    WCHAR **ppwszTip
    )
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = COfflineFilesFolder::OLID_GetFullPath(m_ppolid[0], szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(szPath, ppwszTip);
    }
    return hr;
}


HRESULT 
COfflineItems::GetInfoFlags(
    DWORD *pdwFlags
    )
{
    *pdwFlags = 0;
    return S_OK;
}

//
// IContextMenu Methods -------------------------------------------------------
//
HRESULT 
COfflineItems::QueryContextMenu(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst,
    UINT idCmdLast, 
    UINT uFlags
    )
{
    USHORT cItems = 0;

    return ResultFromShort(cItems);    // number of menu items    
}

HRESULT
COfflineItems::InvokeCommand(
    LPCMINVOKECOMMANDINFO pici
    )
{
    HRESULT hr = S_OK;
    return hr;
}


HRESULT
COfflineItems::GetCommandString(
    UINT_PTR idCmd, 
    UINT uFlags, 
    UINT *pwReserved,
    LPSTR pszName, 
    UINT cchMax
    )
{
    HRESULT hr = E_FAIL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\msgbox.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgbox.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCDLL_MSGBOX_H
#define _INC_CSCDLL_MSGBOX_H

class Win32Error
{
    public:
        explicit Win32Error(DWORD dwWin32Error)
            : m_dwError(dwWin32Error) { }

        DWORD Code(void) const
            { return m_dwError; }

    private:
        DWORD m_dwError;
};


namespace CSCUI 
{
    enum Severity { SEV_ERROR = 0, 
                    SEV_WARNING, 
                    SEV_INFORMATION };
}



INT CscMessageBox(HWND hwndParent, UINT uType, const Win32Error& error);
INT CscMessageBox(HWND hwndParent, UINT uType, const Win32Error& error, LPCTSTR pszMsgText);
INT CscMessageBox(HWND hwndParent, UINT uType, const Win32Error& error, HINSTANCE hInstance, UINT idMsgText, ...);
INT CscMessageBox(HWND hwndParent, UINT uType, LPCTSTR pszMsgText);
INT CscMessageBox(HWND hwndParent, UINT uType, HINSTANCE hInstance, UINT idMsgText, ...);
INT CscWin32Message(HWND hwndParent, DWORD dwError, CSCUI::Severity severity);



#endif // INC_CSCDLL_MSGBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\items.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       items.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_ITEMS_H
#define _INC_CSCUI_ITEMS_H


#ifndef _INC_SHELL_IDLDATA_H
#   include "idldata.h"
#endif

class COfflineItemsData : public CIDLData
{
    public:
        COfflineItemsData(LPCITEMIDLIST pidlFolder, 
                          UINT cidl, 
                          LPCITEMIDLIST *apidl, 
                          HWND hwndParent,
                          IShellFolder *psfOwner = NULL,
                          IDataObject *pdtInner = NULL);

        ~COfflineItemsData(void);

        STDMETHODIMP GetData(FORMATETC *pFEIn, STGMEDIUM *pstm);
        STDMETHODIMP SetData(FORMATETC *pFEIn, STGMEDIUM *pstm, BOOL fRelease);
        STDMETHODIMP QueryGetData(FORMATETC *pFE);


        static HRESULT CreateInstance(COfflineItemsData **ppOut,
                                      LPCITEMIDLIST pidlFolder, 
                                      UINT cidl, 
                                      LPCITEMIDLIST *apidl, 
                                      HWND hwndParent,
                                      IShellFolder *psfOwner = NULL,
                                      IDataObject *pdtInner = NULL);

        static HRESULT CreateInstance(IDataObject **ppOut,
                                      LPCITEMIDLIST pidlFolder, 
                                      UINT cidl, 
                                      LPCITEMIDLIST *apidl, 
                                      HWND hwndParent,
                                      IShellFolder *psfOwner = NULL,
                                      IDataObject *pdtInner = NULL);

        HRESULT CtorResult(void) const
            { return m_hrCtor; }

    protected:
        HRESULT ProvideFormats(CEnumFormatEtc *pEnumFmtEtc);

    private:
        HWND                m_hwndParent;
        LPCOLID            *m_rgpolid; // Pidls cloned in private format.
        int                 m_cItems;
        HRESULT             m_hrCtor;
        DWORD               m_dwPreferredEffect;
        DWORD               m_dwPerformedEffect;
        DWORD               m_dwLogicalPerformedEffect;

        static CLIPFORMAT m_cfHDROP;
        static CLIPFORMAT m_cfFileContents;
        static CLIPFORMAT m_cfFileDesc;
        static CLIPFORMAT m_cfPreferedEffect;
        static CLIPFORMAT m_cfPerformedEffect;
        static CLIPFORMAT m_cfLogicalPerformedEffect;
        static CLIPFORMAT m_cfDataSrcClsid;
       
        HRESULT CreateFileDescriptor(STGMEDIUM *pstm);
        HRESULT CreateFileContents(STGMEDIUM *pstm, LONG lindex);
        HRESULT CreatePrefDropEffect(STGMEDIUM *pstm);
        HRESULT CreatePerformedDropEffect(STGMEDIUM *pstm);
        HRESULT CreateLogicalPerformedDropEffect(STGMEDIUM *pstm);
        HRESULT CreateHDROP(STGMEDIUM *pstm);
        HRESULT CreateDataSrcClsid(STGMEDIUM *pstm);
        HRESULT CreateDWORD(STGMEDIUM *pstm, DWORD dwEffect);
        DWORD GetDataDWORD(FORMATETC *pfe, STGMEDIUM *pstm, DWORD *pdwOut);

        //
        // Prevent copy.
        //
        COfflineItemsData(const COfflineItemsData& rhs);
        COfflineItemsData& operator = (const COfflineItemsData& rhs);
};




class COfflineItems : public IContextMenu, 
                      public IQueryInfo
{
    public:
        HRESULT Initialize(UINT cidl, LPCITEMIDLIST *ppidl);

        //
        // IUnknown Methods
        //
        STDMETHODIMP QueryInterface(REFIID,void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
    
        //
        // IContextMenu Methods
        //
        STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
        STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved, LPSTR pszName, UINT cchMax);

        //
        // IQueryInfo Methods
        //
        STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
        STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);
    
        static HRESULT CreateInstance(COfflineFilesFolder *pfolder, 
                                      HWND hwnd, 
                                      UINT cidl, 
                                      LPCITEMIDLIST *ppidl, 
                                      REFIID riid, 
                                      void **ppv);
    private:
        //
        // Only create through CreateInstance() static function.
        //
        COfflineItems(COfflineFilesFolder *pfolder, HWND hwnd);
        ~COfflineItems();

        LONG                 m_cRef;        // reference count
        COfflineFilesFolder *m_pFolder;     // back pointer to our shell folder
        UINT                 m_cItems;      // number of items we represent
        LPCOLID             *m_ppolid;      // variable size array of items
        HWND                 m_hwndBrowser;
};

#endif // _INC_CSCUI_ITEMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\msgbox.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgbox.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "msgbox.h"


//
// Helper to report system errors.
// Merely ensures a little consistency with respect to message box
// flags.
//
// Example: 
//
//      CscWin32Message(hwndMain,
//                      ERROR_NOT_ENOUGH_MEMORY,
//                      CSCUI::SEV_ERROR);
// 
int
CscWin32Message(
    HWND hwndParent,
    DWORD dwError,    // From GetLastError().
    CSCUI::Severity severity
    )
{
    UINT uType = MB_OK;

    switch(severity)
    {
        case CSCUI::SEV_ERROR:       
            uType |= MB_ICONERROR;   
            break;
        case CSCUI::SEV_WARNING:     
            uType |= MB_ICONWARNING; 
            break;
        case CSCUI::SEV_INFORMATION: 
            uType |= MB_ICONINFORMATION; 
            break;
        default: break;
    }

    return CscMessageBox(hwndParent, uType, Win32Error(dwError));
}


//
// Display a system error message in a message box.
// The Win32Error class was created to eliminate any signature ambiguities
// with the other versions of CscMessageBox.
//
// Example:  
//
//  CscMessageBox(hwndMain, 
//                MB_OK | MB_ICONERROR, 
//                Win32Error(ERROR_NOT_ENOUGH_MEMORY));
//
int
CscMessageBox(
    HWND hwndParent,
    UINT uType,
    const Win32Error& error
    )
{
    int iResult = -1;
    LPTSTR pszBuffer = NULL;
    FormatSystemError(&pszBuffer, error.Code());
    if (NULL != pszBuffer)
    {
        iResult = CscMessageBox(hwndParent, uType, pszBuffer);
        LocalFree(pszBuffer);
    }
    return iResult;
}



//
// Display a system error message in a message box with additional
// text.  
//
// Example:  
//
//  CscMessageBox(hwndMain, 
//                MB_OK | MB_ICONERROR, 
//                Win32Error(ERROR_NOT_ENOUGH_MEMORY),
//                IDS_FMT_LOADINGFILE,
//                pszFile);
//
int 
CscMessageBox(
    HWND hwndParent, 
    UINT uType, 
    const Win32Error& error, 
    LPCTSTR pszMsgText
    )
{
    int iResult = -1;
    size_t cchMsg = lstrlen(pszMsgText) + MAX_PATH;
    LPTSTR pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, cchMsg * sizeof(TCHAR));
    if (NULL != pszBuffer)
    {
        LPTSTR pszRemaining;

        HRESULT hr = StringCchCopyEx(pszBuffer, cchMsg, pszMsgText, &pszRemaining, &cchMsg, 0);
        // We allocated a big enough buffer, so this should never fail
        ASSERT(SUCCEEDED(hr));

        hr = StringCchCopyEx(pszRemaining, cchMsg, TEXT("\n\n"), &pszRemaining, &cchMsg, 0);
        ASSERT(SUCCEEDED(hr));

        int cchLoaded = ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                        NULL,
                                        error.Code(),
                                        0,
                                        pszRemaining,
                                        cchMsg,
                                        NULL);
        if (0 != cchLoaded)
        {
            iResult = CscMessageBox(hwndParent, uType, pszBuffer);
        }
        LocalFree(pszBuffer);
    }
    return iResult;
}


int
CscMessageBox(
    HWND hwndParent,
    UINT uType,
    const Win32Error& error,
    HINSTANCE hInstance,
    UINT idMsgText,
    va_list *pargs
    )
{
    int iResult      = -1;
    LPTSTR pszBuffer = NULL;
    if (0 != vFormatStringID(&pszBuffer, hInstance, idMsgText, pargs))
    {
        iResult = CscMessageBox(hwndParent, uType, error, pszBuffer);
    }
    LocalFree(pszBuffer);
    return iResult;
}


int 
CscMessageBox(
    HWND hwndParent, 
    UINT uType, 
    const Win32Error& error, 
    HINSTANCE hInstance,
    UINT idMsgText, 
    ...
    )
{
    va_list args;
    va_start(args, idMsgText);
    int iResult = CscMessageBox(hwndParent, uType, error, hInstance, idMsgText, &args);
    va_end(args);
    return iResult;
}



//
// Example:  
//
//  CscMessageBox(hwndMain, 
//                MB_OK | MB_ICONWARNING, 
//                TEXT("File %1 could not be deleted"), pszFilename);
//
int
CscMessageBox(
    HWND hwndParent,
    UINT uType,
    HINSTANCE hInstance,
    UINT idMsgText,
    va_list *pargs
    )
{
    int iResult   = -1;
    LPTSTR pszMsg = NULL;
    if (0 != vFormatStringID(&pszMsg, hInstance, idMsgText, pargs))
    {
        iResult = CscMessageBox(hwndParent, uType, pszMsg);
    }
    LocalFree(pszMsg);
    return iResult;
}


int
CscMessageBox(
    HWND hwndParent,
    UINT uType,
    HINSTANCE hInstance,
    UINT idMsgText,
    ...
    )
{
    va_list args;
    va_start(args, idMsgText);
    int iResult = CscMessageBox(hwndParent, uType, hInstance, idMsgText, &args);
    va_end(args);
    return iResult;
}


//
// All of the other variations of CscMessageBox() end up calling this one.
// 
int
CscMessageBox(
    HWND hwndParent,
    UINT uType,
    LPCTSTR pszMsgText
    )
{

    TCHAR szCaption[80] = { TEXT('\0') };
    LoadString(g_hInstance, IDS_APPLICATION, szCaption, ARRAYSIZE(szCaption));

    return MessageBox(hwndParent, pszMsgText, szCaption, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\nopin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       nopin.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "eventlog.h"
#include "nopin.h"
#include "strings.h"
#include "msg.h"


//--------------------------------------------------------------------------
// class CNoPinList
//--------------------------------------------------------------------------
CNoPinList::CNoPinList(
    void
    ) : m_pRoot(NULL)
{
}


CNoPinList::~CNoPinList(
    void
    )
{
    delete m_pRoot;
}


//
// Searches the tree for a COMPLETE path that is a subpath of
// pszPath.  If found, pszPath specifies a file or folder
// that cannot be pinned.
//
// Returns:
//      S_OK            - Pinning is allowed.
//      S_FALSE         - Pinning is NOT allowed.
//      NOPIN_E_BADPATH - Path is not a valid UNC.
//
HRESULT 
CNoPinList::IsPinAllowed(
    LPCTSTR pszPath
    )
{
    TraceEnter(TRACE_UTIL, "CNoPinList::IsPinAllowed");
    TraceAssert(NULL != pszPath);
    TraceAssert(::PathIsUNC(pszPath));

    HRESULT hr = _Initialize();
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        //
        // A quick optimization is to see if the tree is empty.
        // If it is, any file/folder may be pinned.  This helps
        // performance when no pinning restriction is in place.
        //
        TraceAssert(NULL != m_pRoot);
        if (m_pRoot->HasChildren())
        {
            if (::PathIsUNC(pszPath))
            {
                //
                // SubPathExists modifies the path.  Need to make a local copy.
                //
                TCHAR szPath[MAX_PATH];
                hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
                if (SUCCEEDED(hr))
                {
                    hr = m_pRoot->SubPathExists(szPath);
                    if (S_FALSE == hr)
                    {
                        //
                        // Absence from the tree means pinning is allowed.
                        //
                        hr = S_OK;
                    }
                    else if (S_OK == hr)
                    {
                        //
                        // Presence in the tree means pinning is not allowed.
                        //
                        Trace((TEXT("Policy disallows pinning \"%s\""), pszPath));
                        hr = S_FALSE;
                    }
                }
                else if (STRSAFE_E_INSUFFICIENT_BUFFER == hr)
                {
                    hr = NOPIN_E_BADPATH;
                }
            }
            else
            {
                hr = NOPIN_E_BADPATH;
            }
        }
    }
    TraceAssert(S_OK == hr ||
                S_FALSE == hr ||
                NOPIN_E_BADPATH == hr);

    TraceLeaveResult(hr);
}


//
// Quick check to see if ANY pin might be disallowed.
// Returns:
//  S_OK    - Tree has content.
//  S_FALSE - Tree is empty.
//
HRESULT 
CNoPinList::IsAnyPinDisallowed(
    void
    )
{
    HRESULT hr = _Initialize();
    if (SUCCEEDED(hr))
    {
        TraceAssert(NULL != m_pRoot);
        hr = m_pRoot->HasChildren() ? S_OK : S_FALSE;
    }
    return hr;
}



//
// Initializes the no-pin list by reading path strings from the
// registry.  The paths are stored in both HKLM and HKCU under
// the following key:
//
//  Software\Policies\Microsoft\Windows\NetCache\NoMakeAvailableOfflineList
//
// Path strings may contain environment variables.
// Upon return the object contains a tree representing the union of all 
// files and folders listed in both registry keys.
//
// Errors in reading the registry result only in paths not being added
// to the tree.  No error is returned as a result of registry errors.
// If an invalid UNC path is found in the registry, an even log entry
// is recorded.
//
// Returns:
//      S_OK            - List successfully loaded.
//      S_FALSE         - List already initialized.
//      E_OUTOFMEMORY   - Insufficient memory.
//      Other errors are possible.
//      
HRESULT 
CNoPinList::_Initialize(
    void
    )
{
    TraceEnter(TRACE_UTIL, "CNoPinList::_Initialize");
    HRESULT hr = S_OK;

    if (NULL != m_pRoot)
    {
        //
        // List is already initialized.
        //
        hr = S_FALSE;
    }
    else
    {
        m_pRoot = new CNode;
        if (NULL == m_pRoot)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            const HKEY rghkeyRoot[] = { HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE };

            TCHAR szKey[MAX_PATH];
            PathCombine(szKey, REGSTR_KEY_OFFLINEFILESPOLICY, REGSTR_SUBKEY_NOMAKEAVAILABLEOFFLINELIST);

            for (int i = 0; SUCCEEDED(hr) && i < ARRAYSIZE(rghkeyRoot); i++)
            {
                HKEY hkey;
                LONG lResult = ::RegOpenKeyEx(rghkeyRoot[i],
                                              szKey,
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hkey);

                if (ERROR_SUCCESS == lResult)
                {
                    TCHAR szName[MAX_PATH];
                    DWORD dwIndex = 0;
                    DWORD cchName = ARRAYSIZE(szName);
                    //
                    // Enumerate the paths listed in the registry.
                    //
                    while (SUCCEEDED(hr) &&
                           ERROR_SUCCESS == ::RegEnumValue(hkey, 
                                                           dwIndex, 
                                                           szName, 
                                                           &cchName, 
                                                           NULL, 
                                                           NULL, 
                                                           NULL, 
                                                           NULL))
                    {
                        //
                        // Install the path string from the registry into the
                        // tree.  This function will expand any embedded environment strings
                        // as well as convert mapped drive specs to remote UNC paths.
                        //
                        hr = _InitPathFromRegistry(szName);
                        if (NOPIN_E_BADPATH == hr)
                        {
                            //
                            // This is a special error.  It means someone has
                            // put bad data into the registry.  "Bad" meaning
                            // that the path is not or does not expand to a valid UNC 
                            // path string.
                            // Write an event log entry to tell the admin.  The 
                            // entry is generated at event logging level 1.  I don't want
                            // it filling up an event log under normal conditions but
                            // I want an admin to figure it out in case their no-pin
                            // policy appears to be not working.
                            //
                            // The MSG template is this (english):
                            //
                            //  "The registry value '%1' in key '%2\%3' is not, or does not
                            //   expand to, a valid UNC path."
                            //
                            // We handle the error here because this is where we still have the 
                            // value read from the registry.   We include that in the event
                            // log entry so the admin can easily find it.
                            //
                            CscuiEventLog log;
                            log.Push(szName);

                            if (HKEY_LOCAL_MACHINE == rghkeyRoot[i])
                            {
                                log.Push(TEXT("HKEY_LOCAL_MACHINE"));
                            }
                            else
                            {
                                log.Push(TEXT("HKEY_CURRENT_USER"));
                            }
                            log.Push(szKey);
                            log.ReportEvent(EVENTLOG_WARNING_TYPE, MSG_W_INVALID_UNCPATH_INREG, 1);
                            //
                            // We do not abort processing because of a bad reg value.
                            //
                            hr = S_OK;
                        }

                        cchName = ARRAYSIZE(szName);
                        dwIndex++;
                    }    

                    ::RegCloseKey(hkey);
                    hkey = NULL;
                }
            }
        }
    }
    TraceLeaveResult(hr);
}



//
// Given a path string read from the registry, this function expands
// any embedded environment strings, converts any mapped drive letters
// to their corresponding remote UNC paths and installs the resulting
// path string into the tree.
//
HRESULT
CNoPinList::_InitPathFromRegistry(
    LPCTSTR pszPath
    )
{
    TraceEnter(TRACE_UTIL, "CNoPinList::_InitPathFromRegistry");
    TraceAssert(NULL != pszPath);

    HRESULT hr = S_OK;

    TCHAR szNameExp[MAX_PATH]; // Expanded name string buffer.

    //
    // Expand any embedded environment strings.
    //
    if (0 == ::ExpandEnvironmentStrings(pszPath, szNameExp, ARRAYSIZE(szNameExp)))
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        Trace((TEXT("Error %d expanding \"%s\""), dwErr, pszPath));
    }
    if (SUCCEEDED(hr))
    {
        LPCTSTR pszUncPath   = NULL;
        LPTSTR pszRemotePath = NULL;  // Created by GetRemotePath if necessary.
        //
        // Convert a common typing mistake.
        // Remember, these are reg entries.  They could contain most anything.
        //
        for (LPTSTR s = szNameExp; *s; s++)
        {
            if (TEXT('/') == *s)
            {
                *s = TEXT('\\');
            }
        }

        if (::PathIsUNC(szNameExp))
        {
            //
            // Path is a UNC path.  We're golden.
            //
            pszUncPath = szNameExp;
        }
        else
        {
            //
            // Path is probably a mapped drive.
            // Get its remote UNC path.  This API returns S_FALSE
            // if the remote drive is not connected or if it's a local drive.
            //
            hr = ::GetRemotePath(szNameExp, &pszRemotePath);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    pszUncPath = pszRemotePath;
                }
                else if (S_FALSE == hr)
                {
                    //
                    // Path was either to a local drive or to a net drive that 
                    // isn't connected.  Either way it's an invalid drive that
                    // won't be considered in the no-pin logic.  Use the expanded
                    // value from the registry and pass that through to AddPath()
                    // where it will be rejected as an invalid UNC path.
                    //
                    TraceAssert(NULL == pszRemotePath);
                    pszUncPath = szNameExp;
                    hr = S_OK;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            TraceAssert(NULL != pszUncPath);
            TraceAssert(pszUncPath == szNameExp || pszUncPath == pszRemotePath);
            //
            // Insert the UNC path into the tree.
            // At this point, a path may or may not be UNC.  _AddPath()
            // will verify this.
            //
            hr = _AddPath(pszUncPath);
        }
        if (NULL != pszRemotePath)
        {
            ::LocalFree(pszRemotePath);
        }
    }
    TraceLeaveResult(hr);
}




//
// Adds a path to the tree.  If this is a sub-path of an existing
// path in the tree, the remainder of the existing path is removed
// from the tree.
//
// Returns:
//      S_OK            - Path successfully added.
//      E_OUTOFMEMORY   - Insufficient memory.
//      NOPIN_E_BADPATH - Invalid path string.  Not a UNC.
//
HRESULT 
CNoPinList::_AddPath(
    LPCTSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    HRESULT hr = NOPIN_E_BADPATH;

    if (::PathIsUNC(pszPath))
    {
        //
        // AddPath modifies the path.  Need to make a local copy.
        //
        TraceAssert(NULL != m_pRoot);
        TCHAR szPath[MAX_PATH];
        hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
        if (SUCCEEDED(hr))
        {
            hr = m_pRoot->AddPath(szPath);
        }
        else if (STRSAFE_E_INSUFFICIENT_BUFFER == hr)
        {
            hr = NOPIN_E_BADPATH;
        }
    }

    TraceAssert(S_OK == hr ||
                E_OUTOFMEMORY == hr ||
                NOPIN_E_BADPATH == hr);
    return hr;
}




//--------------------------------------------------------------------------
// class CNoPinList::CNode
//--------------------------------------------------------------------------

CNoPinList::CNode::~CNode(
    void
    )
{
    if (NULL != m_pszName)
    {
        ::LocalFree(m_pszName);
    }
    delete m_pChildren;
    delete m_pNext;
}


//
// Initializes a node's name value.
//
HRESULT 
CNoPinList::CNode::Initialize(
    LPCTSTR pszName
    )
{
    TraceAssert(NULL != pszName);
    TraceAssert(NULL == m_pszName);

    HRESULT hr = E_OUTOFMEMORY;

    if (LocalAllocString(&m_pszName, pszName))
    {
        hr = S_OK;
    }
    return hr;
}


//
// Add a child, keeping the children in alphabetical 
// order by name.  We trade a little time during creation
// for the speed benefits during lookup.
//
void
CNoPinList::CNode::_AddChild(
    CNode *pChild
    )
{
    TraceAssert(NULL != pChild);

    CNode **ppNode = &m_pChildren;
    while(NULL != *ppNode)
    {
        CNode *pNode = *ppNode;
        //
        // Find the alphabetical insertion point.
        //
        TraceAssert(NULL != pNode->m_pszName);
        TraceAssert(NULL != pChild->m_pszName);

        int diff = ::lstrcmpi(pChild->m_pszName, pNode->m_pszName);
        if (0 == diff)
        {
            //
            // Child already exists.  Don't allow duplicates.
            //
            return;
        }
        if (diff < 0)
        {
            //
            // The new child is alphabetically "greater" than the currently
            // visited node.
            // Exit the loop with ppNode pointing to the pointer variable
            // where we'll put the address of pChild.
            //
            break;
        }
        else
        {
            //
            // Advance to the next node in the list.
            //
            ppNode = &pNode->m_pNext;
        }
    }
    //
    // Insert the child.
    //
    pChild->m_pNext = *ppNode;
    *ppNode         = pChild;
}


//
// Locates a child node in a node's list of children.
// Comparison is by node name.
// Returns the address of the node if found.  NULL otherwise.
//
CNoPinList::CNode *
CNoPinList::CNode::_FindChild(
    LPCTSTR pszName
    ) const
{
    TraceAssert(NULL != pszName);

    CNode *pChild = NULL;
    for (CNode *pNode = m_pChildren; pNode; pNode = pNode->m_pNext)
    {
        //
        // The list is sorted alphabetically.
        //
        int diff = ::lstrcmpi(pszName, pNode->m_pszName);
        if (diff <= 0)
        {
            //
            // Either we found a match or we've passed all possible
            // matches.
            //
            if (0 == diff)
            {
                //
                // Exact match.
                //
                pChild = pNode;
            }
            break;
        }
    }
    return pChild;
}
     


//
// Given "\\brianau1\public\bin"
// Returns address of "brianau1\public\bin", with *pcchComponent == 8.
//
// Given "public\bin"
// Returns address of "bin", with *pcchComponent == 3.
// 
LPCTSTR 
CNoPinList::CNode::_FindNextPathComponent(   // [static]
    LPCTSTR pszPath,
    int *pcchComponent  // [optional] Can be NULL.
    )
{
    TraceAssert(NULL != pszPath);

    LPCTSTR pszBegin = pszPath;

    const TCHAR CH_BS = TEXT('\\');
    //
    // Skip any leading backslashes.
    //
    while(*pszBegin && CH_BS == *pszBegin)
        ++pszBegin;

    //
    // Find the end of the path component.
    //
    LPCTSTR pszEnd = pszBegin;
    while(*pszEnd && CH_BS != *pszEnd)
        ++pszEnd;

    if (NULL != pcchComponent)
    {
        *pcchComponent = int(pszEnd - pszBegin);
        TraceAssert(0 <= *pcchComponent);
    }

    //
    // Validate the final position of the begin and end ptrs.
    //
    TraceAssert(NULL != pszBegin);
    TraceAssert(NULL != pszEnd);
    TraceAssert(pszBegin >= pszPath);
    TraceAssert(pszBegin <= (pszPath + lstrlen(pszPath)));
    TraceAssert(pszEnd >= pszPath);
    TraceAssert(pszEnd <= (pszPath + lstrlen(pszPath)));
    TraceAssert(TEXT('\\') != *pszBegin);
    return pszBegin;
}


//
// Recursively adds components of a path string to the tree.
//
HRESULT
CNoPinList::CNode::AddPath(
    LPTSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    HRESULT hr = NOPIN_E_BADPATH;
    if (NULL != pszPath)
    {
        hr = S_OK;

        int cchPart = 0;
        LPTSTR pszPart = (LPTSTR)_FindNextPathComponent(pszPath, &cchPart);
        if (*pszPart)
        {
            TCHAR chTemp = TEXT('\0');
            _SwapChars(&chTemp, pszPart + cchPart);
            CNode *pChild = _FindChild(pszPart);

            if (NULL != pChild)
            {
                //
                // Found an existing node for this part of the path.
                // If the node has children, give the remainder of the path 
                // to this node for addition.  If it doesn't that means
                // it's a leaf node and all it's children are excluded from
                // pinning.  No reason to add any children to it.
                //
                _SwapChars(&chTemp, pszPart + cchPart);
                if (pChild->HasChildren())
                {
                    hr = pChild->AddPath(pszPart + cchPart);
                }
            }
            else
            {
                //
                // This is a new sub-path that is not yet in the tree.
                //
                hr = E_OUTOFMEMORY;

                pChild = new CNode();
                if (NULL != pChild)
                {
                    //
                    // Initialize the new child.
                    //
                    hr = pChild->Initialize(pszPart);
                    _SwapChars(&chTemp, pszPart + cchPart);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Have the new child add the remainder of
                        // the path as it's children.
                        //
                        hr = pChild->AddPath(pszPart + cchPart);
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Link the new child into the list of children.
                            //
                            _AddChild(pChild);
                        }
                    }
                    if (FAILED(hr))
                    {
                        delete pChild;
                        pChild = NULL;
                    }
                }
            }
        }                
        else
        {
            //
            // We're at the end of the path, that means we're at a leaf node
            // and this file or directory is excluded from pinning.  If it's 
            // a directory, all children are excluded from pinning so there's 
            // no reason to keep any child nodes in the tree.  This keeps the
            // tree trimmed to a minimum necessary size.
            //
            delete m_pChildren;
            m_pChildren = NULL;
        }
    }

    TraceAssert(S_OK == hr ||
                E_OUTOFMEMORY == hr ||
                NOPIN_E_BADPATH == hr);
    return hr;
}


//
// Recursively determines if a given complete subpath exists for a 
// path string.  If a match occurs at a given level in the tree,
// the remainder of the path string is given to the matching node
// for further searching.  This process continues recursively until
// we hit a leaf node in the tree or the end of the path string, 
// whichever occurs first.
//
// Returns:
//      S_OK    - A complete path exists that is a subpath of pszPath.
//      S_FALSE - A complete path does not exist.
//
HRESULT
CNoPinList::CNode::SubPathExists(
    LPTSTR pszPath
    ) const
{
    HRESULT hr = NOPIN_E_BADPATH;
    if (NULL != pszPath)
    {
        hr = S_FALSE;

        int cchPart = 0;
        LPTSTR pszPart = (LPTSTR)_FindNextPathComponent(pszPath, &cchPart);
        if (*pszPart)
        {
            TCHAR chTemp = TEXT('\0');

            _SwapChars(&chTemp, pszPart + cchPart);
            CNode *pChild = _FindChild(pszPart);
            _SwapChars(&chTemp, pszPart + cchPart);

            if (NULL != pChild)
            {
                if (pChild->HasChildren())
                {
                    hr = pChild->SubPathExists(pszPart + cchPart);
                }
                else
                {
                    //
                    // Hit a leaf node.  That means that we've traversed
                    // down a complete subpath of the path in question.
                    // Pinning of this path is not allowed.
                    // 
                    hr = S_OK;
                }
            }
        }
    }            

    TraceAssert(S_OK == hr || 
                S_FALSE == hr ||
                NOPIN_E_BADPATH == hr);
    return hr;
}



#if DBG

//
// This function dumps the contents of a tree node and all it's decendents.
// The result is an indented list of nodes in the debugger output.
// Handy for debugging tree build problems.
//
void
CNoPinList::_DumpNode(
    const CNoPinList::CNode *pNode,
    int iIndent
    )
{
    CNodeInspector ni(pNode);
    TCHAR szText[1024] = {0};

    iIndent = min(iIndent, 60);

    LPTSTR pszWrite = szText;
    UINT cchWrite = ARRAYSIZE(szText);
    for (int i = 0; i < iIndent; i++)
    {
        *pszWrite++ = TEXT(' ');
        cchWrite--;
    }

    ::OutputDebugString(TEXT("\n\r"));
    ::wnsprintf(pszWrite, cchWrite, TEXT("Node Address.: 0x%08X\n\r"), pNode);
    ::OutputDebugString(szText);
    ::wnsprintf(pszWrite, cchWrite, TEXT("Name.........: %s\n\r"), ni.NodeName() ? ni.NodeName() : TEXT("<null>"));
    ::OutputDebugString(szText);
    ::wnsprintf(pszWrite, cchWrite, TEXT("Children.....: 0x%08X\n\r"), ni.ChildList());
    ::OutputDebugString(szText);
    ::wnsprintf(pszWrite, cchWrite, TEXT("Next Sibling.: 0x%08X\n\r"), ni.NextSibling());
    ::OutputDebugString(szText);

    if (NULL != ni.ChildList())
    {
        _DumpNode(ni.ChildList(), iIndent + 5);
    }
    if (NULL != ni.NextSibling())
    {
        _DumpNode(ni.NextSibling(), iIndent);
    }
}

//
// Dump the entire tree starting with the root.
//
void 
CNoPinList::Dump(
    void
    )
{
    ::OutputDebugString(TEXT("\n\rDumping CNoPinList\n\r"));
    if (NULL != m_pRoot)
    {
        _DumpNode(m_pRoot, 0);
    }
}
        
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\openfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       openfile.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCVIEW_OPENFILE_H
#define _INC_CSCVIEW_OPENFILE_H


DWORD OpenOfflineFile(LPCTSTR pszFile);


#endif // _INC_CSCVIEW_OPENFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\nopin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       nopin.h
//
//--------------------------------------------------------------------------
#ifndef __CSCUI_NOPIN_H
#define __CSCUI_NOPIN_H


const HRESULT NOPIN_E_BADPATH = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

//
// This class contains a tree of nodes, each node representing a file or
// directory.  The tree structure mirrors the directory/file structure
// being represented.  Each leaf node in the tree specifies a particular file
// or directory for which pinning is disallowed.  The tree is initialized
// from the registry using the Initialize() method.  Once initialized,
// the tree is queried using the IsPinAllowed() method.  This method
// searches the tree given a particular UNC path.  If a matching
// traversal ending in a leaf node is found, pinning of that path is
// not allowed.
//
// Since this code is to be used by the Offline Files context menu
// handler, speed is critical.  The tree structure was chosen for
// it's fast lookup characteristics for filesystem paths.
//
class CNoPinList
{
    public:
        CNoPinList(void);
        ~CNoPinList(void);
        //
        // Determines if pinning of a particular path is allowed.
        //   S_OK    == Pinning is allowed.
        //   S_FALSE == Pinning is not allowed.
        //
        HRESULT IsPinAllowed(LPCTSTR pszPath);
        //
        // Determines if there is any pin that would be disallowed.
        // Basically, is the tree not empty?
        //
        HRESULT IsAnyPinDisallowed(void);

#if DBG
        //
        // Dump tree contents to debugger.
        //
        void Dump(void);
#endif

    private:
        //
        // Prevent copy.
        //
        CNoPinList(const CNoPinList& rhs);              // not implemented.
        CNoPinList& operator = (const CNoPinList& rhs); // not implemented.

#if DBG
        //
        // This "inspector" class is a trivial thing to allow us to
        // see inside a CNode object for debugging purposes.  It is a friend
        // of CNode.  This lets us keep the CNode private information private
        // for all bug debugging purposes.  See the method CNoPinList::DumpNode
        // for it's usage.
        //
        class CNode; // fwd decl
        class CNodeInspector
        {
            public:
                CNodeInspector(const CNode *pNode)
                    : m_pNode(pNode) { }

                LPCTSTR NodeName(void) const
                    { return m_pNode->m_pszName; }

                const CNode *ChildList(void) const
                    { return m_pNode->m_pChildren; }

                const CNode *NextSibling(void) const
                    { return m_pNode->m_pNext; }

            private:
                const CNode *m_pNode;
        };
#endif

        //
        // A node in the tree.
        //
        class CNode
        {
            public:
                CNode(void);
                ~CNode(void);

                HRESULT Initialize(LPCTSTR pszName);

                HRESULT AddPath(LPTSTR pszPath);

                HRESULT SubPathExists(LPTSTR pszPath) const;

                bool HasChildren(void) const
                    { return NULL != m_pChildren; }

            private:
                LPTSTR m_pszName;   // Node's name
                CNode *m_pChildren; // List of children.  NULL for leaf nodes.
                CNode *m_pNext;     // Next in list of siblings

                //
                // Prevent copy.
                //
                CNode(const CNode& rhs);                // Not implemented.
                CNode& operator = (const CNode& rhs);   // Not implemented.

                CNode *_FindChild(LPCTSTR pszName) const;
                void _AddChild(CNode *pChild);

                static LPCTSTR _FindNextPathComponent(LPCTSTR pszPath, int *pcchComponent);
                static void _SwapChars(LPTSTR pszA, LPTSTR pszB);
#if DBG
                friend class CNodeInspector;
#endif

        };

        CNode *m_pRoot;        // The root of the tree.

        HRESULT _Initialize(void);
        HRESULT _InitPathFromRegistry(LPCTSTR pszPath);
        HRESULT _AddPath(LPCTSTR pszPath);

#if DBG
        void _DumpNode(const CNode *pNode, int iIndent);
#endif

};



inline
CNoPinList::CNode::CNode(
    void
    ) : m_pszName(NULL),
        m_pChildren(NULL),
        m_pNext(NULL)
{

}


inline void
CNoPinList::CNode::_SwapChars(
    LPTSTR pszA,
    LPTSTR pszB
    )
{
    const TCHAR chTemp = *pszA;
    *pszA = *pszB;
    *pszB = chTemp;
}




#endif // __CSCUI_NOPIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\openfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       openfile.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// Open a file using ShellExecuteEx and the "open" verb.
//
DWORD
OpenOfflineFile(
    LPCTSTR pszFile
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    if (NULL != pszFile && TEXT('\0') != *pszFile)
    {
        //
        // Have CSC create a local copy.  It creates the file with a 
        // unique (and cryptic) name.
        //
        LPTSTR pszCscLocalName = NULL;
        if (!CSCCopyReplica(pszFile, &pszCscLocalName))
        {
            dwErr = GetLastError();
        }
        else
        {
            TraceAssert(NULL != pszCscLocalName);

            //
            // Combine the temporary path and the original filespec to form
            // a name that will be meaningful to the user when the file is opened
            // in it's application.
            //
            TCHAR szCscTempName[MAX_PATH];
            if (FAILED(StringCchCopy(szCscTempName, ARRAYSIZE(szCscTempName), pszCscLocalName))
                || !::PathRemoveFileSpec(szCscTempName)
                || !::PathAppend(szCscTempName, ::PathFindFileName(pszFile)))
            {
                dwErr = ERROR_INVALID_NAME;
            }
            else
            {
                //
                // Remove any read-only attribute in case there's still a copy left
                // from a previous "open" operation.  We'll need to overwrite the
                // existing copy.
                //
                DWORD dwAttrib = GetFileAttributes(szCscTempName);
                if ((DWORD)-1 != dwAttrib)
                {
                    SetFileAttributes(szCscTempName, dwAttrib & ~FILE_ATTRIBUTE_READONLY);
                }
                //
                // Rename the file to use the proper name.
                //
                if (!MoveFileEx(pszCscLocalName, szCscTempName, MOVEFILE_REPLACE_EXISTING))
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Set the file's READONLY bit so that the user can't save 
                    // changes to the file.  They can, however, save it somewhere
                    // else from within the opening app if they want.
                    //
                    dwAttrib = GetFileAttributes(szCscTempName);
                    if (!SetFileAttributes(szCscTempName, dwAttrib | FILE_ATTRIBUTE_READONLY))
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        SHELLEXECUTEINFO si;
                        ZeroMemory(&si, sizeof(si));
                        si.cbSize       = sizeof(si);
                        si.fMask        = SEE_MASK_FLAG_NO_UI;
                        si.lpFile       = szCscTempName;
                        si.nShow        = SW_NORMAL;

                        if (!ShellExecuteEx(&si))
                        {
                            dwErr = GetLastError();
                        }
                    }
                }
            }
            LocalFree(pszCscLocalName);
        }
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _PCH_H_
#define _PCH_H_

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
} // end of extern "C"
#endif

#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>    // SHFree
#include <shlwapi.h>
#include <shlwapip.h>   // QITAB, QISearch
#include <systrayp.h>   // STWM_ENABLESERVICE, etc.
#include <ccstock.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <cscapi.h>
#include <mobsync.h>    // OneStop/SyncMgr interfaces
#include <emptyvc.h>    // Memphis disk cleanup interface
#include <resource.h>   // resource IDs
#include <cscuiext.h>
#include <ras.h>
#include <rasdlg.h>
#include <raserror.h>
#include <strsafe.h>


#ifndef FLAG_CSC_SHARE_STATUS_PINNED_OFFLINE
//
// NTRAID#NTBUG9-350509-2001/04/11-brianau
//
//   JHarper defined this new flag in shdcom.h but I don't think he's
//   yet added it to cscapi.h.
//
#   define FLAG_CSC_SHARE_STATUS_PINNED_OFFLINE 0x2000
#endif

#ifndef FLAG_CSC_HINT_PIN_ADMIN
// This should be defined in cscapi.h, but since
// Remote Boot has been cancelled, use the system hint flag.
#define FLAG_CSC_HINT_PIN_ADMIN     FLAG_CSC_HINT_PIN_SYSTEM
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

//
// Convert a value to a "bool".
// Lower-case "boolify" is intentional to enforce relationship
// to type "bool".
//
template <class T>
inline bool boolify(const T& x)
{
    return !!x;
}


//
// Global function prototypes
//
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#include "debug.h"
#include "cscentry.h"
#include "uuid.h"       // GUIDs
#include "util.h"
#include "filelist.h"   // CscFileNameList, PCSC_NAMELIST_HDR
#include "shellex.h"
#include "update.h"
#include "volclean.h"
#include "config.h"


//
// Global variables
//
extern LONG             g_cRefCount;
extern HINSTANCE        g_hInstance;
extern CLIPFORMAT       g_cfShellIDList;
extern HANDLE           g_heventTerminate;
extern HANDLE           g_hmutexAdminPin;

//
// Magic debug flags
//
#define TRACE_UTIL          0x00000001
#define TRACE_SHELLEX       0x00000002
#define TRACE_UPDATE        0x00000004
#define TRACE_VOLFREE       0x00000008
#define TRACE_CSCST         0x00000080
#define TRACE_CSCENTRY      0x00000100
#define TRACE_ADMINPIN      0x00000200

#define TRACE_COMMON_ASSERT 0x40000000


/*-----------------------------------------------------------------------------
/ Exit macros
/   - these assume that a label "exit_gracefully:" prefixes the epilog
/     to your function
/----------------------------------------------------------------------------*/
#define ExitGracefully(hr, result, text)            \
            { TraceMsg(text); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
            { if ( FAILED(hr) ) { TraceMsg(text); goto exit_gracefully; } }


/*-----------------------------------------------------------------------------
/ Interface helper macros
/----------------------------------------------------------------------------*/
#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }


/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))


/*-----------------------------------------------------------------------------
/ Other helpful macros
/----------------------------------------------------------------------------*/
#define ByteOffset(base, offset)                    \
        (((LPBYTE)base)+offset)


//
// This is from shell32. From the comments in browseui
// this value will not change.
//
#define FCIDM_REFRESH 0xA220

#define MAX_PATH_BYTES  (MAX_PATH * sizeof(TCHAR))


#endif  // _PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\options.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       options.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
/*  File: options.cpp

    Description: Displays a property-sheet-like dialog containing
        optional settings for CSC.


        Classes:
            COfflineFilesPage - Contains basic CSC settings.  Designed
                to be dynamically added to the shell's View->Folder Options
                property sheet.

            CustomGOAAddDlg - Dialog for adding custom go-offline actions to
                the "advanced" dialog.

            CustomGOAEditDlg - Dialog for editing custom go-offline actions
                in the "advanced" dialog.

            CscOptPropSheetExt - Shell property sheet extension object for 
                adding the COfflineFilesPage to the shell's View->Folder Options
                property sheet.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/03/97    Initial creation.                                    BrianAu
    05/28/97    Removed CscOptPropSheet class.  Obsolete.            BrianAu
                Renamed AdvancedPage to CAdvOptDlg.  This better
                reflects the new behavior of the "advanced" dlg
                as a dialog rather than a property page as first
                designed.  
    07/29/98    Removed CscOptPropPage class.  Now we only have      BrianAu
                a single prop page so there was no reason for
                a common base class implementation.  All base
                class functionality has been moved up into the
                COfflineFilesPage class.
                Renamed "GeneralPage" class to "COfflineFilesPage"
                to reflect the current naming in the UI.
    08/21/98    Added PurgeCache and PurgeCacheCallback.             BrianAu
    08/27/98    Options dialog re-layout per PM changes.             BrianAu
                - Replaced part/full sync radio buttons with cbx.
                - Added reminder balloon controls.
    03/30/00    Added support for cache encryption.                  BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop


#include <math.h>
#include <prsht.h>
#include <resource.h>
#include <winnetwk.h>
#include <shlguidp.h>
#include <process.h>
#include <mobsyncp.h>
#include <htmlhelp.h>
#include "options.h"
#include "ccinline.h"
#include "msgbox.h"
#include "filesize.h"
#include "uuid.h"
#include "config.h"
#include "uihelp.h"
#include "cscst.h"   // For PWM_SETREMINDERTIMER
#include "util.h"    // Utils from "dll" directory.
#include "folder.h"
#include "purge.h"
#include "security.h"
#include "syncmgr.h"
#include "strings.h"
#include "termserv.h"


//
// Simple inline helper.  Why this isn't this a Win32 macro?
//
inline void EnableDialogItem(HWND hwnd, UINT idCtl, bool bEnable)
{
    EnableWindow(GetDlgItem(hwnd, idCtl), bEnable);
}


//
// This is for assisting the context help functions.
// Determine if the control has it's help text in windows.hlp or
// in our cscui.hlp.
//
bool UseWindowsHelp(int idCtl)
{
    bool bUseWindowsHelp = false;    
    switch(idCtl)
    {
        case IDOK:
        case IDCANCEL:
        case IDC_STATIC:
            bUseWindowsHelp = true;
            break;

        default:
            break;
    }
    return bUseWindowsHelp;
}


    

//-----------------------------------------------------------------------------
// COfflineFilesPage
//-----------------------------------------------------------------------------
const DWORD COfflineFilesPage::m_rgHelpIDs[] = {
    IDC_CBX_ENABLE_CSC,         HIDC_CBX_ENABLE_CSC,
    IDC_CBX_FULLSYNC_AT_LOGON,  HIDC_CBX_FULLSYNC_AT_LOGON,
    IDC_CBX_FULLSYNC_AT_LOGOFF, HIDC_CBX_FULLSYNC_AT_LOGOFF,
    IDC_CBX_LINK_ON_DESKTOP,    HIDC_CBX_LINK_ON_DESKTOP,
    IDC_CBX_ENCRYPT_CSC,        HIDC_CBX_ENCRYPT_CSC,
    IDC_CBX_REMINDERS,          HIDC_REMINDERS_ENABLE,
    IDC_SPIN_REMINDERS,         HIDC_REMINDERS_PERIOD,
    IDC_TXT_REMINDERS1,         DWORD(-1),               // "minutes."
    IDC_LBL_CACHESIZE_PCT,      DWORD(-1),               
    IDC_SLIDER_CACHESIZE_PCT,   HIDC_CACHESIZE_PCT,
    IDC_TXT_CACHESIZE_PCT,      DWORD(-1),
    IDC_BTN_DELETE_CACHE,       HIDC_BTN_DELETE_CACHE,
    IDC_BTN_VIEW_CACHE,         HIDC_BTN_VIEW_CACHE,
    IDC_BTN_ADVANCED,           HIDC_BTN_ADVANCED,
    IDC_STATIC2,                DWORD(-1),               // Icon
    IDC_STATIC3,                DWORD(-1),               // Icon's text.
    0, 0
    };



//
// This function is called in response to WM_INITDIALOG.  It is also
// called at other times to "reinitialize" the dialog controls to match
// the current CSC configuration.  This is why you see several checks
// for uninitialized values throughout the function.
//
BOOL
COfflineFilesPage::OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lInitParam
    )
{
    if (NULL == m_hwndDlg)
    {
        m_hwndDlg = hwnd;
    }

    //
    // Determine if the user has WRITE access to HKLM.
    //
    HKEY hkeyLM;
    DWORD disposition = 0;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        REGSTR_KEY_OFFLINEFILES,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkeyLM,
                                        &disposition))
    {
        m_bUserHasMachineAccess = true;
        RegCloseKey(hkeyLM);
        hkeyLM = NULL;
    }

    m_config.Load();


    if (!DisableForTerminalServer())
    {
        //
        // "Enable" checkbox.  This reflects the true state of CSC.  
        // Not the state of a registry setting.
        //
        CheckDlgButton(hwnd, 
                       IDC_CBX_ENABLE_CSC, 
                       IsCSCEnabled() ? BST_CHECKED : BST_UNCHECKED);


        //
        // "Sync at logon/logoff action checkboxes.
        //
        CheckDlgButton(hwnd, 
                       IDC_CBX_FULLSYNC_AT_LOGON, 
                       CConfig::eSyncFull == m_config.SyncAtLogon() ? BST_CHECKED : BST_UNCHECKED);

        CheckDlgButton(hwnd, 
                       IDC_CBX_FULLSYNC_AT_LOGOFF, 
                       CConfig::eSyncFull == m_config.SyncAtLogoff() ? BST_CHECKED : BST_UNCHECKED);
        //
        // Configure the "reminder" controls.
        //
        HWND hwndSpin = GetDlgItem(hwnd, IDC_SPIN_REMINDERS);
        HWND hwndEdit = GetDlgItem(hwnd, IDC_EDIT_REMINDERS);
        SendMessage(hwndSpin, UDM_SETRANGE, 0, MAKELONG((short)9999, (short)1));
        SendMessage(hwndSpin, UDM_SETBASE, 10, 0);

        UDACCEL rgAccel[] = {{ 2, 1  },
                             { 4, 10 },
                               6, 100};

        SendMessage(hwndSpin, UDM_SETACCEL, (WPARAM)ARRAYSIZE(rgAccel), (LPARAM)rgAccel);

        SendMessage(hwndEdit, EM_SETLIMITTEXT, 4, 0);

        CheckDlgButton(hwnd, 
                       IDC_CBX_REMINDERS, 
                       m_config.NoReminders() ? BST_UNCHECKED : BST_CHECKED);

        SetDlgItemInt(hwnd, IDC_EDIT_REMINDERS, m_config.ReminderFreqMinutes(), FALSE);

        if (IsLinkOnDesktop())
        {
            CheckDlgButton(hwnd, IDC_CBX_LINK_ON_DESKTOP, BST_CHECKED);
        }
        //
        // Create tooltip for "Encrypt cache" checkbox.
        // If it should be initially visible, that is done
        // in response to PSN_SETACTIVE.
        //
        CreateEncryptionTooltip();
        //
        // Update the "Encrypt" checkbox.
        //
        UpdateEncryptionCheckbox();
        //
        // "Cache Size" slider
        //
        CSCSPACEUSAGEINFO sui;
        GetCscSpaceUsageInfo(&sui);

        m_hwndSlider = GetDlgItem(hwnd, IDC_SLIDER_CACHESIZE_PCT);
        InitSlider(hwnd, sui.llBytesOnVolume, sui.llBytesTotalInCache);

        //
        // Determine if the volume hosting the CSC database supports encryption.
        //
        m_bCscVolSupportsEncryption = CscVolumeSupportsEncryption(sui.szVolume);

        HWND hwndParent = GetParent(hwnd);
        if (NULL == m_pfnOldPropSheetWndProc)
        {
            //
            // Subclass the propsheet itself so we can intercept move messages
            // and adjust the balloon tip position when the dialog is moved.
            //
            m_pfnOldPropSheetWndProc = (WNDPROC)SetWindowLongPtr(hwndParent, 
                                                                 GWLP_WNDPROC, 
                                                                 (LONG_PTR)PropSheetSubclassWndProc);
            SetProp(hwndParent, c_szPropThis, (HANDLE)this);
        }
        if (NULL == m_pfnOldEncryptionTooltipWndProc)
        {
            //
            // Subclass the tooltip balloon so we can make it pop when selected.
            // Tracking tooltips don't pop themselves when clicked.  You have
            // to do it for them.
            //
            m_pfnOldEncryptionTooltipWndProc = (WNDPROC)SetWindowLongPtr(m_hwndEncryptTooltip, 
                                                                         GWLP_WNDPROC, 
                                                                         (LONG_PTR)EncryptionTooltipSubclassWndProc);
            SetProp(m_hwndEncryptTooltip, c_szPropThis, (HANDLE)this);
        }
    }
    //
    // Save away the initial page state.  This will be used to 
    // determine when to enable the "Apply" button.  See 
    // HandlePageStateChange().
    //
    GetPageState(&m_state);
    return TRUE;
}


INT_PTR CALLBACK
COfflineFilesPage::DlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    COfflineFilesPage *pThis = (COfflineFilesPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
        {
            PROPSHEETPAGE *pPage = (PROPSHEETPAGE *)lParam;
            pThis = (COfflineFilesPage *)pPage->lParam;

            TraceAssert(NULL != pThis);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
            bResult = pThis->OnInitDialog(hDlg, (HWND)wParam, lParam);
            break;
        }

        case WM_NOTIFY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnNotify(hDlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_COMMAND:
            if (NULL != pThis)
                bResult = pThis->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnHelp(hDlg, (LPHELPINFO)lParam);
            break;

        case WM_CONTEXTMENU:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_DESTROY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnDestroy(hDlg);
            break;

        case WM_SETTINGCHANGE:
        case WM_SYSCOLORCHANGE:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnSettingChange(hDlg, message, wParam, lParam);
            break;

        case WM_MOVE:
            TraceAssert(NULL != pThis);
            pThis->TrackEncryptionTooltip();
            break;

        case WM_HSCROLL:
            //
            // The cache-size slider generates horizontal scroll messages.
            //
            TraceAssert(NULL != pThis);
            pThis->OnHScroll(hDlg,
                            (HWND)lParam,         // hwndSlider
                            (int)LOWORD(wParam),  // notify code
                            (int)HIWORD(wParam)); // thumb pos
            break;

        default:
            break;
    }
    return bResult;
}


//
// Subclass window proc for the property sheet.
// We intercept WM_MOVE messages and update the position of
// the balloon tooltip to follow the movement of the property
// page.
//
LRESULT 
COfflineFilesPage::PropSheetSubclassWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    COfflineFilesPage *pThis = (COfflineFilesPage *)GetProp(hwnd, c_szPropThis);
    TraceAssert(NULL != pThis);
    switch(uMsg)
    {
        case WM_MOVE:
            if (pThis->m_hwndEncryptTooltip && IsWindowVisible(pThis->m_hwndEncryptTooltip))
            {
                pThis->TrackEncryptionTooltip();
            }
            break;

        default:
            break;
    }
    return CallWindowProc(pThis->m_pfnOldPropSheetWndProc, hwnd, uMsg, wParam, lParam);
}



BOOL
COfflineFilesPage::OnDestroy(
    HWND hwnd
    )
{
    //
    // Remove window properties and cancel subclassing set in OnInitDialog.
    //
    HWND hwndParent = GetParent(hwnd);
    if (NULL != m_pfnOldPropSheetWndProc)
        SetWindowLongPtr(hwndParent, GWLP_WNDPROC, (LONG_PTR)m_pfnOldPropSheetWndProc);

    RemoveProp(hwndParent, c_szPropThis);

    if (NULL != m_hwndEncryptTooltip)
    {
        if (NULL != m_pfnOldEncryptionTooltipWndProc)
        {
            SetWindowLongPtr(m_hwndEncryptTooltip, GWLP_WNDPROC, (LONG_PTR)m_pfnOldEncryptionTooltipWndProc);
        }
        RemoveProp(m_hwndEncryptTooltip, c_szPropThis);
    }
    return FALSE;
}



//
// Forward all WM_SETTINGCHANGE and WM_SYSCOLORCHANGE messages
// to controls that need to stay in sync with color changes.
//
BOOL
COfflineFilesPage::OnSettingChange(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND rghwndCtls[] = { m_hwndSlider };

    for (int i = 0; i < ARRAYSIZE(rghwndCtls); i++)
    {
        SendMessage(rghwndCtls[i], uMsg, wParam, lParam);
    }
    return TRUE;
}


BOOL 
COfflineFilesPage::OnHelp(
    HWND hDlg, 
    LPHELPINFO pHelpInfo
    )
{
    if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
        int idCtl = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);
        WinHelp((HWND)pHelpInfo->hItemHandle, 
                 UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
                 HELP_WM_HELP, 
                 (DWORD_PTR)((LPTSTR)m_rgHelpIDs));
    }
    return TRUE;
}


BOOL
COfflineFilesPage::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem, 
            UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
            HELP_CONTEXTMENU, 
            (DWORD_PTR)((LPTSTR)m_rgHelpIDs));

    return FALSE;
}



UINT CALLBACK
COfflineFilesPage::PageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    UINT uReturn = 1;
    COfflineFilesPage *pThis = (COfflineFilesPage *)ppsp->lParam;
    TraceAssert(NULL != pThis);

    switch(uMsg)
    {
        case PSPCB_CREATE:
            //
            // uReturn == 0 means Don't create the prop page.
            //
            uReturn = 1;
            break;

        case PSPCB_RELEASE:
            //
            // This will release the extension and call the virtual
            // destructor (which will destroy the prop page object).
            //
            pThis->m_pUnkOuter->Release();
            break;
    }
    return uReturn;
}



BOOL
COfflineFilesPage::OnCommand(
    HWND hwnd,
    WORD wNotifyCode,
    WORD wID,
    HWND hwndCtl
    )
{
    BOOL bResult = TRUE;
    switch(wNotifyCode)
    {
        case BN_CLICKED:
            switch(wID)
            {
                case IDC_CBX_ENCRYPT_CSC:
                    //
                    // The "Encrypt cache" checkbox is the 3-state flavor so that
                    // we can represent the following states:
                    //
                    // CHECKED       == "encrypted"
                    // UNCHECKED     == "decrypted"
                    // INDETERMINATE == "partially encrypted or partially decrypted"
                    //
                    // We don't allow the user to set the checkbox state to 
                    // "indeterminate".  It can only become "indeterminate" through
                    // initialization in OnInitDialog.  Successive selections of a 
                    // checkbox cycle through the following states:
                    //
                    //     "checked"->"indeterminate"->"unchecked"->"checked"...
                    //
                    // Therefore, if the state is "indeterminate" following a user click
                    // we force it to "unchecked".  This way the checkbox can represent
                    // three states but the user has control of only two (checked and
                    // unchecked).
                    //
                    if (BST_INDETERMINATE == IsDlgButtonChecked(hwnd, wID))
                    {
                        CheckDlgButton(hwnd, wID, BST_UNCHECKED);
                    }
                    //
                    // The encryption tooltip only appears when the checkbox is in 
                    // the INDETERMINATE state.  Since we've just either checked 
                    // or unchecked it, the tooltip must disappear.
                    //
                    HideEncryptionTooltip();

                    HandlePageStateChange();
                    bResult = FALSE;
                    break;

                case IDC_CBX_ENABLE_CSC:
                    if (IsDlgButtonChecked(m_hwndDlg, IDC_CBX_ENABLE_CSC))
                    {
                        //
                        // Checked the "enable CSC" checkbox.
                        // Set the cache size slider to the default pct-used value (10%)
                        //
                        TrackBar_SetPos(m_hwndSlider, ThumbAtPctDiskSpace(0.10), true);
                        SetCacheSizeDisplay(GetDlgItem(m_hwndDlg, IDC_TXT_CACHESIZE_PCT), TrackBar_GetPos(m_hwndSlider));
                        CheckDlgButton(hwnd, 
                                       IDC_CBX_LINK_ON_DESKTOP, 
                                       IsLinkOnDesktop() ? BST_CHECKED : BST_UNCHECKED);
                    }
                    else
                    {
                        //
                        // If CSC is disabled we remove the Offline Files
                        // folder shortcut from the user's desktop.
                        //
                        CheckDlgButton(hwnd, IDC_CBX_LINK_ON_DESKTOP, BST_UNCHECKED);
                    }
                    //
                    // Fall through...
                    //
                case IDC_CBX_REMINDERS:
                    EnableCtls(hwnd);
                    //
                    // Fall through...
                    //
                case IDC_EDIT_REMINDERS:
                case IDC_CBX_FULLSYNC_AT_LOGOFF:
                case IDC_CBX_FULLSYNC_AT_LOGON:
                case IDC_SLIDER_CACHESIZE_PCT:
                case IDC_CBX_LINK_ON_DESKTOP:
                    HandlePageStateChange();
                    bResult = FALSE;
                    break;

                case IDC_BTN_VIEW_CACHE:
                    COfflineFilesFolder::Open();
                    bResult = FALSE;
                    break;

                case IDC_BTN_DELETE_CACHE:
                    //
                    // Ctl-Shift when pressing "Delete Files..." 
                    // is a special entry to reformatting the cache.
                    //
                    if ((0x8000 & GetAsyncKeyState(VK_SHIFT)) &&
                        (0x8000 & GetAsyncKeyState(VK_CONTROL)))
                    {
                        OnFormatCache();
                    }
                    else
                    {
                        OnDeleteCache();
                    }
                    bResult = FALSE;
                    break;

                case IDC_BTN_ADVANCED:
                {
                    CAdvOptDlg dlg(m_hInstance, m_hwndDlg);
                    dlg.Run();
                    break;
                }
                
                default:
                    break;
            }
            break;
    
        case EN_UPDATE:
            if (IDC_EDIT_REMINDERS == wID)
            {
                static bool bResetting; // prevent reentrancy.
                if (!bResetting)
                {
                    //
                    // The edit control is configured for a max of 4 digits and
                    // numbers-only.  Therefore the user can enter anything between
                    // 0 and 9999.  We don't want to allow 0 so we need this extra
                    // check.  The spinner has been set for a range of 0-9999.
                    //
                    int iValue = GetDlgItemInt(hwnd, IDC_EDIT_REMINDERS, NULL, FALSE);
                    if (0 == iValue)
                    {
                        bResetting = true;
                        SetDlgItemInt(hwnd, IDC_EDIT_REMINDERS, 1, FALSE);
                        bResetting = false;
                    }
                }
                HandlePageStateChange();
            }
            break;
    }
    return bResult;
}



//
// Gather the state of the page and store it in a PgState object.
//
void
COfflineFilesPage::GetPageState(
    PgState *pps
    )
{
    pps->SetCscEnabled(BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_ENABLE_CSC));
    pps->SetLinkOnDesktop(BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_LINK_ON_DESKTOP));
    pps->SetEncrypted(IsDlgButtonChecked(m_hwndDlg, IDC_CBX_ENCRYPT_CSC));
    pps->SetFullSyncAtLogon(BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_FULLSYNC_AT_LOGON));
    pps->SetFullSyncAtLogoff(BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_FULLSYNC_AT_LOGOFF));
    pps->SetSliderPos(TrackBar_GetPos(m_hwndSlider));
    pps->SetRemindersEnabled(BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_REMINDERS));
    pps->SetReminderFreq(GetDlgItemInt(m_hwndDlg, IDC_EDIT_REMINDERS, NULL, FALSE));
}

void
COfflineFilesPage::HandlePageStateChange(
    void
    )
{
    PgState s;
    GetPageState(&s);
    if (s == m_state)
        PropSheet_UnChanged(GetParent(m_hwndDlg), m_hwndDlg);
    else
        PropSheet_Changed(GetParent(m_hwndDlg), m_hwndDlg);
}


//
// Handle horizontal scroll messages generated by the cache-size slider.
//
void
COfflineFilesPage::OnHScroll(
    HWND hwndDlg,
    HWND hwndCtl,
    int iCode,
    int iPos
    )
{
    if (TB_THUMBPOSITION != iCode && TB_THUMBTRACK != iCode)
        iPos = TrackBar_GetPos(hwndCtl);

    SetCacheSizeDisplay(GetDlgItem(hwndDlg, IDC_TXT_CACHESIZE_PCT), iPos);
    if (TB_ENDTRACK == iCode)
        HandlePageStateChange();
}


//
// Update the cache size display "95.3 MB (23% of drive)" string.
//
void
COfflineFilesPage::SetCacheSizeDisplay(
    HWND hwndCtl,
    int iThumbPos
    )
{
    //
    // First convert the thumb position to a disk space value.
    //
    TCHAR szSize[40];
    FileSize fs(DiskSpaceAtThumb(iThumbPos));
    fs.GetString(szSize, ARRAYSIZE(szSize));
    //
    // Convert the thumb position to a percent-disk space value.
    //
    double x = 0.0;
    if (0 < iThumbPos)
        x = MAX(1.0, Rx(iThumbPos) * 100.00);
    //
    // Convert the percent-disk space value to a text string.
    //
    TCHAR szPct[10];
    wnsprintf(szPct, ARRAYSIZE(szPct), TEXT("%d"), (DWORD)x);
    //
    // Format the result and display in the dialog.
    //
    LPTSTR pszText;
    if (0 < FormatStringID(&pszText, m_hInstance, IDS_FMT_CACHESIZE_DISPLAY, szSize, szPct))
    {
        SetWindowText(hwndCtl, pszText);
        LocalFree(pszText);
    }
}



void
COfflineFilesPage::InitSlider(
    HWND hwndDlg,
    LONGLONG llSpaceMax,
    LONGLONG llSpaceUsed
    )
{
    double pctUsed = 0.0; // Default
    
    //
    // Protect against:
    // 1. Div-by-zero
    // 2. Invalid FP operation. (i.e. 0.0 / 0.0)
    //
    if (0 != llSpaceMax)
       pctUsed = double(llSpaceUsed) / double(llSpaceMax);

    //
    // Change the resolution of the slider as drives get larger.
    //
    m_iSliderMax = 100;     // < 1GB
    if (llSpaceMax > 0x0000010000000000i64)
        m_iSliderMax = 500; // >= 1TB
    else if (llSpaceMax > 0x0000000040000000i64)
        m_iSliderMax = 300; // >= 1GB
                        
    m_llAvailableDiskSpace = llSpaceMax;


    TrackBar_SetTicFreq(m_hwndSlider, m_iSliderMax / 10);
    TrackBar_SetPageSize(m_hwndSlider, m_iSliderMax / 10);
    TrackBar_SetRange(m_hwndSlider, 0, m_iSliderMax, false);
    TrackBar_SetPos(m_hwndSlider, ThumbAtPctDiskSpace(pctUsed), true);
    SetCacheSizeDisplay(GetDlgItem(hwndDlg, IDC_TXT_CACHESIZE_PCT), TrackBar_GetPos(m_hwndSlider));
}


//
// Enable/disable page controls.
//
void
COfflineFilesPage::EnableCtls(
    HWND hwnd
    )
{

    typedef bool (CConfigItems::*PBMF)(void) const;

    static const struct
    {
        UINT idCtl;
        PBMF pfnRestricted;
        bool bRequiresMachineAccess;

    } rgCtls[] = { { IDC_CBX_FULLSYNC_AT_LOGOFF, &CConfigItems::NoConfigSyncAtLogoff, false },
                   { IDC_CBX_FULLSYNC_AT_LOGON,  &CConfigItems::NoConfigSyncAtLogon,  false },
                   { IDC_CBX_REMINDERS,          &CConfigItems::NoConfigReminders,    false },
                   { IDC_CBX_LINK_ON_DESKTOP,    NULL,                                false },
                   { IDC_CBX_ENCRYPT_CSC,        &CConfigItems::NoConfigEncryptCache, true  },
                   { IDC_TXT_CACHESIZE_PCT,      NULL,                                true  },
                   { IDC_SLIDER_CACHESIZE_PCT,   &CConfigItems::NoConfigCacheSize,    true  },
                   { IDC_LBL_CACHESIZE_PCT,      &CConfigItems::NoConfigCacheSize,    true  },
                   { IDC_BTN_VIEW_CACHE,         NULL,                                false },
                   { IDC_BTN_ADVANCED,           NULL,                                false },
                   { IDC_BTN_DELETE_CACHE,       NULL,                                false }
                 };

    bool bCscEnabled = BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CBX_ENABLE_CSC);
    bool bEnable;
    for (int i = 0; i < ARRAYSIZE(rgCtls); i++)
    {
        bEnable = bCscEnabled;
        if (bEnable)
        {
            if (rgCtls[i].bRequiresMachineAccess && !m_bUserHasMachineAccess)
            {
                bEnable = false;
            }
            if (bEnable)
            {
                //
                // Apply any policy restrictions.
                //
                PBMF pfn = rgCtls[i].pfnRestricted;
                if (NULL != pfn && (m_config.*pfn)())
                    bEnable = false;

                if (bEnable)
                {
                    //
                    // "View..." button requires special handling as it isn't based off of a 
                    // boolean restriction function.
                    //
                    if ((IDC_BTN_VIEW_CACHE == rgCtls[i].idCtl || IDC_CBX_LINK_ON_DESKTOP == rgCtls[i].idCtl) && m_config.NoCacheViewer())
                    {
                        bEnable = false;
                    }
                    else if (IDC_CBX_ENCRYPT_CSC == rgCtls[i].idCtl)
                    {
                        // 
                        // "Encrypt offline files" checkbox requires special handling.
                        //
                        // Cache encryption cannot be performed with CSC disabled or
                        // if the CSC volume doesn't support encryption or if the user
                        // is not an administrator.
                        //
                        if (!bCscEnabled || 
                            !m_bCscVolSupportsEncryption || 
                            !IsCurrentUserAnAdminMember())
                        {
                            bEnable = false;
                        }
                    }
                }
            }
        }
        EnableDialogItem(hwnd, rgCtls[i].idCtl, bEnable);
    }

    //
    // Reminder controls are dependent upon several inputs.
    //
    bEnable = bCscEnabled && 
              (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CBX_REMINDERS)) &&
              !m_config.NoConfigReminders() &&
              !m_config.NoConfigReminderFreqMinutes();

    EnableDialogItem(hwnd, IDC_TXT_REMINDERS1, bEnable);
    EnableDialogItem(hwnd, IDC_EDIT_REMINDERS, bEnable);
    EnableDialogItem(hwnd, IDC_SPIN_REMINDERS, bEnable);
    //
    // "Enabled" checkbox requires special handling.
    // It can't be included with the other controls because it will be disabled
    // when the user unchecks it.  Then there's no way to re-enable it.
    // Disable the checkbox if any of the following is true:
    //  1. Admin policy has enabled/disabled CSC.
    //  2. User doesn't have WRITE access to HKLM.
    //
    bEnable = !m_config.NoConfigCscEnabled() && m_bUserHasMachineAccess;

    EnableWindow(GetDlgItem(hwnd, IDC_CBX_ENABLE_CSC), bEnable);
}



BOOL 
COfflineFilesPage::OnNotify(
    HWND hDlg, 
    int idCtl, 
    LPNMHDR pnmhdr
    )
{
    BOOL bResult = TRUE;

    switch(pnmhdr->code)
    {
        case PSN_APPLY:
            //
            // Prevent re-entrancy.  If the user changes the encryption
            // setting and presses "OK", the prop sheet will remain visible
            // during the encryption operation.  Since we're displaying a progress
            // dialog and pumping messages, it's possible for the user to 
            // re-select the "OK" or "Apply" buttons during the encryption.
            // Use a simple flag variable to prevent re-entrancy.
            //
            if (!m_bApplyingSettings)
            {
                m_bApplyingSettings = true;
                //
                // If the lParam is TRUE, the property sheet is closing.
                //
                bResult = ApplySettings(hDlg, boolify(((LPPSHNOTIFY)pnmhdr)->lParam));
                m_bApplyingSettings = false;
            }
            break;

        case PSN_KILLACTIVE:
            //
            // Hide the tooltip when the page is deactivated.
            //
            HideEncryptionTooltip();
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            bResult = FALSE;
            break;

        case PSN_SETACTIVE:
            //
            // Enable/disable controls whenever the page becomes active.
            //
            EnableCtls(hDlg);
            //
            // Display the encryption tooltip balloon if necessary
            // on the FIRST page activation only.
            // Note that we need to do this here rather than in OnInitDialog
            // to prevent the balloon from 'hopping' when the property sheet
            // code repositions the page.
            //
            if (m_bFirstActivate)
            {
                UpdateEncryptionTooltipBalloon();
                m_bFirstActivate = false;
            }
            
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            bResult = FALSE;
            break;

        case PSN_TRANSLATEACCELERATOR:
            //
            // User pressed a key.
            // Hide the tooltip.
            //
            HideEncryptionTooltip();
            break;

        case TTN_GETDISPINFO:
            OnTTN_GetDispInfo((LPNMTTDISPINFO)pnmhdr);
            break;


        default:
            break;

    }
    return bResult;
}


LRESULT 
COfflineFilesPage::EncryptionTooltipSubclassWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    COfflineFilesPage *pThis = (COfflineFilesPage *)GetProp(hwnd, c_szPropThis);
    TraceAssert(NULL != pThis);

    switch(uMsg)
    {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            //
            // When the tooltip balloon is clicked, pop the balloon.
            //
            pThis->HideEncryptionTooltip();
            //
            // Fall through...
            //
        default:
            break;
    }
    return CallWindowProc(pThis->m_pfnOldEncryptionTooltipWndProc, hwnd, uMsg, wParam, lParam);
}


//
// Create a tooltip for a given control.
// The parent of the control is required to respond to TTN_GETDISPINFO
// and provide the text.
//
void 
COfflineFilesPage::CreateEncryptionTooltip(
    void
    )
{
    if (NULL == m_hwndEncryptTooltip)
    {
        INITCOMMONCONTROLSEX iccex; 
        iccex.dwICC  = ICC_WIN95_CLASSES;
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        InitCommonControlsEx(&iccex);

        m_hwndEncryptTooltip = CreateWindowEx(NULL,
                                              TOOLTIPS_CLASS,
                                              NULL,
                                              WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,		
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              GetDlgItem(m_hwndDlg, IDC_CBX_ENCRYPT_CSC),
                                              NULL,
                                              m_hInstance,
                                              NULL);
        if (NULL != m_hwndEncryptTooltip)
        {
            TOOLINFO ti;
            ti.cbSize   = sizeof(TOOLINFO);
            ti.uFlags   = TTF_TRACK | TTF_ABSOLUTE;
            ti.hwnd     = m_hwndDlg;
            ti.uId      = IDC_CBX_ENCRYPT_CSC;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.hinst    = NULL;
            ti.lParam   = 0;
    
            SendMessage(m_hwndEncryptTooltip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);	
            //
            // Set the tooltip width to 3/4 the dialog width.
            //
            RECT rcDlg;
            GetClientRect(m_hwndDlg, &rcDlg);
            SendMessage(m_hwndEncryptTooltip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(((rcDlg.right-rcDlg.left) * 3) / 4));
        }
    }
}


void
COfflineFilesPage::OnTTN_GetDispInfo(
    LPNMTTDISPINFO pttdi
    )
{
    LPNMHDR pnmhdr = (LPNMHDR)pttdi;
    BOOL bResult   = TRUE;

    UINT idCtl = (UINT)(UINT_PTR)pnmhdr->idFrom;
    if (TTF_IDISHWND & pttdi->uFlags)
    {
        idCtl = GetDlgCtrlID((HWND)pnmhdr->idFrom);
    }
    if (IDC_CBX_ENCRYPT_CSC == idCtl)
    {
        //
        // Provide the text and image for the encryption tooltip.
        //

        //
        // These constants are standard for TTM_SETTITLE.
        //
        enum TTICON { TTICON_NONE, TTICON_INFO, TTICON_WARNING, TTICON_ERROR };
        //
        // Map of state to body text.
        //
        const UINT rgBodyText[][2] = { 
           // -------------- Decryption ------------  ---------- Encryption ------------------
            { IDS_TT_BODY_DECRYPTED_PARTIAL_NONADMIN, IDS_TT_BODY_ENCRYPTED_PARTIAL_NONADMIN }, // Non-admin user
            { IDS_TT_BODY_DECRYPTED_PARTIAL,          IDS_TT_BODY_ENCRYPTED_PARTIAL          }  // Admin user
            };
        //
        // Map of state to title text and icon.
        //
        const struct
        {
            UINT idsTitle; // Title text
            int  iIcon;    // TTICON_XXXX

        } rgTitleAndIcon[] = {
            { IDS_TT_TITLE_DECRYPTED_PARTIAL, TTICON_INFO    }, // Decryption
            { IDS_TT_TITLE_ENCRYPTED_PARTIAL, TTICON_WARNING }  // Encryption
            };

        const BOOL bEncrypted = IsCacheEncrypted(NULL);
        //
        // For non-admin users, the "Encrypt CSC" checkbox is disabled.
        //
        const BOOL bCbxEncryptEnabled = IsWindowEnabled(GetDlgItem(m_hwndDlg, IDC_CBX_ENCRYPT_CSC));
        //
        // Tooltip body text.
        //
        m_szEncryptTooltipBody[0] = TEXT('\0');
        LoadString(m_hInstance, 
                   rgBodyText[int(bCbxEncryptEnabled)][int(bEncrypted)],
                   m_szEncryptTooltipBody,
                   ARRAYSIZE(m_szEncryptTooltipBody));

        pttdi->lpszText = m_szEncryptTooltipBody;
        //
        // Tooltip title text and icon.
        //
        const iIcon = rgTitleAndIcon[int(bEncrypted)].iIcon;
        LPTSTR pszTitle;
        if (0 < FormatStringID(&pszTitle, m_hInstance, rgTitleAndIcon[int(bEncrypted)].idsTitle))
        {
            SendMessage(m_hwndEncryptTooltip, TTM_SETTITLE, (WPARAM)iIcon, (LPARAM)pszTitle);
            LocalFree(pszTitle);
        }
    }
}



void 
COfflineFilesPage::ShowEncryptionTooltip(
    bool bEncrypted
    )
{
    if (NULL != m_hwndEncryptTooltip)
    {
        //
        // Position tooltip correctly before showing
        //
        TrackEncryptionTooltip();
        //
        // Show the tooltip.
        //
        TOOLINFO ti;
        ti.cbSize   = sizeof(ti);
        ti.hwnd     = m_hwndDlg;
        ti.uId      = IDC_CBX_ENCRYPT_CSC;

        SendMessage(m_hwndEncryptTooltip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
        SendMessage(m_hwndEncryptTooltip, TTM_UPDATE, 0, 0);
    }
}


void
COfflineFilesPage::HideEncryptionTooltip(
    void
    )
{
    if (NULL != m_hwndEncryptTooltip)
    {
        SendMessage(m_hwndEncryptTooltip, TTM_TRACKACTIVATE, (WPARAM)FALSE, 0);
    }
}


void 
COfflineFilesPage::TrackEncryptionTooltip(
    void
    )
{
    //
    // Point the tip stem at center of the lower edge of the encryption
    // checkbox.
    // The Windows UX manual says checkboxes are 10 dialog units wide.
    //
    if (NULL != m_hwndEncryptTooltip)
    {
        const INT DialogBaseUnitsX = LOWORD(GetDialogBaseUnits());
        const INT cxCbx            = (DialogBaseUnitsX * 10) / 4;
        RECT rc;

        GetWindowRect(GetDlgItem(m_hwndDlg, IDC_CBX_ENCRYPT_CSC), &rc);

        SendMessage(m_hwndEncryptTooltip, 
                    TTM_TRACKPOSITION, 
                    0, 
                    (LPARAM)(DWORD)MAKELONG(rc.left + (cxCbx / 2), rc.bottom));
    }
}



//
// Set the state of the "Encrypt Cache" checkbox to reflect
// the actual state of cache encryption.  Also display
// the balloon tooltip if the checkbox is in the 
// indeterminate state.
//
void
COfflineFilesPage::UpdateEncryptionCheckboxOrBalloon(
    bool bCheckbox
    )
{
    //
    // "Encrypt CSC" checkbox.
    // The display logic is captured in this table.
    //
    const UINT rgCheck[] = { BST_UNCHECKED,     // 00 = Decrypted,
                             BST_INDETERMINATE, // 01 = Partially decrypted
                             BST_CHECKED,       // 10 = Encrypted,
                             BST_INDETERMINATE  // 11 = Partially encrypted
                           };

    BOOL bPartial         = FALSE;
    const BOOL bEncrypted = IsCacheEncrypted(&bPartial);
    const int iState      = (int(bEncrypted) << 1) | int(bPartial);

    if (bCheckbox)
    {
        //
        // Update the checkbox.
        //  
        CheckDlgButton(m_hwndDlg, IDC_CBX_ENCRYPT_CSC, rgCheck[iState]);
    }
    else
    {
        //
        // Update the tooltip
        //
        if (BST_INDETERMINATE == rgCheck[iState])
        {
            ShowEncryptionTooltip(boolify(bEncrypted));
        }
        else
        {
            HideEncryptionTooltip();
        }
    }
}


void
COfflineFilesPage::UpdateEncryptionCheckbox(
    void
    )
{
    UpdateEncryptionCheckboxOrBalloon(true);
}

void 
COfflineFilesPage::UpdateEncryptionTooltipBalloon(
    void
    )
{
    UpdateEncryptionCheckboxOrBalloon(false);
}



BOOL
COfflineFilesPage::ApplySettings(
    HWND hwnd,
    bool bPropSheetClosing
    )
{
    //
    // Query the current state of controls on the page to see if
    // anything has changed.
    //
    PgState s;
    GetPageState(&s);
    if (s != m_state)
    {
        //
        // Something on the page has changed.
        // Open the reg keys.
        //
        HKEY hkeyLM = NULL;
        HKEY hkeyCU = NULL;
        DWORD dwDisposition;
        DWORD dwResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                                        REGSTR_KEY_OFFLINEFILES,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkeyLM,
                                        &dwDisposition);
        if (ERROR_SUCCESS != dwResult)                                        
        {
            Trace((TEXT("Error %d opening NetCache machine settings key"), dwResult));
            //
            // Continue...  
            // Note that EnableCtls has disabled any controls that require
            // WRITE access to HKLM.
            //
        }
        dwResult = RegCreateKeyEx(HKEY_CURRENT_USER, 
                                  REGSTR_KEY_OFFLINEFILES,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE,
                                  NULL,
                                  &hkeyCU,
                                  &dwDisposition);

        if (ERROR_SUCCESS != dwResult)                                  
        {
            //
            // Failure to open HKCU is a problem.  No use in proceeding.
            //
            Trace((TEXT("Error %d opening NetCache user settings key"), dwResult));
            RegCloseKey(hkeyLM);
            return FALSE;
        }
        //
        // Handle encryption/decryption of the cache (part 1).
        // Encryption/decryption can only be done when CSC is enabled.
        // Therefore, since the user can change both the "enabled" and
        // "encrypted" state from the same property page we need to be smart
        // about when to do the encryption.  We may need to do it before
        // disabling CSC or after enabling CSC.
        //
        bool bEncryptOperationPerformed = false;
        if (m_state.GetCscEnabled() && !s.GetCscEnabled())
        {
            //
            // User is disabling CSC.  If they also want to change the cache
            // encryption state we must do it now while CSC is enabled.
            //
            _ApplyEncryptionSetting(hkeyLM, hkeyCU, s, bPropSheetClosing, &bEncryptOperationPerformed);
        }

        bool bUpdateSystrayUI = false;
        _ApplyEnabledSetting(hkeyLM, hkeyCU, s, &bUpdateSystrayUI);

        //
        // Handle encryption/decryption of the cache (part 2).
        //
        if (!bEncryptOperationPerformed)
        {
            //
            // Encryption has not yet been performed.  If user wants to change encryption 
            // state, do it now.
            // Note that if the user enabled CSC and that enabling failed, encryption 
            // will also fail.  Not a worry since the probability that CSC will fail
            // to be enabled is extrememly low (I've never seen it fail).  If it does
            // the encryption process will display an error message.
            //
            _ApplyEncryptionSetting(hkeyLM, hkeyCU, s, bPropSheetClosing, &bEncryptOperationPerformed);
        }

        //
        // Write "sync-at-logon/logoff" (quick vs. full) settings.
        //
        _ApplySyncAtLogonSetting(hkeyLM, hkeyCU, s);
        _ApplySyncAtLogoffSetting(hkeyLM, hkeyCU, s);
        //
        // Write the various "reminders" settings.
        //
        _ApplyReminderSettings(hkeyLM, hkeyCU, s);
        //
        // Create or remove the folder link on the desktop.
        //
        _ApplyFolderLinkSetting(hkeyLM, hkeyCU, s);
        //
        // Write cache size as pct * 10,000.
        //
        _ApplyCacheSizeSetting(hkeyLM, hkeyCU, s);
        //
        // Refresh the cached page state info.
        //
        GetPageState(&m_state);
        //
        // Update the SysTray icon if necessary.
        //
        if (bUpdateSystrayUI)
        {
            HWND hwndNotify = NULL;
            if (!s.GetCscEnabled())
            {
                //
                // If we're disabling CSC, refresh the shell windows BEFORE we 
                // destroy the SysTray CSCUI "service".
                //
                hwndNotify = _FindNotificationWindow();
                if (IsWindow(hwndNotify))
                {
                    SendMessage(hwndNotify, PWM_REFRESH_SHELL, 0, 0);
                }
            }

            HWND hwndSysTray = FindWindow(SYSTRAY_CLASSNAME, NULL);
            if (IsWindow(hwndSysTray))
            {
                SendMessage(hwndSysTray, STWM_ENABLESERVICE, STSERVICE_CSC, s.GetCscEnabled());
            }

            if (s.GetCscEnabled())
            {
                SHLoadNonloadedIconOverlayIdentifiers();

                //
                // If we're enabling CSC, refresh the shell windows AFTER we 
                // create the SysTray CSCUI "service".
                //
                hwndNotify = _FindNotificationWindow();
                if (IsWindow(hwndNotify))
                {
                    PostMessage(hwndNotify, PWM_REFRESH_SHELL, 0, 0);
                }
            }
        }
        if (hkeyLM)
        {
            RegCloseKey(hkeyLM);
        }
        if (hkeyCU)
        {
            RegCloseKey(hkeyCU);
        }
    }
    return TRUE;
}


HRESULT
COfflineFilesPage::_ApplyEnabledSetting(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow,
    bool *pbUpdateSystrayUI
    )
{
    HRESULT hr = S_OK;
 
    *pbUpdateSystrayUI = false;

    //
    // Process the "enabled" setting even if the page state hasn't
    // changed.  This is a special case because we initialize the 
    // "enabled" checkbox from IsCSCEnabled() but we change the
    // enabled/disabled state by setting a registry value and 
    // possibly rebooting.
    //
    DWORD dwValue = DWORD(pgstNow.GetCscEnabled());
    DWORD dwResult = RegSetValueEx(hkeyLM,
                                   REGSTR_VAL_CSCENABLED,
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwValue,
                                   sizeof(dwValue));
                                   
    hr = HRESULT_FROM_WIN32(dwResult);                                  
    if (FAILED(hr))
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_CSCENABLED));
    }

    //
    // Handle any enabling/disabling of CSC.
    //
    if (pgstNow.GetCscEnabled() != boolify(IsCSCEnabled()))
    {
        bool bReboot  = false;
        DWORD dwError = ERROR_SUCCESS;
        if (EnableOrDisableCsc(pgstNow.GetCscEnabled(), &bReboot, &dwError))
        {
            if (bReboot)
            {
                //
                // Requires a reboot.
                //
                PropSheet_RebootSystem(GetParent(m_hwndDlg));
            }
            else
            {
                //
                // It's dynamic (no reboot) so update the systray UI.
                // Note that we want to update the systray UI AFTER we've
                // made any configuration changes to the registry 
                // (i.e. balloon settings).
                //
                *pbUpdateSystrayUI = true;
            }
        }
        else
        {
            //
            // Error trying to enable or disable CSC.
            //
            CscMessageBox(m_hwndDlg,
                          MB_ICONERROR | MB_OK,
                          Win32Error(dwError),
                          m_hInstance,
                          pgstNow.GetCscEnabled() ? IDS_ERR_ENABLECSC : IDS_ERR_DISABLECSC);
        }
    }
    return hr;
}



HRESULT
COfflineFilesPage::_ApplySyncAtLogoffSetting(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow
    )
{
    //
    // Write "sync-at-logoff" (quick vs. full) setting.
    //
    DWORD dwValue = DWORD(pgstNow.GetFullSyncAtLogoff());
    DWORD dwResult = RegSetValueEx(hkeyCU,
                                   REGSTR_VAL_SYNCATLOGOFF,
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwValue,
                                   sizeof(dwValue));
                                   
    HRESULT hr = HRESULT_FROM_WIN32(dwResult);                                   
    if (SUCCEEDED(hr))
    {
        if (!m_state.GetFullSyncAtLogoff() && pgstNow.GetFullSyncAtLogoff())
        {
            //
            // If the user has just turned on full sync we want to 
            // make sure SyncMgr is enabled for sync-at-logoff.  
            // There are some weirdnesses with doing this but it's the most
            // consistent behavior we can offer the user given
            // the current design of SyncMgr and CSC.  Internal use and beta
            // testing shows that users expect Sync-at-logoff to be enabled
            // when this checkbox is checked.
            //
            RegisterSyncMgrHandler(TRUE);
            RegisterForSyncAtLogonAndLogoff(SYNCMGRREGISTERFLAG_PENDINGDISCONNECT, 
                                            SYNCMGRREGISTERFLAG_PENDINGDISCONNECT);
        }                                            
    }
    else
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_SYNCATLOGOFF));
    }
    return hr;
}



HRESULT
COfflineFilesPage::_ApplySyncAtLogonSetting(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow
    )
{
    //
    // Write "sync-at-logon" (quick vs. full) setting.
    //
    DWORD dwValue = DWORD(pgstNow.GetFullSyncAtLogon());
    DWORD dwResult = RegSetValueEx(hkeyCU,
                                   REGSTR_VAL_SYNCATLOGON,
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwValue,
                                   sizeof(dwValue));
                                   
    HRESULT hr = HRESULT_FROM_WIN32(dwResult);
    if (SUCCEEDED(hr))
    {
        if (!m_state.GetFullSyncAtLogon() && pgstNow.GetFullSyncAtLogon())
        {
            //
            // If the user has just turned on full sync we want to 
            // make sure SyncMgr is enabled for sync-at-logon.  
            // There are some weirdnesses with doing this but it's the most
            // consistent behavior we can offer the user given
            // the current design of SyncMgr and CSC.  Internal use and beta
            // testing shows that users expect Sync-at-logon to be enabled
            // when this checkbox is checked.
            //
            RegisterSyncMgrHandler(TRUE);
            RegisterForSyncAtLogonAndLogoff(SYNCMGRREGISTERFLAG_CONNECT, 
                                            SYNCMGRREGISTERFLAG_CONNECT);
        }                                            
    }
    else
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_SYNCATLOGON));
    }
    return hr;
}



HRESULT
COfflineFilesPage::_ApplyReminderSettings(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow
    )
{
    DWORD dwValue = DWORD(!pgstNow.GetRemindersEnabled());
    DWORD dwResult = RegSetValueEx(hkeyCU,
                                   REGSTR_VAL_NOREMINDERS,
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwValue,
                                   sizeof(dwValue));
                                   
    HRESULT hr = HRESULT_FROM_WIN32(dwResult);
    if (FAILED(hr))
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_NOREMINDERS));
    }

    dwValue = DWORD(pgstNow.GetReminderFreq());
    dwResult = RegSetValueEx(hkeyCU,
                             REGSTR_VAL_REMINDERFREQMINUTES,
                             0,
                             REG_DWORD,
                             (CONST BYTE *)&dwValue,
                             sizeof(dwValue));
                             
    hr = HRESULT_FROM_WIN32(dwResult);
    if (FAILED(hr))
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_REMINDERFREQMINUTES));
    }

    if (m_state.GetReminderFreq() != pgstNow.GetReminderFreq())
    {
        PostToSystray(PWM_RESET_REMINDERTIMER, 0, 0);
    }
    return hr;
}



HRESULT
COfflineFilesPage::_ApplyFolderLinkSetting(
    HKEY /* hkeyLM */,
    HKEY /* hkeyCU */,
    const PgState& pgstNow
    )
{
    if (m_state.GetLinkOnDesktop() != pgstNow.GetLinkOnDesktop())
    {
        TCHAR szLinkPath[MAX_PATH];
        bool bLinkFileIsOnDesktop = IsLinkOnDesktop(szLinkPath, ARRAYSIZE(szLinkPath));
        if (bLinkFileIsOnDesktop && !pgstNow.GetLinkOnDesktop())
        {
            DeleteOfflineFilesFolderLink(m_hwndDlg);
        }
        else if (!bLinkFileIsOnDesktop && pgstNow.GetLinkOnDesktop())
        {
            COfflineFilesFolder::CreateLinkOnDesktop(m_hwndDlg);
        }
    }
    return S_OK;
}



HRESULT
COfflineFilesPage::_ApplyCacheSizeSetting(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow
    )
{

    double pctCacheSize = Rx(TrackBar_GetPos(m_hwndSlider));
    DWORD dwValue = DWORD(pctCacheSize * 10000.00);
    DWORD dwResult = RegSetValueEx(hkeyLM,
                                   REGSTR_VAL_DEFCACHESIZE,
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwValue,
                                   sizeof(dwValue));

    HRESULT hr = HRESULT_FROM_WIN32(dwResult);
    if (FAILED(hr))
    {
        Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_DEFCACHESIZE));
    }

    ULARGE_INTEGER ulCacheSize;

    ulCacheSize.QuadPart = DWORDLONG(m_llAvailableDiskSpace * pctCacheSize);
    if (!CSCSetMaxSpace(ulCacheSize.HighPart, ulCacheSize.LowPart))
    {
        Trace((TEXT("Error %d setting cache size"), GetLastError()));
    }
    return hr;
}



HRESULT
COfflineFilesPage::_ApplyEncryptionSetting(
    HKEY hkeyLM,
    HKEY hkeyCU,
    const PgState& pgstNow,
    bool bPropSheetClosing,
    bool *pbPerformed
    )
{
    HRESULT hr = S_OK;

    *pbPerformed = false;
    if (m_state.GetEncrypted() != pgstNow.GetEncrypted())
    {
        EncryptOrDecryptCache(BST_CHECKED == pgstNow.GetEncrypted(), bPropSheetClosing);
        *pbPerformed = true;
        //
        // Record the user's setting in the registry as a "preference".  If policy
        // is later applied then removed we need to know the user's previous preference.
        // Note that it's a per-machine preference.  Also note that if the "encrypted"
        // state of the checkbox has changed, we are assured that the user has WRITE
        // access to HKLM.  
        //
        DWORD dwValue = pgstNow.GetEncrypted();
        DWORD dwResult = RegSetValueEx(hkeyLM,
                                       REGSTR_VAL_ENCRYPTCACHE,
                                       0,
                                       REG_DWORD,
                                       (CONST BYTE *)&dwValue,
                                       sizeof(dwValue));
        if (ERROR_SUCCESS != dwResult)
        {
            hr = HRESULT_FROM_WIN32(dwResult);
            Trace((TEXT("Error 0x%08X setting reg value \"%s\""), hr, REGSTR_VAL_ENCRYPTCACHE));
        }
    }
    return hr;
}





//
// Structure for communicating between the Prop Sheet code
// and the CSC progress callbacks.
//
struct ENCRYPT_PROGRESS_INFO
{
    HINSTANCE hInstance;     // Module containing UI text strings.
    HWND hwndParentDefault;  // Default parent window for error UI.
    IProgressDialog *pDlg;   // Progress dialog.
    int  cFilesTotal;        // Total files to be processed.
    int  cFilesProcessed;    // Running count of files processed.
    bool bUserCancelled;     // User cancelled operation?
    bool bPropSheetClosing;  // User pressed "OK" so the prop sheet is closing.
};

//
// Organize the parameters passed from a CSC callback function
// into a single structure.  Note that not all the callback
// parameters are used here.  I've commented out the ones that
// aren't.  If they're needed later, uncomment them and 
// fill in the value in EncryptDecryptCallback().
//
struct CSC_CALLBACK_DATA
{
    LPCWSTR lpszName;
    DWORD dwReason;
    DWORD dwParam1;
    DWORD dwParam2;
    DWORD_PTR dwContext;

/* ----- Unused ------

    DWORD dwStatus;
    DWORD dwHintFlags;
    DWORD dwPinCount;
    WIN32_FIND_DATAW *pFind32;
*/
};


//
// Helper to get the HWND of the progress dialog
// from the progress info block.
//
HWND 
ParentWindowFromProgressInfo(
    const ENCRYPT_PROGRESS_INFO &epi
    )
{
    const HWND hwndParent = GetProgressDialogWindow(epi.pDlg);
    if (NULL != hwndParent)
        return hwndParent;

    return epi.hwndParentDefault;
}


//
// The progress dialog lower's the priority class of it's thread to
// THREAD_PRIORITY_BELOW_NORMAL so that it doesn't compete with the 
// thread doing the real work.  Unfortunately, with this encryption
// stuff this resulted in the dialog being starved of CPU time so that
// it didn't appear in some cases.  To ensure proper operation of the
// progress dialog we promote it's priority back to 
// THREAD_PRIORITY_NORMAL.  This function is the helper to do this.
//
BOOL
SetProgressThreadPriority(
    IProgressDialog *pDlg,
    int iPriority,
    int *piPrevPriority
    )
{
    BOOL bResult = FALSE;
    //
    // Get the thread handle for the progress dialog.
    //
    const DWORD dwThreadId = GetWindowThreadProcessId(GetProgressDialogWindow(pDlg), NULL);
    const HANDLE hThread   = OpenThread(THREAD_SET_INFORMATION, FALSE, dwThreadId);
    if (NULL != hThread)
    {
        //
        // Set the thread's priority.  Return the previous thread
        // priority if the caller requests it.
        //
        const int iPrevPriority = GetThreadPriority(hThread);
        if (SetThreadPriority(hThread, iPriority))
        {
            if (NULL != piPrevPriority)
            {
                *piPrevPriority = iPrevPriority;
            }
            bResult = TRUE;
        }
        CloseHandle(hThread);
    }
    return bResult;
}



//
// Handler for Encryption CSCPROC_REASON_BEGIN
//
DWORD
EncryptDecrypt_BeginHandler(
    const CSC_CALLBACK_DATA& cbd,
    bool bEncrypting
    )
{
    //
    // Nothing to do on "begin".
    //
    return CSCPROC_RETURN_CONTINUE;
}


//
// Handler for Encryption CSCPROC_REASON_MORE_DATA
//
// Returns:
//       CSCPROC_RETURN_CONTINUE == Success.  Continue!
//       CSCPROC_RETURN_ABORT    == User cancelled.
//       CSCPROC_RETURN_RETRY    == An error occured and user says "retry".
//
DWORD
EncryptDecrypt_MoreDataHandler(
    const CSC_CALLBACK_DATA& cbd,
    bool bEncrypting
    ) 
{
    const TCHAR szNull[]               = TEXT("");
    const DWORD dwError                = cbd.dwParam2;
    ENCRYPT_PROGRESS_INFO * const pepi = (ENCRYPT_PROGRESS_INFO *)cbd.dwContext;
    DWORD dwResult                     = CSCPROC_RETURN_CONTINUE;
    LPCTSTR pszName                    = cbd.lpszName ? cbd.lpszName : szNull;

    //
    // Update the progress UI with the file name and % processed.
    //
    pepi->pDlg->SetLine(2, pszName, TRUE, NULL);
    pepi->pDlg->SetProgress(++(pepi->cFilesProcessed), pepi->cFilesTotal);
    //
    // Handle any errors.
    //
    if (ERROR_SUCCESS != dwError)
    {
        //
        // The formatting of this message is as follows (encryption version shown):
        //
        // -----------------------------------------------------
        // Offline Files
        // -----------------------------------------------------
        //
        //      Error encrypting offline copy of 'filename'.
        //
        //      < error description >
        //
        //                          [Cancel][Try Again][Continue]
        //
        //
        TCHAR szPath[MAX_PATH];
        ::PathCompactPathEx(szPath, pszName, 50, 0);  // Compact to 50 chars max.

        LPTSTR pszError;
        if (0 < FormatSystemError(&pszError, dwError))
        {
            INT iResponse;
            if (ERROR_SHARING_VIOLATION == dwError)
            {
                //
                // "File is open" is so common we special-case it to provide a bit more
                // instruction to the user.
                //
                iResponse = CscMessageBox(ParentWindowFromProgressInfo(*pepi),
                                          MB_ICONWARNING | MB_CANCELTRYCONTINUE,
                                          pepi->hInstance,
                                          bEncrypting ? IDS_ERR_FMT_ENCRYPTFILE_INUSE : IDS_ERR_FMT_DECRYPTFILE_INUSE,
                                          szPath);
            }
            else
            {
                //
                // Handle all other errors.  This embeds the error text from winerror
                // into the message.
                //
                iResponse = CscMessageBox(ParentWindowFromProgressInfo(*pepi),
                                          MB_ICONWARNING | MB_CANCELTRYCONTINUE,
                                          pepi->hInstance,
                                          bEncrypting ? IDS_ERR_FMT_ENCRYPTFILE : IDS_ERR_FMT_DECRYPTFILE,
                                          szPath,
                                          pszError);
            }
            LocalFree(pszError);
            switch(iResponse)
            {
                case IDCANCEL:
                    dwResult = CSCPROC_RETURN_ABORT;
                    break;

                case IDTRYAGAIN:
                    //
                    // Take one file away from the progress total.
                    //
                    pepi->cFilesProcessed--;
                    dwResult = CSCPROC_RETURN_RETRY;
                    break;

                case IDCONTINUE:
                    //
                    // Fall through...
                    //
                default:
                    //
                    // Continue processing.
                    //
                    break;
            }
        }
    }
    return dwResult;
}



//
// Handler for Encryption CSCPROC_REASON_END
//
// Returns:
//       CSCPROC_RETURN_CONTINUE
//
DWORD
EncryptDecrypt_EndHandler(
    const CSC_CALLBACK_DATA& cbd,
    bool bEncrypting
    )
{
    const DWORD fCompleted             = cbd.dwParam1;
    const DWORD dwError                = cbd.dwParam2;
    ENCRYPT_PROGRESS_INFO * const pepi = (ENCRYPT_PROGRESS_INFO *)cbd.dwContext;

    //
    // Advance progress to 100% and stop progress dialog.
    //
    pepi->pDlg->SetProgress(pepi->cFilesTotal, pepi->cFilesTotal);
    pepi->pDlg->StopProgressDialog();
    //
    // Handle any errors.
    //
    if (!fCompleted)
    {
        //
        // CSC says it did not complete the encryption/decryption process
        // without errors.
        //
        if (ERROR_SUCCESS != dwError)
        {
            //
            // This path is taken if some error occured outside of the
            // file-processing code (i.e. opening the CSC database,
            // recording encryption state flags in the database etc).
            //
            // -----------------------------------------------------
            // Offline Files
            // -----------------------------------------------------
            //
            //      Error encrypting offline files.
            //
            //      < error-specific text >
            //                                         [OK]
            //
            // Note that we're at the end of the operation so there's no 
            // reason to offer "Cancel" as a user choice.
            //
            LPTSTR pszError;
            if (0 < FormatSystemError(&pszError, dwError))
            {
                CscMessageBox(ParentWindowFromProgressInfo(*pepi),
                              MB_ICONERROR | MB_OK,
                              pepi->hInstance,
                              bEncrypting ? IDS_ERR_FMT_ENCRYPTCSC : IDS_ERR_FMT_DECRYPTCSC,
                              pszError);
                LocalFree(pszError);
            }
        }
        else
        {
            //
            // This path is taken if one or more errors were reported 
            // in the "more data" callback.  In this case the error was
            // already reported so we do nothing.
            //
        }
    }
    return CSCPROC_RETURN_CONTINUE; // Note: CSC ignores return value on CSCPROC_REASON_END.
}



//
// Encryption/Decryption callback from CSC.
//
//  dwReason                  dwParam1           dwParam2
//  ------------------------- ------------------ --------------------------
//  CSCPROC_REASON_BEGIN      1 == Encrypting    0
//  CSCPROC_REASON_MORE_DATA  0                  Win32 error code
//  CSCPROC_REASON_END        1 == Completed     dwParam1 == 1 ? 0
//                                               dwParam1 == 0 ? GetLastError()
//
DWORD CALLBACK
COfflineFilesPage::EncryptDecryptCallback(
    LPCWSTR lpszName,
    DWORD dwStatus,
    DWORD dwHintFlags,
    DWORD dwPinCount,
    WIN32_FIND_DATAW *pFind32,
    DWORD dwReason,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD_PTR dwContext
    )
{
    static bool bEncrypting;
    ENCRYPT_PROGRESS_INFO * const pepi = (ENCRYPT_PROGRESS_INFO *)dwContext;

    if (pepi->bUserCancelled)
    {
        //
        // If user has already cancelled on a previous callback
        // there's no reason to process this callback.  Just return
        // "abort" to CSC.
        //
        return CSCPROC_RETURN_ABORT;
    }

    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    //
    // Package callback data into a struct we can pass to the 
    // handler functions.  Yeah, it's a bit more expensive but 
    // handling the various "reasons" in separate functions sure makes
    // for cleaner code than if they're all handled in a big switch
    // statement.
    //
    CSC_CALLBACK_DATA cbd;
    cbd.lpszName  = lpszName;
    cbd.dwReason  = dwReason;
    cbd.dwParam1  = dwParam1;
    cbd.dwParam2  = dwParam2;
    cbd.dwContext = dwContext;

    //
    // Call the appropriate callback reason handler.
    //
    switch(dwReason)
    {
        case CSCPROC_REASON_BEGIN:
            bEncrypting = boolify(dwParam1);
            dwResult = EncryptDecrypt_BeginHandler(cbd, bEncrypting);
            break;

        case CSCPROC_REASON_MORE_DATA:
            dwResult = EncryptDecrypt_MoreDataHandler(cbd, bEncrypting);
            break;
    
        case CSCPROC_REASON_END:
            dwResult = EncryptDecrypt_EndHandler(cbd, bEncrypting);
            break;

        default:
            break;
    }
    //
    // Detect if user has cancelled the operation in response to 
    // an error message or directly in the progress dialog.
    //
    if (CSCPROC_RETURN_ABORT == dwResult || (!pepi->bUserCancelled && pepi->pDlg->HasUserCancelled()))
    {
        pepi->bUserCancelled = true;
        dwResult             = CSCPROC_RETURN_ABORT;
    }

    if (pepi->bUserCancelled && pepi->bPropSheetClosing)
    {
        //
        // Only display this cautionary message if the user has
        // clicked the "OK" button.  If they clicked "Apply" the prop sheet
        // remains active and we'll display the encryption warning tooltip
        // balloon on the page itself.  If they clicked "OK" the prop sheet
        // is going away so the tooltip will not be presented to the user.
        // Either way we need to let the user know that cancelling 
        // encryption or decryption leaves the cache in a partial state.
        //
        // -----------------------------------------------------
        // Offline Files
        // -----------------------------------------------------
        //
        //      Encryption of Offline Files is enabled but 
        //      not all files have been encrypted.
        //
        //
        const UINT ids   = bEncrypting ? IDS_ENCRYPTCSC_CANCELLED : IDS_DECRYPTCSC_CANCELLED;
        const UINT uType = MB_OK | (bEncrypting ? MB_ICONWARNING : MB_ICONINFORMATION);

        CscMessageBox(ParentWindowFromProgressInfo(*pepi),
                      uType,
                      pepi->hInstance,
                      ids);
    }
    return dwResult;
}



//
// Encrypt or Decrypt the cache.
//
void
COfflineFilesPage::EncryptOrDecryptCache(
    bool bEncrypt,
    bool bPropSheetClosing
    )
{
    HANDLE hMutex = RequestPermissionToEncryptCache();
    if (NULL != hMutex)
    {
        //
        // Excellent.  No one (i.e. policy) is trying to encrypt/decrypt
        // the cache.  We're in business.
        //
        CMutexAutoRelease mutex_auto_release(hMutex); // Ensure release of mutex.

        IProgressDialog *ppd;
        if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, 
                                       NULL, 
                                       CLSCTX_INPROC_SERVER, 
                                       IID_IProgressDialog, 
                                       (void **)&ppd)))
        {
            //
            // Set up the progress dialog using the standard "encrypt file"
            // animation.  The dialog is modal.
            //
            TCHAR szText[MAX_PATH];
            if (0 < LoadString(m_hInstance, IDS_APPLICATION, szText, ARRAYSIZE(szText)))
            {
                ppd->SetTitle(szText);
            }
            if (0 < LoadString(m_hInstance,
                               bEncrypt ? IDS_ENCRYPTING_DOTDOTDOT : IDS_DECRYPTING_DOTDOTDOT,
                               szText,
                               ARRAYSIZE(szText)))
            { 
                ppd->SetLine(1, szText, FALSE, NULL);
            }
            //
            // TODO:  [brianau - 3/8/00] Need special encrypting/decrypting AVI.
            //
            ppd->SetAnimation(m_hInstance, bEncrypt ? IDA_FILEENCR : IDA_FILEDECR);
            ppd->StartProgressDialog(m_hwndDlg, NULL, PROGDLG_NOTIME | PROGDLG_MODAL, NULL);
            //
            // Pass this info to the progress callback so we can display UI.
            //
            ENCRYPT_PROGRESS_INFO epi;
            epi.hInstance         = m_hInstance;
            epi.hwndParentDefault = m_hwndDlg;
            epi.pDlg              = ppd;
            epi.bUserCancelled    = false;
            epi.bPropSheetClosing = bPropSheetClosing;

            CSCSPACEUSAGEINFO sui;
            ZeroMemory(&sui, sizeof(sui));
            GetCscSpaceUsageInfo(&sui);

            epi.cFilesTotal     = sui.dwNumFilesInCache;
            epi.cFilesProcessed = 0;
            //
            // Boost the progress dialog thread's priority to "normal" priority class.
            // The progress dialog sets it's priority class to "below normal" so it
            // doesn't steal all of the CPU running the animation.  However, that also 
            // means that the progress dialog doesn't work so well when displaying progress
            // for a higher-priority compute-bound thread like encryption.
            //
            SetProgressThreadPriority(ppd, THREAD_PRIORITY_NORMAL, NULL);
            //
            // Encrypt/Decrypt the cache files.  Will provide progress info through
            // the callback EncryptDecryptCallback.  Errors are handled in the callback
            // reason handlers.
            //
            CSCEncryptDecryptDatabase(bEncrypt, EncryptDecryptCallback, (DWORD_PTR)&epi);
    
            ppd->StopProgressDialog();
            ppd->Release();
        }
    }
    else
    {
        //
        // Let the user know an encryption/decryption operation is already
        // in progress for system policy.
        //
        CscMessageBox(m_hwndDlg,
                      MB_ICONINFORMATION | MB_OK,
                      m_hInstance,
                      IDS_ENCRYPTCSC_INPROGFORPOLICY);
    }
    //
    // Make sure the encryption checkbox reflects the encryption state of 
    // the cache when we're done.  We don't do it if the prop sheet is closing
    // because that may flash the warning tooltip just as the sheet is going
    // away.  Looks bad.
    //
    if (!bPropSheetClosing)
    {
        UpdateEncryptionCheckbox();
        UpdateEncryptionTooltipBalloon();
    }
}



//
// Enables or disables CSC according to the bEnable arg.
//
// Returns:
//
//  TRUE   == Operation successful (reboot may be required).
//  FALSE  == Operation failed.  See *pdwError for cause.
//
//  *pbReboot indicates if a reboot is required.
//  *pdwError returns any error code.
// 
bool
COfflineFilesPage::EnableOrDisableCsc(
    bool bEnable,
    bool *pbReboot,
    DWORD *pdwError
    )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // We'll assume no reboot required.
    //
    if (NULL != pbReboot)
        *pbReboot = false;

    if (!CSCDoEnableDisable(bEnable))
    {
        //
        // Tried to enable or disable but failed.
        // If enabling, it's just a failure and we return.
        // If disabling, it may have failed because there are open files.
        //
        dwError = GetLastError();
        if (!bEnable && ERROR_BUSY == dwError)
        {
            //
            // Failed to disable and there are open files.
            // Tell the user to close all open files then try again.
            //
            CscMessageBox(m_hwndDlg,
                          MB_ICONINFORMATION | MB_OK,
                          m_hInstance,
                          IDS_OPENFILESONDISABLE);

            if (!CSCDoEnableDisable(bEnable))
            {
                dwError = GetLastError();
                if (ERROR_BUSY == dwError)
                {
                    //
                    // Still can't disable CSC because there are open files.
                    // This means we'll have to reboot.
                    //
                    if (NULL != pbReboot)
                        *pbReboot = true;
                }
            }
        }
    }
    //
    // Return error code to caller.
    //
    if (NULL != pdwError)
        *pdwError = dwError;

    return ERROR_SUCCESS == dwError || ERROR_BUSY == dwError;
}


//
// UI info passed to PurgeCache then returned to PurgeCacheCallback.
//
struct PROGRESS_UI_INFO
{
    HINSTANCE hInstance;     // Module containing UI text strings.
    HWND hwndParent;         // Parent window for error dialog.
    IProgressDialog *pDlg;   // Progress dialog.
};


//
// This callback updates the progress UI for deleting cached items.
// 
//
BOOL
COfflineFilesPage::PurgeCacheCallback(
    CCachePurger *pPurger
    )
{
    BOOL bContinue = TRUE;
    PROGRESS_UI_INFO *ppui = (PROGRESS_UI_INFO *)pPurger->CallbackData();
    IProgressDialog *pDlg  = ppui->pDlg;

    const DWORD dwPhase = pPurger->Phase();

    //
    // Adjust dialog appearance at start of each phase.
    //
    if (0 == pPurger->FileOrdinal())
    {
        TCHAR szText[MAX_PATH];
        if (0 < LoadString(ppui->hInstance, 
                           PURGE_PHASE_SCAN == dwPhase ? IDS_SCANNING_DOTDOTDOT : IDS_DELETING_DOTDOTDOT,
                           szText,
                           ARRAYSIZE(szText)))
        {
            pDlg->SetLine(2, szText, FALSE, NULL);
        }
        //
        // We don't start registering progress until the "delete" phase.
        // To keep this code simple we just set the progress bar at 0% at the beginning
        // of each phase.  This way it will be 0% throughout the scanning phase and then
        // during the delete phase we'll increment it.  The scanning phase is very fast.
        //
        pDlg->SetProgress(0, 100);
    }

    if (PURGE_PHASE_SCAN == dwPhase)
    {
        //
        // Do nothing.  We've already set the "Scanning..." text above at the
        // start of the phase.
        //
    }
    else if (PURGE_PHASE_DELETE == dwPhase)
    {
        DWORD dwResult = pPurger->FileDeleteResult();
        //
        // Divide each value by 1,000 so that our numbers aren't so large.  This
        // means that if you're deleting less than 1,000 bytes of files, progress won't register.
        // I don't think that's a very likely scenario.  The DWORD() casts are required because
        // IProgressDialog::SetProgress only accepts DWORDs.  Dividing by 1,000 makes the 
        // likelihood of DWORD overflow very low.  To overflow the DWORD you'd need to be deleting
        // 4.294 e12 bytes from the cache.  The current limit on cache size is 4GB so that's
        // not going to happen in Win2000.
        //
        pDlg->SetProgress(DWORD(pPurger->BytesDeleted() / 1000), DWORD(pPurger->BytesToDelete() / 1000));
        if (ERROR_SUCCESS != dwResult)
        {
            //
            // The purger won't call us for directory entries.  Only files.
            //
            INT iUserResponse = IDOK;
            if (ERROR_BUSY == dwResult)
            {
                //
                // Special case for ERROR_BUSY.  This means that the
                // file is currently open for use by some process.
                // Most likely the network redirector.  I don't like the
                // standard text for ERROR_BUSY from winerror.
                //
                iUserResponse = CscMessageBox(ppui->hwndParent,
                                              MB_OKCANCEL | MB_ICONERROR,
                                              ppui->hInstance,
                                              IDS_FMT_ERR_DELFROMCACHE_BUSY,
                                              pPurger->FileName());
            }
            else
            {
                iUserResponse = CscMessageBox(ppui->hwndParent,
                                              MB_OKCANCEL | MB_ICONERROR,
                                              Win32Error(dwResult),
                                              ppui->hInstance,
                                              IDS_FMT_ERR_DELFROMCACHE,
                                              pPurger->FileName());
            }
            if (IDCANCEL == iUserResponse)
            {
                bContinue = FALSE;  // User cancelled through error dialog.
            }
        }
    }
    if (pDlg->HasUserCancelled())
        bContinue = FALSE;   // User cancelled through progress dialog.

    return bContinue;
}

//
// This feature has been included for use by PSS when there's no other
// way of fixing CSC operation.  Note this is only a last resort.
// It will wipe out all the contents of the CSC cache including the 
// notion of which files are pinned.  It does not affect any files
// on the network.  It does require a system reboot.  Again, use only
// as a last resort when CSC cache corruption is suspected.
//
void
COfflineFilesPage::OnFormatCache(
    void
    )
{
    if (IDYES == CscMessageBox(m_hwndDlg, 
                               MB_YESNO | MB_ICONWARNING,
                               m_hInstance,
                               IDS_REFORMAT_CACHE))
    {
        HKEY hkey;
        DWORD dwDisposition;
        DWORD dwResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        REGSTR_KEY_OFFLINEFILES,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkey,
                                        &dwDisposition);
        if (ERROR_SUCCESS == dwResult)
        {
            DWORD dwValue = 1;
            dwResult = RegSetValueEx(hkey,
                                     REGSTR_VAL_FORMATCSCDB,
                                     0,
                                     REG_DWORD,
                                     (CONST BYTE *)&dwValue,
                                     sizeof(dwValue));
                                     
            if (ERROR_SUCCESS == dwResult)                                     
            {
                //
                // Tell prop sheet to return ID_PSREBOOTSYSTEM from PropertySheet().
                // Caller of PropertySheet is responsible for prompting user if they
                // want to reboot now or not.
                //
                PropSheet_RebootSystem(GetParent(m_hwndDlg));
            }
            RegCloseKey(hkey);
            if (ERROR_SUCCESS != dwResult)
            {
                Trace((TEXT("Format failed with error %d"), dwResult));
                CscWin32Message(m_hwndDlg, dwResult, CSCUI::SEV_ERROR);
            }
        }
    }
}        


//
// Invoked when user selects "Delete Files..." button in the CSC
// options dialog.
//
void
COfflineFilesPage::OnDeleteCache(
    void
    )
{
    //
    // Ask the user if they want to delete only temporary files
    // from the cache or both temp and pinned files.  Also gives
    // them an opportunity to cancel before beginning the deletion
    // operation.
    //
    CCachePurgerSel sel;
    CCachePurger::AskUserWhatToPurge(m_hwndDlg, &sel);
    if (PURGE_FLAG_NONE != sel.Flags())
    {
        CCoInit coinit;
        if (SUCCEEDED(coinit.Result()))
        {
            //
            // Use the shell's standard progress dialog.
            //
            IProgressDialog *ppd;
            if (SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, 
                                           NULL, 
                                           CLSCTX_INPROC_SERVER, 
                                           IID_IProgressDialog, 
                                           (void **)&ppd)))
            {
                //
                // Set up the progress dialog using the standard shell "file delete"
                // animation (the one without the recycle bin).  The dialog
                // is modal.
                //
                TCHAR szText[MAX_PATH];
                if (0 < LoadString(m_hInstance, IDS_APPLICATION, szText, ARRAYSIZE(szText)))
                {
                    ppd->SetTitle(szText);
                }
                ppd->SetAnimation(m_hInstance, IDA_FILEDEL);
                ppd->StartProgressDialog(m_hwndDlg, NULL, PROGDLG_AUTOTIME | PROGDLG_MODAL, NULL);
                //
                // Pass this info to the progress callback so we can display UI.
                //
                PROGRESS_UI_INFO pui;
                pui.hInstance  = m_hInstance;
                pui.hwndParent = m_hwndDlg;
                pui.pDlg       = ppd;
                //
                // Purge the cache files.  Will provide progress info through
                // the callback PurgeCacheCallback.
                //
                CCachePurger purger(sel, PurgeCacheCallback, &pui);
                purger.Scan();
                purger.Delete();

                ppd->StopProgressDialog();
                //
                // Display message to user.
                // "Deleted 10 files (2.5 MB)."
                //
                FileSize fs(purger.BytesDeleted());
                fs.GetString(szText, ARRAYSIZE(szText));

                if (0 < purger.FilesDeleted())
                {
                    CscMessageBox(m_hwndDlg, 
                                  MB_OK | MB_ICONINFORMATION,
                                  m_hInstance,
                                  1 == purger.FilesDeleted() ? IDS_FMT_DELCACHE_FILEDELETED :
                                                               IDS_FMT_DELCACHE_FILESDELETED,
                                  purger.FilesDeleted(),
                                  szText);
                }
                else
                {
                    CscMessageBox(m_hwndDlg, 
                                  MB_OK | MB_ICONINFORMATION,
                                  m_hInstance,
                                  IDS_DELCACHE_NOFILESDELETED);
                }
                ppd->Release();
            }
        }
    }
}


//
// Determine if there's a shortcut to the offline files folder
// on the desktop.
// 
bool
COfflineFilesPage::IsLinkOnDesktop(
    LPTSTR pszPathOut,
    UINT cchPathOut
    )
{
    return S_OK == COfflineFilesFolder::IsLinkOnDesktop(m_hwndDlg, pszPathOut, cchPathOut);
}



//
// This function checks to see if CSC is compatible with Windows Terminal
// Server.  If it is not, it hides all of the dialog's normal controls
// and replaces them with a block of text explaining the current mode
// of Terminal Server and that the user needs to reconfigure Terminal
// Server in order to use CSC.
//
// Returns:
//    true -    Dialog controls have been disabled.
//    false -   Dialog controls not disabled.  CSC is compatible with TS mode.
//
bool
COfflineFilesPage::DisableForTerminalServer(
    void
    )
{
    bool bDisabled = false;
    DWORD dwTsMode;
    HRESULT hr = CSCUIIsTerminalServerCompatibleWithCSC(&dwTsMode);
    if (S_FALSE == hr)
    {
        RECT rcCbxEnable;
        RECT rcBtnAdvanced;
        RECT rcDlg;
        RECT rcText;
        //
        // Base the size and position of the text rectangle off
        // of existing controls in the dialog.
        //
        // ISSUE-2001/1/22-brianau   Any bi-di issues here?
        //
        GetWindowRect(GetDlgItem(m_hwndDlg, IDC_CBX_ENABLE_CSC), &rcCbxEnable);
        GetWindowRect(GetDlgItem(m_hwndDlg, IDC_BTN_ADVANCED), &rcBtnAdvanced);
        GetWindowRect(m_hwndDlg, &rcDlg);

        rcText.left   = rcCbxEnable.left - rcDlg.left;
        rcText.top    = rcCbxEnable.top - rcDlg.top;
        rcText.right  = rcBtnAdvanced.right - rcDlg.left;
        rcText.bottom = rcBtnAdvanced.bottom - rcDlg.top;

        //
        // Create a static text control for the text block.
        //
        HWND hwndText = CreateWindow(TEXT("static"),
                                     TEXT(""),
                                     WS_CHILD | WS_VISIBLE,
                                     rcText.left,
                                     rcText.top,
                                     rcText.right - rcText.left,
                                     rcText.bottom - rcText.top,
                                     m_hwndDlg,
                                     NULL,
                                     NULL,
                                     NULL);
        if (NULL != hwndText)
        {
            //
            // Load and display the text explaining what the user needs
            // to do to enable CSC.
            //
            LPTSTR pszText;
            if (SUCCEEDED(TS_GetIncompatibilityReasonText(dwTsMode, &pszText)))
            {
                HFONT hFont = (HFONT)SendMessage(m_hwndDlg, WM_GETFONT, 0, 0);
                SendMessage(hwndText, WM_SETFONT, (WPARAM)hFont, FALSE);

                SetWindowText(hwndText, pszText);
                LocalFree(pszText);
            }
            //
            // Hide all of the controls on the page.
            //
            static const UINT rgCtls[] = {
                IDC_CBX_FULLSYNC_AT_LOGOFF,
                IDC_CBX_FULLSYNC_AT_LOGON,
                IDC_CBX_REMINDERS,
                IDC_CBX_LINK_ON_DESKTOP,
                IDC_CBX_ENCRYPT_CSC,
                IDC_TXT_CACHESIZE_PCT,
                IDC_SLIDER_CACHESIZE_PCT,
                IDC_LBL_CACHESIZE_PCT,
                IDC_BTN_VIEW_CACHE,
                IDC_BTN_ADVANCED,
                IDC_BTN_DELETE_CACHE,
                IDC_TXT_REMINDERS1,
                IDC_EDIT_REMINDERS,
                IDC_SPIN_REMINDERS,
                IDC_CBX_ENABLE_CSC
                };

            for (int iCtl = 0; iCtl < ARRAYSIZE(rgCtls); iCtl++)
            {
                ShowWindow(GetDlgItem(m_hwndDlg, rgCtls[iCtl]), SW_HIDE);
            }
        }
        bDisabled = true;
    }
    return bDisabled;
}




//-----------------------------------------------------------------------------
// CAdvOptDlg
//-----------------------------------------------------------------------------
const CAdvOptDlg::CtlActions CAdvOptDlg::m_rgCtlActions[CConfig::eNumOfflineActions] = {
    { IDC_RBN_GOOFFLINE_SILENT, CConfig::eGoOfflineSilent },
    { IDC_RBN_GOOFFLINE_FAIL,   CConfig::eGoOfflineFail   }
                };


const DWORD CAdvOptDlg::m_rgHelpIDs[] = {
    IDOK,                           IDH_OK,
    IDCANCEL,                       IDH_CANCEL,
    IDC_RBN_GOOFFLINE_SILENT,       HIDC_RBN_GOOFFLINE_SILENT,
    IDC_RBN_GOOFFLINE_FAIL,         HIDC_RBN_GOOFFLINE_FAIL,
    IDC_GRP_CUSTGOOFFLINE,          HIDC_LV_CUSTGOOFFLINE,
    IDC_LV_CUSTGOOFFLINE,           HIDC_LV_CUSTGOOFFLINE,
    IDC_BTN_ADD_CUSTGOOFFLINE,      HIDC_BTN_ADD_CUSTGOOFFLINE,
    IDC_BTN_EDIT_CUSTGOOFFLINE,     HIDC_BTN_EDIT_CUSTGOOFFLINE,
    IDC_BTN_DELETE_CUSTGOOFFLINE,   HIDC_BTN_DELETE_CUSTGOOFFLINE,
    IDC_STATIC2,                    DWORD(-1),                    // Icon
    IDC_STATIC3,                    DWORD(-1),                    // Icon's text
    IDC_STATIC4,                    DWORD(-1),                    // Grp box #1
    0, 0
    };


int
CAdvOptDlg::Run(
    void
    )
{
    int iResult = (int)DialogBoxParam(m_hInstance,
                                      MAKEINTRESOURCE(IDD_CSC_ADVOPTIONS),
                                      m_hwndParent,
                                      DlgProc,
                                      (LPARAM)this);

    if (-1 == iResult || 0 == iResult)
    {
        Trace((TEXT("Error %d creating CSC advanced options dialog"),
                 GetLastError()));
    }
    return iResult;
}


INT_PTR CALLBACK
CAdvOptDlg::DlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    CAdvOptDlg *pThis = (CAdvOptDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
        {
            pThis = reinterpret_cast<CAdvOptDlg *>(lParam);
            SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);
            bResult = pThis->OnInitDialog(hDlg, (HWND)wParam, lParam);
            break;
        }

        case WM_NOTIFY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnNotify(hDlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_COMMAND:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnHelp(hDlg, (LPHELPINFO)lParam);
            break;

        case WM_CONTEXTMENU:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnContextMenu(wParam, lParam);
            break;

        case WM_DESTROY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnDestroy(hDlg);
            break;

        default:
            break;
    }

    return bResult;
}


BOOL
CAdvOptDlg::OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lInitParam
    )
{
    CConfig& config = CConfig::GetSingleton();

    m_hwndDlg = hwnd;
    m_hwndLV  = GetDlgItem(hwnd, IDC_LV_CUSTGOOFFLINE);

    CreateListColumns(m_hwndLV);
    ListView_SetExtendedListViewStyle(m_hwndLV, LVS_EX_FULLROWSELECT);

    //
    // Set the default go-offline action radio buttons.
    //
    CConfig::OfflineAction action = (CConfig::OfflineAction)config.GoOfflineAction(&m_bNoConfigGoOfflineAction);
    for (int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        CheckDlgButton(hwnd, 
                       m_rgCtlActions[i].idRbn, 
                       m_rgCtlActions[i].action == action ? BST_CHECKED : BST_UNCHECKED);
    }
    //
    // Fill the custom go-offline actions listview.
    //
    HDPA hdpaCustomGOA = DPA_Create(4);
    if (NULL != hdpaCustomGOA)
    {
        config.GetCustomGoOfflineActions(hdpaCustomGOA);

        const int cGOA = DPA_GetPtrCount(hdpaCustomGOA);
        for (i = 0; i < cGOA; i++)
        {
            CConfig::CustomGOA *pGOA = (CConfig::CustomGOA *)DPA_GetPtr(hdpaCustomGOA, i);
            if (NULL != pGOA)
            {
                AddGOAToListView(m_hwndLV, i, *pGOA);
            }
        }
        CConfig::ClearCustomGoOfflineActions(hdpaCustomGOA);
        DPA_Destroy(hdpaCustomGOA);
    }


    //
    // Adjust "enabledness" of controls for system policy.
    //
    EnableCtls(m_hwndDlg);
    //
    // Remember the initial page state so we can intelligently apply changes.
    //
    GetPageState(&m_state);

    return TRUE;
}



BOOL
CAdvOptDlg::OnHelp(
    HWND hDlg, 
    LPHELPINFO pHelpInfo
    )
{
    if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
        int idCtl = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);
        WinHelp((HWND)pHelpInfo->hItemHandle, 
                 UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
                 HELP_WM_HELP, 
                 (DWORD_PTR)((LPTSTR)m_rgHelpIDs));
    }

    return TRUE;
}


void
CAdvOptDlg::CreateListColumns(
    HWND hwndList
    )
{
    //
    // Create the header titles.
    //
    TCHAR szServer[40] = {0};
    TCHAR szAction[40] = {0};

    LoadString(m_hInstance, IDS_TITLE_COL_SERVER, szServer, ARRAYSIZE(szServer));
    LoadString(m_hInstance, IDS_TITLE_COL_ACTION, szAction, ARRAYSIZE(szAction));

    RECT rcList;
    GetClientRect(hwndList, &rcList);
    int cxList = rcList.right - rcList.left - GetSystemMetrics(SM_CXVSCROLL);

#define LVCOLMASK (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM)

    LV_COLUMN rgCols[] = { 
         { LVCOLMASK, LVCFMT_LEFT, (2 * cxList)/3, szServer, 0, iLVSUBITEM_SERVER },
         { LVCOLMASK, LVCFMT_LEFT, (1 * cxList)/3, szAction, 0, iLVSUBITEM_ACTION }
                         };
    //
    // Add the columns to the listview.
    //
    for (INT i = 0; i < ARRAYSIZE(rgCols); i++)
    {
        if (-1 == ListView_InsertColumn(hwndList, i, &rgCols[i]))
        {
            Trace((TEXT("CAdvOptDlg::CreateListColumns failed to add column %d"), i));
        }
    }
}


int
CAdvOptDlg::GetFirstSelectedLVItemRect(
    RECT *prc
    )
{
    int iSel = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);
    if (-1 != iSel)
    {
        if (ListView_GetItemRect(m_hwndLV, iSel, prc, LVIR_SELECTBOUNDS))
        {
            ClientToScreen(m_hwndLV, (LPPOINT)&prc->left);
            ClientToScreen(m_hwndLV, (LPPOINT)&prc->right);
            return iSel;
        }
    }
    return -1;
}



BOOL
CAdvOptDlg::OnContextMenu(
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndItem = (HWND)wParam;
    INT xPos = -1;
    INT yPos = -1;
    INT iHit = -1;
    BOOL bResult = FALSE;

    if (-1 == lParam)
    {
        //
        // Not invoked with mouse click.  Probably Shift F10.
        // Pretend mouse was clicked in center of first selected item.
        //
        RECT rc;
        iHit = GetFirstSelectedLVItemRect(&rc);
        if (-1 != iHit)
        {
            xPos = rc.left + ((rc.right - rc.left) / 2);
            yPos = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }
    else
    {
        //
        // Invoked with mouse click.  Now find out if a LV item was
        // selected directly.
        //
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);

        LVHITTESTINFO hti;
        hti.pt.x  = xPos;
        hti.pt.y  = yPos;
        hti.flags = LVHT_ONITEM;
        ScreenToClient(m_hwndLV, &hti.pt);
        iHit = (INT)SendMessage(m_hwndLV, LVM_HITTEST, 0, (LPARAM)&hti);
    }
    if (-1 == iHit)
    {
        //
        // LV item not selected directly or Shift-F10 was not pressed.
        // Display "what's this" help for the listview control.
        //
        WinHelp(hwndItem, 
                UseWindowsHelp(GetDlgCtrlID(hwndItem)) ? NULL : c_szHelpFile,
                HELP_CONTEXTMENU, 
                (DWORD_PTR)((LPTSTR)m_rgHelpIDs));
    }
    else
    {
        //
        // LV item selected directly or Shift F10 pressed.  Display context menu for item.
        // 
        if (0 < ListView_GetSelectedCount(m_hwndLV) && IsCustomActionListviewEnabled())
        {
            HMENU hMenu = LoadMenu(m_hInstance, MAKEINTRESOURCE(IDR_ADVOPTIONS_CONTEXTMENU));
            if (NULL != hMenu)
            {
                HMENU hmenuTrackPopup = GetSubMenu(hMenu, 0);
                int cSetByPolicy = 0;
                CountSelectedListviewItems(&cSetByPolicy);
                if (0 < cSetByPolicy)
                {
                    //
                    // Disable menu items if any item in selection was set by policy.
                    //
                    int cItems = GetMenuItemCount(hmenuTrackPopup);
                    for (int i = 0; i < cItems; i++)
                    {
                        EnableMenuItem(hmenuTrackPopup, i, MF_GRAYED | MF_BYPOSITION);
                    }
                }
                else
                {
                    //
                    // Build a mask indicating which actions are present in the selected
                    // listview items.
                    //
                    int iItem = -1;
                    const DWORD fSilent = 0x00000001;
                    const DWORD fFail   = 0x00000002;
                    DWORD fActions = 0;
                    CConfig::CustomGOA *pGOA = NULL;
                    while(-1 != (iItem = ListView_GetNextItem(m_hwndLV, iItem, LVNI_SELECTED)))
                    {
                        pGOA = GetListviewObject(m_hwndLV, iItem);
                        if (NULL != pGOA)
                        {
                            TraceAssert(!pGOA->SetByPolicy());
                            switch(pGOA->GetAction())
                            {
                                case CConfig::eGoOfflineSilent: fActions |= fSilent; break;
                                case CConfig::eGoOfflineFail:   fActions |= fFail;   break;
                                default: break;
                            }
                        }
                    }
                    //
                    // Calculate how many bits are set in the action mask.
                    // If there's only one action set, we check that item in the menu.
                    // Otherwise, we leave them all unchecked to indicate a heterogeneous
                    // set.
                    //
                    int c = 0; // Count of bits set.
                    DWORD dw = fActions;
                    for (c = 0; 0 != dw; c++)
                        dw &= dw - 1;

                    //
                    // If the selection is homogeneous with respect to the action,
                    // check the menu item corresponding to the action.  Otherwise
                    // leave all items unchecked.
                    //
                    if (1 == c)
                    {
                        const struct
                        {
                            DWORD fMask;
                            UINT  idCmd;
                        } rgCmds[] = { { fSilent, IDM_ACTION_WORKOFFLINE },
                                       { fFail,   IDM_ACTION_FAIL        }
                                     };

                        for (int i = 0; i < ARRAYSIZE(rgCmds); i++)
                        {
                            if ((fActions & rgCmds[i].fMask) == rgCmds[i].fMask)
                            {
                                CheckMenuRadioItem(hmenuTrackPopup,
                                                   IDM_ACTION_WORKOFFLINE,
                                                   IDM_ACTION_FAIL,
                                                   rgCmds[i].idCmd,
                                                   MF_BYCOMMAND);
                                break;
                            }
                        }
                    }
                }

                TrackPopupMenu(hmenuTrackPopup,
                               TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                               xPos,
                               yPos,
                               0,
                               GetParent(hwndItem),
                               NULL);
            }
            DestroyMenu(hMenu);
        }
        bResult = TRUE;
    }
    return bResult;
}



//
// Return the offline action code associated with the currently-checked
// offline-action radio button.
//
CConfig::OfflineAction
CAdvOptDlg::GetCurrentGoOfflineAction(
    void
    ) const
{
    CConfig::OfflineAction action = CConfig::eNumOfflineActions;
    for (int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, m_rgCtlActions[i].idRbn))
        {
            action = m_rgCtlActions[i].action;
            break;
        }
    }
    TraceAssert(CConfig::eNumOfflineActions != action);
    return action;
}


BOOL
CAdvOptDlg::OnCommand(
    HWND hwnd,
    WORD wNotifyCode,
    WORD wID,
    HWND hwndCtl
    )
{
    BOOL bResult = TRUE;
    if (BN_CLICKED == wNotifyCode)
    {
        switch(wID)
        {
            case IDOK:
                ApplySettings();
                //
                // Fall through...
                //
            case IDCANCEL:
                EndDialog(hwnd, wID);
                break;

            case IDC_BTN_ADD_CUSTGOOFFLINE:
                OnAddCustomGoOfflineAction();
                bResult = FALSE;
                break;

            case IDC_BTN_EDIT_CUSTGOOFFLINE:
                OnEditCustomGoOfflineAction();
                bResult = FALSE;
                break;

            case IDC_BTN_DELETE_CUSTGOOFFLINE:
                OnDeleteCustomGoOfflineAction();
                FocusOnSomethingInListview();
                if (0 < ListView_GetItemCount(m_hwndLV))
                    SetFocus(GetDlgItem(hwnd, IDC_BTN_DELETE_CUSTGOOFFLINE));
                bResult = FALSE;
                break;

            case IDM_ACTION_WORKOFFLINE:
            case IDM_ACTION_FAIL:
            case IDM_ACTION_DELETE:
                OnContextMenuItemSelected(wID);
                break;

            default:
                break;
        }
    
    }
    return bResult;
}


void
CAdvOptDlg::ApplySettings(
    void
    )
{
    //
    // Now store changes from the "Advanced" dialog.
    //
    PgState s;
    GetPageState(&s);
    if (m_state != s)
    {
        HKEY hkeyCU;
        DWORD dwDisposition;
        DWORD dwResult = RegCreateKeyEx(HKEY_CURRENT_USER,
                                        REGSTR_KEY_OFFLINEFILES,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkeyCU,
                                        &dwDisposition);
        if (ERROR_SUCCESS == dwResult)
        {
            DWORD dwValue = DWORD(s.GetDefGoOfflineAction());
            dwResult = RegSetValueEx(hkeyCU,
                                     REGSTR_VAL_GOOFFLINEACTION,
                                     0,
                                     REG_DWORD,
                                     (CONST BYTE *)&dwValue,
                                     sizeof(dwValue));
                                     
            if (ERROR_SUCCESS != dwResult)
            {
                Trace((TEXT("Error %d setting reg value \"%s\""), dwResult, REGSTR_VAL_GOOFFLINEACTION));
            }

            //
            // Delete all existing contents from key before saving
            // current list of actions.
            //
            SHDeleteKey(hkeyCU, REGSTR_SUBKEY_CUSTOMGOOFFLINEACTIONS);
            
            HKEY hkeyCustom;
            dwResult = RegCreateKeyEx(hkeyCU,
                                      REGSTR_SUBKEY_CUSTOMGOOFFLINEACTIONS,
                                      0,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_WRITE,
                                      NULL,
                                      &hkeyCustom,
                                      &dwDisposition);
                                      
            if (ERROR_SUCCESS == dwResult)
            {
                HRESULT hr = CConfig::SaveCustomGoOfflineActions(hkeyCustom, 
                                                                 s.GetCustomGoOfflineActions());
                if (FAILED(hr))
                {
                    Trace((TEXT("Error 0x%08X setting custom offline actions"), hr));
                }
                RegCloseKey(hkeyCustom);
            }
            RegCloseKey(hkeyCU);
        }
        else
        {
            Trace((TEXT("Error %d opening advanced settings user key"), dwResult));
        }
    }
}



void
CAdvOptDlg::DeleteSelectedListviewItems(
    void
    )
{
    int iItem = -1;
    CConfig::CustomGOA *pGOA = NULL;
    CAutoSetRedraw autoredraw(m_hwndLV, false);
    while(-1 != (iItem = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED)))
    {
        pGOA = GetListviewObject(m_hwndLV, iItem);
        if (pGOA)
        {
            TraceAssert(!pGOA->SetByPolicy());
            ListView_DeleteItem(m_hwndLV, iItem);
            delete pGOA;
        }
    }
    //
    // If the list is empty, this will disable the "Delete" and
    // "Edit" buttons.
    //
    EnableCtls(m_hwndDlg);
}


void
CAdvOptDlg::SetSelectedListviewItemsAction(
    CConfig::OfflineAction action
    )
{
    int iItem = -1;
    CConfig::CustomGOA *pGOA = NULL;
    CAutoSetRedraw autoredraw(m_hwndLV, false);
    while(-1 != (iItem = ListView_GetNextItem(m_hwndLV, iItem, LVNI_SELECTED)))
    {
        pGOA = GetListviewObject(m_hwndLV, iItem);
        if (pGOA)
        {
            TraceAssert(!pGOA->SetByPolicy());
            pGOA->SetAction(action);
            ListView_RedrawItems(m_hwndLV, iItem, iItem);
        }
    }
}

int
CAdvOptDlg::CountSelectedListviewItems(
    int *pcSetByPolicy
    )
{
    TraceAssert(NULL != pcSetByPolicy);
    int iItem = -1;
    int cSelected = 0;
    CConfig::CustomGOA *pGOA = NULL;
    while(-1 != (iItem = ListView_GetNextItem(m_hwndLV, iItem, LVNI_SELECTED)))
    {
        cSelected++;
        pGOA = GetListviewObject(m_hwndLV, iItem);
        if (pGOA && pGOA->SetByPolicy())
           (*pcSetByPolicy)++;
    }
    return cSelected;
}


void
CAdvOptDlg::OnContextMenuItemSelected(
    int idMenuItem
    )
{
    if (IDM_ACTION_DELETE == idMenuItem)
    {
        DeleteSelectedListviewItems();
    }
    else
    {
        CConfig::OfflineAction action = CConfig::eNumOfflineActions;
        switch(idMenuItem)
        {
            case IDM_ACTION_WORKOFFLINE: action = CConfig::eGoOfflineSilent; break;
            case IDM_ACTION_FAIL:        action = CConfig::eGoOfflineFail;   break;
            default: break;
        }
        TraceAssert(CConfig::eNumOfflineActions != action);

        SetSelectedListviewItemsAction(action);
    }
}



//
// Responds to the user pressing the "Add..." button.
//
void
CAdvOptDlg::OnAddCustomGoOfflineAction(
    void
    )
{
    CConfig::OfflineAction action = GetCurrentGoOfflineAction();
    TCHAR szServer[MAX_PATH] = {0};
    bool bDone = false;
    while(!bDone)
    {
        //
        // Run the "Add custom go-offline action" dialog.
        // User enters a server name and selects an action
        // from a set of radio buttons.
        //
        CustomGOAAddDlg dlg(m_hInstance, m_hwndDlg, szServer, ARRAYSIZE(szServer), &action);
        int iResult = dlg.Run();

        if (IDCANCEL == iResult || TEXT('\0') == szServer[0])
        {
            //
            // User cancelled or didn't enter anything.
            //
            bDone = true;
        }
        else
        {
            //
            // User entered a server name.  Check if it's already in 
            // our list.
            //
            int iItem = -1;
            CConfig::CustomGOA *pObj = FindGOAInListView(m_hwndLV, szServer, &iItem);
            if (NULL != pObj)
            {
                //
                // Already an entry in list for this server.
                // If not set by policy, can replace it if desired.
                // If set by policy, can't change or delete it.
                //
                bool bSetByPolicy = pObj->SetByPolicy();
                DWORD idMsg   = bSetByPolicy ? IDS_ERR_GOOFFLINE_DUPACTION_NOCHG : IDS_ERR_GOOFFLINE_DUPACTION;
                DWORD dwFlags = bSetByPolicy ? MB_OK : MB_YESNO;
                if (IDYES == CscMessageBox(m_hwndDlg,
                                           dwFlags | MB_ICONWARNING,
                                           m_hInstance,
                                           idMsg,
                                           szServer))
                {
                    ReplaceCustomGoOfflineAction(pObj, iItem, action);
                    bDone = true;
                }
            }
            else
            {
                //
                // Server doesn't already exist in list.
                // Check if it's available on the net.
                //
                CAutoWaitCursor waitcursor;
                DWORD dwNetErr = CheckNetServer(szServer);
                switch(dwNetErr)
                {
                    case ERROR_SUCCESS:
                        //
                        // Server is available.  Add the entry to the listview.
                        //
                        AddCustomGoOfflineAction(szServer, action);
                        bDone = true;
                        break;

                    default:
                    {
                        LPTSTR pszNetMsg = NULL;
                        if (ERROR_EXTENDED_ERROR == dwNetErr)
                        {
                            const DWORD cchNetMsg = MAX_PATH;
                            pszNetMsg = (LPTSTR)LocalAlloc(LPTR, cchNetMsg * sizeof(*pszNetMsg));
                            if (NULL != pszNetMsg)
                            {
                                TCHAR szNetProvider[MAX_PATH];
                                WNetGetLastError(&dwNetErr,
                                                 pszNetMsg,
                                                 cchNetMsg,
                                                 szNetProvider,
                                                 ARRAYSIZE(szNetProvider));
                            }
                        }
                        else
                        {
                            FormatSystemError(&pszNetMsg, dwNetErr);
                        }
                        if (NULL != pszNetMsg)
                        {
                            //
                            // "The server 'servername' is either invalid
                            // or cannot be verified at this time.  Add anyway?"
                            // [Yes] [No] [Cancel].
                            //
                            switch(CscMessageBox(m_hwndDlg,
                                                 MB_YESNOCANCEL | MB_ICONWARNING,
                                                 m_hInstance,
                                                 IDS_ERR_INVALIDSERVER,
                                                 szServer,
                                                 pszNetMsg))
                            {
                                case IDYES:
                                    AddCustomGoOfflineAction(szServer, action);
                                    //
                                    // Fall through...
                                    //
                                case IDCANCEL:
                                    bDone = true;
                                    //
                                    // Fall through...
                                    //
                                case IDNO:
                                    break;
                            }
                            LocalFree(pszNetMsg);
                        }
                        break;
                    }
                }
            }
        }
    }
}


//
// Verify a server by going out to the net.
// Assumes pszServer points to a properly-formatted
// server name. (i.e. "Server" or "\\Server")
//
DWORD
CAdvOptDlg::CheckNetServer(
    LPCTSTR pszServer
    )
{
    TraceAssert(NULL != pszServer);

    TCHAR rgchResult[MAX_PATH];
    DWORD cbResult = sizeof(rgchResult);
    LPTSTR pszSystem = NULL;

    //
    // Ensure the server name has a preceding "\\" for the
    // call to WNetGetResourceInformation.
    //
    TCHAR szServer[MAX_PATH];
    while(*pszServer && TEXT('\\') == *pszServer)
        pszServer++;

    szServer[0] = TEXT('\\');
    szServer[1] = TEXT('\\');
    StringCchCopy(szServer+2, ARRAYSIZE(szServer)-2, pszServer);

    NETRESOURCE nr;
    nr.dwScope          = RESOURCE_GLOBALNET;
    nr.dwType           = RESOURCETYPE_ANY;
    nr.dwDisplayType    = 0;
    nr.dwUsage          = 0;
    nr.lpLocalName      = NULL;
    nr.lpRemoteName     = szServer;
    nr.lpComment        = NULL;
    nr.lpProvider       = NULL;

    return WNetGetResourceInformation(&nr, rgchResult, &cbResult, &pszSystem);
}


//
// Adds a CustomGOA object to the listview.
//
void
CAdvOptDlg::AddCustomGoOfflineAction(
    LPCTSTR pszServer,
    CConfig::OfflineAction action
    )
{
    AddGOAToListView(m_hwndLV, 0, CConfig::CustomGOA(pszServer, action, false));
}


//
// Replaces the action for an object in the listview.
//
void
CAdvOptDlg::ReplaceCustomGoOfflineAction(
    CConfig::CustomGOA *pGOA,
    int iItem,
    CConfig::OfflineAction action
    )
{
    pGOA->SetAction(action);
    ListView_RedrawItems(m_hwndLV, iItem, iItem);
}


//
// Create and add a CustomGOA object to the listview.
//
int
CAdvOptDlg::AddGOAToListView(
    HWND hwndLV, 
    int iItem, 
    const CConfig::CustomGOA& goa
    )
{
    int iItemResult = -1;
    CConfig::CustomGOA *pGOA = new CConfig::CustomGOA(goa);
    if (NULL != pGOA)
    {
        LVITEM item;
        item.iSubItem = 0;
        item.mask     = LVIF_PARAM | LVIF_TEXT;
        item.pszText  = LPSTR_TEXTCALLBACK;
        item.iItem    = -1 == iItem ? ListView_GetItemCount(hwndLV) : iItem;
        item.lParam   = (LPARAM)pGOA;
        iItemResult = ListView_InsertItem(hwndLV, &item);
        if (-1 == iItemResult)
        {
            delete pGOA;
        }
    }
    return iItemResult;
}


//
// Find the matching CustomGOA object in the listview for a given
// server.
//
CConfig::CustomGOA *
CAdvOptDlg::FindGOAInListView(
    HWND hwndLV,
    LPCTSTR pszServer,
    int *piItem
    )
{
    int cItems = ListView_GetItemCount(hwndLV);
    for (int iItem = 0; iItem < cItems; iItem++)
    {
        CConfig::CustomGOA *pObj = GetListviewObject(hwndLV, iItem);
        if (pObj)
        {
            if (0 == lstrcmpi(pObj->GetServerName(), pszServer))
            {
                if (piItem)
                    *piItem = iItem;
                return pObj;
            }
        }
    }
    return NULL;
}

            
void
CAdvOptDlg::OnEditCustomGoOfflineAction(
    void
    )
{
    int cSetByPolicy = 0;
    int cSelected = CountSelectedListviewItems(&cSetByPolicy);

    if (0 < cSelected && 0 == cSetByPolicy)
    {
        TraceAssert(0 == cSetByPolicy);
        CConfig::OfflineAction action = GetCurrentGoOfflineAction();
        TCHAR szServer[MAX_PATH] = {0};
        CConfig::CustomGOA *pGOA = NULL;
        int iItem = -1;
        //
        // At least one selected item wasn't set by policy.
        //
        if (1 == cSelected)
        {
            //
            // Only one item selected so we can display a server name
            // in the dialog and indicate it's currently-set action.
            //
            iItem  = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);
            pGOA   = GetListviewObject(m_hwndLV, iItem);
            if (pGOA)
            {
                action = pGOA->GetAction();
                pGOA->GetServerName(szServer, ARRAYSIZE(szServer));
            }
        }

        //
        // Display the "edit" dialog and let the user select a new action.
        //
        CustomGOAEditDlg dlg(m_hInstance, m_hwndDlg, szServer, &action);
        if (IDOK == dlg.Run())
        {
            SetSelectedListviewItemsAction(action);
        }
    }
}


void
CAdvOptDlg::OnDeleteCustomGoOfflineAction(
    void
    )
{
    int cSetByPolicy = 0;
    int cSelected = CountSelectedListviewItems(&cSetByPolicy);

    if (0 < cSelected)
    {
        DeleteSelectedListviewItems();
    }
}



BOOL 
CAdvOptDlg::OnNotify(
    HWND hDlg, 
    int idCtl, 
    LPNMHDR pnmhdr
    )
{
    BOOL bResult = TRUE;

    switch(pnmhdr->code)
    {
        case NM_SETFOCUS:
            if (IDC_LV_CUSTGOOFFLINE == idCtl)
                FocusOnSomethingInListview();
            break;

        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)pnmhdr);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)pnmhdr);
            break;

        case LVN_ITEMCHANGED:
            OnLVN_ItemChanged((NM_LISTVIEW *)pnmhdr);
            break;

        case LVN_ITEMACTIVATE:
            OnEditCustomGoOfflineAction();
            break;

        case LVN_KEYDOWN:
            OnLVN_KeyDown((NMLVKEYDOWN *)pnmhdr);
            break;
    }

    return bResult;
}



void
CAdvOptDlg::FocusOnSomethingInListview(
    void
    )
{
    //
    // Focus on something.
    //
    int iFocus = ListView_GetNextItem(m_hwndLV, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(m_hwndLV, iFocus, LVIS_FOCUSED | LVIS_SELECTED,
                                            LVIS_FOCUSED | LVIS_SELECTED);

}


int CALLBACK 
CAdvOptDlg::CompareLVItems(
    LPARAM lParam1, 
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    CAdvOptDlg *pdlg = reinterpret_cast<CAdvOptDlg *>(lParamSort);
    int diff = 0;

    CConfig::CustomGOA *pGOA1 = (CConfig::CustomGOA *)lParam1;
    CConfig::CustomGOA *pGOA2 = (CConfig::CustomGOA *)lParam2;
    TCHAR szText[2][MAX_PATH];

    //
    // This array controls the comparison column IDs used when
    // values for the selected column are equal.  These should
    // remain in order of the iLVSUBITEM_xxxxx enumeration with
    // respect to the first element in each row.
    //
    static const int rgColComp[2][2] = { 
        { iLVSUBITEM_SERVER, iLVSUBITEM_ACTION },
        { iLVSUBITEM_ACTION, iLVSUBITEM_SERVER }
                                       };
    int iCompare = 0;
    while(0 == diff && iCompare < ARRAYSIZE(rgColComp))
    {
        switch(rgColComp[pdlg->m_iLastColSorted][iCompare++])
        {
            case iLVSUBITEM_SERVER:
                diff = lstrcmpi(pGOA1->GetServerName(), pGOA2->GetServerName());
                break;

            case iLVSUBITEM_ACTION:
                if (0 < LoadString(pdlg->m_hInstance, 
                                   IDS_GOOFFLINE_ACTION_FIRST + (DWORD)pGOA1->GetAction(),
                                   szText[0],
                                   ARRAYSIZE(szText[0])))
                {
                    if (0 < LoadString(pdlg->m_hInstance,
                                       IDS_GOOFFLINE_ACTION_FIRST + (DWORD)pGOA2->GetAction(),
                                       szText[1],
                                       ARRAYSIZE(szText[1])))
                    {
                        diff = lstrcmpi(szText[0], szText[1]);
                    }
                }
                break;

            default:
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                TraceAssert(false);
                break;
        }
    }
    return pdlg->m_bSortAscending ? diff : -1 * diff;
}



void
CAdvOptDlg::OnLVN_ItemChanged(
    NM_LISTVIEW *pnmlv
    )
{
    static const int rgBtns[] = { IDC_BTN_EDIT_CUSTGOOFFLINE,
                                  IDC_BTN_DELETE_CUSTGOOFFLINE };

    //
    // LVN_ITEMCHANGED is sent multiple times when you move the
    // highlight bar in a listview.  
    // Only run this code when the "focused" state bit is set
    // for the "new state".  This should be the last call in 
    // the series.
    // 
    if (LVIS_FOCUSED & pnmlv->uNewState && IsCustomActionListviewEnabled())
    {
        bool bEnable = 0 < ListView_GetSelectedCount(m_hwndLV);
        if (bEnable)
        {
            //
            // Only enable if all items weren't set by policy.
            //
            int cSetByPolicy = 0;
            CountSelectedListviewItems(&cSetByPolicy);
            bEnable = (0 == cSetByPolicy);
        }

        for (int i = 0; i < ARRAYSIZE(rgBtns); i++)
        {
            HWND hwnd    = GetDlgItem(m_hwndDlg, rgBtns[i]);
            if (bEnable != boolify(IsWindowEnabled(hwnd)))
            {
                EnableWindow(hwnd, bEnable);
            }
        }
    }
}

void
CAdvOptDlg::OnLVN_ColumnClick(
    NM_LISTVIEW *pnmlv
    )
{
    if (m_iLastColSorted != pnmlv->iSubItem)
    {
        m_bSortAscending = true;
        m_iLastColSorted = pnmlv->iSubItem;
    }
    else
    {
        m_bSortAscending = !m_bSortAscending;
    }

    ListView_SortItems(m_hwndLV, CompareLVItems, LPARAM(this));
}



void
CAdvOptDlg::OnLVN_KeyDown(
    NMLVKEYDOWN *plvkd
    )
{
    if (VK_DELETE == plvkd->wVKey && IsCustomActionListviewEnabled())
    {
        int cSetByPolicy = 0;
        CountSelectedListviewItems(&cSetByPolicy);
        if (0 == cSetByPolicy)
        {
            OnDeleteCustomGoOfflineAction();
            FocusOnSomethingInListview();
        }
        else
        {
            //
            // Provide feedback that deleting things set by policy
            // isn't allowed.  Visual feedback is that the "Remove"
            // button and context menu item are disabled.  That
            // doesn't help when user hits the [Delete] key.
            //
            MessageBeep(MB_OK);
        }
    }
}


void
CAdvOptDlg::OnLVN_GetDispInfo(
    LV_DISPINFO *plvdi
    )
{
    static TCHAR szText[MAX_PATH];

    CConfig::CustomGOA* pObj = (CConfig::CustomGOA *)plvdi->item.lParam;

    szText[0] = TEXT('\0');
    if (LVIF_TEXT & plvdi->item.mask)
    {
        switch(plvdi->item.iSubItem)
        {
            case iLVSUBITEM_SERVER:
                if (pObj->SetByPolicy())
                {
                    //
                    // Format as "server ( policy )"
                    //
                    TCHAR szFmt[80];
                    if (0 < LoadString(m_hInstance,  
                                       IDS_FMT_GOOFFLINE_SERVER_POLICY,
                                       szFmt, 
                                       ARRAYSIZE(szFmt)))
                    {
                        wnsprintf(szText, ARRAYSIZE(szText), szFmt, pObj->GetServerName());
                    }
                }
                else
                {
                    //
                    // Just plain 'ol "server".
                    //
                    pObj->GetServerName(szText, ARRAYSIZE(szText));
                }
                break;
                
            case iLVSUBITEM_ACTION:
                LoadString(m_hInstance, 
                           IDS_GOOFFLINE_ACTION_FIRST + (DWORD)pObj->GetAction(),
                           szText,
                           ARRAYSIZE(szText));
                break;

            default:
                break;
        }
        plvdi->item.pszText = szText;
    }

    if (LVIF_IMAGE & plvdi->item.mask)
    {
        //
        // Not displaying any images.  This is just a placeholder.
        // Should be optimized out by compiler.
        //
    }
}


CConfig::CustomGOA *
CAdvOptDlg::GetListviewObject(
    HWND hwndLV,
    int iItem
    )
{
    LVITEM item;
    item.iItem    = iItem;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;
    if (-1 != ListView_GetItem(hwndLV, &item))
    {
        return (CConfig::CustomGOA *)item.lParam;
    }
    return NULL;
}
    


BOOL 
CAdvOptDlg::OnDestroy(
    HWND hwnd
    )
{
    if (NULL != m_hwndLV)
    {
        int cItems = ListView_GetItemCount(m_hwndLV);
        for (int i = 0; i < cItems; i++)
        {
            CConfig::CustomGOA *pObj = GetListviewObject(m_hwndLV, i);
            delete pObj;
        }
        ListView_DeleteAllItems(m_hwndLV);
    }
    return FALSE;
}
        


void
CAdvOptDlg::EnableCtls(
    HWND hwnd
    )
{
    static const struct
    {
        UINT idCtl;
        bool bRestricted;

    } rgCtls[] = { { IDC_RBN_GOOFFLINE_SILENT,     m_bNoConfigGoOfflineAction    },
                   { IDC_RBN_GOOFFLINE_FAIL,       m_bNoConfigGoOfflineAction    },
                   { IDC_GRP_GOOFFLINE_DEFAULTS,   m_bNoConfigGoOfflineAction    },
                   { IDC_GRP_CUSTGOOFFLINE,        false },
                   { IDC_BTN_ADD_CUSTGOOFFLINE,    false },
                   { IDC_BTN_EDIT_CUSTGOOFFLINE,   false },
                   { IDC_BTN_DELETE_CUSTGOOFFLINE, false }
                 };
    
    //
    // bCscEnabled is always true here.  The logic in the options prop page won't
    // let us display the "Advanced" dialog if it isn't.
    //
    bool bCscEnabled = true;
    for (int i = 0; i < ARRAYSIZE(rgCtls); i++)
    {
        bool bEnable = bCscEnabled;
        HWND hwndCtl = GetDlgItem(hwnd, rgCtls[i].idCtl);
        if (bEnable)
        {
            //
            // May be some further policy restrictions.
            //
            if (rgCtls[i].bRestricted)
                bEnable = false;

            if (bEnable)
            {
                if (IDC_BTN_EDIT_CUSTGOOFFLINE == rgCtls[i].idCtl ||
                    IDC_BTN_DELETE_CUSTGOOFFLINE == rgCtls[i].idCtl)
                {
                    //
                    // Only enable "Edit" and "Delete" buttons if there's an active
                    // selection in the listview.
                    //
                    bEnable = (0 < ListView_GetSelectedCount(m_hwndLV));
                }
            }
        }

        if (!bEnable)
        {
            if (GetFocus() == hwndCtl)
            {
                //
                // If disabling a control that has focus, advance the 
                // focus to the next control in the tab order before
                // disabling the current control.  Otherwise, it will
                // be stuck with focus and tabbing is busted.
                //
                SetFocus(GetNextDlgTabItem(hwnd, hwndCtl, FALSE));
            }
        }
        EnableWindow(GetDlgItem(hwnd, rgCtls[i].idCtl), bEnable);
    }
}



void
CAdvOptDlg::GetPageState(
    PgState *pps
    )
{
    pps->SetDefGoOfflineAction(GetCurrentGoOfflineAction());
    pps->SetCustomGoOfflineActions(m_hwndLV);
}



CAdvOptDlg::PgState::~PgState(
    void
    )
{
    if (NULL != m_hdpaCustomGoOfflineActions)
    {
        CConfig::ClearCustomGoOfflineActions(m_hdpaCustomGoOfflineActions);
        DPA_Destroy(m_hdpaCustomGoOfflineActions);
    }
}



//
// Retrieve the records from the "custom go-offline actions" listview and place them
// into a member array, sorted by server name.
//
void
CAdvOptDlg::PgState::SetCustomGoOfflineActions(
    HWND hwndLV
    )
{
    int iItem = -1;
    LVITEM item;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;

    if (NULL != m_hdpaCustomGoOfflineActions)
    {
        CConfig::ClearCustomGoOfflineActions(m_hdpaCustomGoOfflineActions);

        int cLvItems = ListView_GetItemCount(hwndLV);
        for (int iLvItem = 0; iLvItem < cLvItems; iLvItem++)
        {
            CConfig::CustomGOA *pGOA = CAdvOptDlg::GetListviewObject(hwndLV, iLvItem);
            if (NULL != pGOA)
            {
                if (!pGOA->SetByPolicy())
                {
                    int cArrayItems = DPA_GetPtrCount(m_hdpaCustomGoOfflineActions);
                    int iArrayItem;
                    for (iArrayItem = 0; iArrayItem < cArrayItems; iArrayItem++)
                    {
                        CConfig::CustomGOA *pCustomGOA = (CConfig::CustomGOA *)DPA_GetPtr(m_hdpaCustomGoOfflineActions, iArrayItem);
                        if (NULL != pCustomGOA)
                        {
                            if (0 > lstrcmpi(pGOA->GetServerName(), pCustomGOA->GetServerName()))
                                break;
                        }
                    }
                    CConfig::CustomGOA *pCopy = new CConfig::CustomGOA(*pGOA);
                    if (NULL != pCopy)
                    {
                        if (iArrayItem < cArrayItems)
                        {
                            if (-1 != DPA_InsertPtr(m_hdpaCustomGoOfflineActions,
                                                    iArrayItem,
                                                    pCopy))
                            {
                                pCopy = NULL;
                            }
                        }
                        else
                        {
                            if (-1 != DPA_AppendPtr(m_hdpaCustomGoOfflineActions, pCopy))
                            {
                                pCopy = NULL;
                            }
                        }
                        if (NULL != pCopy)
                        {
                            delete pCopy;
                        }
                    }
                }
            }
        }
    }
}

//
// Two page states are equal if their Default go-offline actions are equal and their
// customized go-offline actions are equal.  Action is tested first because it's a 
// faster test.
//
bool
CAdvOptDlg::PgState::operator == (
    const CAdvOptDlg::PgState& rhs
    ) const
{
    bool bMatch = false;
    if (m_DefaultGoOfflineAction == rhs.m_DefaultGoOfflineAction)
    {
        if (NULL != m_hdpaCustomGoOfflineActions && NULL != rhs.m_hdpaCustomGoOfflineActions)
        {
            const int cLhs = DPA_GetPtrCount(m_hdpaCustomGoOfflineActions);
            const int cRhs = DPA_GetPtrCount(rhs.m_hdpaCustomGoOfflineActions);

            if (cLhs == cRhs)
            {
                for (int i = 0; i < cLhs; i++)
                {
                    CConfig::CustomGOA *pGoaLhs = (CConfig::CustomGOA *)DPA_GetPtr(m_hdpaCustomGoOfflineActions, i);
                    CConfig::CustomGOA *pGoaRhs = (CConfig::CustomGOA *)DPA_GetPtr(rhs.m_hdpaCustomGoOfflineActions, i);
                    
                    if (NULL != pGoaLhs && NULL != pGoaRhs)
                    {
                        if (pGoaLhs->GetAction() != pGoaRhs->GetAction())
                            break;

                        if (0 != lstrcmpi(pGoaLhs->GetServerName(), pGoaRhs->GetServerName()))
                            break;
                    }
                }
                bMatch = (i == cLhs);
            }
        }
    }
    return bMatch;
}


//-----------------------------------------------------------------------------
// CustomGOAAddDlg
// "GOA" == Go Offline Action
// This dialog is for adding customized offline actions for particular
// network servers.
// It is invoked via the "Add..." button on the "Advanced" dialog.
//-----------------------------------------------------------------------------
const CustomGOAAddDlg::CtlActions CustomGOAAddDlg::m_rgCtlActions[CConfig::eNumOfflineActions] = {
    { IDC_RBN_GOOFFLINE_SILENT, CConfig::eGoOfflineSilent },
    { IDC_RBN_GOOFFLINE_FAIL,   CConfig::eGoOfflineFail   }
                };


const DWORD CustomGOAAddDlg::m_rgHelpIDs[] = {
    IDOK,                        IDH_OK,
    IDCANCEL,                    IDH_CANCEL,
    IDC_EDIT_GOOFFLINE_SERVER,   HIDC_EDIT_GOOFFLINE_SERVER,
    IDC_STATIC4,                 HIDC_EDIT_GOOFFLINE_SERVER, // "Computer:"
    IDC_RBN_GOOFFLINE_SILENT,    HIDC_RBN_GOOFFLINE_SILENT,
    IDC_RBN_GOOFFLINE_FAIL,      HIDC_RBN_GOOFFLINE_FAIL,
    IDC_BTN_BROWSEFORSERVER,     HIDC_BTN_BROWSEFORSERVER,
    IDC_GRP_GOOFFLINE_DEFAULTS,  DWORD(-1),
    IDC_STATIC2,                 DWORD(-1),                  // icon
    IDC_STATIC3,                 DWORD(-1),                  // icon's text
    0, 0
    };


CustomGOAAddDlg::CustomGOAAddDlg(
    HINSTANCE hInstance, 
    HWND hwndParent, 
    LPTSTR pszServer,
    UINT cchServer,
    CConfig::OfflineAction *pAction
    ) : m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDlg(NULL),
        m_hwndEdit(NULL),
        m_pszServer(pszServer),
        m_cchServer(cchServer),
        m_pAction(pAction) 
{ 
    TraceAssert(NULL != pAction);
}


int 
CustomGOAAddDlg::Run(
    void
    )
{
    return (int)DialogBoxParam(m_hInstance,
                               MAKEINTRESOURCE(IDD_CSC_ADVOPTIONS_ADD),
                               m_hwndParent,
                               DlgProc,
                               (LPARAM)this);
}


INT_PTR CALLBACK 
CustomGOAAddDlg::DlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL bResult = FALSE;

    CustomGOAAddDlg *pThis = (CustomGOAAddDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
        {
            pThis = (CustomGOAAddDlg *)lParam;
            TraceAssert(NULL != pThis);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
            bResult = pThis->OnInitDialog(hDlg, (HWND)wParam, lParam);
            break;
        }

        case WM_COMMAND:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnHelp(hDlg, (LPHELPINFO)lParam);
            break;

        case WM_CONTEXTMENU:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_DESTROY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnDestroy(hDlg);
            break;

        default:
            break;
    }

    return bResult;
}

BOOL 
CustomGOAAddDlg::OnInitDialog(
    HWND hDlg, 
    HWND hwndFocus, 
    LPARAM lInitParam
    )
{
    m_hwndDlg = hDlg;
    //
    // Set the default go-offline action radio buttons.
    //
    for (int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        CheckDlgButton(hDlg, 
                       m_rgCtlActions[i].idRbn, 
                       m_rgCtlActions[i].action == *m_pAction ? BST_CHECKED : BST_UNCHECKED);
    }
    m_hwndEdit = GetDlgItem(hDlg, IDC_EDIT_GOOFFLINE_SERVER);

    SetWindowText(m_hwndEdit, m_pszServer);

    return TRUE;
}

void
CustomGOAAddDlg::GetEnteredServerName(
    LPTSTR pszServer,
    UINT cchServer,
    bool bTrimLeadingJunk
    )
{
    //
    // Get the server name.
    //
    GetWindowText(m_hwndEdit, pszServer, cchServer);
    if (bTrimLeadingJunk)
    {
        //
        // Remove any leading "\\" or space user might have entered.
        //
        LPTSTR pszLookahead = pszServer;
        while(*pszLookahead && (TEXT('\\') == *pszLookahead || TEXT(' ') == *pszLookahead))
            pszLookahead++;

        if (pszLookahead > pszServer)
        {
            // overlapped
            TraceAssert(StringByteSize(pszLookahead) < cchServer*sizeof(TCHAR));
            MoveMemory(pszServer, pszLookahead, StringByteSize(pszLookahead));
        }
    }
}


//
// Query the dialog and return the state through pointer args.
//
void
CustomGOAAddDlg::GetActionInfo(
    LPTSTR pszServer,
    UINT cchServer,
    CConfig::OfflineAction *pAction
    )
{
    TraceAssert(NULL != pszServer);
    TraceAssert(NULL != pAction);
    //
    // Get the action radio button setting.
    //
    *pAction = CConfig::eNumOfflineActions;
    for(int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, m_rgCtlActions[i].idRbn))
        {
            *pAction = m_rgCtlActions[i].action;
            break;
        }
    }
    TraceAssert(CConfig::eNumOfflineActions != *pAction);

    //
    // Retrieve the entered server name with leading junk removed.
    // Should have just a bare server name (i.e. "worf").
    //
    GetEnteredServerName(pszServer, cchServer, true);
}


//
// See if server name entered could be valid.
// This weeds out things like entering a UNC share name
// instead of a server name.  
//
// "\\rastaman" or "rastaman" is good.
// "\\rastaman\ntwin" is bad.
//
// This function will display error UI if the name is not valid.
// Returns:
//     true  = Name is a UNC server name.
//     false = Name is not a UNC server name.
//
bool
CustomGOAAddDlg::CheckServerNameEntered(
    void
    )
{
    TCHAR szPath[MAX_PATH];
    szPath[0] = TEXT('\\');
    szPath[1] = TEXT('\\');
    GetEnteredServerName(szPath+2, ARRAYSIZE(szPath)-2, true);  // Name with leading "\\" and any spaces removed.

    if (!::PathIsUNCServer(szPath))
    {
        //
        // Name provided is not a UNC server name.
        //
        GetEnteredServerName(szPath, ARRAYSIZE(szPath), false); // Name "as entered".
        CscMessageBox(m_hwndDlg,
                      MB_OK | MB_ICONERROR,
                      m_hInstance,
                      IDS_ERR_NOTSERVERNAME,
                      szPath);
        return false;
    }
    return true;
}



BOOL 
CustomGOAAddDlg::OnCommand(
    HWND hDlg, 
    WORD wNotifyCode, 
    WORD wID, 
    HWND hwndCtl
    )
{
    switch(wID)
    {
        case IDOK:
            //
            // First see if server name entered could be valid.
            // This weeds out things like entering a UNC share name
            // instead of a server name.  
            //
            // "\\rastaman" or "rastaman" is good.
            // "\\rastaman\ntwin" is bad.
            //
            // This function will display error UI if the name is not valid.
            //
            if (!CheckServerNameEntered())
            {
                //
                // Invalid name. Return focus to the server name edit control.
                //
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_GOOFFLINE_SERVER));
                break;
            }

            GetActionInfo(m_pszServer, m_cchServer, m_pAction);            
            //
            // Fall through...
            //
        case IDCANCEL:
            EndDialog(hDlg, wID);
            break;

        case IDC_BTN_BROWSEFORSERVER:
        {
            TCHAR szServer[MAX_PATH];

            szServer[0] = TEXT('\0');
            BrowseForServer(hDlg, szServer, ARRAYSIZE(szServer));
            if (TEXT('\0') != szServer[0])
            {
                SetWindowText(GetDlgItem(hDlg, IDC_EDIT_GOOFFLINE_SERVER), szServer);
            }
            break;
        }
    }
    return FALSE;
}


//
// Use the SHBrowseForFolder dialog to find a server.
//
void
CustomGOAAddDlg::BrowseForServer(
    HWND hDlg,
    LPTSTR pszServer,
    UINT cchServer
    )
{
    TraceAssert(NULL != pszServer);
 
    LPTSTR pszTitle;
    if (0 < LoadStringAlloc(&pszTitle, m_hInstance, IDS_BROWSEFORSERVER))
    {
        BROWSEINFO bi;
        ZeroMemory(&bi, sizeof(bi));

        //
        // Start browsing in the network folder.
        //
        LPITEMIDLIST pidlRoot = NULL;
        HRESULT hr = SHGetSpecialFolderLocation(hDlg, CSIDL_NETWORK, &pidlRoot);
        if (SUCCEEDED(hr))
        {
            TCHAR szServer[MAX_PATH];

            bi.hwndOwner      = hDlg;
            bi.pidlRoot       = pidlRoot;
            bi.pszDisplayName = szServer;   // assumed to be at least MAX_PATH
            bi.lpszTitle      = pszTitle;
            bi.ulFlags        = BIF_BROWSEFORCOMPUTER;
            bi.lpfn           = NULL;
            bi.lParam         = NULL;
            bi.iImage         = 0;

            LPITEMIDLIST pidlFolder = SHBrowseForFolder(&bi);
            ILFree(pidlRoot);
            if (NULL != pidlFolder)
            {
                ILFree(pidlFolder);
                StringCchCopy(pszServer, cchServer, szServer);
            }
        }
        else
        {
            CscMessageBox(hDlg, MB_OK, Win32Error(HRESULT_CODE(hr)));
        }
        LocalFree(pszTitle);
    }
}


BOOL 
CustomGOAAddDlg::OnHelp(
    HWND hDlg, 
    LPHELPINFO pHelpInfo
    )
{
    if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
        int idCtl = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);
        WinHelp((HWND)pHelpInfo->hItemHandle, 
                 UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
                 HELP_WM_HELP, 
                 (DWORD_PTR)((LPTSTR)m_rgHelpIDs));
    }
    return FALSE;
}


BOOL
CustomGOAAddDlg::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem, 
            UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
            HELP_CONTEXTMENU, 
            (DWORD_PTR)((LPTSTR)m_rgHelpIDs));

    return FALSE;
}


BOOL 
CustomGOAAddDlg::OnDestroy(
    HWND hDlg
    )
{

    return FALSE;
}


//-----------------------------------------------------------------------------
// CustomGOAEditDlg
// "GOA" == Go Offline Action
// This dialog is for editing customized offline actions for particular
// network servers.
// It is invoked via the "Edit..." button on the "Advanced" dialog.
//-----------------------------------------------------------------------------
const CustomGOAEditDlg::CtlActions CustomGOAEditDlg::m_rgCtlActions[CConfig::eNumOfflineActions] = {
    { IDC_RBN_GOOFFLINE_SILENT, CConfig::eGoOfflineSilent },
    { IDC_RBN_GOOFFLINE_FAIL,   CConfig::eGoOfflineFail   },
                };


const DWORD CustomGOAEditDlg::m_rgHelpIDs[] = {
    IDOK,                           IDH_OK,
    IDCANCEL,                       IDH_CANCEL,
    IDC_TXT_GOOFFLINE_SERVER,       HIDC_TXT_GOOFFLINE_SERVER,
    IDC_STATIC4,                    HIDC_TXT_GOOFFLINE_SERVER, // "Computer:"
    IDC_RBN_GOOFFLINE_SILENT,       HIDC_RBN_GOOFFLINE_SILENT,
    IDC_RBN_GOOFFLINE_FAIL,         HIDC_RBN_GOOFFLINE_FAIL,
    IDC_GRP_GOOFFLINE_DEFAULTS,     DWORD(-1),
    IDC_STATIC2,                    DWORD(-1),                 // icon
    IDC_STATIC3,                    DWORD(-1),                 // icon's text.
    0, 0
    };

CustomGOAEditDlg::CustomGOAEditDlg(
    HINSTANCE hInstance, 
    HWND hwndParent, 
    LPCTSTR pszServer,                // NULL == multi-server.
    CConfig::OfflineAction *pAction
    ) : m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDlg(NULL),
        m_pAction(pAction) 
{ 
    TraceAssert(NULL != pAction);

    if (NULL != pszServer && TEXT('\0') != *pszServer)
    {
        StringCchCopy(m_szServer, ARRAYSIZE(m_szServer), pszServer);
    }
    else
    {
        m_szServer[0] = TEXT('\0');
        LoadString(m_hInstance, IDS_GOOFFLINE_MULTISERVER, m_szServer, ARRAYSIZE(m_szServer));
    }
}



int 
CustomGOAEditDlg::Run(
    void
    )
{
    return (int)DialogBoxParam(m_hInstance,
                               MAKEINTRESOURCE(IDD_CSC_ADVOPTIONS_EDIT),
                               m_hwndParent,
                               DlgProc,
                               (LPARAM)this);
}


INT_PTR CALLBACK 
CustomGOAEditDlg::DlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BOOL bResult = FALSE;

    CustomGOAEditDlg *pThis = (CustomGOAEditDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
        case WM_INITDIALOG:
        {
            pThis = (CustomGOAEditDlg *)lParam;
            TraceAssert(NULL != pThis);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
            bResult = pThis->OnInitDialog(hDlg, (HWND)wParam, lParam);
            break;
        }

        case WM_COMMAND:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnHelp(hDlg, (LPHELPINFO)lParam);
            break;

       case WM_CONTEXTMENU:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_DESTROY:
            TraceAssert(NULL != pThis);
            bResult = pThis->OnDestroy(hDlg);
            break;

        default:
            break;
    }
    return bResult;
}

BOOL 
CustomGOAEditDlg::OnInitDialog(
    HWND hDlg, 
    HWND hwndFocus, 
    LPARAM lInitParam
    )
{
    m_hwndDlg = hDlg;
    //
    // Set the default go-offline action radio buttons.
    //
    for (int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        CheckDlgButton(hDlg, 
                       m_rgCtlActions[i].idRbn, 
                       m_rgCtlActions[i].action == *m_pAction ? BST_CHECKED : BST_UNCHECKED);
    }
    SetWindowText(GetDlgItem(hDlg, IDC_TXT_GOOFFLINE_SERVER), m_szServer);

    return TRUE;
}

//
// Query the dialog and return the state through pointer args.
//
void
CustomGOAEditDlg::GetActionInfo(
    CConfig::OfflineAction *pAction
    )
{
    TraceAssert(NULL != pAction);
    //
    // Get the action radio button setting.
    //
    *pAction = CConfig::eNumOfflineActions;
    for(int i = 0; i < ARRAYSIZE(m_rgCtlActions); i++)
    {
        if (BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, m_rgCtlActions[i].idRbn))
        {
            *pAction = m_rgCtlActions[i].action;
            break;
        }
    }
    TraceAssert(CConfig::eNumOfflineActions != *pAction);
}


BOOL 
CustomGOAEditDlg::OnCommand(
    HWND hDlg, 
    WORD wNotifyCode, 
    WORD wID, 
    HWND hwndCtl
    )
{
    switch(wID)
    {
        case IDOK:
            GetActionInfo(m_pAction);            
            //
            // Fall through...
            //
        case IDCANCEL:
            EndDialog(hDlg, wID);
            break;
    }
    return FALSE;
}


BOOL 
CustomGOAEditDlg::OnHelp(
    HWND hDlg, 
    LPHELPINFO pHelpInfo
    )
{
    if (HELPINFO_WINDOW == pHelpInfo->iContextType)
    {
        int idCtl = GetDlgCtrlID((HWND)pHelpInfo->hItemHandle);
        WinHelp((HWND)pHelpInfo->hItemHandle, 
                 UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
                 HELP_WM_HELP, 
                 (DWORD_PTR)((LPTSTR)m_rgHelpIDs));
    }

    return FALSE;
}

BOOL
CustomGOAEditDlg::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem, 
            UseWindowsHelp(idCtl) ? NULL : c_szHelpFile,
            HELP_CONTEXTMENU, 
            (DWORD_PTR)((LPTSTR)m_rgHelpIDs));

    return FALSE;
}


BOOL 
CustomGOAEditDlg::OnDestroy(
    HWND hDlg
    )
{

    return FALSE;
}



//-----------------------------------------------------------------------------
// COfflineFilesSheet
//-----------------------------------------------------------------------------
COfflineFilesSheet::COfflineFilesSheet(
    HINSTANCE hInstance,
    LONG *pDllRefCount,
    HWND hwndParent
    ) : m_hInstance(hInstance),
        m_pDllRefCount(pDllRefCount),
        m_hwndParent(hwndParent)
{
    InterlockedIncrement(m_pDllRefCount);
}

COfflineFilesSheet::~COfflineFilesSheet(
    void
    )
{
    ASSERT( 0 != *m_pDllRefCount );
    InterlockedDecrement(m_pDllRefCount);
}


BOOL CALLBACK
COfflineFilesSheet::AddPropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam
    )
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < COfflineFilesSheet::MAXPAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }

    return FALSE;
}


//
// Static function for creating and running an instance of the
// CSCUI options dialog.  This is the ONLY function callable
// by non-member code to create and run an options dialog.
//
DWORD
COfflineFilesSheet::CreateAndRun(
    HINSTANCE hInstance,
    HWND hwndParent,
    LONG *pDllRefCount,
    BOOL bAsync
    )
{
    //
    // First try to activate an existing instance of the prop sheet.
    //
    TCHAR szSheetTitle[MAX_PATH] = {0};
    LoadString(hInstance, IDS_CSCOPT_PROPSHEET_TITLE, szSheetTitle, ARRAYSIZE(szSheetTitle));

    HWND hwnd = FindWindowEx(NULL, NULL, WC_DIALOG, szSheetTitle);
    if (NULL == hwnd || !SetForegroundWindow(hwnd))
    {
        //
        // This thread param buffer will be deleted by the
        // thread proc.
        //
        ThreadParams *ptp = new ThreadParams(hwndParent, pDllRefCount);
        if (NULL != ptp)
        {
            if (bAsync)
            {
                //
                // LoadLibrary on ourselves so that we stay in memory even
                // if the caller calls FreeLibrary.  We'll call FreeLibrary
                // when the thread proc exits.
                //
                ptp->SetModuleHandle(LoadLibrary(TEXT("cscui.dll")));

                DWORD idThread;
                HANDLE hThread = CreateThread(NULL,
                                              0,
                                              ThreadProc,
                                              ptp,
                                              0,
                                              &idThread);

                if (INVALID_HANDLE_VALUE != hThread)
                {
                    CloseHandle(hThread);
                }
                else
                {
                    //
                    // Thread creation failed.  Delete thread param buffer.
                    //
                    delete ptp;
                }
            }
            else
            {
                ThreadProc(ptp);
            }
        }
    }
    return 0;
}


//
// The share dialog's thread proc.
//
DWORD WINAPI
COfflineFilesSheet::ThreadProc(
    LPVOID pvParam
    )
{
    ThreadParams *ptp = reinterpret_cast<ThreadParams *>(pvParam);
    TraceAssert(NULL != ptp);

    HINSTANCE hInstance = ptp->m_hInstance; // Save local copy.

    COfflineFilesSheet dlg(ptp->m_hInstance ? ptp->m_hInstance : g_hInstance,
                           ptp->m_pDllRefCount,
                           ptp->m_hwndParent);
    dlg.Run();

    delete ptp;

    if (NULL != hInstance)
        FreeLibraryAndExitThread(hInstance, 0);

    return 0;
}


DWORD
COfflineFilesSheet::Run(
    void
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (CConfig::GetSingleton().NoConfigCache())
    {
        Trace((TEXT("System policy restricts configuration of Offline Files cache")));
        return ERROR_SUCCESS;
    }

    TCHAR szSheetTitle[MAX_PATH] = {0};
    LoadString(m_hInstance, IDS_CSCOPT_PROPSHEET_TITLE, szSheetTitle, ARRAYSIZE(szSheetTitle));

    HPROPSHEETPAGE rghPages[COfflineFilesSheet::MAXPAGES];
    PROPSHEETHEADER psh;
    ZeroMemory(&psh, sizeof(psh));
    //
    // Define sheet.
    //
    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.dwFlags         = 0;
    psh.hInstance       = m_hInstance;
    psh.hwndParent      = m_hwndParent;
    psh.pszIcon         = MAKEINTRESOURCE(IDI_CSCUI_ICON);
    psh.pszCaption      = szSheetTitle;
    psh.nPages          = 0;
    psh.nStartPage      = 0;
    psh.phpage          = rghPages;

    //
    // Policy doesn't prevent user from configuring CSC cache.
    // Add the dynamic page(s).
    //
    CCoInit coinit;
    HRESULT hr = coinit.Result();
    if (SUCCEEDED(hr))
    {
        IShellExtInit *psei;
        hr = CoCreateInstance(CLSID_OfflineFilesOptions,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IShellExtInit,
                              (void **)&psei);

        if (SUCCEEDED(hr))
        {
            IShellPropSheetExt *pspse;
            hr = psei->QueryInterface(IID_IShellPropSheetExt, (void **)&pspse);
            if (SUCCEEDED(hr))
            {
                hr = pspse->AddPages(AddPropSheetPage, (LPARAM)&psh);
                pspse->Release();
                pspse = NULL;
            }

            switch(PropertySheet(&psh))
            {
                case ID_PSREBOOTSYSTEM:
                    //
                    // User wants to change enabled state of CSC.  Requires reboot.
                    //
                    if (IDYES == CscMessageBox(m_hwndParent,
                                               MB_YESNO | MB_ICONINFORMATION,
                                               m_hInstance,
                                               IDS_REBOOTSYSTEM))
                    {
                        dwError = CSCUIRebootSystem();
                        if (ERROR_SUCCESS != dwError)
                        {
                            Trace((TEXT("Reboot failed with error %d"), dwError));
                            CscMessageBox(m_hwndParent,
                                          MB_ICONWARNING | MB_OK,
                                          Win32Error(dwError),
                                          m_hInstance,
                                          IDS_ERR_REBOOTFAILED);
                        }
                    }
                    dwError = ERROR_SUCCESS;  // Run() succeeded.
                    break;

                case -1:
                {
                    dwError = GetLastError();
                    Trace((TEXT("PropertySheet failed with error %d"), dwError));
                    CscWin32Message(m_hwndParent, dwError, CSCUI::SEV_ERROR);
                    break;
                }
                default:
                    break;
            }
            psei->Release();
            psei = NULL;
        }
        else
        {
            Trace((TEXT("CoCreateInstance failed with result 0x%08X"), hr));
        }
    }
    else
    {
        Trace((TEXT("CoInitialize failed with result 0x%08X"), hr));
    }

    return dwError;
}


//
// Exported API for launching the CSC Options property sheet.
// If policy disallows configuration of CSC, we display a messagebox
// with an error message.
//
DWORD CSCUIOptionsPropertySheetEx(HWND hwndParent, BOOL bAsync)
{
    DWORD dwResult = ERROR_SUCCESS;
    if (!CConfig::GetSingleton().NoConfigCache())
    {
        dwResult = COfflineFilesSheet::CreateAndRun(g_hInstance,
                                                    hwndParent,
                                                    &g_cRefCount,
                                                    bAsync);
    }
    else
    {
        CscMessageBox(hwndParent,
                      MB_OK,
                      g_hInstance,
                      IDS_ERR_POLICY_NOCONFIGCSC);
    }
    return dwResult;
}
    

DWORD CSCUIOptionsPropertySheet(HWND hwndParent)
{
    return CSCUIOptionsPropertySheetEx(hwndParent, TRUE);
}
    

STDAPI_(void) CSCOptions_RunDLLW(HWND hwndStub, HINSTANCE /*hInst*/, LPWSTR pszCmdLine, int /*nCmdShow*/)
{
    DllAddRef();

    HWND hwndParent = FindWindowW(NULL, pszCmdLine);
    CSCUIOptionsPropertySheetEx(hwndParent ? hwndParent : hwndStub, FALSE);

    DllRelease();
}


STDAPI_(void) CSCOptions_RunDLLA(HWND hwndStub, HINSTANCE hInst, LPSTR pszCmdLine, int nCmdShow)
{
    WCHAR wszCmdLine[MAX_PATH];

    DllAddRef();

    SHAnsiToUnicode(pszCmdLine, wszCmdLine, ARRAYSIZE(wszCmdLine));
    CSCOptions_RunDLLW(hwndStub, hInst, wszCmdLine, nCmdShow);

    DllRelease();
}


//-----------------------------------------------------------------------------
// CscOptPropSheetExt
// This is the shell prop sheet extension implementation for creating
// the "Offline Folders" property page.
//-----------------------------------------------------------------------------
CscOptPropSheetExt::CscOptPropSheetExt(
    HINSTANCE hInstance,
    LONG *pDllRefCnt
    ) : m_cRef(0),
        m_pDllRefCnt(pDllRefCnt),
        m_hInstance(hInstance),
        m_pOfflineFoldersPg(NULL)
{
    InterlockedIncrement(m_pDllRefCnt);
}

CscOptPropSheetExt::~CscOptPropSheetExt(
    void
    )
{
    delete m_pOfflineFoldersPg;
    ASSERT( 0 != *m_pDllRefCnt );
    InterlockedDecrement(m_pDllRefCnt);
}


HRESULT
CscOptPropSheetExt::QueryInterface(
    REFIID riid,
    void **ppvOut
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid ||
        IID_IShellExtInit == riid)
    {
        *ppvOut = static_cast<IShellExtInit *>(this);
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvOut = static_cast<IShellPropSheetExt *>(this);
    }
    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }
    return hr;
}


ULONG
CscOptPropSheetExt::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

ULONG
CscOptPropSheetExt::Release(
    void
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT
CscOptPropSheetExt::Initialize(
    LPCITEMIDLIST pidlFolder, 
    LPDATAOBJECT pdtobj,
    HKEY hkeyProgID
    )
{
    return NOERROR;
}


HRESULT
CscOptPropSheetExt::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam
    )
{
    TraceAssert(NULL != lpfnAddPage);
    TraceAssert(NULL == m_pOfflineFoldersPg);

    HRESULT hr = E_FAIL; // Assume failure.

    if (!CConfig::GetSingleton().NoConfigCache())
    {
        hr = E_OUTOFMEMORY;
        HPROPSHEETPAGE hOfflineFoldersPg = NULL;
        m_pOfflineFoldersPg  = new COfflineFilesPage(m_hInstance, 
                                                     static_cast<IShellPropSheetExt *>(this));
        if (NULL != m_pOfflineFoldersPg)
        {
            hr = AddPage(lpfnAddPage, lParam, *m_pOfflineFoldersPg, &hOfflineFoldersPg);
        }
    }

    return hr;
}


HRESULT
CscOptPropSheetExt::AddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam,
    const COfflineFilesPage& pg,
    HPROPSHEETPAGE *phPage
    )
{
    TraceAssert(NULL != lpfnAddPage);
    TraceAssert(NULL != phPage);

    HRESULT hr = E_FAIL;

    PROPSHEETPAGE psp;

    psp.dwSize          = sizeof(psp);
    psp.dwFlags         = PSP_USECALLBACK | PSP_USEREFPARENT;
    psp.hInstance       = m_hInstance;
    psp.pszTemplate     = MAKEINTRESOURCE(pg.GetDlgTemplateID());
    psp.hIcon           = NULL;
    psp.pszTitle        = NULL;
    psp.pfnDlgProc      = pg.GetDlgProcPtr();
    psp.lParam          = (LPARAM)&pg;
    psp.pcRefParent     = (UINT *)m_pDllRefCnt;
    psp.pfnCallback     = (LPFNPSPCALLBACK)pg.GetCallbackFuncPtr();

    *phPage = CreatePropertySheetPage(&psp);
    if (NULL != *phPage)
    {
        if (!lpfnAddPage(*phPage, lParam))
        {
            Trace((TEXT("AddPage Failed to add page.")));
            DestroyPropertySheetPage(*phPage);
            *phPage = NULL;
        }
    }
    else
    {
        Trace((TEXT("CreatePropertySheetPage failed.")));
    }
    if (NULL != *phPage)
    {
        AddRef();
        hr = NOERROR;
    }
    return hr;
}


STDAPI 
COfflineFilesOptions_CreateInstance(
    REFIID riid, 
    void **ppv
    )
{
    HRESULT hr = E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IShellPropSheetExt) ||
        IsEqualIID(riid, IID_IShellExtInit))
    {
        //
        // Create the property sheet extension to handle the CSC options property
        // pages.
        //
        CscOptPropSheetExt *pse = new CscOptPropSheetExt(g_hInstance, &g_cRefCount);
        if (NULL != pse)
        {
            pse->AddRef();
            hr = pse->QueryInterface(riid, ppv);
            pse->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        *ppv = NULL;
    }

    return hr;
}


//
// Initialize the "config items" object.
// This loads all of the user preference/policy information for the page when
// the page is first created.
//
void
COfflineFilesPage::CConfigItems::Load(
    void
    )
{
#define LOADCFG(i, f) m_rgItems[i].dwValue = DWORD(c.f(&m_rgItems[i].bSetByPolicy))

    CConfig& c = CConfig::GetSingleton();

    LOADCFG(iCFG_NOCONFIGCACHE,       NoConfigCache);
    LOADCFG(iCFG_SYNCATLOGOFF,        SyncAtLogoff);
    LOADCFG(iCFG_SYNCATLOGON,         SyncAtLogon);
    LOADCFG(iCFG_NOREMINDERS,         NoReminders);
    LOADCFG(iCFG_REMINDERFREQMINUTES, ReminderFreqMinutes);
    LOADCFG(iCFG_DEFCACHESIZE,        DefaultCacheSize);
    LOADCFG(iCFG_NOCACHEVIEWER,       NoCacheViewer);
    LOADCFG(iCFG_CSCENABLED,          CscEnabled);
    LOADCFG(iCFG_ENCRYPTCACHE,        EncryptCache);

#undef LOADCFG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\purge.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       purge.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <cscuiext.h>   // CSCUIRemoveFolderFromCache
#include "purge.h"
#include "msgbox.h"
#include "resource.h"
#include "security.h"
#include "util.h"
#include "strings.h"

//
// We use a path buffer with this many TCHARs for the recursive tree walk.
//
#define PURGE_BUFFER_LENGTH     (MAX_PATH * 2)

//
// This is also defined in cscui\dll\pch.h
// If you change it there you must change it here and vice versa.
//
#define FLAG_CSC_HINT_PIN_ADMIN  FLAG_CSC_HINT_PIN_SYSTEM

//
// Purge confirmation dialog.
// The user can set which files are purged from the cache.
//
class CConfirmPurgeDialog
{
    public:
        CConfirmPurgeDialog(void)
            : m_hInstance(NULL),
              m_hwnd(NULL),
              m_hwndLV(NULL),
              m_pSel(NULL)
              { }

        ~CConfirmPurgeDialog(void)
            { if (NULL != m_hwnd) DestroyWindow(m_hwnd); }

        int Run(HINSTANCE hInstance, HWND hwndParent, CCachePurgerSel *pSel);

    private:
        HINSTANCE        m_hInstance;
        HWND             m_hwnd;
        HWND             m_hwndLV;
        CCachePurgerSel *m_pSel;                // Ptr to destination for selection info.

        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
        void OnInitDialog(HWND hwnd);
        void OnDestroy(void);
        void OnOk(void);
        void OnSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam);
        LPARAM LVGetItemData(HWND hwndLV, int i);
        int LVAddItem(HWND hwndLV, LPCTSTR pszItem, LPARAM lParam);
};


inline ULONGLONG
MakeULongLong(DWORD dwLow, DWORD dwHigh)
{
    return ((ULONGLONG)(((DWORD)(dwLow)) | ((LONGLONG)((DWORD)(dwHigh))) << 32));
}

inline bool
IsDirty(const CscFindData& cfd)
{
    return 0 != (FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY & cfd.dwStatus);
}


inline bool
IsSuperHidden(const CscFindData& cfd)
{
    const DWORD dwSuperHidden = (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
    return (cfd.fd.dwFileAttributes & dwSuperHidden) == dwSuperHidden;
}

inline bool
OthersHaveAccess(const CscFindData& cfd)
{
    return CscAccessOther(cfd.dwStatus);
}


CCachePurger::CCachePurger(
    const CCachePurgerSel& sel,
    LPFNPURGECALLBACK pfnCbk, 
    LPVOID pvCbkData
    ) : m_ullBytesToScan(0),
        m_ullBytesScanned(0),
        m_ullBytesToDelete(0),
        m_ullBytesDeleted(0),
        m_ullFileBytes(0),
        m_dwPhase(0),
        m_cFilesToScan(0),
        m_cFilesScanned(0),
        m_cFilesToDelete(0),
        m_cFilesDeleted(0),
        m_iFile(0),
        m_dwFileAttributes(0),
        m_dwResult(0),
        m_hgcPurgeInProgress(NULL),
        m_pszFile(NULL),
        m_pvCbkData(pvCbkData),
        m_bWillDelete(FALSE),
        m_pfnCbk(pfnCbk),
        m_bIsValid(true),
        m_sel(sel),
        m_bDelPinned(0 != (PURGE_FLAG_PINNED & sel.Flags())),
        m_bDelUnpinned(0 != (PURGE_FLAG_UNPINNED & sel.Flags())),
        m_bIgnoreAccess(0 != (PURGE_IGNORE_ACCESS & sel.Flags())),
        m_bUserIsAnAdmin(boolify(IsCurrentUserAnAdminMember()))
{
    //
    // Let the world know we're purging files from the cache.
    // In particular, our overlay handler in cscui\dll\shellex.cpp needs
    // to disable it's auto-pin code whenever we're purging.  If we didn't
    // do this AND the source folder is open during the purge, we get a 
    // nasty race condition between our shell notifications for purging
    // and the overlay handler's auto-pin code.  We'll delete a file
    // and send a notification.  The shell updates the icon overlay.
    // Our handler sees that the parent folder is pinned so it re-pins
    // the purged file which restores the file in the folder. This ends
    // up resulting in a very nasty infinite loop. Those interested
    // should call IsPurgeInProgress() to determine if the purge is
    // in progress (see cscui\dll\util.cpp).  [brianau - 11/01/99]
    //
    m_hgcPurgeInProgress = SHGlobalCounterCreateNamed(c_szPurgeInProgCounter, 0);
    if (m_hgcPurgeInProgress)
    {
        SHGlobalCounterIncrement(m_hgcPurgeInProgress);
    }
}

CCachePurger::~CCachePurger(
    void
    )
{
    if (NULL != m_hgcPurgeInProgress)
    {
        SHGlobalCounterDecrement(m_hgcPurgeInProgress);
        SHGlobalCounterDestroy(m_hgcPurgeInProgress);
    }
}

   
//
// Deletes a directory and all it's contents according to the PURGE_FLAG_XXXXX flag 
// bits set by the caller of PurgeCache().
// This function recursively traverses the cache file hierarchy in a post-order fashion.
// Directory nodes are deleted after all children have been deleted.
// If the caller of PurgeCache provided a callback function, it is called
// after each deletion.   If the callback function returns FALSE, the traversal
// operation is terminated.
//
// pstrPath - Address of path string containing the path of the directory to be
//            deleted.  This object is used to contain the working path throughout
//            the tree traversal.
//
// dwPhase -  PURGE_PHASE_SCAN    - Scanning for file totals.
//            PURGE_PHASE_DELETE  - Deleting files.
//
// bShareIsOffline - The share is offline.
//
// Returns:   true  = Continue traversal.
//            false = User cancelled via callback.  Terminate traversal.
//            
//
bool
CCachePurger::ProcessDirectory(
    LPTSTR pszPath,
    DWORD dwPhase,
    bool bShareIsOffline
    )
{
    bool bContinue = true;

    //
    // We are working with a buffer longer than MAX_PATH, so we can't use
    // the Path functions.  However, we can make a couple of simplifying
    // assumptions about the path we're working with.
    //
    int cchPath = lstrlen(pszPath);
    TraceAssert(PathIsUNC(pszPath));
    if (cchPath+1 >= PURGE_BUFFER_LENGTH)
    {
        // Not enough buffer space to do anything here, but continue anyway
        return true;
    }

    CscFindData cfd;
    CCscFindHandle hFind(CacheFindFirst(pszPath, m_sel.UserSid(), &cfd));
    if (hFind.IsValid())
    {
        // Append a backslash
        TraceAssert(cchPath > 2 && pszPath[cchPath-1] != TEXT('\\'));
        pszPath[cchPath++] = TEXT('\\');
        pszPath[cchPath] = TEXT('\0');

        do
        {
            //
            // Create full path to this file/folder.
            //
            if (SUCCEEDED(StringCchCopy(pszPath + cchPath, PURGE_BUFFER_LENGTH - cchPath, cfd.fd.cFileName)))
            {
                bool bIsDirectory = (0 != (FILE_ATTRIBUTE_DIRECTORY & cfd.fd.dwFileAttributes));
                if (bIsDirectory)
                {
                    //
                    // It's a directory.  Recursively delete it's contents.
                    //
                    bContinue = ProcessDirectory(pszPath, dwPhase, bShareIsOffline);
                }
                if (bContinue)
                {
                    bool bPinned = (0 != ((FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN) & cfd.dwHintFlags));
                    //
                    // The decision to delete a file has several criteria.  I've tried to break this
                    // up using inlines and member variables to make it more understandable and minimize
                    // maintenance bugs.
                    // The logic for deletion is this:
                    //
                    //  bDelete = false;
                    //  If (pinned AND deleting pinned) OR (not pinned and deleting unpinned) then
                    //      If super_hidden then
                    //          bDelete = true;
                    //      else
                    //          If (not locally dirty) then
                    //              If (ignore access) then
                    //                  bDelete = true;
                    //              else
                    //                  If (user is an admin) then
                    //                      bDelete = true;
                    //                  else
                    //                      if (others have NO access) then
                    //                          bDelete = true;
                    //                      endif
                    //                  endif
                    //              endif
                    //          endif
                    //      endif
                    //  endif
                    bool bDelete = ((bPinned && m_bDelPinned) || (!bPinned && m_bDelUnpinned)) &&
                                   (IsSuperHidden(cfd) || 
                                        (!IsDirty(cfd) && 
                                            (m_bIgnoreAccess ||
                                                (m_bUserIsAnAdmin || !OthersHaveAccess(cfd)))));

                    m_pszFile          = pszPath;
                    m_dwFileAttributes = cfd.fd.dwFileAttributes;
                    m_ullFileBytes     = MakeULongLong(cfd.fd.nFileSizeLow, cfd.fd.nFileSizeHigh);
                    m_bWillDelete      = bDelete;

                    if (PURGE_PHASE_SCAN == dwPhase)
                    {
                        if (!bIsDirectory && m_pfnCbk)
                        {
                            //
                            // Exclude directories from the file and byte counts.
                            // 
                            if (bDelete)
                            {
                                m_cFilesToDelete++;
                                m_ullBytesToDelete += m_ullFileBytes;
                            }
                            m_cFilesScanned++;
                            m_ullBytesScanned += m_ullFileBytes;

                            m_dwResult = ERROR_SUCCESS;
                            bContinue = boolify((*m_pfnCbk)(this));
                            m_iFile++;
                        }
                    }
                    else if (PURGE_PHASE_DELETE == dwPhase && bDelete)
                    {
                        LONG lShellEvent = SHCNE_UPDATEITEM;

                        m_dwResult = CscDelete(pszPath);
                        if (ERROR_SUCCESS == m_dwResult)
                        {
                            if (!bIsDirectory)
                            {
                                m_cFilesDeleted++;
                                m_ullBytesDeleted += m_ullFileBytes;
                            }

                            if (bShareIsOffline)
                            {
                                lShellEvent = bIsDirectory ? SHCNE_RMDIR : SHCNE_DELETE;
                            }
                        }
                        else
                        {
                            if (ERROR_ACCESS_DENIED == m_dwResult)
                            {
                                //
                                // This is a little weird.  CscDelete
                                // returns ERROR_ACCESS_DENIED if there's
                                // a handle open on the file. Set the
                                // code to ERROR_BUSY so we know to handle 
                                // this as a special case.
                                //
                                m_dwResult = ERROR_BUSY;
                            }

                            //
                            // NTRAID#NTBUG9-213486-2001/01/29-jeffreys
                            //
                            // CscDelete failed.  Make sure it's unpinned, so
                            // it doesn't get the icon overlay anymore.
                            //
                            // This can happen if there is a handle open on a file,
                            // or if there is a view open on a directory, in which
                            // case there is a change notification handle open. It
                            // will also happen (later) for any parent directories,
                            // since they are not empty.
                            //
                            CSCUnpinFile(pszPath,
                                         FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER,
                                         NULL,
                                         NULL,
                                         NULL);
                        }

                        ShellChangeNotify(pszPath, &cfd.fd, FALSE, lShellEvent);

                        if (!bIsDirectory && m_pfnCbk)
                        {
                            bContinue = boolify((*m_pfnCbk)(this));
                            m_iFile++;
                        }
                    }
                }
            }

            // Remove the file spec
            pszPath[cchPath] = TEXT('\0');
        }
        while(bContinue && CacheFindNext(hFind, &cfd));

        // Remove the trailing backslash
        pszPath[cchPath-1] = TEXT('\0');
    }

    return bContinue;
}



//
// Public function for purging cache contents.
//
HRESULT
CCachePurger::Process(
    DWORD dwPhase
    )
{
    HRESULT hr = NOERROR;

    if (!m_bIsValid)
        return E_OUTOFMEMORY;  // Failed ctor.

    m_dwPhase = dwPhase;

    if (PURGE_PHASE_SCAN == dwPhase)
    {
        //
        // At start of scanning phase, get the max bytes and file count 
        // from the CSC database.  This will let us provide meaningful 
        // progress data during the scanning phase.
        //
        ULARGE_INTEGER ulTotalBytes = {0, 0};
        ULARGE_INTEGER ulUsedBytes  = {0, 0};
        DWORD dwTotalFiles          = 0;
        DWORD dwTotalDirs           = 0;
        TCHAR szVolume[MAX_PATH];
        CSCGetSpaceUsage(szVolume,
                         ARRAYSIZE(szVolume),
                         &ulTotalBytes.HighPart,
                         &ulTotalBytes.LowPart,
                         &ulUsedBytes.HighPart,
                         &ulUsedBytes.LowPart,
                         &dwTotalFiles,
                         &dwTotalDirs);

        m_cFilesToScan     = dwTotalFiles + dwTotalDirs;
        m_ullBytesToScan   = ulTotalBytes.QuadPart;
        m_ullBytesToDelete = 0;
        m_ullBytesDeleted  = 0;
        m_ullBytesScanned  = 0;
        m_ullFileBytes     = 0;
        m_cFilesToDelete   = 0;
        m_cFilesDeleted    = 0;
        m_cFilesScanned    = 0;
        m_dwFileAttributes = 0;
        m_dwResult         = 0;
        m_pszFile          = NULL;
        m_bWillDelete      = false;
    }
    m_iFile = 0; // Reset this for each phase.

    bool bContinue = true;
    CscFindData cfd;
    TCHAR szPath[PURGE_BUFFER_LENGTH];
    if (0 < m_sel.ShareCount())
    {
        //
        // Delete 1+ (but not all) shares.
        //
        for (int i = 0; i < m_sel.ShareCount(); i++)
        {
            if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), m_sel.ShareName(i))))
            {
                cfd.dwStatus = 0;
                CSCQueryFileStatus(szPath, &cfd.dwStatus, NULL, NULL);

                bContinue = ProcessDirectory(szPath, 
                                             dwPhase, 
                                             boolify(FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & cfd.dwStatus));
                                             
                if (PURGE_PHASE_DELETE == dwPhase)
                {
                    LONG lShellEvent = SHCNE_UPDATEITEM;

                    if (ERROR_SUCCESS == CscDelete(szPath))
                    {
                        if (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & cfd.dwStatus)
                        {
                            lShellEvent = SHCNE_RMDIR;
                        }
                    }
                    else
                    {
                        //
                        // NTRAID#NTBUG9-213486-2001/01/29-jeffreys
                        //
                        // If unable to delete, make sure it's unpinned.
                        //
                        CSCUnpinFile(szPath,
                                     FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER,
                                     NULL,
                                     NULL,
                                     NULL);
                    }

                    ZeroMemory(&cfd.fd, sizeof(cfd.fd));
                    cfd.fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                    StringCchCopy(cfd.fd.cFileName, ARRAYSIZE(cfd.fd.cFileName), szPath);
                    ShellChangeNotify(szPath, &cfd.fd, FALSE, lShellEvent);
                }
            }
        }

        if (PURGE_PHASE_DELETE == dwPhase)
        {
            //
            // On the DELETE phase always try to remove any empty
            // share entries from the database.  CSCDelete will
            // harmlessly fail if the share entry cannot be deleted.
            //
            CCscFindHandle hFind(CacheFindFirst(NULL, m_sel.UserSid(), &cfd));
            if (hFind.IsValid())
            {
                do
                {
                    // Don't unpin on failure here. The user wants to keep these.
                    if (ERROR_SUCCESS == CscDelete(cfd.fd.cFileName))
                    {
                        ShellChangeNotify(cfd.fd.cFileName,
                                          &cfd.fd,
                                          FALSE,
                                          (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & cfd.dwStatus) ? SHCNE_RMDIR : SHCNE_UPDATEITEM);
                    }
                }
                while(CacheFindNext(hFind, &cfd));
            }
        }
    }
    else
    {
        //
        // Delete all shares.
        //
        CCscFindHandle hFind(CacheFindFirst(NULL, m_sel.UserSid(), &cfd));
        if (hFind.IsValid())
        {
            do
            {
                if (SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), cfd.fd.cFileName)))
                {
                    bContinue = ProcessDirectory(szPath, 
                                                 dwPhase,
                                                 boolify(FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & cfd.dwStatus));
                    if (PURGE_PHASE_DELETE == dwPhase)
                    {
                        LONG lShellEvent = SHCNE_UPDATEITEM;

                        if (ERROR_SUCCESS == CscDelete(szPath))
                        {
                            if (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & cfd.dwStatus)
                            {
                                lShellEvent = SHCNE_RMDIR;
                            }
                        }
                        else
                        {
                            //
                            // NTRAID#NTBUG9-213486-2001/01/29-jeffreys
                            //
                            // If unable to delete, make sure it's unpinned.
                            //
                            CSCUnpinFile(szPath,
                                         FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER,
                                         NULL,
                                         NULL,
                                         NULL);
                        }

                        ShellChangeNotify(szPath, &cfd.fd, FALSE, lShellEvent);
                    }
                }
            }
            while(bContinue && CacheFindNext(hFind, &cfd));
        }
    }

    //
    // Flush any pending notifications
    //
    ShellChangeNotify(NULL, TRUE);

    return hr;
}


//
// Displays a modal dialog to get cache purging confirmation from the 
// user.  Let's user indicate if they want to purge only temp files
// from the cache or both temp and pinned.
//
// Returns PURGE_FLAG_XXXX flags and a list of share names
// in the CCachePurgerSel object.
//
void
CCachePurger::AskUserWhatToPurge(
    HWND hwndParent,
    CCachePurgerSel *pSel
    )
{
    CConfirmPurgeDialog dlg;
    dlg.Run(GetModuleHandle(TEXT("cscui.dll")), hwndParent, pSel);
}


//
// Returns:
//      0 = User cancelled.
//      1 = User pressed OK.
//
// Returns PURGE_FLAG_XXXX flags and a list of share names
// in the CCachePurgerSel object.
//
int
CConfirmPurgeDialog::Run(
    HINSTANCE hInstance,
    HWND hwndParent,
    CCachePurgerSel *pSel        // We don't "own" this.  Merely a WRITE reference.
    )
{
    TraceAssert(NULL != hInstance);
    TraceAssert(NULL != hwndParent);
    TraceAssert(NULL != pSel);
   
    m_hInstance = hInstance;

    m_pSel = pSel;

    int iResult = (int)DialogBoxParam(hInstance, 
                                      MAKEINTRESOURCE(IDD_CONFIRM_PURGE),
                                      hwndParent,
                                      DlgProc,
                                      (LPARAM)this);
    if (-1 == iResult)
    {
        Trace((TEXT("Error %d creating delete confirmation dialog"), GetLastError()));
    }
    return iResult;
}




INT_PTR CALLBACK
CConfirmPurgeDialog::DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CConfirmPurgeDialog *pThis = reinterpret_cast<CConfirmPurgeDialog *>(GetWindowLongPtr(hwnd, DWLP_USER));

    switch(message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
            pThis = reinterpret_cast<CConfirmPurgeDialog *>(lParam);
            TraceAssert(NULL != pThis);
            pThis->OnInitDialog(hwnd);
            return TRUE;

        case WM_ENDSESSION:
            EndDialog(hwnd, IDNO);
            return FALSE;

        case WM_COMMAND:
        {
            int iResult = 0; // Assume [Cancel]
            switch(LOWORD(wParam))
            {
                case IDOK:
                    iResult = 1;
                    pThis->OnOk();
                    //
                    // Fall through...
                    //
                case IDCANCEL:
                    EndDialog(hwnd, iResult);
                    return FALSE;
            }
        }
        break;

        case WM_SETTINGCHANGE:
        case WM_SYSCOLORCHANGE:
            pThis->OnSettingChange(message, wParam, lParam);
            break;
            
        case WM_DESTROY:
            pThis->OnDestroy();
            pThis->m_hwnd = NULL;
            return FALSE;

        default:
            break;
    }
    return FALSE;
}


void
CConfirmPurgeDialog::OnInitDialog(
    HWND hwnd
    )
{
    TraceAssert(NULL != hwnd);

    RECT rc;
    m_hwnd   = hwnd;
    m_hwndLV = GetDlgItem(hwnd, IDC_LIST_PURGE);
    CheckDlgButton(hwnd, IDC_RBN_CONFIRMPURGE_UNPINNED, BST_CHECKED);
    CheckDlgButton(hwnd, IDC_RBN_CONFIRMPURGE_ALL,      BST_UNCHECKED);

    //
    // Turn on checkboxes in the listview.
    //
    ListView_SetExtendedListViewStyleEx(m_hwndLV, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);
    //
    // Add the single column to the listview.
    //
    GetClientRect(m_hwndLV, &rc);

    LV_COLUMN col = { LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM, 
                      LVCFMT_LEFT, 
                      rc.right - rc.left, 
                      TEXT(""), 
                      0, 
                      0 };

    ListView_InsertColumn(m_hwndLV, 0, &col);

    //
    // Create the image list for the listview.
    //
    HIMAGELIST hSmallImages = ImageList_Create(16, 16, ILC_MASK, 1, 0);
    if (NULL != hSmallImages)
    {
        HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SHARE));
        if (NULL != hIcon)
        {
            ImageList_AddIcon(hSmallImages, hIcon);
        }
        ListView_SetImageList(m_hwndLV, hSmallImages, LVSIL_SMALL);        
    }

    //
    // Fill "shares" list with share names.
    //
    CscFindData cfd;
    CCscFindHandle hFind(CacheFindFirst(NULL, &cfd));
    if (hFind.IsValid())
    {
        LPITEMIDLIST pidl = NULL;
        SHFILEINFO sfi;
        CSCSHARESTATS ss;
        CSCGETSTATSINFO si = { SSEF_NONE, SSUF_TOTAL, true, false };
         
        do
        {
            _GetShareStatisticsForUser(cfd.fd.cFileName, &si, &ss);
            if (0 < ss.cTotal)
            {
                ZeroMemory(&sfi, sizeof(sfi));
                if (SUCCEEDED(SHSimpleIDListFromFindData(cfd.fd.cFileName, &cfd.fd, &pidl)))
                {
                    SHGetFileInfo((LPCTSTR)pidl,
                                  0,
                                  &sfi,
                                  sizeof(sfi),
                                  SHGFI_PIDL | SHGFI_DISPLAYNAME);
                    SHFree(pidl);
                }
                if (sfi.szDisplayName[0] != TEXT('\0'))
                {
                    //
                    // Each item's lParam contains a pointer to the
                    // UNC path allocated on the heap.  Must be deleted
                    // in OnDestroy().
                    //
                    LPTSTR pszFileName = StrDup(cfd.fd.cFileName);
                    if (NULL != pszFileName)
                    {
                        int iItem = LVAddItem(m_hwndLV, sfi.szDisplayName, (LPARAM)pszFileName);
                        if (0 <= iItem)
                        {
                            //
                            // All items are initially checked.
                            //
                            ListView_SetCheckState(m_hwndLV, iItem, TRUE);
                        }
                        else
                        {
                            LocalFree(pszFileName);
                        }
                    }
                }
            }
        }
        while(CacheFindNext(hFind, &cfd));
    }
    if (0 == ListView_GetItemCount(m_hwndLV))
    {
        //
        // No items are in the listview.
        // Disable all of the controls, hide the "OK" button and 
        // change the "Cancel" button to "Close".
        //
        const UINT rgidCtls[] = { IDC_TXT_CONFIRMPURGE3,
                                  IDC_RBN_CONFIRMPURGE_UNPINNED,
                                  IDC_RBN_CONFIRMPURGE_ALL,
                                  IDC_LIST_PURGE,
                                  IDOK};
                                  
        ShowWindow(GetDlgItem(m_hwnd, IDOK), SW_HIDE);

        for (int i = 0; i < ARRAYSIZE(rgidCtls); i++)                                  
        {
            EnableWindow(GetDlgItem(m_hwnd, rgidCtls[i]), FALSE);
        }

        TCHAR szText[MAX_PATH];
        LoadString(m_hInstance, IDS_BTN_TITLE_CLOSE, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(m_hwnd, IDCANCEL), szText);
        //
        // Replace the listview's caption with something like "There are
        // no offline files to delete".
        //
        LoadString(m_hInstance, IDS_TXT_NO_FILES_TO_DELETE, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(m_hwnd, IDC_TXT_CONFIRMPURGE2), szText);
        //
        // Uncheck both radio buttons.
        //
        CheckDlgButton(m_hwnd, IDC_RBN_CONFIRMPURGE_UNPINNED, BST_UNCHECKED);
        CheckDlgButton(m_hwnd, IDC_RBN_CONFIRMPURGE_ALL, BST_UNCHECKED);
    }
}


LPARAM
CConfirmPurgeDialog::LVGetItemData(
    HWND hwndLV,
    int i
    )
{
    LVITEM item;
    item.mask     = LVIF_PARAM;
    item.iItem    = i;
    item.iSubItem = 0;

    if (ListView_GetItem(hwndLV, &item))
    {
        return item.lParam;
    }
    return 0;
}


int
CConfirmPurgeDialog::LVAddItem(
    HWND hwndLV,
    LPCTSTR pszItem,
    LPARAM lParam
    )
{
    LVITEM item;
    item.mask     = LVIF_TEXT | LVIF_PARAM;
    item.pszText  = (LPTSTR)pszItem;
    item.iItem    = ListView_GetItemCount(hwndLV);
    item.iSubItem = 0;
    item.lParam   = lParam;

    return ListView_InsertItem(hwndLV, &item);
}


void 
CConfirmPurgeDialog::OnOk(
    void
    )
{
    const int cShares = ListView_GetItemCount(m_hwndLV);
    for (int i = 0; i < cShares; i++)
    {
        if (0 != ListView_GetCheckState(m_hwndLV, i))
        {
            m_pSel->AddShareName((LPCTSTR)LVGetItemData(m_hwndLV, i));
        }
    }
    
    if (0 < m_pSel->ShareCount())
    {
        m_pSel->SetFlags((BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_RBN_CONFIRMPURGE_UNPINNED)) ? 
                          PURGE_FLAG_UNPINNED : PURGE_FLAG_ALL);
    }
    else
    {
        m_pSel->SetFlags(PURGE_FLAG_NONE);
    }
}


void
CConfirmPurgeDialog::OnDestroy(
    void
    )
{
    if (NULL != m_hwndLV)
    {
        const int cShares = ListView_GetItemCount(m_hwndLV);
        for (int i = 0; i < cShares; i++)
        {
            LPTSTR psz = (LPTSTR)LVGetItemData(m_hwndLV, i);
            if (NULL != psz)
            {
                LocalFree(psz);
            }
        }
    }
}

void
CConfirmPurgeDialog::OnSettingChange(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (NULL != m_hwndLV)
        SendMessage(m_hwndLV, uMsg, wParam, lParam);
}



CCachePurgerSel::~CCachePurgerSel(
    void
    )
{
    if (NULL != m_hdpaShares)
    {
        const int cShares = DPA_GetPtrCount(m_hdpaShares);
        for (int i = 0; i < cShares; i++)
        {
            LPTSTR psz = (LPTSTR)DPA_GetPtr(m_hdpaShares, i);
            if (NULL != psz)
            {
                LocalFree(psz);
            }
        }
        DPA_Destroy(m_hdpaShares);
    }
    if (NULL != m_psidUser)
    {
        LocalFree(m_psidUser);
    }
}



BOOL
CCachePurgerSel::SetUserSid(
    PSID psid
    )
{
    if (NULL != m_psidUser)
    {
        LocalFree(m_psidUser);
        m_psidUser = NULL;
    }
    if (NULL != psid && IsValidSid(psid))
    {
        DWORD cbSid = GetLengthSid(psid);
        PSID psidNew = (PSID)LocalAlloc(LPTR, cbSid);
        if (NULL != psidNew)
        {
            if (!CopySid(cbSid, psidNew, psid))
            {
                LocalFree(psidNew);
                psidNew = NULL;
            }
            m_psidUser = psidNew;
        }
    }
    return NULL != m_psidUser;
}


BOOL 
CCachePurgerSel::AddShareName(
    LPCTSTR pszShare
    )
{
    //
    // Be tolerant of a NULL pszShare pointer.
    //
    if (NULL != m_hdpaShares && NULL != pszShare)
    {
        LPTSTR pszCopy = StrDup(pszShare);
        if (NULL != pszCopy)
        {
            if (-1 != DPA_AppendPtr(m_hdpaShares, pszCopy))
            {
                return true;
            }
            LocalFree(pszCopy);
        }
    }
    return false;
}


typedef struct _RemoveFolderCBData
{
    PFN_CSCUIRemoveFolderCallback pfnCB;
    LPARAM lParam;
} RemoveFolderCBData, *PRemoveFolderCBData;

BOOL CALLBACK
_RemoveFolderCallback(CCachePurger *pPurger)
{
    PRemoveFolderCBData pcbdata = (PRemoveFolderCBData)pPurger->CallbackData();
    if (pcbdata->pfnCB)
        return pcbdata->pfnCB(pPurger->FileName(), pcbdata->lParam);
    return TRUE;
}

STDAPI
CSCUIRemoveFolderFromCache(LPCWSTR pszFolder,
                           DWORD /*dwReserved*/,    // can use for flags
                           PFN_CSCUIRemoveFolderCallback pfnCB,
                           LPARAM lParam)
{
    RemoveFolderCBData cbdata = { pfnCB, lParam };

    CCachePurgerSel sel;
    sel.SetFlags(PURGE_FLAG_ALL | PURGE_IGNORE_ACCESS);
    sel.AddShareName(pszFolder);

    CCachePurger purger(sel, _RemoveFolderCallback, &cbdata);

    return purger.Delete();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\options.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       options.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_OPTIONS_H
#define _INC_CSCUI_OPTIONS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: options.h

    Description: 
            

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    04/15/98    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef _INC_CSCVIEW_CONFIG_H
#   include "config.h"
#endif

#ifndef _INC_CSCUI_UIHELP_H
#   include "uihelp.h"
#endif

#ifndef _INC_MATH
#   include <math.h>
#endif

#ifndef _INC_CSCUI_PURGE_H
#   include "purge.h"
#endif

#include "resource.h"

//
// The "Advanced" dialog invoked from the "Advanced" button on the 
// "Offline Files" prop page.
//
class CAdvOptDlg
{
    public:
        enum 
        {
            //
            // Listview subitem IDs.
            // 
            iLVSUBITEM_SERVER = 0,
            iLVSUBITEM_ACTION = 1
        };

        CAdvOptDlg(HINSTANCE hInstance, 
                   HWND hwndParent)
            : m_hInstance(hInstance),
              m_hwndParent(hwndParent),
              m_hwndDlg(NULL),
              m_hwndLV(NULL),
              m_iLastColSorted(-1),
              m_bSortAscending(true),
              m_bNoConfigGoOfflineAction(false) { }

        int Run(void);

    protected:
        BOOL OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lInitParam);
        BOOL OnNotify(HWND hDlg, int idCtl, LPNMHDR pnmhdr);
        BOOL OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
        BOOL OnDestroy(HWND hDlg);
        BOOL OnContextMenu(WPARAM wParam, LPARAM lParam);
        BOOL OnHelp(HWND hDlg, LPHELPINFO pHelpInfo);

    private:
        //
        // Structure to associate a radio button with an offline action code.
        //
        struct CtlActions
        {
            UINT                    idRbn;
            CConfig::OfflineAction action;
        };

        //
        // Class to describe the state of controls in the dialog.  Used to 
        // determine if user has changed anything.
        //
        class PgState
        {
            public:
                PgState(void)
                    : m_DefaultGoOfflineAction(CConfig::eGoOfflineSilent),
                      m_hdpaCustomGoOfflineActions(DPA_Create(4)) { }

                ~PgState(void);

                void SetDefGoOfflineAction(CConfig::OfflineAction action)
                    { m_DefaultGoOfflineAction = action; }

                CConfig::OfflineAction GetDefGoOfflineAction(void) const
                    { return m_DefaultGoOfflineAction; }

                void SetCustomGoOfflineActions(HWND hwndLV);

                HDPA GetCustomGoOfflineActions(void) const
                    { return m_hdpaCustomGoOfflineActions; }

                bool operator == (const PgState& rhs) const;

                bool operator != (const PgState& rhs) const
                    { return !(*this == rhs); }

            private:
                CConfig::OfflineAction  m_DefaultGoOfflineAction;
                HDPA                    m_hdpaCustomGoOfflineActions;
        };

        HINSTANCE    m_hInstance;
        HWND         m_hwndParent;
        HWND         m_hwndDlg;
        HWND         m_hwndLV;
        int          m_iLastColSorted;
        PgState      m_state;         // State on creation.
        bool         m_bSortAscending;
        bool         m_bNoConfigGoOfflineAction;

        static const CtlActions m_rgCtlActions[CConfig::eNumOfflineActions];
        static const DWORD m_rgHelpIDs[];

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        void ApplySettings(void);
        void EnableCtls(HWND hwnd);
        void CreateListColumns(HWND hwndList);
        void OnLVN_GetDispInfo(LV_DISPINFO *plvdi);
        void OnLVN_ColumnClick(NM_LISTVIEW *pnmlv);
        void OnLVN_ItemChanged(NM_LISTVIEW *pnmlv);
        void OnLVN_KeyDown(NMLVKEYDOWN *plvkd);
        void OnContextMenuItemSelected(int idMenuItem);
        static int CALLBACK CompareLVItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
        void GetPageState(PgState *pps);
        CConfig::OfflineAction GetCurrentGoOfflineAction(void) const;
        void AddCustomGoOfflineAction(LPCTSTR pszServer, CConfig::OfflineAction action);
        void ReplaceCustomGoOfflineAction(CConfig::CustomGOA *pGOA, int iItem, CConfig::OfflineAction action);
        void OnAddCustomGoOfflineAction(void);
        void OnEditCustomGoOfflineAction(void);
        void OnDeleteCustomGoOfflineAction(void);
        int CountSelectedListviewItems(int *pcSetByPolicy);
        void DeleteSelectedListviewItems(void);
        void SetSelectedListviewItemsAction(CConfig::OfflineAction action);
        void FocusOnSomethingInListview(void);
        int GetFirstSelectedLVItemRect(RECT *prc);
        bool IsCustomActionListviewEnabled(void) const
            { return boolify(IsWindowEnabled(GetDlgItem(m_hwndDlg, IDC_GRP_CUSTGOOFFLINE))); }
        static DWORD CheckNetServer(LPCTSTR pszServer);
        static int AddGOAToListView(HWND hwndLV, int iItem, const CConfig::CustomGOA& goa);
        static CConfig::CustomGOA *FindGOAInListView(HWND hwndLV, LPCTSTR pszServer, int *piItem);
        static CConfig::CustomGOA *GetListviewObject(HWND hwndLV, int iItem);

        //
        // PgState calls GetListviewObject.
        //
        friend void PgState::SetCustomGoOfflineActions(HWND);
};

//
// The "Offline Files" property sheet page.
//
class COfflineFilesPage
{
    public:
        COfflineFilesPage(HINSTANCE hInstance, LPUNKNOWN pUnkOuter)
            : m_hInstance(hInstance),
              m_hwndDlg(NULL),
              m_pUnkOuter(pUnkOuter),
              m_hwndSlider(NULL),
              m_hwndEncryptTooltip(NULL),
              m_pfnOldPropSheetWndProc(NULL),
              m_pfnOldEncryptionTooltipWndProc(NULL),
              m_bUserHasMachineAccess(false),
              m_bCscVolSupportsEncryption(false),
              m_bApplyingSettings(false),
              m_bFirstActivate(true),
              m_iSliderMax(0),
              m_llAvailableDiskSpace(0) { }

        UINT GetDlgTemplateID(void) const
            { return IDD_CSC_OPTIONS; }

        LPFNPSPCALLBACK GetCallbackFuncPtr(void) const
            { return PageCallback; }

        DLGPROC GetDlgProcPtr(void) const
            { return DlgProc; }

        //
        // This is called by the "Advanced" page to determine if controls can
        // be enabled or not.
        //
        bool IsCscEnabledChecked(void) const
            { return m_hwndDlg && BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_ENABLE_CSC); }

    protected:
        BOOL OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lInitParam);
        BOOL OnNotify(HWND hDlg, int idCtl, LPNMHDR pnmhdr);
        BOOL OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
        BOOL OnDestroy(HWND hDlg);
        BOOL OnContextMenu(HWND hwndItem, int xPos, int yPos);
        BOOL ApplySettings(HWND hDlg, bool bPropSheetClosing);
        BOOL OnHelp(HWND hDlg, LPHELPINFO pHelpInfo);
        BOOL OnSettingChange(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    private:
        class PgState
        {
            public:
                PgState(void)
                    : m_bCscEnabled(false),
                      m_bFullSyncAtLogoff(false),
                      m_bFullSyncAtLogon(false),
                      m_bLinkOnDesktop(false),
                      m_bReminders(false),
                      m_iEncrypted(BST_UNCHECKED),
                      m_iReminderFreq(0),
                      m_iSliderPos(0) { }

                void SetCscEnabled(bool bCscEnabled)
                    { m_bCscEnabled = bCscEnabled; }

                bool GetCscEnabled(void) const
                    { return m_bCscEnabled; }

                void SetFullSyncAtLogon(bool bFullSync)
                    { m_bFullSyncAtLogon = bFullSync; }

                bool GetFullSyncAtLogon(void) const
                    { return m_bFullSyncAtLogon; }

                void SetFullSyncAtLogoff(bool bFullSync)
                    { m_bFullSyncAtLogoff = bFullSync; }

                bool GetFullSyncAtLogoff(void) const
                    { return m_bFullSyncAtLogoff; }

                void SetEncrypted(int iEncrypted)
                    { m_iEncrypted = iEncrypted; }

                int GetEncrypted(void) const
                    { return m_iEncrypted; }

                void SetSliderPos(int iSliderPos)
                    { m_iSliderPos = iSliderPos; }

                int GetSliderPos(void) const
                    { return m_iSliderPos; }

                void SetRemindersEnabled(bool bEnabled)
                    { m_bReminders = bEnabled; }

                bool GetRemindersEnabled(void) const
                    { return m_bReminders; }

                void SetReminderFreq(int iMinutes)
                    { m_iReminderFreq = iMinutes; }

                int GetReminderFreq(void) const
                    { return m_iReminderFreq; }

                void SetLinkOnDesktop(bool bEnabled)
                    { m_bLinkOnDesktop = bEnabled; }

                bool GetLinkOnDesktop(void) const
                    { return m_bLinkOnDesktop; }

                bool operator == (const PgState& rhs) const
                    { return (m_bCscEnabled       == rhs.m_bCscEnabled &&
                              m_bFullSyncAtLogoff == rhs.m_bFullSyncAtLogoff &&
                              m_bFullSyncAtLogon  == rhs.m_bFullSyncAtLogon &&
                              m_bLinkOnDesktop    == rhs.m_bLinkOnDesktop && 
                              m_iEncrypted        == rhs.m_iEncrypted &&
                              m_iSliderPos        == rhs.m_iSliderPos &&
                              m_bReminders        == rhs.m_bReminders &&
                              m_iReminderFreq     == rhs.m_iReminderFreq); }

                bool operator != (const PgState& rhs) const
                    { return !(*this == rhs); }

            private:
                bool m_bCscEnabled;
                bool m_bFullSyncAtLogon;
                bool m_bFullSyncAtLogoff;
                bool m_bLinkOnDesktop;
                bool m_bReminders;
                int  m_iEncrypted;  // BST_CHECKED, BST_UNCHECKED, BST_INDETERMINATE
                int  m_iSliderPos;
                int  m_iReminderFreq;
        };

        class CConfigItems
        {
            public:
                CConfigItems(void) { ZeroMemory(m_rgItems, sizeof(m_rgItems)); }

                void Load(void);

                CConfig::SyncAction SyncAtLogoff(void) const
                    { return CConfig::SyncAction(m_rgItems[iCFG_SYNCATLOGOFF].dwValue); }
                CConfig::SyncAction SyncAtLogon(void) const
                    { return CConfig::SyncAction(m_rgItems[iCFG_SYNCATLOGON].dwValue); }
                bool NoConfigCache(void) const
                    { return boolify(m_rgItems[iCFG_NOCONFIGCACHE].dwValue); }
                bool NoConfigSyncAtLogoff(void) const
                    { return m_rgItems[iCFG_SYNCATLOGOFF].bSetByPolicy; }
                bool NoConfigSyncAtLogon(void) const
                    { return m_rgItems[iCFG_SYNCATLOGON].bSetByPolicy; }
                bool NoReminders(void) const
                    { return boolify(m_rgItems[iCFG_NOREMINDERS].dwValue); }
                bool NoConfigReminders(void) const
                    { return m_rgItems[iCFG_NOREMINDERS].bSetByPolicy; }
                bool NoConfigCacheSize(void) const
                    { return m_rgItems[iCFG_DEFCACHESIZE].bSetByPolicy; }
                bool NoCacheViewer(void) const
                    { return boolify(m_rgItems[iCFG_NOCACHEVIEWER].dwValue); }
                bool NoConfigCscEnabled(void) const
                    { return boolify(m_rgItems[iCFG_CSCENABLED].bSetByPolicy); }
                bool NoConfigReminderFreqMinutes(void) const
                    { return boolify(m_rgItems[iCFG_REMINDERFREQMINUTES].bSetByPolicy); }
                int ReminderFreqMinutes(void) const
                    { return int(m_rgItems[iCFG_REMINDERFREQMINUTES].dwValue); }
                bool EncryptCache(void) const
                    { return boolify(m_rgItems[iCFG_ENCRYPTCACHE].dwValue); }
                bool NoConfigEncryptCache(void) const
                    { return boolify(m_rgItems[iCFG_ENCRYPTCACHE].bSetByPolicy); }

            private:
                struct ConfigItem
                {
                    DWORD dwValue;
                    bool bSetByPolicy;
                };

                enum eConfigItems
                {
                    iCFG_NOCONFIGCACHE,
                    iCFG_SYNCATLOGOFF,
                    iCFG_SYNCATLOGON,
                    iCFG_NOREMINDERS,
                    iCFG_DEFCACHESIZE,
                    iCFG_NOCACHEVIEWER,
                    iCFG_CSCENABLED,
                    iCFG_REMINDERFREQMINUTES,
                    iCFG_ENCRYPTCACHE,
                    MAX_CONFIG_ITEMS
                };

                ConfigItem m_rgItems[MAX_CONFIG_ITEMS];
        };


        HINSTANCE    m_hInstance;
        HWND         m_hwndDlg;
        LPUNKNOWN    m_pUnkOuter;
        HWND         m_hwndSlider;
        HWND         m_hwndEncryptTooltip;
        int          m_iSliderMax;
        LONGLONG     m_llAvailableDiskSpace;
        PgState      m_state;
        CConfigItems m_config;
        TCHAR        m_szEncryptTooltipBody[MAX_PATH];
        WNDPROC      m_pfnOldPropSheetWndProc;
        WNDPROC      m_pfnOldEncryptionTooltipWndProc;
        bool         m_bUserHasMachineAccess;
        bool         m_bCscVolSupportsEncryption;
        bool         m_bApplyingSettings;
        bool         m_bFirstActivate;
        static const DWORD m_rgHelpIDs[];

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        static UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
        static BOOL CALLBACK PurgeCacheCallback(CCachePurger *pPurger);
        static DWORD CALLBACK EncryptDecryptCallback(LPCWSTR lpszName, DWORD dwStatus, DWORD dwHintFlags,
                                                     DWORD dwPinCount, WIN32_FIND_DATAW *pFind32, DWORD dwReason,
                                                     DWORD dwParam1, DWORD dwParam2, DWORD_PTR dwContext);
        static LRESULT CALLBACK PropSheetSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK EncryptionTooltipSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        void OnDeleteCache(void);
        void OnFormatCache(void);
        void EnableCtls(HWND hwnd);
        void InitSlider(HWND hwndDlg, LONGLONG llMaxDiskSpace, LONGLONG llUsedDiskSpace);
        void OnHScroll(HWND hwndDlg, HWND hwndCtl, int iCode, int iPos);
        void SetCacheSizeDisplay(HWND hwndCtl, int iThumbPos);
        void EncryptOrDecryptCache(bool bEncrypt, bool bPropSheetClosing);
        void CreateEncryptionTooltip(void);
        void ShowEncryptionTooltip(bool bEncrypted);
        void HideEncryptionTooltip(void);
        void TrackEncryptionTooltip(void);
        void UpdateEncryptionCheckbox(void);
        void UpdateEncryptionTooltipBalloon(void);
        void UpdateEncryptionCheckboxOrBalloon(bool bCheckbox);
        void OnTTN_GetDispInfo(LPNMTTDISPINFO pttdi);
        double Fx(double x);
        double Fy(double y);
        double Rx(double x);
        LONGLONG DiskSpaceAtThumb(int t);
        int ThumbAtPctDiskSpace(double pct);
        void GetPageState(PgState *pps);
        void HandlePageStateChange(void);
        bool IsLinkOnDesktop(LPTSTR pszPathOut = NULL, UINT cchPathOut = 0);
        bool EnableOrDisableCsc(bool bEnable, bool *pbReboot, DWORD *pdwError);
        bool DisableForTerminalServer(void);
        HRESULT _ApplyEnabledSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow, bool *pbUpdateSysTrayUI);
        HRESULT _ApplySyncAtLogoffSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow);
        HRESULT _ApplySyncAtLogonSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow);
        HRESULT _ApplyReminderSettings(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow);
        HRESULT _ApplyFolderLinkSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow);
        HRESULT _ApplyCacheSizeSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow);
        HRESULT _ApplyEncryptionSetting(HKEY hkeyLM, HKEY hkeyCU, const PgState& pgstNow, bool bPropSheetClosing, bool *pbPerformed);
};


class COfflineFilesSheet
{
    public:
        static DWORD CreateAndRun(HINSTANCE hInstance,
                                  HWND hwndParent,
                                  LONG *pDllRefCount,
                                  BOOL bAsync=TRUE);

    private:
        //
        // Increase this if more pages are required.
        // Currently, we only need the "Offline Files" page.
        //
        enum { MAXPAGES = 1 };

        HINSTANCE m_hInstance;
        HWND      m_hwndParent;
        LONG     *m_pDllRefCount;

        //
        // Trivial class for passing parameters to share dialog thread proc.
        //
        class ThreadParams
        {
            public:
                ThreadParams(HWND hwndParent, LONG *pDllRefCount)
                    : m_hwndParent(hwndParent),
                      m_hInstance(NULL),
                      m_pDllRefCount(pDllRefCount) { }
    
                HWND      m_hwndParent;
                HINSTANCE m_hInstance;
                LONG     *m_pDllRefCount;
  
                void SetModuleHandle(HINSTANCE hInstance)
                    { m_hInstance = hInstance; }
        };

        COfflineFilesSheet(HINSTANCE hInstance,
                           LONG *pDllRefCount,
                           HWND hwndParent);

        ~COfflineFilesSheet(void);

        DWORD Run(void);
        static DWORD WINAPI ThreadProc(LPVOID pvParam);
        static BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
};


class CscOptPropSheetExt : public IShellExtInit, IShellPropSheetExt
{
    public:
        CscOptPropSheetExt(HINSTANCE hInstance, LONG *pDllRefCnt);
        ~CscOptPropSheetExt(void);

        //
        // IUnknown
        //
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        //
        // IShellExtInit method
        //
        STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);
        //
        // IShellPropSheetExt
        //
        STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
            { return E_NOTIMPL; }

        //
        // Change this if you add or remove any prop pages from this prop sheet ext.
        //
        enum { NUMPAGES = 2 };

    private:
        LONG               m_cRef;
        HINSTANCE          m_hInstance;
        LONG              *m_pDllRefCnt;
        COfflineFilesPage *m_pOfflineFoldersPg;

        HRESULT AddPage(LPFNADDPROPSHEETPAGE lpfnAddPage, 
                        LPARAM lParam, 
                        const COfflineFilesPage& pg,
                        HPROPSHEETPAGE *phPage);
};


class CustomGOAAddDlg
{
    public:
        CustomGOAAddDlg(HINSTANCE hInstance, 
                        HWND hwndParent, 
                        LPTSTR pszServer,
                        UINT cchServer,
                        CConfig::OfflineAction *pAction);
        int Run(void);

    private:
        //
        // Structure to associate a radio button with an offline action code.
        //
        struct CtlActions
        {
            UINT                   idRbn;
            CConfig::OfflineAction action;
        };
        HINSTANCE m_hInstance;
        HWND      m_hwndParent;
        HWND      m_hwndDlg;
        HWND      m_hwndEdit;
        LPTSTR    m_pszServer;  // Output.
        UINT      m_cchServer;
        CConfig::OfflineAction *m_pAction;
        static const CtlActions m_rgCtlActions[CConfig::eNumOfflineActions];
        static const DWORD m_rgHelpIDs[];

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        BOOL OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lInitParam);
        BOOL OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
        BOOL OnDestroy(HWND hDlg);
        BOOL OnHelp(HWND hDlg, LPHELPINFO pHelpInfo);
        BOOL OnContextMenu(HWND hwndItem, int xPos, int yPos);
        void BrowseForServer(HWND hDlg, LPTSTR pszServer, UINT cchServer);
        void GetActionInfo(LPTSTR pszServer, UINT cchServer, CConfig::OfflineAction *pAction);
        bool CheckServerNameEntered(void);
        void GetEnteredServerName(LPTSTR pszServer, UINT cchServer, bool bTrimLeadingJunk);
};

class CustomGOAEditDlg
{
    public:
        CustomGOAEditDlg(HINSTANCE hInstance, 
                         HWND hwndParent, 
                         LPCTSTR pszServer, 
                         CConfig::OfflineAction *pAction);
        int Run(void);

    private:
        //
        // Structure to associate a radio button with an offline action code.
        //
        struct CtlActions
        {
            UINT                   idRbn;
            CConfig::OfflineAction action;
        };
        HINSTANCE m_hInstance;
        HWND      m_hwndParent;
        HWND      m_hwndDlg;
        TCHAR     m_szServer[MAX_PATH];
        CConfig::OfflineAction *m_pAction;
        static const CtlActions m_rgCtlActions[CConfig::eNumOfflineActions];
        static const DWORD m_rgHelpIDs[];

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
        BOOL OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lInitParam);
        BOOL OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
        BOOL OnDestroy(HWND hDlg);
        BOOL OnHelp(HWND hDlg, LPHELPINFO pHelpInfo);
        BOOL OnContextMenu(HWND hwndItem, int xPos, int yPos);
        void GetActionInfo(CConfig::OfflineAction *pAction);
};



//-----------------------------------------------------------------------------
// Inline functions.
//-----------------------------------------------------------------------------
//
// This is the "gain" function for the slider and resulting value.
// Pass in a true position of the slider thumb and you get back 
// a scaled value for the thumb.  To change the gain, change
// this function.  Remember to change Fy() also.
//
inline double
COfflineFilesPage::Fx(
    double x
    )
{
    return (x * x) / 2.0;
}


//
// This is the "gain" function for the slider solved for 'y'.
// Pass in a virtual position for the thumb and you get back
// a true thumb position.
//
inline double
COfflineFilesPage::Fy(
    double y
    )
{
    return sqrt(2.0 * y);
}

//
// Ratio used to calculate the disk space value for a given
// true thumb position.  Give it a true thumb position between
// 0 and 100 and it will return a number between 0.0 and 1.0 that
// can be used to find the disk space.
// 
// DiskSpace = DiskSpaceMax * Rx(thumb)
//
inline double
COfflineFilesPage::Rx(
    double x
    )
{
    double denominator = Fx(m_iSliderMax);
    if (0.00001 < denominator)
        return Fx(x) / denominator;
    else
        return 1.0;
}

//
// Calculates the disk space value at a particular position of the
// slider thumb for values of 't' between 0 and 100.
//
inline LONGLONG
COfflineFilesPage::DiskSpaceAtThumb(
    int t
    )
{
    return LONGLONG(double(m_llAvailableDiskSpace) * Rx(t));
}

//
// Calculates the true thumb position for a given disk space
// percent value between 0.0 and 1.0.
// The expression breaks down as follows:
// 
//      double MaxVirtualThumb = Fx(m_iSliderMax);
//      double VirtualThumb    = MaxVirtualThumb * pct;
//      double TrueThumb       = Fy(VirtualThumb);
//
//      return round(TrueThumb);  // "round" used for illustration only.
//
inline int
COfflineFilesPage::ThumbAtPctDiskSpace(
    double pct
    )
{
    double t  = Fy(Fx(m_iSliderMax) * pct);
    double ft = floor(t);
    if (0.5 < t - ft)
    {
        //
        // Since the thumb position must be a whole number,
        // round up if necessary.  Typecast from double to int
        // merely truncates at the decimal point.
        //
        ft += 1.0;
    }
    return int(ft);
}


#endif // _INC_CSCUI_OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\security.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_SECURITY_H
#define _INC_CSCUI_SECURITY_H

DWORD 
Security_SetPrivilegeAttrib(
    LPCTSTR PrivilegeName, 
    DWORD NewPrivilegeAttribute, 
    DWORD *OldPrivilegeAttribute);

BOOL IsSidCurrentUser(PSID psid);
inline BOOL IsCurrentUserAnAdminMember(VOID) { return IsUserAnAdmin(); } // shlobjp.h, shell32p.lib

#endif _INC_CSCUI_SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\purge.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       purge.h
//
//--------------------------------------------------------------------------

#ifndef __CSCUI_PURGE_H
#define __CSCUI_PURGE_H

//
// Definitions for the dwFlags bits in PurgeCache().
//
#define PURGE_FLAG_NONE      0x00000000
#define PURGE_FLAG_PINNED    0x00000001
#define PURGE_FLAG_UNPINNED  0x00000002
#define PURGE_FLAG_ALL       0x00000003
#define PURGE_IGNORE_ACCESS  0x80000000
//
// Phase identification constants specified in dwPhase argument to PurgeCache
// and returned in PURGECALLBACKINFO.dwPhase.
// 
#define PURGE_PHASE_SCAN     0
#define PURGE_PHASE_DELETE   1

class CCachePurger;  // fwd decl.

//
// Purge callback function pointer type.
//
typedef BOOL (CALLBACK * LPFNPURGECALLBACK)(CCachePurger *pPurger);


class CCachePurgerSel
{
    public:
        CCachePurgerSel(void) 
            : m_dwFlags(0),
              m_hdpaShares(DPA_Create(8)),
              m_psidUser(NULL) { };

        ~CCachePurgerSel(void);

        DWORD Flags(void) const
            { return m_dwFlags; }

        BOOL SetUserSid(PSID psid);

        PSID UserSid(void) const
            { return m_psidUser; }

        int ShareCount(void) const
            { return m_hdpaShares ? DPA_GetPtrCount(m_hdpaShares) : 0; }

        LPCTSTR ShareName(int iShare) const
            { return m_hdpaShares ? (LPCTSTR)DPA_GetPtr(m_hdpaShares, iShare) : NULL; }

        DWORD SetFlags(DWORD dwFlags)
            { m_dwFlags = dwFlags; return m_dwFlags; }

        DWORD AddFlags(DWORD dwFlags)
            { m_dwFlags |= dwFlags; return m_dwFlags; }

        BOOL AddShareName(LPCTSTR pszShare);

    private:
        DWORD m_dwFlags;
        HDPA  m_hdpaShares;
        PSID  m_psidUser;

        LPTSTR MyStrDup(LPCTSTR psz);

        //
        // Prevent copy.
        //
        CCachePurgerSel(const CCachePurgerSel& rhs);
        CCachePurgerSel& operator = (const CCachePurgerSel& rhs);
};





class CCachePurger
{
    public:
        CCachePurger(const CCachePurgerSel& desc, 
                     LPFNPURGECALLBACK pfnCbk, 
                     LPVOID pvCbkData);

        ~CCachePurger(void);

        HRESULT Scan(void)
            { return Process(PURGE_PHASE_SCAN); }

        HRESULT Delete(void)
            { return Process(PURGE_PHASE_DELETE); }

        static void AskUserWhatToPurge(HWND hwndParent, CCachePurgerSel *pDesc);

        ULONGLONG BytesToScan(void) const
            { return m_ullBytesToScan; }

        ULONGLONG BytesScanned(void) const
            { return m_ullBytesScanned; }

        ULONGLONG BytesToDelete(void) const
            { return m_ullBytesToDelete; }

        ULONGLONG BytesDeleted(void) const
            { return m_ullBytesDeleted; }

        ULONGLONG FileBytes(void) const
            { return m_ullFileBytes; }

        DWORD Phase(void) const
            { return m_dwPhase; }

        DWORD FilesToScan(void) const
            { return m_cFilesToScan; }

        DWORD FilesToDelete(void) const
            { return m_cFilesToDelete; }

        DWORD FilesScanned(void) const
            { return m_cFilesScanned; }

        DWORD FilesDeleted(void) const
            { return m_cFilesDeleted; }

        DWORD FileOrdinal(void) const
            { return m_iFile; }

        DWORD FileAttributes(void) const
            { return m_dwFileAttributes; }

        DWORD FileDeleteResult(void) const
            { return m_dwResult; }

        LPCTSTR FileName(void) const
            { return m_pszFile; }

        LPVOID CallbackData(void) const
            { return m_pvCbkData; }

        BOOL WillDeleteThisFile(void) const
            { return m_bWillDelete; }

    private:
        //
        // State information to support callback info query functions.
        //
        ULONGLONG m_ullBytesToScan;   // Total bytes to scan.
        ULONGLONG m_ullBytesToDelete; // Total bytes to delete. Known after scanning.
        ULONGLONG m_ullBytesScanned;  // Total bytes scanned.
        ULONGLONG m_ullBytesDeleted;  // Total bytes deleted.
        ULONGLONG m_ullFileBytes;     // Size of this file in bytes.
        DWORD     m_dwPhase;          // PURGE_PHASE_XXXXXX value.
        DWORD     m_cFilesToScan;     // Total files to be scanned.
        DWORD     m_cFilesScanned;    // Total files actually scanned.
        DWORD     m_cFilesToDelete;   // Total files to delete.  Known after scanning.
        DWORD     m_cFilesDeleted;    // Total files actually deleted.
        DWORD     m_iFile;            // "This" file's number [0..(n-1)].
        DWORD     m_dwFileAttributes; // This file's Win32 file attributes.
        DWORD     m_dwResult;         // Win32 result code from CSCDelete()
        HANDLE    m_hgcPurgeInProgress;// Purge-in-progress counter.
        LPCTSTR   m_pszFile;          // This file's full path.
        LPVOID    m_pvCbkData;        // App data provided in DeleteCacheFiles().
        BOOL      m_bWillDelete;      // 1 == File will be deleted in delete phase.

        DWORD             m_dwFlags;     // PURGE_FLAG_XXXXX flags.
        LPFNPURGECALLBACK m_pfnCbk;      // Ptr to callback function.
        const CCachePurgerSel& m_sel;    // Ref to selection info.
        bool              m_bIsValid;    // Ctor success indicator.
        bool              m_bDelPinned;  // Do dwFlags say delete "pinned"?
        bool              m_bDelUnpinned;// Do dwFlags say delete "non-pinned"?
        bool              m_bUserIsAnAdmin;
        bool              m_bIgnoreAccess;

        HRESULT Process(DWORD dwPhase);
        bool ProcessDirectory(LPTSTR pszPath, DWORD dwPhase, bool bShareIsOffline);

        //
        // Prevent copy.
        //
        CCachePurger(const CCachePurger& rhs);
        CCachePurger& operator = (const CCachePurger& rhs);
};


#endif __CSCUI_PURGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\security.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       security.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "security.h"


DWORD 
Security_SetPrivilegeAttrib(
    LPCTSTR PrivilegeName, 
    DWORD NewPrivilegeAttribute, 
    DWORD *OldPrivilegeAttribute
    )
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //
    if(!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) 
    {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &TokenHandle)) 
    {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof(TOKEN_PRIVILEGES);
    if (!AdjustTokenPrivileges(
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof(TOKEN_PRIVILEGES),
                &OldTokenPrivileges,
                &ReturnLength
                )) 
    {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else 
    {
        if (NULL != OldPrivilegeAttribute) 
        {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return ERROR_SUCCESS;
    }
}


//
// Returns the SID of the currently logged on user.
// If the function succeeds, use the LocalFree API to 
// free the returned SID structure.
//
HRESULT
GetCurrentUserSid(
    PSID *ppsid
    )
{
    HRESULT hr  = E_FAIL;
    DWORD dwErr = 0;

    //
    // Get the token handle. First try the thread token then the process
    // token.  If these fail we return early.  No sense in continuing
    // on if we can't get a user token.
    //
    *ppsid = NULL;
    CWin32Handle hToken;
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_READ,
                         TRUE,
                         hToken.HandlePtr()))
    {
        if (ERROR_NO_TOKEN == GetLastError())
        {
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_READ,
                                  hToken.HandlePtr()))
            {
                dwErr = GetLastError();
                return HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Find operator's SID.
    //
    LPBYTE pbTokenInfo = NULL;
    DWORD cbTokenInfo = 0;
    cbTokenInfo = 0;
    if (!GetTokenInformation(hToken,
                             TokenUser,
                             NULL,
                             cbTokenInfo,
                             &cbTokenInfo))
    {
        dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
        {
            pbTokenInfo = new BYTE[cbTokenInfo];
            if (NULL == pbTokenInfo)
                hr = E_OUTOFMEMORY;
        }
        else
        {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    if (NULL != pbTokenInfo)
    {
        //
        // Get the user token information.
        //
        if (!GetTokenInformation(hToken,
                                 TokenUser,
                                 pbTokenInfo,
                                 cbTokenInfo,
                                 &cbTokenInfo))
        {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            SID_AND_ATTRIBUTES *psa = (SID_AND_ATTRIBUTES *)pbTokenInfo;
            int cbSid = GetLengthSid(psa->Sid);
            PSID psid = (PSID)LocalAlloc(LPTR, cbSid);

            if (NULL != psid)
            {
                CopySid(cbSid, psid, psa->Sid);
                if (IsValidSid(psid))
                {
                    //
                    // SID is valid.  Transfer buffer to caller.
                    //
                    *ppsid = psid;
                    hr = NOERROR;
                }
                else
                {
                    //
                    // SID is invalid.
                    //
                    LocalFree(psid);
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        delete[] pbTokenInfo;
    }
    return hr;
}


//
// Determines if a given SID is that of the current user.
//
BOOL IsSidCurrentUser(PSID psid)
{
    BOOL bIsCurrent = FALSE;
    PSID psidUser;
    if (SUCCEEDED(GetCurrentUserSid(&psidUser)))
    {
        bIsCurrent = EqualSid(psid, psidUser);
        LocalFree(psidUser);
    }
    return bIsCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\sharecnx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sharecnx.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "sharecnx.h"

//
// This class is a simple cache of net share names and some status flags.
// Initially, the only status maintained is to remember if there's an
// an open net connection for the share.
// The motivation for the cache is to avoid expensive net calls while
// we're cruising through lists of files (i.e. deleting files from the
// cache).  After we delete a file from the cache, it is effectively
// unpinned.  Therefore, we like to notify the shell so it can remove
// the "pinned" icon overlay from the affected file(s).  However,
// we don't want to hit the net with a change notify if there
// isn't an open connection to a file's parent share.  Before we issue
// a change notify, we just query this cache for a file using
// IsOpenConnectionPathUNC().  If there's no entry for the file's share,
// one is added and the connection status is obtained.  If there's
// already an entry, then we just return the status.  The public APIs
// support a "refresh" flag if refresh is desired.
// Additional status information could easily be added for each entry
// if it's needed later.
// [brianau - 12/12/98]
//

//-----------------------------------------------------------------------------
// CShareCnxStatusCache member functions.
//-----------------------------------------------------------------------------

CShareCnxStatusCache::CShareCnxStatusCache(
    void
    ) : m_hdpa(NULL)
{
}


CShareCnxStatusCache::~CShareCnxStatusCache(
    void
    )
{
    if (NULL != m_hdpa)
    {
        //
        // Delete all the entries then destroy the DPA.
        //
        int cEntries = Count();
        for (int i = 0; i < cEntries; i++)
        {
            delete GetEntry(i);
        }
        DPA_Destroy(m_hdpa);
    }
}


//
// Returns address of entry or NULL if not found.
//
CShareCnxStatusCache::Entry *
CShareCnxStatusCache::FindEntry(
    LPCTSTR pszShare
    ) const
{
    if (NULL != m_hdpa)
    {
        int cEntries = Count();
        for (int i = 0; i < cEntries; i++)
        {
            Entry *pEntry = GetEntry(i);
            if (NULL != pEntry && NULL != pEntry->Share())
            {
                if (0 == lstrcmpi(pszShare, pEntry->Share()))
                {
                    //
                    // Aha, we found a match.
                    //
                    return pEntry;
                }
            }
        }
    }
    return NULL;
}

    
//
// Creates a new entry and adds it to the DPA of entries.
// If successful, returns address of new entry.
// Does not check for duplicate entry before adding new one.
//
CShareCnxStatusCache::Entry *
CShareCnxStatusCache::AddEntry(
    LPCTSTR pszShare,
    DWORD dwStatus
    )
{
    Entry *pEntry = NULL;

    if (NULL == m_hdpa)
    {
        //
        // Must be first addition.  Create the DPA.
        //
        m_hdpa = DPA_Create(8);
    }

    if (NULL != m_hdpa)
    {
        int iEntry = -1;
        pEntry = new Entry(pszShare, dwStatus);
        if (NULL != pEntry && pEntry->IsValid())
        {
            //
            // We have a valid entry. Add it to the DPA.
            //
            iEntry = DPA_AppendPtr(m_hdpa, pEntry);
        }
        if (-1 == iEntry)
        {
            //
            // One of the following bad things happened:
            //
            //   1. Entry creation failed.  Most likely couldn't alloc string.
            //   2. Failed to add entry to DPA (out of memory).
            // 
            // Either way, destroy the entry and set the entry ptr so we 
            // return NULL.
            //
            delete pEntry;
            pEntry = NULL;
        }
    }
    return pEntry;
}        



//
// Determine if the net share associated with a UNC path (file or folder)
// has an open connection on this machine.
//
// Returns:
//    S_OK          = Open connection.
//    S_FALSE       = No open connection.
//    E_OUTOFMEMORY
//
HRESULT
CShareCnxStatusCache::IsOpenConnectionPathUNC(
    LPCTSTR pszPathUNC,
    bool bRefresh       // [optional].  Default = false.
    )
{
    //
    // Trim the path back to just the UNC share name.
    // Call IsOpenConnectionShare() to do the actual work.
    //
    TCHAR szShare[MAX_PATH];
    StringCchCopy(szShare, ARRAYSIZE(szShare), pszPathUNC);
    PathStripToRoot(szShare);
    return IsOpenConnectionShare(szShare, bRefresh);
}



//
// Determine if the net share has an open connection on this machine.
//
// Returns:
//    S_OK     = Open connection.
//    S_FALSE  = No open connection.
//
HRESULT
CShareCnxStatusCache::IsOpenConnectionShare(
    LPCTSTR pszShare, 
    bool bRefresh       // [optional].  Default = false.
    )
{
    DWORD dwStatus    = 0;
    HRESULT hr = GetShareStatus(pszShare, &dwStatus, bRefresh);
    if (SUCCEEDED(hr))
    {
        if (0 != (dwStatus & Entry::StatusOpenCnx))
            hr = S_OK;
        else
            hr = S_FALSE;
    }
    return hr;
}



//
// Returns:
//
//      E_INVALIDARG = Path was not a UNC share.
//      S_OK         = Status is valid.
//
HRESULT
CShareCnxStatusCache::GetShareStatus(
    LPCTSTR pszShare, 
    DWORD *pdwStatus,
    bool bRefresh       // [optional].  Default = false.
    )
{
    HRESULT hr = E_INVALIDARG;  // Assume share name isn't UNC.
    *pdwStatus = 0;

    if (PathIsUNCServerShare(pszShare))
    {
        //
        // We have a valid UNC "\\server\share" name string.
        //
        Entry *pEntry = FindEntry(pszShare);
        if (NULL == pEntry)
        {
            //
            // Cache miss.  Get the system status for the share and try to 
            // cache it.
            //
            hr = Entry::QueryShareStatus(pszShare, pdwStatus);
            if (SUCCEEDED(hr))
            {
                //
                // Note that we don't return any errors from the cache attempt.
                // The only problem of not caching the entry is that the next 
                // call to this function will need to re-query the system for
                // the information.  This makes the cache meaningless but it's
                // not worth failing the information request.  Just slows things
                // down a bit.
                //
                AddEntry(pszShare, *pdwStatus);
            }
        }
        else 
        {
            //
            // Cache hit.
            //
            hr = S_OK;
            if (bRefresh)
            {
                //
                // Caller want's fresh info.
                //
                hr = pEntry->Refresh();
            }
            *pdwStatus = pEntry->Status();
            if (SUCCEEDED(hr))
                hr = pEntry->LastResult();
        }
    }
    return hr;
}



//
// Returns number of entries in the cache.
//
int 
CShareCnxStatusCache::Count(
    void
    ) const
{
    return (NULL != m_hdpa) ? DPA_GetPtrCount(m_hdpa) : 0;
}


//-----------------------------------------------------------------------------
// CShareCnxStatusCache::Entry member functions.
//-----------------------------------------------------------------------------

CShareCnxStatusCache::Entry::Entry(
    LPCTSTR pszShare,
    DWORD dwStatus
    ) : m_pszShare(StrDup(pszShare)),
        m_dwStatus(dwStatus),
        m_hrLastResult(NOERROR)
{
    if (NULL == m_pszShare)
    {
        m_hrLastResult = E_OUTOFMEMORY;
    }
}



CShareCnxStatusCache::Entry::~Entry(
    void
    )
{
    if (NULL != m_pszShare)
    {
        LocalFree(m_pszShare);
    }
}



//
// Obtain new status info for the entry.
// Returns true if no errors obtaining info, false if there were errors.
//
HRESULT
CShareCnxStatusCache::Entry::Refresh(
    void
    )
{
    m_dwStatus     = 0;
    m_hrLastResult = E_OUTOFMEMORY;

    if (NULL != m_pszShare)
        m_hrLastResult = QueryShareStatus(m_pszShare, &m_dwStatus);

    return m_hrLastResult;
}



//
// Static function for obtaining entry status info from the
// system.  Made this a static function so the cache object
// can obtain information before creating the entry.  In case
// entry creation fails, we still want to be able to return
// valid status info.
//
HRESULT
CShareCnxStatusCache::Entry::QueryShareStatus(
    LPCTSTR pszShare,
    DWORD *pdwStatus
    )
{
    HRESULT hr = NOERROR;
    *pdwStatus = 0;

    //
    // Check the open connection status for this share.
    //
    hr = ::IsOpenConnectionShare(pszShare);
    switch(hr)
    {
        case S_OK:
            //
            // Open connection found.
            //
            *pdwStatus |= StatusOpenCnx;
            break;

        case S_FALSE:
            hr = S_OK;
            break;

        default:
            break;
    }

    //
    // If any other status information is required in the future,
    // here's where you collect it from the system.
    //
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cscui.rc
//
#define IDS_UNKNOWN_USER                33
#define IDS_DISKCLEAN_DISPLAY           35
#define IDS_DISKCLEAN_DESCRIPTION       36
#define IDS_ERROR                       37
#define IDS_MENU_PIN                    38
#define IDS_MENU_SYNCHRONIZE            39
#define IDS_HELP_PIN                    40
#define IDS_HELP_UPDATE_SEL             41
#define IDS_PIN_ENCRYPT_WARNING         43
#define IDS_DISKCLEAN_BTN_TEXT          44
#define IDS_APPLICATION                 45
#define IDS_DISKCLEAN_PIN_DESCRIPTION   46
#define IDS_VERSION_FORMAT              47
#define IDS_SHARE_STATUS_ONLINE         51
#define IDS_SHARE_STATUS_OFFLINE        52
#define IDS_TITLE_COL_SERVER            54
#define IDS_PIN_FILE_ERROR              96
#define IDS_FILL_SPARSE_FILES_ERROR     97
#define IDS_MERGE_SHARE_ERROR           98
#define IDS_COPY_WARNING                99
#define IDS_UNDO_SCAN                   100
#define IDS_NEW_SCAN                    101
#define IDS_DELETE_WARNING              102
#define IDS_FILE_OPEN_ERROR             103
#define IDS_SERVER_FULL_ERROR           104
#define IDS_LOCAL_DISK_FULL_ERROR       105
#define IDS_NET_ERROR                   106
#define IDS_NAME_CONFLICT_ERROR         107
#define IDS_ACCESS_ERROR                108
#define IDS_SHARE_CONNECT_ERROR         109
#define IDS_UNKNOWN_SYNC_ERROR          110
#define IDS_OPENFILE_MERGE_WARNING      111
#define IDS_STALEREASON_FIRST           112
#define IDS_STALEREASON_NOTSTALE        112
#define IDS_STALEREASON_ORPHAN          113
#define IDS_STALEREASON_SUSPECT         114
#define IDS_STALEREASON_STALE           115
#define IDS_STALEREASON_LOCALLY_MODATTR 116
#define IDS_STALEREASON_LOCALLY_MODTIME 117
#define IDS_STALEREASON_LOCALLY_MODDATA 118
#define IDS_STALEREASON_LOCALLY_CREATED 119
#define IDS_STALEREASON_SPARSE          120
#define IDS_STALEREASON_LAST            127
#define IDS_CONFIRM_UNPIN_OFFLINE       129
#define IDS_FMT_PIN_EFS_MSG             130
#define IDS_FMT_DELETE_APPLY_ALL        140
#define IDS_ERR_POLICY_NOVIEWCACHE      160
#define IDS_ERR_TSCONFIG_CONFLICT       161
#define IDS_FMT_ERR_DELFROMCACHE        162
#define IDS_FMT_ERR_DELFROMCACHE_BUSY   163
#define IDS_FMT_CACHESIZE_DISPLAY       167
#define IDS_ORDER_BYTES                 168
#define IDS_ORDER_KB                    169
#define IDS_ORDER_MB                    170
#define IDS_ORDER_GB                    171
#define IDS_ORDER_TB                    172
#define IDS_ORDER_PB                    173
#define IDS_ORDER_EB                    174
#define IDS_CSC_CM_SHOWVIEWER           180
#define IDS_BROWSEFORSERVER             188
#define IDS_ERR_NOTSERVERNAME           189
#define IDS_OPENDETAILS                 195
#define IDS_NOTHING_TO_SYNC             196
#define IDS_CSCOPT_PROPSHEET_TITLE      202
#define IDS_TITLE_COL_ACTION            203
#define IDS_GOOFFLINE_ACTION_FIRST      204
#define IDS_GOOFFLINE_ACTION_SILENT     204
#define IDS_GOOFFLINE_ACTION_FAIL       205
#define IDS_ERR_INVALIDSERVER           207
#define IDS_ERR_GOOFFLINE_DUPACTION     209
#define IDS_ERR_GOOFFLINE_DUPACTION_NOCHG 210
#define IDS_FMT_GOOFFLINE_SERVER_POLICY 212
#define IDS_GOOFFLINE_MULTISERVER       213
#define IDS_CACHE_CORRUPT               214
#define IDS_ERR_POLICY_NOCONFIGCSC      215
#define IDS_ERR_FMT_ENCRYPTCSC          216
#define IDS_ERR_FMT_DECRYPTCSC          217
#define IDS_ERR_FMT_ENCRYPTFILE         218
#define IDS_ERR_FMT_DECRYPTFILE         219
#define IDS_ENCRYPTING_DOTDOTDOT        220
#define IDS_DECRYPTING_DOTDOTDOT        221
#define IDS_REBOOTSYSTEM                222
#define IDS_CLOSEDETAILS                223
#define IDS_SCANNING_DOTDOTDOT          225
#define IDS_DELETING_DOTDOTDOT          226
#define IDS_FILE_PINNED                 227
#define IDS_FILE_NOTPINNED              228
#define IDS_COL_NAME                    229
#define IDS_COL_TYPE                    230
#define IDS_COL_SYNCSTATUS              231
#define IDS_COL_PINSTATUS               232
#define IDS_COL_LOCATION                233
#define IDS_COL_SIZE                    234
#define IDS_COL_DATE                    235
#define IDS_COL_ENCRYPTION              236
#define IDS_FILE_ENCRYPTED              237
#define IDS_FILE_DECRYPTED              238
#define IDS_ENCRYPTCSC_CANCELLED        239
#define IDS_DECRYPTCSC_CANCELLED        240
#define IDS_ENCRYPTCSC_INPROGFORPOLICY  241
#define IDS_TS_UNKNOWN                  242
#define IDS_TS_APP_SERVER               243
#define IDS_TS_NON_CONSOLE              244
#define IDS_TS_MULTI_CNX                245
#define IDS_TS_REMOTE_CNX               246
#define IDS_ERR_FMT_ENCRYPTFILE_INUSE   247
#define IDS_ERR_FMT_DECRYPTFILE_INUSE   248
#define IDS_PIN_NOPINFILE_POLICY_WARNING 249
#define IDS_PIN_NOPINFOLDER_POLICY_WARNING 250
#define IDS_TS_FUS_ENABLED              251
#define IDR_ADVOPTIONS_CONTEXTMENU      1103
#define IDI_CSCUI_ICON                  1200
#define IDI_PIN_OVERLAY                 1201
#define IDI_SHARE                       1205
#define IDI_DOCUMENT                    1208
#define IDI_NUKE                        1209
#define IDI_CSCNORMAL                   1213
#define IDI_CSCINFORMATION              1214
#define IDI_CSCWARNING                  1215
#define IDA_FILEDEL                     1218
#define IDA_FILEENCR                    1219
#define IDA_FILEDECR                    1220
#define IDD_CSC_OPTIONS                 1315
#define IDD_CSC_ADVOPTIONS              1323
#define IDD_CSC_ADVOPTIONS_ADD          1324
#define IDD_CSC_ADVOPTIONS_EDIT         1325
#define IDD_CONFIRM_PIN                 1328
#define IDD_OPEN_FILES_WARNING          1329
#define IDD_CONFIRM_PURGE               1330
#define IDD_FILE_CONFLICT_DELETE        1331
#define IDD_FIRSTPIN_WELCOME            1332
#define IDD_FIRSTPIN_PIN                1333
#define IDD_FIRSTPIN_OFFLINE            1334
#define IDB_FIRSTPIN_COVER              1340
#define IDD_CONFIRM_UNPIN               1341
#define IDD_CSCUI_STATUS                1342
#define IDB_FIRSTPIN_PIN                1343
#define IDB_FIRSTPIN_SYNC               1344
#define IDB_FIRSTPIN_TRAY               1346
#define IDI_SERVER                      1347
#define IDI_SERVER_OFFLINE              1348
#define IDD_CONFIRM_DELETE              1349
#define IDB_FIRSTPIN_OVERLAY            1350
#define IDD_CONFIRM_DELETEMOD           1351
#define IDD_CONFIRM_PIN_EFS             1352
#define IDD_FOLDER_CONFLICT_DELETE      1353
#define IDD_OPEN_FILES_WARNING_MULTIUSER 1354
#define IDC_CBX_ENABLE_CSC              2033
#define IDC_RBN_FULLSYNC_AT_LOGOFF      2068
#define IDC_RBN_PARTSYNC_AT_LOGOFF      2069
#define IDC_SLIDER_CACHESIZE_PCT        2096
#define IDC_TXT_CACHESIZE_PCT           2097
#define IDC_LBL_CACHESIZE_PCT           2098
#define IDC_BTN_DELETE_CACHE            2101
#define IDC_BTN_VIEW_CACHE              2102
#define IDC_BTN_EDIT_CUSTGOOFFLINE      2103
#define IDC_BTN_ADD_CUSTGOOFFLINE       2104
#define IDC_BTN_DELETE_CUSTGOOFFLINE    2105
#define IDC_GRP_GOOFFLINE_DEFAULTS      2106
#define IDC_RBN_GOOFFLINE_SILENT        2108
#define IDC_RBN_GOOFFLINE_FAIL          2109
#define IDC_LV_CUSTGOOFFLINE            2110
#define IDC_EDIT_GOOFFLINE_SERVER       2111
#define IDC_TXT_GOOFFLINE_SERVER        2112
#define IDC_CBX_ENCRYPT_CSC             2113
#define IDC_GRP_CUSTGOOFFLINE           2114
#define IDC_BTN_ADVANCED                2121
#define IDC_ERROR_TABS                  2124
#define IDC_SHARELB                     2126
#define IDC_OPENFILESLB                 2127
#define IDC_DETAILS                     2129
#define IDC_SINGLESHARENAME             2130
#define IDC_SEP                         2131
#define IDC_BTN_BROWSEFORSERVER         2132
#define IDC_DLGTYPEICON                 2133
#define IDC_RASCONNECT                  2135
#define IDC_WORKOFFLINE                 2136
#define IDC_CBRASENTRIES                2137
#define IDC_NETDOWNTEXT                 2138
#define IDC_STATIC2                     2141
#define IDC_STATIC3                     2142
#define IDC_STATIC4                     2143
#define IDC_PIN_NO_RECURSE              2144
#define IDC_PIN_RECURSE                 2145
#define IDC_FILENAME                    2147
#define IDC_KEEP_LOCAL                  2148
#define IDC_DELETE_LOCAL                2149
#define IDC_RBN_CONFIRMPURGE_UNPINNED   2150
#define IDC_RBN_CONFIRMPURGE_ALL        2151
#define IDC_TXT_CONFIRMPURGE            2152
#define IDC_CBX_FULLSYNC_AT_LOGOFF      2153
#define IDC_CBX_FULLSYNC_AT_LOGON       2154
#define IDC_CBX_REMINDERS               2155
#define IDC_EDIT_REMINDERS              2157
#define IDC_SPIN_REMINDERS              2159
#define IDC_TXT_REMINDERS1              2160
#define IDC_TXT_REMINDERS2              2161
#define IDC_CBX_FIRSTPIN_AUTOSYNC       2165
#define IDC_CBX_FIRSTPIN_FLDRLNK        2166
#define IDC_TXT_FIRSTPIN_WELCOME_TITLE  2168
#define IDC_TXT_FIRSTPIN_FINISH_TITLE   2169
#define IDC_CBX_FIRSTPIN_NOSHOW         2170
#define IDC_BTN_DETAILS                 2171
#define IDC_BTN_SYNCHRONIZE             2172
#define IDC_LV_STATUSDLG                2174
#define IDC_BTN_VIEWFILES               2175
#define IDC_BTN_SETTINGS                2176
#define IDC_TXT_STATUSDLG               2178
#define IDC_SEP_STATUSDLG               2179
#define IDC_CBX_STATUSDLG               2183
#define IDC_CBX_CONFIRMDEL_NOSHOW       2186
#define IDC_TXT_CONFIRM_DELETEMOD       2187
#define IDC_CBX_LINK_ON_DESKTOP         2188
#define IDC_DEBUG_LIST                  2189
#define IDC_PINEFS_APPLYTOALL           2190
#define IDC_EFS_MSG                     2191
#define IDC_APPLY_TO_ALL                2193
#define IDC_LIST_PURGE                  2195
#define IDS_COL_SERVERSTATUS            4101
#define IDS_BTHDR_INITIAL               4103
#define IDS_BTHDR_REMIND                4104
#define IDS_BTSTA_OFFLINE               4106
#define IDS_BTBOD_OFFLINE               4107
#define IDS_BTBOD_OFFLINE_M             4108
#define IDS_BTBOD_STILLOFFLINE          4109
#define IDS_BTBOD_STILLOFFLINE_M        4110
#define IDS_BTDIR_VIEWSTATUS            4111
#define IDS_BTDIR_RECONNECT             4112
#define IDS_BTSTA_DIRTY                 4114
#define IDS_BTSTA_SERVERBACK            4115
#define IDS_BTBOD_SERVERBACK            4116
#define IDS_BTBOD_SERVERBACK_M          4117
#define IDS_BTBOD_DIRTY                 4118
#define IDS_BTBOD_DIRTY_M               4119
#define IDS_BTBOD_STILLBACK             4120
#define IDS_BTBOD_STILLBACK_M           4121
#define IDS_BTBOD_STILLDIRTY            4122
#define IDS_BTBOD_STILLDIRTY_M          4123
#define IDS_BTDIR_SYNC                  4124
#define IDS_CSC_CM_SETTINGS             4125
#define IDS_FIRSTPIN_PIN_TITLE          4131
#define IDS_FIRSTPIN_PIN_SUBTITLE       4132
#define IDS_FIRSTPIN_OFFLINE_TITLE      4133
#define IDS_FIRSTPIN_OFFLINE_SUBTITLE   4134
#define IDS_FIRSTPIN_CONTROLS_TITLE     4135
#define IDS_FIRSTPIN_CONTROLS_SUBTITLE  4136
#define IDS_FIRSTPIN_SYNC_TITLE         4137
#define IDS_FIRSTPIN_SYNC_SUBTITLE      4138
#define IDS_FIRSTPIN_FONTHT_PTS         4139
#define IDS_ERR_REGSYNCATLOGONLOGOFF    4140
#define IDS_BTSTA_NONET                 4141
#define IDS_BTBOD_NONET                 4142
#define IDS_BTBOD_STILLNONET            4143
#define IDS_CSC_CM_STATUS               4144
#define IDS_STATUSDLG_HDR_SERVER        4145
#define IDS_STATUSDLG_HDR_STATUS        4146
#define IDS_STATUSDLG_HDR_INFO          4147
#define IDS_TT_HEADER                   4148
#define IDS_TT_OFFLINE                  4149
#define IDS_TT_OFFLINE_M                4150
#define IDS_TT_SERVERBACK               4151
#define IDS_TT_SERVERBACK_M             4152
#define IDS_TT_DIRTY                    4153
#define IDS_TT_DIRTY_M                  4154
#define IDS_TT_NONET                    4155
#define IDS_STATUSDLG_TITLE             4156
#define IDS_STATUSDLG_OFFLINE           4157
#define IDS_STATUSDLG_SERVERBACK        4158
#define IDS_STATUSDLG_DIRTY             4159
#define IDS_STATUSDLG_BTN_SYNC          4160
#define IDS_STATUSDLG_BTN_RECONN        4161
#define IDS_CSC_CM_SYNCHRONIZE          4162
#define IDS_STATUSDLG_OFFLINE_M         4163
#define IDS_STATUSDLG_SERVERBACK_M      4164
#define IDS_STATUSDLG_DIRTY_M           4165
#define IDS_SHARE_INFO_DIRTY            4166
#define IDS_SHARE_INFO_AVAIL_MOD        4167
#define IDS_SHARE_INFO_UNAVAIL_MOD      4168
#define IDS_SHARE_INFO_AVAIL            4169
#define IDS_SHARE_INFO_UNAVAIL          4170
#define IDS_SHARE_INFO_BLANK            4171
#define IDS_REFORMAT_CACHE              4172
#define IDS_STATUSDLG_NONET             4173
#define IDS_BALLOONHDR_FORMAT           4174
#define IDS_BALLOONBODY_FORMAT          4175
#define IDS_FMT_DELCACHE_FILESDELETED   4176
#define IDS_FMT_DELCACHE_FILEDELETED    4177
#define IDS_DELFILEPROG_LINE1           4178
#define IDS_FMT_DELFILES_ERROR          4179
#define IDS_FOLDER_LINK_NAME            4180
#define IDS_OPENFILESONDISABLE          4181
#define IDS_ERR_DISABLECSC              4182
#define IDS_ERR_ENABLECSC               4183
#define IDS_COL_ACCESS                  4184
#define IDS_ACCESS_NONE                 4185
#define IDS_ACCESS_READ                 4186
#define IDS_ACCESS_WRITE                4187
#define IDS_ACCESS_READWRITE            4188
#define IDS_NULLMERGE_ITEMNAME          4189
#define IDS_NULLSYNC_ITEMNAME           4190
#define IDS_CONFIRM_DELETEMOD           4191
#define IDS_CANTPIN_SYNCINPROGRESS      4192
#define IDS_CANTSYNC_SYNCINPROGRESS     4193
#define IDS_CANTRECONN_SYNCINPROGRESS   4194
#define IDS_CACHING_DISALLOWED          4195
#define IDM_MORE_SHARES                 4199
#define IDM_SHARES_LAST                 4199
#define IDM_SHOW_DEBUGINFO              4200
#define IDM_ACTION_DELETE               4292
#define IDM_ACTION_WORKOFFLINE          4293
#define IDM_ACTION_FAIL                 4295
#define IDS_DELCACHE_NOFILESDELETED     4296
#define IDS_CMD_DELETE                  4297
#define IDS_CMD_DELETE_HELPTEXT         4298
#define IDC_TXT_STATUSDLG_CHECKTOSYNC   4299
#define IDS_BTN_TITLE_CLOSE             4300
#define IDC_TXT_CONFIRMPURGE2           4301
#define IDC_TXT_CONFIRMPURGE3           4302
#define IDS_TXT_NO_FILES_TO_DELETE      4303
#define IDS_ERR_REBOOTFAILED            4304
#define IDS_TT_BODY_ENCRYPTED_PARTIAL   4305
#define IDS_TT_BODY_DECRYPTED_PARTIAL   4306
#define IDS_TT_BODY_ENCRYPTED_PARTIAL_NONADMIN 4307
#define IDS_TT_BODY_DECRYPTED_PARTIAL_NONADMIN 4308
#define IDS_TT_TITLE_ENCRYPTED_PARTIAL  4309
#define IDS_TT_TITLE_DECRYPTED_PARTIAL  4310
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1355
#define _APS_NEXT_COMMAND_VALUE         4311
#define _APS_NEXT_CONTROL_VALUE         2199
#define _APS_NEXT_SYMED_VALUE           2000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\shellex.cpp ===
// Authors;
//   Jeff Saathoff (jeffreys)
//
// Notes;
//   Context Menu and Property Sheet shell extensions

#include "pch.h"
#include "options.h"    // ..\viewer\options.h
#include "firstpin.h"
#include "msgbox.h"
#include "strings.h"
#include "nopin.h"
#include <ccstock.h>

#define CSC_PROP_NO_CSC         0x00000001L
#define CSC_PROP_MULTISEL       0x00000002L
#define CSC_PROP_PINNED         0x00000004L
#define CSC_PROP_SYNCABLE       0x00000008L
#define CSC_PROP_ADMIN_PINNED   0x00000010L
#define CSC_PROP_INHERIT_PIN    0x00000020L
#define CSC_PROP_DCON_MODE      0x00000040L

// Thread data for unpinning files
typedef struct
{
    CscFilenameList *pNamelist;
    DWORD            dwUpdateFlags;
    HWND             hwndOwner;
    BOOL             bOffline;
} CSC_UNPIN_DATA;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDAPI CCscShellExt::CreateInstance(REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    CCscShellExt *pThis = new CCscShellExt;
    if (pThis)
    {
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();                           // release initial ref
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCscShellExt::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CCscShellExt, IShellExtInit),
        QITABENT(CCscShellExt, IContextMenu),
        QITABENT(CCscShellExt, IShellIconOverlayIdentifier),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CCscShellExt::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CCscShellExt::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellExtInit

STDMETHODIMP CCscShellExt::Initialize(LPCITEMIDLIST /*pidlFolder*/, IDataObject *pdobj, HKEY /*hKeyProgID*/)
{
    IUnknown_Set((IUnknown **)&m_lpdobj, pdobj);
    return S_OK;
}


// IContextMenu
//
//  PURPOSE: Called by the shell just before the context menu is displayed.
//           This is where you add your specific menu items.
//
//  PARAMETERS:
//    hMenu      - Handle to the context menu
//    iMenu      - Index of where to begin inserting menu items
//    idCmdFirst - Lowest value for new menu ID's
//    idCmtLast  - Highest value for new menu ID's
//    uFlags     - Specifies the context of the menu event
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//

STDMETHODIMP CCscShellExt::QueryContextMenu(HMENU hMenu, UINT iMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = ResultFromShort(0);
    UINT idCmd = idCmdFirst;
    TCHAR szMenu[MAX_PATH];
    MENUITEMINFO mii;
    CConfig& config = CConfig::GetSingleton();
    
    if ((uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY)) || !m_lpdobj)
        return hr;

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::QueryContextMenu");
    TraceAssert(IsCSCEnabled());

    //
    // Check the pin status and CSC-ability of the current selection
    //
    m_dwUIStatus = 0;
    if (FAILED(CheckFileStatus(m_lpdobj, &m_dwUIStatus)))
        m_dwUIStatus = CSC_PROP_NO_CSC;

    if (m_dwUIStatus & CSC_PROP_NO_CSC)
        TraceLeaveResult(hr);

    //
    // Add a menu separator
    //
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;

    InsertMenuItem(hMenu, iMenu++, TRUE, &mii);

    if (!config.NoMakeAvailableOffline())
    {
        if (SUCCEEDED(hr = CanAllFilesBePinned(m_lpdobj)))
        {
            if (S_OK == hr)
            {
                mii.fState = MFS_ENABLED;  // All files in selection can be pinned.
            }
            else
            {
                mii.fState = MFS_DISABLED; // 1+ files in selection cannot be pinned.
            }

            //
            // Add the "Make Available Offline" menu item
            //
            LoadString(g_hInstance, IDS_MENU_PIN, szMenu, ARRAYSIZE(szMenu));

            mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            mii.fType = MFT_STRING;
            if (m_dwUIStatus & (CSC_PROP_ADMIN_PINNED | CSC_PROP_PINNED))
            {
                mii.fState = MFS_CHECKED;
                if (m_dwUIStatus & (CSC_PROP_ADMIN_PINNED | CSC_PROP_INHERIT_PIN))
                    mii.fState |= MFS_DISABLED;
            }
            mii.wID = idCmd++;
            mii.dwTypeData = szMenu;

            InsertMenuItem(hMenu, iMenu++, TRUE, &mii);
        }
    }

    if (m_dwUIStatus & (CSC_PROP_SYNCABLE | CSC_PROP_PINNED | CSC_PROP_ADMIN_PINNED))
    {
        //
        // Add the "Synchronize" menu item
        //
        LoadString(g_hInstance, IDS_MENU_SYNCHRONIZE, szMenu, ARRAYSIZE(szMenu));

        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = idCmd++;
        mii.dwTypeData = szMenu;

        InsertMenuItem(hMenu, iMenu++, TRUE, &mii);
    }    

    //
    // Return the number of menu items we added.
    //
    hr = ResultFromShort(idCmd - idCmdFirst);

    TraceLeaveResult(hr);
}


//
//  FUNCTION: IContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//

STDMETHODIMP
CCscShellExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr = S_OK;
    UINT iCmd = 0;
    CscFilenameList *pfnl = NULL;   // Namelist object.
    BOOL fPin;
    BOOL bSubFolders = FALSE;
    DWORD dwUpdateFlags = 0;

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::InvokeCommand");
    TraceAssert(IsCSCEnabled());
    TraceAssert(!(m_dwUIStatus & CSC_PROP_NO_CSC));

    if (HIWORD(lpcmi->lpVerb))
    {
        if (!lstrcmpiA(lpcmi->lpVerb, STR_PIN_VERB))
        {
            iCmd = 0;
            m_dwUIStatus &= ~CSC_PROP_PINNED;
        }
        else if (!lstrcmpiA(lpcmi->lpVerb, STR_UNPIN_VERB))
        {
            iCmd = 0;
            m_dwUIStatus |= CSC_PROP_PINNED;
        }
        else if (!lstrcmpiA(lpcmi->lpVerb, STR_SYNC_VERB))
        {
            iCmd = 1;
        }
        else
        {
            Trace((TEXT("Unknown command \"%S\""), lpcmi->lpVerb));
            ExitGracefully(hr, E_INVALIDARG, "Invalid command");
        }
    }
    else
    {
        iCmd = LOWORD(lpcmi->lpVerb);

        // If we didn't add the "Make Available Offline" verb, adjust the index
        if (CConfig::GetSingleton().NoMakeAvailableOffline())
            iCmd++;
    }
    if (iCmd >= 2)
        ExitGracefully(hr, E_INVALIDARG, "Invalid command");

    pfnl = new CscFilenameList;
    if (!pfnl)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create CscFilenameList object");

    hr = BuildFileList(m_lpdobj, lpcmi->hwnd, pfnl, &bSubFolders);
    FailGracefully(hr, "Unable to build file list");

    switch (iCmd)
    {
    case 0:  // "Make  available offline" menu choice - Pin files
        if (!FirstPinWizardCompleted())
        {
            //
            // User has never seen the "first pin" wizard.
            // 
            if (S_FALSE == ShowFirstPinWizard(lpcmi->hwnd))
            {
                //
                // User cancelled wizard.  Abort pinning operation.
                //
                ExitGracefully(hr, S_OK, "User cancelled first-pin wizard");
            }
        }
        fPin = !(m_dwUIStatus & CSC_PROP_PINNED);
        if (!fPin && (m_dwUIStatus & CSC_PROP_DCON_MODE))
        {
            // Unpin while disconnected causes things to disappear.
            // Warn the user.
            if (IDCANCEL == CscMessageBox(lpcmi->hwnd,
                                          MB_OKCANCEL | MB_ICONWARNING,
                                          g_hInstance,
                                          IDS_CONFIRM_UNPIN_OFFLINE))
            {
                ExitGracefully(hr, E_FAIL, "User cancelled disconnected unpin operation");
            }
        }
        // If there is a directory in the list AND we're pinning AND 
        // the "AlwaysPinSubFolders" policy is NOT set, ask the user 
        // whether to go deep or not.
        // If the policy IS set we automatically do a recursive pin.
        if (bSubFolders && (!fPin || !CConfig::GetSingleton().AlwaysPinSubFolders()))
        {
            switch (DialogBox(g_hInstance,
                    MAKEINTRESOURCE(fPin ? IDD_CONFIRM_PIN : IDD_CONFIRM_UNPIN),
                    lpcmi->hwnd,
                    _ConfirmPinDlgProc))
            {
            case IDYES:
                // nothing
                break;
            case IDNO:
                bSubFolders = FALSE; // no subfolders
                break;
            case IDCANCEL:
                ExitGracefully(hr, E_FAIL, "User cancelled (un)pin operation");
                break;
            }
        }

        if (bSubFolders)
            dwUpdateFlags |= CSC_UPDATE_PIN_RECURSE;

        if (fPin)
        {
            // Set the flags for pin + quick sync
            dwUpdateFlags |= CSC_UPDATE_SELECTION | CSC_UPDATE_STARTNOW
                                | CSC_UPDATE_PINFILES | CSC_UPDATE_FILL_QUICK;
        }
        else
        {
            HANDLE hThread;
            DWORD dwThreadID;
            CSC_UNPIN_DATA *pUnpinData = (CSC_UNPIN_DATA *)LocalAlloc(LPTR, sizeof(*pUnpinData));

            //
            // No sync is required to unpin files, so let's do it in this
            // process rather than starting SyncMgr.  However, let's do
            // it in the background in case there's a lot to unpin.
            //
            if (pUnpinData)
            {
                pUnpinData->pNamelist = pfnl;
                pUnpinData->dwUpdateFlags = dwUpdateFlags;
                pUnpinData->hwndOwner = lpcmi->hwnd;
                pUnpinData->bOffline = !!(m_dwUIStatus & CSC_PROP_DCON_MODE);
                hThread = CreateThread(NULL,
                                       0,
                                       _UnpinFilesThread,
                                       pUnpinData,
                                       0,
                                       &dwThreadID);
                if (hThread)
                {
                    // The thread will delete pUnpinData and pUnpinData->pNamelist
                    pfnl = NULL;

                    // We give the async thread a little time to complete, during which we
                    // put up the busy cursor.  This is solely to let the user see that
                    // some work is being done...
                    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    WaitForSingleObject(hThread, 750);
                    CloseHandle(hThread);
                    SetCursor(hCur);
                }
                else
                {
                    LocalFree(pUnpinData);
                }
            }

            // Clear the flags to prevent sync below
            dwUpdateFlags = 0;
        }
        break;

    case 1: // Synchronize
        // Set the flags for a full sync
        dwUpdateFlags = CSC_UPDATE_SELECTION | CSC_UPDATE_STARTNOW
                            | CSC_UPDATE_REINT | CSC_UPDATE_FILL_ALL
                            | CSC_UPDATE_SHOWUI_ALWAYS | CSC_UPDATE_NOTIFY_DONE;
        break;
    }

    //
    // Update the files we are pinning or synchronizing.
    // Setting the "ignore access" flag will cause us to ignore the 
    // user/guest/other access info and sync all selected files.  We want
    // this behavior as the operation was initiated by a user's explicit
    // selection of files/folders in explorer.
    //
    if (dwUpdateFlags && pfnl->GetFileCount())
    {
        if (!::IsSyncInProgress())
        {
            hr = CscUpdateCache(dwUpdateFlags | CSC_UPDATE_IGNORE_ACCESS, pfnl);
        }
        else
        {
            //
            // A sync is in progress.  Tell user why they can't currently
            // pin or sync.
            //
            const UINT rgidsMsg[] = { IDS_CANTPIN_SYNCINPROGRESS,
                                      IDS_CANTSYNC_SYNCINPROGRESS };

            CscMessageBox(lpcmi->hwnd, 
                          MB_OK | MB_ICONINFORMATION, 
                          g_hInstance, 
                          rgidsMsg[iCmd]);
        }
    }

exit_gracefully:

    delete pfnl;

    TraceLeaveResult(hr);
}


//
//  FUNCTION: IContextMenu::GetCommandString(UINT, UINT, UINT, LPSTR, UINT)
//
//  PURPOSE: Called by the shell after the user has selected on of the
//           menu items that was added in QueryContextMenu().
//
//  PARAMETERS:
//    lpcmi - Pointer to an CMINVOKECOMMANDINFO structure
//
//  RETURN VALUE:
//    HRESULT signifying success or failure.
//
//  COMMENTS:
//
STDMETHODIMP
CCscShellExt::GetCommandString(UINT_PTR iCmd,
                               UINT uFlags,
                               LPUINT /*reserved*/,
                               LPSTR pszString,
                               UINT cchMax)
{
    HRESULT hr = E_UNEXPECTED;

    if (uFlags == GCS_VALIDATE)
        hr = S_FALSE;

    if (iCmd > 1)
        return hr;

    hr = S_OK;

    if (uFlags == GCS_HELPTEXT)
    {
        if (0 == LoadString(g_hInstance, iCmd ? IDS_HELP_UPDATE_SEL : IDS_HELP_PIN, (LPTSTR)pszString, cchMax))
        {
            hr = ResultFromLastError();
        }
    }
    else if (uFlags == GCS_VERB)
    {
        hr = StringCchCopy((LPTSTR)pszString, cchMax, iCmd ? TEXT(STR_SYNC_VERB) : ((m_dwUIStatus & CSC_PROP_PINNED) ? TEXT(STR_UNPIN_VERB) : TEXT(STR_PIN_VERB)));
    }
    else if (uFlags != GCS_VALIDATE)
    {
        // Must be some other flag that we don't handle
        hr = E_NOTIMPL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shell extension object implementation (IShellIconOverlayIdentifier)       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCscShellExt::IsMemberOf(LPCWSTR pwszPath, DWORD dwAttrib)
{
    HRESULT hr = S_FALSE;  // assume not pinned
    DWORD dwHintFlags;
    DWORD dwErr;
    LPTSTR pszUNC = NULL;
    LPTSTR pszSlash;

    //
    // Make sure we have a UNC path
    //
    GetRemotePath(pwszPath, &pszUNC);
    if (!pszUNC)
        return S_FALSE;

    //
    // Ask CSC if this is a pinned file
    //
    dwHintFlags = 0;
    if (CSCQueryFileStatus(pszUNC, NULL, NULL, &dwHintFlags))
    {
        if (dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN))
            hr = S_OK;
    }
    else
    {
        dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND != dwErr)
        {
            //
            // Need to check for 0 to accomodate GetLastError
            // returning 0 on CSCQueryFileStatus failure.
            // I'll talk to Shishir about getting this fixed.
            // [brianau - 5/13/99]
            //
            // Most of these were fixed for Windows 2000. If we
            // hit the assertion below we should file a bug and
            // get Shishir to fix it.
            // [jeffreys - 1/24/2000]
            //
            if (0 == dwErr)
            {
                ASSERTMSG(FALSE, "CSCQueryFileStatus failed with error = 0");
                dwErr = ERROR_GEN_FAILURE;
            }

            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    DWORD dwAttribTest = FILE_ATTRIBUTE_ENCRYPTED;
    if (!CConfig::GetSingleton().AlwaysPinSubFolders())
        dwAttribTest |= FILE_ATTRIBUTE_DIRECTORY;
    
    if (S_FALSE == hr && !(dwAttrib & dwAttribTest))
    {
        //
        // Check to see if pinning is disallowed by system policy.
        //
        hr = m_NoPinList.IsPinAllowed(pszUNC);
        if (S_OK == hr)
        {
            hr = S_FALSE; // Reset
            //
            // If we get here, then either CSCQueryFileStatus succeeded but the file
            // isn't pinned, or the file isn't in the cache (ERROR_FILE_NOT_FOUND).
            // Also, policy allows pinning of this file/folder.
            //
            // Check whether the parent folder has the pin-inherit-user or
            // admin-pin flag and pin this file if necessary.
            //
            // Note that we don't pin encrypted files here.
            // Also note that pinning of folder is policy-dependent.  The default
            // behavior is to NOT pin folders (only files).  If the 
            // "AlwaysPinSubFolders" policy is set, we will pin folders.
            //
            pszSlash = PathFindFileName(pszUNC);
            if (pszSlash && pszUNC != pszSlash)
            {
                --pszSlash;
                *pszSlash = TEXT('\0'); // truncate the path

                // Check the parent status
                if (CSCQueryFileStatus(pszUNC, NULL, NULL, &dwHintFlags) &&
                    (dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN)))
                {
                    // The parent is pinned, so pin this file with the same flags
                    if (dwHintFlags & FLAG_CSC_HINT_PIN_USER)
                        dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;

                    // Restore the rest of the path
                    *pszSlash = TEXT('\\');
            
                    //
                    // To avoid a nasty race condition between purging and auto-pinning we need
                    // to disable auto-pinning when a purge is in progress.  The race condition
                    // can occur if a shell folder for the files being purged is open.  We purge
                    // a file and send out a change notify.  The shell updates the icon overlay
                    // and calls our overlay handler to remove the overlay.  Our handler notices 
                    // that the parent folder is pinned so we re-pin the file which places it 
                    // back in the cache.  Ugh... [brianau - 11/01/99]
                    //
                    // p.s.:  Note that this check calls WaitForSingleObject so we only
                    //        do it AFTER we're sure that we want to pin the file.  We don't
                    //        want to do the "wait" and THEN decide the file should not be
                    //        pinned because it's not a UNC path or it's a directory.
                    //
                    if (!IsPurgeInProgress())
                    {
                        if (CSCPinFile(pszUNC, dwHintFlags, NULL, NULL, NULL))
                            hr = S_OK;
                    }
                }
            }
        }
    }

    LocalFreeString(&pszUNC);

    return hr;
}

STDMETHODIMP
CCscShellExt::GetOverlayInfo (LPWSTR pwszIconFile,
                              int cchMax,
                              int * pIndex,
                              DWORD * pdwFlags)
{
    // Use positive #'s for indexes, negative for ID's (NT only)
    *pIndex = -IDI_PIN_OVERLAY;
    *pdwFlags = (ISIOI_ICONFILE | ISIOI_ICONINDEX);
    return StringCchCopy(pwszIconFile, cchMax, c_szDllName);
}

STDMETHODIMP
CCscShellExt::GetPriority (int * pIPriority)
{
    *pIPriority = 1;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CCscShellExt implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ShareIsCacheable(LPCTSTR pszUNC, BOOL bPathIsFile, LPTSTR *ppszConnectionName, PDWORD pdwShareStatus)
{
    TCHAR szShare[MAX_PATH];
    DWORD dwShareStatus = FLAG_CSC_SHARE_STATUS_NO_CACHING;

    *ppszConnectionName = NULL;

    // CSCQueryFileStatus can fail for multiple reasons, one of which is that
    // there is no database entry and no existing SMB connection to the share.
    // To handle the no-connection part, we try to connect to the share and
    // retry CSCQueryFileStatus.
    //
    // However, there may be a non-SMB connnection which the SMB RDR doesn't
    // know about, so we have to check for a connection first. If there is a
    // non-SMB connection and we connect again, we would end up disconnecting
    // the pre-existing connection later, since we think we made the connection.
    //
    // If there is a non-SMB connection, then caching is not possible.
    //
    // Note that we can get here without a connection in at least 3 ways:
    // 1. When exploring on \\server and the context menu is for \\server\share.
    // 2. When checking a link target, which may live on a different server
    //    than what we're exploring.
    // 3. When checking a folder which is a DFS junction (we need to connect
    //    to the 'child' share).


    // Use a deep path to get correct results in DFS scenarios, but strip the
    // filename if it's not a directory.
    if (SUCCEEDED(StringCchCopy(szShare, ARRAYSIZE(szShare), pszUNC)))
    {
        if (bPathIsFile)
        {
            PathRemoveFileSpec(szShare);
        }

        // CSCQueryShareStatus is currently unable to return permissions in
        // some cases (e.g. DFS), so don't use the permission parameters.
        if (!CSCQueryShareStatus(szShare, &dwShareStatus, NULL, NULL, NULL, NULL))
        {
            if (!ShareIsConnected(szShare) && ConnectShare(szShare, ppszConnectionName))
            {
                if (!CSCQueryShareStatus(szShare, &dwShareStatus, NULL, NULL, NULL, NULL))
                {
                    dwShareStatus = FLAG_CSC_SHARE_STATUS_NO_CACHING;

                    // We're going to return FALSE; kill the connection
                    if (*ppszConnectionName)
                    {
                        WNetCancelConnection2(*ppszConnectionName, 0, FALSE);
                        LocalFreeString(ppszConnectionName);
                    }
                }
            }
            else
            {
                dwShareStatus = FLAG_CSC_SHARE_STATUS_NO_CACHING;
            }
        }
    }

    *pdwShareStatus = dwShareStatus;

    return !((dwShareStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING);
}

BOOL
IsSameServer(LPCTSTR pszUNC, LPCTSTR pszServer)
{
    ULONG nLen;
    LPTSTR pszSlash;

    pszUNC += 2;    // Skip leading backslashes

    pszSlash = StrChr(pszUNC, TEXT('\\'));
    if (pszSlash)
        nLen = (ULONG)(pszSlash - pszUNC);
    else
        nLen = lstrlen(pszUNC);

    return (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                        NORM_IGNORECASE,
                                        pszUNC,
                                        nLen,
                                        pszServer,
                                        -1));
}

STDMETHODIMP
CCscShellExt::CheckOneFileStatus(LPCTSTR pszItem,
                                 DWORD   dwAttr,        // SFGAO_* flags
                                 BOOL    bShareChecked,
                                 LPDWORD pdwStatus)     // CSC_PROP_* flags
{
    HRESULT hr = S_OK;
    LPTSTR pszConnectionName = NULL;
    DWORD dwHintFlags = 0;

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::CheckOneFileStatus");
    TraceAssert(pszItem && *pszItem);
    TraceAssert(pdwStatus);

    if (!PathIsUNC(pszItem))
        ExitGracefully(hr, HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME), "Not a network path");

    // If server is local machine, fail.  Don't allow someone to
    // cache a local path via a net share.
    if (IsSameServer(pszItem, m_szLocalMachine))
        ExitGracefully(hr, HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME), "Locally redirected path");

    // Check whether the share is cacheable
    // To handle DFS correctly, we need to re-check share status for folders,
    // since they may be DFS junction points and have different cache settings.
    if (!bShareChecked || (dwAttr & SFGAO_FOLDER))
    {
        DWORD dwShareStatus = 0;

        if (!ShareIsCacheable(pszItem, !(dwAttr & SFGAO_FOLDER), &pszConnectionName, &dwShareStatus))
            ExitGracefully(hr, E_FAIL, "Share not cacheable");

        if (dwShareStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
            *pdwStatus |= CSC_PROP_DCON_MODE;
    }

    // Check the file status
    if (!CSCQueryFileStatus(pszItem, NULL, NULL, &dwHintFlags))
    {
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            if (NO_ERROR == dwErr)
                dwErr = ERROR_GEN_FAILURE;
            ExitGracefully(hr, HRESULT_FROM_WIN32(dwErr), "CSCQueryFileStatus failed");
        }
    }
    else
    {
        if (dwAttr & SFGAO_FOLDER)
        {
            // CSCQueryFileStatus succeeded, so this folder is in the cache.
            // Enable the sync menu.
            if (PathIsRoot(pszItem))
            {
                // Special note for "\\server\share" items: CSCQueryFileStatus
                // can succeed even if nothing on the share is cached. Only
                // enable CSC_PROP_SYNCABLE if something on this share is cached.
                CSCSHARESTATS shareStats;
                CSCGETSTATSINFO si = { SSEF_NONE,  // No exclusions
                                       SSUF_TOTAL, // Interested in total only.
                                       false,      // No access info reqd (faster).
                                       false };     

                _GetShareStatisticsForUser(pszItem, &si, &shareStats);
                if (shareStats.cTotal)
                    *pdwStatus |= CSC_PROP_SYNCABLE;
            }
            else
            {
                *pdwStatus |= CSC_PROP_SYNCABLE;
            }
        }

        const bool bPinSubFolders = CConfig::GetSingleton().AlwaysPinSubFolders();
        if (!(*pdwStatus & CSC_PROP_INHERIT_PIN) && 
            (!(dwAttr & SFGAO_FOLDER) || bPinSubFolders))
        {
            TCHAR szParent[MAX_PATH];
            DWORD dwParentHints = 0;

            // It's a file OR it's a folder and the "AlwaysPinSubFolders" 
            // policy is set.. Check whether the parent is pinned.
            if (SUCCEEDED(StringCchCopy(szParent, ARRAYSIZE(szParent), pszItem))
                && PathRemoveFileSpec(szParent)
                && CSCQueryFileStatus(szParent, NULL, NULL, &dwParentHints)
                && (dwParentHints & FLAG_CSC_HINT_PIN_USER))
            {
                *pdwStatus |= CSC_PROP_INHERIT_PIN;
            }
        }
    }

    // If it's not pinned, turn off pinned flag
    if (0 == (dwHintFlags & FLAG_CSC_HINT_PIN_USER))
        *pdwStatus &= ~CSC_PROP_PINNED;

    // If it's not admin pinned, turn off admin pinned flag
    if (0 == (dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN))
        *pdwStatus &= ~CSC_PROP_ADMIN_PINNED;

exit_gracefully:

    if (pszConnectionName)
    {
        WNetCancelConnection2(pszConnectionName, 0, FALSE);
        LocalFreeString(&pszConnectionName);
    }

    TraceLeaveResult(hr);
}

BOOL
_PathIsUNCServer(LPCTSTR pszPath)
{
    int i;

    if (!pszPath)
        return FALSE;

    for (i = 0; *pszPath; pszPath++ )
    {
        if (pszPath[0]==TEXT('\\') && pszPath[1]) // don't count a trailing slash
        {
            i++;
        }
    }

    return (i == 2);
}

STDMETHODIMP CCscShellExt::CheckFileStatus(IDataObject *pdobj, DWORD *pdwStatus)        // CSC_PROP_* flags
{
    LPTSTR pszConnectionName = NULL;
    UINT i;
    BOOL bShareOK = FALSE;
    TCHAR szItem[MAX_PATH];
    CIDArray ida;

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::CheckFileStatus");
    TraceAssert(pdobj != NULL);
    TraceAssert(IsCSCEnabled());

    if (pdwStatus)
        *pdwStatus = 0;

    // Assume that everything is both user and system pinned.  If anything
    // is not pinned, clear the appropriate flag and treat the entire
    // selection as non-pinned.
    DWORD dwStatus = CSC_PROP_PINNED | CSC_PROP_ADMIN_PINNED;

    HRESULT hr = ida.Initialize(pdobj);
    FailGracefully(hr, "Can't get ID List format from data object");

    if (ida.Count() > 1)
        dwStatus |= CSC_PROP_MULTISEL;

    // Check the parent path
    hr = ida.GetFolderPath(szItem, ARRAYSIZE(szItem));
    FailGracefully(hr, "No parent path");

    if (ida.Count() > 1 && PathIsUNC(szItem) && !_PathIsUNCServer(szItem))
    {
        DWORD dwShareStatus = 0;

        if (!ShareIsCacheable(szItem, FALSE, &pszConnectionName, &dwShareStatus))
            ExitGracefully(hr, E_FAIL, "Share not cacheable");

        if (dwShareStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
            dwStatus |= CSC_PROP_DCON_MODE;

        // No need to check share status again inside CheckOneFileStatus
        bShareOK = TRUE;
    }

    // Loop over each selected item
    for (i = 0; i < ida.Count(); i++)
    {
        // Get the attributes
        DWORD dwAttr = SFGAO_FILESYSTEM | SFGAO_LINK | SFGAO_FOLDER;
        hr = ida.GetItemPath(i, szItem, ARRAYSIZE(szItem), &dwAttr);
        FailGracefully(hr, "Unable to get item attributes");

        if (!(dwAttr & SFGAO_FILESYSTEM))
            ExitGracefully(hr, E_FAIL, "Not a filesystem object");

        // Is it a shortcut?
        if (dwAttr & SFGAO_LINK)
        {
            LPTSTR pszTarget = NULL;

            // Check the target
            GetLinkTarget(szItem, &pszTarget);
            if (pszTarget)
            {
                hr = CheckOneFileStatus(pszTarget, 0, FALSE, &dwStatus);
                LocalFreeString(&pszTarget);

                if (SUCCEEDED(hr) && !PathIsUNC(szItem))
                {
                    // The link is local, but the target is remote, so don't
                    // bother checking status of the link itself.  Just go
                    // with the target status and move on to the next item.
                    continue;
                }
            }
        } 

        hr = CheckOneFileStatus(szItem, dwAttr, bShareOK, &dwStatus);
        FailGracefully(hr, "File not cacheable");
    }

exit_gracefully:

    if (pszConnectionName)
    {
        WNetCancelConnection2(pszConnectionName, 0, FALSE);
        LocalFreeString(&pszConnectionName);
    }

    if (SUCCEEDED(hr) && pdwStatus != NULL)
        *pdwStatus = dwStatus;

    TraceLeaveResult(hr);
}


//
// Determines if a folder has subfolders.
// Returns:
//      S_OK          = Has subfolders.
//      S_FALSE       = No subfolders.
//      E_OUTOFMEMORY = Insufficient memory.
//
HRESULT
CCscShellExt::FolderHasSubFolders(
    LPCTSTR pszPath,
    CscFilenameList *pfnl
    )
{
    if (NULL == pszPath || TEXT('\0') == *pszPath)
        return E_INVALIDARG;

    HRESULT hr = S_FALSE;
    size_t cchBuffer = lstrlen(pszPath) + 1 + MAX_PATH;
    LPTSTR pszTemp = (LPTSTR)LocalAlloc(LPTR, cchBuffer * sizeof(TCHAR));
    if (NULL != pszTemp)
    {
        LPTSTR pszEnd;

        // We allocated more than enough to hold pszPath + "\\*", so
        // this should never fail.
        StringCchCopyEx(pszTemp, cchBuffer, pszPath, &pszEnd, &cchBuffer, 0);
        ASSERT(pszEnd > pszTemp && *(pszEnd-1) != TEXT('\\'));

        StringCchCopy(pszEnd, cchBuffer, TEXT("\\*"));
        pszEnd++;   // move past '\\'
        cchBuffer--;

        WIN32_FIND_DATA fd;
        HANDLE hFind = FindFirstFile(pszTemp, &fd);
        if (INVALID_HANDLE_VALUE != hFind)
        {
            do
            {
                if ((FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes) && !PathIsDotOrDotDot(fd.cFileName))
                {
                    if (IsHiddenSystem(fd.dwFileAttributes))
                    {
                        // This subfolder is "super hidden".  Build the full path
                        // and silently add it to the file list, but don't set the
                        // result to S_OK (we don't want superhidden subfolders to
                        // cause prompts).
                        if (SUCCEEDED(StringCchCopy(pszEnd, cchBuffer, fd.cFileName)))
                        {
                            pfnl->AddFile(pszTemp, true);
                        }
                    }
                    else
                        hr = S_OK;  // don't break, there may be superhidden folders
                }
            }
            while(FindNextFile(hFind, &fd));
            FindClose(hFind);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        LocalFree(pszTemp);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


STDMETHODIMP CCscShellExt::BuildFileList(IDataObject *pdobj, HWND hwndOwner, 
                                         CscFilenameList *pfnl, LPBOOL pbSubFolders)
{
    UINT i;
    TCHAR szItem[MAX_PATH];
    CIDArray ida;
    BOOL bDirectory;

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::BuildFileList");
    TraceAssert(pdobj != NULL);
    TraceAssert(pfnl != NULL);

    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    HRESULT hr = ida.Initialize(pdobj);
    FailGracefully(hr, "Can't get ID List format from data object");

    // Loop over each selected item
    for (i = 0; i < ida.Count(); i++)
    {
        // Get the attributes
        DWORD dwAttr = SFGAO_FILESYSTEM | SFGAO_LINK | SFGAO_FOLDER;
        hr = ida.GetItemPath(i, szItem, ARRAYSIZE(szItem), &dwAttr);
        FailGracefully(hr, "Unable to get item attributes");

        if (!(dwAttr & SFGAO_FILESYSTEM))
            continue;

        // Is it a shortcut?
        if (dwAttr & SFGAO_LINK)
        {
            LPTSTR pszTarget = NULL;

            // Check the target
            GetLinkTarget(szItem, &pszTarget);
            if (pszTarget)
            {
                // Add the target to the file list
                if (!pfnl->FileExists(pszTarget, false))
                    pfnl->AddFile(pszTarget, false);

                LocalFreeString(&pszTarget);
            }
        } 

        bDirectory = (dwAttr & SFGAO_FOLDER);

        if (pbSubFolders && bDirectory && !*pbSubFolders)
            *pbSubFolders = (S_OK == FolderHasSubFolders(szItem, pfnl));

        // Add the item to the file list
        pfnl->AddFile(szItem, !!bDirectory);

        // If it's an html file, look for a directory of the same name
        // and add it to the file list if necessary.
        //
        // We're supposed to look for a localized version of "Files"
        // tacked on to the root name.  For example, given "foo.htm" we
        // should look for a directory named "foo Files" where the "Files"
        // part comes from a list of localized strings provided by Office.
        // We don't bother and just look for a directory named "foo".
        //
        if (!bDirectory && PathIsHTMLFile(szItem))
        {
            // Truncate the path
            LPTSTR pszExtn = PathFindExtension(szItem);
            if (pszExtn)
                *pszExtn = NULL;

            // Check for existence
            dwAttr = GetFileAttributes(szItem);

            if ((DWORD)-1 != dwAttr && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                pfnl->AddFile(szItem, true);
        }
    }

exit_gracefully:

    SetCursor(hCur);

    TraceLeaveResult(hr);
}


#define _WNET_ENUM_BUFFER_SIZE      4000

BOOL
ShareIsConnected(LPCTSTR pszUNC)
{
    HANDLE hEnum;
    PVOID  pBuffer;
    BOOL   fShareIsConnected  = FALSE;

    pBuffer = (PVOID)LocalAlloc(LMEM_FIXED, _WNET_ENUM_BUFFER_SIZE);

    if (NULL != pBuffer)
    {
        //
        // Enumerate all connected disk resources
        //
        if (NO_ERROR == WNetOpenEnum(RESOURCE_CONNECTED, RESOURCETYPE_DISK, 0, NULL, &hEnum))
        {
            //
            // Look at each connected share.  If we find the share we're looking for,
            // we know it's connected so we can quit looking.
            //
            while (!fShareIsConnected)
            {
                LPNETRESOURCE pnr;
                DWORD cEnum = (DWORD)-1;
                DWORD dwBufferSize = _WNET_ENUM_BUFFER_SIZE;

                if (NO_ERROR != WNetEnumResource(hEnum, &cEnum, pBuffer, &dwBufferSize))
                    break;

                for (pnr = (LPNETRESOURCE)pBuffer; cEnum > 0; cEnum--, pnr++)
                {
                    if (NULL != pnr->lpRemoteName &&
                        0 == lstrcmpi(pnr->lpRemoteName, pszUNC))
                    {
                        // Found it
                        fShareIsConnected = TRUE;
                        break;
                    }
                }
            }

            WNetCloseEnum(hEnum);
        }
        LocalFree(pBuffer);
    }

    return fShareIsConnected;
}


BOOL
ConnectShare(LPCTSTR pszUNC, LPTSTR *ppszAccessName)
{
    NETRESOURCE nr;
    DWORD dwResult;
    DWORD dwErr;
    TCHAR szAccessName[MAX_PATH];
    DWORD cchAccessName = ARRAYSIZE(szAccessName);

    TraceEnter(TRACE_SHELLEX, "CCscShellExt::ConnectShare");
    TraceAssert(pszUNC && *pszUNC);

    nr.dwType = RESOURCETYPE_DISK;
    nr.lpLocalName = NULL;
    nr.lpRemoteName = (LPTSTR)pszUNC;
    nr.lpProvider = NULL;

    szAccessName[0] = TEXT('\0');

    dwErr = WNetUseConnection(NULL,
                              &nr,
                              NULL,
                              NULL,
                              0,
                              szAccessName,
                              &cchAccessName,
                              &dwResult);

    Trace((TEXT("Connecting %s (%d)"), pszUNC, dwErr));

    if (ppszAccessName && NOERROR == dwErr)
    {
        LocalAllocString(ppszAccessName, szAccessName);
    }

    TraceLeaveValue(NOERROR == dwErr);
}


DWORD WINAPI
CCscShellExt::_UnpinFilesThread(LPVOID pvThreadData)
{
    CSC_UNPIN_DATA *pUnpinData = reinterpret_cast<CSC_UNPIN_DATA *>(pvThreadData);
    if (pUnpinData)
    {
        HINSTANCE hInstThisDll = LoadLibrary(c_szDllName);
        if (hInstThisDll)
        {
            CscUnpinFileList(pUnpinData->pNamelist,
                            (pUnpinData->dwUpdateFlags & CSC_UPDATE_PIN_RECURSE),
                            pUnpinData->bOffline,
                            NULL, NULL, 0);
        }

        delete pUnpinData->pNamelist;
        LocalFree(pUnpinData);

        if (hInstThisDll)
        {
            FreeLibraryAndExitThread(hInstThisDll, 0);
        }
    }
    return 0;
}


INT_PTR CALLBACK
CCscShellExt::_ConfirmPinDlgProc(HWND hDlg,
                                 UINT uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    INT_PTR bResult = TRUE;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDC_PIN_NO_RECURSE, IDC_PIN_RECURSE, IDC_PIN_RECURSE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
            // Return IDYES to indicate that the operation should be recursive.
            // Return IDNO to indicate no recursion.
            EndDialog(hDlg, BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_PIN_RECURSE) ? IDYES : IDNO);
            break;
        }
        break;

    default:
        bResult = FALSE;    // message not handled
    }

    return bResult;
}


//
// Given an IDataObject ptr representing a selection of files from 
// within the shell, this function determins if pinning of any of 
// the files and directories is disallowed via system policy.
//
// Returns: S_OK    - All files in data object can be pinned.
//          S_FALSE - At least one file in data object cannot be pinned.
//
HRESULT
CCscShellExt::CanAllFilesBePinned(
    IDataObject *pdtobj
    )
{
    TraceEnter(TRACE_SHELLEX, "CCscShellExt::CanAllFilesBePinned");

    //
    // Quick check to see if ANY pin restrictions are in place.
    //
    HRESULT hr = m_NoPinList.IsAnyPinDisallowed();
    if (S_OK == hr)
    {
        //
        // Yes, at least one restriction was read from registry.
        //
        CscFilenameList fnl;
        hr = BuildFileList(m_lpdobj, 
                           GetDesktopWindow(),
                           &fnl,
                           NULL);
        if (SUCCEEDED(hr))
        {
            //
            // Iterate over all UNC paths in the data object
            // until we either exhaust the list or find one for which
            // pinning is disallowed.
            //
            CscFilenameList::ShareIter si = fnl.CreateShareIterator();
            CscFilenameList::HSHARE hShare;

            while(si.Next(&hShare))
            {
                TCHAR szUncPath[MAX_PATH];

                hr = StringCchCopy(szUncPath, ARRAYSIZE(szUncPath), fnl.GetShareName(hShare));
                if (FAILED(hr) || !PathAddBackslash(szUncPath))
                {
                    TraceLeaveResult(HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));
                }

                const int cchShare = lstrlen(szUncPath);

                CscFilenameList::FileIter fi = fnl.CreateFileIterator(hShare);

                LPCTSTR pszFile;
                while(NULL != (pszFile = fi.Next()))
                {
                    //
                    // Assemble the full UNC path string.
                    // If the item is a directory, will need to truncate the trailing
                    // "\*" characters.
                    //
                    hr = StringCchCopy(szUncPath + cchShare, ARRAYSIZE(szUncPath) - cchShare, pszFile);
                    if (FAILED(hr))
                    {
                        TraceLeaveResult(HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));
                    }
                    LPTSTR pszEnd = szUncPath + lstrlen(szUncPath) - 1;
                    while(pszEnd > szUncPath && (TEXT('\\') == *pszEnd || TEXT('*') == *pszEnd))
                    {
                        *pszEnd-- = TEXT('\0');
                    }
                    if (S_FALSE == m_NoPinList.IsPinAllowed(szUncPath))
                    {
                        Trace((TEXT("Policy prevents pinning of \"%s\""), szUncPath));
                        TraceLeaveResult(S_FALSE);
                    }
                }
            }
        }
    }
    TraceLeaveResult(SUCCEEDED(hr) ? S_OK : hr);
}


//
// Support for recursively unpinning a tree with progress updates
//
typedef struct _UNPIN_FILES_DATA
{
    BOOL                    bSubfolders;
    BOOL                    bOffline;
    PFN_UNPINPROGRESSPROC   pfnProgressCB;
    LPARAM                  lpContext;
} UNPIN_FILES_DATA, *PUNPIN_FILES_DATA;

DWORD WINAPI
_UnpinCallback(LPCTSTR             pszItem,
               ENUM_REASON         eReason,
               DWORD               /*dwStatus*/,
               DWORD               dwHintFlags,
               DWORD               dwPinCount,
               LPWIN32_FIND_DATA   pFind32,
               LPARAM              lpContext)
{
    PUNPIN_FILES_DATA pufd = reinterpret_cast<PUNPIN_FILES_DATA>(lpContext);

    // Skip folders if we aren't recursing
    if (eReason == ENUM_REASON_FOLDER_BEGIN && !pufd->bSubfolders)
        return CSCPROC_RETURN_SKIP;

    // Update progress
    if (pufd->pfnProgressCB)
    {
        DWORD dwResult = (*pufd->pfnProgressCB)(pszItem, pufd->lpContext);
        if (CSCPROC_RETURN_CONTINUE != dwResult)
            return dwResult;
    }

    // Unpin the item if it's pinned.  For folders,
    // do this before recursing.
    if ((eReason == ENUM_REASON_FILE || eReason == ENUM_REASON_FOLDER_BEGIN)
        && (dwHintFlags & FLAG_CSC_HINT_PIN_USER))
    {
        if (CSCUnpinFile(pszItem,
                         FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER,
                         NULL,
                         NULL,
                         &dwHintFlags))
        {
            ShellChangeNotify(pszItem, pFind32, FALSE);
        }
    }

    // Delete items that are no longer pinned.  For folders,
    // do this after recursing.
    if (eReason == ENUM_REASON_FILE || eReason == ENUM_REASON_FOLDER_END)
    {
        if (!dwHintFlags && !dwPinCount)
        {
            if (NOERROR == CscDelete(pszItem) && pufd->bOffline)
            {
                // Removing from the cache while in offline mode means
                // it's no longer available, so remove it from view.
                ShellChangeNotify(pszItem,
                                  pFind32,
                                  FALSE,
                                  (pFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? SHCNE_RMDIR : SHCNE_DELETE);
            }
        }
    }

    return CSCPROC_RETURN_CONTINUE;
}

DWORD
_UnpinOneShare(CscFilenameList *pfnl,
               CscFilenameList::HSHARE hShare,
               PUNPIN_FILES_DATA pufd)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    LPCTSTR pszFile;
    LPCTSTR pszShare = pfnl->GetShareName(hShare);
    CscFilenameList::FileIter fi = pfnl->CreateFileIterator(hShare);

    // Iterate over the filenames associated with the share.
    while (pszFile = fi.Next())
    {
        TCHAR szFullPath[MAX_PATH];
        WIN32_FIND_DATA fd;
        DWORD dwPinCount = 0;
        DWORD dwHintFlags = 0;

        ZeroMemory(&fd, sizeof(fd));
        fd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

        // Build the full path
        if (!PathCombine(szFullPath, pszShare, pszFile))
        {
            // fail instead?
            continue;
        }

        // Directories have a trailing "\*"
        if (StrChr(pszFile, TEXT('*')))
        {
            // It's a directory. Trim off the "\*"
            PathRemoveFileSpec(szFullPath);
            fd.dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        }

        // Update progress
        if (pufd->pfnProgressCB)
        {
            dwResult = (*pufd->pfnProgressCB)(szFullPath, pufd->lpContext);
            switch (dwResult)
            {
            case CSCPROC_RETURN_SKIP:
                continue;
            case CSCPROC_RETURN_ABORT:
                break;
            }
        }

        // Unpin it
        if (CSCUnpinFile(szFullPath,
                         FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER,
                         NULL,
                         &dwPinCount,
                         &dwHintFlags))
        {
            StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), PathFindFileName(szFullPath));
            ShellChangeNotify(szFullPath, &fd, FALSE);
        }

        // If it's a directory, unpin its contents
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            _CSCEnumDatabase(szFullPath,
                             pufd->bSubfolders,
                             _UnpinCallback,
                             (LPARAM)pufd);
        }

        // Is it still pinned?
        if (!dwHintFlags && !dwPinCount)
        {
            // Remove it from the cache (folders may still contain children
            // so we expect this to fail sometimes).
            if (NOERROR == CscDelete(szFullPath) && pufd->bOffline)
            {
                // Removing from the cache while in offline mode means
                // it's no longer available, so remove it from view.
                ShellChangeNotify(szFullPath,
                                  &fd,
                                  FALSE,
                                  (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? SHCNE_RMDIR : SHCNE_DELETE);
            }
        }
    }

    return dwResult;
}

void
CscUnpinFileList(CscFilenameList      *pfnl,
                 BOOL                  bSubfolders,
                 BOOL                  bOffline,
                 LPCTSTR               pszShare,
                 PFN_UNPINPROGRESSPROC pfnProgressCB,
                 LPARAM                lpContext)
{
    UNPIN_FILES_DATA ufd;
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    CscFilenameList::HSHARE hShare;

    if (NULL == pfnl || !pfnl->IsValid() || 0 == pfnl->GetFileCount())
        return;

    ufd.bSubfolders = bSubfolders;
    ufd.bOffline = bOffline;
    ufd.pfnProgressCB = pfnProgressCB;
    ufd.lpContext = lpContext;

    if (pszShare)   // enumerate this share only
    {
        if (pfnl->GetShareHandle(pszShare, &hShare))
            _UnpinOneShare(pfnl, hShare, &ufd);
    }
    else            // enumerate everything in the list
    {
        CscFilenameList::ShareIter si = pfnl->CreateShareIterator();

        while (si.Next(&hShare) && dwResult != CSCPROC_RETURN_ABORT)
        {
            dwResult = _UnpinOneShare(pfnl, hShare, &ufd);
        }
    }

    // Flush the shell notify queue
    ShellChangeNotify(NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\sharecnx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sharecnx.h
//
//--------------------------------------------------------------------------

#ifndef _WINDOWS_
#   include <windows.h>
#endif
#ifndef _INC_COMMCTRL_
#   include <commctrl.h>
#endif
#ifndef _INC_COMCTRLP
#   include <comctrlp.h>
#endif

class CShareCnxStatusCache
{
    public:
        CShareCnxStatusCache(void);
        ~CShareCnxStatusCache(void);

        HRESULT IsOpenConnectionShare(LPCTSTR pszShare, bool bRefresh = false);
        HRESULT IsOpenConnectionPathUNC(LPCTSTR pszPathUNC, bool bRefresh = false);

    private:
        class Entry
        {
            public:
                enum { StatusOpenCnx = 0x00000001 };     // 1 == Open connection.

                explicit Entry(LPCTSTR pszShare, DWORD dwStatus = 0);
                ~Entry(void);
                //
                // Refresh cached data in m_dwStatus member.
                //
                HRESULT Refresh(void);
                //
                // Returns the status DWORD.
                //
                DWORD Status(void) const
                    { return m_dwStatus; }
                //
                // Returns true if requested status bits are set.
                //
                bool CheckStatus(DWORD dwMask) const
                    { return boolify(dwMask == (m_dwStatus & dwMask)); }
                //
                // Returns error bits from m_dwStatus member.
                //
                HRESULT LastResult(void) const
                    { return m_hrLastResult; }
                //
                // Returns address of share name.  Can be NULL.
                //
                LPCTSTR Share(void) const
                    { return m_pszShare; }
                //
                // Returns true if share name ptr is non-null and all error
                // bits in m_dwStatus member are clear.
                //
                bool IsValid(void) const
                    { return NULL != Share() && SUCCEEDED(m_hrLastResult); }
                //
                // Static function for obtaining share's system status.  Result goes
                // in m_dwStatus member.  Static so that creator of an Entry object
                // can use the status value in the Entry ctor.
                //
                static HRESULT QueryShareStatus(LPCTSTR pszShare, DWORD *pdwStatus);

            private:
                LPTSTR m_pszShare;     // Name of the share associated with entry.
                DWORD  m_dwStatus;     // Share status and error bits.
                DWORD  m_hrLastResult; // Last query result.
                //
                // Prevent copy.
                //
                Entry(const Entry& rhs);
                Entry& operator = (const Entry& rhs);
                //
                // We don't want folks creating blank entries.
                // The error reporting structure assumes that a NULL
                // m_pszShare member indicates an allocation failure.
                //
                Entry(void)
                    : m_pszShare(NULL),
                      m_dwStatus(0),
                      m_hrLastResult(E_FAIL) { }
        };

        HDPA m_hdpa;  // Dynamic array of Entry object ptrs.

        //
        // Number of entries in cache.
        //
        int Count(void) const;
        //
        // Add an entry to the cache.
        //
        Entry *AddEntry(LPCTSTR pszShare, DWORD dwStatus);
        //
        // Find an entry in the cache.
        //
        Entry *FindEntry(LPCTSTR pszShare) const;
        //
        // Retrieve a given entry at a given DPA index.
        //
        Entry *GetEntry(int iEntry) const
            { return (Entry *)DPA_GetPtr(m_hdpa, iEntry); }
        //
        // Same as GetEntry but won't AV if m_hdpa is NULL.
        //
        Entry *SafeGetEntry(int iEntry) const
            { return NULL != m_hdpa ? GetEntry(iEntry) : NULL; }
        //
        // Get the status information for a share.
        //
        HRESULT GetShareStatus(LPCTSTR pszShare, DWORD *pdwStatus, bool bRefresh);
        //
        // Prevent copy.
        //
        CShareCnxStatusCache(const CShareCnxStatusCache& rhs);
        CShareCnxStatusCache& operator = (const CShareCnxStatusCache& rhs);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------
#include <pch.h>
#pragma hdrstop

#define DEFINE_CSCUI_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\statdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       statdlg.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "statdlg.h"
#include "resource.h"
#include "folder.h"
#include "cscst.h"
#include "options.h"
#include "fopendlg.h"
#include "msgbox.h"
#include "strings.h"

// Global used for IsDialogMessage processing
HWND g_hwndStatusDlg = NULL;

CStatusDlg::CStatusDlg(
    HINSTANCE hInstance,
    LPCTSTR pszText,
    eSysTrayState eState,
    Modes mode            // Optional.  Default is MODE_NORMAL
    ) : m_hInstance(hInstance),
        m_hwndDlg(NULL),
        m_hwndLV(NULL),
        m_himl(NULL),
        m_mode(mode),
        m_bExpanded(true),
        m_bSortAscending(true),
        m_iLastColSorted(-1),
        m_eSysTrayState(eState),
        m_cyExpanded(0),
        m_pszText(StrDup(pszText)) 
{ 
}

CStatusDlg::~CStatusDlg(
    void
    ) 
{ 
    if (NULL != m_pszText)
    {
        LocalFree(m_pszText);
    }
}

int
CStatusDlg::Create(
    HWND hwndParent,
    LPCTSTR pszText,
    eSysTrayState eState,
    Modes mode
    )
{
    int iResult = 0;
    CStatusDlg *pdlg = new CStatusDlg(g_hInstance, pszText, eState, mode);
    if (pdlg)
    {
        iResult = pdlg->Run(hwndParent);
        if (!iResult)
            delete pdlg;
        // else pdlg is automatically deleted when the dialog is closed
    }
    return iResult;
}

//
// Run the status dialog as a modeless dialog.
// Activates an existing instance if one is available.
//
int
CStatusDlg::Run(
    HWND hwndParent
    )
{
    //
    // First activate an existing instance if one is already running.
    //
    int iResult = 0;
    TCHAR szDlgTitle[MAX_PATH];
    LoadString(m_hInstance, IDS_STATUSDLG_TITLE, szDlgTitle, ARRAYSIZE(szDlgTitle));

    m_hwndDlg = FindWindow(NULL, szDlgTitle);
    if (NULL != m_hwndDlg && IsWindow(m_hwndDlg) && IsWindowVisible(m_hwndDlg))
    {
        SetForegroundWindow(m_hwndDlg);
    }
    else
    {
        //
        // Otherwise create a new dialog.
        // We need to use CreateDialog rather than DialogBox because
        // sometimes the dialog is hidden.  DialogBox doesn't allow us to
        // change the visibility attributed defined in the dialog template.
        //
        m_hwndDlg = CreateDialogParam(m_hInstance,
                                      MAKEINTRESOURCE(IDD_CSCUI_STATUS),
                                      hwndParent,
                                      DlgProc,
                                      (LPARAM)this);
        if (NULL != m_hwndDlg)
        {
            ShowWindow(m_hwndDlg, MODE_NORMAL == m_mode ? SW_NORMAL : SW_HIDE);
            UpdateWindow(m_hwndDlg);

            // We don't need a message loop here. We're on systray's main
            // thread which has a message pump.

            iResult = 1;
        }
    }
    g_hwndStatusDlg = m_hwndDlg;
    return iResult;
}



void
CStatusDlg::Destroy(
    void
    )
{
    if (NULL != m_hwndDlg)
        DestroyWindow(m_hwndDlg);
    g_hwndStatusDlg = NULL;
}



INT_PTR CALLBACK 
CStatusDlg::DlgProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CStatusDlg *pThis = (CStatusDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    BOOL bResult = FALSE;
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            pThis = (CStatusDlg *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pThis);
            pThis->m_hwndDlg = hwnd;
            bResult = pThis->OnInitDialog(wParam, lParam);
            break;
        }

        case WM_COMMAND:
            if (NULL != pThis)
                bResult = pThis->OnCommand(wParam, lParam);
            break;

        case WM_NOTIFY:
            bResult = pThis->OnNotify(wParam, lParam);
            break;

        case WM_DESTROY:
            pThis->OnDestroy();
            break;
    }
    return bResult;
}


//
// WM_INITDIALOG handler.
//
BOOL
CStatusDlg::OnInitDialog(
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult = TRUE;
    RECT rcExpanded;
    CConfig& config = CConfig::GetSingleton();

    m_hwndLV = GetDlgItem(m_hwndDlg, IDC_LV_STATUSDLG);
    //
    // Center the dialog on the desktop before contraction.
    //
    CenterWindow(m_hwndDlg, GetDesktopWindow());
    //
    // Start with the dialog not expanded.
    //
    GetWindowRect(m_hwndDlg, &rcExpanded);
    m_cyExpanded = rcExpanded.bottom - rcExpanded.top;
    //
    // Set the cached "expanded" member to be the opposite of the user's
    // preference for expansion.  ExpandDialog will only change the
    // expanded state if it's different from the current state.
    //
    m_bExpanded = !UserLikesDialogExpanded();
    ExpandDialog(!m_bExpanded);
    //
    // Disable buttons as necessary.
    //
    if (config.NoCacheViewer())
        EnableWindow(GetDlgItem(m_hwndDlg, IDC_BTN_VIEWFILES), FALSE);
    if (config.NoConfigCache())
        EnableWindow(GetDlgItem(m_hwndDlg, IDC_BTN_SETTINGS), FALSE);
    //
    // Initialize the message text.
    //
    SetWindowText(GetDlgItem(m_hwndDlg, IDC_TXT_STATUSDLG), m_pszText ? m_pszText : TEXT(""));
    //
    // Turn on checkboxes for column 0.
    //
    EnableListviewCheckboxes(true);
    //
    // Create the imagelist.
    //
    m_himl = CreateImageList();
    if (NULL != m_himl)
        ListView_SetImageList(m_hwndLV, m_himl, LVSIL_SMALL);
    //
    // Create the listview columns.
    //
    CreateListColumns();
    //
    // Fill the listview.
    //
    FillListView();

    if (MODE_AUTOSYNC == m_mode)
    {
        //
        // The dialog is being invoked for it's synchronize function only.
        // The dialog will not be displayed but we'll invoke the synchronize 
        // function just as if it had been displayed.  This feature is used 
        // by the systray context menu to ensure we get the same synchronize 
        // behavior if the action is invoked through either the dialog or 
        // the systray context menu.
        //
        PostMessage(m_hwndDlg, WM_COMMAND, IDOK, 0);
    }
    else
    {
        //
        // Since we're a child of the hidden systray window we need to force ourselves
        // to the forground.
        //
        SetForegroundWindow(m_hwndDlg);
    }

    return bResult;
}


//
// WM_DESTROY handler.
//
BOOL
CStatusDlg::OnDestroy(
    void
    )
{
    RememberUsersDialogSizePref(m_bExpanded);
    DestroyLVEntries();

    //
    // Destroy the CStatusDlg object
    //
    delete this;

    //
    // Image list is automatically destroyed by the listview in comctl32.
    //
    return FALSE;
}


//
// WM_COMMAND handler.
//
BOOL
CStatusDlg::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult = TRUE;
    switch(LOWORD(wParam))
    {
        case IDOK:
            SynchronizeServers();
            // Fall through and destroy the dialog
        case IDCANCEL:
        case IDCLOSE:
            Destroy();
            break;
            
        case IDC_BTN_VIEWFILES:
            COfflineFilesFolder::Open();
            break;

        case IDC_BTN_SETTINGS:
            COfflineFilesSheet::CreateAndRun(g_hInstance, GetDesktopWindow(), &g_cRefCount);
            break;

        case IDC_BTN_DETAILS:
            ExpandDialog(!m_bExpanded);
            break;

        default:
            bResult = FALSE;
            break;  
    }
    return bResult;
}


//
// WM_NOTIFY handler.
//
BOOL
CStatusDlg::OnNotify(
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult = TRUE;
  //int idCtl    = int(wParam);
    LPNMHDR pnm  = (LPNMHDR)lParam;

    switch(pnm->code)
    {
        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)lParam);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)lParam);
            break;

        default:
            bResult = FALSE;
            break;
    }
    return bResult;
}

//
// LVN_GETDISPINFO handler.
//
void
CStatusDlg::OnLVN_GetDispInfo(
    LV_DISPINFO *plvdi
    )
{
    LVEntry *pEntry = (LVEntry *)plvdi->item.lParam;
    if (LVIF_TEXT & plvdi->item.mask)
    {
        static TCHAR szText[MAX_PATH];
        szText[0] = TEXT('\0');
        switch(plvdi->item.iSubItem)
        {
            case iLVSUBITEM_SERVER:
                StringCchCopy(szText, ARRAYSIZE(szText), pEntry->Server());
                break;
                
            case iLVSUBITEM_STATUS:
                pEntry->GetStatusText(szText, ARRAYSIZE(szText));
                break;

            case iLVSUBITEM_INFO:
                pEntry->GetInfoText(szText, ARRAYSIZE(szText));
                break;
        }
        plvdi->item.pszText = szText;
    }
    if (LVIF_IMAGE & plvdi->item.mask)
    {
        plvdi->item.iImage = pEntry->GetImageIndex();
    }
}

//
// LVN_COLUMNCLICK handler.
//
void
CStatusDlg::OnLVN_ColumnClick(
    NM_LISTVIEW *pnmlv
    )
{
    if (m_iLastColSorted != pnmlv->iSubItem)
    {
        m_bSortAscending = true;
        m_iLastColSorted = pnmlv->iSubItem;
    }
    else
    {
        m_bSortAscending = !m_bSortAscending;
    }

    ListView_SortItems(m_hwndLV, CompareLVItems, LPARAM(this));
}


//
// Create the server listview columns.
//
void
CStatusDlg::CreateListColumns(
    void
    )
{
    //
    // Clear out the listview and header.
    //
    ListView_DeleteAllItems(m_hwndLV);
    HWND hwndHeader = ListView_GetHeader(m_hwndLV);
    if (NULL != hwndHeader)
    {
        while(0 < Header_GetItemCount(hwndHeader))
            ListView_DeleteColumn(m_hwndLV, 0);
    }

    //
    // Create the header titles.
    //
    TCHAR szServer[80] = {0};
    TCHAR szStatus[80] = {0};
    TCHAR szInfo[80]   = {0};
    LoadString(m_hInstance, IDS_STATUSDLG_HDR_SERVER, szServer, ARRAYSIZE(szServer));
    LoadString(m_hInstance, IDS_STATUSDLG_HDR_STATUS, szStatus, ARRAYSIZE(szStatus));
    LoadString(m_hInstance, IDS_STATUSDLG_HDR_INFO,   szInfo,   ARRAYSIZE(szInfo));

    RECT rcList;
    GetClientRect(m_hwndLV, &rcList);
    int cxLV = rcList.right - rcList.left;

#define LVCOLMASK (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM)

    LV_COLUMN rgCols[] = { 
         { LVCOLMASK, LVCFMT_LEFT, cxLV/4, szServer, 0, iLVSUBITEM_SERVER },
         { LVCOLMASK, LVCFMT_LEFT, cxLV/4, szStatus, 0, iLVSUBITEM_STATUS },
         { LVCOLMASK, LVCFMT_LEFT, cxLV/2, szInfo,   0, iLVSUBITEM_INFO   }
                         };
    //
    // Add the columns to the listview.
    //
    for (INT i = 0; i < ARRAYSIZE(rgCols); i++)
    {
        ListView_InsertColumn(m_hwndLV, i, &rgCols[i]);
    }
}



//
// Populate the listview.
//
void
CStatusDlg::FillListView(
    void
    )
{
    DWORD dwStatus;
    DWORD dwPinCount;
    DWORD dwHintFlags;
    FILETIME ft;
    WIN32_FIND_DATA fd;

    CCscFindHandle hFind = CacheFindFirst(NULL, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft);
    if (hFind.IsValid())
    {
        LPTSTR pszServer = fd.cFileName;
        LPTSTR pszEnd;
        LVEntry *pEntry;
        CSCSHARESTATS stats;
        do
        {
            //
            // Exclude the following:
            //   1. Directories.
            //   2. Files marked as "locally deleted".
            //
            // NOTE:  The filtering done by this function must be the same as 
            //        in several other places throughout the CSCUI code.
            //        To locate these, search the source for the comment
            //        string CSCUI_ITEM_FILTER.
            //
            const DWORD fExclude = SSEF_LOCAL_DELETED | 
                                   SSEF_DIRECTORY;

            CSCGETSTATSINFO si = { fExclude,
                                   SSUF_NONE,
                                   false,      // No access info reqd (faster).
                                   false };     

            if (_GetShareStatisticsForUser(fd.cFileName, &si, &stats) && 
                (0 < stats.cTotal || stats.bOffline))
            {
                bool bReplacedBackslash = false;
                //
                // Extract the server name from the share name returned by CSC.
                //
                while(*pszServer && TEXT('\\') == *pszServer)
                    pszServer++;
                pszEnd = pszServer;
                while(*pszEnd && TEXT('\\') != *pszEnd)
                    pszEnd++;
                if (TEXT('\\') == *pszEnd)
                {
                    *pszEnd = TEXT('\0');
                    bReplacedBackslash = true;
                }
                //
                // Find an existing server entry.  If none found, create a new one.
                //
                if (NULL == (pEntry = FindLVEntry(pszServer)))
                {
                    bool bConnectable = boolify(SendToSystray(CSCWM_ISSERVERBACK, 0, (LPARAM)fd.cFileName));
                    pEntry = CreateLVEntry(pszServer, bConnectable);
                }
                if (NULL != pEntry)
                {
                    if (bReplacedBackslash)
                        *pszEnd = TEXT('\\');

                    //
                    // If we're running in "normal" mode, we 
                    // can't trust the share's "modified offline" bit.
                    // Use the info we got by scanning the cache.
                    // If we're running in "autosync" mode, we can just
                    // use the share's "modified offline" indicator.
                    // If something is truly modified offline, the bit
                    // will be set.
                    //
                    if (MODE_NORMAL == m_mode)
                    {
                        dwStatus &= ~FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE;
                        if (0 < stats.cModified)
                            dwStatus |= FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE;
                    }
                    //
                    // Add this share and it's statistics to the 
                    // server's list entry.
                    //
                    pEntry->AddShare(fd.cFileName, stats, dwStatus);
                }
            }
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft));
        //
        // Remove those servers that the user won't be interested in.
        // Also place a checkmark next to those servers that are available
        // for reconnection.
        //
        PrepListForDisplay();
    }
}


//
// Build the image list used by the server listview.
//
HIMAGELIST
CStatusDlg::CreateImageList(
    void
    )
{
    HIMAGELIST himl = NULL;

    //
    // Note:  The order of these icon ID's in this array must match with the
    //        iIMAGELIST_ICON_XXXXX enumeration.
    //        The enum values represent the image indices in the image list.
    //
    static const struct IconDef
    {
        LPTSTR szName;
        HINSTANCE hInstance;

    } rgIcons[] = { 
                    { MAKEINTRESOURCE(IDI_SERVER),         m_hInstance },
                    { MAKEINTRESOURCE(IDI_SERVER_OFFLINE), m_hInstance },
                    { MAKEINTRESOURCE(IDI_CSCINFORMATION), m_hInstance },
                    { MAKEINTRESOURCE(IDI_CSCWARNING),     m_hInstance }
                  };
    //
    // Create the image lists for the listview.
    //
    int cxIcon = GetSystemMetrics(SM_CXSMICON);
    int cyIcon = GetSystemMetrics(SM_CYSMICON);

    himl = ImageList_Create(cxIcon,
                            cyIcon,
                            ILC_MASK, 
                            ARRAYSIZE(rgIcons), 
                            10);
    if (NULL != himl)
    {
        for (UINT i = 0; i < ARRAYSIZE(rgIcons); i++)
        {
            HICON hIcon = (HICON)LoadImage(rgIcons[i].hInstance, 
                                           rgIcons[i].szName,
                                           IMAGE_ICON,
                                           cxIcon,
                                           cyIcon,
                                           0);
            if (NULL != hIcon)
            {
                ImageList_AddIcon(himl, hIcon);
                DestroyIcon(hIcon);
            }
        }
        ImageList_SetBkColor(himl, CLR_NONE);  // Transparent background.
    }

    return himl;
}


void
CStatusDlg::EnableListviewCheckboxes(
    bool bEnable
    )
{    
    DWORD dwStyle    = ListView_GetExtendedListViewStyle(m_hwndLV);
    DWORD dwNewStyle = bEnable ? (dwStyle | LVS_EX_CHECKBOXES) :
                                 (dwStyle & ~LVS_EX_CHECKBOXES);
                                 
    ListView_SetExtendedListViewStyle(m_hwndLV, dwNewStyle);
}


//
// The "Details" button changes it's title depending on 
// the dialog state (expanded or not).
//
void
CStatusDlg::UpdateDetailsBtnTitle(
    void
    )
{
    TCHAR szBtnTitle[80];
    int idsBtnTitle = IDS_OPENDETAILS;
    if (m_bExpanded)
        idsBtnTitle = IDS_CLOSEDETAILS;

    LoadString(m_hInstance, idsBtnTitle, szBtnTitle, ARRAYSIZE(szBtnTitle));
    SetWindowText(GetDlgItem(m_hwndDlg, IDC_BTN_DETAILS), szBtnTitle);
}

//
// Expand or contract the dialog vertically.
// When expanded, the server listview is made visible along
// with the "Settings..." and "View Files..." buttons.
//
void 
CStatusDlg::ExpandDialog(
    bool bExpand
    )
{
    if (bExpand != m_bExpanded)
    {
        CConfig& config = CConfig::GetSingleton();
        //
        // Table describing enable/disable state of controls in the lower part
        // of the dialog that are displayed when the dialog is expanded.
        //
        struct
        {
            UINT idCtl;
            bool bEnable;

        } rgidExpanded[] = { { IDC_LV_STATUSDLG,  bExpand },
                             { IDC_BTN_SETTINGS,  bExpand && !config.NoConfigCache() },
                             { IDC_BTN_VIEWFILES, bExpand && !config.NoCacheViewer() }
                           };

        RECT rcDlg;
        GetWindowRect(m_hwndDlg, &rcDlg);
        if (!bExpand)
        {
            //
            // Closing details.
            //
            RECT rcSep;
            GetWindowRect(GetDlgItem(m_hwndDlg, IDC_SEP_STATUSDLG), &rcSep);
            rcDlg.bottom = rcSep.top;
        }
        else
        {
            //
            // Opening details.
            //
            rcDlg.bottom = rcDlg.top + m_cyExpanded;
        }

        //
        // If the dialog is not expanded, we want to disable all of the
        // "tabbable" items in the hidden part so they don't participate
        // in the dialog's tab order.  Note that the "Settings" and
        // "View Files" buttons also have a policy setting involved in
        // the enabling logic.
        //
        for (int i = 0; i < ARRAYSIZE(rgidExpanded); i++)
        {
            EnableWindow(GetDlgItem(m_hwndDlg, rgidExpanded[i].idCtl), rgidExpanded[i].bEnable);
        }

        SetWindowPos(m_hwndDlg,
                     NULL,
                     rcDlg.left,
                     rcDlg.top,
                     rcDlg.right - rcDlg.left,
                     rcDlg.bottom - rcDlg.top,
                     SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

        m_bExpanded = bExpand;
        UpdateDetailsBtnTitle();
    }
}




//
// Queries the HKCU reg data to see if the user closed the dialog
// expanded or not expanded last time the dialog was used.
// Returns:  true = expanded, false = not expanded.
//
bool
CStatusDlg::UserLikesDialogExpanded(
    void
    )
{
    DWORD dwExpanded = 0;
    DWORD cbData = sizeof(DWORD);
    SHRegGetValue(HKEY_CURRENT_USER,
                  REGSTR_KEY_OFFLINEFILES,
                  REGSTR_VAL_EXPANDSTATUSDLG,
                  SRRF_RT_DWORD,
                  NULL,
                  &dwExpanded,
                  &cbData);
    return !!dwExpanded;
}


//
// Stores the current state of the status dialog in per-user
// reg data.  Used next time the dialog is opened so that if the
// user likes the dialog expanded, it opens expanded.
//
void
CStatusDlg::RememberUsersDialogSizePref(
    bool bExpanded
    )
{
    DWORD dwExpanded = DWORD(bExpanded);
    SHSetValue(HKEY_CURRENT_USER,
               REGSTR_KEY_OFFLINEFILES,
               REGSTR_VAL_EXPANDSTATUSDLG,
               REG_DWORD,
               &dwExpanded,
               sizeof(dwExpanded));
}


//
// Build a list of share names for synchronization and
// reconnect.
//
HRESULT 
CStatusDlg::BuildFilenameList(
    CscFilenameList *pfnl
    )
{
    LVEntry *pEntry;
    LVITEM item;

    int cEntries = ListView_GetItemCount(m_hwndLV);
    for (int i = 0; i < cEntries; i++)
    {
        if (ListView_GetCheckState(m_hwndLV, i))
        {
            //
            // Server has checkmark so we add it's
            // shares to the filename list.
            //
            item.mask     = LVIF_PARAM;
            item.iItem    = i;
            item.iSubItem = 0;
            if (ListView_GetItem(m_hwndLV, &item))
            {
                pEntry = (LVEntry *)item.lParam;
                int cShares = pEntry->GetShareCount();
                for (int iShare = 0; iShare < cShares; iShare++)
                {
                    LPCTSTR pszShare = pEntry->GetShareName(iShare);
                    if (NULL != pszShare)
                    {
                        if (!pfnl->AddFile(pszShare, TRUE))
                            return E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    return NOERROR;
}


//
// Synchronize all of the checked servers from the listview and
// reconnect them.
//
HRESULT
CStatusDlg::SynchronizeServers(
    void
    )
{
    HRESULT hr = NOERROR;
    const bool bSkipTheSync = BST_CHECKED == IsDlgButtonChecked(m_hwndDlg, IDC_CBX_STATUSDLG);
    
    if (::IsSyncInProgress())
    {
        CscMessageBox(m_hwndDlg, 
                      MB_OK | MB_ICONINFORMATION, 
                      m_hInstance, 
                      bSkipTheSync ? IDS_CANTRECONN_SYNCINPROGRESS : IDS_CANTSYNC_SYNCINPROGRESS);
    }
    else
    {
        //
        // First build the FilenameList containing shares to sync.
        //
        CscFilenameList fnl;
        hr = BuildFilenameList(&fnl);
        if (SUCCEEDED(hr))
        {
            if (bSkipTheSync)
            {
                //
                // User has checked "reconnect without sync" checkbox.
                // Therefore, we skip the sync and go straight to reconnect.
                //
                hr = ReconnectServers(&fnl, TRUE, FALSE);
                if (S_OK == hr)
                {
                    PostToSystray(CSCWM_UPDATESTATUS, STWM_STATUSCHECK, 0);
                }

            }
            else
            {
                const DWORD dwUpdateFlags = CSC_UPDATE_STARTNOW |
                                            CSC_UPDATE_SELECTION |
                                            CSC_UPDATE_REINT |
                                            CSC_UPDATE_NOTIFY_DONE |
                                            CSC_UPDATE_SHOWUI_ALWAYS |
                                            CSC_UPDATE_RECONNECT;
                //
                // Syncing is an asynchronous operation involving
                // mobsync.exe.  The code in CscUpdateCache will check for open
                // files and notify the user.  When the sync is done, it will
                // transition everything in the file list to online mode.
                //
                hr = CscUpdateCache(dwUpdateFlags, &fnl);
            }
        }
    }
    return hr;
}


//
// Create an entry for the listview.
// Returns ptr to new entry on success.  NULL on failure.
//
CStatusDlg::LVEntry *
CStatusDlg::CreateLVEntry(
    LPCTSTR pszServer,
    bool bConnectable
    )
{
    LVEntry *pEntry = new LVEntry(m_hInstance, pszServer, bConnectable);
    if (NULL != pEntry)
    {
        LVITEM item;
        item.mask     = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        item.lParam   = (LPARAM)pEntry;
        item.iItem    = ListView_GetItemCount(m_hwndLV);
        item.iSubItem = 0;
        item.pszText  = LPSTR_TEXTCALLBACK;
        item.iImage   = I_IMAGECALLBACK;
        if (-1 == ListView_InsertItem(m_hwndLV, &item))
        {
            delete pEntry;
            pEntry = NULL;
        }
    }
    return pEntry;
}

//
// Find an entry in the listview using the servername as the key.
// Return ptr to entry on success.  NULL on failure.
//
CStatusDlg::LVEntry *
CStatusDlg::FindLVEntry(
    LPCTSTR pszServer
    )
{
    LVEntry *pEntry = NULL;
    LVITEM item;

    int cEntries = ListView_GetItemCount(m_hwndLV);
    for (int i = 0; i < cEntries; i++)
    {
        item.mask     = LVIF_PARAM;
        item.iItem    = i;
        item.iSubItem = 0;
        if (ListView_GetItem(m_hwndLV, &item))
        {
            pEntry = (LVEntry *)item.lParam;
            //
            // This comparison must be case-INSENSITIVE.  Entries
            // in the CSC database are on a "\\server\share" basis and
            // are at the mercy of what was passed in through the CSC APIs.
            // Therefore, the database can contain "\\Foo\bar" and
            // "\\foo\bar2".  We must treat "Foo" and "foo" as the single
            // server they represent.
            //
            if (0 == lstrcmpi(pEntry->Server(), pszServer))
                break;
            pEntry = NULL;
        }
    }
    return pEntry;
}

//
// Clear out the listview.  Ensures all listview item objects
// are destroyed.
//
void
CStatusDlg::DestroyLVEntries(
    void
    )
{
    LVITEM item;

    int cEntries = ListView_GetItemCount(m_hwndLV);
    for (int i = 0; i < cEntries; i++)
    {
        item.mask     = LVIF_PARAM;
        item.iItem    = i;
        item.iSubItem = 0;
        if (ListView_GetItem(m_hwndLV, &item))
        {
            delete (LVEntry *)item.lParam;
            if (ListView_DeleteItem(m_hwndLV, i))
            {
                i--;
                cEntries--;
            }
        }
    }
}

//
// Determine if a listview entry should remain visible in the listview.
// Currently we include servers that currently connected through the 
// network redirector and are offline OR those that are dirty.
// 
bool
CStatusDlg::ShouldIncludeLVEntry(
    const CStatusDlg::LVEntry& entry
    )
{
    DWORD dwCscStatus;
    entry.GetStats(NULL, &dwCscStatus);

    return (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwCscStatus) || 
           (FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE & dwCscStatus);
}


//
// Determine if a checkmark should be placed next to an item in 
// the listview.
//
bool
CStatusDlg::ShouldCheckLVEntry(
    const CStatusDlg::LVEntry& entry
    )
{
    return true;
}


//
// Remove all entries not to be displayed from the listview.
// Initially we create LV entries for each server in the CSC cache.  
// After all servers have been entered and their statistics tallied,
// we call PrepListForDisplay to remove the ones that the
// user won't want to see.
// 
void
CStatusDlg::PrepListForDisplay(
    void
    )
{
    LVEntry *pEntry;
    LVITEM item;

    int cEntries = ListView_GetItemCount(m_hwndLV);
    for (int i = 0; i < cEntries; i++)
    {
        item.mask     = LVIF_PARAM;
        item.iItem    = i;
        item.iSubItem = 0;
        if (ListView_GetItem(m_hwndLV, &item))
        {
            pEntry = (LVEntry *)item.lParam;
            if (ShouldIncludeLVEntry(*pEntry))
            {
                ListView_SetCheckState(m_hwndLV, i, ShouldCheckLVEntry(*pEntry));
            }
            else
            {
                delete pEntry;
                if (ListView_DeleteItem(m_hwndLV, i))
                {
                    i--;
                    cEntries--;
                }
            }
        }
    }
}


//
// Listview item comparison callback.
//
int CALLBACK 
CStatusDlg::CompareLVItems(
    LPARAM lParam1, 
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    CStatusDlg *pdlg = reinterpret_cast<CStatusDlg *>(lParamSort);
    CStatusDlg::LVEntry *pEntry1 = reinterpret_cast<CStatusDlg::LVEntry *>(lParam1);
    CStatusDlg::LVEntry *pEntry2 = reinterpret_cast<CStatusDlg::LVEntry *>(lParam2);
    int diff = 0;
    TCHAR szText1[MAX_PATH];
    TCHAR szText2[MAX_PATH];

    //
    // This array controls the comparison column IDs used when
    // values for the selected column are equal.  These should
    // remain in order of the iLVSUBITEM_xxxxx enumeration with
    // respect to the first element in each row.
    //
    static const int rgColComp[3][3] = { 
        { iLVSUBITEM_SERVER, iLVSUBITEM_STATUS, iLVSUBITEM_INFO   },
        { iLVSUBITEM_STATUS, iLVSUBITEM_SERVER, iLVSUBITEM_INFO   },
        { iLVSUBITEM_INFO,   iLVSUBITEM_SERVER, iLVSUBITEM_STATUS }
                                       };
    int iCompare = 0;
    while(0 == diff && iCompare < ARRAYSIZE(rgColComp))
    {
        //
        // This comparison should be case-sensitive since it is controlling
        // sort order of display columns.
        //
        switch(rgColComp[pdlg->m_iLastColSorted][iCompare++])
        {
            case iLVSUBITEM_SERVER:
                diff = lstrcmp(pEntry1->Server(), pEntry2->Server());
                break;

            case iLVSUBITEM_STATUS:
                pEntry1->GetStatusText(szText1, ARRAYSIZE(szText1));
                pEntry2->GetStatusText(szText2, ARRAYSIZE(szText2));
                diff = lstrcmp(szText1, szText2);
                break;

            case iLVSUBITEM_INFO:
                pEntry1->GetInfoText(szText1, ARRAYSIZE(szText1));
                pEntry2->GetInfoText(szText2, ARRAYSIZE(szText2));
                diff = lstrcmp(szText1, szText2);
                break;

            default:
                //
                // If you hit this, you need to update this function
                // to handle the new column you've added to the listview.
                //
                TraceAssert(false);
                break;
        }
    }

    return pdlg->m_bSortAscending ? diff : -1 * diff;
}



const TCHAR CStatusDlg::LVEntry::s_szBlank[] = TEXT("");
//
// There are 3 binary conditions that control the selection of the entry 
// display information.  Therefore we can use a simple 8-element map of string resource
// IDs and icon image list indices to determine the correct display information
// string for the corresponding LV entry state.  GetDispInfoIndex() is called
// to retrieve the index for a particular LVEntry.
//
const CStatusDlg::LVEntry::DispInfo 
CStatusDlg::LVEntry::s_rgDispInfo[] = {                                                                   // online available modified
    { IDS_SHARE_STATUS_OFFLINE, IDS_SHARE_INFO_UNAVAIL,     CStatusDlg::iIMAGELIST_ICON_SERVER_OFFLINE }, //    0       0         0      
    { IDS_SHARE_STATUS_OFFLINE, IDS_SHARE_INFO_UNAVAIL_MOD, CStatusDlg::iIMAGELIST_ICON_SERVER_OFFLINE }, //    0       0         1
    { IDS_SHARE_STATUS_OFFLINE, IDS_SHARE_INFO_AVAIL,       CStatusDlg::iIMAGELIST_ICON_SERVER_BACK    }, //    0       1         0
    { IDS_SHARE_STATUS_OFFLINE, IDS_SHARE_INFO_AVAIL_MOD,   CStatusDlg::iIMAGELIST_ICON_SERVER_BACK    }, //    0       1         1 
    { IDS_SHARE_STATUS_ONLINE,  IDS_SHARE_INFO_BLANK,       CStatusDlg::iIMAGELIST_ICON_SERVER         }, //    1       0         0
    { IDS_SHARE_STATUS_ONLINE,  IDS_SHARE_INFO_DIRTY,       CStatusDlg::iIMAGELIST_ICON_SERVER_DIRTY   }, //    1       0         1
    { IDS_SHARE_STATUS_ONLINE,  IDS_SHARE_INFO_BLANK,       CStatusDlg::iIMAGELIST_ICON_SERVER         }, //    1       1         0
    { IDS_SHARE_STATUS_ONLINE,  IDS_SHARE_INFO_DIRTY,       CStatusDlg::iIMAGELIST_ICON_SERVER_DIRTY   }  //    1       1         1
    };

CStatusDlg::LVEntry::LVEntry(
    HINSTANCE hInstance,
    LPCTSTR pszServer,
    bool bConnectable
    ) : m_hInstance(hInstance),
        m_pszServer(StrDup(pszServer)),
        m_dwCscStatus(0),
        m_hdpaShares(DPA_Create(4)),
        m_bConnectable(bConnectable),
        m_iDispInfo(-1)
{
    m_stats.cTotal    = 0;
    m_stats.cPinned   = 0;
    m_stats.cModified = 0;
    m_stats.cSparse   = 0;

    if (NULL == m_pszServer)
        m_pszServer = const_cast<LPTSTR>(s_szBlank);
}


CStatusDlg::LVEntry::~LVEntry(
    void
    )
{
    if (s_szBlank != m_pszServer && NULL != m_pszServer)
    {
        LocalFree(m_pszServer);
    }
    if (NULL != m_hdpaShares)
    {
        int cShares = DPA_GetPtrCount(m_hdpaShares);
        for (int i = 0; i < cShares; i++)
        {
            LPTSTR psz = (LPTSTR)DPA_GetPtr(m_hdpaShares, i);
            if (NULL != psz)
            {
                LocalFree(psz);
            }
        }
        DPA_Destroy(m_hdpaShares);
    }
}


bool
CStatusDlg::LVEntry::AddShare(
    LPCTSTR pszShare,
    const CSCSHARESTATS& s,
    DWORD dwCscStatus
    )
{
    bool bResult = false;
    if (NULL != m_hdpaShares)
    {
        LPTSTR pszCopy = StrDup(pszShare);
        if (NULL != pszCopy)
        {
            if (-1 != DPA_AppendPtr(m_hdpaShares, pszCopy))
            {
                m_stats.cTotal    += s.cTotal;
                m_stats.cPinned   += s.cPinned;
                m_stats.cModified += s.cModified;
                m_stats.cSparse   += s.cSparse;

                m_dwCscStatus |= dwCscStatus;

                bResult = true;
            }
            else
            {
                LocalFree(pszCopy);
            }
        }
    }
    return bResult;
}


int 
CStatusDlg::LVEntry::GetShareCount(
    void
    ) const
{
    if (NULL != m_hdpaShares)
        return DPA_GetPtrCount(m_hdpaShares);
    return 0;
}


LPCTSTR 
CStatusDlg::LVEntry::GetShareName(
    int iShare
    ) const
{
    if (NULL != m_hdpaShares)
        return (LPCTSTR)DPA_GetPtr(m_hdpaShares, iShare);
    return NULL;
}


void 
CStatusDlg::LVEntry::GetStats(
    CSCSHARESTATS *ps,
    DWORD *pdwCscStatus
    ) const
{
    if (NULL != ps)
        *ps = m_stats;
    if (NULL != pdwCscStatus)
        *pdwCscStatus = m_dwCscStatus;
}

//
// Determines the index into s_rgDispInfo[] for obtaining display information
// for the LV entry.
//
int
CStatusDlg::LVEntry::GetDispInfoIndex(
    void
    ) const
{
    if (-1 == m_iDispInfo)
    {
        m_iDispInfo = 0;

        if (IsModified())
            m_iDispInfo |= DIF_MODIFIED;

        if (!IsOffline())
            m_iDispInfo |= DIF_ONLINE;

        if (IsConnectable())
            m_iDispInfo |= DIF_AVAILABLE;
    }
    return m_iDispInfo;
}


//
// Retrieve the entry's text for the "Status" column in the listview.
//
void 
CStatusDlg::LVEntry::GetStatusText(
    LPTSTR pszStatus, 
    int cchStatus
    ) const
{
    UINT idsStatusText = s_rgDispInfo[GetDispInfoIndex()].idsStatusText;
    LoadString(m_hInstance, idsStatusText, pszStatus, cchStatus);
}


//
// Retrieve entry's text for the "Information" column in the listview.
//
void 
CStatusDlg::LVEntry::GetInfoText(
    LPTSTR pszInfo, 
    int cchInfo
    ) const
{
    int iInfoText = GetDispInfoIndex();
    int idsInfoText = s_rgDispInfo[iInfoText].idsInfoText;
    if (iInfoText & DIF_MODIFIED)
    {
        //
        // Info text has embedded modified file count.
        // Requires a little more work.
        //
        TCHAR szTemp[MAX_PATH];
        INT_PTR rgcModified[] = { m_stats.cModified };
        LoadString(m_hInstance, idsInfoText, szTemp, ARRAYSIZE(szTemp));
        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szTemp,
                      0,
                      0,
                      pszInfo,
                      cchInfo,
                      (va_list *)rgcModified);
    }
    else
    {
        LoadString(m_hInstance, idsInfoText, pszInfo, cchInfo);
    }
}


//
// Retrieve entry's imagelist index for the image displayed next to the
// entry in the listview.
//
int
CStatusDlg::LVEntry::GetImageIndex(
    void
    ) const
{
    return s_rgDispInfo[GetDispInfoIndex()].iImage;
}


//
// Wrapper for CSCTransitionServerOnline
//
//
// CAUTION!
//
// TransitionShareOnline is called from ReconnectServers (below) which
// means we may be running in either explorer or mobsync.  It's also
// called directly from the systray code when auto-reconnecting a
// server.
//
// 1. Be careful with SendMessage, since it may go out of process. Note that
// STDBGOUT uses SendMessage.
// 2. Be careful not to do anything that could cause a transition to offline,
// which results in a SendMessage from WinLogon, which deadlocks if we are
// running on the systray thread (the recipient of the SendMessage).
// For example, use SHSimpleIDListFromFindData instead of ILCreateFromPath.
//
BOOL
TransitionShareOnline(LPCTSTR pszShare,
                      BOOL  bShareIsAlive,  // TRUE skips CheckShareOnline
                      BOOL  bCheckSpeed,    // FALSE skips slow link check
                      DWORD dwPathSpeed)    // Used if (bShareIsAlive && bCheckSpeed)
{
    BOOL bShareTransitioned = FALSE;
    DWORD dwShareStatus;

    if (!pszShare || !*pszShare)
        return FALSE;

    //
    // Protect against calling CSCCheckShareOnline & CSCTransitionServerOnline
    // for shares that are already online. In particular, CSCCheckShareOnline
    // establishes a net connection so it can be slow.
    //
    // This also means that we call CSCTransitionServerOnline for only one
    // share on a given server, since all shares transition online/offline
    // at the same time.
    //
    if (CSCQueryFileStatus(pszShare, &dwShareStatus, NULL, NULL)
        && (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus))
    {
        //
        // Only try to transition the server online if the share is
        // truly available on the net.  Otherwise we'll put the server online
        // and the next call for net resources on that server will cause a net
        // timeout.
        //
        if (!bShareIsAlive)
        {
            bShareIsAlive = CSCCheckShareOnlineEx(pszShare, &dwPathSpeed);
            if (!bShareIsAlive)
            {
                DWORD dwErr = GetLastError();
                if (ERROR_ACCESS_DENIED == dwErr ||
                    ERROR_LOGON_FAILURE == dwErr)
                {
                    // The share is reachable, but we don't have valid
                    // credentials.  We don't have a valid path speed,
                    // so the best we can do is assume fast link.
                    //
                    // Currently, this function is always called with
                    // bShareIsAlive and bCheckSpeed both TRUE or both FALSE
                    // so it doesn't make any difference.  Could change in
                    // the future, though.
                    //
                    bShareIsAlive = TRUE;
                    bCheckSpeed = FALSE;
                }
            }
        }
        if (bShareIsAlive)
        {
            //
            // Also, for auto-reconnection, we only transition if not on a
            // slow link.
            //
            if (!bCheckSpeed || !_PathIsSlow(dwPathSpeed))
            {
                //
                // Transition to online
                //
                STDBGOUT((2, TEXT("Transitioning server \"%s\" to online"), pszShare));
                if (CSCTransitionServerOnline(pszShare))
                {
                    STDBGOUT((1, TEXT("Server \"%s\" reconnected."), pszShare));
                    LPTSTR pszTemp;
                    if (LocalAllocString(&pszTemp, pszShare))
                    {
                        //
                        // Strip the path to only the "\\server" part.
                        //
                        PathStripToRoot(pszTemp);
                        PathRemoveFileSpec(pszTemp);
                        SendCopyDataToSystray(PWM_REFRESH_SHELL, StringByteSize(pszTemp), pszTemp);
                        LocalFreeString(&pszTemp);
                    }
                    bShareTransitioned = TRUE;
                }
                else
                {
                    STDBGOUT((1, TEXT("Error %d reconnecting \"%s\""), GetLastError(), pszShare));
                }
            }
            else
            {
                STDBGOUT((1, TEXT("Path to \"%s\" is SLOW.  No reconnect."), pszShare));
            }
        }
        else
        {
            STDBGOUT((1, TEXT("Unable to connect to \"%s\".  No reconnect."), pszShare));
        }
    }

    return bShareTransitioned;
}


//
// CAUTION!
//
// ReconnectServers is called from both the Status Dialog (explorer) and
// the sync update handler (mobsync.exe). Any communication with systray
// must be done in a process-safe manner.
//
// See comments for TransitionShareOnline above.
//
HRESULT
ReconnectServers(CscFilenameList *pfnl,
                 BOOL bCheckForOpenFiles,
                 BOOL bCheckSpeed)          // FALSE skips slow link check
{
    if (pfnl)
    {
        CscFilenameList::ShareIter si = pfnl->CreateShareIterator();
        CscFilenameList::HSHARE hShare;
        BOOL bRefreshShell = FALSE;

        if (bCheckForOpenFiles)
        {
            //
            // First scan the shares to see if any have open files.
            //
            while(si.Next(&hShare))
            {
                DWORD dwShareStatus;
                if (CSCQueryFileStatus(pfnl->GetShareName(hShare), &dwShareStatus, NULL, NULL))
                {
                    if ((FLAG_CSC_SHARE_STATUS_FILES_OPEN & dwShareStatus) &&
                        (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus))
                    {
                        if (IDOK != OpenFilesWarningDialog())
                        {
                            return S_FALSE; // User cancelled.
                        }

                        break;
                    }
                }
            }
            si.Reset();
        }

        //
        // Walk through the list, transitioning everything to online.
        //
        while(si.Next(&hShare))
        {
            if (TransitionShareOnline(pfnl->GetShareName(hShare), FALSE, bCheckSpeed, 0))
                bRefreshShell = TRUE;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\shellex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       shellex.h
//
//--------------------------------------------------------------------------

#ifndef _SHELLEX_H_
#define _SHELLEX_H_

#include "nopin.h"

class CCscShellExt : public IShellExtInit,
                            IContextMenu,
                            IShellIconOverlayIdentifier
{
    LONG m_cRef;
    LPDATAOBJECT m_lpdobj;  // interface passed in by shell
    DWORD m_dwUIStatus;
    TCHAR m_szLocalMachine[MAX_COMPUTERNAME_LENGTH+1];
    CNoPinList m_NoPinList;

public:
    CCscShellExt() : m_cRef(1), m_lpdobj(NULL), m_dwUIStatus(0)
    {
        DllAddRef();

        m_szLocalMachine[0] = TEXT('\0');
        ULONG n = ARRAYSIZE(m_szLocalMachine);
        GetComputerName(m_szLocalMachine, &n);
    }
    ~CCscShellExt()
    {
        if (m_lpdobj)
            m_lpdobj->Release();
        DllRelease();
    }

    static HRESULT WINAPI CreateInstance(REFIID riid, LPVOID *ppv);

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit method
    STDMETHODIMP Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY);

    // IContextMenu methods
    STDMETHODIMP QueryContextMenu(HMENU hMenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd,
                                  UINT uFlags,
                                  UINT FAR *reserved,
                                  LPSTR pszName,
                                  UINT cchMax);

    // IShellIconOverlayIdentifier methods
    STDMETHODIMP IsMemberOf(LPCWSTR pwszPath,
                            DWORD dwAttrib);
    STDMETHODIMP GetOverlayInfo(LPWSTR pwszIconFile,
                                int cchMax,
                                int * pIndex,
                                DWORD * pdwFlags);
    STDMETHODIMP GetPriority(int * pIPriority);

private:
    STDMETHODIMP CheckOneFileStatus(LPCTSTR pszItem,
                                    DWORD   dwAttr,
                                    BOOL    bShareChecked,
                                    LPDWORD pdwStatus);
    STDMETHODIMP CheckFileStatus(LPDATAOBJECT pdobj,
                                 LPDWORD pdwStatus);
    STDMETHODIMP BuildFileList(LPDATAOBJECT pdobj,
                               HWND hwndOwner,
                               CscFilenameList * pfnl,
                               LPBOOL pbSubDir = NULL);

    HRESULT CanAllFilesBePinned(IDataObject *pdtobj);
    
    static HRESULT FolderHasSubFolders(LPCTSTR pszPath, CscFilenameList *pfnl);

    static DWORD WINAPI _UnpinFilesThread(LPVOID pvData);
    static INT_PTR CALLBACK _ConfirmPinDlgProc(HWND, UINT, WPARAM, LPARAM);
};
typedef CCscShellExt *PCSCSHELLEXT;


typedef DWORD (WINAPI* PFN_UNPINPROGRESSPROC)(LPCTSTR pszItem, LPARAM lpContext);
void CscUnpinFileList(CscFilenameList*, BOOL, BOOL, LPCTSTR, PFN_UNPINPROGRESSPROC, LPARAM);

BOOL ShareIsCacheable(LPCTSTR pszUNC,
                      BOOL bPathIsFile,
                      LPTSTR *ppszConnectionName,
                      PDWORD pdwShareStatus = FALSE);
BOOL ShareIsConnected(LPCTSTR pszUNC);
BOOL ConnectShare(LPCTSTR pszUNC, LPTSTR *ppszAccessName);

#endif  // _SHELLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\syncmgr.h ===
#ifndef __CSCUI_SYNCMGR_H
#define __CSCUI_SYNCMGR_H

HRESULT RegisterSyncMgrHandler(BOOL bRegister=TRUE, LPUNKNOWN punkSyncMgr=NULL);
HRESULT RegisterForSyncAtLogonAndLogoff(DWORD dwMask, DWORD dwValue);
HRESULT IsRegisteredForSyncAtLogonAndLogoff(bool *pbLogon = NULL, bool *pbLogoff = NULL);

#endif // __CSCUI_SYNCMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\syncmgr.cpp ===
#include "pch.h"
#pragma hdrstop

#include <mobsyncp.h>


//*************************************************************
//
//  RegisterSyncMgrHandler
//
//  Purpose:    Register/unregister CSC Update handler with SyncMgr
//
//  Parameters: bRegister - TRUE to register, FALSE to unregister
//              punkSyncMgr - (optional) instance of SyncMgr to use
//
//  Return:     HRESULT
//
//*************************************************************
HRESULT
RegisterSyncMgrHandler(
    BOOL bRegister, 
    LPUNKNOWN punkSyncMgr
    )
{
    HRESULT hr;
    HRESULT hrComInit = E_FAIL;
    ISyncMgrRegister *pSyncRegister = NULL;
    const DWORD dwRegFlags = SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT;

    TraceEnter(TRACE_UPDATE, "CscRegisterHandler");

    if (punkSyncMgr)
    {
        hr = punkSyncMgr->QueryInterface(IID_ISyncMgrRegister, (LPVOID*)&pSyncRegister);
    }
    else
    {
        hrComInit = CoInitialize(NULL);
        hr = CoCreateInstance(CLSID_SyncMgr,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISyncMgrRegister,
                              (LPVOID*)&pSyncRegister);
    }
    FailGracefully(hr, "Unable to get ISyncMgrRegister interface");

    if (bRegister)
        hr = pSyncRegister->RegisterSyncMgrHandler(CLSID_CscUpdateHandler, NULL, dwRegFlags);
    else
        hr = pSyncRegister->UnregisterSyncMgrHandler(CLSID_CscUpdateHandler, dwRegFlags);

exit_gracefully:

    DoRelease(pSyncRegister);

    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    TraceLeaveResult(hr);
}


//
// Set/Clear the sync-at-logon-logoff flags for our SyncMgr handler.
// When set, SyncMgr will include Offline Files in any sync activity
// at logon and/or logoff.
//
// dwFlagsRequested - Value of flags bits.  1 == set, 0 == clear.
// dwMask           - Mask describing which flags bits to use.
//
// Both dwMask and dwFlagsRequested may be one of the following:
//
//  0
//  SYNCMGRREGISTER_CONNECT
//  SYNCMGRREGISTER_PENDINGDISCONNECT
//  SYNCMGRREGISTER_CONNECT | SYNCMGRREGISTER_PENDINGDISCONNECT
//
HRESULT
RegisterForSyncAtLogonAndLogoff(
    DWORD dwMask,
    DWORD dwFlagsRequested
    )
{
    CCoInit coinit;
    HRESULT hr = coinit.Result();
    if (SUCCEEDED(hr))
    {
        ISyncMgrRegisterCSC *pSyncRegister = NULL;
        hr = CoCreateInstance(CLSID_SyncMgr,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISyncMgrRegisterCSC,
                              (LPVOID*)&pSyncRegister);
        if (SUCCEEDED(hr))
        {
            //
            // Re-register the sync mgr handler with the "connect" and "disconnect" 
            // flags set.  Other existing flags are left unmodified.
            //
            DWORD dwFlagsActual;
            hr = pSyncRegister->GetUserRegisterFlags(&dwFlagsActual);
            if (SUCCEEDED(hr))
            {
                const DWORD LOGON   = SYNCMGRREGISTERFLAG_CONNECT;
                const DWORD LOGOFF  = SYNCMGRREGISTERFLAG_PENDINGDISCONNECT;

                if (dwMask & LOGON)
                {
                    if (dwFlagsRequested & LOGON)
                        dwFlagsActual |= LOGON;
                    else
                        dwFlagsActual &= ~LOGON;
                }
                
                if (dwMask & LOGOFF)
                {
                    if (dwFlagsRequested & LOGOFF)
                        dwFlagsActual |= LOGOFF;
                    else
                        dwFlagsActual &= ~LOGOFF;
                }
                
                hr = pSyncRegister->SetUserRegisterFlags(dwMask & (LOGON | LOGOFF), 
                                                         dwFlagsActual);
            }
            pSyncRegister->Release();
        }
    }
    return hr;
}


//
// Determine if we're registered for sync at logon/logoff.
// Returns:
//      S_OK    = We're registered.  Query *pbLogon and *pbLogoff to
//                determine specifics if you're interested.
//      S_FALSE = We're not registered.
//      Other   = Couldn't determine because of some error.
//
HRESULT
IsRegisteredForSyncAtLogonAndLogoff(
    bool *pbLogon,
    bool *pbLogoff
    )
{
    bool bLogon  = false;
    bool bLogoff = false;
    CCoInit coinit;
    HRESULT hr = coinit.Result();
    if (SUCCEEDED(hr))
    {
        ISyncMgrRegisterCSC *pSyncRegister = NULL;
        hr = CoCreateInstance(CLSID_SyncMgr,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISyncMgrRegisterCSC,
                              (LPVOID*)&pSyncRegister);
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags;
            hr = pSyncRegister->GetUserRegisterFlags(&dwFlags);
            if (SUCCEEDED(hr))
            {
                hr      = S_FALSE;
                bLogon  = (0 != (SYNCMGRREGISTERFLAG_CONNECT & dwFlags));
                bLogoff = (0 != (SYNCMGRREGISTERFLAG_PENDINGDISCONNECT & dwFlags));
                if (bLogon || bLogoff)
                    hr = S_OK;
            }
            pSyncRegister->Release();
        }
    }
    if (NULL != pbLogon)
        *pbLogon = bLogon;
    if (NULL != pbLogoff)
        *pbLogoff = bLogoff;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __CSCUI_STRINGS_H_
#define __CSCUI_STRINGS_H_

#ifdef __cplusplus
#   define EXTERN_C extern "C"
#else
#   define EXTERN_C extern
#endif

#ifdef DEFINE_CSCUI_STRINGS
#   define DEFINE_STRING(x,y)    EXTERN_C const TCHAR x[] = TEXT(##y##)
#   define DEFINE_STRINGA(x,y)   EXTERN_C const char x[] = y
#else
#   define DEFINE_STRING(x,y)    EXTERN_C const TCHAR x[]
#   define DEFINE_STRINGA(x,y)   EXTERN_C const char x[]
#endif



DEFINE_STRING(c_szStar,                   "*");
DEFINE_STRING(c_szCSCKey,                 "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache");
DEFINE_STRING(c_szCSCShareKey,            "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache\\Shares");
DEFINE_STRING(c_szSyncMutex,              "Global\\CscUpdate_SyncMutex");
DEFINE_STRING(c_szSyncInProgCounter,      "CscUpdate_SyncInProgCounter");
DEFINE_STRING(c_szSyncCompleteEvent,      "Global\\CscUpdate_SyncCompleteEvent");
DEFINE_STRING(c_szPurgeInProgCounter,     "CscCache_PurgeInProgCounter");
DEFINE_STRING(c_szEncryptionInProgMutex,  "CscCache_EncryptionInProgMutex");
DEFINE_STRING(c_szTSConfigMutex,          "Global\\TerminalServerConfigMutex");
DEFINE_STRING(c_szPolicy,                 "Policy");
DEFINE_STRINGA(c_szCmVerbSync,            "synchronize");
DEFINE_STRINGA(c_szCmVerbPin,             "pin");
DEFINE_STRING(c_szCFDataSrcClsid,         "Data Source CLSID");
DEFINE_STRING(c_szPurgeAtNextLogoff,      "PurgeAtNextLogoff");
DEFINE_STRING(c_szDllName,                "cscui.dll");
DEFINE_STRING(c_szRegKeyAPF,              "Software\\Policies\\Microsoft\\Windows\\NetCache\\AssignedOfflineFolders");
DEFINE_STRING(c_szRegKeyAPFResult,        "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache\\AssignedOfflineFolders");
DEFINE_STRING(c_szEntryID,                "ID");
DEFINE_STRING(c_szLastSync,               "LastSyncTime");
DEFINE_STRING(c_szLNK,                    ".lnk");
DEFINE_STRING(c_szSyncMgrInitialized,     "SyncMgrInitialized");
DEFINE_STRING(c_szConfirmDelShown,        "ConfirmDelShown");
DEFINE_STRINGA(c_szHtmlHelpFile,          "OFFLINEFOLDERS.CHM > windefault");
DEFINE_STRINGA(c_szHtmlHelpTopic,         "csc_overview.htm");
DEFINE_STRING(c_szHelpFile,               "CSCUI.HLP");
DEFINE_STRING(c_szPropThis,               "PropThis");
DEFINE_STRING(c_szPinCountsReset,         "PinCountsReset");
DEFINE_STRING(c_szAPFStart,               "AdminPinStartTime");
DEFINE_STRING(c_szAPFEnd,                 "AdminPinFinishTime");
DEFINE_STRING(c_szAPFMessage,             "AdminPinNotification");

//
// These need to be macros.
//
#define STR_SYNC_VERB   "synchronize"
#define STR_PIN_VERB    "pin"
#define STR_UNPIN_VERB  "unpin"
#define STR_DELETE_VERB "delete"



//
// The following table lists all of the registry parameters associated with CSC.
// Parameters can be broken into two groups.  
//    a. Operational values
//    b. Restrictions
//
// Operational values provide operational control for CSC.  Values may exist as
// system policy (per-user or per-machine) or they may be user-configured.
// The policy value serves as the default with HKLM taking precedence.
// If there is no corresponding restriction and a user-defined value exists, it is
// used in place of the policy value.  If there is a restriction or if only the policy
// value exists, the policy value is used.  In the case where there is no policy value
// or no user-defined value, a hard-coded default is used.
//
// Restrictions are policy-rules preventing users from performing some action.
// In general, this means controlling the ability for users to change an operational 
// value.  Restrictions are only present under the CSC "policy" registry key.  All of 
// the restriction values are prefixed with "No".  If a restriction value is not present,
// it is assumed there is no restriction.
//
//
//                                - User pref-    -- Policy --
//  Parameter Name                HKCU    HKLM    HKCU    HKLM    Values
//  ----------------------------- ----    ----    ----    ------  --------------------------------------
//  CustomGoOfflineActions        X               X       X       ShareName-OfflineAction pairs.
//  DefCacheSize                                          X       (Pct disk * 10000) 5025 = 50.25%
//  Enabled                                               X       0 = Disabled,1 = Enabled
//  ExtExclusionList                              X       X       List of semicolon-delimited file exts.
//  GoOfflineAction               X               X       X       0 = Silent, 1 = Fail
//  NoConfigCache                                 X       X       0 = No restriction, 1 = restricted
//  NoCacheViewer                                 X       X       0 = No restriction, 1 = restricted
//  NoMakeAvailableOffline                        X       X       0 = No restriction, 1 = restricted
//  SyncAtLogoff                  X               X       X       0 = Partial (quick), 1 = Full
//  SyncAtLogon                   X               X       X       0 = Partial (quick), 1 = Full
//  SyncAtSuspend                                 X       X       -1 = None, 0 = Quick, 1 = Full
//  NoReminders                   X               X       X       0 = Show reminders.
//  NoConfigReminders                             X       X       0 = No restriction. 1 = restricted.
//  ReminderFreqMinutes           X               X       X       Frequency of reminder balloons in min.
//  InitialBalloonTimeoutSeconds  X               X       X       Seconds before initial balloon auto-pops.
//  ReminderBalloonTimeoutSeconds X               X       X       Seconds before reminder balloon auto-pops.
//  EventLoggingLevel                     X               X       0 = No logging, (1) minimal -> (3) verbose.
//  PurgeAtLogoff                                 X       X       1 = Purge, 0 = Don't purge users's files
//  PurgeOnlyAutoCacheAtLogoff                    X       X       1 = Purge only auto-cached files at logoff.
//  AlwaysPinSubFolders                                   X       1 = Always recursively pin.
//  EncryptCache                          X               X       1 = Encrypted, 0 = Not encrypted.
//  NoMakeAvailableOfflineList                    X       X       List of semicolon-delimited paths
//

DEFINE_STRING(REGSTR_KEY_OFFLINEFILESPOLICY,            "Software\\Policies\\Microsoft\\Windows\\NetCache");
DEFINE_STRING(REGSTR_KEY_OFFLINEFILES,                  "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache");
DEFINE_STRING(REGSTR_SUBKEY_CUSTOMGOOFFLINEACTIONS,     "CustomGoOfflineActions");
DEFINE_STRING(REGSTR_SUBKEY_NOMAKEAVAILABLEOFFLINELIST, "NoMakeAvailableOfflineList");
DEFINE_STRING(REGSTR_VAL_DEFCACHESIZE,                  "DefCacheSize");
DEFINE_STRING(REGSTR_VAL_CSCENABLED,                    "Enabled");
DEFINE_STRING(REGSTR_VAL_EXTEXCLUSIONLIST,              "ExcludedExtensions");
DEFINE_STRING(REGSTR_VAL_GOOFFLINEACTION,               "GoOfflineAction");
DEFINE_STRING(REGSTR_VAL_NOCONFIGCACHE,                 "NoConfigCache");
DEFINE_STRING(REGSTR_VAL_NOCACHEVIEWER,                 "NoCacheViewer");
DEFINE_STRING(REGSTR_VAL_NOMAKEAVAILABLEOFFLINE,        "NoMakeAvailableOffline");
DEFINE_STRING(REGSTR_VAL_SYNCATLOGOFF,                  "SyncAtLogoff");
DEFINE_STRING(REGSTR_VAL_SYNCATLOGON,                   "SyncAtLogon");
DEFINE_STRING(REGSTR_VAL_SYNCATSUSPEND,                 "SyncAtSuspend");
DEFINE_STRING(REGSTR_VAL_NOREMINDERS,                   "NoReminders");
DEFINE_STRING(REGSTR_VAL_NOCONFIGREMINDERS,             "NoConfigReminders");
DEFINE_STRING(REGSTR_VAL_REMINDERFREQMINUTES,           "ReminderFreqMinutes");
DEFINE_STRING(REGSTR_VAL_INITIALBALLOONTIMEOUTSECONDS,  "InitialBalloonTimeoutSeconds");
DEFINE_STRING(REGSTR_VAL_REMINDERBALLOONTIMEOUTSECONDS, "ReminderBalloonTimeoutSeconds");
DEFINE_STRING(REGSTR_VAL_FIRSTPINWIZARDSHOWN,           "FirstPinWizardShown");
DEFINE_STRING(REGSTR_VAL_EXPANDSTATUSDLG,               "ExpandStatusDlg");
DEFINE_STRING(REGSTR_VAL_FORMATCSCDB,                   "FormatDatabase");
DEFINE_STRING(REGSTR_VAL_EVENTLOGGINGLEVEL,             "EventLoggingLevel");
DEFINE_STRING(REGSTR_VAL_PURGEATLOGOFF,                 "PurgeAtLogoff");
DEFINE_STRING(REGSTR_VAL_PURGEONLYAUTOCACHEATLOGOFF,    "PurgeOnlyAutoCacheAtLogoff");
DEFINE_STRING(REGSTR_VAL_SLOWLINKSPEED,                 "SlowLinkSpeed");
DEFINE_STRING(REGSTR_VAL_ALWAYSPINSUBFOLDERS,           "AlwaysPinSubFolders");
DEFINE_STRING(REGSTR_VAL_ENCRYPTCACHE,                  "EncryptCache");
DEFINE_STRING(REGSTR_VAL_FOLDERSHORTCUTCREATED,         "FolderShortcutCreated");
DEFINE_STRING(REGSTR_VAL_NOFRADMINPIN,                  "DisableFRAdminPin");

#endif // __CSCUI_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\statdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       statdlg.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_STATDLG_H
#define _INC_CSCUI_STATDLG_H


#ifndef _CSCST_H_
#   include "cscst.h"
#endif

class CStatusDlg
{
    public:
        enum Modes { MODE_NORMAL = 0,
                     MODE_AUTOSYNC
                   };

        static int Create(HWND hwndParent, LPCTSTR pszText, eSysTrayState eState, Modes mode = MODE_NORMAL);

    private:
        CStatusDlg(HINSTANCE hInstance, LPCTSTR pszText, eSysTrayState eState, Modes mode = MODE_NORMAL);

        ~CStatusDlg(void);

        int Run(HWND hwndParent);

        void Destroy(void);

        enum { iIMAGELIST_ICON_SERVER = 0,
               iIMAGELIST_ICON_SERVER_OFFLINE,
               iIMAGELIST_ICON_SERVER_BACK,
               iIMAGELIST_ICON_SERVER_DIRTY
             };

        //
        // An entry in the listview.
        //
        class LVEntry
        {
            public:
                LVEntry(HINSTANCE hInstance, LPCTSTR pszServer, bool bConnectable);
                ~LVEntry(void);

                LPCTSTR Server(void) const
                    { return m_pszServer; }

                void GetStatusText(LPTSTR pszStatus, int cchStatus) const;

                void GetInfoText(LPTSTR pszInfo, int cchInfo) const;

                int GetImageIndex(void) const;

                bool AddShare(LPCTSTR pszShare, const CSCSHARESTATS& s, DWORD dwCscStatus);

                void GetStats(CSCSHARESTATS *ps, DWORD *pdwCscStatus) const;

                int GetShareCount(void) const;

                LPCTSTR GetShareName(int iShare) const;

                bool IsModified(void) const
                {
                    return (0 < m_stats.cModified);
                }

                bool IsConnected(void) const
                {
                    return (0 != (FLAG_CSC_SHARE_STATUS_CONNECTED & m_dwCscStatus));
                }

                bool IsOffline(void) const
                {
                    return (0 != (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & m_dwCscStatus));
                }

                bool IsConnectable(void) const
                {
                    return m_bConnectable;
                }
                //
                // Structure describing the display info for one listview entry.
                //
                struct DispInfo
                {
                    UINT idsStatusText;
                    UINT idsInfoText;
                    int  iImage;
                };

            private:
                //
                // Disp Info flags used to control what's displayed for the
                // entry in the listview.
                //
                enum { DIF_MODIFIED  = 0x00000001,
                       DIF_AVAILABLE = 0x00000002,
                       DIF_ONLINE    = 0x00000004 };

                HINSTANCE      m_hInstance;
                CSCSHARESTATS  m_stats;
                DWORD          m_dwCscStatus;
                LPTSTR         m_pszServer;
                HDPA           m_hdpaShares;
                mutable int    m_iDispInfo;    // Index into s_rgDispInfo[]
                bool           m_bConnectable;

                static const TCHAR s_szBlank[];
                static const DispInfo s_rgDispInfo[];

                int GetDispInfoIndex(void) const;

                //
                // Prevent copy.
                //
                LVEntry(const LVEntry& rhs);
                LVEntry& operator = (const LVEntry& rhs);
        };

        enum { iLVSUBITEM_SERVER = 0,
               iLVSUBITEM_STATUS,
               iLVSUBITEM_INFO
             };

        HINSTANCE     m_hInstance;
        HWND          m_hwndDlg;
        HWND          m_hwndLV;
        HIMAGELIST    m_himl;
        LPTSTR        m_pszText;
        Modes         m_mode;           // MODE_NORMAL etc.
        eSysTrayState m_eSysTrayState;
        int           m_cyExpanded;
        int           m_iLastColSorted;
        bool          m_bExpanded;
        bool          m_bSortAscending;
        
        BOOL OnInitDialog(WPARAM wParam, LPARAM lParam);
        BOOL OnCommand(WPARAM wParam, LPARAM lParam);
        BOOL OnNotify(WPARAM wParam, LPARAM lParam);
        BOOL OnDestroy(void);
        void OnLVN_GetDispInfo(LV_DISPINFO *plvdi);
        void OnLVN_ColumnClick(NM_LISTVIEW *pnmlv);

        void CreateListColumns(void);
        HIMAGELIST CreateImageList(void);
        void FillListView(void);
        void DestroyLVEntries(void);
        LVEntry *CreateLVEntry(LPCTSTR pszServer, bool bConnectable);
        LVEntry *FindLVEntry(LPCTSTR pszServer);
        bool ShouldIncludeLVEntry(const CStatusDlg::LVEntry& entry);
        bool ShouldCheckLVEntry(const CStatusDlg::LVEntry& entry);
        void PrepListForDisplay(void);
        void EnableListviewCheckboxes(bool bEnable);

        static int CALLBACK CompareLVItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        void ExpandDialog(bool bExpand);
        void UpdateDetailsBtnTitle(void);
        void RememberUsersDialogSizePref(bool bExpanded);
        bool UserLikesDialogExpanded(void);
        HRESULT SynchronizeServers(void);
        HRESULT BuildFilenameList(CscFilenameList *pfnl);
};

BOOL TransitionShareOnline(LPCTSTR pszShare, BOOL  bShareIsAlive, BOOL  bCheckSpeed, DWORD dwPathSpeed);
HRESULT ReconnectServers(CscFilenameList *pfnl, BOOL bCheckForOpenFiles, BOOL bCheckSpeed);


#endif // _INC_CSCUI_STATDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\termserv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       termserv.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include <winsta.h>     // WinStationGetTermSrvCountersValue
#include <allproc.h>    // TS_COUNTER
#include "termserv.h"
#include "strings.h"


HRESULT TS_AppServer(void);
HRESULT TS_MultipleUsersAllowed(void);
HRESULT TS_ConnectionsAllowed(void);
HRESULT TS_ActiveSessionCount(DWORD *pcSessions);
HRESULT TS_MultipleSessions(void);


//
// Returns:
//    S_OK    == Yes, is App Server.
//    S_FALSE == No, is not app server.
//
HRESULT
TS_AppServer(
    void
    )
{
    return(IsOS(OS_TERMINALSERVER) ? S_OK : S_FALSE);
}


//
// Returns:
//    S_OK    == Yes, multiple users allowed.
//    S_FALSE == No, multiple users not allowed.
//    other   == Failure.
//
HRESULT
TS_MultipleUsersAllowed(
    void
    )
{
    HRESULT hr = S_FALSE;
    if (IsOS(OS_ANYSERVER))
    {
        //
        // Assume "multiple users allowed" on all server SKUs.
        // This is per the Terminal Server team (MakarP).
        //
        hr = S_OK;
    }
    else if (IsOS(OS_FASTUSERSWITCHING))
    {
        hr = S_OK;
    }
    return hr;
}


//
// Returns:
//    S_OK    == Yes, terminal server connections are allowed.
//    S_FALSE == Now, TS connections are not allowed.
//    other   == Failure.
//
HRESULT
TS_ConnectionsAllowed(
    void
    )
{
    HRESULT hr = E_FAIL;
    HMODULE hmodRegAPI = LoadLibrary(TEXT("RegApi.dll"));
    if (NULL != hmodRegAPI)
    {
        typedef BOOLEAN (*PFDenyConnectionPolicy)(void);
        PFDenyConnectionPolicy pfnDenyConnectionPolicy;

        pfnDenyConnectionPolicy = (PFDenyConnectionPolicy) GetProcAddress(hmodRegAPI, "RegDenyTSConnectionsPolicy");

        if (NULL != pfnDenyConnectionPolicy)
        {
            //
            // This function returns FALSE if connections are allowed. 
            //
            if (!(*pfnDenyConnectionPolicy)())
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        FreeLibrary(hmodRegAPI);
    }
    return hr;
}


//
// Returns:
//    E_FAIL on failure of WTS APIs.
//    S_OK otherwise.
//
HRESULT
TS_ActiveSessionCount(
    DWORD *pcSessions
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwActiveSessionCount = 0;

    //  Open a connection to terminal services and get the number of sessions.

    HANDLE hServer = WinStationOpenServerW(reinterpret_cast<WCHAR*>(SERVERNAME_CURRENT));
    if (hServer != NULL)
    {
        TS_COUNTER tsCounters[2] = {0};

        tsCounters[0].counterHead.dwCounterID = TERMSRV_CURRENT_DISC_SESSIONS;
        tsCounters[1].counterHead.dwCounterID = TERMSRV_CURRENT_ACTIVE_SESSIONS;

        if (WinStationGetTermSrvCountersValue(hServer, ARRAYSIZE(tsCounters), tsCounters))
        {
            int i;

            hr = S_OK;

            for (i = 0; i < ARRAYSIZE(tsCounters); i++)
            {
                if (tsCounters[i].counterHead.bResult)
                {
                    dwActiveSessionCount += tsCounters[i].dwValue;
                }
            }
        }

        WinStationCloseServer(hServer);
    }

    if (NULL != pcSessions)
    {
        *pcSessions = dwActiveSessionCount;
    }

    return hr;
}


//
// Returns:
//    S_OK    == Yes, there are 2+ active sessions.
//    S_FALSE == No, there are 1 or less active sessions.
//    other   == Failure.
//
HRESULT
TS_MultipleSessions(
    void
    )
{
    DWORD cSessions;
    HRESULT hr = TS_ActiveSessionCount(&cSessions);
    if (SUCCEEDED(hr))
    {
        hr = (1 < cSessions) ? S_OK : S_FALSE;
    }
    return hr;
}


//
// Request ownership of the global "configuring Terminal Server" mutex.
// This is a well-known mutex defined by the terminal server group.
// There are currently 3 scenarios that claim ownership of the mutex.
//
// 1. Terminal Server configuration UI.
// 2. The TS_IsTerminalServerCompatibleWithCSC API (below).
// 3. The Offline Files property page when the user has hit 'Apply'
//    and the user is enabling CSC.
//
// If the function succeeds, the caller is responsible for closing the
// mutex handle returned in *phMutex.
//
HRESULT
TS_RequestConfigMutex(
    HANDLE *phMutex,
    DWORD dwTimeoutMs
    )
{
    HANDLE hMutex = CreateMutex(NULL, TRUE, c_szTSConfigMutex);
    if (NULL != hMutex)
    {
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            if (WAIT_OBJECT_0 != WaitForSingleObject(hMutex, dwTimeoutMs))
            {
                CloseHandle(hMutex);
                hMutex = NULL;
            }
        }
        *phMutex = hMutex;
    }
    return NULL != hMutex ? S_OK : E_FAIL;
}


//
// Returns a text string associated with a particular TS mode explaining
// that mode and why CSC is incompatible with it.
// The caller is responsible for freeing the returned buffer with
// LocalFree().
//
HRESULT
TS_GetIncompatibilityReasonText(
    DWORD dwTsMode,
    LPTSTR *ppszText
    )
{
    TraceAssert(CSCTSF_COUNT > dwTsMode);
    TraceAssert(NULL != ppszText);

    HRESULT hr   = S_OK;
    UINT idsText = IDS_TS_UNKNOWN;

    *ppszText = NULL;

    //
    // Map of TS mode to string resource ID.
    //
    static const struct
    {
        DWORD dwTsMode;
        UINT idsText;

    } rgMap[] = {

        { CSCTSF_UNKNOWN,     IDS_TS_UNKNOWN     },
        { CSCTSF_APP_SERVER,  IDS_TS_APP_SERVER  },
        { CSCTSF_MULTI_CNX,   IDS_TS_MULTI_CNX   },
        { CSCTSF_REMOTE_CNX,  IDS_TS_REMOTE_CNX  },
        { CSCTSF_FUS_ENABLED, IDS_TS_FUS_ENABLED }
        };

    for (int iMode = 0; iMode < ARRAYSIZE(rgMap); iMode++)
    {
        if (rgMap[iMode].dwTsMode == dwTsMode)
        {
            idsText = rgMap[iMode].idsText;
            break;
        }
    }
    //
    // Load and display the text explaining what the user needs
    // to do to enable CSC.
    //
    if (0 == LoadStringAlloc(ppszText, g_hInstance, idsText))
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}
        



//
// Returns:
//    S_OK    == OK to display CSC UI.
//    S_FALSE == Not OK to display CSC UI.  Inspect *pdwTsMode for reason.
//    other   == Failure.  *pdwTsMode contains CSCTSF_UNKNOWN.
//
HRESULT
CSCUIIsTerminalServerCompatibleWithCSC(
    DWORD *pdwTsMode
    )
{
    TraceAssert(NULL != pdwTsMode);

    if (IsOS(OS_FRIENDLYLOGONUI) && IsOS(OS_FASTUSERSWITCHING))
    {
        *pdwTsMode = CSCTSF_FUS_ENABLED;
        return S_FALSE;
    }

    HANDLE hMutex;
    HRESULT hr = TS_RequestConfigMutex(&hMutex, 5000);
    if (SUCCEEDED(hr))
    {
        *pdwTsMode = CSCTSF_APP_SERVER;

        if (S_FALSE == (hr = TS_AppServer()))
        {
            //
            // Not app server.
            //
            if ((S_OK == (hr = TS_ConnectionsAllowed())))
            {
                //
                // Connections are allowed.
                // Check if multiple connections are allowed (like on TS servers)
                //
                if (S_OK == (hr = TS_MultipleUsersAllowed()))
                {
                    //
                    // There can be multiple users or TS connections.
                    //
                    *pdwTsMode = CSCTSF_MULTI_CNX;
                }
                else
                {
                    //
                    // Personal Terminal Server (only 1 active connection can be allowed)
                    // OK to display CSC UI.
                    //
                    *pdwTsMode = CSCTSF_CSC_OK;
                    CloseHandle(hMutex);
                    return S_OK;
                }
            }
            else
            {
                //
                // TS connections are not allowed, but there could be existing active connecitons,
                // check if any exists.
                //
                if (S_OK == (hr = TS_MultipleSessions()))
                {
                    *pdwTsMode = CSCTSF_REMOTE_CNX;
                }
                else
                {
                    //
                    // No active remote sessions,
                    // OK to display CSC UI.
                    //
                    *pdwTsMode = CSCTSF_CSC_OK;
                    CloseHandle(hMutex);
                    return S_OK;
                }
            }
        }
        CloseHandle(hMutex);
    }
    if (FAILED(hr))
    {
        //
        // Something failed.  We can't report any particular TS mode
        // with any confidence.
        //
        *pdwTsMode = CSCTSF_UNKNOWN;
    }

    //
    // Any S_OK return value was returned inline above.
    // At this point we want to return either S_FALSE or an error code.
    //
    return SUCCEEDED(hr) ? S_FALSE : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\termserv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       termserv.h
//
//--------------------------------------------------------------------------
#ifndef __CSCUI_TERMSERV_H
#define __CSCUI_TERMSERV_H

HRESULT TS_RequestConfigMutex(HANDLE *phMutex, DWORD dwTimeoutMs);
HRESULT TS_MultipleSessions(void);
HRESULT TS_GetIncompatibilityReasonText(DWORD dwTsMode, LPTSTR *ppszText);

#ifndef CSCTSF_UNKNOWN
//
// REVIEW:  Remove this once this declaration is in cscuiext.h
//
//
// One of these is returned in the *pdwTsMode
// argument to CSCUI_IsTerminalServerCompatibleWithCSC API.
//
// CSCTSF_ = "CSC Terminal Server Flag"
//
#define CSCTSF_UNKNOWN       0  // Can't obtain TS status.
#define CSCTSF_CSC_OK        1  // OK to use CSC.
#define CSCTSF_APP_SERVER    2  // TS is configured as an app server.
#define CSCTSF_MULTI_CNX     3  // Multiple connections are allowed.
#define CSCTSF_REMOTE_CNX    4  // There are currently remote connections active.
//
// Returns:
//    S_OK    - Terminal Server is in a mode that is compatible with CSC.
//    S_FALSE - Not OK to use CSC.  Inspect *pdwTsMode for reason.
//    other   - Failure.  *pdwTsMode contains CSCTSF_UNKNOWN.
//
HRESULT CSCUIIsTerminalServerCompatibleWithCSC(DWORD *pdwTsMode);

#endif //CSCTSF_UNKNOWN


#endif // __CSCUI_TERMSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\uihelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uihelp.h
//
//--------------------------------------------------------------------------

#ifndef _INC_CSCUI_UIHELP_H
#define _INC_CSCUI_UIHELP_H

//
// Don't change these without coordinating with the help content author.
//
#define HIDC_BTN_ADD_CUSTGOOFFLINE       0  // IDD_CSC_ADVOPTIONS
#define HIDC_BTN_DELETE_CACHE            1  // IDD_CSC_OPTIONS
#define HIDC_BTN_DELETE_CUSTGOOFFLINE    2  // IDD_CSC_ADVOPTIONS
#define HIDC_BTN_EDIT_CUSTGOOFFLINE      3  // IDD_CSC_ADVOPTIONS
#define HIDC_BTN_VIEW_CACHE              4  // IDD_CSC_OPTIONS
#define HIDC_CBX_ENABLE_CSC              5  // IDD_CSC_OPTIONS
#define HIDC_CBX_ENCRYPT_CSC             6  // IDD_CSC_OPTIONS
#define HIDC_EDIT_GOOFFLINE_SERVER       7  // IDD_CSC_ADVOPTIONS_ADD
#define HIDC_LV_CUSTGOOFFLINE           11  // IDD_CSC_ADVOPTIONS
#define HIDC_CBX_FULLSYNC_AT_LOGOFF     12  // IDD_CSC_OPTIONS
#define HIDC_RBN_GOOFFLINE_FAIL         13  // IDD_CSC_ADVOPTIONS
#define HIDC_RBN_GOOFFLINE_SILENT       15  // IDD_CSC_ADVOPTIONS
#define HIDC_CACHESIZE_PCT              26  // IDD_CSC_OPTIONS
#define HIDC_TXT_GOOFFLINE_SERVER       28  // IDD_CSC_ADVOPTIONS_EDIT
#define HIDC_BTN_ADVANCED               29  // IDD_CSC_OPTIONS
#define HIDC_CBX_LINK_ON_DESKTOP        30  // IDD_CSC_OPTIONS
#define HIDC_REMINDERS_ENABLE           31  // IDD_CSC_OPTIONS
#define HIDC_REMINDERS_PERIOD           32  // IDD_CSC_OPTIONS
#define HIDC_BTN_BROWSEFORSERVER        33  // IDD_CSC_ADVOPTIONS_ADD
#define HIDC_CBX_FULLSYNC_AT_LOGON      34  // IDD_CSC_OPTIONS

//
// These IDs were made obsolete on 5/10/99.
// Coordinated with help author a-margem.
//
//#define HIDC_GRP_CUSTGOOFFLINE           8  // IDD_CSC_ADVOPTIONS
//#define HIDC_RBN_GOOFFLINE_PROMPT       14  // IDD_CSC_ADVOPTIONS
//#define HIDC_RBN_PARTSYNC_AT_LOGOFF     16  // IDD_CSC_OPTIONS
//#define HIDC_SHRSUM_BTN_OPTIONS         17  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_BTN_VIEW            18  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_PINNEDFILES     19  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_PINNEDFOLDERS   20  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_SHARENAME       21  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_SYNC            22  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_TOTALFILES      23  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_SHRSUM_TXT_TOTALFOLDERS    24  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_BTN_CLOSE                  25  // IDD_CACHEVIEW_SHARESUMMARY
//#define HIDC_TXT_CACHESIZE_PCT          27  // IDD_CSC_OPTIONS

#endif // _INC_CSCUI_UIHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\update.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       update.h
//
//--------------------------------------------------------------------------

#ifndef _UPDATE_H_
#define _UPDATE_H_

#include <mobsync.h>
#include "cscentry.h"
#include "util.h"       // ENUM_REASON
#include "nopin.h"

//
// Flags used in CscUpdateCache
//
#define CSC_UPDATE_STARTNOW       0x00000002  // Don't wait for user confirmation to start update
#define CSC_UPDATE_SELECTION      0x00000004  // Update current selection (CSC_NAMELIST_HDR buffer)
#define CSC_UPDATE_PINFILES       0x00000008  // Pin files while updating them
#define CSC_UPDATE_PIN_RECURSE    0x00000010  // Recurse into subfolders when pinning
#define CSC_UPDATE_REINT          0x00000020  // Perform outward reintegration
#define CSC_UPDATE_FILL_QUICK     0x00000040  // Perform quick inward sync (fill sparse files)
#define CSC_UPDATE_FILL_ALL       0x00000080  // Perform full inward sync (overrides CSC_UPDATE_FILL_QUICK)
#define CSC_UPDATE_NOTIFY_DONE    0x00000100  // Send CSCWM_DONESYNCING to notify window when done.
#define CSC_UPDATE_SHOWUI_ALWAYS  0x00000200  // Nothing to sync but show SyncMgr UI anyway.
#define CSC_UPDATE_IGNORE_ACCESS  0x00000400  // Default is to sync files with USER and/or GUEST access.
#define CSC_UPDATE_RECONNECT      0x00000800  // Transition all servers online after syncing
#define CSC_UPDATE_UNATTENDED     0x00001000  // Run sync unattended.  Can't prompt user.

HRESULT CscUpdateCache(DWORD dwUpdateFlags, CscFilenameList *pfnl=NULL);

void BuildSilentFolderList(CscFilenameList *pfnlSilentFolders,
                           CscFilenameList *pfnlSpecialFolders);


class CCscUpdate;
typedef CCscUpdate *PCSCUPDATE;

typedef struct
{
    PCSCUPDATE      pThis;
    SYNCMGRITEMID   ItemID;
    HANDLE          hThread;
    LPTSTR          pszShareName;
    TCHAR           szDrive[4];
    DWORD           dwSyncStatus;
    LONG            cFilesToSync;
    LONG            cFilesDone;
    CscFilenameList *pUndoExclusionList;
    DWORD           dwCscContext;
    DWORD           dwPinHints;
} SYNCTHREADDATA, *PSYNCTHREADDATA;


class CCscUpdate : ISyncMgrSynchronize
{
private:
    LONG                            m_cRef;
    CscFilenameList                *m_pFileList;
    DWORD                           m_dwSyncFlags;
    HDSA                            m_hSyncItems;
    CSCEntryLog                     m_ShareLog;
    LPSYNCMGRSYNCHRONIZECALLBACK    m_pSyncMgrCB;
    HDPA                            m_hSyncThreads;
    CRITICAL_SECTION                m_csThreadList;
    BOOL                            m_bCSInited;
    HWND                            m_hwndDlgParent;
    HANDLE                          m_hSyncMutex;
    HANDLE                          m_hgcSyncInProgress;
    BOOL                            m_bCacheIsEncrypted;
    CscFilenameList                *m_pConflictPinList;
    CscFilenameList                *m_pSilentFolderList;
    CscFilenameList                *m_pSpecialFolderList;
    CscFilenameList                 m_ReconnectList;
    CNoPinList                      m_NoPinList;

private:
    CCscUpdate();
    ~CCscUpdate();
    HRESULT _Init();

public:
    static HRESULT WINAPI CreateInstance(REFIID riid, LPVOID *ppv);

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISyncMgrSynchronize methods
    STDMETHODIMP Initialize(DWORD dwReserved,
                            DWORD dwSyncFlags,
                            DWORD cbCookie,
                            const BYTE *lpCookie);
    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    STDMETHODIMP EnumSyncMgrItems(LPSYNCMGRENUMITEMS *ppenum);
    STDMETHODIMP GetItemObject(REFSYNCMGRITEMID rItemID, REFIID riid, LPVOID *ppv);
    STDMETHODIMP ShowProperties(HWND hWndParent, REFSYNCMGRITEMID rItemID);
    STDMETHODIMP SetProgressCallback(LPSYNCMGRSYNCHRONIZECALLBACK pCallback);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,
                                SYNCMGRITEMID *pItemIDs,
                                HWND hWndParent,
                                DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hWndParent);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID pItemID,
                               DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,
                            REFSYNCMGRERRORID ErrorID);
private:
    HRESULT LogError(REFSYNCMGRITEMID rItemID,
                     LPCTSTR pszText,
                     DWORD dwLogLevel = SYNCMGRLOGLEVEL_ERROR,
                     REFSYNCMGRERRORID ErrorID = GUID_NULL);
    DWORD LogError(REFSYNCMGRITEMID rItemID,
                   DWORD dwLogLevel,
                   UINT nFormatID,
                   ...);
    DWORD LogError(REFSYNCMGRITEMID rItemID,
                   UINT nFormatID,
                   LPCTSTR pszName,
                   DWORD dwErr,
                   DWORD dwLogLevel = SYNCMGRLOGLEVEL_ERROR);
    HRESULT SynchronizeShare(SYNCMGRITEMID *pItemID,
                             LPCTSTR pszShareName,
                             BOOL bRasConnected);
    void  SetLastSyncTime(LPCTSTR pszShareName);
    DWORD GetLastSyncTime(LPCTSTR pszShareName, LPFILETIME pft);
    void  SyncThreadCompleted(PSYNCTHREADDATA pSyncData);
    void  SyncCompleted(void);
    DWORD CopyLocalFileWithDriveMapping(LPCTSTR pszSrc,
                                        LPCTSTR pszDst,
                                        LPCTSTR pszShare,
                                        LPCTSTR pszDrive,
                                        BOOL    bDirectory = FALSE);
    DWORD HandleFileConflict(PSYNCTHREADDATA    pSyncData,
                             LPCTSTR            pszName,
                             DWORD              dwStatus,
                             DWORD              dwHintFlags,
                             LPWIN32_FIND_DATA  pFind32);
    DWORD HandleDeleteConflict(PSYNCTHREADDATA   pSyncData,
                               LPCTSTR           pszName,
                               DWORD             dwStatus,
                               DWORD             dwHintFlags,
                               LPWIN32_FIND_DATA pFind32);
    DWORD CscCallback(PSYNCTHREADDATA     pSyncData,
                      LPCTSTR             pszName,
                      DWORD               dwStatus,
                      DWORD               dwHintFlags,
                      DWORD               dwPinCount,
                      LPWIN32_FIND_DATA   pFind32,
                      DWORD               dwReason,
                      DWORD               dwParam1,
                      DWORD               dwParam2);

    static void NotifySyncMgr(PSYNCTHREADDATA pSyncData,
                              LPSYNCMGRPROGRESSITEM pspi);
    static DWORD WINAPI _CscCallback(LPCTSTR             pszName,
                                     DWORD               dwStatus,
                                     DWORD               dwHintFlags,
                                     DWORD               dwPinCount,
                                     LPWIN32_FIND_DATA   pFind32,
                                     DWORD               dwReason,
                                     DWORD               dwParam1,
                                     DWORD               dwParam2,
                                     DWORD_PTR           dwContext);

    BOOL PinLinkTarget(LPCTSTR pszName, PSYNCTHREADDATA pSyncData);
    static DWORD WINAPI _PinNewFilesW32Callback(LPCTSTR             pszName,
                                                ENUM_REASON         eReason,
                                                LPWIN32_FIND_DATA   pFind32,
                                                LPARAM              lpContext);
    static DWORD WINAPI _PinNewFilesCSCCallback(LPCTSTR             pszName,
                                                ENUM_REASON         eReason,
                                                DWORD               dwStatus,
                                                DWORD               dwHintFlags,
                                                DWORD               dwPinCount,
                                                LPWIN32_FIND_DATA   pFind32,
                                                LPARAM              lpContext);
    static DWORD WINAPI _SyncThread(LPVOID pThreadData);

    DWORD MergeShare(PSYNCTHREADDATA pSyncData);
    DWORD FillShare(PSYNCTHREADDATA pSyncData, int cPinned, DWORD dwConnectionSpeed);

    void PinFiles(PSYNCTHREADDATA pSyncData, BOOL bConflictPinList=FALSE);
    void NotifyUndo(PSYNCTHREADDATA pSyncData, LPCTSTR pszName);
    void UndoPinFiles(PSYNCTHREADDATA pSyncData);
    static DWORD WINAPI _UndoProgress(LPCTSTR pszItem, LPARAM lpContext);

    BOOL SkipEFSPin(PSYNCTHREADDATA pSyncData, LPCTSTR pszItem);

    typedef enum
    {
        SyncStop = 0,
        SyncPause,
        SyncResume
    } eSetSyncStatus;

    HRESULT SetSyncThreadStatus(eSetSyncStatus status, REFGUID rItemID);

    HRESULT GetSilentFolderList(void);
    BOOL IsSilentFolder(LPCTSTR pszName)
    { return (m_pSilentFolderList && m_pSilentFolderList->FileExists(pszName, false)); }
    BOOL IsSilentShare(LPCTSTR pszShare)
    { return (m_pSilentFolderList && m_pSilentFolderList->ShareExists(pszShare)); }
    BOOL IsSpecialFolder(LPCTSTR pszName)
    { return ((m_pSpecialFolderList && m_pSpecialFolderList->FileExists(pszName, false)) || IsSilentFolder(pszName)); }
    BOOL IsSpecialFolderShare(LPCTSTR pszShare)
    { return ((m_pSpecialFolderList && m_pSpecialFolderList->ShareExists(pszShare)) || IsSilentShare(pszShare)); }
    BOOL ShouldPinRecurse(LPCTSTR pszName);

    void _BuildOfflineShareList(CscFilenameList *pfnl);
    
    friend class CUpdateEnumerator;
};

class CUpdateEnumerator : ISyncMgrEnumItems
{
private:
    LONG                        m_cRef;
    PCSCUPDATE                  m_pUpdate;
    HANDLE                      m_hFind;
    BOOL                        m_bEnumFileSelection;
    INT                         m_cCheckedItemsEnumerated;
    CscFilenameList::ShareIter  m_SelectionIterator;

public:
    CUpdateEnumerator(PCSCUPDATE pUpdate);
    ~CUpdateEnumerator();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISyncMgrEnumItems methods
    STDMETHODIMP Next(ULONG celt, LPSYNCMGRITEM rgelt, PULONG pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(LPSYNCMGRENUMITEMS *ppenum);
};
typedef CUpdateEnumerator *PUPDATEENUM;

#endif  // _UPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\update.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       update.cpp
//
//  Authors;
//    Jeff Saathoff (jeffreys)
//
//  Notes;
//    SyncMgr integration
//--------------------------------------------------------------------------
#include "pch.h"
#include "msgbox.h"     // CscWin32Message
#include "folder.h"
#include <openfile.h>   // OpenOfflineFile
#include "cscst.h"      // PostToSystray
#include "fopendlg.h"   // OpenFilesWarningDialog
#include "nopin.h"
#include "statdlg.h"    // ReconnectServers
#include "security.h"
#include "strings.h"

#define RAS_CONNECT_DELAY       (10 * 1000)

// Maximum length of username
#define MAX_USERNAME_CHARS      64

// SYNCTHREADDATA.dwSyncStatus flags
#define SDS_SYNC_OUT                0x00000001  // CSCMergeShare
#define SDS_SYNC_IN_QUICK           0x00000002  // CSCFillSparseFiles(FALSE)
#define SDS_SYNC_IN_FULL            0x00000004  // CSCFillSparseFiles(TRUE)
#define SDS_SYNC_FORCE_INWARD       0x00000008
#define SDS_SYNC_RAS_CONNECTED      0x00000010
#define SDS_SYNC_RESTART_MERGE      0x00000020
#define SDS_SYNC_DELETE_DELETE      0x00000040
#define SDS_SYNC_DELETE_RESTORE     0x00000080
#define SDS_SYNC_AUTOCACHE          0x00000100
#define SDS_SYNC_CONFLICT_KEEPLOCAL 0x00000200
#define SDS_SYNC_CONFLICT_KEEPNET   0x00000400
#define SDS_SYNC_CONFLICT_KEEPBOTH  0x00000800
#define SDS_SYNC_STARTED            0x00010000
#define SDS_SYNC_ERROR              0x00020000
#define SDS_SYNC_CANCELLED          0x00040000
#define SDS_SYNC_FILE_SKIPPED       0x00080000

#define SDS_SYNC_DELETE_CONFLICT_MASK   (SDS_SYNC_DELETE_DELETE | SDS_SYNC_DELETE_RESTORE)
#define SDS_SYNC_FILE_CONFLICT_MASK     (SDS_SYNC_CONFLICT_KEEPLOCAL | SDS_SYNC_CONFLICT_KEEPNET | SDS_SYNC_CONFLICT_KEEPBOTH)


// Sync Flags used internally by CCscUpdate
#define CSC_SYNC_OUT                0x00000001L
#define CSC_SYNC_IN_QUICK           0x00000002L
#define CSC_SYNC_IN_FULL            0x00000004L
#define CSC_SYNC_SETTINGS           0x00000008L
#define CSC_SYNC_MAYBOTHERUSER      0x00000010L
#define CSC_SYNC_NOTIFY_SYSTRAY     0x00000020L
#define CSC_SYNC_LOGOFF             0x00000040L
#define CSC_SYNC_LOGON              0x00000080L
#define CSC_SYNC_IDLE               0x00000100L
#define CSC_SYNC_NONET              0x00000200L
#define CSC_SYNC_PINFILES           0x00000400L
#define CSC_SYNC_PIN_RECURSE        0x00000800L
#define CSC_SYNC_OFWARNINGDONE      0x00001000L
#define CSC_SYNC_CANCELLED          0x00002000L
#define CSC_SYNC_SHOWUI_ALWAYS      0x00004000L
#define CSC_SYNC_IGNORE_ACCESS      0x00008000L
#define CSC_SYNC_EFS_PIN_NONE       0x00010000L
#define CSC_SYNC_EFS_PIN_ALL        0x00020000L
#define CSC_SYNC_RECONNECT          0x00040000L

#define CSC_LOCALLY_MODIFIED    (FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED         \
                                    | FLAG_CSC_COPY_STATUS_LOCALLY_DELETED          \
                                    | FLAG_CSC_COPY_STATUS_LOCALLY_CREATED)

HICON g_hCscIcon = NULL;

// Used for marshalling data into the SyncMgr process
typedef struct _CSC_UPDATE_DATA
{
    DWORD dwUpdateFlags;
    DWORD dwFileBufferOffset;
} CSC_UPDATE_DATA, *PCSC_UPDATE_DATA;


LPTSTR GetErrorText(DWORD dwErr)
{
    UINT idString = (UINT)-1;
    LPTSTR pszError = NULL;

    switch (dwErr)
    {
    case ERROR_INVALID_NAME:
        // "Files of this type cannot be made available offline."
        idString = IDS_CACHING_DISALLOWED;
        break;
    }

    if ((UINT)-1 != idString)
    {
        LoadStringAlloc(&pszError, g_hInstance, idString);
    }
    else if (NOERROR != dwErr)
    {
        FormatSystemError(&pszError, dwErr);
    }
    return pszError;
}


//*************************************************************
//
//  CscUpdateCache
//
//  Purpose:    Invoke SyncMgr to update the CSC cache
//
//  Parameters: pNamelist - list of files passed to the CSC SyncMgr handler
//
//
//  Return:     HRESULT
//
//*************************************************************
HRESULT
CscUpdateCache(DWORD dwUpdateFlags, CscFilenameList *pfnl)
{
    HRESULT hr;
    HRESULT hrComInit = E_FAIL;
    ISyncMgrSynchronizeInvoke *pSyncInvoke = NULL;
    DWORD dwSyncMgrFlags = 0;
    ULONG cbDataLength = sizeof(CSC_UPDATE_DATA);
    PCSC_UPDATE_DATA pUpdateData = NULL;
    PCSC_NAMELIST_HDR pNamelist = NULL;

    TraceEnter(TRACE_UPDATE, "CscUpdateCache");

    hrComInit = CoInitialize(NULL);
    hr = CoCreateInstance(CLSID_SyncMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISyncMgrSynchronizeInvoke,
                          (LPVOID*)&pSyncInvoke);
    FailGracefully(hr, "Unable to create SyncMgr object");

    if (dwUpdateFlags & CSC_UPDATE_SELECTION)
    {
        if (NULL == pfnl || (0 == (CSC_UPDATE_SHOWUI_ALWAYS & dwUpdateFlags) && 0 == pfnl->GetShareCount()))
            ExitGracefully(hr, E_INVALIDARG, "CSC_UPDATE_SELECTION with no selection");

        pNamelist = pfnl->CreateListBuffer();
        if (!pNamelist)
            ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create namelist buffer");

        cbDataLength += pNamelist->cbSize;
    }

    //
    // Alloc a buffer for the cookie data
    //
    pUpdateData = (PCSC_UPDATE_DATA)LocalAlloc(LPTR, cbDataLength);
    if (!pUpdateData)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pUpdateData->dwUpdateFlags = dwUpdateFlags;
    if (pNamelist)
    {
        pUpdateData->dwFileBufferOffset = sizeof(CSC_UPDATE_DATA);
        CopyMemory(ByteOffset(pUpdateData, pUpdateData->dwFileBufferOffset),
                   pNamelist,
                   pNamelist->cbSize);
    }

    if (dwUpdateFlags & CSC_UPDATE_STARTNOW)
        dwSyncMgrFlags |= SYNCMGRINVOKE_STARTSYNC;

    //
    // Start SyncMgr
    //
    hr = pSyncInvoke->UpdateItems(dwSyncMgrFlags,
                                  CLSID_CscUpdateHandler,
                                  cbDataLength,
                                  (LPBYTE)pUpdateData);

exit_gracefully:

    if (pNamelist)
        CscFilenameList::FreeListBuffer(pNamelist);

    if (pUpdateData)
        LocalFree(pUpdateData);

    DoRelease(pSyncInvoke);

    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    TraceLeaveResult(hr);
}


//*************************************************************
//
//  GetNewVersionName
//
//  Purpose:    Create unique names for copies of a file
//
//  Parameters: LPTSTR pszUNCPath - fully qualified UNC name of file
//              LPTSTR pszShare - \\server\share that file lives on
//              LPTSTR pszDrive - drive mapping to use for net operations
//              LPTSTR *ppszNewName - filename for new version returned here (must free)
//
//  Return:     Win32 error code
//
//*************************************************************
DWORD
GetNewVersionName(LPCTSTR pszUNCPath,
                  LPCTSTR pszShare,
                  LPCTSTR pszDrive,
                  LPTSTR *ppszNewName)
{
    DWORD dwErr = NOERROR;
    LPTSTR pszDriveLetterPath = NULL;
    LPTSTR pszPath = NULL;
    LPTSTR pszFile = NULL;
    LPTSTR pszExt = NULL;
    LPTSTR pszWildCardName = NULL;
    TCHAR szUserName[MAX_USERNAME_CHARS];
    ULONG nLength;
    ULONG nMaxVersion = 0;
    ULONG cOlderVersions = 0;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR pszT;

    TraceEnter(TRACE_UPDATE, "GetNewVersionName");
    TraceAssert(pszUNCPath != NULL);
    TraceAssert(ppszNewName != NULL);

    *ppszNewName = NULL;

    // 1. Split the path into components.
    // 2. Build wildcard name "X:\dir\foo (johndoe v*).txt"
    // 3. Do a findfirst/findnext loop to get the min & max version #
    //    and count the number of old versions.
    // 4. Increment the max version # and build the new filename as:
    //    "foo (johndoe v<max+1>).txt"

    // Assume that the UNC name contains more than the share
    TraceAssert(!StrCmpNI(pszUNCPath, pszShare, lstrlen(pszShare)));
    TraceAssert(lstrlen(pszUNCPath) > lstrlen(pszShare));

    // Copy the path (without \\server\share)
    if (!LocalAllocString(&pszPath, pszUNCPath + lstrlen(pszShare)))
        ExitGracefully(dwErr, ERROR_OUTOFMEMORY, "LocalAllocString failed");

    // Find the file part of the name
    pszT = PathFindFileName(pszPath);
    if (!pszT)
        ExitGracefully(dwErr, ERROR_INVALID_PARAMETER, "Incomplete path");

    // Copy the filename
    if (!LocalAllocString(&pszFile, pszT))
        ExitGracefully(dwErr, ERROR_OUTOFMEMORY, "LocalAllocString failed");

    // Look for the file extension
    pszT = PathFindExtension(pszFile);
    if (pszT)
    {
        // Copy the extension and truncate the file root at this point
        LocalAllocString(&pszExt, pszT);
        *pszT = TEXT('\0');
    }

    // Truncate the path
    PathRemoveFileSpec(pszPath);

    // Get the user name
    nLength = ARRAYSIZE(szUserName);
    if (!GetUserName(szUserName, &nLength))
        LoadString(g_hInstance, IDS_UNKNOWN_USER, szUserName, ARRAYSIZE(szUserName));

    // Build the wildcard path "foo (johndoe v*).txt"

    nLength = FormatStringID(&pszWildCardName, g_hInstance, IDS_VERSION_FORMAT, pszFile, szUserName, c_szStar, pszExt);
    if (!nLength)
        ExitGracefully(dwErr, GetLastError(), "Unable to format string");

    pszDriveLetterPath = (LPTSTR)LocalAlloc(LPTR, MAX_PATH_BYTES);
    if (!pszDriveLetterPath)
        ExitGracefully(dwErr, ERROR_OUTOFMEMORY, "LocalAlloc failed");

    if (!PathCombine(pszDriveLetterPath, pszDrive, pszPath) ||
        !PathAppend(pszDriveLetterPath, pszWildCardName))
    {
        ExitGracefully(dwErr, ERROR_FILENAME_EXCED_RANGE, "Path too long");
    }
    nLength = (ULONG)(StrStr(pszWildCardName, c_szStar) - pszWildCardName); // remember where the '*' is

    // Search for existing versions of the file with this username
    hFind = FindFirstFile(pszDriveLetterPath, &fd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        ULONG nVersion;

        do
        {
            nVersion = StrToLong(&fd.cFileName[nLength]);

            if (nVersion > nMaxVersion)
            {
                nMaxVersion = nVersion;
            }

            cOlderVersions++;
        }
        while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    // Build the new file name to return to the caller.
    // This one is version nMaxVersion+1.
    ULongToString(nMaxVersion+1, pszDriveLetterPath, MAX_PATH);
    nLength = FormatStringID(ppszNewName, g_hInstance, IDS_VERSION_FORMAT, pszFile, szUserName, pszDriveLetterPath, pszExt);
    if (!nLength)
        ExitGracefully(dwErr, GetLastError(), "Unable to format string");

exit_gracefully:

    LocalFreeString(&pszDriveLetterPath);
    LocalFreeString(&pszPath);
    LocalFreeString(&pszFile);
    LocalFreeString(&pszExt);
    LocalFreeString(&pszWildCardName);

    if (NOERROR != dwErr)
    {
        LocalFreeString(ppszNewName);
    }

    TraceLeaveValue(dwErr);
}


//*************************************************************
//
//  ConflictDlgCallback
//
//  Purpose:    Display local or remote file from conflict dialog
//
//  Parameters: hWnd - conflict dialog handle (used as parent for UI)
//              uMsg - one of RFCCM_*
//              wParam - depends on uMsg (unused)
//              lParam - pointer to context data (RFCDLGPARAM)
//
//
//  Return:     TRUE on success, FALSE otherwise
//
//*************************************************************

typedef struct _CONFLICT_DATA
{
    LPCTSTR pszShare;
    LPCTSTR pszDrive;
} CONFLICT_DATA;

BOOL
ConflictDlgCallback(HWND hWnd, UINT uMsg, WPARAM /*wParam*/, LPARAM lParam)
{
    RFCDLGPARAM *pdlgParam = (RFCDLGPARAM*)lParam;
    CONFLICT_DATA cd = {0};
    LPTSTR pszTmpName = NULL;
    ULONG cchShare = 0;
    LPTSTR szFile;
    DWORD dwErr = NOERROR;

    TraceEnter(TRACE_UPDATE, "ConflictDlgCallback");

    if (NULL == pdlgParam)
    {
        TraceAssert(FALSE);
        TraceLeaveValue(FALSE);
    }

    szFile = (LPTSTR)LocalAlloc(LMEM_FIXED,
                                MAX(StringByteSize(pdlgParam->pszLocation)
                                    + StringByteSize(pdlgParam->pszFilename), MAX_PATH_BYTES));
    if (!szFile)
        TraceLeaveValue(FALSE);

    if (pdlgParam->lCallerData)
        cd = *(CONFLICT_DATA*)pdlgParam->lCallerData;
    if (cd.pszShare)
        cchShare = lstrlen(cd.pszShare);

    switch (uMsg)
    {
    case RFCCM_VIEWLOCAL:
        // Build UNC path and view what's in the cache
        if (PathCombine(szFile, pdlgParam->pszLocation, pdlgParam->pszFilename))
        {
            dwErr = OpenOfflineFile(szFile);
        }
        else
        {
            dwErr = ERROR_FILENAME_EXCED_RANGE;
        }
        break;

    case RFCCM_VIEWNETWORK:
        // Build drive letter (non-UNC) path and ShellExecute it
        if (PathCombine(szFile, cd.pszDrive, pdlgParam->pszLocation + cchShare)
            && PathAppend(szFile, pdlgParam->pszFilename))
        {
            SHELLEXECUTEINFO si = {0};
            si.cbSize           = sizeof(si);
            si.fMask            = SEE_MASK_FLAG_NO_UI;
            si.hwnd             = hWnd;
            si.lpFile           = szFile;
            si.nShow            = SW_NORMAL;

            Trace((TEXT("ShellExecuting \"%s\""), szFile));
            if (!ShellExecuteEx(&si))
                dwErr = GetLastError();
        }
        else
        {
            dwErr = ERROR_FILENAME_EXCED_RANGE;
        }
        break;
    }

    if (NOERROR != dwErr)
        CscWin32Message(hWnd, dwErr, CSCUI::SEV_ERROR);

    LocalFree(szFile);
    TraceLeaveValue(TRUE);
}

//*************************************************************
//
//  ShowConflictDialog
//
//  Purpose:    Invoke the conflict resolution dialog
//
//  Parameters: hWndParent - dialog parent window
//              pszUNCPath - full UNC of file that conflicts
//              pszNewName - filespec to use for new copy of file (e.g. "foo (johndoe v1).txt"
//              pszShare - "\\server\share"
//              pszDrive - "X:" drive mapping of remote connection
//              pfdLocal - Information about local file
//              pfdRemote - Information about remote file
//
//
//  Return:     HRESULT
//
//*************************************************************

typedef int (WINAPI *PFNSYNCMGRRESOLVECONFLICT)(HWND hWndParent, RFCDLGPARAM *pdlgParam);
TCHAR const c_szSyncMgrDll[]        = TEXT("mobsync.dll");
CHAR  const c_szResolveConflict[]   = "SyncMgrResolveConflictW";

BOOL FileHasAssociation(LPCTSTR pszFile)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_ASSOCIATION);
    if (pszFile)
    {
        pszFile = PathFindExtension(pszFile);
        if (pszFile && *pszFile)
        {
            IQueryAssociations *pAssoc = NULL;
            hr = AssocCreate(CLSID_QueryAssociations,
                             IID_IQueryAssociations,
                             (LPVOID*)&pAssoc);
            if (SUCCEEDED(hr))
            {
                hr = pAssoc->Init(ASSOCF_IGNOREBASECLASS, pszFile, NULL, NULL);
                pAssoc->Release();
            }
        }
    }
    return SUCCEEDED(hr);
}

int
ShowConflictDialog(HWND hWndParent,
                   LPCTSTR pszUNCPath,
                   LPCTSTR pszNewName,
                   LPCTSTR pszShare,
                   LPCTSTR pszDrive,
                   LPWIN32_FIND_DATA pfdLocal,
                   LPWIN32_FIND_DATA pfdRemote)
{
    int nResult = 0;
    TCHAR szUser[MAX_USERNAME_CHARS];
    LPTSTR pszPath = NULL;
    LPTSTR pszFile = NULL;
    TCHAR szRemoteDate[MAX_PATH];
    TCHAR szLocalDate[MAX_PATH];
    ULONG nLength;
    RFCDLGPARAM dp = {0};
    CONFLICT_DATA cd;
    BOOL bLocalIsDir = FALSE;
    BOOL bRemoteIsDir = FALSE;

    static PFNSYNCMGRRESOLVECONFLICT pfnResolveConflict = NULL;

    TraceEnter(TRACE_UPDATE, "ShowConflictDialog");
    TraceAssert(pszUNCPath);

    if (NULL == pfnResolveConflict)
    {
        // The CSC Update handler is loaded by SyncMgr, so assume the SyncMgr
        // dll is already loaded.  We don't want to link to the LIB to keep
        // SyncMgr from loading every time our context menu or icon overlay
        // handler is loaded (for example).
        HMODULE hSyncMgrDll = GetModuleHandle(c_szSyncMgrDll);
        if (NULL != hSyncMgrDll)
            pfnResolveConflict = (PFNSYNCMGRRESOLVECONFLICT)GetProcAddress(hSyncMgrDll,
                                                                           c_szResolveConflict);
        if (NULL == pfnResolveConflict)
            return 0;
    }
    TraceAssert(NULL != pfnResolveConflict);

    szUser[0] = TEXT('\0');
    nLength = ARRAYSIZE(szUser);
    GetUserName(szUser, &nLength);

    szRemoteDate[0] = TEXT('\0');
    if (NULL != pfdRemote)
    {
        DWORD dwFlags = FDTF_DEFAULT;
        SHFormatDateTime(&pfdRemote->ftLastWriteTime, &dwFlags, szRemoteDate, ARRAYSIZE(szRemoteDate));

        if (pfdRemote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            bRemoteIsDir = TRUE;
    }

    szLocalDate[0] = TEXT('\0');
    if (NULL != pfdLocal)
    {
        DWORD dwFlags = FDTF_DEFAULT;
        SHFormatDateTime(&pfdLocal->ftLastWriteTime, &dwFlags, szLocalDate, ARRAYSIZE(szLocalDate));

        if (pfdLocal->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            bLocalIsDir = TRUE;
    }

    if (!LocalAllocString(&pszPath, pszUNCPath))
        ExitGracefully(nResult, 0, "LocalAllocString failed");
    pszFile = PathFindFileName(pszUNCPath);
    PathRemoveFileSpec(pszPath);

    dp.dwFlags              = RFCF_APPLY_ALL;
    dp.pszFilename          = pszFile;
    dp.pszLocation          = pszPath;
    dp.pszNewName           = pszNewName;
    dp.pszNetworkModifiedBy = NULL;
    dp.pszLocalModifiedBy   = szUser;
    dp.pszNetworkModifiedOn = szRemoteDate;
    dp.pszLocalModifiedOn   = szLocalDate;
    dp.pfnCallBack          = NULL;
    dp.lCallerData          = 0;

    // Only turn on the View buttons (set a callback) if we're
    // dealing with files that have associations.
    if (!(bLocalIsDir || bRemoteIsDir) && FileHasAssociation(pszFile))
    {
        // Save both the share name and drive letter for building paths to view files
        cd.pszShare = pszShare;
        cd.pszDrive = pszDrive;

        dp.pfnCallBack      = ConflictDlgCallback;
        dp.lCallerData      = (LPARAM)&cd;
    }

    nResult = (*pfnResolveConflict)(hWndParent, &dp);

exit_gracefully:

    LocalFreeString(&pszPath);
    // No need to free pszFile

    TraceLeaveValue(nResult);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SyncMgr integration implementation                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CCscUpdate::CCscUpdate() : m_cRef(1), m_bCSInited(FALSE),
  m_pSyncMgrCB(NULL), m_hSyncThreads(NULL),
  m_pFileList(NULL), m_hSyncItems(NULL), m_hwndDlgParent(NULL),
  m_hgcSyncInProgress(NULL), m_pConflictPinList(NULL),
  m_pSilentFolderList(NULL), m_pSpecialFolderList(NULL),
  m_bCacheIsEncrypted(IsCacheEncrypted(NULL))
{
    DllAddRef();
    if (!g_hCscIcon)
        g_hCscIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_CSCUI_ICON));
}


CCscUpdate::~CCscUpdate()
{
    TraceEnter(TRACE_UPDATE, "CCscUpdate::~CCscUpdate");

    SyncCompleted();
    TraceAssert(NULL == m_hgcSyncInProgress);

    // We should never get here while a sync thread is still running
    TraceAssert(NULL == m_hSyncThreads || 0 == DPA_GetPtrCount(m_hSyncThreads));
    DPA_Destroy(m_hSyncThreads);

    if (m_bCSInited)
    {
        DeleteCriticalSection(&m_csThreadList);
    }

    DSA_Destroy(m_hSyncItems);

    DoRelease(m_pSyncMgrCB);

    delete m_pFileList;
    delete m_pConflictPinList;
    delete m_pSilentFolderList;
    delete m_pSpecialFolderList;

    if (NULL != m_hSyncMutex)
        CloseHandle(m_hSyncMutex);

    DllRelease();
    TraceLeaveVoid();
}


HRESULT
CCscUpdate::_Init()
{
    TraceEnter(TRACE_UPDATE, "CCscUpdate::_Init");

    HRESULT hr = m_ShareLog.Initialize(HKEY_CURRENT_USER, c_szCSCShareKey);
    if (SUCCEEDED(hr))
    {
        m_bCSInited = InitializeCriticalSectionAndSpinCount(&m_csThreadList, 0);
        if (m_bCSInited)
        {
            m_hSyncMutex = CreateMutex(NULL, FALSE, c_szSyncMutex);
            if (NULL == m_hSyncMutex)
            {
                hr = ResultFromLastError();
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }

    TraceLeaveResult(hr);
}


HRESULT WINAPI
CCscUpdate::CreateInstance(REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    CCscUpdate *pThis;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::CreateInstance");
    TraceAssert(IsCSCEnabled());

    pThis = new CCscUpdate;

    if (pThis)
    {
        hr = pThis->_Init();
        if (SUCCEEDED(hr))
        {
            hr = pThis->QueryInterface(riid, ppv);
        }
        pThis->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    TraceLeaveResult(hr);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SyncMgr integration implementation (IUnknown)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCscUpdate::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CCscUpdate, ISyncMgrSynchronize),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CCscUpdate::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CCscUpdate::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Sync Manager integration implementation (ISyncMgrSynchronize)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CCscUpdate::Initialize(DWORD /*dwReserved*/,
                       DWORD dwSyncFlags,
                       DWORD cbCookie,
                       const BYTE *pCookie)
{
    HRESULT hr = S_OK;
    BOOL bNoNet = TRUE;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::Initialize");
    TraceAssert(IsCSCEnabled());

    if (!(SYNCMGRFLAG_SETTINGS & dwSyncFlags) && ::IsSyncInProgress())
    {
        //
        // We need to guard against running multiple syncs at the 
        // same time.  User notification in the UI is handled where
        // the UI code calls CscUpdate().  This is so that the UI 
        // message contains the proper context with respect to what 
        // the user is doing.
        //
        TraceLeaveResult(E_FAIL);
    }

    m_dwSyncFlags = 0;
    delete m_pFileList;
    m_pFileList = NULL;
    delete m_pConflictPinList;
    m_pConflictPinList = NULL;

    // We used to get the tray status to check for NoNet, but
    // there's a timing problem at logon (the tray window may not
    // be created yet).  So ask RDR instead.  If this call fails,
    // then RDR must be dead, so bNoNet defaults to TRUE.
    CSCIsServerOffline(NULL, &bNoNet);

    switch (dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
    {
    case SYNCMGRFLAG_CONNECT:               // Logon
        if (bNoNet)
            ExitGracefully(hr, E_FAIL, "No Logon sync when no net");
        m_dwSyncFlags = CSC_SYNC_OUT | CSC_SYNC_LOGON | CSC_SYNC_NOTIFY_SYSTRAY; // | CSC_SYNC_RECONNECT;
        if (CConfig::eSyncFull == CConfig::GetSingleton().SyncAtLogon())
        {
            m_dwSyncFlags |= CSC_SYNC_IN_FULL;
        }
        break;

    case SYNCMGRFLAG_PENDINGDISCONNECT:     // Logoff
        if (bNoNet)
            ExitGracefully(hr, E_FAIL, "No Logoff sync when no net");
        m_dwSyncFlags = CSC_SYNC_LOGOFF;
        if (CConfig::eSyncFull == CConfig::GetSingleton().SyncAtLogoff())
            m_dwSyncFlags |= CSC_SYNC_OUT | CSC_SYNC_IN_FULL;
        else
            m_dwSyncFlags |= CSC_SYNC_IN_QUICK;
        break;

    case SYNCMGRFLAG_INVOKE:                // CscUpdateCache
        if (pCookie != NULL && cbCookie > 0)
        {
            PCSC_UPDATE_DATA pUpdateData = (PCSC_UPDATE_DATA)pCookie;

            TraceAssert(cbCookie >= sizeof(CSC_UPDATE_DATA));

            DWORD dwUpdateFlags = pUpdateData->dwUpdateFlags;

            if (dwUpdateFlags & CSC_UPDATE_SELECTION)
            {
                TraceAssert(cbCookie > sizeof(CSC_UPDATE_DATA));

                // Create the filelist from the selection provided
                m_pFileList = new CscFilenameList((PCSC_NAMELIST_HDR)ByteOffset(pUpdateData, pUpdateData->dwFileBufferOffset),
                                                  true);

                if (!m_pFileList)
                    ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create CscFilenameList object");

                if (!m_pFileList->IsValid())
                    ExitGracefully(hr, E_FAIL, "Unable to initialize CscFilenameList object");

                if (CSC_UPDATE_SHOWUI_ALWAYS & dwUpdateFlags)
                {
                    m_dwSyncFlags |= CSC_SYNC_SHOWUI_ALWAYS;
                }
                else if (0 == m_pFileList->GetShareCount())
                    ExitGracefully(hr, E_UNEXPECTED, "CSC_UPDATE_SELECTION with no selection");
            }

            if (dwUpdateFlags & CSC_UPDATE_RECONNECT)
            {
                m_dwSyncFlags |= CSC_SYNC_RECONNECT;
            }

            if (dwUpdateFlags & CSC_UPDATE_UNATTENDED)
            {
                dwSyncFlags &= ~SYNCMGRFLAG_MAYBOTHERUSER;
            }

            if (dwUpdateFlags & CSC_UPDATE_NOTIFY_DONE)
            {
                //
                // Caller of CscUpdateCache want's systray notification
                // when sync is complete.
                //
                m_dwSyncFlags |= CSC_SYNC_NOTIFY_SYSTRAY;
            }

            if (dwUpdateFlags & CSC_UPDATE_FILL_ALL)
                m_dwSyncFlags |= CSC_SYNC_IN_FULL;
            else if (dwUpdateFlags & CSC_UPDATE_FILL_QUICK)
                m_dwSyncFlags |= CSC_SYNC_IN_QUICK;

            if (dwUpdateFlags & CSC_UPDATE_REINT)
                m_dwSyncFlags |= CSC_SYNC_OUT;

            if (dwUpdateFlags & CSC_UPDATE_PIN_RECURSE)
                m_dwSyncFlags |= CSC_SYNC_PINFILES | CSC_SYNC_PIN_RECURSE | CSC_SYNC_IN_QUICK;
            else if (dwUpdateFlags & CSC_UPDATE_PINFILES)
                m_dwSyncFlags |= CSC_SYNC_PINFILES | CSC_SYNC_IN_QUICK;

            if (dwUpdateFlags & CSC_UPDATE_IGNORE_ACCESS)
                m_dwSyncFlags |= CSC_SYNC_IGNORE_ACCESS;
        }
        break;

    case SYNCMGRFLAG_IDLE:                  // Auto-sync at idle time
        if (bNoNet)
            ExitGracefully(hr, E_FAIL, "No idle sync when no net");
        m_dwSyncFlags = CSC_SYNC_OUT | CSC_SYNC_IN_QUICK | CSC_SYNC_IDLE | CSC_SYNC_NOTIFY_SYSTRAY;
        break;

    case SYNCMGRFLAG_MANUAL:                // Run "mobsync.exe"
        m_dwSyncFlags = CSC_SYNC_OUT | CSC_SYNC_IN_FULL | CSC_SYNC_NOTIFY_SYSTRAY | CSC_SYNC_RECONNECT;
        break;

    case SYNCMGRFLAG_SCHEDULED:             // User scheduled sync
        m_dwSyncFlags = CSC_SYNC_OUT | CSC_SYNC_IN_FULL | CSC_SYNC_NOTIFY_SYSTRAY;
        break;
    }

    if (!(m_dwSyncFlags & CSC_SYNC_PINFILES))
        m_dwSyncFlags |= CSC_SYNC_EFS_PIN_NONE; // skip EFS if not pinning

    if (dwSyncFlags & SYNCMGRFLAG_SETTINGS)
        m_dwSyncFlags |= CSC_SYNC_SETTINGS;

    if (!m_dwSyncFlags)
        ExitGracefully(hr, E_UNEXPECTED, "Nothing to do");

    if (dwSyncFlags & SYNCMGRFLAG_MAYBOTHERUSER)
        m_dwSyncFlags |= CSC_SYNC_MAYBOTHERUSER;

    if (bNoNet)
        m_dwSyncFlags |= CSC_SYNC_NONET;

    hr = GetSilentFolderList();
    if (FAILED(hr))
    {
        m_dwSyncFlags = 0;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


STDMETHODIMP
CCscUpdate::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    HRESULT hr = S_OK;
    LPSYNCMGRHANDLERINFO pHandlerInfo;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::GetHandlerInfo");

    if (NULL == ppSyncMgrHandlerInfo)
        TraceLeaveResult(E_INVALIDARG);

    *ppSyncMgrHandlerInfo = NULL;

    pHandlerInfo = (LPSYNCMGRHANDLERINFO)CoTaskMemAlloc(sizeof(SYNCMGRHANDLERINFO));
    if (NULL == pHandlerInfo)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pHandlerInfo->cbSize = sizeof(SYNCMGRHANDLERINFO);
    pHandlerInfo->hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_CSCUI_ICON));
    pHandlerInfo->SyncMgrHandlerFlags = (m_dwSyncFlags & CSC_SYNC_LOGOFF) ? 0 :
        (SYNCMGRHANDLER_HASPROPERTIES | SYNCMGRHANDLER_MAYESTABLISHCONNECTION);
    LoadStringW(g_hInstance,
                IDS_APPLICATION,
                pHandlerInfo->wszHandlerName,
                ARRAYSIZE(pHandlerInfo->wszHandlerName));

    *ppSyncMgrHandlerInfo = pHandlerInfo;

exit_gracefully:

    TraceLeaveResult(hr);
}


STDMETHODIMP
CCscUpdate::EnumSyncMgrItems(LPSYNCMGRENUMITEMS *ppenum)
{
    HRESULT hr;
    PUPDATEENUM pNewEnum;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::EnumSyncMgrItems");

    *ppenum = NULL;

    pNewEnum = new CUpdateEnumerator(this);
    if (pNewEnum)
    {
        hr = pNewEnum->QueryInterface(IID_ISyncMgrEnumItems, (LPVOID*)ppenum);
        pNewEnum->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    TraceLeaveResult(hr);
}


STDMETHODIMP
CCscUpdate::GetItemObject(REFSYNCMGRITEMID /*rItemID*/, REFIID /*riid*/, LPVOID * /*ppv*/)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CCscUpdate::ShowProperties(HWND hWndParent, REFSYNCMGRITEMID rItemID)
{
    COfflineFilesFolder::Open();

        // Notify SyncMgr that the ShowProperties is done.
    if (NULL != m_pSyncMgrCB)
        m_pSyncMgrCB->ShowPropertiesCompleted(S_OK);

    return S_OK;
}


STDMETHODIMP
CCscUpdate::SetProgressCallback(LPSYNCMGRSYNCHRONIZECALLBACK pCallback)
{
    TraceEnter(TRACE_UPDATE, "CCscUpdate::SetProgressCallback");

    DoRelease(m_pSyncMgrCB);

    m_pSyncMgrCB = pCallback;

    if (m_pSyncMgrCB)
        m_pSyncMgrCB->AddRef();

    TraceLeaveResult(S_OK);
}


STDMETHODIMP
CCscUpdate::PrepareForSync(ULONG cNumItems,
                           SYNCMGRITEMID *pItemID,
                           HWND /*hWndParent*/,
                           DWORD /*dwReserved*/)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::PrepareForSync");
    TraceAssert(0 != cNumItems);
    TraceAssert(NULL != pItemID);

    //
    // Copy the list of item ID's
    //
    if (NULL == m_hSyncItems)
    {
        m_hSyncItems = DSA_Create(sizeof(SYNCMGRITEMID), 4);
        if (NULL == m_hSyncItems)
            ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DSA for SYNCMGRITEMID list");
    }
    else
        DSA_DeleteAllItems(m_hSyncItems);

    while (cNumItems--)
        DSA_AppendItem(m_hSyncItems, pItemID++);

exit_gracefully:

    // ISyncMgrSynchronize::PrepareForSync is now an asynchronous call
    // so we could create another thread to do the work and return from
    // this call immediately.  However, since all we do is copy the list
    // of Item IDs, let's do it here and call
    // m_pSyncMgrCB->PrepareForSyncCompleted before returning.

    if (NULL != m_pSyncMgrCB)
        m_pSyncMgrCB->PrepareForSyncCompleted(hr);

    TraceLeaveResult(hr);
}


STDMETHODIMP
CCscUpdate::Synchronize(HWND hWndParent)
{
    HRESULT hr = E_FAIL;
    ULONG cItems = 0;
    BOOL bConnectionEstablished = FALSE;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::Synchronize");

    if (NULL != m_hSyncItems)
        cItems = DSA_GetItemCount(m_hSyncItems);

    //
    // Don't want systray UI updates while syncing.
    // Whenever the systray UI is updated, the code checks first
    // for this global counter object.  If it's non-zero, the
    // systray knows there's a sync in progress and the UI isn't
    // updated.
    //
    TraceAssert(NULL == m_hgcSyncInProgress);
    m_hgcSyncInProgress = SHGlobalCounterCreateNamed(c_szSyncInProgCounter, 0);
    if (m_hgcSyncInProgress)
    {
        SHGlobalCounterIncrement(m_hgcSyncInProgress);
    }

    if (0 == cItems)
    {
        ExitGracefully(hr, E_UNEXPECTED, "Nothing to synchronize");
    }
    else if (1 == cItems)
    {
        SYNCMGRITEMID *pItemID = (SYNCMGRITEMID*)DSA_GetItemPtr(m_hSyncItems, 0);
        if (NULL != pItemID && IsEqualGUID(GUID_CscNullSyncItem, *pItemID))
        {
            //
            // A single item in the DSA and it's our "null sync" GUID.
            // This means we really have nothing to sync but the invoker 
            // of the sync wants to see some SyncMgr progress UI.  In 
            // this scenario the update item enumerator already enumerated
            // the "null sync" item.  Here we set this single item's progress
            // UI info to 100% complete and skip any sync activity.
            //
            SYNCMGRPROGRESSITEM spi = {0};
            spi.mask = SYNCMGRPROGRESSITEM_STATUSTYPE |
                       SYNCMGRPROGRESSITEM_STATUSTEXT |
                       SYNCMGRPROGRESSITEM_PROGVALUE | 
                       SYNCMGRPROGRESSITEM_MAXVALUE;

            spi.cbSize        = sizeof(spi);
            spi.dwStatusType  = SYNCMGRSTATUS_SUCCEEDED;
            spi.lpcStatusText = L" ";
            spi.iProgValue    = 1;
            spi.iMaxValue     = 1;
            m_pSyncMgrCB->Progress(GUID_CscNullSyncItem, &spi);
            m_pSyncMgrCB->SynchronizeCompleted(S_OK);

            if (CSC_SYNC_RECONNECT & m_dwSyncFlags)
            {
                //
                // We have nothing to sync but one or more servers
                // may still be offline.  The user's expectation is that the
                // sync will transition these to online regardless of link
                // speed.  Add them to the "reconnect" list.
                //
                _BuildOfflineShareList(&m_ReconnectList);
            }
            ExitGracefully(hr, NOERROR, "Nothing to sync.  Progress UI displayed");
        }
    }

    m_hwndDlgParent = hWndParent;

    // We can pin autocached files without a net (no sync required);
    // otherwise we need to establish a RAS connection to do anything.
    if ((m_dwSyncFlags & CSC_SYNC_NONET) && !(m_dwSyncFlags & CSC_SYNC_PINFILES))
    {
        hr = m_pSyncMgrCB->EstablishConnection(NULL, 0);
        FailGracefully(hr, "Unable to establish RAS connection");

        bConnectionEstablished = TRUE;
    }

    // For each share, kick off a thread to do the work
    while (cItems > 0)
    {
        SYNCMGRITEMID *pItemID;
        CSCEntry *pShareEntry;

        --cItems;
        pItemID = (SYNCMGRITEMID*)DSA_GetItemPtr(m_hSyncItems, cItems);

        pShareEntry = m_ShareLog.Get(*pItemID);

        // We don't enumerate shares to SyncMgr unless a share entry
        // exists in the registry, so m_ShareLog.Get should never fail here.
        if (NULL == pShareEntry)
            ExitGracefully(hr, E_UNEXPECTED, "No share entry");

        hr = SynchronizeShare(pItemID, pShareEntry->Name(), bConnectionEstablished);
        DSA_DeleteItem(m_hSyncItems, cItems);
        FailGracefully(hr, "Unable to create sync thread");
    }

    TraceAssert(0 == DSA_GetItemCount(m_hSyncItems));

exit_gracefully:

    if (FAILED(hr))
        SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);

    TraceLeaveResult(hr);
}


//
// Try to reconnect any server that is currently offline.
//
void 
CCscUpdate::_BuildOfflineShareList(
    CscFilenameList *pfnl
    )
{
    WIN32_FIND_DATA fd;
    DWORD dwStatus = 0;
    CCscFindHandle hFind = CacheFindFirst(NULL, &fd, &dwStatus, NULL, NULL, NULL);
    if (hFind.IsValid())
    {
        do
        {
            if (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwStatus)
            {
                CscFilenameList::HSHARE hShare;
                pfnl->AddShare(fd.cFileName, &hShare);
            }
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, NULL, NULL, NULL));
    }
}


STDMETHODIMP
CCscUpdate::SetItemStatus(REFSYNCMGRITEMID rItemID,
                          DWORD dwSyncMgrStatus)
{
    HRESULT hr = E_FAIL;
    ULONG cItems;
    BOOL bAllItems;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::SetItemStatus");

    if (SYNCMGRSTATUS_SKIPPED != dwSyncMgrStatus && SYNCMGRSTATUS_STOPPED != dwSyncMgrStatus)
        TraceLeaveResult(E_NOTIMPL);

    bAllItems = FALSE;
    if (SYNCMGRSTATUS_STOPPED == dwSyncMgrStatus)
    {
        bAllItems = TRUE;
        m_dwSyncFlags |= CSC_SYNC_CANCELLED;
    }

    // SetItemStatus can be called between PrepareForSync and Synchronize, in
    // in which case the correct thing to do is remove the item from m_hSyncItems.
    if (NULL != m_hSyncItems)
    {
        cItems = DSA_GetItemCount(m_hSyncItems);

        while (cItems > 0)
        {
            SYNCMGRITEMID *pItemID;

            --cItems;
            pItemID = (SYNCMGRITEMID*)DSA_GetItemPtr(m_hSyncItems, cItems);

            if (bAllItems || (NULL != pItemID && IsEqualGUID(rItemID, *pItemID)))
            {
                // Remove the item from the list of items to sync
                DSA_DeleteItem(m_hSyncItems, cItems);
                if (!bAllItems)
                    ExitGracefully(hr, S_OK, "Skipping item");
            }
        }
    }

    // Lookup the thread for the item ID and set its status
    // to cause it to terminate.
    hr = SetSyncThreadStatus(SyncStop, bAllItems ? GUID_NULL : rItemID);

exit_gracefully:

    TraceLeaveResult(hr);
}


STDMETHODIMP
CCscUpdate::ShowError(HWND /*hWndParent*/ , REFSYNCMGRERRORID /*ErrorID*/)
{
    return E_NOTIMPL;
}


HRESULT
CCscUpdate::SynchronizeShare(SYNCMGRITEMID *pItemID, LPCTSTR pszShareName, BOOL bRasConnected)
{
    HRESULT hr = S_OK;
    DWORD dwThreadID;
    PSYNCTHREADDATA pThreadData;
    ULONG cbShareName = 0;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::SynchronizeShare");
    TraceAssert(NULL != pItemID);
    TraceAssert(NULL != pszShareName);
    TraceAssert(*pszShareName);

    EnterCriticalSection(&m_csThreadList);
    if (NULL == m_hSyncThreads)
        m_hSyncThreads = DPA_Create(4);
    LeaveCriticalSection(&m_csThreadList);

    if (NULL == m_hSyncThreads)
        ExitGracefully(hr, E_OUTOFMEMORY, "Unable to create DPA for threads");

    cbShareName = StringByteSize(pszShareName);
    pThreadData = (PSYNCTHREADDATA)LocalAlloc(LPTR, sizeof(SYNCTHREADDATA) + cbShareName);

    if (!pThreadData)
        ExitGracefully(hr, E_OUTOFMEMORY, "LocalAlloc failed");

    pThreadData->pThis = this;
    pThreadData->ItemID = *pItemID;
    pThreadData->pszShareName = (LPTSTR)(pThreadData + 1);
    CopyMemory(pThreadData->pszShareName, pszShareName, cbShareName);

    //
    // If we established a RAS connection, then it will go away
    // right after the sync completes, so there's no point trying
    // to reconnect.  That is, only check CSC_SYNC_RECONNECT and
    // add the share to the reconnect list if we aren't doing RAS.
    //
    if (bRasConnected)
    {
        pThreadData->dwSyncStatus |= SDS_SYNC_RAS_CONNECTED;
    }
    else if (m_dwSyncFlags & CSC_SYNC_RECONNECT)
    {
        CscFilenameList::HSHARE hShare;
        m_ReconnectList.AddShare(pszShareName, &hShare);
    }

    // Give the thread a reference to this object and the DLL
    AddRef();
    LoadLibrary(c_szDllName);

    pThreadData->hThread = CreateThread(NULL,
                                        0,
                                        _SyncThread,
                                        pThreadData,
                                        CREATE_SUSPENDED,
                                        &dwThreadID);

    if (NULL != pThreadData->hThread)
    {
        EnterCriticalSection(&m_csThreadList);
        DPA_AppendPtr(m_hSyncThreads, pThreadData);
        LeaveCriticalSection(&m_csThreadList);

        ResumeThread(pThreadData->hThread);
    }
    else
    {
        DWORD dwErr = GetLastError();

        LocalFree(pThreadData);

        LPTSTR pszErr = GetErrorText(GetLastError());
        LogError(*pItemID,
                 SYNCMGRLOGLEVEL_ERROR,
                 IDS_FILL_SPARSE_FILES_ERROR,
                 pszShareName,
                 pszErr);
        LocalFreeString(&pszErr);
        hr = HRESULT_FROM_WIN32(dwErr);

        Release();
        FreeLibrary(g_hInstance);
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


void
CCscUpdate::SetLastSyncTime(LPCTSTR pszShareName)
{
    HKEY hKey = NULL;

    hKey = m_ShareLog.OpenKey(pszShareName, KEY_SET_VALUE);
    if (hKey)
    {
        FILETIME ft = {0};
        GetSystemTimeAsFileTime(&ft);
        RegSetValueEx(hKey, c_szLastSync, 0, REG_BINARY, (LPBYTE)&ft, sizeof(ft));
        RegCloseKey(hKey);
    }
}


DWORD
CCscUpdate::GetLastSyncTime(LPCTSTR pszShareName, LPFILETIME pft)
{
    DWORD dwResult = ERROR_PATH_NOT_FOUND;
    HKEY hKey = NULL;

    hKey = m_ShareLog.OpenKey(pszShareName, KEY_QUERY_VALUE);
    if (hKey)
    {
        DWORD dwSize = sizeof(*pft);
        dwResult = RegQueryValueEx(hKey, c_szLastSync, NULL, NULL, (LPBYTE)pft, &dwSize);
        RegCloseKey(hKey);
    }
    return dwResult;
}


void
CCscUpdate::SyncThreadCompleted(PSYNCTHREADDATA pSyncData)
{
    int iThread;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::SyncThreadCompleted");
    TraceAssert(NULL != pSyncData);
    TraceAssert(NULL != m_hSyncThreads);

    EnterCriticalSection(&m_csThreadList);

    iThread = DPA_GetPtrIndex(m_hSyncThreads, pSyncData);
    TraceAssert(-1 != iThread);

    DPA_DeletePtr(m_hSyncThreads, iThread);
    CloseHandle(pSyncData->hThread);
    pSyncData->hThread = NULL;

    iThread = DPA_GetPtrCount(m_hSyncThreads);

    LeaveCriticalSection(&m_csThreadList);

    if (0 == iThread)
    {
        SyncCompleted();
    }

    TraceLeaveVoid();
}


void
CCscUpdate::SyncCompleted(void)
{

    if ((m_dwSyncFlags & CSC_SYNC_RECONNECT) &&
        !(m_dwSyncFlags & CSC_SYNC_CANCELLED))
    {
        m_dwSyncFlags &= ~CSC_SYNC_RECONNECT;
        ReconnectServers(&m_ReconnectList, FALSE, FALSE);
    }

    if (NULL != m_hgcSyncInProgress)
    {
        // We're not syncing so reset the global event
        SHGlobalCounterDecrement(m_hgcSyncInProgress);
        SHGlobalCounterDestroy(m_hgcSyncInProgress);
        m_hgcSyncInProgress = NULL;
    }

    if (m_dwSyncFlags & CSC_SYNC_NOTIFY_SYSTRAY)
    {
        // Notify systray that we're done
        PostToSystray(CSCWM_DONESYNCING, 0, 0);
        m_dwSyncFlags &= ~CSC_SYNC_NOTIFY_SYSTRAY;
    }

    // Notify SyncMgr that the sync is done
    if (NULL != m_pSyncMgrCB)
    {
        m_pSyncMgrCB->SynchronizeCompleted(S_OK);
    }

    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, c_szSyncCompleteEvent);
    if (NULL != hEvent)
    {
        //
        // Let anyone interested know that the sync is complete.
        //
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}


UINT
GetErrorFormat(DWORD dwErr, BOOL bMerging = FALSE)
{
    UINT idString = 0;

    // These are all just initial guesses.  Not sure
    // which error codes we'll get from CSC.

    switch (dwErr)
    {
    case ERROR_DISK_FULL:
        // "The server disk is full."
        // "The local disk is full."
        idString = bMerging ? IDS_SERVER_FULL_ERROR : IDS_LOCAL_DISK_FULL_ERROR;
        break;

    case ERROR_LOCK_VIOLATION:
    case ERROR_SHARING_VIOLATION:
    case ERROR_OPEN_FILES:
    case ERROR_ACTIVE_CONNECTIONS:
    case ERROR_DEVICE_IN_USE:
        // "'%1' is in use on %2"
        idString = IDS_FILE_OPEN_ERROR;
        break;

    case ERROR_BAD_NETPATH:
    case ERROR_DEV_NOT_EXIST:
    case ERROR_NETNAME_DELETED:
    case ERROR_BAD_NET_NAME:
    case ERROR_SHARING_PAUSED:
    case ERROR_REQ_NOT_ACCEP:
    case ERROR_REDIR_PAUSED:
    case ERROR_BAD_DEVICE:
    case ERROR_CONNECTION_UNAVAIL:
    case ERROR_NO_NET_OR_BAD_PATH:
    case ERROR_NO_NETWORK:
    case ERROR_CONNECTION_REFUSED:
    case ERROR_GRACEFUL_DISCONNECT:
    case ERROR_NETWORK_UNREACHABLE:
    case ERROR_HOST_UNREACHABLE:
    case ERROR_PROTOCOL_UNREACHABLE:
    case ERROR_PORT_UNREACHABLE:
    case ERROR_LOGON_FAILURE:
        // "Unable to connect to '%1.'  %2"
        idString = IDS_SHARE_CONNECT_ERROR;
        break;

    case ERROR_OPEN_FAILED:
    case ERROR_UNEXP_NET_ERR:
    case ERROR_NETWORK_BUSY:
    case ERROR_BAD_NET_RESP:
        // "Unable to access '%1' on %2.  %3"
        idString = IDS_NET_ERROR;
        break;

    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        // "Access to '%1' is denied on %2"
        idString = IDS_ACCESS_ERROR;
        break;

    case ERROR_BAD_FORMAT:
        // "The Offline Files cache is corrupt.  Restart the computer to correct the cache."
        idString = IDS_CACHE_CORRUPT;
        break;

    default:
        // "Error accessing '%1' on %2.  %3"
        idString = IDS_UNKNOWN_SYNC_ERROR;
        break;
    }

    return idString;
}


HRESULT
CCscUpdate::LogError(REFSYNCMGRITEMID rItemID,
                     LPCTSTR pszText,
                     DWORD dwLogLevel,
                     REFSYNCMGRERRORID ErrorID)
{
    HRESULT hr;
    SYNCMGRLOGERRORINFO slei;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::LogError");

    if (NULL == m_pSyncMgrCB)
        TraceLeaveResult(E_UNEXPECTED);

    slei.cbSize = sizeof(slei);
    slei.mask   = SYNCMGRLOGERROR_ITEMID | SYNCMGRLOGERROR_ERRORID;
    slei.ItemID = rItemID;
    slei.ErrorID = ErrorID;

    // if we have a jumptext associated with this item then
    // set the enable jumptext flag
    if (ErrorID != GUID_NULL)
    {
        slei.mask |= SYNCMGRLOGERROR_ERRORFLAGS;
        slei.dwSyncMgrErrorFlags = SYNCMGRERRORFLAG_ENABLEJUMPTEXT;
    }

    Trace((pszText));
    hr = m_pSyncMgrCB->LogError(dwLogLevel, pszText, &slei);

    TraceLeaveResult(hr);
}

DWORD
CCscUpdate::LogError(REFSYNCMGRITEMID rItemID,
                     DWORD dwLogLevel,
                     UINT nFormatID,
                     ...)
{
    LPTSTR pszError = NULL;
    va_list args;
    va_start(args, nFormatID);
    if (vFormatStringID(&pszError, g_hInstance, nFormatID, &args))
    {
        LogError(rItemID, pszError, dwLogLevel);
        LocalFree(pszError);
    }
    va_end(args);
    return 0;
}

void _CopyParentPathForDisplay(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc)
{
    ASSERT(pszDest != NULL && cchDest != 0);
    *pszDest = TEXT('\0');
    if (pszSrc)
    {
        StringCchCopy(pszDest, cchDest, pszSrc);
        PathRemoveFileSpec(pszDest);
    }
    if (TEXT('\0') == *pszDest)
    {
        StringCchCopy(pszDest, cchDest, TEXT("\\"));
    }
}

DWORD
CCscUpdate::LogError(REFSYNCMGRITEMID rItemID,
                     UINT nFormatID,
                     LPCTSTR pszName,
                     DWORD dwErr,
                     DWORD dwLogLevel)
{
    //
    // Break the filename into "file" and "path" components
    //
    TCHAR szPath[MAX_PATH] = TEXT("\\");
    _CopyParentPathForDisplay(szPath, ARRAYSIZE(szPath), pszName);

    //
    // Get the system error text and format the error
    //
    LPTSTR pszErr = GetErrorText(dwErr);
    LogError(rItemID,
             dwLogLevel,
             nFormatID,
             PathFindFileName(pszName),
             szPath,
             pszErr);
    LocalFreeString(&pszErr);

    return 0;
}


BOOL
MakeDriveLetterPath(LPCTSTR pszUNC,
                    LPCTSTR pszShare,
                    LPCTSTR pszDrive,
                    LPTSTR *ppszResult)
{
    BOOL bResult = FALSE;
    ULONG cchShare;

    if (!pszUNC || !pszShare || !ppszResult)
        return FALSE;

    *ppszResult = NULL;

    cchShare = lstrlen(pszShare);

    // If the path is on the share, use the drive letter instead
    if (pszDrive && *pszDrive &&
        0 == StrCmpNI(pszUNC, pszShare, cchShare))
    {
        // We now know that pszUNC is at least as long as pszShare, since
        // they are identical up to that point.  But we need to avoid this:
        //   pszShare = \\server\share
        //   pszUNC   = \\server\share2   <-- not a match
        if (pszUNC[cchShare] == TEXT('\0') || pszUNC[cchShare] == TEXT('\\'))
        {
            *ppszResult = (LPTSTR)LocalAlloc(LPTR, MAX(StringByteSize(pszUNC), MAX_PATH_BYTES));
            if (*ppszResult)
            {
                if (PathCombine(*ppszResult, pszDrive, pszUNC + cchShare))
                {
                    bResult = TRUE;
                }
                else
                {
                    LocalFreeString(ppszResult);
                }
            }
        }
    }
    return bResult;
}


DWORD
CCscUpdate::CopyLocalFileWithDriveMapping(LPCTSTR pszSrc,
                                          LPCTSTR pszDst,
                                          LPCTSTR pszShare,
                                          LPCTSTR pszDrive,
                                          BOOL    bDirectory)
{
    DWORD dwErr = NOERROR;
    LPTSTR szDst = NULL;

    if (!pszSrc || !pszDst || !pszShare)
        return ERROR_INVALID_PARAMETER;

    // If the destination is on the share, use the drive letter instead
    if (MakeDriveLetterPath(pszDst, pszShare, pszDrive, &szDst))
        pszDst = szDst;

    if (bDirectory)
    {
        // We don't need to copy the directory contents here, just create
        // the tree structure on the server.
        dwErr = SHCreateDirectory(NULL, pszDst);
        if (ERROR_ALREADY_EXISTS == dwErr)
            dwErr = NOERROR;
    }
    else
    {
        LPTSTR pszTmpName = NULL;

        if (CSCCopyReplica(pszSrc, &pszTmpName))
        {
            if (!MoveFileEx(pszTmpName,
                            pszDst,
                            MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))
            {
                dwErr = GetLastError();

                if (ERROR_PATH_NOT_FOUND == dwErr)
                {
                    // The parent directory doesn't exist, create it now.
                    TCHAR szParent[MAX_PATH];
                    if (SUCCEEDED(StringCchCopy(szParent, ARRAYSIZE(szParent), pszDst))
                        && PathRemoveFileSpec(szParent))
                    {
                        dwErr = SHCreateDirectory(NULL, szParent);

                        // If that worked, retry the original operation.
                        if (NOERROR == dwErr)
                            dwErr = CopyLocalFileWithDriveMapping(pszSrc, pszDst, pszShare, NULL, bDirectory);
                    }
                }
            }

            DeleteFile(pszTmpName);
            LocalFree(pszTmpName);
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    LocalFreeString(&szDst);

    return dwErr;
}


BOOL
HandleConflictLocally(PSYNCTHREADDATA   pSyncData,
                      LPCTSTR           pszPath,
                      DWORD             dwCscStatus,
                      DWORD             dwLocalAttr,
                      DWORD             dwRemoteAttr = 0)
{
    BOOL bResult = FALSE;
    LPTSTR szParent = NULL;

    // If it's super-hidden or not modified locally, we can always
    // handle the conflict locally.
    if (!(dwCscStatus & CSC_LOCALLY_MODIFIED) || IsHiddenSystem(dwLocalAttr) || IsHiddenSystem(dwRemoteAttr))
        return TRUE;

    // If we're dealing with 2 folders, the worst that happens is that the
    // underlying files/folders get merged.
    if ((FILE_ATTRIBUTE_DIRECTORY & dwLocalAttr) && (FILE_ATTRIBUTE_DIRECTORY & dwRemoteAttr))
        return TRUE;

    //
    // Next, check whether the parent path is super-hidden.
    //
    // For example, recycle bin makes super-hidden folders and puts
    // metadata files in them.
    //
    // Do this on the server, since CSC has exclusive access to the database
    // while merging, causing GetFileAttributes to fail with Access Denied.
    //
    //
    // Do this on the server, since CSC has exclusive access to the database
    // while merging, causing GetFileAttributes to fail with Access Denied.
    //
    if (MakeDriveLetterPath(pszPath, pSyncData->pszShareName, pSyncData->szDrive, &szParent))
    {
        //
        // Don't check attributes at the root, just stop.
        // WinSE 16781.
        //
        for(PathRemoveFileSpec(szParent); !PathIsRoot(szParent); PathRemoveFileSpec(szParent))
        {
            dwRemoteAttr = GetFileAttributes(szParent);

            if ((DWORD)-1 == dwRemoteAttr)
            {
                // Path doesn't exist, access denied, etc.
                break;
            }

            if (IsHiddenSystem(dwRemoteAttr))
            {
                bResult = TRUE;
                break;
            }
        }
    }

    LocalFreeString(&szParent);

    return bResult;
}

DWORD
CCscUpdate::HandleFileConflict(PSYNCTHREADDATA     pSyncData,
                               LPCTSTR             pszName,
                               DWORD               dwStatus,
                               DWORD               dwHintFlags,
                               LPWIN32_FIND_DATA   pFind32)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    DWORD dwErr = NOERROR;
    int nErrorResolution = RFC_KEEPBOTH;
    LPTSTR pszNewName = NULL;
    LPTSTR szFullPath = NULL;
    BOOL bApplyToAll = FALSE;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::HandleFileConflict");
    Trace((TEXT("File conflict: %s"), pszName));
    TraceAssert(pSyncData->dwSyncStatus & SDS_SYNC_OUT);

    szFullPath = (LPTSTR)LocalAlloc(LPTR, MAX_PATH_BYTES);
    if (!szFullPath)
    {
        dwErr = ERROR_OUTOFMEMORY;
        ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "LocalAlloc failed");
    }

    HANDLE hFind;
    WIN32_FIND_DATA fdRemote;

    if (!PathCombine(szFullPath, pSyncData->szDrive, pszName + lstrlen(pSyncData->pszShareName)))
    {
        dwErr = ERROR_FILENAME_EXCED_RANGE;
        ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Full path is too long");
    }

    hFind = FindFirstFile(szFullPath, &fdRemote);

    // Does the net version still exist?
    if (hFind == INVALID_HANDLE_VALUE)
        ExitGracefully(dwResult, HandleDeleteConflict(pSyncData, pszName, dwStatus, dwHintFlags, pFind32), "Net file deleted");

    // Still exists, continue
    FindClose(hFind);

    // If only the attributes or file times were modified locally,
    // or if the file is hidden+system, keep the server copy and
    // don't bother the user.  (e.g. desktop.ini)
    if (HandleConflictLocally(pSyncData, pszName, dwStatus, pFind32->dwFileAttributes, fdRemote.dwFileAttributes))
    {
        ExitGracefully(dwResult, CSCPROC_RETURN_FORCE_INWARD, "Ignoring conflict");
    }
    else if (IsSilentFolder(pszName))
    {
        // It's in a per-user shell special folder. Last writer wins.
        if (CompareFileTime(&pFind32->ftLastWriteTime, &fdRemote.ftLastWriteTime) < 0)
        {
            ExitGracefully(dwResult, CSCPROC_RETURN_FORCE_INWARD, "Handling special folder conflict - server copy wins");
        }
        else
        {
            ExitGracefully(dwResult, CSCPROC_RETURN_FORCE_OUTWARD, "Handling special folder conflict - local copy wins");
        }
    }

    dwErr = GetNewVersionName(pszName,
                              pSyncData->pszShareName,
                              pSyncData->szDrive,
                              &pszNewName);
    if (NOERROR != dwErr)
    {
        ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "GetNewVersionName failed");
    }

    switch (SDS_SYNC_FILE_CONFLICT_MASK & pSyncData->dwSyncStatus)
    {
    case 0:
        if (CSC_SYNC_MAYBOTHERUSER & m_dwSyncFlags)
        {
            nErrorResolution = ShowConflictDialog(m_hwndDlgParent,
                                                  pszName,
                                                  pszNewName,
                                                  pSyncData->pszShareName,
                                                  pSyncData->szDrive,
                                                  pFind32,
                                                  &fdRemote);
            if (RFC_APPLY_TO_ALL & nErrorResolution)
            {
                bApplyToAll = TRUE;
                nErrorResolution &= ~RFC_APPLY_TO_ALL;
            }
        }
        break;

    case SDS_SYNC_CONFLICT_KEEPLOCAL:
        nErrorResolution = RFC_KEEPLOCAL;
        break;

    case SDS_SYNC_CONFLICT_KEEPNET:
        nErrorResolution = RFC_KEEPNETWORK;
        break;

    case SDS_SYNC_CONFLICT_KEEPBOTH:
        nErrorResolution = RFC_KEEPBOTH;
        break;
    }

    switch (nErrorResolution)
    {
    default:
    case RFC_KEEPBOTH:
        if (bApplyToAll)
            pSyncData->dwSyncStatus |= SDS_SYNC_CONFLICT_KEEPBOTH;
        if (SUCCEEDED(StringCchCopy(szFullPath, MAX_PATH, pszName))
            && PathRemoveFileSpec(szFullPath))
        {
            if (FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes)
            {
                // Rename the local version in the cache and merge again.
                if (FAILED(StringCchCopy(pFind32->cFileName, ARRAYSIZE(pFind32->cFileName), pszNewName)))
                {
                    dwErr = ERROR_FILENAME_EXCED_RANGE;
                    ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "CSCDoLocalRenameEx failed");
                }
                if (!CSCDoLocalRenameEx(pszName, szFullPath, pFind32, TRUE, TRUE))
                {
                    dwErr = GetLastError();
                    ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "CSCDoLocalRenameEx failed");
                }
                // Because CSCDoLocalRenameEx and CSCMergeShare are separate operations,
                // we have to abort the current merge operation and start over.
                // Otherwise, the current merge operation fails due to the "left
                // hand not knowing what the right hande is doing".
                Trace((TEXT("Restarting merge on: %s"), pSyncData->pszShareName));
                pSyncData->dwSyncStatus |= SDS_SYNC_RESTART_MERGE;
                dwResult = CSCPROC_RETURN_ABORT;
            }
            else
            {
                // Note that CSCDoLocalRenameEx would work for files also, but we
                // prefer to avoid restarting CSCMergeShare so do these ourselves.
                if (!PathAppend(szFullPath, pszNewName))
                {
                    dwErr = ERROR_FILENAME_EXCED_RANGE;
                    ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Full path is too long");
                }
                dwErr = CopyLocalFileWithDriveMapping(pszName,
                                                      szFullPath,
                                                      pSyncData->pszShareName,
                                                      pSyncData->szDrive);
                if (NOERROR != dwErr)
                {
                    ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "CopyLocalFileWithDriveMapping failed");
                }

                // If the original file was pinned, we want to pin the copy also.
                // Unfortunately, we can't reliably pin during a merge, so we have
                // to remember these in a list and pin them later.
                if (dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN))
                {
                    if (!m_pConflictPinList)
                        m_pConflictPinList = new CscFilenameList;
                    if (m_pConflictPinList)
                    {
                        m_pConflictPinList->AddFile(szFullPath,
                                                    !!(pFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));
                    }
                }

                // Tell CSCMergeShare to copy the server copy to the cache
                // (with the old name).  This clears the dirty cache.
                dwResult = CSCPROC_RETURN_FORCE_INWARD;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_NAME;
            ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Invalid path");
        }
        break;

    case RFC_KEEPNETWORK:
        // Tell CSCMergeShare to copy the server copy to the cache
        dwResult = CSCPROC_RETURN_FORCE_INWARD;
        if (bApplyToAll)
            pSyncData->dwSyncStatus |= SDS_SYNC_CONFLICT_KEEPNET;
        break;

    case RFC_KEEPLOCAL:
        // Tell CSCMergeShare to push the local copy to the server
        dwResult = CSCPROC_RETURN_FORCE_OUTWARD;
        if (bApplyToAll)
            pSyncData->dwSyncStatus |= SDS_SYNC_CONFLICT_KEEPLOCAL;
        break;

    case RFC_CANCEL:
        TraceMsg("HandleFileConflict: Cancelling sync - user bailed");
        SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);
        dwResult = CSCPROC_RETURN_ABORT;
        break;
    }

exit_gracefully:

    if (CSCPROC_RETURN_FORCE_INWARD == dwResult)
    {
        // CSCMergeShare truncates (makes sparse) the
        // file if we return this.  We'd like to fill
        // it during this sync.
        pSyncData->cFilesToSync++;
        pSyncData->dwSyncStatus |= SDS_SYNC_FORCE_INWARD;
    }

    if (NOERROR != dwErr)
    {
        pszName += lstrlen(pSyncData->pszShareName);
        if (*pszName == TEXT('\\'))
            pszName++;
        LogError(pSyncData->ItemID,
                 IDS_NAME_CONFLICT_ERROR,
                 pszName,
                 dwErr);
        pSyncData->dwSyncStatus |= SDS_SYNC_ERROR;
    }

    LocalFreeString(&szFullPath);
    LocalFreeString(&pszNewName);

    TraceLeaveResult(dwResult);
}


// Returns values for the Resolve Delete Conflict dialog
#define RDC_CANCEL      0x00
#define RDC_DELETE      0x01
#define RDC_RESTORE     0x02
#define RDC_APPLY_ALL   0x04
#define RDC_DELETE_ALL  (RDC_APPLY_ALL | RDC_DELETE)
#define RDC_RESTORE_ALL (RDC_APPLY_ALL | RDC_RESTORE)

TCHAR const c_szDeleteSelection[]   = TEXT("DeleteConflictSelection");

INT_PTR CALLBACK
DeleteConflictProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nResult;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szShare[MAX_PATH];
            LPCTSTR pszPath = (LPCTSTR)lParam;
            LPTSTR pszT = NULL;

            szShare[0] = TEXT('\0');
            StringCchCopy(szShare, ARRAYSIZE(szShare), pszPath);
            PathStripToRoot(szShare);

            // Format the file name
            PathSetDlgItemPath(hDlg, IDC_FILENAME, pszPath);

            // Build the "Do this for all on <this share>" string
            FormatStringID(&pszT, g_hInstance, IDS_FMT_DELETE_APPLY_ALL, szShare);
            if (pszT)
            {
                SetDlgItemText(hDlg, IDC_APPLY_TO_ALL, pszT);
                LocalFreeString(&pszT);
            }
            // else default text is OK (no share name)

            // Select whatever the user chose last time, default is "restore"
            DWORD dwPrevSelection = RDC_RESTORE;
            DWORD dwType;
            DWORD cbData = sizeof(dwPrevSelection);
            SHGetValue(HKEY_CURRENT_USER,
                       c_szCSCKey,
                       c_szDeleteSelection,
                       &dwType,
                       &dwPrevSelection,
                       &cbData);
            dwPrevSelection = (RDC_DELETE == dwPrevSelection ? IDC_DELETE_LOCAL : IDC_KEEP_LOCAL);
            CheckRadioButton(hDlg, IDC_KEEP_LOCAL, IDC_DELETE_LOCAL, dwPrevSelection);

            // Get the file-type icon
            pszT = PathFindExtension(pszPath);
            if (pszT)
            {
                SHFILEINFO sfi = {0};
                SHGetFileInfo(pszT, 0, &sfi, sizeof(sfi), SHGFI_ICON);
                if (sfi.hIcon)
                {
                    SendDlgItemMessage(hDlg,
                                       IDC_DLGTYPEICON,
                                       STM_SETICON,
                                       (WPARAM)sfi.hIcon,
                                       0L);
                }
            }
        }
        return TRUE;

    case WM_COMMAND:
        nResult = -1;
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            nResult = RDC_CANCEL;
            break;

        case IDOK:
            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELETE_LOCAL))
                nResult = RDC_DELETE;
            else
                nResult = RDC_RESTORE;
            // Remember the selection for next time
            SHSetValue(HKEY_CURRENT_USER,
                       c_szCSCKey,
                       c_szDeleteSelection,
                       REG_DWORD,
                       &nResult,
                       sizeof(nResult));
            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_APPLY_TO_ALL))
                nResult |= RDC_APPLY_ALL;
            break;
        }
        if (-1 != nResult)
        {
            EndDialog(hDlg, nResult);
            return TRUE;
        }
        break;
    }
    return FALSE;
}


BOOL CALLBACK
ConflictPurgeCallback(LPCWSTR /*pszFile*/, LPARAM lParam)
{
    PSYNCTHREADDATA pSyncData = (PSYNCTHREADDATA)lParam;
    return !(SDS_SYNC_CANCELLED & pSyncData->dwSyncStatus);
}


DWORD
CCscUpdate::HandleDeleteConflict(PSYNCTHREADDATA    pSyncData,
                                 LPCTSTR            pszName,
                                 DWORD              dwStatus,
                                 DWORD              dwHintFlags,
                                 LPWIN32_FIND_DATA  pFind32)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    int nErrorResolution = RDC_DELETE;  // default action
    BOOL bDirectory = (FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes);

    TraceEnter(TRACE_UPDATE, "CCscUpdate::HandleDeleteConflict");
    Trace((TEXT("Net file deleted: %s"), pszName));

    //
    // We already know that the net file was deleted, or HandleDeleteConflict
    // wouldn't be called.  If the local copy was also deleted, then there
    // isn't really a conflict and we can continue without prompting.
    //
    // Handle the conflict silently if only attributes changed or it's super-hidden.
    //
    // Finally, if the file lives in certain special folder locations,
    // such as AppData, handle the conflict silently.
    //
    // If we get past all that, ask the user what to do, but only bother
    // the user as a last resort.
    //
    if ( !(dwStatus & FLAG_CSC_COPY_STATUS_LOCALLY_DELETED)
         && !HandleConflictLocally(pSyncData, pszName, dwStatus, pFind32->dwFileAttributes)
         && !IsSilentFolder(pszName)
        )
    {
        // The file is either pinned or modified locally, so
        // default action is now "restore".
        nErrorResolution = RDC_RESTORE;

        switch (SDS_SYNC_DELETE_CONFLICT_MASK & pSyncData->dwSyncStatus)
        {
        case 0:
            if (CSC_SYNC_MAYBOTHERUSER & m_dwSyncFlags)
            {
                int idDialog = (bDirectory ? IDD_FOLDER_CONFLICT_DELETE : IDD_FILE_CONFLICT_DELETE);
                nErrorResolution = (int)DialogBoxParam(g_hInstance,
                                                       MAKEINTRESOURCE(idDialog),
                                                       m_hwndDlgParent,
                                                       DeleteConflictProc,
                                                       (LPARAM)pszName);
                if (RDC_DELETE_ALL == nErrorResolution)
                {
                    pSyncData->dwSyncStatus |= SDS_SYNC_DELETE_DELETE;
                    nErrorResolution = RDC_DELETE;
                }
                else if (RDC_RESTORE_ALL == nErrorResolution)
                {
                    pSyncData->dwSyncStatus |= SDS_SYNC_DELETE_RESTORE;
                    nErrorResolution = RDC_RESTORE;
                }
            }
            break;

        case SDS_SYNC_DELETE_DELETE:
            nErrorResolution = RDC_DELETE;
            break;

        case SDS_SYNC_DELETE_RESTORE:
            nErrorResolution = RDC_RESTORE;
            break;
        }
    }

    switch (nErrorResolution)
    {
    default:
    case RDC_RESTORE:
        Trace((TEXT("HandleDeleteConflict: restoring %s"), pszName));
        // Tell CSCMergeShare to push the local copy to the server
        dwResult = CSCPROC_RETURN_FORCE_OUTWARD;
        break;

    case RDC_DELETE:
        Trace((TEXT("HandleDeleteConflict: deleting %s"), pszName));
        if (bDirectory)
        {
            // Deep delete
            CSCUIRemoveFolderFromCache(pszName, 0, ConflictPurgeCallback, (LPARAM)pSyncData);
        }
        else
        {
            if (ERROR_SUCCESS == CscDelete(pszName))
            {
                ShellChangeNotify(pszName, pFind32, TRUE, SHCNE_DELETE);
            }
        }
        dwResult = CSCPROC_RETURN_SKIP;
        break;

    case RDC_CANCEL:
        TraceMsg("HandleDeleteConflict: Cancelling sync - user bailed");
        SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);
        dwResult = CSCPROC_RETURN_ABORT;
        break;
    }

    TraceLeaveResult(dwResult);
}

DWORD
CCscUpdate::CscCallback(PSYNCTHREADDATA     pSyncData,
                        LPCTSTR             pszName,
                        DWORD               dwStatus,
                        DWORD               dwHintFlags,
                        DWORD               dwPinCount,
                        LPWIN32_FIND_DATA   pFind32,
                        DWORD               dwReason,
                        DWORD               dwParam1,
                        DWORD               dwParam2)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    SYNCMGRPROGRESSITEM spi = { sizeof(spi), 0 };

    TraceEnter(TRACE_UPDATE, "CCscUpdate::CscCallback");
    TraceAssert(pSyncData != NULL);
    TraceAssert(pSyncData->pThis == this);

    // Check for Cancel
    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
    {
        TraceMsg("Cancelling sync operation");
        TraceLeaveValue(CSCPROC_RETURN_ABORT);
    }

    switch (dwReason)
    {
    case CSCPROC_REASON_BEGIN:
        // First thing to do is determine if this is for the entire share
        // or an individual file in the share.
        if (!(pSyncData->dwSyncStatus & SDS_SYNC_STARTED))
        {
            // SHARE BEGIN
            pSyncData->dwSyncStatus |= SDS_SYNC_STARTED;

            TraceAssert(!lstrcmpi(pszName, pSyncData->pszShareName));
            Trace((TEXT("Share begin: %s"), pszName));

            if (pSyncData->dwSyncStatus & SDS_SYNC_OUT)
            {
                // Save the drive letter to use for net operations
                Trace((TEXT("Drive %s"), pFind32->cFileName));
                StringCchCopy(pSyncData->szDrive, ARRAYSIZE(pSyncData->szDrive), pFind32->cFileName);
            }
            else
            {
                pSyncData->szDrive[0] = TEXT('\0');
            }

            // Remember whether it's an autocache share or not
            switch (dwStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK)
            {
            case FLAG_CSC_SHARE_STATUS_AUTO_REINT:
            case FLAG_CSC_SHARE_STATUS_VDO:
                pSyncData->dwSyncStatus |= SDS_SYNC_AUTOCACHE;
                break;
            }
        }
        else
        {
            // FILE BEGIN
            BOOL bSkipFile = FALSE;

            TraceAssert(lstrlen(pszName) > lstrlen(pSyncData->pszShareName));

            if (!(pFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // If we're updating a file selection and this file
                // isn't part of the selection, skip it.
                if (m_pFileList && !m_pFileList->FileExists(pszName, false))
                {
                    bSkipFile = TRUE;
                }
                else if (!(pSyncData->dwSyncStatus & (SDS_SYNC_AUTOCACHE | SDS_SYNC_OUT)) &&
                         !(dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN)) &&
                         !IsSpecialFolder(pszName))
                {
                    // Skip autocached files when filling on a
                    // non-autocache share. Raid #341786
                    bSkipFile = TRUE;
                }
                else if (!(pSyncData->dwSyncStatus & CSC_SYNC_IGNORE_ACCESS))
                {
                    // dwReserved0 is the current user's access mask
                    // dwReserved1 is the Guest access mask
                    DWORD dwCurrentAccess = pFind32->dwReserved0 | pFind32->dwReserved1;
                    if (pSyncData->dwSyncStatus & SDS_SYNC_OUT)
                    {
                        //
                        // If the current user doesn't have sufficient access
                        // to merge offline changes, then don't bother trying.
                        // (It must be some other user's file.)
                        //

                        // Have the attributes changed offline?
                        if (FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED & dwStatus)
                        {
                            // Yes. Continue if the current user has
                            // write-attribute access.
                            bSkipFile = !(dwCurrentAccess & FILE_WRITE_ATTRIBUTES);
                        }

                        // Have the contents changed offline?
                        if (!bSkipFile &&
                            ((FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED
                              | FLAG_CSC_COPY_STATUS_LOCALLY_CREATED
                              | FLAG_CSC_COPY_STATUS_LOCALLY_DELETED) & dwStatus))
                        {
                            // Yes. Continue if the current user has
                            // write-data access.
                            bSkipFile = !(dwCurrentAccess & FILE_WRITE_DATA);
                        }
                    }
                    else
                    {
                        //
                        // We're filling. Continue if the current user has
                        // read-data access, otherwise skip.
                        //
                        bSkipFile = !(dwCurrentAccess & FILE_READ_DATA);
                    }
                }
            }
            else if (!(pSyncData->dwSyncStatus & SDS_SYNC_OUT))
            {
                // It's a directory and we're in CSCFillSparseFiles.
                //
                // Note that we never skip directories when merging (we may be
                // interested in a file further down the tree) although we
                // can skip directories when filling.

                // If it's not in the file selection, skip it.
                if (m_pFileList && !m_pFileList->FileExists(pszName, false))
                {
                    bSkipFile = TRUE;
                }
            }

            if (bSkipFile)
            {
                Trace((TEXT("Skipping: %s"), pszName));
                dwResult = CSCPROC_RETURN_SKIP;
                pSyncData->dwSyncStatus |= SDS_SYNC_FILE_SKIPPED;
                break;
            }

            Trace((TEXT("File begin: %s"), pszName));

            //
            // Since we sometimes don't skip directories, even when it turns
            // out they have nothing that the current user is interested in,
            // don't display directory names in SyncMgr.
            //
            // If we sync a file farther down the tree, we will display the
            // filename and the intervening directory names will be visible
            // at that time.
            //
            if (!(pFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // Tell SyncMgr what we're doing
                spi.mask = SYNCMGRPROGRESSITEM_STATUSTEXT;
                spi.lpcStatusText = pszName + lstrlen(pSyncData->pszShareName) + 1;
                NotifySyncMgr(pSyncData, &spi);
            }

            // dwParam1 is non-zero when there is a conflict, i.e. both the
            // local and remote versions of the file have been modified.
            if (dwParam1)
            {
                if (dwParam2)  // indicates server file deleted
                {
                    Trace((TEXT("Delete conflict: %d"), dwParam2));
                    dwResult = HandleDeleteConflict(pSyncData, pszName, dwStatus, dwHintFlags, pFind32);
                }
                else
                {
                    Trace((TEXT("Update conflict: %d"), dwParam1));
                    dwResult = HandleFileConflict(pSyncData, pszName, dwStatus, dwHintFlags, pFind32);
                }
            }
        }
        break;

    case CSCPROC_REASON_END:
        // dwParam2 == error code (winerror.h)
        if (3000 <= dwParam2 && dwParam2 <= 3200)
        {
            // Private error codes used in cscdll
            Trace((TEXT("CSC error: %d"), dwParam2));
            dwParam2 = NOERROR;
        }
        else if (ERROR_OPERATION_ABORTED == dwParam2)
        {
            // We returned CSCPROC_RETURN_ABORT for some reason.
            // Whatever it was, we already reported it.
            dwParam2 = NOERROR;
            dwResult = CSCPROC_RETURN_ABORT;
        }
        if (lstrlen(pszName) == lstrlen(pSyncData->pszShareName))
        {
            // SHARE END
            TraceAssert(!lstrcmpi(pszName, pSyncData->pszShareName));
            Trace((TEXT("Share end: %s"), pszName));

            pSyncData->dwSyncStatus &= ~SDS_SYNC_STARTED;
        }
        else
        {
            BOOL bUpdateProgress = FALSE;

            // FILE END
            if (!(pSyncData->dwSyncStatus & SDS_SYNC_FILE_SKIPPED))
            {
                Trace((TEXT("File end: %s"), pszName));

                bUpdateProgress = TRUE;

                // Special case errors
                switch (dwParam2)
                {
                case ERROR_ACCESS_DENIED:
                    if (FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes)
                    {
                        // 317751 directories are not per-user, so if a
                        // different user syncs, we can hit this.  Don't want
                        // to show an error message unless we are ignoring
                        // access (when the user explicitly selected something
                        // to pin/sync).
                        //
                        // 394362 BrianV hit this running as an admin, so don't
                        // show this error for admins either.
                        //
                        if (!(pSyncData->dwSyncStatus & CSC_SYNC_IGNORE_ACCESS))
                        {
                            TraceMsg("Suppressing ERROR_ACCESS_DENIED on folder");
                            dwParam2 = NOERROR;
                        }
                    }
                    break;

                case ERROR_GEN_FAILURE:
                    TraceMsg("Received ERROR_GEN_FAILURE from cscdll");
                    if (dwStatus & FLAG_CSC_COPY_STATUS_FILE_IN_USE)
                        dwParam2 = ERROR_OPEN_FILES;
                    break;

                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    // We either handle the error here or the user is
                    // prompted, so no need for another error message.
                    dwParam2 = NOERROR;
                    // If this is an autocache file and has not been modified
                    // offline, nuke it now.  Otherwise, prompt for action.
                    if (CSCPROC_RETURN_FORCE_OUTWARD == HandleDeleteConflict(pSyncData,
                                                                             pszName,
                                                                             dwStatus,
                                                                             dwHintFlags,
                                                                             pFind32))
                    {
                        dwParam2 = CopyLocalFileWithDriveMapping(pszName,
                                                                 pszName,
                                                                 pSyncData->pszShareName,
                                                                 pSyncData->szDrive,
                                                                 (FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes));
                    }
                    break;

                case ERROR_DISK_FULL:
                    // There's no point continuing
                    dwResult = CSCPROC_RETURN_ABORT;
                    break;

                default:
                    // nothing
                    break;
                }
            }
            else
            {
                pSyncData->dwSyncStatus &= ~SDS_SYNC_FILE_SKIPPED;
                dwParam2 = NOERROR;

                // If doing full sync, then we count progress for skipped
                // files as well. Not true for quick fill or merge.
                if (pSyncData->dwSyncStatus & SDS_SYNC_IN_FULL)
                    bUpdateProgress = TRUE;
            }

            // Update progress in SyncMgr
            if (bUpdateProgress)
            {
                pSyncData->cFilesDone++;

                spi.mask = SYNCMGRPROGRESSITEM_PROGVALUE;
                spi.iProgValue = min(pSyncData->cFilesDone, pSyncData->cFilesToSync - 1);
                Trace((TEXT("%d of %d files done"), spi.iProgValue, pSyncData->cFilesToSync));
                NotifySyncMgr(pSyncData, &spi);
            }
        }
        if (dwParam2 != NOERROR)
        {
            UINT idsError = GetErrorFormat(dwParam2, boolify(pSyncData->dwSyncStatus & SDS_SYNC_OUT));
            if (IDS_SHARE_CONNECT_ERROR == idsError)
            {
                LPTSTR pszErr = GetErrorText(dwParam2);
                //
                // Special-case the "can't connect to share" error.
                // Display only the share name in the error message
                // and abort the synchronization of this share.  
                //
                LogError(pSyncData->ItemID,
                         SYNCMGRLOGLEVEL_ERROR,
                         idsError,
                         pSyncData->pszShareName,
                         pszErr ? pszErr : TEXT(""));

                LocalFreeString(&pszErr);
                dwResult = CSCPROC_RETURN_ABORT;
            }
            else
            {
                LogError(pSyncData->ItemID,
                         idsError,
                         pszName,
                         dwParam2);
            }
            pSyncData->dwSyncStatus |= SDS_SYNC_ERROR;
        }
        break;
    }

    // Check for Cancel
    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
    {
        TraceMsg("Cancelling sync operation");
        dwResult = CSCPROC_RETURN_ABORT;
    }
    
    TraceLeaveValue(dwResult);
}


void
CCscUpdate::NotifySyncMgr(PSYNCTHREADDATA pSyncData, LPSYNCMGRPROGRESSITEM pspi)
{
    LPSYNCMGRSYNCHRONIZECALLBACK pSyncMgr = pSyncData->pThis->m_pSyncMgrCB;

    if (pSyncMgr)
    {
        HRESULT hr = pSyncMgr->Progress(pSyncData->ItemID, pspi);

        if (hr == S_SYNCMGR_CANCELITEM || hr == S_SYNCMGR_CANCELALL)
            pSyncData->dwSyncStatus |= SDS_SYNC_CANCELLED;
    }
}


DWORD WINAPI
CCscUpdate::_CscCallback(LPCTSTR             pszName,
                         DWORD               dwStatus,
                         DWORD               dwHintFlags,
                         DWORD               dwPinCount,
                         LPWIN32_FIND_DATA   pFind32,
                         DWORD               dwReason,
                         DWORD               dwParam1,
                         DWORD               dwParam2,
                         DWORD_PTR           dwContext)
{
    DWORD dwResult = CSCPROC_RETURN_ABORT;
    PSYNCTHREADDATA pSyncData = (PSYNCTHREADDATA)dwContext;

    if (pSyncData != NULL && pSyncData->pThis != NULL)
        dwResult = pSyncData->pThis->CscCallback(pSyncData,
                                                 pszName,
                                                 dwStatus,
                                                 dwHintFlags,
                                                 dwPinCount,
                                                 pFind32,
                                                 dwReason,
                                                 dwParam1,
                                                 dwParam2);
    return dwResult;
}


BOOL
CCscUpdate::PinLinkTarget(LPCTSTR pszName, PSYNCTHREADDATA pSyncData)
{
    BOOL bResult = FALSE;
    LPTSTR pszTarget = NULL;

    TraceEnter(TRACE_SHELLEX, "PinLinkTarget");

    GetLinkTarget(pszName, &pszTarget);
    if (pszTarget)
    {
        DWORD dwAttr = GetFileAttributes(pszTarget);
        if ((DWORD)-1 == dwAttr)
            ExitGracefully(bResult, FALSE, "Link target not found");

        TraceAssert(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY));

        // Check for EFS
        if ((FILE_ATTRIBUTE_ENCRYPTED & dwAttr) && SkipEFSPin(pSyncData, pszTarget))
            ExitGracefully(bResult, FALSE, "Skipping EFS link target");

        if (!(pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED))
        {
            HRESULT hr = m_NoPinList.IsPinAllowed(pszTarget);
            if (S_OK == hr)
            {
                if (CSCPinFile(pszTarget, pSyncData->dwPinHints, NULL, NULL, NULL))
                {
                    WIN32_FIND_DATA fd = {0};
                    fd.dwFileAttributes = dwAttr;
                    StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), PathFindFileName(pszTarget));

                    ShellChangeNotify(pszTarget, &fd, FALSE);

                    bResult = TRUE;

                    if ((FILE_ATTRIBUTE_ENCRYPTED & dwAttr) && !m_bCacheIsEncrypted)
                    {
                        LogError(pSyncData->ItemID,
                                 IDS_PIN_ENCRYPT_WARNING,
                                 pszTarget,
                                 NOERROR,
                                 SYNCMGRLOGLEVEL_WARNING);
                    }
                }
            }
            else if (S_FALSE == hr)
            {
                if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
                {
                    LogError(pSyncData->ItemID,
                             SYNCMGRLOGLEVEL_WARNING,
                             IDS_PIN_NOPINFOLDER_POLICY_WARNING,
                             pszTarget);
                }
                else
                {
                    LogError(pSyncData->ItemID,
                             IDS_PIN_NOPINFILE_POLICY_WARNING,
                             pszTarget,
                             NOERROR,
                             SYNCMGRLOGLEVEL_WARNING);
                }
            }
        }
    }

exit_gracefully:

    LocalFreeString(&pszTarget);
    TraceLeaveValue(bResult);
}


BOOL
CCscUpdate::ShouldPinRecurse(LPCTSTR pszName)
{
    //
    // NTRAID#NTBUG9-508029-2001/12/18-jeffreys
    //
    // If CSC_SYNC_PIN_RECURSE is set, the answer is always TRUE.  Otherwise,
    // if we're not pinning files (typically running the FrankAr code), we
    // automatically recurse on special folders.
    //
    return ((m_dwSyncFlags & CSC_SYNC_PIN_RECURSE) ||
            (!(m_dwSyncFlags & CSC_SYNC_PINFILES) && !CConfig::GetSingleton().NoAdminPinSpecialFolders() && IsSpecialFolder(pszName)));
}


DWORD WINAPI
CCscUpdate::_PinNewFilesW32Callback(LPCTSTR             pszName,
                                    ENUM_REASON         eReason,
                                    LPWIN32_FIND_DATA   pFind32,
                                    LPARAM              lpContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    PSYNCTHREADDATA pSyncData = (PSYNCTHREADDATA)lpContext;
    DWORD dwHintFlags = 0;
    DWORD dwErr = NOERROR;
    LPTSTR pszConnectionName = NULL;

    // This callback is used when enumerating a pinned folder looking
    // for new files on the server.  Since the parent folder is pinned,
    // any files in it that aren't pinned get pinned here.

    TraceEnter(TRACE_UPDATE, "CCscUpdate::_PinNewFilesW32Callback");
    TraceAssert(pSyncData != NULL);

    // Check for Cancel
    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
    {
        TraceMsg("Cancelling sync operation");
        TraceLeaveValue(CSCPROC_RETURN_ABORT);
    }

    // Always ignore folder_end and ignore folder_begin if we
    // aren't doing a recursive pin operation.
    if (eReason == ENUM_REASON_FOLDER_END ||
        (eReason == ENUM_REASON_FOLDER_BEGIN && !pSyncData->pThis->ShouldPinRecurse(pszName)))
    {
        TraceLeaveValue(CSCPROC_RETURN_SKIP);
    }

    if (eReason == ENUM_REASON_FOLDER_BEGIN)
    {
        DWORD dwShareStatus = 0;

        // Folders may be DFS junctions, so make sure it's cacheable.
        if (!ShareIsCacheable(pszName, FALSE, &pszConnectionName, &dwShareStatus))
        {
            ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Skipping no-cache folder");
        }
    }

    if (S_FALSE == pSyncData->pThis->m_NoPinList.IsPinAllowed(pszName))
    {
        if (FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes)
        {
            pSyncData->pThis->LogError(pSyncData->ItemID,
                                       SYNCMGRLOGLEVEL_WARNING,
                                       IDS_PIN_NOPINFOLDER_POLICY_WARNING,
                                       pszName);
        }
        else
        {
            pSyncData->pThis->LogError(pSyncData->ItemID,
                                       IDS_PIN_NOPINFILE_POLICY_WARNING,
                                       pszName,
                                       NOERROR,
                                       SYNCMGRLOGLEVEL_WARNING);
        }

        ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Skipping per no-pin policy");
    }

    // At this point, we either have 1) a file or 2) folder_begin + recurse,
    // so pin anything that isn't pinned.

    // Is this file already pinned?
    if (!CSCQueryFileStatus(pszName, NULL, NULL, &dwHintFlags))
        dwErr = GetLastError();

    if (ERROR_FILE_NOT_FOUND == dwErr ||
        (NOERROR == dwErr && !(dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN))))
    {
        // Check for EFS
        BOOL bIsEFSFile = (FILE_ATTRIBUTE_ENCRYPTED & pFind32->dwFileAttributes) &&
                            !(FILE_ATTRIBUTE_DIRECTORY & pFind32->dwFileAttributes);

        if (bIsEFSFile && pSyncData->pThis->SkipEFSPin(pSyncData, pszName))
            ExitGracefully(dwResult, CSCPROC_RETURN_SKIP, "Skipping EFS file");

        if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
            ExitGracefully(dwResult, CSCPROC_RETURN_ABORT, "Sync cancelled");

        // Pin it now.
        if (CSCPinFile(pszName, pSyncData->dwPinHints, NULL, NULL, NULL))
        {
            
            pSyncData->cFilesToSync++;
            ShellChangeNotify(pszName, pFind32, FALSE);

            if (bIsEFSFile && !pSyncData->pThis->m_bCacheIsEncrypted)
            {
                pSyncData->pThis->LogError(pSyncData->ItemID,
                                           IDS_PIN_ENCRYPT_WARNING,
                                           pszName,
                                           NOERROR,
                                           SYNCMGRLOGLEVEL_WARNING);
            }

            // If this is a link file, pin the target (if appropriate)
            LPTSTR pszExtn = PathFindExtension(pszName);
            if (pszExtn && !lstrcmpi(pszExtn, c_szLNK))
            {
                if (pSyncData->pThis->PinLinkTarget(pszName, pSyncData))
                    pSyncData->cFilesToSync++;
            }
        }
        else
        {
            DWORD dwError = GetLastError();
            UINT idsError = GetErrorFormat(dwError);
            if (IDS_SHARE_CONNECT_ERROR == idsError)
            {
                LPTSTR pszErr = GetErrorText(dwError);
                //
                // Special-case the "can't connect to share" error.
                // Display only the share name in the error message
                // and abort the pinning of this share.  
                //
                pSyncData->pThis->LogError(pSyncData->ItemID,
                                           SYNCMGRLOGLEVEL_ERROR,
                                           idsError,
                                           pSyncData->pszShareName,
                                           pszErr ? pszErr : TEXT(""));

                LocalFreeString(&pszErr);
                pSyncData->dwSyncStatus |= SDS_SYNC_CANCELLED;
            }
            else
            {
                DWORD dwSyncMgrLogLevel = SYNCMGRLOGLEVEL_ERROR;
                if (ERROR_INVALID_NAME == dwError)
                {
                    //
                    // File type is in the exclusion list.
                    // This is a warning, not an error.
                    //
                    dwSyncMgrLogLevel = SYNCMGRLOGLEVEL_WARNING;
                }
                pSyncData->pThis->LogError(pSyncData->ItemID,
                                           IDS_PIN_FILE_ERROR,
                                           pszName,
                                           dwError,
                                           dwSyncMgrLogLevel);
            }
            pSyncData->dwSyncStatus |= SDS_SYNC_ERROR;
        }

        LPTSTR pszScanMsg = NULL;
        SYNCMGRPROGRESSITEM spi;
        spi.cbSize = sizeof(spi);
        spi.mask = SYNCMGRPROGRESSITEM_STATUSTEXT;
        spi.lpcStatusText = L" ";

        // Skip the share name
        TraceAssert(PathIsPrefix(pSyncData->pszShareName, pszName));
        pszName += lstrlen(pSyncData->pszShareName);
        if (*pszName == TEXT('\\'))
            pszName++;

        TCHAR szPath[MAX_PATH] = TEXT("\\");
        _CopyParentPathForDisplay(szPath, ARRAYSIZE(szPath), pszName);

        // If we still have a name, build a string like
        // "scanning: dir\foo.txt" to display in SyncMgr
        if (FormatStringID(&pszScanMsg, g_hInstance, IDS_NEW_SCAN, PathFindFileName(pszName), szPath))
        {
            spi.lpcStatusText = pszScanMsg;
        }

        NotifySyncMgr(pSyncData, &spi);

        LocalFreeString(&pszScanMsg);
    }
    else if ((dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN)) &&
             (pSyncData->pThis->m_dwSyncFlags & CSC_SYNC_PINFILES))
    {
        // FLAG_CSC_HINT_PIN_USER being set implies that CSCQueryFileStatus
        // succeeded above.

        // The item was already pinned.  Save it in the undo exclusion list.
        if (!pSyncData->pUndoExclusionList)
            pSyncData->pUndoExclusionList = new CscFilenameList;

        if (pSyncData->pUndoExclusionList)
            pSyncData->pUndoExclusionList->AddFile(pszName);
    }

exit_gracefully:

    if (pszConnectionName)
    {
        WNetCancelConnection2(pszConnectionName, 0, FALSE);
        LocalFreeString(&pszConnectionName);
    }

    TraceLeaveValue(dwResult);
}


DWORD WINAPI
CCscUpdate::_PinNewFilesCSCCallback(LPCTSTR             pszName,
                                    ENUM_REASON         eReason,
                                    DWORD               /*dwStatus*/,
                                    DWORD               dwHintFlags,
                                    DWORD               /*dwPinCount*/,
                                    LPWIN32_FIND_DATA   /*pFind32*/,
                                    LPARAM              lpContext)
{
    PSYNCTHREADDATA pSyncData = (PSYNCTHREADDATA)lpContext;
    PCSCUPDATE pThis;

    // This callback is used when enumerating the CSC database looking
    // for pinned folders, with the intention of pinning new files
    // in those folders on the server.

    TraceEnter(TRACE_UPDATE, "CCscUpdate::_PinNewFilesCSCCallback");
    TraceAssert(pSyncData != NULL);
    TraceAssert(pSyncData->pThis != NULL);

    pThis = pSyncData->pThis;

    // Check for Cancel
    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
    {
        TraceMsg("Cancelling sync operation");
        TraceLeaveValue(CSCPROC_RETURN_ABORT);
    }

    // If this isn't a directory with the user hint flag, keep looking.
    if (eReason != ENUM_REASON_FOLDER_BEGIN ||
        !(dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN)))
    {
        TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
    }

    // If we have a file list and this directory isn't in the list,
    // continue without doing anything here.
    if (pSyncData->pThis->m_pFileList &&
        !pSyncData->pThis->m_pFileList->FileExists(pszName, false))
    {
        TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
    }

    // Ok, we've found a directory with the user hint flag set. Walk
    // this directory on the server, pinning any files that aren't pinned.
    pSyncData->dwPinHints = dwHintFlags;
    _Win32EnumFolder(pszName,
                     FALSE,
                     _PinNewFilesW32Callback,
                     (LPARAM)pSyncData);

    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}


DWORD WINAPI
CCscUpdate::_SyncThread(LPVOID pThreadData)
{
    PSYNCTHREADDATA pSyncData = (PSYNCTHREADDATA)pThreadData;
    PCSCUPDATE pThis;
    HRESULT hrComInit = E_FAIL;
    SYNCMGRPROGRESSITEM spi = {0};
    DWORD dwErr = NOERROR;
    CSCSHARESTATS shareStats;
    CSCGETSTATSINFO si = { SSEF_NONE,
                           SSUF_NONE,
                           false,      // No access info reqd (faster).
                           false };     
    ULONG cDirtyFiles = 0;
    ULONG cStaleFiles = 0;
    DWORD dwShareStatus = 0;
    BOOL bShareOnline = FALSE;
    DWORD dwConnectionSpeed = 0;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::_SyncThread");

    TraceAssert(pSyncData);
    TraceAssert(pSyncData->pThis);
    TraceAssert(pSyncData->pszShareName && *pSyncData->pszShareName);

    pThis = pSyncData->pThis;

    spi.cbSize = sizeof(spi);

    hrComInit = CoInitialize(NULL);

    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        ExitGracefully(dwErr, NOERROR, "Cancelling sync operation");

    // Figure out how many files need updating
    pSyncData->cFilesDone = 0;
    pSyncData->cFilesToSync = 0;
    _GetShareStatisticsForUser(pSyncData->pszShareName, &si, &shareStats);

    // Get share status
    CSCQueryFileStatus(pSyncData->pszShareName, &dwShareStatus, NULL, NULL);

    // The root of a special folder is pinned with a pin count, but
    // not the user-hint flag, so _GetShareStats doesn't count it.
    // We need to count this for some of the checks below.
    // (If the share is manual-cache, these look exactly like the 
    // Siemens scenario in 341786, but we want to sync them.)
    if (shareStats.cTotal && pThis->IsSpecialFolderShare(pSyncData->pszShareName))
    {
        shareStats.cPinned++;

        //
        // At logoff, we want to run the FrankAr code on all 
        // 'special' folder shares.
        // Customers expect folder redirection of special folders
        // to ensure all contents are cached.
        //
        if (pThis->m_dwSyncFlags & CSC_SYNC_LOGOFF)
        {
            pSyncData->dwSyncStatus |= SDS_SYNC_FORCE_INWARD;
        }
    }

    if (pThis->m_dwSyncFlags & CSC_SYNC_OUT)
    {
        cDirtyFiles = shareStats.cModified;

        //
        // Force the merge code if there are open files, so we are
        // sure to do the open file warning. The danger here is that we
        // don't warn because the share with open files has nothing dirty,
        // but we merge changes on another share and then transition online.
        // We don't want to transition online without warning about open files.
        //
        if (0 == cDirtyFiles)
        {
            if ((FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus) &&
                (FLAG_CSC_SHARE_STATUS_FILES_OPEN & dwShareStatus))
            {
                cDirtyFiles++;
            }
        }
    }

    if (pThis->m_dwSyncFlags & CSC_SYNC_IN_FULL)
    {
        // For full inward sync, always set cStaleFiles to at least 1 to force
        // a call to CSCFillSparseFiles.
        // Also, we get callbacks for each file and folder, even if they
        // are not sparse or stale, so go with cTotal here to make
        // the progress bar look right.
        cStaleFiles = max(shareStats.cTotal, 1);
    }
    else if (pThis->m_dwSyncFlags & CSC_SYNC_IN_QUICK)
    {
        cStaleFiles = shareStats.cSparse;

        // If we're pinning, then it's possible that nothing is sparse yet,
        // but we'll need to call CSCFillSparseFiles.
        if (pThis->m_dwSyncFlags & CSC_SYNC_PINFILES)
            pSyncData->dwSyncStatus |= SDS_SYNC_FORCE_INWARD;
    }

    if (dwShareStatus & FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP)
    {
        // Can't call CSCFillSparseFiles when disconnected (it just fails)
        cStaleFiles = 0;
    }
    else if ((dwShareStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_MANUAL_REINT
             && 0 == shareStats.cPinned
             && !(pThis->m_dwSyncFlags & CSC_SYNC_PINFILES))
    {
        // On a manual share, if nothing is pinned (and we aren't pinning)
        // then we prefer not to call CSCFillSparseFiles on the share.
        // Raid #341786
        Trace((TEXT("Manual cache share '%s' has only autocached files"), pSyncData->pszShareName));
        cStaleFiles = 0;
    }

    pSyncData->cFilesToSync = cDirtyFiles + cStaleFiles;

    //
    // At this point, if pSyncData->cFilesToSync is nonzero, then we are doing
    // a sync, and will be calling CSCBeginSynchronization to connect to the
    // share (with prompt for credentials if necessary).
    //
    // If SDS_SYNC_FORCE_INWARD is on, then we are pinning files.  We will only
    // call CSCFillSparseFiles is the server is in connected mode, and we will
    // only call CSCBeginSynchronization if pSyncData->cFilesToSync is nonzero
    // (to pin something, you must already have a connection to the share).
    //

    if (0 == pSyncData->cFilesToSync && !(pSyncData->dwSyncStatus & SDS_SYNC_FORCE_INWARD))
        ExitGracefully(dwErr, NOERROR, "Nothing to synchronize");

    // Tell SyncMgr how many files we're updating
    spi.mask = SYNCMGRPROGRESSITEM_STATUSTYPE
                | SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE;
    spi.dwStatusType = SYNCMGRSTATUS_UPDATING;
    spi.iProgValue = 0;
    spi.iMaxValue = pSyncData->cFilesToSync;
    Trace((TEXT("%d files to sync on %s"), spi.iMaxValue, pSyncData->pszShareName));
    NotifySyncMgr(pSyncData, &spi);

    if (pSyncData->cFilesToSync)
    {
        //
        // CSCBeginSynchronization makes a net connection to the share
        // using the "interactive" flag. This causes a credential popup
        // if the current user doesn't have access to the share.
        // Use the sync mutex to avoid multiple concurrent popups.
        //
        WaitForSingleObject(pThis->m_hSyncMutex, INFINITE);
        bShareOnline = CSCBeginSynchronization(pSyncData->pszShareName,
                                               &dwConnectionSpeed,
                                               &pSyncData->dwCscContext);
        ReleaseMutex(pThis->m_hSyncMutex);
    }

    if (pSyncData->cFilesToSync && !bShareOnline)
    {
        // The share isn't reachable, so there's no point in continuing.
        dwErr = GetLastError();

        if (ERROR_CANCELLED == dwErr)
        {
            // The user cancelled the credential popup
            pSyncData->dwSyncStatus |= SDS_SYNC_CANCELLED;
            ExitGracefully(dwErr, NOERROR, "User cancelled sync");
        }

        LPTSTR pszErr = GetErrorText(dwErr);
        pThis->LogError(pSyncData->ItemID,
                        SYNCMGRLOGLEVEL_ERROR,
                        IDS_SHARE_CONNECT_ERROR,
                        pSyncData->pszShareName,
                        pszErr);
        LocalFreeString(&pszErr);
        ExitGracefully(dwErr, dwErr, "Share not reachable");
    }

    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        ExitGracefully(dwErr, NOERROR, "Cancelling sync operation");

    // Note the time of this sync
    pThis->SetLastSyncTime(pSyncData->pszShareName);

    // Merge
    if (0 != cDirtyFiles)
    {
        dwErr = pThis->MergeShare(pSyncData);
        if (NOERROR != dwErr)
        {
            LPTSTR pszErr = GetErrorText(dwErr);
            pThis->LogError(pSyncData->ItemID,
                            SYNCMGRLOGLEVEL_ERROR,
                            IDS_MERGE_SHARE_ERROR,
                            pSyncData->pszShareName,
                            pszErr);
            LocalFreeString(&pszErr);
            ExitGracefully(dwErr, dwErr, "Aborting due to merge error");
        }
    }

    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        ExitGracefully(dwErr, NOERROR, "Cancelling sync operation");

    // Fill
    if (0 != cStaleFiles || (pSyncData->dwSyncStatus & SDS_SYNC_FORCE_INWARD))
    {
        dwErr = pThis->FillShare(pSyncData, shareStats.cPinned, dwConnectionSpeed);
    }

exit_gracefully:

    // If we called CSCBeginSynchronization and it succeeded,
    // we need to call CSCEndSynchronization.
    if (bShareOnline)
        CSCEndSynchronization(pSyncData->pszShareName, pSyncData->dwCscContext);

    // Tell SyncMgr that we're done (succeeded, failed, or stopped)
    spi.mask = SYNCMGRPROGRESSITEM_STATUSTYPE | SYNCMGRPROGRESSITEM_STATUSTEXT
        | SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE;
    spi.dwStatusType = SYNCMGRSTATUS_SUCCEEDED; // Assume success
    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        spi.dwStatusType = SYNCMGRSTATUS_STOPPED;
    if (NOERROR != dwErr || (pSyncData->dwSyncStatus & SDS_SYNC_ERROR))
        spi.dwStatusType = SYNCMGRSTATUS_FAILED;
    spi.lpcStatusText = L" ";
    spi.iProgValue = spi.iMaxValue = pSyncData->cFilesToSync; // This tells syncmgr that the item is done

    NotifySyncMgr(pSyncData, &spi);

    if ((pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        && (pThis->m_dwSyncFlags & CSC_SYNC_PINFILES))
    {
        // We cancelled a pin operation, roll back to the previous state
        CscUnpinFileList(pThis->m_pFileList,
                        (pThis->m_dwSyncFlags & CSC_SYNC_PIN_RECURSE),
                        (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus),
                        pSyncData->pszShareName,
                        _UndoProgress,
                        (LPARAM)pSyncData);
    }

    // Tell the Update Handler that this thread is exiting
    // This may use OLE to notify SyncMgr that the sync is done,
    // so do this before CoUninitialize.
    Trace((TEXT("%s finished"), pSyncData->pszShareName));
    pThis->SyncThreadCompleted(pSyncData);

    if (SUCCEEDED(hrComInit))
        CoUninitialize();

    delete pSyncData->pUndoExclusionList;
    LocalFree(pSyncData);

    // Release our ref on the object
    // (also release our ref on the DLL)
    pThis->Release();

    TraceLeave();
    FreeLibraryAndExitThread(g_hInstance, dwErr);
    return 0;
}

DWORD
CCscUpdate::MergeShare(PSYNCTHREADDATA pSyncData)
{
    DWORD dwErr = NOERROR;
    BOOL bMergeResult = TRUE;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::MergeShare");

    // CSCMergeShare fails if another thread (or process) is
    // currently merging.  This is because CSCMergeShare uses
    // a drive letter connection to the share to bypass CSC,
    // and we don't want to use up all of the drive letters.
    // So let's protect the call to CSCMergeShare with a mutex
    // (rather than dealing with failure and retrying, etc.)

    WaitForSingleObject(m_hSyncMutex, INFINITE);

    if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
        ExitGracefully(dwErr, NOERROR, "Merge cancelled");

    //
    // It would be nice to skip the open file warning if we knew
    // that the open files were on a "silent folder".  The best
    // we can do, though, is detect that the open files are on
    // the same share as a silent folder.  There's no guarantee
    // that the open files are not from a different folder on
    // the same share, so we have to show the warning.
    //
    //if (!IsSilentShare(pSyncData->pszShareName))
    {
        DWORD dwShareStatus = 0;
        CSCQueryFileStatus(pSyncData->pszShareName, &dwShareStatus, NULL, NULL);
        if (FLAG_CSC_SHARE_STATUS_FILES_OPEN & dwShareStatus)
        {
            if (CSC_SYNC_MAYBOTHERUSER & m_dwSyncFlags)
            {
                // Only show this warning once per sync (not per thread)
                if (!(CSC_SYNC_OFWARNINGDONE & m_dwSyncFlags))
                {
                    m_dwSyncFlags |= CSC_SYNC_OFWARNINGDONE;
                    //
                    // This dialog we're going to display can use one of 
                    // two templates.
                    //
                    // 1. Single user logged on.  Tell user to close all files.
                    //    Dialog provides [OK] and [Cancel] options.  User can
                    //    choose to continue or cancel.
                    //
                    // 2. Multiple users logged on.  Tell user that sync cannot
                    //    be performed with multiple users logged on.  Dialog
                    //    presents only an [OK] button.  However, it's ID is
                    //    IDCANCEL so pressing it will cause us to stop the 
                    //    merge.
                    // 
                    if (IDOK != OpenFilesWarningDialog())
                    {
                        TraceMsg("Cancelling sync - user bailed at open file warning");
                        SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);
                    }
                }
                // else we already put up the warning on another thread.  If the
                // user cancelled, SDS_SYNC_CANCELLED will be set.
            }
            else
            {
                // Don't merge, but continue otherwise.
                LogError(pSyncData->ItemID,
                         SYNCMGRLOGLEVEL_WARNING,
                         IDS_OPENFILE_MERGE_WARNING,
                         pSyncData->pszShareName);
                ExitGracefully(dwErr, NOERROR, "Skipping merge due to open files");
            }
        }
    }

    //
    // Conflict resolution may require stopping and restarting CSCMergeShare,
    // so do this in a loop
    //
    while (!(pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED))
    {
        Trace((TEXT("Calling CSCMergeShare(%s)"), pSyncData->pszShareName));

        pSyncData->dwSyncStatus = SDS_SYNC_OUT;
        bMergeResult = CSCMergeShare(pSyncData->pszShareName,
                                     CCscUpdate::_CscCallback,
                                     (DWORD_PTR)pSyncData);

        Trace((TEXT("CSCMergeShare(%s) returned"), pSyncData->pszShareName));

        // Do we need to merge again?
        if (!(SDS_SYNC_RESTART_MERGE & pSyncData->dwSyncStatus))
            break;
    }

    if (!(pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED) && !bMergeResult)
    {
        dwErr = GetLastError();
        if (ERROR_OPERATION_ABORTED == dwErr)
            dwErr = NOERROR;
    }

exit_gracefully:

    ReleaseMutex(m_hSyncMutex);

    TraceLeaveValue(dwErr);
}

DWORD
CCscUpdate::FillShare(PSYNCTHREADDATA pSyncData, int cPinned, DWORD dwConnectionSpeed)
{
    DWORD dwErr = NOERROR;
    DWORD dwShareStatus = 0;
    DWORD dwShareHints = 0;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::FillShare");

    CSCQueryFileStatus(pSyncData->pszShareName, &dwShareStatus, NULL, &dwShareHints);

    //
    // At logoff, we want to run the FrankAr code on all 
    // 'special' folder shares.
    // Customers expect folder redirection of special folders
    // to ensure all contents are cached.
    //
    if ((m_dwSyncFlags & CSC_SYNC_IN_FULL) ||
        ((m_dwSyncFlags & CSC_SYNC_LOGOFF) && IsSpecialFolderShare(pSyncData->pszShareName)))
    {
        pSyncData->dwSyncStatus = SDS_SYNC_IN_FULL;

        Trace((TEXT("Full sync at %d00 bps"), dwConnectionSpeed));

        //
        // Check the server for new files that should be pinned.
        //
        // We can't do this when disconnected.  Also, this is
        // time consuming, so don't do it on a slow connection.
        //
        if (!(FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus)
            && cPinned && !_PathIsSlow(dwConnectionSpeed))
        {
            //
            // Look for pinned folders on this share by enumerating
            // in the CSC database.  Go out to the server only if/when
            // we find a pinned folder.
            //
            TraceMsg("Running FrankAr code");
            //
            if (CConfig::GetSingleton().AlwaysPinSubFolders())
            {
                //
                // If the "AlwaysPinSubFolders" policy is set, we 
                // do a recursive pin.  This will cause any content 
                // (including folders) of a pinned folder to become pinned.
                //
                pSyncData->pThis->m_dwSyncFlags |= CSC_SYNC_PIN_RECURSE;
            }

            // First check the root folder
            if (_PinNewFilesCSCCallback(pSyncData->pszShareName,
                                        ENUM_REASON_FOLDER_BEGIN,
                                        0,
                                        dwShareHints,
                                        0,
                                        NULL,
                                        (LPARAM)pSyncData) == CSCPROC_RETURN_CONTINUE)
            {
                _CSCEnumDatabase(pSyncData->pszShareName,
                                 TRUE,
                                 _PinNewFilesCSCCallback,
                                 (LPARAM)pSyncData);
            }

            TraceMsg("FrankAr code complete");
        }
    }
    else
    {
        pSyncData->dwSyncStatus = SDS_SYNC_IN_QUICK;

        if (m_dwSyncFlags & CSC_SYNC_PINFILES)
        {
            //
            // Enumerate the file list and pin everything, checking with
            // SyncMgr periodically.
            //
            PinFiles(pSyncData);
        }
    }

    if (m_pConflictPinList)
    {
        // Make sure that any files we created because of merge
        // conflicts are pinned.
        PinFiles(pSyncData, TRUE);
    }

    // Can't fill when disconnected
    if (!(FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus))
    {
        // Clear the status text and update the max count in case we
        // pinned somthing above
        SYNCMGRPROGRESSITEM spi;
        spi.cbSize = sizeof(spi);
        spi.mask = SYNCMGRPROGRESSITEM_STATUSTEXT | SYNCMGRPROGRESSITEM_MAXVALUE;
        spi.lpcStatusText = L" ";
        spi.iMaxValue = pSyncData->cFilesToSync;
        Trace((TEXT("%d files to sync on %s"), spi.iMaxValue, pSyncData->pszShareName));
        NotifySyncMgr(pSyncData, &spi);

        if (!(pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED))
        {
            Trace((TEXT("Calling CSCFillSparseFiles(%s, %s)"), pSyncData->pszShareName, (pSyncData->dwSyncStatus & SDS_SYNC_IN_FULL) ? TEXT("full") : TEXT("quick")));
            if (!CSCFillSparseFiles(pSyncData->pszShareName,
                                    !!(pSyncData->dwSyncStatus & SDS_SYNC_IN_FULL),
                                    CCscUpdate::_CscCallback,
                                    (DWORD_PTR)pSyncData))
            {
                dwErr = GetLastError();
                if (ERROR_OPERATION_ABORTED == dwErr)
                    dwErr = NOERROR;
            }
            Trace((TEXT("CSCFillSparseFiles(%s) complete"), pSyncData->pszShareName));
        }
    }
    else
    {
        Trace((TEXT("Skipping CSCFillSparseFiles(%s) - server is offline"), pSyncData->pszShareName));
    }

    TraceLeaveValue(dwErr);
}

void
CCscUpdate::PinFiles(PSYNCTHREADDATA pSyncData, BOOL bConflictPinList)
{
    CscFilenameList *pfnl;
    CscFilenameList::HSHARE hShare;
    LPCTSTR pszFile;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::PinFiles");
    TraceAssert((m_dwSyncFlags & CSC_SYNC_PINFILES) || bConflictPinList);

    pfnl = m_pFileList;

    if (bConflictPinList)
    {
        pfnl = m_pConflictPinList;
    }

    if (!pfnl ||
        !pfnl->GetShareHandle(pSyncData->pszShareName, &hShare))
    {
        TraceLeaveVoid();
    }

    CscFilenameList::FileIter fi = pfnl->CreateFileIterator(hShare);

    // Iterate over the filenames associated with the share.
    while (pszFile = fi.Next())
    {
        TCHAR szFullPath[MAX_PATH];
        WIN32_FIND_DATA fd;

        // Check for Cancel
        if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
            break;

        ZeroMemory(&fd, sizeof(fd));

        // Build the full path
        if (!PathCombine(szFullPath, pSyncData->pszShareName, pszFile))
            continue;

        // Directories have a trailing "\*"
        if (StrChr(pszFile, TEXT('*')))
        {
            // It's a directory. Trim off the "\*"
            PathRemoveFileSpec(szFullPath);
        }

         // Get attributes and test for existence
        fd.dwFileAttributes = GetFileAttributes(szFullPath);
        if ((DWORD)-1 == fd.dwFileAttributes)
            continue;

        if (S_FALSE == m_NoPinList.IsPinAllowed(szFullPath))
        {
            //
            // Policy says don't pin this file/folder.
            //
            if (FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes)
            {
                LogError(pSyncData->ItemID,
                         SYNCMGRLOGLEVEL_WARNING,
                         IDS_PIN_NOPINFOLDER_POLICY_WARNING,
                         szFullPath);
            }
            else
            {
                LogError(pSyncData->ItemID,
                         IDS_PIN_NOPINFILE_POLICY_WARNING,
                         szFullPath,
                         NOERROR,
                         SYNCMGRLOGLEVEL_WARNING);
            }
            continue;
        }

        // Check for EFS
        BOOL bIsEFSFile;
        bIsEFSFile = (FILE_ATTRIBUTE_ENCRYPTED & fd.dwFileAttributes) &&
                        !(FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes);

        if (bIsEFSFile && SkipEFSPin(pSyncData, szFullPath))
            continue;

        if (pSyncData->dwSyncStatus & SDS_SYNC_CANCELLED)
            break;

        // Pin it
        pSyncData->dwPinHints = FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_INHERIT_USER;
        if (CSCPinFile(szFullPath, pSyncData->dwPinHints, NULL, NULL, NULL))
        {
            if (bConflictPinList && m_pFileList)
                m_pFileList->AddFile(szFullPath, !!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));
            pSyncData->cFilesToSync++;
            StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), PathFindFileName(szFullPath));
            ShellChangeNotify(szFullPath, &fd, FALSE);
            if (bIsEFSFile && !m_bCacheIsEncrypted)
            {
                LogError(pSyncData->ItemID,
                         IDS_PIN_ENCRYPT_WARNING,
                         szFullPath,
                         NOERROR,
                         SYNCMGRLOGLEVEL_WARNING);
            }
        }
        else
        {
            DWORD dwError = GetLastError();
            UINT idsError = GetErrorFormat(dwError);
            if (IDS_SHARE_CONNECT_ERROR == idsError)
            {
                LPTSTR pszErr = GetErrorText(dwError);
                //
                // Special-case the "can't connect to share" error.
                // Display only the share name in the error message
                // and abort the pinning of this share.  
                //
                LogError(pSyncData->ItemID,
                         SYNCMGRLOGLEVEL_ERROR,
                         idsError,
                         pSyncData->pszShareName,
                         pszErr ? pszErr : TEXT(""));

                LocalFreeString(&pszErr);
                pSyncData->dwSyncStatus |= SDS_SYNC_CANCELLED;
            }
            else
            {
                DWORD dwSyncMgrLogLevel = SYNCMGRLOGLEVEL_ERROR;
                if (ERROR_INVALID_NAME == dwError)
                {
                    //
                    // File type is in the exclusion list.
                    // This is a warning, not an error.
                    //
                    dwSyncMgrLogLevel = SYNCMGRLOGLEVEL_WARNING;
                }
                LogError(pSyncData->ItemID,
                         IDS_PIN_FILE_ERROR,
                         szFullPath,
                         dwError,
                         dwSyncMgrLogLevel);
            }
            pSyncData->dwSyncStatus |= SDS_SYNC_ERROR;
        }

        // If it's a directory, pin its contents
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            _Win32EnumFolder(szFullPath,
                             !bConflictPinList && ShouldPinRecurse(szFullPath),
                             CCscUpdate::_PinNewFilesW32Callback,
                             (LPARAM)pSyncData);
        }
    }

    // Flush the shell notify queue
    ShellChangeNotify(NULL, TRUE);
    TraceLeaveVoid();
}


void
CCscUpdate::NotifyUndo(PSYNCTHREADDATA pSyncData, LPCTSTR pszName)
{
    LPTSTR pszMsg;
    SYNCMGRPROGRESSITEM spi;
    spi.cbSize = sizeof(spi);
    spi.mask = SYNCMGRPROGRESSITEM_STATUSTEXT;

    spi.lpcStatusText = L" ";

    // Skip the share name
    if (PathIsPrefix(pSyncData->pszShareName, pszName))
    {
        pszName += lstrlen(pSyncData->pszShareName);
        if (*pszName == TEXT('\\'))
            pszName++;
    }

    TCHAR szPath[MAX_PATH] = TEXT("\\");
    _CopyParentPathForDisplay(szPath, ARRAYSIZE(szPath), pszName);

    // If we still have a name, build a string like
    // "undo: dir\foo.txt" to display in SyncMgr
    if (FormatStringID(&pszMsg, g_hInstance, IDS_UNDO_SCAN, PathFindFileName(pszName), szPath))
    {
        spi.lpcStatusText = pszMsg;
    }

    NotifySyncMgr(pSyncData, &spi);

    LocalFreeString(&pszMsg);
}


DWORD WINAPI
CCscUpdate::_UndoProgress(LPCTSTR pszItem, LPARAM lpContext)
{
    PSYNCTHREADDATA pSyncData = reinterpret_cast<PSYNCTHREADDATA>(lpContext);

    if (pSyncData->pUndoExclusionList &&
        pSyncData->pUndoExclusionList->FileExists(pszItem))
    {
        return CSCPROC_RETURN_SKIP;
    }

    // Update SyncMgr
    pSyncData->pThis->NotifyUndo(pSyncData, pszItem);

    return CSCPROC_RETURN_CONTINUE;
}

//
// The user's response to the "confirm pin encrypted" dialog is encoded
// to fit into the return value from EndDialog.  The PINEFS_XXXXX macros
// describe this encoding.
//
// Bits 0 and 1 represent the user's [Yes][No][Cancel] choice.
//
#define PINEFS_YES        0x00000001
#define PINEFS_NO         0x00000002
#define PINEFS_CANCEL     0x00000003
#define PINEFS_YNC_MASK   0x00000003
//
// Bit 31 indicates if the user checked the "Apply to all" checkbox.
//
#define PINEFS_APPLYTOALL 0x80000000
//
// Convenience macros for indicating yes-to-all and no-to-all.
//
#define PINEFS_NO_TOALL   (PINEFS_NO | PINEFS_APPLYTOALL)
#define PINEFS_YES_TOALL  (PINEFS_YES | PINEFS_APPLYTOALL)


//
// Returns (by way of EndDialog) one of the PINEFS_XXXXXX codes.
//
// PINEFS_YES       - Pin this file but ask again on the next.
// PINEFS_YES_TOALL - Pin this file and all encrypted files encountered.
// PINEFS_NO        - Don't pin this file but ask again on the next.
// PINEFS_NO_TOALL  - Don't pin this file nor any other encrypted files.
// PINEFS_CANCEL    - Don't pin this file.  Cancel entire operation.
// 
INT_PTR CALLBACK
ConfirmEFSPinProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR nResult = 0;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            LPTSTR pszMsg = NULL;
            LPCTSTR pszFile = PathFindFileName((LPCTSTR)lParam);
            FormatStringID(&pszMsg, g_hInstance, IDS_FMT_PIN_EFS_MSG, pszFile);
            if (pszMsg)
            {
                SetDlgItemText(hDlg, IDC_EFS_MSG, pszMsg);
                LocalFree(pszMsg);
            }
            else
            {
                //
                // Let's be safe.  On failure we won't pin an encrypted file
                // to a non-encrypted cache.
                //
                EndDialog(hDlg, PINEFS_NO_TOALL);
            }
        }
        nResult = TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDYES:
            EndDialog(hDlg, BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_PINEFS_APPLYTOALL) ? PINEFS_YES_TOALL : PINEFS_YES);
            nResult = TRUE;
            break;

        case IDNO:
            EndDialog(hDlg, BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_PINEFS_APPLYTOALL) ? PINEFS_NO_TOALL : PINEFS_NO);
            nResult = TRUE;
            break;

        case IDCANCEL:
            EndDialog(hDlg, PINEFS_CANCEL);
            nResult = TRUE;
            break;

        default:
            break;
        }
        break;
    }

    return nResult;
}

BOOL
CCscUpdate::SkipEFSPin(PSYNCTHREADDATA pSyncData, LPCTSTR pszItem)
{
    BOOL bSkip = FALSE;

    if (!m_bCacheIsEncrypted)
    {
        int iResult;
        EnterCriticalSection(&m_csThreadList);

        if ((CSC_SYNC_EFS_PIN_NONE & m_dwSyncFlags) ||
            !(CSC_SYNC_MAYBOTHERUSER & m_dwSyncFlags))
        {
            iResult = PINEFS_NO;
        }
        else if (CSC_SYNC_EFS_PIN_ALL & m_dwSyncFlags)
        {
            iResult = PINEFS_YES;
        }
        else
        {
            // Suspend the other sync threads
            SetSyncThreadStatus(SyncPause, pSyncData->ItemID);

            iResult = (int)DialogBoxParam(g_hInstance,
                                          MAKEINTRESOURCE(IDD_CONFIRM_PIN_EFS),
                                          m_hwndDlgParent,
                                          ConfirmEFSPinProc,
                                          (LPARAM)pszItem);

            if (PINEFS_APPLYTOALL & iResult)
            {
                //
                // User checked the "apply to all" checkbox.
                // Persist a [Yes][No] button selection.
                //
                if (PINEFS_NO == (PINEFS_YNC_MASK & iResult))
                {
                    m_dwSyncFlags |= CSC_SYNC_EFS_PIN_NONE;
                }
                else if (PINEFS_YES == (PINEFS_YNC_MASK & iResult))
                {
                    m_dwSyncFlags |= CSC_SYNC_EFS_PIN_ALL;
                }
            }

            // Resume syncing
            SetSyncThreadStatus(SyncResume, pSyncData->ItemID);
        }
        LeaveCriticalSection(&m_csThreadList);

        switch (PINEFS_YNC_MASK & iResult)
        {
        default:
        case PINEFS_NO:
            bSkip = TRUE;
            break;

        case PINEFS_YES:
            // continue
            break;

        case PINEFS_CANCEL:
            // stop all threads
            SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);
            break;
        }
    }

    return bSkip;
}

HRESULT
CCscUpdate::SetSyncThreadStatus(eSetSyncStatus status, REFGUID rItemID)
{
    // Assume success here.  If we don't find the thread,
    // it's probably already finished.
    HRESULT hr = S_OK;
    BOOL bOneItem;

    TraceEnter(TRACE_UPDATE, "CCscUpdate::SetSyncThreadStatus");

    bOneItem = (SyncStop == status && !IsEqualGUID(rItemID, GUID_NULL));

    EnterCriticalSection(&m_csThreadList);

    if (NULL != m_hSyncThreads)
    {
        int cItems = DPA_GetPtrCount(m_hSyncThreads);
        SYNCMGRPROGRESSITEM spi = {0};
        DWORD (WINAPI *pfnStartStop)(HANDLE);

        pfnStartStop = ResumeThread;

        spi.cbSize        = sizeof(spi);
        spi.mask          = SYNCMGRPROGRESSITEM_STATUSTYPE | SYNCMGRPROGRESSITEM_STATUSTEXT;
        spi.lpcStatusText = L" ";
        spi.dwStatusType  = SYNCMGRSTATUS_UPDATING;
        if (SyncPause == status)
        {
            spi.dwStatusType  = SYNCMGRSTATUS_PAUSED;
            pfnStartStop = SuspendThread;
        }

        while (cItems > 0)
        {
            PSYNCTHREADDATA pSyncData;

            --cItems;
            pSyncData = (PSYNCTHREADDATA)DPA_FastGetPtr(m_hSyncThreads, cItems);
            TraceAssert(NULL != pSyncData);

            if (SyncStop == status)
            {
                // Tell the thread to abort
                if (!bOneItem || IsEqualGUID(rItemID, pSyncData->ItemID))
                {
                    pSyncData->dwSyncStatus |= SDS_SYNC_CANCELLED;
                    if (bOneItem)
                        break;
                }
            }
            else
            {
                // Suspend or resume the thread if it's not the current thread
                if (!IsEqualGUID(rItemID, pSyncData->ItemID))
                    (*pfnStartStop)(pSyncData->hThread);
                m_pSyncMgrCB->Progress(pSyncData->ItemID, &spi);
            }
        }
    }

    LeaveCriticalSection(&m_csThreadList);

    TraceLeaveResult(hr);
}



HRESULT
CCscUpdate::GetSilentFolderList(void)
{
    HRESULT hr = S_OK;

    delete m_pSilentFolderList;
    m_pSilentFolderList = new CscFilenameList;

    delete m_pSpecialFolderList;
    m_pSpecialFolderList = new CscFilenameList;

    if (NULL == m_pSilentFolderList || NULL == m_pSpecialFolderList)
    {
        delete m_pSilentFolderList;
        m_pSilentFolderList = NULL;
        delete m_pSpecialFolderList;
        m_pSpecialFolderList = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        BuildSilentFolderList(m_pSilentFolderList, m_pSpecialFolderList);

        if (0 == m_pSilentFolderList->GetShareCount())
        {
            delete m_pSilentFolderList;
            m_pSilentFolderList = NULL;
        }

        if (0 == m_pSpecialFolderList->GetShareCount())
        {
            delete m_pSpecialFolderList;
            m_pSpecialFolderList = NULL;
        }
    }
    return hr;
}


void
BuildSilentFolderList(CscFilenameList *pfnlSilentFolders,
                      CscFilenameList *pfnlSpecialFolders)
{
    //
    // We will silently handle sync conflicts in any of the folders
    // below that have a '1' after them.
    //
    // If we get complaints about conflicts in folders that we
    // think we can handle silently and safely, add them.
    //
    // Note that CSIDL_PERSONAL (MyDocs) and CSIDL_MYPICTURES
    // should probably never be silent, since the user
    // interacts with them directly.
    //
    // This list corresponds to the list of shell folders that may
    // be redirected.  See also
    // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
    //
    static const int s_csidlFolders[][2] =
    {
        { CSIDL_PROGRAMS,           0 },
        { CSIDL_PERSONAL,           0 },
        { CSIDL_FAVORITES,          0 },
        { CSIDL_STARTUP,            0 },
        { CSIDL_RECENT,             1 },
        { CSIDL_SENDTO,             0 },
        { CSIDL_STARTMENU,          1 },
        { CSIDL_DESKTOPDIRECTORY,   0 },
        { CSIDL_NETHOOD,            0 },
        { CSIDL_TEMPLATES,          0 },
        { CSIDL_APPDATA,            1 },
        { CSIDL_PRINTHOOD,          0 },
        { CSIDL_MYPICTURES,         0 },
        { CSIDL_PROFILE,            1 },
        { CSIDL_ADMINTOOLS,         0 },
    };
    TCHAR szPath[MAX_PATH];

    for (int i = 0; i < ARRAYSIZE(s_csidlFolders); i++)
    {
        if (SHGetSpecialFolderPath(NULL,
                                   szPath,
                                   s_csidlFolders[i][0] | CSIDL_FLAG_DONT_VERIFY,
                                   FALSE))
        {
            // We only want UNC net paths
            LPTSTR pszUNC = NULL;
            GetRemotePath(szPath, &pszUNC);
            if (!pszUNC)
                continue;

            if (s_csidlFolders[i][1])
            {
                if (pfnlSilentFolders)
                    pfnlSilentFolders->AddFile(pszUNC, true);
            }
            else
            {
                if (pfnlSpecialFolders)
                    pfnlSpecialFolders->AddFile(pszUNC, true);
            }

            LocalFreeString(&pszUNC);
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SyncMgr integration (ISyncMgrEnumItems)                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CUpdateEnumerator::CUpdateEnumerator(PCSCUPDATE pUpdate)
: m_cRef(1),
  m_pUpdate(pUpdate),
  m_hFind(INVALID_HANDLE_VALUE),
  m_bEnumFileSelection(FALSE),
  m_cCheckedItemsEnumerated(0)
{
    DllAddRef();

    if (m_pUpdate)
    {
        m_pUpdate->AddRef();

        if (m_pUpdate->m_pFileList)
        {
            m_bEnumFileSelection = TRUE;
            m_SelectionIterator = m_pUpdate->m_pFileList->CreateShareIterator();
        }
    }
}

CUpdateEnumerator::~CUpdateEnumerator()
{
    if (m_hFind != INVALID_HANDLE_VALUE)
        CSCFindClose(m_hFind);

    DoRelease(m_pUpdate);
    DllRelease();
}


STDMETHODIMP CUpdateEnumerator::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CUpdateEnumerator, ISyncMgrEnumItems),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CUpdateEnumerator::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CUpdateEnumerator::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP
CUpdateEnumerator::Next(ULONG celt, LPSYNCMGRITEM rgelt, PULONG pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG cFetched = 0;
    LPSYNCMGRITEM pItem = rgelt;
    WIN32_FIND_DATA fd = {0};
    DWORD dwShareStatus = 0;
    DWORD dwSyncFlags;
    CscFilenameList::HSHARE hShare;
    LPCTSTR pszShareName = NULL;

    TraceEnter(TRACE_UPDATE, "CUpdateEnumerator::Next");
    TraceAssert(m_pUpdate != NULL);

    if (NULL == rgelt)
        TraceLeaveResult(E_INVALIDARG);

    dwSyncFlags = m_pUpdate->m_dwSyncFlags;

    while (cFetched < celt)
    {
        CSCEntry *pShareEntry;
        CSCSHARESTATS shareStats;
        CSCGETSTATSINFO si = { SSEF_NONE,
                               SSUF_TOTAL | SSUF_PINNED | SSUF_MODIFIED | SSUF_SPARSE | SSUF_DIRS,
                               false,
                               false };     

        if (m_bEnumFileSelection)
        {
            if (!m_SelectionIterator.Next(&hShare))
                break;

            pszShareName = m_pUpdate->m_pFileList->GetShareName(hShare);

            CSCQueryFileStatus(pszShareName, &dwShareStatus, NULL, NULL);
            fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            StringCchCopy(fd.cFileName, ARRAYSIZE(fd.cFileName), pszShareName);
        }
        else
        {
            if (m_hFind == INVALID_HANDLE_VALUE)
            {
                m_hFind = CacheFindFirst(NULL, &fd, &dwShareStatus, NULL, NULL, NULL);

                if (m_hFind == INVALID_HANDLE_VALUE)
                {
                    // The database is empty, so there's nothing to enumerate..
                    break;
                }

                pszShareName = fd.cFileName;
            }
            else if (CacheFindNext(m_hFind, &fd, &dwShareStatus, NULL, NULL, NULL))
            {
                pszShareName = fd.cFileName;
            }
            else
                break;
        }
        TraceAssert(pszShareName);

//
// This was proposed as a fix for part of 383011. However,
// that bug only applies in a multi-user scenario, and if there
// are more than 3 users using the machine, this would cause a
// user whose SID had been expelled from the CSC database to not
// be able to sync a share where they do indeed have access.
//
//        // If the current user has no access to the share, don't enumerate it.
//        if (!(CscAccessUser(dwShareStatus) || CscAccessGuest(dwShareStatus)))
//            continue;

        // Count the # of pinned files, sparse files, etc.
        _GetShareStatisticsForUser(pszShareName, &si, &shareStats);

        // The root of a special folder is pinned with a pin count, but
        // not the user-hint flag, so _GetShareStats doesn't count it.
        // We need to count this for some of the checks below.
        // (If the share is manual-cache, these look exactly like the 
        // Siemens scenario in 341786, but we want to sync them.)
        if (shareStats.cTotal && m_pUpdate->IsSpecialFolderShare(pszShareName))
        {
            shareStats.cPinned++;
            if (dwSyncFlags & CSC_SYNC_LOGOFF)
            {
                //
                // At logoff, we want to run the FrankAr code on all 
                // 'special' folder shares.
                // Customers expect folder redirection of special folders
                // to ensure all contents are cached.
                //
                dwSyncFlags |= CSC_SYNC_IN_FULL;
            }
        }

        // If we're pinning, then even if nothing is sparse now,
        // there will be sparse files after we pin them.
        if (dwSyncFlags & CSC_SYNC_PINFILES)
        {
            shareStats.cSparse++;
            shareStats.cTotal++;
        }

        // If there's nothing cached on this share, then don't even
        // enumerate it to SyncMgr.  This avoids listing extra junk
        // in SyncMgr.
        if ((0 == shareStats.cTotal) ||
            (shareStats.cTotal == shareStats.cDirs && 0 == shareStats.cPinned))
        {
            // Either there is nothing cached for this share, or the only
            // things found were unpinned dirs (no files, no pinned dirs).
            // The second case can happen if you delete files from the viewer,
            // in which case you think you deleted everything but the viewer
            // doesn't show directories, so they weren't deleted.
            Trace((TEXT("Nothing cached on %s, not enumerating"), pszShareName));
            continue;
        }

        if ((dwShareStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING)
        {
            //
            // Don't enumerate "no-cache" shares if there's nothing to merge.
            //
            // These can exist in the cache if the share was previously
            // cacheable, but has since been changed to "no caching".
            //
            // If there's something to merge, we should still sync it to
            // get everything squared away.
            //
            if (!((dwSyncFlags & CSC_SYNC_OUT) && (shareStats.cModified)))
            {
                Trace((TEXT("Not enumerating no-cache share %s"), pszShareName));
                continue;
            }
            Trace((TEXT("Enumerating no-cache share %s with offline changes."), pszShareName));
        }

        // Explorer has shut down by the time we do a logoff sync.  Hide the
        // Properties button at logoff so we don't end up restarting Explorer.
        pItem->dwFlags = (dwSyncFlags & CSC_SYNC_LOGOFF) ? 0 : SYNCMGRITEM_HASPROPERTIES;

        if ((dwShareStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_MANUAL_REINT
             && 0 == shareStats.cPinned
             && !(dwSyncFlags & CSC_SYNC_PINFILES))
        {
            // On a manual share, if nothing is pinned (and we aren't pinning)
            // then we don't want to call CSCFillSparseFiles on the share.
            // Raid #341786
            Trace((TEXT("Manual cache share '%s' has only autocached files"), pszShareName));

            // However, if there is something to merge, then we need to sync.
            if (!((dwSyncFlags & CSC_SYNC_OUT) && shareStats.cModified))
            {
                Trace((TEXT("Not enumerating manual-cache share %s"), pszShareName));
                continue;
            }

            // There is something to merge, so enumerate the share but
            // tell SyncMgr that it's temporary so it doesn't save state
            // for this share.
            pItem->dwFlags |= SYNCMGRITEM_TEMPORARY;
        }

        //
        // In some circumstances, we may want to merge even if there
        // are no modified files, in order to show the open files warning.
        //
        // See comments in CCscUpdate::_SyncThread
        //
        if (0 == shareStats.cModified)
        {
            if ((FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus) &&
                (FLAG_CSC_SHARE_STATUS_FILES_OPEN & dwShareStatus))
            {
                shareStats.cModified++;
            }
        }

        // Enumerate this share
        cFetched++;

        // Get existing share entry or create a new one
        pShareEntry = m_pUpdate->m_ShareLog.Add(pszShareName);
        if (!pShareEntry)
            TraceLeaveResult(E_OUTOFMEMORY);

        pItem->cbSize = sizeof(SYNCMGRITEM);
        pItem->ItemID = pShareEntry->Guid();
        pItem->hIcon = g_hCscIcon;
        // SYNCMGRITEM_TEMPORARY causes items to not show up in
        // SyncMgr's logon/logoff settings page.  Raid #237288
        //if (0 == shareStats.cPinned)
        //    pItem->dwFlags |= SYNCMGRITEM_TEMPORARY;
        if (ERROR_SUCCESS == m_pUpdate->GetLastSyncTime(pszShareName, &pItem->ftLastUpdate))
            pItem->dwFlags |= SYNCMGRITEM_LASTUPDATETIME;

        //
        // Determine whether this share needs syncing.
        //
        // At settings time, assume everything needs syncing (check everything)
        //
        // If outbound, shares with modified files are checked
        // If inbound (full), shares with sparse or pinned files are checked
        // If inbound (quick), shares with sparse files are checked
        //
        // Anything else doesn't need to be sync'ed at this time (unchecked)
        //
        pItem->dwItemState = SYNCMGRITEMSTATE_CHECKED;
        if (!(dwSyncFlags & CSC_SYNC_SETTINGS) &&
            !((dwSyncFlags & CSC_SYNC_OUT)      && shareStats.cModified) &&
            !((dwSyncFlags & CSC_SYNC_IN_FULL)  && shareStats.cTotal   ) &&
            !((dwSyncFlags & CSC_SYNC_IN_QUICK) && shareStats.cSparse  ))
        {
            pItem->dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
        }

        // Get friendly share name here
        LPITEMIDLIST pidl = NULL;
        SHFILEINFO sfi = {0};
        if (SUCCEEDED(SHSimpleIDListFromFindData(pszShareName, &fd, &pidl)))
        {
            SHGetFileInfo((LPCTSTR)pidl,
                          0,
                          &sfi,
                          sizeof(sfi),
                          SHGFI_PIDL | SHGFI_DISPLAYNAME);
            SHFree(pidl);
        }
        if (TEXT('\0') != sfi.szDisplayName[0])
            pszShareName = sfi.szDisplayName;

        SHTCharToUnicode((LPTSTR)pszShareName, pItem->wszItemName, ARRAYSIZE(pItem->wszItemName));
        if (SYNCMGRITEMSTATE_CHECKED == pItem->dwItemState)
        {
            m_cCheckedItemsEnumerated++;
            Trace((TEXT("Enumerating %s, checked"), pszShareName));
        }
        else
        {
            Trace((TEXT("Enumerating %s, unchecked"), pszShareName));
        }

        pItem++;
    }


    if (pceltFetched)
        *pceltFetched = cFetched;

    if (cFetched != celt)
        hr = S_FALSE;

    if ((S_FALSE == hr) && 
        0 == m_cCheckedItemsEnumerated &&
        (CSC_SYNC_SHOWUI_ALWAYS & dwSyncFlags))
    {
        //
        // Special-case where we're synching nothing but still
        // want to display SyncMgr progress UI.  We enumerate a 
        // special string rather than a share name for display in
        // the status UI.  Force hr == S_OK so the caller will accept
        // this "dummy" item.  Next() will be called once more but 
        // m_cCheckedItemsEnumerated will be 1 so this block won't be
        // entered and we'll return S_FALSE indicating the end of the
        // enumeration.
        //
        pItem->cbSize      = sizeof(SYNCMGRITEM);
        pItem->hIcon       = g_hCscIcon;
        pItem->dwFlags     = 0;
        pItem->dwItemState = SYNCMGRITEMSTATE_CHECKED;
        pItem->ItemID      = GUID_CscNullSyncItem;

        UINT idString = IDS_NULLSYNC_ITEMNAME;
        if ((CSC_SYNC_OUT & dwSyncFlags) &&
            !((CSC_SYNC_IN_QUICK | CSC_SYNC_IN_FULL) & dwSyncFlags))
        {
            // Use different text if we are only merging
            idString = IDS_NULLMERGE_ITEMNAME;
        }

        LoadStringW(g_hInstance, 
                    idString, 
                    pItem->wszItemName,
                    ARRAYSIZE(pItem->wszItemName));
        m_cCheckedItemsEnumerated = 1;

        TraceMsg("Enumerating NULL item");
        hr = S_OK;
    }

    TraceLeaveResult(hr);
}


STDMETHODIMP
CUpdateEnumerator::Skip(ULONG celt)
{
    return Next(celt, NULL, NULL);
}


STDMETHODIMP
CUpdateEnumerator::Reset()
{
    m_cCheckedItemsEnumerated = 0;
    if (m_bEnumFileSelection)
    {
        m_SelectionIterator.Reset();
    }
    else if (m_hFind != INVALID_HANDLE_VALUE)
    {
        CSCFindClose(m_hFind);
        m_hFind = INVALID_HANDLE_VALUE;
    }
    return S_OK;
}


STDMETHODIMP
CUpdateEnumerator::Clone(LPSYNCMGRENUMITEMS *ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\uuid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuid.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#include "uuid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       version.h
//
//  Resources for the common version chunk
//
//--------------------------------------------------------------------------

#ifndef APSTUDIO_INVOKED

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Client Side Caching UI"
#define VER_INTERNALNAME_STR            "cscui"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "cscui.dll"

#include <ntverp.h>
#include <common.ver>

#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\uuid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       uuid.h
//
//--------------------------------------------------------------------------

// Uncomment this if code in cscst.cpp monitors device changes.
//#include <pnpmgr.h>    // For GUID_DEVNODE_CHANGE

// {750fdf0e-2a26-11d1-a3ea-080036587f03}
DEFINE_GUID(CLSID_CscShellExt, 0x750fdf0e, 0x2a26, 0x11d1, 0xa3, 0xea, 0x08, 0x00, 0x36, 0x58, 0x7f, 0x03);

// {750fdf10-2a26-11d1-a3ea-080036587f03}
DEFINE_GUID(CLSID_CscUpdateHandler, 0x750fdf10, 0x2a26, 0x11d1, 0xa3, 0xea, 0x08, 0x00, 0x36, 0x58, 0x7f, 0x03);

// {750fdf0f-2a26-11d1-a3ea-080036587f03}
DEFINE_GUID(CLSID_CscVolumeCleaner, 0x750fdf0f, 0x2a26, 0x11d1, 0xa3, 0xea, 0x08, 0x00, 0x36, 0x58, 0x7f, 0x03);
// {effc2928-37b1-11d2-a3c1-00c04fb1782a}
DEFINE_GUID(CLSID_CscVolumeCleaner2, 0xeffc2928, 0x37b1, 0x11d2, 0xa3, 0xc1, 0x00, 0xc0, 0x4f, 0xb1, 0x78, 0x2a);

// {AFDB1F70-2A4C-11d2-9039-00C04F8EEB3E}
DEFINE_GUID(CLSID_OfflineFilesFolder, 0xafdb1f70, 0x2a4c, 0x11d2, 0x90, 0x39, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);

// {10CFC467-4392-11d2-8DB4-00C04FA31A66}
DEFINE_GUID(CLSID_OfflineFilesOptions, 0x10cfc467, 0x4392, 0x11d2, 0x8d, 0xb4, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66);

// {A8A5A263-A58C-11d2-A7C2-00C04FA31A66}
DEFINE_GUID(GUID_CscNullSyncItem, 
0xa8a5a263, 0xa58c, 0x11d2, 0xa7, 0xc2, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\volclean.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.cpp
//
//  Authors;
//    Jeff Saathoff (jeffreys)
//
//  Notes;
//    CSC disk cleanup implementation (IEmptyVolumeCache)
//--------------------------------------------------------------------------
#include "pch.h"
#include "folder.h"


int
CoTaskLoadString(HINSTANCE hInstance, UINT idString, LPWSTR *ppwsz)
{
    int nResult = 0;

    *ppwsz = NULL;

    ULONG cchString = SizeofStringResource(hInstance, idString);
    if (cchString)
    {
        cchString++;    // for NULL
        *ppwsz = (LPWSTR)CoTaskMemAlloc(cchString * sizeof(WCHAR));
        if (*ppwsz)
            nResult = LoadStringW(hInstance, idString, *ppwsz, cchString);
    }

    return nResult;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IClassFactory::CreateInstance support                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CCscVolumeCleaner::CreateInstance(REFIID riid, LPVOID *ppv)
{
    return Create(FALSE, riid, ppv);
}

HRESULT WINAPI
CCscVolumeCleaner::CreateInstance2(REFIID riid, LPVOID *ppv)
{
    return Create(TRUE, riid, ppv);
}

HRESULT WINAPI
CCscVolumeCleaner::Create(BOOL fPinned, REFIID riid, LPVOID *ppv)
{
    HRESULT hr;

    CCscVolumeCleaner *pThis = new CCscVolumeCleaner(fPinned);
    if (pThis)
    {
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IUnknown implementation                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCscVolumeCleaner::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CCscVolumeCleaner, IEmptyVolumeCache),
        QITABENT(CCscVolumeCleaner, IEmptyVolumeCache2),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CCscVolumeCleaner::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CCscVolumeCleaner::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IEmptyVolumeCache implementation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CCscVolumeCleaner::Initialize(HKEY  /*hkRegKey*/,
                              LPCWSTR pcwszVolume,
                              LPWSTR *ppwszDisplayName,
                              LPWSTR *ppwszDescription,
                              LPDWORD pdwFlags)
{
    BOOL bSettingsMode;
    CSCSPACEUSAGEINFO sui = {0};

    TraceEnter(TRACE_SHELLEX, "IEmptyVolumeCache::Initialize");
    TraceAssert(pcwszVolume != NULL);
    TraceAssert(ppwszDisplayName != NULL);
    TraceAssert(ppwszDescription != NULL);
    TraceAssert(pdwFlags != NULL);
    TraceAssert(IsCSCEnabled());

    bSettingsMode = (BOOL)((*pdwFlags) & EVCF_SETTINGSMODE);

    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;
    *pdwFlags = 0;

    // If this isn't the volume containing the CSC database, then we have
    // nothing to free. Note that we don't use the space usage data
    // returned here.
    GetCscSpaceUsageInfo(&sui);
    if (!bSettingsMode && !PathIsSameRoot(sui.szVolume, pcwszVolume))
        TraceLeaveResult(S_FALSE);

    m_PurgerSel.SetFlags(m_fPinned ? PURGE_FLAG_PINNED : (PURGE_FLAG_UNPINNED | PURGE_IGNORE_ACCESS));
    m_pPurger = new CCachePurger(m_PurgerSel,
                                 CachePurgerCallback,
                                 this);
    if (!m_pPurger)
        TraceLeaveResult(E_FAIL);

    // If we're freeing auto-cached files, we want to be enabled by default,
    // but not if we're freeing pinned files.
    *pdwFlags = 0;
    if (!m_fPinned)
        *pdwFlags = EVCF_ENABLEBYDEFAULT | EVCF_ENABLEBYDEFAULT_AUTO;

    // If policy allows, turn on the "Details" button which launches the viewer
    if (!CConfig::GetSingleton().NoCacheViewer())
        *pdwFlags |= EVCF_HASSETTINGS;

    // Load the display name string
    CoTaskLoadString(g_hInstance,
                     m_fPinned ? IDS_APPLICATION : IDS_DISKCLEAN_DISPLAY,
                     ppwszDisplayName);

    // Load the description string
    CoTaskLoadString(g_hInstance,
                     m_fPinned ? IDS_DISKCLEAN_PIN_DESCRIPTION : IDS_DISKCLEAN_DESCRIPTION,
                     ppwszDescription);

    TraceLeaveResult(S_OK);
}

STDMETHODIMP
CCscVolumeCleaner::GetSpaceUsed(DWORDLONG *pdwlSpaceUsed,
                                LPEMPTYVOLUMECACHECALLBACK picb)
{
    m_pDiskCleaner = picb;
    m_pPurger->Scan();
    if (m_pDiskCleaner)
        m_pDiskCleaner->ScanProgress(m_dwlSpaceToFree,
                                     EVCCBF_LASTNOTIFICATION,
                                     NULL);
    *pdwlSpaceUsed = m_dwlSpaceToFree;
    return S_OK;
}

STDMETHODIMP
CCscVolumeCleaner::Purge(DWORDLONG /*dwlSpaceToFree*/,
                         LPEMPTYVOLUMECACHECALLBACK picb)
{
    m_pDiskCleaner = picb;
    m_pPurger->Delete();
    if (m_pDiskCleaner)
        m_pDiskCleaner->PurgeProgress(m_dwlSpaceFreed,
                                      0,
                                      EVCCBF_LASTNOTIFICATION,
                                      NULL);
    return S_OK;
}

STDMETHODIMP
CCscVolumeCleaner::ShowProperties(HWND /*hwnd*/)
{
    // Launch the viewer
    COfflineFilesFolder::Open();
    return S_FALSE;
}

STDMETHODIMP
CCscVolumeCleaner::Deactivate(LPDWORD /*pdwFlags*/)
{
    // nothing to do here
    return S_OK;
}

// IEmptyVolumeCache2 method
STDMETHODIMP
CCscVolumeCleaner::InitializeEx(HKEY hkRegKey,
                                LPCWSTR pcwszVolume,
                                LPCWSTR pcwszKeyName,
                                LPWSTR *ppwszDisplayName,
                                LPWSTR *ppwszDescription,
                                LPWSTR *ppwszBtnText,
                                LPDWORD pdwFlags)
{
    HRESULT hr = Initialize(hkRegKey,
                            pcwszVolume,
                            ppwszDisplayName,
                            ppwszDescription,
                            pdwFlags);
    if (S_OK == hr)
        CoTaskLoadString(g_hInstance, IDS_DISKCLEAN_BTN_TEXT, ppwszBtnText);
    return hr;
}

BOOL
CCscVolumeCleaner::ScanCallback(CCachePurger *pPurger)
{
    BOOL bContinue = TRUE;

    // If the pinned state matches what we're looking for, add the
    // size to the total.
    if (pPurger->WillDeleteThisFile())
        m_dwlSpaceToFree += pPurger->FileBytes();

    if (m_pDiskCleaner)
        bContinue = SUCCEEDED(m_pDiskCleaner->ScanProgress(m_dwlSpaceToFree,
                                                           0,
                                                           NULL));
    return bContinue;
}

BOOL
CCscVolumeCleaner::DeleteCallback(CCachePurger *pPurger)
{
    BOOL bContinue = TRUE;

    // Don't let this go below zero
    m_dwlSpaceToFree -= min(pPurger->FileBytes(), m_dwlSpaceToFree);
    m_dwlSpaceFreed += pPurger->FileBytes();

    if (m_pDiskCleaner)
        bContinue = SUCCEEDED(m_pDiskCleaner->PurgeProgress(m_dwlSpaceFreed,
                                                            m_dwlSpaceToFree,
                                                            0,
                                                            NULL));
    return bContinue;
}

BOOL CALLBACK
CCscVolumeCleaner::CachePurgerCallback(CCachePurger *pPurger)
{
    PCSCVOLCLEANER pThis = (PCSCVOLCLEANER)pPurger->CallbackData();
    switch (pPurger->Phase())
    {
    case PURGE_PHASE_SCAN:
        return pThis->ScanCallback(pPurger);
    case PURGE_PHASE_DELETE:
        return pThis->DeleteCallback(pPurger);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

#ifndef _INC_CSCVIEW_CONFIG_H
#   include "config.h"
#endif

#include "debug.h"

HRESULT GetRemotePath(LPCTSTR szInName, LPTSTR *pszOutName);
LPTSTR ULongToString(ULONG i, LPTSTR psz, ULONG cchMax);
VOID LocalFreeString(LPTSTR *ppsz);
BOOL LocalAllocString(LPTSTR *ppszDest, LPCTSTR pszSrc);
UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);
void ShellChangeNotify(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, BOOL bFlush, LONG nEvent = 0);
inline void ShellChangeNotify(LPCTSTR pszPath, BOOL bFlush = FALSE, LONG nEvent = 0) {ShellChangeNotify(pszPath, NULL, bFlush, nEvent);}
HRESULT GetLinkTarget(LPCTSTR pszShortcut, LPTSTR *ppszTarget, DWORD *pdwAttr = NULL);
void CenterWindow(HWND hwnd, HWND hwndParent);
DWORD CSCUIRebootSystem(void);
HRESULT SHSimpleIDListFromFindData(LPCTSTR pszPath, const WIN32_FIND_DATA *pfd, LPITEMIDLIST *ppidl);
DWORD CscDelete(LPCTSTR pszPath);
HRESULT IsOpenConnectionShare(LPCTSTR pszShare);
BOOL IsCSCEnabled(void);
BOOL IsCacheEncrypted(BOOL *pbPartial);
BOOL IsSyncInProgress(void);
BOOL IsPurgeInProgress(void);
BOOL IsEncryptionInProgress(void);
HANDLE RequestPermissionToEncryptCache(void);
bool CscVolumeSupportsEncryption(LPCTSTR pszPath = NULL);
BOOL IsWindowsTerminalServer(void);
HRESULT SHCreateFileSysBindCtx(const WIN32_FIND_DATA *pfd, IBindCtx **ppbc);
BOOL DeleteOfflineFilesFolderLink(HWND hwndParent = NULL);
BOOL DeleteOfflineFilesFolderLink_PerfSensitive(HWND hwndParent = NULL);
BOOL ShowHidden(void);
BOOL ShowSuperHidden(void);
BOOL IsSyncMgrInitialized(void);
void SetSyncMgrInitialized(void);
HWND GetProgressDialogWindow(IProgressDialog *ppd);
HRESULT ExpandStringInPlace(LPTSTR psz, DWORD cch);
LONG _RegEnumValueExp(
    HKEY hKey,
    DWORD dwIndex,
    LPTSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData);

//
// Info returned through CSCFindFirst[Next]File APIs.
//
struct CscFindData
{
    WIN32_FIND_DATA fd;
    DWORD           dwStatus;
    DWORD           dwPinCount;
    DWORD           dwHintFlags;
    FILETIME        ft;        
};

HANDLE CacheFindFirst(LPCTSTR pszPath, PSID psid, WIN32_FIND_DATA *pfd, DWORD *pdwStatus, DWORD *pdwPinCount, DWORD *pdwHintFlags, FILETIME *pft);

inline 
HANDLE CacheFindFirst(LPCTSTR pszPath, WIN32_FIND_DATA *pfd, DWORD *pdwStatus, DWORD *pdwPinCount, DWORD *pdwHintFlags, FILETIME *pft)
    { return CacheFindFirst(pszPath, (PSID)NULL, pfd, pdwStatus, pdwPinCount, pdwHintFlags, pft); }

inline 
HANDLE CacheFindFirst(LPCTSTR pszPath, CscFindData *p)
    { return CacheFindFirst(pszPath, &p->fd, &p->dwStatus, &p->dwPinCount, &p->dwHintFlags, &p->ft); }

inline 
HANDLE CacheFindFirst(LPCTSTR pszPath, PSID psid, CscFindData *p)
    { return CacheFindFirst(pszPath, psid, &p->fd, &p->dwStatus, &p->dwPinCount, &p->dwHintFlags, &p->ft); }

BOOL CacheFindNext(HANDLE hFind, WIN32_FIND_DATA *pfd, DWORD *pdwStatus, DWORD *pdwPinCount, DWORD *pdwHintFlags, FILETIME *pft);

inline
BOOL CacheFindNext(HANDLE hFind, CscFindData *p)
    { return CacheFindNext(hFind, &p->fd, &p->dwStatus, &p->dwPinCount, &p->dwHintFlags, &p->ft); }


inline bool IsHiddenSystem(DWORD dwAttr)
{
    return ((dwAttr & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) == (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
}


inline BOOL _PathIsSlow(DWORD dwSpeed) { return (dwSpeed && dwSpeed <= DWORD(CConfig::GetSingleton().SlowLinkSpeed())); }


typedef struct
{
    TCHAR    szVolume[80];         // Volume where CSC cache is stored.
    LONGLONG llBytesOnVolume;      // Disk size (bytes)
    LONGLONG llBytesTotalInCache;  // Size of cache (bytes)
    LONGLONG llBytesUsedInCache;   // Amount of cache used (bytes)
    DWORD    dwNumFilesInCache;    // Files in cache
    DWORD    dwNumDirsInCache;     // Directories in cache

} CSCSPACEUSAGEINFO;

void GetCscSpaceUsageInfo(CSCSPACEUSAGEINFO *psui);

typedef enum _enum_reason
{
    ENUM_REASON_FILE = 0,
    ENUM_REASON_FOLDER_BEGIN,
    ENUM_REASON_FOLDER_END
} ENUM_REASON;

typedef DWORD (WINAPI *PFN_CSCENUMPROC)(LPCTSTR, ENUM_REASON, DWORD, DWORD, DWORD, PWIN32_FIND_DATA, LPARAM);
DWORD _CSCEnumDatabase(LPCTSTR pszFolder, BOOL bRecurse, PFN_CSCENUMPROC pfnCB, LPARAM lpContext);

typedef DWORD (WINAPI *PFN_WIN32ENUMPROC)(LPCTSTR, ENUM_REASON, PWIN32_FIND_DATA, LPARAM);
DWORD _Win32EnumFolder(LPCTSTR pszFolder, BOOL bRecurse, PFN_WIN32ENUMPROC pfnCB, LPARAM lpContext);


//
// Statistical information about a particular network share in the CSC database.
//
typedef struct _CSCSHARESTATS
{
    int cTotal;
    int cPinned;
    int cModified;
    int cSparse;
    int cDirs;
    int cAccessUser;
    int cAccessGuest;
    int cAccessOther;
    bool bOffline;
    bool bOpenFiles;
} CSCSHARESTATS, *PCSCSHARESTATS;

typedef struct
{
    int cShares;
    int cTotal;
    int cPinned;
    int cModified;
    int cSparse;
    int cDirs;
    int cAccessUser;
    int cAccessGuest;
    int cAccessOther;
    int cSharesOffline;
    int cSharesWithOpenFiles;
} CSCCACHESTATS, *PCSCCACHESTATS;


//
// These flags indicate if the enumeration should stop when one or more associated 
// value's exceed 1.  This is useful when you're interested in 0 vs. !0 as opposed
// to an actual count.
// If multiple flags are set, the statistics enumeration continues until the
// values corresponding to ALL set unity flags are non-zero.
//
enum SHARE_STATS_UNITY_FLAGS { SSUF_NONE     = 0x00000000,   // This is the default.
                               SSUF_TOTAL    = 0x00000001,
                               SSUF_PINNED   = 0x00000002,
                               SSUF_MODIFIED = 0x00000004,
                               SSUF_SPARSE   = 0x00000008,
                               SSUF_DIRS     = 0x00000010,
                               SSUF_ACCUSER  = 0x00000020,
                               SSUF_ACCGUEST = 0x00000040,
                               SSUF_ACCOTHER = 0x00000080,
                               SSUF_ACCAND   = 0x00000100, // Must match all set access mask flags.
                               SSUF_ACCOR    = 0x00000200, // Match at least one access mask flag.
                               SSUF_ALL      = 0x000000FF };
//
// These flags indicate if any cache items should be excluded from the enumeration.
// By default, the value is 0 (everything included).  For perf reasons, we use the
// same flags defined in cscapi.h.
//
enum SHARE_STATS_EXCLUDE_FLAGS {
        SSEF_NONE               = 0x00000000,  // Default.  Include everything.
        SSEF_LOCAL_MOD_DATA     = FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED,
        SSEF_LOCAL_MOD_ATTRIB   = FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED,
        SSEF_LOCAL_MOD_TIME     = FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED,
        SSEF_LOCAL_DELETED      = FLAG_CSC_COPY_STATUS_LOCALLY_DELETED,
        SSEF_LOCAL_CREATED      = FLAG_CSC_COPY_STATUS_LOCALLY_CREATED,
        SSEF_STALE              = FLAG_CSC_COPY_STATUS_STALE,
        SSEF_SPARSE             = FLAG_CSC_COPY_STATUS_SPARSE,
        SSEF_ORPHAN             = FLAG_CSC_COPY_STATUS_ORPHAN,
        SSEF_SUSPECT            = FLAG_CSC_COPY_STATUS_SUSPECT,
        SSEF_CSCMASK            = FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED |
                                  FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED |
                                  FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED |
                                  FLAG_CSC_COPY_STATUS_LOCALLY_DELETED |
                                  FLAG_CSC_COPY_STATUS_LOCALLY_CREATED |
                                  FLAG_CSC_COPY_STATUS_STALE |
                                  FLAG_CSC_COPY_STATUS_SPARSE |
                                  FLAG_CSC_COPY_STATUS_ORPHAN |
                                  FLAG_CSC_COPY_STATUS_SUSPECT,
        SSEF_DIRECTORY          = 0x01000000,
        SSEF_FILE               = 0x02000000,
        SSEF_NOACCUSER          = 0x04000000,  // Exclude if no USER access.
        SSEF_NOACCGUEST         = 0x08000000,  // Exclude if no GUEST access.
        SSEF_NOACCOTHER         = 0x10000000,  // Exclude if no OTHER access.
        SSEF_NOACCAND           = 0x20000000   // Treat previous 3 flags as single mask.
        };

typedef struct
{
    DWORD dwExcludeFlags;  // [in] SSEF_XXXXX flags.
    DWORD dwUnityFlags;    // [in] SSUF_XXXXX flags.
    bool bAccessInfo;      // [in] Implied 'T' if unity or exclude access bits are set.
    bool bEnumAborted;     // [out]

} CSCGETSTATSINFO, *PCSCGETSTATSINFO;

BOOL _GetShareStatistics(LPCTSTR pszShare, PCSCGETSTATSINFO pi, PCSCSHARESTATS pss);
BOOL _GetCacheStatistics(PCSCGETSTATSINFO pi, PCSCCACHESTATS pcs);
BOOL _GetShareStatisticsForUser(LPCTSTR pszShare, PCSCGETSTATSINFO pi, PCSCSHARESTATS pss);
BOOL _GetCacheStatisticsForUser(PCSCGETSTATSINFO pi, PCSCCACHESTATS pcs);

// Higher level wrapper for IDA stuff
class CIDArray
{
private:
    STGMEDIUM       m_Medium;
    LPIDA           m_pIDA;
    IShellFolder   *m_psf;

public:
    CIDArray() : m_pIDA(NULL), m_psf(NULL)
    {
        ZeroMemory(&m_Medium, sizeof(m_Medium));
    }

    ~CIDArray();

    HRESULT Initialize(IDataObject *pdobj);

    HRESULT GetFolderPath(LPTSTR pszPath, UINT cch);
    HRESULT GetItemPath(UINT iItem, LPTSTR pszPath, UINT cch, DWORD *pdwAttribs);
    UINT Count() { return m_pIDA ? m_pIDA->cidl : 0; }
};


//
// Trivial class to ensure cleanup of FindFirst/FindNext handles.
// Perf should be as close as possible to a simple handle so most
// operations are defined inline.
// Implementation is in enum.cpp
//
class CCscFindHandle
{
    public:
        CCscFindHandle(HANDLE handle = INVALID_HANDLE_VALUE)
            : m_handle(handle), m_bOwns(INVALID_HANDLE_VALUE != handle) { }

        CCscFindHandle(const CCscFindHandle& rhs)
            : m_handle(INVALID_HANDLE_VALUE), m_bOwns(false)
            { *this = rhs; }

        ~CCscFindHandle(void)
            { Close(); }

        void Close(void);

        HANDLE Detach(void) const
            { m_bOwns = false; return m_handle; }

        void Attach(HANDLE handle)
            { Close(); m_handle = handle; m_bOwns = true; }

        operator HANDLE() const
            { return m_handle; }

        bool IsValid(void) const
            { return INVALID_HANDLE_VALUE != m_handle; }

        CCscFindHandle& operator = (HANDLE handle)
            { Attach(handle); return *this; }

        CCscFindHandle& operator = (const CCscFindHandle& rhs);

    private:
        mutable HANDLE m_handle;
        mutable bool   m_bOwns;
};


class CMutexAutoRelease
{
    public:
        explicit CMutexAutoRelease(HANDLE hmutex)
            : m_hmutex(hmutex) { }

        ~CMutexAutoRelease(void)
        { 
            if (m_hmutex)
            { 
                ReleaseMutex(m_hmutex);
                CloseHandle(m_hmutex);
            }
        }

    private:
        HANDLE m_hmutex;

        CMutexAutoRelease(const CMutexAutoRelease& rhs);
        CMutexAutoRelease& operator = (const CMutexAutoRelease& rhs);
};



//
// Ensures CoInitialize/CoUninitialize is exception-safe.
//
class CCoInit
{
    public:
        CCoInit(void)
            : m_hr(CoInitialize(NULL)) { }

        ~CCoInit(void)
            { if (SUCCEEDED(m_hr)) CoUninitialize(); }

        HRESULT Result(void) const
            { return m_hr; }
    private:
        HRESULT m_hr;
};


// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD FormatSystemError(LPTSTR *ppszResult, DWORD dwSysError);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);


void EnableDlgItems(HWND hwndDlg, const UINT* pCtlIds, int cCtls, bool bEnable);
void ShowDlgItems(HWND hwndDlg, const UINT* pCtlIds, int cCtls, bool bShow);


//
// We commonly use groups of CSC status flags together.
// Define them here so we're consistent throughout the project.
//
#define FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY        (FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_DELETED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_CREATED)

#define FLAG_CSCUI_COPY_STATUS_ALL_DIRTY            (FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_DELETED | \
                                                     FLAG_CSC_COPY_STATUS_LOCALLY_CREATED)

//
// Some helper inlines for querying cache item access information.
//
inline bool CscCheckAccess(DWORD dwShareStatus, DWORD dwShift, DWORD dwAccessType)
{
    return 0 != ((dwShareStatus >> dwShift) & dwAccessType);
}

inline bool CscAccessUserRead(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_USER_ACCESS_SHIFT_COUNT, FLAG_CSC_READ_ACCESS);
}

inline bool CscAccessUserWrite(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_USER_ACCESS_SHIFT_COUNT, FLAG_CSC_WRITE_ACCESS);
}

inline bool CscAccessUser(DWORD dwShareStatus)
{
    return 0 != (dwShareStatus & FLAG_CSC_USER_ACCESS_MASK);
}

inline bool CscAccessGuestRead(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT, FLAG_CSC_READ_ACCESS);
}

inline bool CscAccessGuestWrite(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT, FLAG_CSC_WRITE_ACCESS);
}

inline bool CscAccessGuest(DWORD dwShareStatus)
{
    return 0 != (dwShareStatus & FLAG_CSC_GUEST_ACCESS_MASK);
}

inline bool CscAccessOtherRead(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT, FLAG_CSC_READ_ACCESS);
}

inline bool CscAccessOtherWrite(DWORD dwShareStatus)
{
    return CscCheckAccess(dwShareStatus, FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT, FLAG_CSC_WRITE_ACCESS);
}

inline bool CscAccessOther(DWORD dwShareStatus)
{
    return 0 != (dwShareStatus & FLAG_CSC_OTHER_ACCESS_MASK);
}

inline bool CscCanUserMergeFile(DWORD dwStatus)
{
    return (CscAccessUserWrite(dwStatus) || CscAccessGuestWrite(dwStatus));
}

//
// template inlines avoid the side-effects of min/max macros.
//
template <class T>
inline const T&
MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

template <class T>
inline const T&
MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}

class CWin32Handle
{
    public:
        CWin32Handle(HANDLE handle)
            : m_handle(handle) { }

        CWin32Handle(void)
            : m_handle(NULL) { }

        ~CWin32Handle(void)
            { Close(); }

        void Close(void)
            { if (m_handle) CloseHandle(m_handle); m_handle = NULL; }

        operator HANDLE() const
            { return m_handle; }

        HANDLE *HandlePtr(void)
            { TraceAssert((NULL == m_handle)); return &m_handle; }

    private:
        HANDLE m_handle;

        //
        // Prevent copy.
        // This class is only intended for automatic handle cleanup.
        //
        CWin32Handle(const CWin32Handle& rhs);
        CWin32Handle& operator = (const CWin32Handle& rhs);
};



HRESULT DataObject_SetGlobal(IDataObject *pdtobj, CLIPFORMAT cf, HGLOBAL hGlobal);
HRESULT DataObject_SetDWORD(IDataObject *pdtobj, CLIPFORMAT cf, DWORD dw);
HRESULT DataObject_GetDWORD(IDataObject *pdtobj, CLIPFORMAT cf, DWORD *pdwOut);
HRESULT SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect);
DWORD   GetPreferredDropEffect(IDataObject *pdtobj);
HRESULT SetLogicalPerformedDropEffect(IDataObject *pdtobj, DWORD dwEffect);
DWORD   GetLogicalPerformedDropEffect(IDataObject *pdtobj);



//
// Simple class for automating the display and resetting of a wait cursor.
//
class CAutoWaitCursor
{
    public:
        CAutoWaitCursor(void)
            : m_hCursor(SetCursor(LoadCursor(NULL, IDC_WAIT))) 
            { ShowCursor(TRUE); }

        ~CAutoWaitCursor(void)
            { Reset(); }

        void Reset(void);

    private:
        HCURSOR m_hCursor;
};



class CAutoSetRedraw
{
    public:
        CAutoSetRedraw(HWND hwnd)
            : m_hwnd(hwnd) { }

        CAutoSetRedraw(HWND hwnd, bool bSet)
            : m_hwnd(hwnd) { Set(bSet); }

        ~CAutoSetRedraw(void)
            { Set(true); }

        void Set(bool bSet)
            { SendMessage(m_hwnd, WM_SETREDRAW, (WPARAM)bSet, 0); }

    private:
        HWND m_hwnd;
};




#endif  // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\util.cpp ===
#include "pch.h"
#include <shsemip.h>    // ILClone, ILIsEmpty, etc.
#include <sddl.h>
#include "security.h"
#include "shguidp.h"
#include "folder.h"
#include "strings.h"
#include <ccstock.h>

#ifdef DEBUG
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "CSC UI"
#define  SZ_MODULE          "CSCUI.DLL"
// (These are deliberately CHAR)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipMsg[] = SZ_MODULE "  RIP: ";
#endif

//
//  Purpose:    Return UNC version of a path
//
//  Parameters: pszInName - initial path
//              ppszOutName - UNC path returned here
//
//
//  Return:     HRESULT
//              S_OK - UNC path returned
//              S_FALSE - drive not connected (UNC not returned)
//              or failure code
//
//  Notes:      The function fails is the path is not a valid
//              network path.  If the path is already UNC,
//              a copy is made without validating the path.
//              *ppszOutName must be LocalFree'd by the caller.
//

HRESULT GetRemotePath(LPCTSTR pszInName, LPTSTR *ppszOutName)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

    *ppszOutName = NULL;

    // Don't bother calling GetFullPathName first, since we always
    // deal with full (complete) paths.

    if (pszInName[1] == TEXT(':'))
    {
        TCHAR szLocalName[3];

        szLocalName[0] = pszInName[0];
        szLocalName[1] = pszInName[1];
        szLocalName[2] = 0;

        // Call GetDriveType before WNetGetConnection, to avoid loading
        // MPR.DLL until absolutely necessary.
        if (DRIVE_REMOTE == GetDriveType(szLocalName))
        {
            TCHAR szRemoteName[MAX_PATH];
            DWORD dwLen = ARRAYSIZE(szRemoteName);
            DWORD dwErr = WNetGetConnection(szLocalName, szRemoteName, &dwLen);
            if (NO_ERROR == dwErr)
            {
                size_t cch = lstrlen(szRemoteName);
                // Skip the drive letter and add the length of the rest of the path
                // (including NULL)
                pszInName += 2;
                cch += lstrlen(pszInName) + 1;

                // We should never get incomplete paths, so we should always
                // see a backslash after the "X:".  If this isn't true, then
                // we should call GetFullPathName above.
                TraceAssert(TEXT('\\') == *pszInName);

                // Allocate the return buffer
                *ppszOutName = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
                if (*ppszOutName)
                {
                    LPTSTR pszRemaining;
                    hr = StringCchCopyEx(*ppszOutName, cch, szRemoteName, &pszRemaining, &cch, 0);  // root part
                    // We allocated a big enough buffer, so this should never fail
                    ASSERT(SUCCEEDED(hr));
                    hr = StringCchCopy(pszRemaining, cch, pszInName);    // rest of path
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else if (ERROR_NOT_CONNECTED == dwErr)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else if (PathIsUNC(pszInName))
    {
        // Just copy the path without validating it
        hr = LocalAllocString(ppszOutName, pszInName) ? S_OK : E_OUTOFMEMORY;
    }

    if (S_OK == hr)
        PathRemoveBackslash(*ppszOutName);

    return hr;
}

//
//  Purpose:    TCHAR version of itoa
//
//  Parameters: UINT i - unsigned integer to convert
//              LPTSTR psz - location to store string result
//              UINT cchMax - size of buffer pointed to by psz
//

LPTSTR ULongToString(ULONG i, LPTSTR psz, ULONG cchMax)
{
    wnsprintf(psz, cchMax, TEXT("%d"), i);
    return psz;
}

//
//  Purpose:    Free a string allocated with LocalAlloc[String]
//
//  Parameters: LPTSTR *ppsz - location of pointer to string
//

void LocalFreeString(LPTSTR *ppsz)
{
    if (ppsz && *ppsz)
    {
        LocalFree(*ppsz);
        *ppsz = NULL;
    }
}

//
//  Purpose:    Copy a string into a newly allocated buffer
//
//  Parameters: LPTSTR *ppszDest - location to store string copy
//              LPCTSTR pszSrc - string to copy
//
//  Return:     BOOL - FALSE if LocalAlloc fails or invalid parameters
//

BOOL LocalAllocString(LPTSTR *ppszDest, LPCTSTR pszSrc)
{
    if (!ppszDest)
        return FALSE;

    *ppszDest = StrDup(pszSrc);
    return *ppszDest ? TRUE : FALSE;
}

//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}

//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//

int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}

//
//  Purpose:    Wrapper for SHChangeNotify
//
//  Parameters: pszPath - path of file that changed
//              bFlush - TRUE forces a flush of the shell's
//                       notify queue.
//
//  Return:     none
//
//  Notes:      SHCNF_PATH doesn't work outside of the shell,
//              so we create a pidl and use SHCNF_IDLIST.
//
//              Force a flush every 8 calls so the shell
//              doesn't start ignoring notifications.
//

void
ShellChangeNotify(
    LPCTSTR pszPath,
    WIN32_FIND_DATA *pfd,
    BOOL bFlush,
    LONG nEvent
    )
{
    LPITEMIDLIST pidlFile = NULL;
    LPCVOID pvItem = NULL;
    UINT uFlags = 0;

    static int cNoFlush = 0;

    if (pszPath)
    {
        if ((pfd && SUCCEEDED(SHSimpleIDListFromFindData(pszPath, pfd, &pidlFile)))
            || (pidlFile = ILCreateFromPath(pszPath)))
        {
            uFlags = SHCNF_IDLIST;
            pvItem = pidlFile;
        }
        else
        {
            // ILCreateFromPath sometimes fails when we're in disconnected
            // mode, so try the path instead.
            uFlags = SHCNF_PATH;
            pvItem = pszPath;
        }
        if (0 == nEvent)
            nEvent = SHCNE_UPDATEITEM;
    }
    else
        nEvent = 0;

    if (8 < cNoFlush++)
        bFlush = TRUE;

    if (bFlush)
    {
        uFlags |= (SHCNF_FLUSH | SHCNF_FLUSHNOWAIT);
        cNoFlush = 0;
    }
    SHChangeNotify(nEvent, uFlags, pvItem, NULL);

    if (pidlFile)
        SHFree(pidlFile);
}


//
//  Purpose:    Get the path to the target file of a link
//
//  Parameters: pszShortcut - name of link file
//              ppszTarget - target path returned here
//
//
//  Return:     HRESULT
//              S_OK - target file returned
//              S_FALSE - target not returned
//              or failure code
//
//  Notes:      COM must be initialized before calling.
//              The function fails is the target is a folder.
//              *ppszTarget must be LocalFree'd by the caller.
//

HRESULT GetLinkTarget(LPCTSTR pszShortcut, LPTSTR *ppszTarget, DWORD *pdwAttr)
{
    *ppszTarget = NULL;

    if (pdwAttr)
        *pdwAttr = 0;

    IShellLink *psl;
    HRESULT hr = LoadFromFile(CLSID_ShellLink, pszShortcut, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        // Get the pidl of the target
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            hr = S_FALSE;   // means no target returned
            TCHAR szTarget[MAX_PATH];
            DWORD dwAttr = SFGAO_FOLDER;
            if (SUCCEEDED(SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, szTarget, ARRAYSIZE(szTarget), &dwAttr)))
            {
                if (!(dwAttr & SFGAO_FOLDER))
                {
                    if (pdwAttr)
                    {
                        *pdwAttr = GetFileAttributes(szTarget);
                    }
                    hr = GetRemotePath(szTarget, ppszTarget);
                }
            }
            SHFree(pidlTarget);
        }
        psl->Release();
    }

    TraceLeaveResult(hr);
}


//*************************************************************
//
//  _CSCEnumDatabase
//
//  Purpose:    Enumerate CSC database recursively
//
//  Parameters: pszFolder - name of folder to begin enumeration
//                          (can be NULL to enum shares)
//              bRecurse - TRUE to recurse into child folders
//              pfnCB - callback function called once for each child
//              lpContext - extra data passed to callback function
//
//  Return:     One of CSCPROC_RETURN_*
//
//  Notes:      Return CSCPROC_RETURN_SKIP from the callback to prevent
//              recursion into a child folder. CSCPROC_RETURN_ABORT
//              will terminate the entire operation (unwind all recursive
//              calls). CSCPROC_RETURN_CONTINUE will continue normally.
//              Other CSCPROC_RETURN_* values are treated as ABORT.
//
//*************************************************************
#define PATH_BUFFER_SIZE    1024

typedef struct
{
    LPTSTR              szPath;
    int                 cchPathBuffer;
    BOOL                bRecurse;
    PFN_CSCENUMPROC     pfnCB;
    LPARAM              lpContext;
} CSC_ENUM_CONTEXT, *PCSC_ENUM_CONTEXT;

DWORD
_CSCEnumDatabaseInternal(PCSC_ENUM_CONTEXT pContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    HANDLE hFind;
    DWORD dwStatus = 0;
    DWORD dwPinCount = 0;
    DWORD dwHintFlags = 0;
    LPTSTR pszPath;
    int cchBuffer;
    LPTSTR pszFind = NULL;
    int cchDir = 0;
    WIN32_FIND_DATA fd;

    TraceEnter(TRACE_UTIL, "_CSCEnumDatabaseInternal");
    TraceAssert(pContext);
    TraceAssert(pContext->pfnCB);
    TraceAssert(pContext->szPath);
    TraceAssert(pContext->cchPathBuffer);

    pszPath = pContext->szPath;
    cchBuffer = pContext->cchPathBuffer;

    if (*pszPath)
    {
        cchDir = lstrlen(pszPath);
        TraceAssert(cchDir > 0 && pszPath[cchDir-1] != TEXT('\\')); // no backslash yet
        TraceAssert(cchDir + 1 < cchBuffer);                        // room for backslash
        pszPath[cchDir++] = TEXT('\\');
        pszPath[cchDir] = TEXT('\0');
        pszFind = pszPath;
    }

    // skips "." and ".."
    hFind = CacheFindFirst(pszFind,
                           &fd,
                           &dwStatus,
                           &dwPinCount,
                           &dwHintFlags,
                           NULL);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            int cchFile;
            ENUM_REASON eReason = ENUM_REASON_FILE;

            cchFile = lstrlen(fd.cFileName);
            if (cchFile >= cchBuffer - cchDir)
            {
                // Realloc the path buffer
                TraceMsg("Reallocating path buffer");
                cchBuffer += max(PATH_BUFFER_SIZE, cchFile + 1);
                pszPath = (LPTSTR)LocalReAlloc(pContext->szPath,
                                               cchBuffer * sizeof(TCHAR),
                                               LMEM_MOVEABLE);
                if (pszPath)
                {
                    pContext->szPath = pszPath;
                    pContext->cchPathBuffer = cchBuffer;
                }
                else
                {
                    pszPath = pContext->szPath;
                    cchBuffer = pContext->cchPathBuffer;
                    TraceMsg("Unable to reallocate path buffer");
                    Trace((pszPath));
                    Trace((fd.cFileName));
                    continue;
                }
            }

            // Build full path.  We just reallocated the buffer
            // if necessary, so this should never fail.
            StringCchCopy(pszPath + cchDir, cchBuffer - cchDir, fd.cFileName);
            cchFile = lstrlen(pszPath);

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || !pszFind)
                eReason = ENUM_REASON_FOLDER_BEGIN;

            // Call the callback
            dwResult = (*pContext->pfnCB)(pszPath,
                                          eReason,
                                          dwStatus,
                                          dwHintFlags,
                                          dwPinCount,
                                          &fd,
                                          pContext->lpContext);

            // Recurse into folders
            if (CSCPROC_RETURN_CONTINUE == dwResult &&
                pContext->bRecurse &&
                ENUM_REASON_FOLDER_BEGIN == eReason)
            {
                dwResult = _CSCEnumDatabaseInternal(pContext);

                // Call the callback again
                pszPath[cchFile] = 0;
                dwResult = (*pContext->pfnCB)(pszPath,
                                              ENUM_REASON_FOLDER_END,
                                              0, // dwStatus,       // these have probably changed
                                              0, // dwHintFlags,
                                              0, // dwPinCount,
                                              &fd,
                                              pContext->lpContext);
            }

            if (CSCPROC_RETURN_SKIP == dwResult)
                dwResult = CSCPROC_RETURN_CONTINUE;

            if (CSCPROC_RETURN_CONTINUE != dwResult)
                break;

        } while (CacheFindNext(hFind,
                               &fd,
                               &dwStatus,
                               &dwPinCount,
                               &dwHintFlags,
                               NULL));
        CSCFindClose(hFind);
    }

    TraceLeaveValue(dwResult);
}


DWORD
_CSCEnumDatabase(LPCTSTR pszFolder,
                 BOOL bRecurse,
                 PFN_CSCENUMPROC pfnCB,
                 LPARAM lpContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    CSC_ENUM_CONTEXT ec;

    TraceEnter(TRACE_UTIL, "_CSCEnumDatabase");
    TraceAssert(pfnCB);

    if (!pfnCB)
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    // Allocate the single buffer used for the entire enumeration.
    // It will be reallocated later if necessary.
    size_t cchFolder = pszFolder ? lstrlen(pszFolder) : 0;
    ec.cchPathBuffer = ((cchFolder/PATH_BUFFER_SIZE) + 1) * PATH_BUFFER_SIZE;
    ec.szPath = (LPTSTR)LocalAlloc(LMEM_FIXED, ec.cchPathBuffer*sizeof(TCHAR));
    if (!ec.szPath)
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    ec.szPath[0] = TEXT('\0');

    // Assume pszFolder is valid a directory path or NULL
    if (pszFolder)
    {
        // We made sure the buffer was big enough for this above
        StringCchCopy(ec.szPath, ec.cchPathBuffer, pszFolder);

        // _CSCEnumDatabaseInternal assumes there is no trailing backslash
        if (cchFolder && ec.szPath[cchFolder-1] == TEXT('\\'))
        {
            ec.szPath[cchFolder-1] = TEXT('\0');
        }
    }

    ec.bRecurse = bRecurse;
    ec.pfnCB = pfnCB;
    ec.lpContext = lpContext;

    dwResult = _CSCEnumDatabaseInternal(&ec);

    LocalFree(ec.szPath);

    TraceLeaveValue(dwResult);
}


//*************************************************************
//
//  _Win32EnumFolder
//
//  Purpose:    Enumerate a directory recursively
//
//  Parameters: pszFolder - name of folder to begin enumeration
//              bRecurse - TRUE to recurse into child folders
//              pfnCB - callback function called once for each child
//              lpContext - extra data passed to callback function
//
//  Return:     One of CSCPROC_RETURN_*
//
//  Notes:      Same as _CSCEnumDatabase except using FindFirstFile
//              instead of CSCFindFirstFile.
//
//*************************************************************

typedef struct
{
    LPTSTR              szPath;
    int                 cchPathBuffer;
    BOOL                bRecurse;
    PFN_WIN32ENUMPROC   pfnCB;
    LPARAM              lpContext;
} W32_ENUM_CONTEXT, *PW32_ENUM_CONTEXT;

DWORD
_Win32EnumFolderInternal(PW32_ENUM_CONTEXT pContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    HANDLE hFind;
    LPTSTR pszPath;
    int cchBuffer;
    int cchDir = 0;
    WIN32_FIND_DATA fd;

    TraceEnter(TRACE_UTIL, "_Win32EnumFolderInternal");
    TraceAssert(pContext);
    TraceAssert(pContext->pfnCB);
    TraceAssert(pContext->szPath && pContext->szPath[0]);
    TraceAssert(pContext->cchPathBuffer);

    pszPath = pContext->szPath;
    cchBuffer = pContext->cchPathBuffer;

    // Build wildcard path
    cchDir = lstrlen(pszPath);
    TraceAssert(cchDir > 0 && pszPath[cchDir-1] != TEXT('\\')); // no backslash yet
    TraceAssert(cchDir + 2 < cchBuffer);                        // room for "\\*"
    pszPath[cchDir++] = TEXT('\\');
    pszPath[cchDir] = TEXT('*');
    pszPath[cchDir+1] = 0;

    hFind = FindFirstFile(pszPath, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            int cchFile;
            ENUM_REASON eReason = ENUM_REASON_FILE;

            // skip "." and ".."
            if (PathIsDotOrDotDot(fd.cFileName))
                continue;

            cchFile = lstrlen(fd.cFileName);
            if (cchFile >= cchBuffer - cchDir)
            {
                // Realloc the path buffer
                TraceMsg("Reallocating path buffer");
                cchBuffer += max(PATH_BUFFER_SIZE, cchFile + 1);
                pszPath = (LPTSTR)LocalReAlloc(pContext->szPath,
                                               cchBuffer * sizeof(TCHAR),
                                               LMEM_MOVEABLE);
                if (pszPath)
                {
                    pContext->szPath = pszPath;
                    pContext->cchPathBuffer = cchBuffer;
                }
                else
                {
                    pszPath = pContext->szPath;
                    cchBuffer = pContext->cchPathBuffer;
                    TraceMsg("Unable to reallocate path buffer");
                    Trace((pszPath));
                    Trace((fd.cFileName));
                    continue;
                }
            }

            // Build full path.  We just reallocated the buffer
            // if necessary, so this should never fail.
            StringCchCopy(pszPath + cchDir, cchBuffer - cchDir, fd.cFileName);
            cchFile = lstrlen(pszPath);

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                eReason = ENUM_REASON_FOLDER_BEGIN;

            // Call the callback
            dwResult = (*pContext->pfnCB)(pszPath,
                                          eReason,
                                          &fd,
                                          pContext->lpContext);

            // Recurse into folders
            if (CSCPROC_RETURN_CONTINUE == dwResult &&
                pContext->bRecurse &&
                ENUM_REASON_FOLDER_BEGIN == eReason)
            {
                dwResult = _Win32EnumFolderInternal(pContext);

                // Call the callback again
                pszPath[cchFile] = 0;
                dwResult = (*pContext->pfnCB)(pszPath,
                                              ENUM_REASON_FOLDER_END,
                                              &fd,
                                              pContext->lpContext);
            }

            if (CSCPROC_RETURN_SKIP == dwResult)
                dwResult = CSCPROC_RETURN_CONTINUE;

            if (CSCPROC_RETURN_CONTINUE != dwResult)
                break;

        } while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    TraceLeaveValue(dwResult);
}


DWORD
_Win32EnumFolder(LPCTSTR pszFolder,
                 BOOL bRecurse,
                 PFN_WIN32ENUMPROC pfnCB,
                 LPARAM lpContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    W32_ENUM_CONTEXT ec;

    TraceEnter(TRACE_UTIL, "_Win32EnumFolder");
    TraceAssert(pszFolder);
    TraceAssert(pfnCB);

    if (!pszFolder || !*pszFolder || !pfnCB)
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    // Allocate the single buffer used for the entire enumeration.
    // It will be reallocated later if necessary.
    size_t cchFolder = lstrlen(pszFolder);
    ec.cchPathBuffer = ((cchFolder/PATH_BUFFER_SIZE) + 1) * PATH_BUFFER_SIZE;
    ec.szPath = (LPTSTR)LocalAlloc(LMEM_FIXED, ec.cchPathBuffer*sizeof(TCHAR));
    if (!ec.szPath)
        TraceLeaveValue(CSCPROC_RETURN_ABORT);

    // Assume pszFolder is valid a directory path
    // We made sure the buffer was big enough for this above
    StringCchCopy(ec.szPath, ec.cchPathBuffer, pszFolder);

    // _Win32EnumFolderInternal assumes there is no trailing backslash
    if (cchFolder && ec.szPath[cchFolder-1] == TEXT('\\'))
    {
        ec.szPath[cchFolder-1] = TEXT('\0');
    }

    ec.bRecurse = bRecurse;
    ec.pfnCB = pfnCB;
    ec.lpContext = lpContext;

    dwResult = _Win32EnumFolderInternal(&ec);

    LocalFree(ec.szPath);

    TraceLeaveValue(dwResult);
}

CIDArray::~CIDArray()
{
    DoRelease(m_psf);
    if (m_pIDA)
    {
        GlobalUnlock(m_Medium.hGlobal);
        m_pIDA = NULL;
    }
    ReleaseStgMedium(&m_Medium);
}

HRESULT CIDArray::Initialize(IDataObject *pdobj)
{
    TraceAssert(NULL == m_pIDA);
    FORMATETC fe = { g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    HRESULT hr = pdobj->GetData(&fe, &m_Medium);
    if (SUCCEEDED(hr))
    {
        m_pIDA = (LPIDA)GlobalLock(m_Medium.hGlobal);
        if (m_pIDA)
        {
            LPCITEMIDLIST pidlFolder = (LPCITEMIDLIST)ByteOffset(m_pIDA, m_pIDA->aoffset[0]);
            hr = SHBindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder, &m_psf));
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CIDArray::GetItemPath(UINT iItem, LPTSTR pszPath, UINT cchPath, DWORD *pdwAttribs)
{
    HRESULT hr = E_INVALIDARG;

    if (m_psf && m_pIDA && (iItem < m_pIDA->cidl))
    {
        LPCITEMIDLIST pidlChild, pidl = (LPCITEMIDLIST)ByteOffset(m_pIDA, m_pIDA->aoffset[iItem + 1]);
        IShellFolder *psf;
        hr = SHBindToFolderIDListParent(m_psf, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
        if (SUCCEEDED(hr))
        {
            if (pszPath)
            {
                hr = DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING, pszPath, cchPath);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszRemote;
                    if (S_OK == GetRemotePath(pszPath, &pszRemote))
                    {
                        hr = StringCchCopy(pszPath, cchPath, pszRemote);
                        LocalFree(pszRemote);
                    }
                }
            }

            if (SUCCEEDED(hr) && pdwAttribs)
                hr = psf->GetAttributesOf(1, &pidlChild, pdwAttribs);

            psf->Release();
        }
    }
    return hr;
}

HRESULT CIDArray::GetFolderPath(LPTSTR pszPath, UINT cchPath)
{
    HRESULT hr = GetItemPath(0, pszPath, cchPath, NULL);
    if (SUCCEEDED(hr))
    {
        PathRemoveFileSpec(pszPath);
    }
    return hr;
}


//*************************************************************
//
//  CCscFileHandle non-inline member functions.
//
//*************************************************************
CCscFindHandle& 
CCscFindHandle::operator = (
    const CCscFindHandle& rhs
    )
{
    if (this != &rhs)
    {
        Attach(rhs.Detach());
    }
    return *this;
}


void 
CCscFindHandle::Close(
    void
    )
{ 
    if (m_bOwns && INVALID_HANDLE_VALUE != m_handle)
    { 
        CSCFindClose(m_handle); 
    }
    m_bOwns  = false;
    m_handle = INVALID_HANDLE_VALUE;
}



//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}

DWORD
FormatSystemError(LPTSTR *ppszResult, DWORD dwSysError)
{
    LPTSTR pszBuffer = NULL;
    DWORD dwResult = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | 
                                   FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
                                   NULL,
                                   dwSysError,
                                   0,
                                   (LPTSTR)&pszBuffer,
                                   1,
                                   NULL);

    if (NULL != pszBuffer)
    {
        *ppszResult = pszBuffer;
    }
    return dwResult;
}

//
// Center a window in it's parent.
// If hwndParent is NULL, the window's parent is used.
// If hwndParent is not NULL, hwnd is centered in it.
// If hwndParent is NULL and hwnd doesn't have a parent, it is centered
// on the desktop.
//
void
CenterWindow(
    HWND hwnd, 
    HWND hwndParent
    )
{
    RECT rcScreen;

    if (NULL != hwnd)
    {
        rcScreen.left   = rcScreen.top = 0;
        rcScreen.right  = GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = GetSystemMetrics(SM_CYSCREEN);

        if (NULL == hwndParent)
        {
            hwndParent = GetParent(hwnd);
            if (NULL == hwndParent)
                hwndParent = GetDesktopWindow();
        }

        RECT rcWnd;
        RECT rcParent;

        GetWindowRect(hwnd, &rcWnd);
        GetWindowRect(hwndParent, &rcParent);

        INT cxWnd    = rcWnd.right  - rcWnd.left;
        INT cyWnd    = rcWnd.bottom - rcWnd.top;
        INT cxParent = rcParent.right  - rcParent.left;
        INT cyParent = rcParent.bottom - rcParent.top;
        POINT ptParentCtr;

        ptParentCtr.x = rcParent.left + (cxParent / 2);
        ptParentCtr.y = rcParent.top  + (cyParent / 2);

        if ((ptParentCtr.x + (cxWnd / 2)) > rcScreen.right)
        {
            //
            // Window would run off the right edge of the screen.
            //
            rcWnd.left = rcScreen.right - cxWnd;
        }
        else if ((ptParentCtr.x - (cxWnd / 2)) < rcScreen.left)
        {
            //
            // Window would run off the left edge of the screen.
            //
            rcWnd.left = rcScreen.left;
        }
        else
        {
            rcWnd.left = ptParentCtr.x - (cxWnd / 2);
        }

        if ((ptParentCtr.y + (cyWnd / 2)) > rcScreen.bottom)
        {
            //
            // Window would run off the bottom edge of the screen.
            //
            rcWnd.top = rcScreen.bottom - cyWnd;
        }
        else if ((ptParentCtr.y - (cyWnd / 2)) < rcScreen.top)
        {
            //
            // Window would run off the top edge of the screen.
            //
            rcWnd.top = rcScreen.top;
        }
        else
        {
            rcWnd.top = ptParentCtr.y - (cyWnd / 2);
        }

        MoveWindow(hwnd, rcWnd.left, rcWnd.top, cxWnd, cyWnd, TRUE);
    }
}

//
// We have some extra stuff to pass to the stats callback so we wrap the
// CSCSHARESTATS in a larger structure.
//
typedef struct
{
    CSCSHARESTATS ss;       // The stats data.
    DWORD dwUnityFlagsReq;  // SSUF_XXXX flags set by user (requested).
    DWORD dwUnityFlagsSum;  // SSUF_XXXX flags set during enum (sum total).
    DWORD dwExcludeFlags;   // SSEF_XXXX flags.
    bool bEnumAborted;      // true if unity flags satisfied.

} CSCSHARESTATS_CBKINFO, *PCSCSHARESTATS_CBKINFO;


//
// Called by CSCEnumForStats for each CSC item enumerated.
//
DWORD
_CscShareStatisticsCallback(LPCTSTR             lpszName,
                            DWORD               dwStatus,
                            DWORD               dwHintFlags,
                            DWORD               dwPinCount,
                            WIN32_FIND_DATA    *lpFind32,
                            DWORD               dwReason,
                            DWORD               dwParam1,
                            DWORD               dwParam2,
                            DWORD_PTR           dwContext)
{
    DWORD dwResult = CSCPROC_RETURN_CONTINUE;

    if (CSCPROC_REASON_BEGIN != dwReason &&   // Not "start of data" notification.
        CSCPROC_REASON_END != dwReason &&     // Not "end of data" notification.
        1 != dwParam2)                        // Not "share root" entry.
    {
        PCSCSHARESTATS_CBKINFO pssci = (PCSCSHARESTATS_CBKINFO)(dwContext);
        PCSCSHARESTATS pss = &(pssci->ss);
        const DWORD dwExcludeFlags  = pssci->dwExcludeFlags;
        const DWORD dwUnityFlagsReq = pssci->dwUnityFlagsReq;
        const bool bIsDir           = (0 == dwParam1);
        const bool bAccessUser      = CscAccessUser(dwStatus);
        const bool bAccessGuest     = CscAccessGuest(dwStatus);
        const bool bAccessOther     = CscAccessOther(dwStatus);

        if (0 != dwExcludeFlags)
        {
            //
            // Caller want's to exclude some items from the enumeration.
            // If item is in "excluded" specification, return early.
            //
            if (0 != (dwExcludeFlags & (dwStatus & SSEF_CSCMASK)))
            {
                return dwResult;
            }
            if ((bIsDir && (dwExcludeFlags & SSEF_DIRECTORY)) || 
                (!bIsDir && (dwExcludeFlags & SSEF_FILE)))
            {
                return dwResult;
            }

            const struct
            {
                DWORD fExclude;
                bool bAccess;
                BYTE  fMask;

            } rgExclAccess[] = {{ SSEF_NOACCUSER,  bAccessUser,  0x01 },
                                { SSEF_NOACCGUEST, bAccessGuest, 0x02 },
                                { SSEF_NOACCOTHER, bAccessOther, 0x04 }};

            BYTE fExcludeMask = 0;
            BYTE fNoAccessMask  = 0;
            for (int i = 0; i < ARRAYSIZE(rgExclAccess); i++)
            {
                if (dwExcludeFlags & rgExclAccess[i].fExclude)
                    fExcludeMask |= rgExclAccess[i].fMask;

                if (!rgExclAccess[i].bAccess)
                    fNoAccessMask |= rgExclAccess[i].fMask;
            }

            if (SSEF_NOACCAND & dwExcludeFlags)
            {
                //
                // Treat all access exclusion flags as a single unit.
                //
                if (fExcludeMask == fNoAccessMask)
                    return dwResult;
            }
            else
            {
                //
                // Treat each access flag individually.  Only one specified access
                // condition must be true to exclude this file.
                //
                if (fExcludeMask & fNoAccessMask)
                    return dwResult;
            }
        }

        if (0 == (SSEF_DIRECTORY & dwExcludeFlags) || !bIsDir)
        {
            pss->cTotal++;
            pssci->dwUnityFlagsSum |= SSUF_TOTAL;

            if (0 != (dwHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_ADMIN)))
            {
                pss->cPinned++;
                pssci->dwUnityFlagsSum |= SSUF_PINNED;
            }
            if (0 != (dwStatus & FLAG_CSCUI_COPY_STATUS_ALL_DIRTY))
            {
                //
                // If the current user doesn't have sufficient access
                // to merge offline changes, then someone else must have
                // modified the file, so don't count it for this user.
                //
                if (bIsDir || CscCanUserMergeFile(dwStatus))
                {
                    pss->cModified++;
                    pssci->dwUnityFlagsSum |= SSUF_MODIFIED;
                }
            }

            const struct
            {
                DWORD flag;
                int  *pCount;
                bool bAccess;

            } rgUnity[] = {{ SSUF_ACCUSER,  &pss->cAccessUser,  bAccessUser  },
                           { SSUF_ACCGUEST, &pss->cAccessGuest, bAccessGuest },
                           { SSUF_ACCOTHER, &pss->cAccessOther, bAccessOther }};

            DWORD fUnityMask  = 0;
            DWORD fAccessMask = 0;
            for (int i = 0; i < ARRAYSIZE(rgUnity); i++)
            {
                if (dwUnityFlagsReq & rgUnity[i].flag)
                    fUnityMask |= rgUnity[i].flag;

                if (rgUnity[i].bAccess)
                {
                    (*rgUnity[i].pCount)++;
                    fAccessMask |= rgUnity[i].flag;
                }
            }
            if (SSUF_ACCAND & dwUnityFlagsReq)
            {
                //
                // Treat all access unity flags as a single unit.
                // We only signal unity if all of the specified access 
                // unity conditions are true.
                //
                if (fUnityMask == fAccessMask)
                    pssci->dwUnityFlagsSum |= fUnityMask;
            }
            else
            {
                //
                // Treat all access exclusion flags individually.
                //
                if (fUnityMask & fAccessMask)
                {
                    if (SSUF_ACCOR & dwUnityFlagsReq)
                        pssci->dwUnityFlagsSum |= fUnityMask;
                    else
                        pssci->dwUnityFlagsSum |= fAccessMask;
                }
            }

            if (bIsDir)
            {
                pss->cDirs++;
                pssci->dwUnityFlagsSum |= SSUF_DIRS;
            }
            // Note the 'else': don't count dirs in the sparse total
            else if (0 != (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE))
            {
                pss->cSparse++;
                pssci->dwUnityFlagsSum |= SSUF_SPARSE;
            }

            if (0 != dwUnityFlagsReq)
            {
                //
                // Abort enumeration if all of the requested SSUF_XXXX unity flags 
                // have been set.
                //
                if (dwUnityFlagsReq == (dwUnityFlagsReq & pssci->dwUnityFlagsSum))
                {
                   dwResult = CSCPROC_RETURN_ABORT;
                   pssci->bEnumAborted;
                }
            }
        }
    }

    return dwResult;
}

//
// Enumerate all items for a given share and tally up the
// relevant information like file count, pinned count etc.
// Information is returned through *pss.
//
BOOL
_GetShareStatistics(
    LPCTSTR pszShare, 
    PCSCGETSTATSINFO pi,
    PCSCSHARESTATS pss
    )
{
    typedef BOOL (WINAPI * PFNENUMFORSTATS)(LPCTSTR, LPCSCPROC, DWORD_PTR);

    CSCSHARESTATS_CBKINFO ssci;
    BOOL bResult;
    DWORD dwShareStatus = 0;
    PFNENUMFORSTATS pfnEnumForStats = CSCEnumForStats;

    ZeroMemory(&ssci, sizeof(ssci));
    ssci.dwUnityFlagsReq = pi->dwUnityFlags;
    ssci.dwExcludeFlags  = pi->dwExcludeFlags;

    if (pi->bAccessInfo ||
        (pi->dwUnityFlags & (SSUF_ACCUSER | SSUF_ACCGUEST | SSUF_ACCOTHER)) ||
        (pi->dwExcludeFlags & (SSEF_NOACCUSER | SSEF_NOACCGUEST | SSEF_NOACCOTHER)))
    {
        //
        // If the enumeration requires access information, use the "ex" version
        // of the EnumForStats CSC api.  Only use it if necessary because gathering
        // the access information has a perf cost.
        //
        pfnEnumForStats = CSCEnumForStatsEx;
    }

    pi->bEnumAborted = false;

    bResult = (*pfnEnumForStats)(pszShare, _CscShareStatisticsCallback, (DWORD_PTR)&ssci);
    *pss = ssci.ss;

    if (CSCQueryFileStatus(pszShare, &dwShareStatus, NULL, NULL))
    {
        if (FLAG_CSC_SHARE_STATUS_FILES_OPEN & dwShareStatus)
        {
            pss->bOpenFiles = true;
        }
        if (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & dwShareStatus)
        {
            pss->bOffline = true;
        }
    }
    pi->bEnumAborted = ssci.bEnumAborted;

    return bResult;
}

//
// Retrieve the statistics for the entire cache.
// This is a simple wrapper that calls _GetShareStatistics for each share
// in the cache then sums the results for the entire cache.  It accepts
// the same unity and exclusion flags used by _GetShareStatistics.
//
BOOL
_GetCacheStatistics(
    PCSCGETSTATSINFO pi,
    PCSCCACHESTATS pcs
    )
{
    BOOL bResult = TRUE;
    WIN32_FIND_DATA fd;
    CSCSHARESTATS ss;

    ZeroMemory(pcs, sizeof(*pcs));

    pi->bEnumAborted = false;

    CCscFindHandle hFind(CacheFindFirst(NULL, &fd, NULL, NULL, NULL, NULL));
    if (hFind.IsValid())
    {
        do
        {
            pcs->cShares++;
            if (bResult = _GetShareStatistics(fd.cFileName, 
                                              pi,
                                              &ss))
            {
                pcs->cTotal               += ss.cTotal;
                pcs->cPinned              += ss.cPinned;
                pcs->cModified            += ss.cModified;
                pcs->cSparse              += ss.cSparse;
                pcs->cDirs                += ss.cDirs;
                pcs->cAccessUser          += ss.cAccessUser;
                pcs->cAccessGuest         += ss.cAccessGuest;
                pcs->cAccessOther         += ss.cAccessOther;
                pcs->cSharesOffline       += int(ss.bOffline);
                pcs->cSharesWithOpenFiles += int(ss.bOpenFiles);
            }
        }
        while(bResult && !pi->bEnumAborted && CacheFindNext(hFind, &fd, NULL, NULL, NULL, NULL));
    }

    return bResult;
}


//
// Sets the proper exclusion flags to report only on files accessible by the
// logged on user.  Otherwise it's the same as calling _GetShareStatistics.
//
BOOL
_GetShareStatisticsForUser(
    LPCTSTR pszShare, 
    PCSCGETSTATSINFO pi,
    PCSCSHARESTATS pss
    )
{
    pi->dwExcludeFlags |= SSEF_NOACCUSER | SSEF_NOACCGUEST | SSEF_NOACCAND;
    return _GetShareStatistics(pszShare, pi, pss);
}


//
// Sets the proper exclusion flags to report only on files accessible by the
// logged on user.  Otherwise it's the same as calling _GetCacheStatistics.
//
BOOL
_GetCacheStatisticsForUser(
    PCSCGETSTATSINFO pi,
    PCSCCACHESTATS pcs
    )
{
    pi->dwExcludeFlags |= SSEF_NOACCUSER | SSEF_NOACCGUEST | SSEF_NOACCAND;
    return _GetCacheStatistics(pi, pcs);
}


//
// CSCUI version of reboot.  Requires security goo.
// This code was pattered after that found in \shell\shell32\restart.c
// function CommonRestart().
//
DWORD 
CSCUIRebootSystem(
    void
    )
{
    TraceEnter(TRACE_UTIL, "CSCUIRebootSystem");
    DWORD dwOldState, dwStatus, dwSecError;
    DWORD dwRebootError = ERROR_SUCCESS;

    SetLastError(0);           // Be really safe about last error value!
    dwStatus = Security_SetPrivilegeAttrib(SE_SHUTDOWN_NAME,
                                           SE_PRIVILEGE_ENABLED,
                                           &dwOldState);
    dwSecError = GetLastError();  // ERROR_NOT_ALL_ASSIGNED sometimes    

    if (!ExitWindowsEx(EWX_REBOOT, 0))
    {
        dwRebootError = GetLastError();
        Trace((TEXT("Error %d rebooting system"), dwRebootError));
    }
    if (NT_SUCCESS(dwStatus))
    {
        if (ERROR_SUCCESS == dwSecError)
        {
            Security_SetPrivilegeAttrib(SE_SHUTDOWN_NAME, dwOldState, NULL);
        }
        else
        {
            Trace((TEXT("Error %d setting SE_SHUTDOWN_NAME privilege"), dwSecError));
        }
    }
    else
    {
        Trace((TEXT("Error %d setting SE_SHUTDOWN_NAME privilege"), dwStatus));
    }
    TraceLeaveResult(dwRebootError);
}


//
// Retrieve location, size and file/directory count information for the 
// CSC cache.  If CSC is disabled, information is gathered about the
// system volume.  That's where the CSC agent will put the cache when
// one is created.
//
void
GetCscSpaceUsageInfo(
    CSCSPACEUSAGEINFO *psui
    )
{
    ULARGE_INTEGER ulTotalBytes = {0, 0};
    ULARGE_INTEGER ulUsedBytes = {0, 0};

    ZeroMemory(psui, sizeof(*psui));
    CSCGetSpaceUsage(psui->szVolume,
                     ARRAYSIZE(psui->szVolume),
                     &ulTotalBytes.HighPart,
                     &ulTotalBytes.LowPart,
                     &ulUsedBytes.HighPart,
                     &ulUsedBytes.LowPart,
                     &psui->dwNumFilesInCache,
                     &psui->dwNumDirsInCache);

    if (0 == psui->szVolume[0])
    {
        //
        // CSCGetSpaceUsage didn't give us a volume name.  Probably because
        // CSC hasn't been enabled on the system.  Default to the system
        // drive because that's what CSC uses anyway.
        //
        GetSystemDirectory(psui->szVolume, ARRAYSIZE(psui->szVolume));
        psui->dwNumFilesInCache = 0;
        psui->dwNumDirsInCache  = 0;
    }

    PathStripToRoot(psui->szVolume);
    DWORD spc = 0; // Sectors per cluster.
    DWORD bps = 0; // Bytes per sector.
    DWORD fc  = 0; // Free clusters.
    DWORD nc  = 0; // Total clusters.
    GetDiskFreeSpace(psui->szVolume, &spc, &bps, &fc, &nc);

    psui->llBytesOnVolume     = (LONGLONG)nc * (LONGLONG)spc * (LONGLONG)bps;
    psui->llBytesTotalInCache = ulTotalBytes.QuadPart;
    psui->llBytesUsedInCache  = ulUsedBytes.QuadPart;
}



//-----------------------------------------------------------------------------
// This is code taken from shell32's utils.cpp file.
// We need the function SHSimpleIDListFromFindData() but it's not exported
// from shell32.  Therefore, until it is, we just lifted the code.
// [brianau - 9/28/98]
//-----------------------------------------------------------------------------
class CFileSysBindData: public IFileSystemBindData
{ 
public:
    CFileSysBindData();
    
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IFileSystemBindData
    STDMETHODIMP SetFindData(const WIN32_FIND_DATAW *pfd);
    STDMETHODIMP GetFindData(WIN32_FIND_DATAW *pfd);

private:
    ~CFileSysBindData();
    
    LONG _cRef;
    WIN32_FIND_DATAW _fd;
};


CFileSysBindData::CFileSysBindData() : _cRef(1)
{
    ZeroMemory(&_fd, sizeof(_fd));
}

CFileSysBindData::~CFileSysBindData()
{
}

HRESULT CFileSysBindData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysBindData, IFileSystemBindData), // IID_IFileSystemBindData
         { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysBindData::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysBindData::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFileSysBindData::SetFindData(const WIN32_FIND_DATAW *pfd)
{
    _fd = *pfd;
    return S_OK;
}

HRESULT CFileSysBindData::GetFindData(WIN32_FIND_DATAW *pfd) 
{
    *pfd = _fd;
    return S_OK;
}


HRESULT
SHCreateFileSysBindCtx(
    const WIN32_FIND_DATA *pfd, 
    IBindCtx **ppbc
    )
{
    HRESULT hres;
    IFileSystemBindData *pfsbd = new CFileSysBindData();
    if (pfsbd)
    {
        if (pfd)
        {
            WIN32_FIND_DATAW fdw;
            memcpy(&fdw, pfd, FIELD_OFFSET(WIN32_FIND_DATAW, cFileName));
            SHTCharToUnicode(pfd->cFileName, fdw.cFileName, ARRAYSIZE(fdw.cFileName));
            SHTCharToUnicode(pfd->cAlternateFileName, fdw.cAlternateFileName, ARRAYSIZE(fdw.cAlternateFileName));
            pfsbd->SetFindData(&fdw);
        }

        hres = CreateBindCtx(0, ppbc);
        if (SUCCEEDED(hres))
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfMode = STGM_CREATE;
            (*ppbc)->SetBindOptions(&bo);
            (*ppbc)->RegisterObjectParam(STR_FILE_SYS_BIND_DATA, pfsbd);
        }
        pfsbd->Release();
    }
    else
    {
        *ppbc = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;
}


HRESULT
SHSimpleIDListFromFindData(
    LPCTSTR pszPath, 
    const WIN32_FIND_DATA *pfd, 
    LPITEMIDLIST *ppidl
    )
{
    IShellFolder *psfDesktop;
    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        IBindCtx *pbc;
        hres = SHCreateFileSysBindCtx(pfd, &pbc);
        if (SUCCEEDED(hres))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

            hres = psfDesktop->ParseDisplayName(NULL, pbc, wszPath, NULL, ppidl, NULL);
            pbc->Release();
        }
        psfDesktop->Release();
    }

    if (FAILED(hres))
        *ppidl = NULL;
    return hres;
}


//
// Number of times a CSC API will be repeated if it fails.
// In particular, this is used for CSCDelete and CSCFillSparseFiles; both of
// which can fail on one call but succeed the next.  This isn't designed
// behavior but it is reality.  ShishirP knows about it and may be able to
// investigate later. [brianau - 4/2/98]
// 
const int CSC_API_RETRIES = 3;

//
// Occasionally if a call to a CSC API fails with ERROR_ACCESS_DENIED, 
// repeating the call will succeed.
// Here we wrap up the call to CSCDelete so that it is called multiple
// times in the case of these failures.
//
DWORD
CscDelete(
    LPCTSTR pszPath
    )
{
    DWORD dwError = ERROR_SUCCESS;
    int nRetries = CSC_API_RETRIES;
    while(0 < nRetries--)
    {
        if (CSCDelete(pszPath))
            return ERROR_SUCCESS;

        dwError = GetLastError();
        if (ERROR_ACCESS_DENIED != dwError)
            return dwError;
    }
    if (ERROR_SUCCESS == dwError)
    {
        //
        // Hack for some CSC APIs returning
        // ERROR_SUCCESS even though they fail.
        //
        dwError = ERROR_GEN_FAILURE;
    }
    return dwError;
}


void 
EnableDlgItems(
    HWND hwndDlg, 
    const UINT* pCtlIds, 
    int cCtls, 
    bool bEnable
    )
{
    for (int i = 0; i < cCtls; i++)
    {
        EnableWindow(GetDlgItem(hwndDlg, *(pCtlIds + i)), bEnable);
    }
}

void 
ShowDlgItems(
    HWND hwndDlg, 
    const UINT* pCtlIds, 
    int cCtls, 
    bool bShow
    )
{
    const int nCmdShow = bShow ? SW_NORMAL : SW_HIDE;

    for (int i = 0; i < cCtls; i++)
    {
        ShowWindow(GetDlgItem(hwndDlg, *(pCtlIds + i)), nCmdShow);
    }
}



//
// Wrapper around GetVolumeInformation that accounts for mounted
// volumes.  This was borrowed from shell32\mulprsht.c
//
BOOL GetVolumeFlags(LPCTSTR pszPath, DWORD *pdwFlags)
{
    TraceAssert(NULL != pszPath);
    TraceAssert(NULL != pdwFlags);

    TCHAR szRoot[MAX_PATH];

    *pdwFlags = NULL;

    //
    // Is this a mount point, e.g. c:\ or c:\hostfolder\
    // 
    if (!GetVolumePathName(pszPath, szRoot, ARRAYSIZE(szRoot)))
    {
        //
        // No.  Use path provided by caller.
        //
        StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPath);
        PathStripToRoot(szRoot);
    }
    //
    // GetVolumeInformation requires a trailing backslash.
    //
    PathAddBackslash(szRoot);
    return GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, pdwFlags, NULL, 0);
}


//
// Determine if a net share has an open connection on the local machine.
//
// Returns:
//
//      S_OK        = There is an open connection to the share.
//      S_FALSE     = No open connection to the share.
//      other       = Some error code.
//
HRESULT
IsOpenConnectionShare(
    LPCTSTR pszShare
    )
{
    DWORD dwStatus;
    if (CSCQueryFileStatus(pszShare, &dwStatus, NULL, NULL))
    {
        if (FLAG_CSC_SHARE_STATUS_CONNECTED & dwStatus)
            return S_OK;
    }
    return S_FALSE;
}


// With this version of CSCIsCSCEnabled, we can delay all extra dll loads
// (including cscdll.dll) until we actually see a net file/folder.
#include <devioctl.h>
#include <shdcom.h>
static TCHAR const c_szShadowDevice[] = TEXT("\\\\.\\shadow");

BOOL IsCSCEnabled(void)
{
    BOOL bIsCSCEnabled = FALSE;
    if (!IsOS(OS_PERSONAL))
    {
        SHADOWINFO sSI = {0};
        ULONG ulBytesReturned;

        HANDLE hShadowDB = CreateFile(c_szShadowDevice,
                                      FILE_EXECUTE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,
                                      OPEN_EXISTING,
                                      0,
                                      NULL);
        if (INVALID_HANDLE_VALUE == hShadowDB)
            return FALSE;

        sSI.uStatus = SHADOW_SWITCH_SHADOWING;
        sSI.uOp = SHADOW_SWITCH_GET_STATE;

        if (DeviceIoControl(hShadowDB,
                            IOCTL_SWITCHES,
                            (void *)(&sSI),
                            0,
                            NULL,
                            0,
                            &ulBytesReturned,
                            NULL))
        {
            bIsCSCEnabled = (sSI.uStatus & SHADOW_SWITCH_SHADOWING);
        }
        CloseHandle(hShadowDB);
    }
    return bIsCSCEnabled;
}


//
// The bit-masking used by this function is dependent upon the way
// Shishir defined the database status flags in cscapi.h
//
//  FLAG_DATABASESTATUS_ENCRYPTION_MASK        0x00000006   (0000 0110)
//  FLAG_DATABASESTATUS_UNENCRYPTED            0x00000000   (0000 0000)
//  FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED  0x00000004   (0000 0100)
//  FLAG_DATABASESTATUS_ENCRYPTED              0x00000002   (0000 0010)
//  FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED    0x00000006   (0000 0110)
// 
// Things to note:
//    1. Bit 1 == encryption status.
//    2. Bit 2 == partial completion status.
//
//
// Returns:
//    TRUE   == Database is encrypted.  May be fully or partially encrypted.
//    FALSE  == Database is not encrypted.  May be fully or partially not encrypted.
//
//    *pbPartial == Indicates if state is "partial" or not.
//
//    Partial encryption means an encryption operation was started 
//    but not successfully completed.  All new files created will be encrypted.
//    Partial decryption means a decryption operation was started 
//    but not successfully completed.  All new files created will be unencrypted.
//
BOOL IsCacheEncrypted(BOOL *pbPartial)
{
    ULONG ulStatus;
    ULONG ulErrors;
    BOOL bEncrypted = FALSE;
    if (CSCQueryDatabaseStatus(&ulStatus, &ulErrors))
    {
        ulStatus &= FLAG_DATABASESTATUS_ENCRYPTION_MASK;

        bEncrypted = (0 != (FLAG_DATABASESTATUS_ENCRYPTED & ulStatus));
        if (NULL != pbPartial)
        {
            const ULONG FLAGS_PARTIAL = (FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED & FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED);
            *pbPartial = (0 != (FLAGS_PARTIAL & ulStatus));
        }
    }
    return bEncrypted;
}



bool
CscVolumeSupportsEncryption(
    LPCTSTR pszPathIn        // Path of CSC volume.  Can be NULL.
    )
{
    CSCSPACEUSAGEINFO sui;
    DWORD dwVolFlags;
    bool bSupportsEncryption = false;

    if (NULL == pszPathIn)
    {
        //
        // Caller didn't provide path of CSC volume.
        // Get it from CSC.
        //
        sui.szVolume[0] = 0;
        GetCscSpaceUsageInfo(&sui);
        pszPathIn = sui.szVolume;
    }

    if (GetVolumeFlags(pszPathIn, &dwVolFlags))
    {
        if (0 != (FILE_SUPPORTS_ENCRYPTION & dwVolFlags))
        {
            bSupportsEncryption = true;
        }
    }

    return bSupportsEncryption;
}



//
// Returns:
//
//    NULL     == Mutex is owned by another thread.
//    non-NULL == Handle of mutex object.  This thread now owns the mutex.
//                Caller is responsible for releasing the mutex and closing
//                the mutex handle.
//
//    *pbAbandoned indicates if mutex was abandoned by its thread.
//
//
HANDLE
RequestNamedMutexOwnership(
    LPCTSTR pszMutexName,
    BOOL *pbAbandoned     // [optional]
    )
{
    BOOL bAbandoned = FALSE;
    
    HANDLE hMutex = CreateMutex(NULL, FALSE, pszMutexName);
    if (NULL != hMutex)
    {
        //
        // Whether we created or opened the mutex, wait on it
        // to gain ownership.
        //
        switch(WaitForSingleObject(hMutex, 0))
        {
            case WAIT_ABANDONED:
                bAbandoned = TRUE;
                //
                // Fall through...
                //
            case WAIT_OBJECT_0:
                //
                // Current thread now owns the mutex.
                // We'll return the handle to the caller.
                //
                break;

            case WAIT_TIMEOUT:
            default:
                //
                // Couldn't gain ownership of the mutex.
                // Close the handle.
                //
                CloseHandle(hMutex);
                hMutex = NULL;
                break;
        }
    }
    if (NULL != pbAbandoned)
    {
        *pbAbandoned = bAbandoned;
    }
    return hMutex;
}

//
// Determine if a named mutex is currently owned by another thread
// or not.  This function only determines ownership then immediately 
// releases the mutex.  If you need to determine ownership and want
// to retain ownership if previously unowned call 
// RequestNamedMutexOwnership instead.
//
BOOL
IsNamedMutexOwned(
    LPCTSTR pszMutexName,
    BOOL *pbAbandoned
    )
{
    HANDLE hMutex = RequestNamedMutexOwnership(pszMutexName, pbAbandoned);
    if (NULL != hMutex)
    {
        //
        // Mutex was not owned (now owned by current thread).
        // Since we're only interested in determining prior ownership
        // we release it and close the handle.
        //
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        return FALSE;
    }
    return TRUE;
}

long GetGlobalCounterValue(LPCTSTR pszCounterName)
{
    long lValue = 0;
    HANDLE hCounter = SHGlobalCounterCreateNamed(pszCounterName, 0);
    if (hCounter)
    {
        lValue = SHGlobalCounterGetValue(hCounter);
        SHGlobalCounterDestroy(hCounter);
    }
    return lValue;
}

BOOL IsSyncInProgress(void)
{
    return GetGlobalCounterValue(c_szSyncInProgCounter) > 0;
}

BOOL IsPurgeInProgress(void)
{
    return GetGlobalCounterValue(c_szPurgeInProgCounter) > 0;
}

BOOL IsEncryptionInProgress(void)
{
    return IsNamedMutexOwned(c_szEncryptionInProgMutex, NULL);
}
//
// Requests ownership of the global cache encryption mutex.
//
// Returns:
//     NULL     == Mutex already owned by another thread.
//     Non-NULL == Mutex now owned by current thread.
//                 Caller is responsible for releasing the mutex
//                 and closing the mutex handle.
//
HANDLE RequestPermissionToEncryptCache(void)
{
    return RequestNamedMutexOwnership(c_szEncryptionInProgMutex, NULL);
}





//---------------------------------------------------------------
// DataObject helper functions.
// These are roughly taken from similar functions in 
// shell\shell32\datautil.cpp
//---------------------------------------------------------------
HRESULT
DataObject_SetBlob(
    IDataObject *pdtobj,
    CLIPFORMAT cf, 
    LPCVOID pvBlob,
    UINT cbBlob
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    void * pv = GlobalAlloc(GPTR, cbBlob);
    if (pv)
    {
        CopyMemory(pv, pvBlob, cbBlob);
        hr = DataObject_SetGlobal(pdtobj, cf, pv);

        if (FAILED(hr))
            GlobalFree((HGLOBAL)pv);
    }
    return hr;
}

HRESULT
DataObject_GetBlob(
    IDataObject *pdtobj, 
    CLIPFORMAT cf, 
    void * pvBlob, 
    UINT cbBlob
    )
{
    STGMEDIUM medium = {0};
    FORMATETC fmte = {cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        void * pv = GlobalLock(medium.hGlobal);
        if (pv)
        {
            ASSERT(GlobalSize(medium.hGlobal) >= cbBlob);
            CopyMemory(pvBlob, pv, cbBlob);
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


HRESULT
DataObject_SetGlobal(
    IDataObject *pdtobj,
    CLIPFORMAT cf, 
    HGLOBAL hGlobal
    )
{
    FORMATETC fmte = {cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = hGlobal;
    medium.pUnkForRelease = NULL;

    return pdtobj->SetData(&fmte, &medium, TRUE);
}


HRESULT
DataObject_SetDWORD(
    IDataObject *pdtobj,
    CLIPFORMAT cf, 
    DWORD dw
    )
{
    return DataObject_SetBlob(pdtobj, cf, &dw, sizeof(dw));
}


HRESULT
DataObject_GetDWORD(
    IDataObject *pdtobj, 
    CLIPFORMAT cf, 
    DWORD *pdwOut
    )
{
    return DataObject_GetBlob(pdtobj, cf, pdwOut, sizeof(DWORD));
}
 

HRESULT
SetGetLogicalPerformedDropEffect(
    IDataObject *pdtobj,
    DWORD *pdwEffect,
    bool bSet
    )
{
    HRESULT hr = NOERROR;
    static CLIPFORMAT cf;
    if ((CLIPFORMAT)0 == cf)
        cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);

    if (bSet)
    {
        hr = DataObject_SetDWORD(pdtobj, cf, *pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
        DataObject_GetDWORD(pdtobj, cf, pdwEffect);
    }        
        
    return hr;
}

DWORD 
GetLogicalPerformedDropEffect(
    IDataObject *pdtobj
    )
{
    DWORD dwEffect = DROPEFFECT_NONE;
    SetGetLogicalPerformedDropEffect(pdtobj, &dwEffect, false);
    return dwEffect;
}

HRESULT
SetLogicalPerformedDropEffect(
    IDataObject *pdtobj,
    DWORD dwEffect
    )
{
    return SetGetLogicalPerformedDropEffect(pdtobj, &dwEffect, true);
}


HRESULT
SetGetPreferredDropEffect(
    IDataObject *pdtobj,
    DWORD *pdwEffect,
    bool bSet
    )
{
    HRESULT hr = NOERROR;
    static CLIPFORMAT cf;
    if ((CLIPFORMAT)0 == cf)
        cf = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);

    if (bSet)
    {
        hr = DataObject_SetDWORD(pdtobj, cf, *pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
        DataObject_GetDWORD(pdtobj, cf, pdwEffect);
    }        
        
    return hr;
}

DWORD 
GetPreferredDropEffect(
    IDataObject *pdtobj
    )
{
    DWORD dwEffect = DROPEFFECT_NONE;
    SetGetPreferredDropEffect(pdtobj, &dwEffect, false);
    return dwEffect;
}

HRESULT
SetPreferredDropEffect(
    IDataObject *pdtobj,
    DWORD dwEffect
    )
{
    return SetGetPreferredDropEffect(pdtobj, &dwEffect, true);
}


//
// Wrap CSCFindFirstFile so we don't enumerate "." or "..".
// Wrapper also helps code readability.
// 
HANDLE 
CacheFindFirst(
    LPCTSTR pszPath, 
    PSID psid,
    WIN32_FIND_DATA *pfd,
    DWORD *pdwStatus,
    DWORD *pdwPinCount,
    DWORD *pdwHintFlags,
    FILETIME *pft
    )
{ 
    HANDLE hFind = CSCFindFirstFileForSid(pszPath, 
                                          psid,
                                          pfd, 
                                          pdwStatus, 
                                          pdwPinCount, 
                                          pdwHintFlags, 
                                          pft); 

    while(INVALID_HANDLE_VALUE != hFind && PathIsDotOrDotDot(pfd->cFileName))
    {
        if (!CSCFindNextFile(hFind, 
                             pfd, 
                             pdwStatus, 
                             pdwPinCount, 
                             pdwHintFlags, 
                             pft))
        {
            CSCFindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }
    return hFind;
}


//
// Wrap CSCFindFirstFile so we don't enumerate "." or "..".
// Wrapper also helps code readability.
//
BOOL 
CacheFindNext(
    HANDLE hFind, 
    WIN32_FIND_DATA *pfd,
    DWORD *pdwStatus,
    DWORD *pdwPinCount,
    DWORD *pdwHintFlags,
    FILETIME *pft
    )
{   
    BOOL bResult = FALSE;
    do
    {
        bResult = CSCFindNextFile(hFind, 
                                  pfd, 
                                  pdwStatus, 
                                  pdwPinCount, 
                                  pdwHintFlags, 
                                  pft); 
    }
    while(bResult && PathIsDotOrDotDot(pfd->cFileName));
    return bResult;
}


//
// If there's a link to the Offline Files folder on the
// user's desktop, delete the link.  This version checks a flag in the registry
// before enumerating all LNK's on the desktop.  If the flag doesn't exist,
// we don't continue.  This is a perf enhancement used at logon.
//
BOOL
DeleteOfflineFilesFolderLink_PerfSensitive(
    HWND hwndParent
    )
{    
    BOOL bResult = FALSE;
    //
    // Before enumerating links on the desktop, check to see if the user
    // has created a link.
    //
    DWORD dwValue;
    DWORD cbValue = sizeof(dwValue);
    DWORD dwType;
    DWORD dwResult = SHGetValue(HKEY_CURRENT_USER,
                                REGSTR_KEY_OFFLINEFILES,
                                REGSTR_VAL_FOLDERSHORTCUTCREATED,
                                &dwType,
                                &dwValue,
                                &cbValue);
    
    if (ERROR_SUCCESS == dwResult)
    {
        //
        // We don't care about the value or it's type.  
        // Presence/absence of the value is all that matters.
        //
        bResult = DeleteOfflineFilesFolderLink(hwndParent);
    }
    return bResult;
}


//
// This version of the "delete link" function does not check the
// flag in the registry.  It finds the link file on the desktop and deletes it.
//
BOOL 
DeleteOfflineFilesFolderLink(
    HWND hwndParent
    )
{
    BOOL bResult = FALSE;
    TCHAR szLinkPath[MAX_PATH];
    if (SUCCEEDED(COfflineFilesFolder::IsLinkOnDesktop(hwndParent, szLinkPath, ARRAYSIZE(szLinkPath))))
    {
        bResult = DeleteFile(szLinkPath);
    }
    //
    // Remove the "folder shortcut created" flag from the registry.
    //
    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_KEY_OFFLINEFILES, REGSTR_VAL_FOLDERSHORTCUTCREATED);
    return bResult;
}


//
// This was taken from shell\shell32\util.cpp.
//
BOOL ShowSuperHidden(void)
{
    BOOL bRet = FALSE;

    if (!SHRestricted(REST_DONTSHOWSUPERHIDDEN))
    {
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SHOWSUPERHIDDEN, FALSE);
        bRet = ss.fShowSuperHidden;
    }
    return bRet;
}


BOOL ShowHidden(void)
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    return ss.fShowAllObjects;
}


BOOL IsSyncMgrInitialized(void)
{    
    //
    // Is this the first time this user has used run CSCUI?
    //
    DWORD dwValue = 0;
    DWORD cbData  = sizeof(dwValue);
    DWORD dwType;
    SHGetValue(HKEY_CURRENT_USER,
               c_szCSCKey,
               c_szSyncMgrInitialized,
               &dwType,
               (void *)&dwValue,
               &cbData);
    
    return (0 != dwValue);
}


void SetSyncMgrInitialized(void)
{

    //
    // Set the "initialized" flag so our logoff code in cscst.cpp doesn't
    // try to re-register for sync-at-logon/logoff.
    //
    DWORD dwSyncMgrInitialized = 1;
    SHSetValue(HKEY_CURRENT_USER,
               c_szCSCKey,
               c_szSyncMgrInitialized,
               REG_DWORD,
               &dwSyncMgrInitialized,
               sizeof(dwSyncMgrInitialized));
}


//
// Return the HWND for a standard progress dialog.
//
HWND GetProgressDialogWindow(IProgressDialog *ppd)
{
    HWND hwndProgress = NULL;
    //
    // Get the progress dialog's window handle.  We'll use
    // it as a parent window for error UI.
    //
    HRESULT hr = IUnknown_GetWindow(ppd, &hwndProgress);
    return hwndProgress;
}




void 
CAutoWaitCursor::Reset(
    void
    )
{ 
    ShowCursor(FALSE); 
    if (NULL != m_hCursor) 
        SetCursor(m_hCursor); 
    m_hCursor = NULL;
}


//
// Expand all environment strings in a text string.
//
HRESULT
ExpandStringInPlace(
    LPTSTR psz,
    DWORD cch
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    LPTSTR pszCopy;
    if (LocalAllocString(&pszCopy, psz))
    {
        DWORD cchExpanded = ExpandEnvironmentStrings(pszCopy, psz, cch);
        if (0 == cchExpanded)
            hr = HRESULT_FROM_WIN32(GetLastError());
        else if (cchExpanded > cch)
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else
            hr = S_OK;

        LocalFreeString(&pszCopy);
    }
    if (FAILED(hr) && 0 < cch)
    {
        *psz = 0;
    }
    return hr;
}


//
// Version of RegEnumValue that expands environment variables 
// in all string values.
//
LONG
_RegEnumValueExp(
    HKEY hKey,
    DWORD dwIndex,
    LPTSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    DWORD cchNameDest = lpcbValueName ? *lpcbValueName / sizeof(TCHAR) : 0;
    DWORD cchDataDest = lpcbData ? *lpcbData / sizeof(TCHAR) : 0;
    DWORD dwType;
    if (NULL == lpType)
        lpType = &dwType;
        
    LONG lResult = RegEnumValue(hKey,
                                dwIndex,
                                lpValueName,
                                lpcbValueName,
                                lpReserved,
                                lpType,
                                lpData,
                                lpcbData);

    if (ERROR_SUCCESS == lResult)
    {
        HRESULT hr = ExpandStringInPlace(lpValueName, cchNameDest);
        
        if ((NULL != lpData) && (REG_SZ == *lpType || REG_EXPAND_SZ == *lpType))
        {
            hr = ExpandStringInPlace((LPTSTR)lpData, cchDataDest);
        }
        lResult = HRESULT_CODE(hr);
    }
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\volclean.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.h
//
//--------------------------------------------------------------------------

#ifndef _VOLFREE_H_
#define _VOLFREE_H_

#include "purge.h"

class CCscVolumeCleaner : public IEmptyVolumeCache2
{
    LONG m_cRef;
    BOOL m_fPinned; // TRUE if this instance frees pinned files, FALSE for auto-cached files
    CCachePurger *m_pPurger;
    LPEMPTYVOLUMECACHECALLBACK m_pDiskCleaner;
    DWORDLONG m_dwlSpaceToFree;
    DWORDLONG m_dwlSpaceFreed;
    CCachePurgerSel m_PurgerSel;

public:
    CCscVolumeCleaner(BOOL fPinned) : m_cRef(1), m_fPinned(fPinned), m_pPurger(NULL),
        m_pDiskCleaner(NULL), m_dwlSpaceToFree(0), m_dwlSpaceFreed(0)
    {
        DllAddRef();
    }
    ~CCscVolumeCleaner()
    {
        delete m_pPurger;
        DllRelease();
    }

    static HRESULT WINAPI CreateInstance(REFIID riid, LPVOID *ppv);
    static HRESULT WINAPI CreateInstance2(REFIID riid, LPVOID *ppv);

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEmptyVolumeCache methods
    STDMETHODIMP Initialize(HKEY hkRegKey,
                            LPCWSTR pcwszVolume,
                            LPWSTR *ppwszDisplayName,
                            LPWSTR *ppwszDescription,
                            LPDWORD pdwFlags);
    STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwlSpaceUsed,
                              LPEMPTYVOLUMECACHECALLBACK picb);
    STDMETHODIMP Purge(DWORDLONG dwlSpaceToFree,
                       LPEMPTYVOLUMECACHECALLBACK picb);
    STDMETHODIMP ShowProperties(HWND hwnd);
    STDMETHODIMP Deactivate(LPDWORD pdwFlags);

    // IEmptyVolumeCache methods
    STDMETHODIMP InitializeEx(HKEY hkRegKey,
                              LPCWSTR pcwszVolume,
                              LPCWSTR pcwszKeyName,
                              LPWSTR *ppwszDisplayName,
                              LPWSTR *ppwszDescription,
                              LPWSTR *ppwszBtnText,
                              LPDWORD pdwFlags);

private:
    BOOL ScanCallback(CCachePurger *pPurger);
    BOOL DeleteCallback(CCachePurger *pPurger);

    static BOOL CALLBACK CachePurgerCallback(CCachePurger *pPurger);
    static HRESULT WINAPI Create(BOOL fPinned, REFIID riid, LPVOID *ppv);
};
typedef CCscVolumeCleaner *PCSCVOLCLEANER;

#endif  // _VOLFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\console.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       console.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_CONSOLE_H_
#define __CSCPIN_CONSOLE_H_


HRESULT ConsoleInitialize(void);
HRESULT ConsoleUninitialize(void);
BOOL ConsoleHasCtrlEventOccured(DWORD *pdwCtrlEvent = NULL);


#endif // __CSCPIN_CONSOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\cscpin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cscpin.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include <stdio.h>

#include "cscpin.h"
#include "console.h"
#include "error.h"
#include "exitcode.h"
#include "listfile.h"
#include "print.h"
#include "strings.h"


//-----------------------------------------------------------------------------
// CCscPinItem
//
// This class represents a single item being pinned or unpinned.
// It contains all of the knowledge of how to pin and unpin a file.  The
// CCscPin class coordinates the pinning and unpinning of the entire set
// of files.
//-----------------------------------------------------------------------------

class CCscPinItem
{
    public:
        CCscPinItem(LPCWSTR pszFile, 
                    const WIN32_FIND_DATAW *pfd,
                    const CPrint& pr);

        DWORD Pin(DWORD *pdwCscResult = NULL);
        DWORD Unpin(DWORD *pdwCscResult = NULL);        
        DWORD DeleteIfUnused(void);

    private:
        WCHAR            m_szFile[MAX_PATH];
        SHFILEINFOW      m_sfi;
        WIN32_FIND_DATAW m_fd;
        BOOL             m_bIsValidUnc;       // Is m_szFile a valid UNC?
        BOOL             m_bIsValidFindData;  // Is m_fd valid?
        const CPrint&    m_pr;                // For console/log output.

        bool _Skip(void) const;
        DWORD _PinFile(LPCWSTR pszFile, WIN32_FIND_DATAW *pfd, DWORD *pdwCscResult);
        DWORD _PinOrUnpinLinkTarget(LPCWSTR pszFile, BOOL bPin, DWORD *pdwCscResult);
        DWORD _PinLinkTarget(LPCWSTR pszFile, DWORD *pdwCscResult)
            { return _PinOrUnpinLinkTarget(pszFile, TRUE, pdwCscResult); }
        DWORD _UnpinLinkTarget(LPCWSTR pszFile, DWORD *pdwCscResult)
            { return _PinOrUnpinLinkTarget(pszFile, FALSE, pdwCscResult); }
        DWORD _UnpinFile(LPCWSTR pszFile, WIN32_FIND_DATAW *pfd, DWORD *pdwCscResult);
        DWORD _GetDesiredPinCount(LPCWSTR pszFile);
        void _DecrementPinCountForFile(LPCWSTR pszFile, DWORD dwCurrentPinCount);
        BOOL _IsSpecialRedirectedFile(LPCWSTR pszFile);
        WIN32_FIND_DATAW *_FindDataPtrOrNull(void)
            { return m_bIsValidFindData ? &m_fd : NULL; }


        //
        // Prevent copy.
        //
        CCscPinItem(const CCscPinItem& rhs);                // not implemented.
        CCscPinItem& operator = (const CCscPinItem& rhs);   // not implemented.
};



CCscPinItem::CCscPinItem(
    LPCWSTR pszFile,
    const WIN32_FIND_DATAW *pfd,    // Optional.  May be NULL.
    const CPrint& pr
    ) : m_bIsValidUnc(FALSE),
        m_bIsValidFindData(FALSE),
        m_pr(pr)
{
    TraceAssert(NULL != pszFile);

    lstrcpynW(m_szFile, pszFile, ARRAYSIZE(m_szFile));

    if (NULL != pfd)
    {
        m_fd = *pfd;
        m_bIsValidFindData = TRUE;
    }

    ZeroMemory(&m_sfi, sizeof(m_sfi));
    m_sfi.dwAttributes = SFGAO_FILESYSTEM | SFGAO_LINK;

    if (PathIsUNCW(m_szFile) && 
        SHGetFileInfoW(m_szFile, 0, &m_sfi, sizeof(m_sfi), SHGFI_ATTRIBUTES | SHGFI_ATTR_SPECIFIED))
    {
        m_bIsValidUnc = true;
    }
}



//
// Pins the item's file.  If the item is a link, the link target
// is also pinned.
// Returns one of the CSCPROC_RETURN_XXXXX codes.
// Optionally returns the result of CSCPinFile.
//
DWORD
CCscPinItem::Pin(
    DWORD *pdwCscResult  // Optional.  Default is NULL.
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPinItem::Pin");

    DWORD dwCscResult = ERROR_SUCCESS;
    DWORD dwResult    = CSCPROC_RETURN_SKIP;

    if (!_Skip())
    {
        if (SFGAO_LINK & m_sfi.dwAttributes)
        {
            //
            // Ignore result from pinning the link target.
            // 
            DWORD dwCscResultIgnored;
            _PinLinkTarget(m_szFile, &dwCscResultIgnored);
        }
        dwResult = _PinFile(m_szFile, _FindDataPtrOrNull(), &dwCscResult);
    }
    if (NULL != pdwCscResult)
    {
        *pdwCscResult = dwCscResult;
    }
    TraceLeaveValue(dwResult);
}



//
// Unpins the item's file.
// Returns one of the CSCPROC_RETURN_XXXXX codes.
// Optionally returns the result of CSCUnpinFile.
//
DWORD
CCscPinItem::Unpin(
    DWORD *pdwCscResult  // Optional.  Default is NULL.
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPinItem::Unpin");

    DWORD dwCscResult = ERROR_SUCCESS;
    DWORD dwResult    = CSCPROC_RETURN_SKIP;

    if (!_Skip())
    {
        if (SFGAO_LINK & m_sfi.dwAttributes)
        {
            //
            // Ignore result from unpinning the link target.
            // 
            DWORD dwCscResultIgnored;
            _UnpinLinkTarget(m_szFile, &dwCscResultIgnored);
        }
        dwResult = _UnpinFile(m_szFile, _FindDataPtrOrNull(), &dwCscResult);
    }
    if (NULL != pdwCscResult)
    {
        *pdwCscResult = dwCscResult;
    }
    TraceLeaveResult(dwResult);
}



//
// Delete an item if it is no longer used.
//
DWORD
CCscPinItem::DeleteIfUnused(
    void
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPin::DeleteIfUnused");

    DWORD dwStatus    = 0;
    DWORD dwPinCount  = 0;
    DWORD dwHintFlags = 0;
    DWORD dwResult    = ERROR_SUCCESS;

    if (CSCQueryFileStatusW(m_szFile, &dwStatus, &dwPinCount, &dwHintFlags) &&
        0 == dwPinCount && 
        0 == dwHintFlags &&
        !(dwStatus & FLAG_CSCUI_COPY_STATUS_LOCALLY_DIRTY))
    {
        dwResult = CscDelete(m_szFile);
        if (ERROR_SUCCESS == dwResult)
        {
            m_pr.PrintVerbose(L"Deleted \"%s\" from cache.\n", m_szFile);
            ShellChangeNotify(m_szFile, _FindDataPtrOrNull(), FALSE);
        }
        else
        {
            if (ERROR_DIR_NOT_EMPTY == dwResult)
            {
                dwResult = ERROR_SUCCESS;
            }
            if (ERROR_SUCCESS != dwResult)
            {
                m_pr.PrintAlways(L"Error deleting \"%s\" from cache.  %s\n",
                                 m_szFile, CWinError(dwResult).Text());

            }
        }
    }
    TraceLeaveValue(dwResult);
}


//
// Internal function for pinning a file.  This is a common
// function called by both Pin() and _PinOrUnpinLinkTarget().
//
DWORD
CCscPinItem::_PinFile(
    LPCWSTR pszFile,        // UNC path of file to pin.
    WIN32_FIND_DATAW *pfd,  // Optional. May be NULL.
    DWORD *pdwCscResult     // Result of CSCPinFile.
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPinItem::_PinFile");
    TraceAssert(NULL != pszFile);
    TraceAssert(NULL != pdwCscResult);

    *pdwCscResult = ERROR_SUCCESS;
    //
    // Collect cache information for the item.
    // This may fail, for example if the file is not in the cache
    //
    DWORD dwPinCount  = 0;
    DWORD dwHintFlags = 0;
    CSCQueryFileStatusW(pszFile, NULL, &dwPinCount, &dwHintFlags);
    //
    // Is the admin flag already turned on?
    //
    const BOOL bNewItem = !(dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN);
    if (bNewItem)
    {
        //
        // Turn on the admin flag
        //
        dwHintFlags |= FLAG_CSC_HINT_PIN_ADMIN;

        if (CSCPinFileW(pszFile,
                        dwHintFlags,
                        NULL,
                        &dwPinCount,
                        &dwHintFlags))
        {
            m_pr.PrintVerbose(L"Pin \"%s\"\n", pszFile);
            ShellChangeNotify(pszFile, pfd, FALSE);
        }
        else
        {
            const DWORD dwErr = GetLastError();
            if (ERROR_INVALID_NAME == dwErr)
            {
                //
                // This is the error we get from CSC when trying to
                // pin a file in the exclusion list.  Display a unique
                // error message for this particular situation.
                //
                m_pr.PrintAlways(L"Pinning file \"%s\" is not allowed.\n", pszFile);
            }
            else
            {
                m_pr.PrintAlways(L"Error pinning \"%s\".  %s\n", 
                                 pszFile,
                                 CWinError(dwErr).Text());
            }
            *pdwCscResult = dwErr;
        }
    }
    else
    {
        m_pr.PrintVerbose(L"\"%s\" already pinned.\n", pszFile);
    }
    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}



//
//.Get the target of a link and pin it.
//
DWORD
CCscPinItem::_PinOrUnpinLinkTarget(
    LPCWSTR pszFile,         // UNC of link file.
    BOOL bPin,
    DWORD *pdwCscResult      // Result of CSCPinFile on target.
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPinItem::_PinOrUnpinLinkTarget");
    TraceAssert(NULL != pszFile);
    TraceAssert(NULL != pdwCscResult);

    *pdwCscResult = ERROR_SUCCESS;

    DWORD dwResult   = CSCPROC_RETURN_CONTINUE;
    LPWSTR pszTarget = NULL;
    //
    // We only want to pin a link target if it's a file (not a directory).
    // GetLinkTarget does this check and only returns files.
    //
    GetLinkTarget(pszFile, &pszTarget, NULL);

    if (NULL != pszTarget)
    {
        WIN32_FIND_DATAW fd = {0};
        LPCWSTR pszT = PathFindFileName(pszTarget);
        fd.dwFileAttributes = 0;
        lstrcpynW(fd.cFileName, pszT ? pszT : pszTarget, ARRAYSIZE(fd.cFileName));
        //
        // Pin the target
        //
        if (bPin)
        {
            dwResult = _PinFile(pszTarget, &fd, pdwCscResult);
        }
        else
        {
            dwResult = _UnpinFile(pszTarget, &fd, pdwCscResult);
        }

        LocalFree(pszTarget);
    }
    TraceLeaveValue(dwResult);
}



DWORD
CCscPinItem::_UnpinFile(
    LPCWSTR pszFile,        // UNC of file to unpin.
    WIN32_FIND_DATAW *pfd,  // Optional. May be NULL.
    DWORD *pdwCscResult     // Result of CSCUnpinFile
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPinItem::_UnpinFile");
    TraceAssert(NULL != pszFile);
    TraceAssert(NULL != pdwCscResult);

    *pdwCscResult = ERROR_SUCCESS;

    //
    // Collect cache information for the item.
    // This may fail, for example if the file is not in the cache
    //
    DWORD dwPinCount  = 0;
    DWORD dwHintFlags = 0;
    DWORD dwStatus    = 0;
    CSCQueryFileStatusW(pszFile, &dwStatus, &dwPinCount, &dwHintFlags);

    if (dwHintFlags & FLAG_CSC_HINT_PIN_ADMIN)
    {
        DWORD dwStatus    = 0;
        DWORD dwHintFlags = 0;
        //
        // Decrement pin count.  Amount decremented depends on the file.
        // Win2000 deployment code increments the pin count of some special
        // folders as well as for the desktop.ini file in those special
        // folders.  In those cases, we want to leave the pin count at
        // 1.  For all other files, the pin count can drop to zero.
        //
        _DecrementPinCountForFile(pszFile, dwPinCount);
        //
        // Clear system-pin flag (aka admin-pin flag).
        //
        dwHintFlags |= FLAG_CSC_HINT_PIN_ADMIN;

        if (CSCUnpinFileW(pszFile,
                          dwHintFlags,
                          &dwStatus,
                          &dwPinCount,
                          &dwHintFlags))
        {
            m_pr.PrintVerbose(L"Unpin \"%s\"\n", pszFile);
            if (FLAG_CSC_COPY_STATUS_IS_FILE & dwStatus)
            {
                //
                // Delete a file here.  Directories are deleted
                // on the backside of the post-order traversal
                // in CscPin::_FolderCallback.
                //
                DeleteIfUnused();
            }
            ShellChangeNotify(pszFile, pfd, FALSE);
        }
        else
        {
            *pdwCscResult = GetLastError();
            m_pr.PrintAlways(L"Error unpinning \"%s\".  %s\n", 
                             pszFile, 
                             CWinError(*pdwCscResult).Text());
        }
    }

    TraceLeaveValue(CSCPROC_RETURN_CONTINUE);
}


//
// As part of the unpin operation, we decrement the pin count
// to either 0 or 1.  Folder redirection (contact RahulTh) increments 
// the pin count of redirected special folders and the desktop.ini file
// within those folders.  In those cases, we want to leave the
// pin count at 1 so that we don't upset the behavior of redirected
// folders.  For all other files we drop the pin count to 0.
//
void
CCscPinItem::_DecrementPinCountForFile(
    LPCWSTR pszFile,
    DWORD dwCurrentPinCount
    )
{
    DWORD dwStatus    = 0;
    DWORD dwPinCount  = 0;
    DWORD dwHintFlags = 0;

    const DWORD dwDesiredPinCount = _GetDesiredPinCount(pszFile);

    while(dwCurrentPinCount-- > dwDesiredPinCount)
    {
        dwHintFlags = FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT;
        CSCUnpinFileW(pszFile,
                      dwHintFlags,
                      &dwStatus,
                      &dwPinCount,
                      &dwHintFlags);
    }
}



//
// This function returns the desired pin count (0 or 1) for a 
// given file.  Returns 1 for any redirected special folders
// and the desktop.ini file within those folders.  Returns 0
// for all other files.
//
DWORD
CCscPinItem::_GetDesiredPinCount(
    LPCWSTR pszFile
    )
{
    TraceAssert(NULL != pszFile);

    DWORD dwPinCount = 0; // Default for most files.
    if (_IsSpecialRedirectedFile(pszFile))
    {
        dwPinCount = 1;
    }
    return dwPinCount;
}



//
// Determines if a path is a "special" file pinned by the folder
// redirection code.
//
BOOL
CCscPinItem::_IsSpecialRedirectedFile(
    LPCWSTR pszPath
    )
{
    TraceAssert(NULL != pszPath);

    //
    // This list of special folder IDs provided by RahulTh (08/30/00).  
    // These are the paths that may be pinned by folder redirection.
    //
    static struct
    {
        int csidl;
        WCHAR szPath[MAX_PATH];
        int cchPath;

    } rgFolderPaths[] = {
        { CSIDL_PERSONAL,         0, 0 },
        { CSIDL_MYPICTURES,       0, 0 },
        { CSIDL_DESKTOPDIRECTORY, 0, 0 },
        { CSIDL_STARTMENU,        0, 0 },
        { CSIDL_PROGRAMS,         0, 0 },
        { CSIDL_STARTUP,          0, 0 },
        { CSIDL_APPDATA,          0, 0 }
        };

    int i;
    if (L'\0' == rgFolderPaths[0].szPath[0])
    {
        //
        // Initialize the special folder path data.
        // One-time only initialization.
        //
        for (i = 0; i < ARRAYSIZE(rgFolderPaths); i++)
        {
            if (!SHGetSpecialFolderPath(NULL,
                                        rgFolderPaths[i].szPath,
                                        rgFolderPaths[i].csidl | CSIDL_FLAG_DONT_VERIFY,
                                        FALSE))
            {
                m_pr.PrintAlways(L"Error getting path for shell special folder %d.  %s\n",
                                 rgFolderPaths[i].csidl,
                                 CWinError(GetLastError()).Text());
            }
            else
            {
                //
                // Calculate and cache the length.
                //
                rgFolderPaths[i].cchPath = lstrlen(rgFolderPaths[i].szPath);
            }
        }
    }

    const int cchPath = lstrlen(pszPath);

    for (i = 0; i < ARRAYSIZE(rgFolderPaths); i++)
    {
        int cchThis     = rgFolderPaths[i].cchPath;
        LPCWSTR pszThis = rgFolderPaths[i].szPath;
        if (cchPath >= cchThis)
        {
            //
            // Path being examined is the same length or longer than 
            // current path from the table.  Possible match.
            //
            if (0 == StrCmpNIW(pszPath, pszThis, cchThis))
            {
                //
                // Path being examined is either the same as,
                // or a child of, the current path from the table.
                //
                if (L'\0' == *(pszPath + cchThis))
                {
                    //
                    // Path is same as this path from the table.
                    //
                    return TRUE;
                }
                else if (0 == lstrcmpiW(pszPath + cchThis + 1, L"desktop.ini"))
                {
                    //
                    // Path is for a desktop.ini file that exists in the
                    // root of one of our special folders.
                    //
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}



//
// Determines if the item should be skipped or not.
//
bool
CCscPinItem::_Skip(
    void
    ) const
{
    return !m_bIsValidUnc || (0 == (SFGAO_FILESYSTEM & m_sfi.dwAttributes));
}



//-----------------------------------------------------------------------------
// CCscPin
//-----------------------------------------------------------------------------

CCscPin::CCscPin(
    const CSCPIN_INFO& info
    ) : m_bUseListFile(info.bUseListFile),
        m_bPin(info.bPin),
        m_bPinDefaultSet(info.bPinDefaultSet),
        m_bBreakDetected(FALSE),
        m_cFilesPinned(0),
        m_cCscErrors(0),
        m_pr(info.bVerbose, info.pszLogFile)
{
    TraceAssert(NULL != info.pszFile);

    lstrcpynW(m_szFile, info.pszFile, ARRAYSIZE(m_szFile));
}


CCscPin::~CCscPin(
    void
    )
{

}


//
// The only public method on the CCscPin object.
// Just create an object and tell it to Run.
//
HRESULT
CCscPin::Run(
    void
    )
{
    HRESULT hr = E_FAIL;

    m_cCscErrors = 0;
    m_cFilesPinned = 0;

    if (!IsCSCEnabled())
    {
        m_pr.PrintAlways(L"Offline Files is not enabled.\n");
        SetExitCode(CSCPIN_EXIT_CSC_NOT_ENABLED);
    }
    else if (_IsAdminPinPolicyActive())
    {
        m_pr.PrintAlways(L"The Offline Files 'admin-pin' policy is active.\n");
        SetExitCode(CSCPIN_EXIT_POLICY_ACTIVE);
    }
    else
    {
        if (m_bUseListFile)
        {
            //
            // Process files listed in m_szFile.
            //
            hr = _ProcessPathsInFile(m_szFile);
        }
        else
        {
            //
            // Process the one file provided on the cmd line.
            // Do a quick existence check first.
            //
            if (DWORD(-1) != GetFileAttributesW(m_szFile))
            {
                hr = _ProcessThisPath(m_szFile, m_bPin);
            }
            else
            {
                m_pr.PrintAlways(L"File \"%s\" not found.\n", m_szFile);
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                SetExitCode(CSCPIN_EXIT_FILE_NOT_FOUND);
            }
        }
        //
        // Flush all change notifications.
        //
        ShellChangeNotify(NULL, TRUE);

        if (0 < m_cFilesPinned && !_DetectConsoleBreak())
        {
            //
            // If we pinned some files, fill all sparse 
            // files in the cache.
            //
            _FillSparseFiles();
        }

        if (0 < m_cCscErrors)
        {
            SetExitCode(CSCPIN_EXIT_CSC_ERRORS);
        }
    }
    return hr;
}


//
// Callback parameter block passed to _FolderCallback.
//
struct
CSCPIN_FOLDER_CBK_PARAMS
{
    CCscPin     *pCscPin;  // Reference to the CCscPin object.
    BOOL         bPin;     // TRUE == Pin files, FALSE == Unpin.
};


//
// Callback used for enumerating the filesystem.  This function
// is called for each file processed.
//
DWORD WINAPI
CCscPin::_FolderCallback(
    LPCWSTR pszItem,
    ENUM_REASON  eReason,
    WIN32_FIND_DATAW *pFind32,
    LPARAM pContext            // Ptr to CSCPIN_FOLDER_CBK_PARAMS.
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPin::_PinFolderCallback");
    TraceAssert(NULL != pszItem);
    TraceAssert(NULL != pContext);

    CSCPIN_FOLDER_CBK_PARAMS *pfcp = (CSCPIN_FOLDER_CBK_PARAMS *)pContext;
    CCscPin *pThis  = pfcp->pCscPin;
    DWORD dwResult  = CSCPROC_RETURN_CONTINUE;

    if (pThis->_DetectConsoleBreak())
    {
        TraceLeaveValue(CSCPROC_RETURN_ABORT);
    }

    if (!pszItem || !*pszItem)
    {
        TraceLeaveValue(CSCPROC_RETURN_SKIP);
    }

    if (ENUM_REASON_FILE == eReason || ENUM_REASON_FOLDER_BEGIN == eReason)
    {
        TraceAssert(NULL != pFind32);

        CCscPinItem item(pszItem, pFind32, pThis->m_pr);
        DWORD dwCscResult = ERROR_SUCCESS;
        if (pfcp->bPin)
        {
            dwResult = item.Pin(&dwCscResult);
            if (ERROR_SUCCESS == dwCscResult)
            {
                pThis->m_cFilesPinned++;
            }
        }
        else
        {
            dwResult = item.Unpin(&dwCscResult);
        }
        if (ERROR_SUCCESS != dwCscResult)
        {
            pThis->m_cCscErrors++;
        }
    }
    else if (ENUM_REASON_FOLDER_END == eReason && !pfcp->bPin)
    {
        //
        // This code is executed for each folder item after all children
        // have been visited in the post-order traversal of the 
        // CSC filesystem.  We use it to remove any empty folder entries
        // from the cache.
        //
        CCscPinItem item(pszItem, pFind32, pThis->m_pr);
        item.DeleteIfUnused();
    }            
    TraceLeaveValue(dwResult);
}


//
// Pin or unpin one path string.  If it's a folder, all it's children
// are also pinned or unpinned according to the bPin argument.
//
HRESULT
CCscPin::_ProcessThisPath(
    LPCWSTR pszFile,
    BOOL bPin
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPin::_ProcessThisPath");
    TraceAssert(NULL != pszFile);

    LPCWSTR pszPath    = pszFile;
    LPWSTR pszUncPath = NULL;

    if (!PathIsUNC(pszPath))
    {
        GetRemotePath(pszPath, &pszUncPath);
        pszPath = (LPCWSTR)pszUncPath;
    }

    if (NULL != pszPath)
    {
        CSCPIN_FOLDER_CBK_PARAMS CbkParams = { this, bPin };
        //
        // Process this item
        //
        DWORD dwResult = _FolderCallback(pszPath, ENUM_REASON_FILE, NULL, (LPARAM)&CbkParams);
        //
        // Process everything under this folder (if it's a folder)
        //
        //
        // ISSUE-2000/08/28-BrianAu  Should we provide the capability to
        //      limit recursive pinning and unpinning?   Maybe in the future
        //      but not now.
        //
        if (CSCPROC_RETURN_CONTINUE == dwResult && PathIsUNC(pszPath))
        {
            _Win32EnumFolder(pszPath, TRUE, _FolderCallback, (LPARAM)&CbkParams);
        }
        //
        // Finally, once we're all done, delete the top level item if it's
        // unused.
        //
        CCscPinItem item(pszPath, NULL, m_pr);
        item.DeleteIfUnused();
    }
    LocalFreeString(&pszUncPath);
    TraceLeaveResult(S_OK);
}




//
// Reads paths in the [Pin], [Unpin] and [Default] sections of an INI file.
// For each, call the _ProcessThisPath function.
//
HRESULT
CCscPin::_ProcessPathsInFile(
    LPCWSTR pszFile
    )
{
    TraceEnter(TRACE_ADMINPIN, "CCscPin::_ProcessPathsInFile");
    TraceAssert(NULL != pszFile);

    HRESULT hr = S_OK;

    //
    // Need a full path name.  Otherwise, the PrivateProfile APIs
    // used by the CListFile object will assume the file is in
    // one of the "system" directories.
    //
    WCHAR szFile[MAX_PATH];
    LPWSTR pszNamePart;
    if (0 == GetFullPathNameW(pszFile,
                              ARRAYSIZE(szFile),
                              szFile,
                              &pszNamePart))
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        SetExitCode(CSCPIN_EXIT_LISTFILE_NO_OPEN);
        m_pr.PrintAlways(L"Error expanding path \"%s\". %s\n", 
                         pszFile, 
                         CWinError(hr).Text());
    }
    else
    {
        //
        // Before we go any further, verify the file really exists.
        //
        if (DWORD(-1) == GetFileAttributesW(szFile))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            SetExitCode(CSCPIN_EXIT_LISTFILE_NO_OPEN);
            m_pr.PrintAlways(L"Error opening input file \"%s\". %s\n", 
                             szFile, CWinError(hr).Text());
        }
        else
        {
            //
            // Read and process the information in the file.
            // Note that the listfile object MUST remain alive while the
            // iterator is being used.
            //
            CListFile listfile(szFile);
            CDblNulStrIter iter;

            typedef HRESULT (CListFile::*PFN)(CDblNulStrIter *);    

            //
            // This table describes the sections read from the listfile,
            // the order they are read in and if the files read should
            // be 'pinned' or 'unpinned'.  
            // 
            static const struct
            {
                PFN pfn;     // Function called to read file contents.
                BOOL bQuery; // Query input file for these items?
                BOOL bPin;   // Action to perform on contents read.

            } rgReadFuncs[] = { 
                { &CListFile::GetFilesToUnpin,  TRUE,             FALSE  }, // Reads [Unpin] section.
                { &CListFile::GetFilesToPin,    TRUE,             TRUE   }, // Reads [Pin] section.
                { &CListFile::GetFilesDefault,  m_bPinDefaultSet, m_bPin }, // Reads [Default] section.
                };

            for (int i = 0; i < ARRAYSIZE(rgReadFuncs) && !_DetectConsoleBreak(); i++)
            {
                if (rgReadFuncs[i].bQuery)
                {
                    PFN pfn   = rgReadFuncs[i].pfn;
                    BOOL bPin = rgReadFuncs[i].bPin;
                    //
                    // Read the info from the listfile using the appropriate
                    // function.  The returned iterator will iterate over all
                    // of the files read.
                    //
                    hr = (listfile.*pfn)(&iter);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Process the entries.
                        //
                        LPCWSTR pszPath;
                        while(iter.Next(&pszPath))
                        {
                            //
                            // Paths in the listfile can contain embedded environment
                            // strings.
                            //
                            TCHAR szPathExpanded[MAX_PATH];
                            if (0 == ExpandEnvironmentStrings(pszPath, szPathExpanded, ARRAYSIZE(szPathExpanded)))
                            {
                                m_pr.PrintAlways(L"Error expanding \"%s\". %s\n", 
                                                 pszPath,
                                                 CWinError(GetLastError()));

                                lstrcpynW(szPathExpanded, pszPath, ARRAYSIZE(szPathExpanded));
                            }
                            hr = _ProcessThisPath(szPathExpanded, bPin);
                        }
                    }
                }
            }
        }
    }
    return hr;       
}


//
// Enumerates each share in the cache and attempts to fill all sparse
// files in that share.
//
HRESULT
CCscPin::_FillSparseFiles(
    void
    )
{
    HRESULT hr = S_OK;

    m_pr.PrintAlways(L"Copying pinned files into cache...\n");

    DWORD dwStatus;
    DWORD dwPinCount;
    DWORD dwHintFlags;
    WIN32_FIND_DATA fd;
    FILETIME ft;
    CCscFindHandle hFind;

    hFind = CacheFindFirst(NULL, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft);
    if (hFind.IsValid())
    {
        do
        {
            const BOOL bFullSync = FALSE;
            CSCFillSparseFilesW(fd.cFileName, 
                                bFullSync,
                                _FillSparseFilesCallback, 
                                (DWORD_PTR)this);
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, &ft));
    }
    return hr;
}


//
// Called by CSC for each file processed by CSCFillSparseFiles.
//
DWORD WINAPI 
CCscPin::_FillSparseFilesCallback(
    LPCWSTR pszName, 
    DWORD dwStatus, 
    DWORD dwHintFlags, 
    DWORD dwPinCount,
    WIN32_FIND_DATAW *pfd,
    DWORD dwReason,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD_PTR dwContext
    )
{
    TraceAssert(NULL != dwContext);

    CCscPin *pThis = (CCscPin *)dwContext;

    DWORD dwResult = CSCPROC_RETURN_CONTINUE;
    if (pThis->_DetectConsoleBreak())
    {
        dwResult = CSCPROC_RETURN_ABORT;
    }
    else
    {
        switch(dwReason)
        {
            case CSCPROC_REASON_BEGIN:
                pThis->m_pr.PrintVerbose(L"Filling file \"%s\"\n", pszName);
                break;

            case CSCPROC_REASON_END:
                dwParam2 = pThis->_TranslateFillResult(dwParam2, dwStatus, &dwResult);
                if (ERROR_SUCCESS != dwParam2)
                {
                    pThis->m_cCscErrors++;
                    pThis->m_pr.PrintAlways(L"Error filling \"%s\" %s\n", 
                                            pszName,
                                            CWinError(dwParam2).Text());
                }
                break;

            default:
                break;
        }
    }
    TraceLeaveValue(dwResult);
}


//
// Translates the error code and status provided by CSC from CSCFillSparseFiles
// into the correct error code and CSCPROC_RETURN_XXXXXX value.  Some errors
// require translation before presentation to the user.
//
DWORD
CCscPin::_TranslateFillResult(
    DWORD dwError,
    DWORD dwStatus,
    DWORD *pdwCscAction
    )
{
    DWORD dwResult = dwError;
    DWORD dwAction = CSCPROC_RETURN_CONTINUE;

    if (ERROR_SUCCESS != dwError)
    {
        if (3000 <= dwError && dwError <= 3200)
        {
            //
            // Special internal CSC error codes.
            //
            dwResult = ERROR_SUCCESS;
        }
        else 
        {
            switch(dwError)
            {
                case ERROR_OPERATION_ABORTED:
                    dwResult = ERROR_SUCCESS;
                    dwAction = CSCPROC_RETURN_ABORT;
                    break;

                case ERROR_GEN_FAILURE:
                    if (FLAG_CSC_COPY_STATUS_FILE_IN_USE & dwStatus)
                    {
                        dwResult = ERROR_OPEN_FILES;
                    }
                    break;

                case ERROR_DISK_FULL:
                    dwAction = CSCPROC_RETURN_ABORT;
                    break;

                default:
                    break;
            }
        }
    }
    if (NULL != pdwCscAction)
    {
        *pdwCscAction = dwAction;
    }
    return dwResult;
}


//
// Determine if the admin-pin policy is active on the current
// computer.
//
BOOL
CCscPin::_IsAdminPinPolicyActive(
    void
    )
{
    const HKEY rghkeyRoots[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER };

    BOOL bIsActive = FALSE;
    for (int i = 0; !bIsActive && i < ARRAYSIZE(rghkeyRoots); i++)
    {
        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKeyEx(rghkeyRoots[i], c_szRegKeyAPF, 0, KEY_READ, &hkey))
        {
            WCHAR szName[MAX_PATH];
            DWORD cchName = ARRAYSIZE(szName);

            if (ERROR_SUCCESS == RegEnumValue(hkey, 
                                              0, 
                                              szName, 
                                              &cchName, 
                                              NULL, 
                                              NULL, 
                                              NULL, 
                                              NULL))
            {
                bIsActive = TRUE;
            }
            RegCloseKey(hkey);
        }
    }
    return bIsActive;
}



//
// Determine if one of the following system events has occured.
//
// 1. User pressed Ctrl-C.
// 2. User pressed Ctrl-Break.
// 3. Console window was closed.
// 4. User logged off.
//
// If one of these events has occured, an output message is generated
// and TRUE is returned.
// Otherwise, FALSE is returned.  
// Note that the output message is generated only once.
//
BOOL 
CCscPin::_DetectConsoleBreak(
    void
    )
{
    if (!m_bBreakDetected)
    {
        DWORD dwCtrlEvent;
        m_bBreakDetected = ConsoleHasCtrlEventOccured(&dwCtrlEvent);
        if (m_bBreakDetected)
        {
            m_pr.PrintAlways(L"Program aborted. ");
            switch(dwCtrlEvent)
            {
                case CTRL_C_EVENT:
                    m_pr.PrintAlways(L"User pressed Ctrl-C\n");
                    break;

                case CTRL_BREAK_EVENT:
                    m_pr.PrintAlways(L"User pressed Ctrl-Break\n");
                    break;

                case CTRL_CLOSE_EVENT:
                    m_pr.PrintAlways(L"Application forceably closed.\n");
                    break;

                case CTRL_LOGOFF_EVENT:
                    m_pr.PrintAlways(L"User logged off.\n");
                    break;

                default:
                    m_pr.PrintAlways(L"Unknown console break event %d\n", dwCtrlEvent);
                    break;
            }
        }
    }
    return m_bBreakDetected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\console.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       console.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop


#include <stdio.h>

static DWORD g_dwConsoleCtrlEvent = DWORD(-1);


//
// Handler for console Control events.
//
BOOL WINAPI 
CtrlCHandler(
    DWORD dwCtrlType
    )
{
    BOOL bResult = TRUE;  // Assume handled.
    
    switch(dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
        case CTRL_CLOSE_EVENT:
        case CTRL_LOGOFF_EVENT:
            g_dwConsoleCtrlEvent = dwCtrlType;
            break;

        default:
            bResult = FALSE;
            break; // Ignore
    }
    return bResult;
}


//
// Registers CtrlCHandler() as the console control event
// handler.
//
HRESULT
ConsoleInitialize(
    void
    )
{
    HRESULT hr = S_OK;
    if (!SetConsoleCtrlHandler(CtrlCHandler, TRUE))
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}


//
// Unregisters CtrlCHandler() as the console control event
// handler.
//

HRESULT
ConsoleUninitialize(
    void
    )
{
    HRESULT hr = S_OK;
    if (!SetConsoleCtrlHandler(CtrlCHandler, FALSE))
    {
        const DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}


//
// Determines if a console control event has occured.
// Optionally returns the event code.
//
BOOL
ConsoleHasCtrlEventOccured(
    DWORD *pdwCtrlEvent      // [optional].  Default is NULL.
    )
{
    BOOL bResult = FALSE;

    if (DWORD(-1) != g_dwConsoleCtrlEvent)
    {
        bResult = TRUE;
        if (NULL != pdwCtrlEvent)
        {
            *pdwCtrlEvent = g_dwConsoleCtrlEvent;
        }
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\error.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       error.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_ERROR_H_
#define __CSCPIN_ERROR_H_



class CWinError
{
    public:
        CWinError(DWORD dwError);
        CWinError(HRESULT hr);
        ~CWinError(void) { };

        operator LPCWSTR () const
            { return m_szText; }

        LPCWSTR Text(void) const
            { return m_szText; }

    private:
        WCHAR m_szText[512];

        void _Initialize(DWORD dwError, bool bHResult);
};

#endif // __CSCPIN_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\cscpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cscpin.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_CSCPIN_H_
#define __CSCPIN_CSCPIN_H_

#include "print.h"

//
// This structure contains the information the user passed on the command
// line.
//
struct CSCPIN_INFO
{
    LPCTSTR pszFile;        // Single file or input file listing multiple files.
    LPCTSTR pszLogFile;     // Non-null if log file is to be used.
    BOOL bUseListFile;      // pszFile is the name of a listing file.
    BOOL bPin;              // TRUE == Default behavior is 'pin'.
    BOOL bPinDefaultSet;    // TRUE if user specified -p or -u cmd line param.
    BOOL bVerbose;          // TRUE == Output verbose information.
};

//-----------------------------------------------------------------------------
// CCscPin
//
// This class coordinates the pinning and unpinning of an entire set of
// files and directories.  It is initialized with information provided on the
// command line through a CSCPIN_INFO structure.  The object client calls
// the Run() method to start the pinning/unpinning process.
//
//-----------------------------------------------------------------------------

class CCscPin
{
    public:
        CCscPin(const CSCPIN_INFO& info);
        ~CCscPin(void);

        HRESULT Run(void);

    private:
        WCHAR  m_szFile[MAX_PATH];        // The single file or the listfile.
        BOOL   m_bUseListFile;            // m_szFile is a listfile.
        BOOL   m_bPin;                    // TRUE if -p specified, FALSE if -u.
        BOOL   m_bPinDefaultSet;          // TRUE if either -p or -u specified.
        BOOL   m_bVerbose;                // TRUE if -v specified.
        BOOL   m_bBreakDetected;          // TRUE if a console break occured.
        int    m_cFilesPinned;            // Count of files pinned.
        int    m_cCscErrors;              // Count of CSC errors that occured.
        CPrint m_pr;                      // Console/Log output object.

        HRESULT _ProcessThisPath(LPCTSTR pszFile, BOOL bPin);
        HRESULT _ProcessPathsInFile(LPCTSTR pszFile);
        HRESULT _FillSparseFiles(void);
        DWORD _TranslateFillResult(DWORD dwError, DWORD dwStatus, DWORD *pdwCscAction);
        BOOL _IsAdminPinPolicyActive(void);
        BOOL _DetectConsoleBreak(void);

        static DWORD WINAPI _FolderCallback(
                                LPCWSTR pszItem, 
                                ENUM_REASON  eReason, 
                                WIN32_FIND_DATAW *pFind32, 
                                LPARAM pContext);

        static DWORD WINAPI _FillSparseFilesCallback(
                                LPCWSTR pszName, 
                                DWORD dwStatus, 
                                DWORD dwHintFlags, 
                                DWORD dwPinCount,
                                WIN32_FIND_DATAW *pfd,
                                DWORD dwReason,
                                DWORD dwParam1,
                                DWORD dwParam2,
                                DWORD_PTR dwContext);
};

#endif // __CSCPIN_CSCPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\exitcode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       exitcode.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_EXITCODE_H_
#define __CSCPIN_EXITCODE_H_

//
// Error codes returned by the application to the cmd interpreter.
//
//  0 means everything completed without error.
// <0 means something went wrong and application did not complete.
// >0 means application completed but not all items were processed.
//
const int CSCPIN_EXIT_POLICY_ACTIVE      = -6;  // Admin-pin policy is active.
const int CSCPIN_EXIT_OUT_OF_MEMORY      = -5;  // Insufficient memory.
const int CSCPIN_EXIT_CSC_NOT_ENABLED    = -4;  // CSC not enabled.
const int CSCPIN_EXIT_LISTFILE_NO_OPEN   = -3;  // Can't find or open listfile.
const int CSCPIN_EXIT_FILE_NOT_FOUND     = -2;  // Single file not found.
const int CSCPIN_EXIT_INVALID_PARAMETER  = -1;  // Invalid argument
const int CSCPIN_EXIT_NORMAL             =  0;
const int CSCPIN_EXIT_APPLICATION_ABORT  =  1;  // App aborted by user.
const int CSCPIN_EXIT_CSC_ERRORS         =  2;  // CSC errors occured.

void SetExitCode(int iCode);
int GetExitCode(void);


#endif // __CSCPIN_EXITCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\exitcode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       exitcode.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop


#include "exitcode.h"

int g_iExitCode = CSCPIN_EXIT_NORMAL;

void
SetExitCode(int iCode)
{
    g_iExitCode = iCode;
}

int 
GetExitCode(void)
{
    return g_iExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\error.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cscpin.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "error.h"

CWinError::CWinError(
    DWORD dwError
    )
{
    _Initialize(dwError, false);
}


CWinError::CWinError(
    HRESULT hr
    )
{
    _Initialize(DWORD(hr), true);
}

void
CWinError::_Initialize(
    DWORD dwError,
    bool bHResult
    )
{
    if (0 ==  FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             dwError,
                             0,
                             (LPWSTR)m_szText,
                             ARRAYSIZE(m_szText),
                             NULL))
    {
        LPCTSTR pszFmt = L"Error code %d";
        if (bHResult)
        {
            pszFmt = L"Error code 0x%08X";
        }
        wnsprintf(m_szText, ARRAYSIZE(m_szText), pszFmt, dwError);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\listfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       listfile.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_LISTFILE_H_
#define __CSCPIN_LISTFILE_H_


//
// Class to walk a double-nul terminated list of strings.
// Used together with class CDblNulStr.
//
class CDblNulStrIter
{
    public:
        explicit CDblNulStrIter(LPCTSTR psz = NULL)
            : m_pszStart(psz),
              m_pszCurrent(psz) { }

        void Reset(void) const
            { m_pszCurrent = m_pszStart; }

        bool Next(LPCTSTR *ppsz) const;

    private:
        LPCTSTR m_pszStart;
        mutable LPCTSTR m_pszCurrent;
};

             
class CListFile
{
    public:
        CListFile(LPCTSTR pszFile);
        ~CListFile(void);

        HRESULT GetFilesToPin(CDblNulStrIter *pIter);
        HRESULT GetFilesToUnpin(CDblNulStrIter *pIter);
        HRESULT GetFilesDefault(CDblNulStrIter *pIter);

    private:
        TCHAR  m_szFile[MAX_PATH];
        LPTSTR m_pszFilesToPin;
        LPTSTR m_pszFilesToUnpin;
        LPTSTR m_pszFilesDefault;

        DWORD 
        _ReadString(
            LPCTSTR pszAppName,  // May be NULL.
            LPCTSTR pszKeyName,  // May be NULL.
            LPCTSTR pszDefault,
            LPTSTR *ppszResult);

        DWORD 
        _ReadSectionItemNames(
            LPCTSTR pszSection, 
            LPTSTR *ppszItemNames,
            bool *pbEmpty = NULL);

        DWORD 
        _ReadItemValue(
            LPCTSTR pszSection, 
            LPCTSTR pszItemName, 
            LPTSTR *ppszItemValue);

        DWORD
        _ReadPathsToPin(
            LPTSTR *ppszNames,
            bool *pbEmpty = NULL);

        DWORD
        _ReadPathsToUnpin(
            LPWSTR *ppszNames,
            bool *pbEmpty = NULL);

        DWORD
        _ReadPathsDefault(
            LPWSTR *ppszNames,
            bool *pbEmpty = NULL);
};


#endif // __CSCPIN_LISTFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\listfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       listfile.cpp
//
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "listfile.h"

const TCHAR g_szPin[]     = TEXT("Pin");
const TCHAR g_szUnpin[]   = TEXT("Unpin");
const TCHAR g_szDefault[] = TEXT("Default");


bool 
CDblNulStrIter::Next(
    LPCTSTR *ppsz
    ) const
{
    ASSERT(NULL != ppsz);

    if (m_pszCurrent && *m_pszCurrent)
    {
        *ppsz = m_pszCurrent;
        while(*m_pszCurrent++)
            NULL;

        return true;
    }
    return false;
};


//
// Class used to represent a double-nul terminated list of strings.
// Simplifies counting and enumerating substrings.
//
class CDblNulStr
{
    public:
        CDblNulStr(LPCTSTR psz)
            : m_pszStart(psz) { }

        DWORD StringCount(void) const;

        CDblNulStrIter GetIter(void) const
            { return CDblNulStrIter(m_pszStart); }

    private:
        LPCTSTR m_pszStart;
};


DWORD 
CDblNulStr::StringCount(
    void
    ) const
{
    ASSERT(NULL != m_pszStart);

    LPCWSTR psz = m_pszStart;
    DWORD n = 0;
    while(*psz++)
    {
        n++;
        while(*psz++)
            NULL;
    }
    return n;
}


CListFile::CListFile(
    LPCTSTR pszFile
    ) : m_pszFilesToPin(NULL),
        m_pszFilesToUnpin(NULL),
        m_pszFilesDefault(NULL)
{
    lstrcpyn(m_szFile, pszFile, ARRAYSIZE(m_szFile));
}


CListFile::~CListFile(
    void
    )
{
    if (NULL != m_pszFilesToPin)
    {
        LocalFree(m_pszFilesToPin);
    }
    if (NULL != m_pszFilesToUnpin)
    {
        LocalFree(m_pszFilesToUnpin);
    }
    if (NULL != m_pszFilesDefault)
    {
        LocalFree(m_pszFilesDefault);
    }
}


HRESULT
CListFile::GetFilesToPin(
    CDblNulStrIter *pIter
    )
{
    HRESULT hr = S_OK;
    if (NULL == m_pszFilesToPin)
    {
        DWORD dwResult = _ReadPathsToPin(&m_pszFilesToPin);
        if (ERROR_SUCCESS != dwResult)
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    if (SUCCEEDED(hr))
    {
        *pIter = CDblNulStrIter(m_pszFilesToPin);
    }
    return hr;
}


HRESULT
CListFile::GetFilesToUnpin(
    CDblNulStrIter *pIter
    )
{
    HRESULT hr = S_OK;
    if (NULL == m_pszFilesToUnpin)
    {
        DWORD dwResult = _ReadPathsToUnpin(&m_pszFilesToUnpin);
        if (ERROR_SUCCESS != dwResult)
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    if (SUCCEEDED(hr))
    {
        *pIter = CDblNulStrIter(m_pszFilesToUnpin);
    }
    return hr;
}


HRESULT
CListFile::GetFilesDefault(
    CDblNulStrIter *pIter
    )
{
    HRESULT hr = S_OK;
    if (NULL == m_pszFilesDefault)
    {
        DWORD dwResult = _ReadPathsDefault(&m_pszFilesDefault);
        if (ERROR_SUCCESS != dwResult)
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    if (SUCCEEDED(hr))
    {
        *pIter = CDblNulStrIter(m_pszFilesDefault);
    }
    return hr;
}


//
// Load a value string from an INI file.  Automatically 
// grows buffer to necessary length.  Returned string must be freed
// using LocalFree().
//
DWORD 
CListFile::_ReadString(
    LPCTSTR pszAppName,  // May be NULL.
    LPCTSTR pszKeyName,  // May be NULL.
    LPCTSTR pszDefault,
    LPTSTR *ppszResult
    )
{
    ASSERT(NULL != pszDefault);
    ASSERT(NULL != ppszResult);


    LPTSTR pszValue      = NULL;
    const DWORD CCHGROW  = MAX_PATH;
    DWORD cchValue       = CCHGROW;
    DWORD dwResult       = ERROR_SUCCESS;

    do
    {
        pszValue = (LPTSTR)LocalAlloc(LPTR, cchValue * sizeof(*pszValue));
        if (NULL == pszValue)
        {
            dwResult = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            DWORD cchCopied = GetPrivateProfileString(pszAppName,
                                                      pszKeyName,
                                                      pszDefault,
                                                      pszValue,
                                                      cchValue,
                                                      m_szFile);
           
            if (((NULL == pszAppName || NULL == pszKeyName) && (cchValue - 2) == cchCopied) ||
                ((NULL != pszAppName && NULL != pszKeyName) && (cchValue - 1) == cchCopied))
            {
                //
                // Buffer too small.  Reallocate and try again.
                //
                cchValue += CCHGROW;
                LocalFree(pszValue);
                pszValue = NULL;
            }
        }
    }
    while(NULL == pszValue && ERROR_SUCCESS == dwResult);

    if (ERROR_SUCCESS == dwResult)
    {
        //
        // Don't forget, this data can be a double-nul terminated string.
        // Don't try to copy it to an exact-sized buffer using strcpy.
        //
        ASSERT(NULL != pszValue);
        *ppszResult = pszValue;
    }
    return dwResult;
}


//
// Read all of the item names in a given INI file section.
// The names are returned in a double-nul term string.
// Caller must free returned string using LocalFree.
// *pbEmpty is set to true if no items were found.
//
DWORD 
CListFile::_ReadSectionItemNames(
    LPCTSTR pszSection, 
    LPTSTR *ppszItemNames,
    bool *pbEmpty          // [optional]  Default == NULL.
    )
{
    bool bEmpty = false;
    LPTSTR pszItemNames;
    DWORD dwResult = _ReadString(pszSection, NULL, TEXT(""), &pszItemNames);
    if (ERROR_SUCCESS == dwResult && TEXT('\0') == *pszItemNames)
    {
        LocalFree(pszItemNames);
        bEmpty = true;
    }
    else
    {
        *ppszItemNames = pszItemNames;
    }
    if (NULL != pbEmpty)
    {
        *pbEmpty = bEmpty;
    }
    return dwResult;
}


//
// Read a single item value from an INI file.
// Caller must free returned string using LocalFree.
//
DWORD 
CListFile::_ReadItemValue(
    LPCTSTR pszSection, 
    LPCTSTR pszItemName, 
    LPTSTR *ppszItemValue
    )
{
    LPTSTR pszValue;
    DWORD dwResult = _ReadString(pszSection, pszItemName, TEXT(""), &pszValue);
    if (ERROR_SUCCESS == dwResult && TEXT('\0') == *pszValue)
    {
        LocalFree(pszValue);
        dwResult = ERROR_INVALID_DATA;
    }
    else
    {
        *ppszItemValue = pszValue;
    }
    return dwResult;
}    


//
// Read the names of all paths in the [Pin] section.
// Caller must free returned string using LocalFree
// 
DWORD
CListFile::_ReadPathsToPin(
    LPTSTR *ppszNames,
    bool *pbEmpty
    )
{
    return _ReadSectionItemNames(g_szPin, ppszNames, pbEmpty);
}


//
// Read the names of all paths in the [Unpin] section.
// Caller must free returned string using LocalFree
// 
DWORD
CListFile::_ReadPathsToUnpin(
    LPWSTR *ppszNames,
    bool *pbEmpty
    )
{
    return _ReadSectionItemNames(g_szUnpin, ppszNames, pbEmpty);
}


//
// Read the names of all paths in the [Default] section.
// Caller must free returned string using LocalFree
// 
DWORD
CListFile::_ReadPathsDefault(
    LPWSTR *ppszNames,
    bool *pbEmpty
    )
{
    return _ReadSectionItemNames(g_szDefault, ppszNames, pbEmpty);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\print.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       print.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include <stdio.h>
#include "print.h"

CPrint::CPrint(
    BOOL bVerbose,
    LPCWSTR pszLogFile  // optional.  Default is NULL.
    ) : m_bVerbose(bVerbose),
        m_pfLog(NULL)
{
    if (NULL != pszLogFile)
    {
        //
        // Open the log file.
        //
        m_pfLog = _wfopen(pszLogFile, L"w");
        if (NULL == m_pfLog)
        {
            fwprintf(stderr, L"Unable to open log file \"%s\"\n", pszLogFile);
            fprintf(stderr, _strerror("Reason: "));
            fwprintf(stderr, L"Output will go to stderr\n");
        }
    }
    if (NULL == m_pfLog)
    {
        //
        // If no log file is specified or if we failed to open the specified
        // log file, default to stderr.
        //
        m_pfLog = stderr;
    }
}


CPrint::~CPrint(
    void
    )
{
    if (NULL != m_pfLog && stderr != m_pfLog)
    {
        fclose(m_pfLog);
    }
}


//
// Some simple printing functions that handle verbose vs. non-verbose mode.
// The output is directed at whatever stream m_pfLog refers to.
// If the user specified a log file on the command line, and that file
// could be opened, all output goes to that file.  Otherwise, it 
// defaults to stderr.
//
void
CPrint::_Print(
    LPCWSTR pszFmt,
    va_list args
    ) const
{
    TraceAssert(NULL != m_pfLog);
    TraceAssert(NULL != pszFmt);
    vfwprintf(m_pfLog, pszFmt, args);
}

//
// Output regardless of "verbose" mode.
//
void 
CPrint::PrintAlways(
    LPCWSTR pszFmt, 
    ...
    ) const
{
    va_list args;
    va_start(args, pszFmt);
    _Print(pszFmt, args);
    va_end(args);
}


//
// Output only in "verbose" mode.
// Verbose is turned on with the -v cmd line switch.
//
void
CPrint::PrintVerbose(
    LPCWSTR pszFmt,
    ...
    ) const
{
    if (m_bVerbose)
    {
        va_list args;
        va_start(args, pszFmt);
        _Print(pszFmt, args);
        va_end(args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include <stdio.h>

#include "util.h"
#include "cscpin.h"
#include "console.h"
#include "exitcode.h"


void 
ShowUsage(
    void
    )
{
    fwprintf(stderr, L"\aUsage: cscpin -p | -u  <filename> | -f <listfile>  [-v] [-l <logfile>]\n\n");
    fwprintf(stderr, L"\t-p = Pin files.\n");
    fwprintf(stderr, L"\t-u = Unpin files.\n");
    fwprintf(stderr, L"\t-f = Process paths in <listfile>.\n");
    fwprintf(stderr, L"\t-l = Log results to <logfile>.\n");
    fwprintf(stderr, L"\t-v = Verbose mode.\n");
    fwprintf(stderr, L"\t<filename> = name of file or folder to pin/unpin.\n\n");
    fwprintf(stderr, L"Examples:\n\n");
    fwprintf(stderr, L"\tcscpin -v -p \\\\server\\share\\dir\n\n");
    fwprintf(stderr, L"\tcscpin -u \\\\server\\share2\\dir\\foo.txt\n\n");
    fwprintf(stderr, L"\tcscpin -f pinthese.txt -l cscpin.log\n\n");
}


int __cdecl 
wmain(
    int argc, 
    WCHAR **argv
    )
{
    const WCHAR CH_DASH  = '-';
    const WCHAR CH_SLASH = '/';

    CSCPIN_INFO info;
    ZeroMemory(&info, sizeof(info));


    const DWORD OPTION_PIN_OR_UNPIN = 0x00000001;
    const DWORD OPTION_VERBOSE      = 0x00000002;
    const DWORD OPTION_INPUTFILE    = 0x00000004;
    const DWORD OPTION_LOGFILE      = 0x00000008;

    const DWORD OPTION_ALL          = (OPTION_PIN_OR_UNPIN |
                                       OPTION_VERBOSE |
                                       OPTION_LOGFILE |
                                       OPTION_INPUTFILE);

    DWORD dwOptions = 0;
    bool bShowUsage = false;

    for (int i = 1; i < argc && !bShowUsage && (OPTION_ALL != dwOptions); i++)
    {
        if (CH_DASH == argv[i][0] || CH_SLASH == argv[i][0])
        {
            switch(argv[i][1])
            {
                case L'U':
                case L'u':
                    if (0 == (OPTION_PIN_OR_UNPIN & dwOptions))
                    {
                        info.bPin           = FALSE;
                        info.bPinDefaultSet = TRUE;
                        dwOptions |= OPTION_PIN_OR_UNPIN;
                    }
                    else
                    {
                        fwprintf(stderr, L"Only one [-u] or [-p] allowed.\n\n");
                        bShowUsage = true;
                    }
                    break;

                case L'P':
                case L'p':
                    if (0 == (OPTION_PIN_OR_UNPIN & dwOptions))
                    {
                        info.bPin           = TRUE;
                        info.bPinDefaultSet = TRUE;
                        dwOptions |= OPTION_PIN_OR_UNPIN;
                    }
                    else
                    {
                        fwprintf(stderr, L"Only one [-u] or [-p] allowed.\n\n");
                        bShowUsage = true;
                    }
                    break;

                case L'V':
                case L'v':
                    info.bVerbose = TRUE;
                    dwOptions |= OPTION_VERBOSE;
                    break;

                case L'F':
                case L'f':
                    if (0 == (OPTION_INPUTFILE & dwOptions))
                    {
                        if (++i < argc)
                        {
                            if (NULL == info.pszFile)
                            {
                                info.pszFile = argv[i];
                                info.bUseListFile = TRUE;
                                dwOptions |= OPTION_INPUTFILE;
                            }
                            else
                            {
                                fwprintf(stderr, L"Specify a list file using -F or a single file, not both.\n\n");
                                bShowUsage = true;
                            }
                        }
                        else
                        {
                            fwprintf(stderr, L"<filename> expected following -F\n\n");
                            bShowUsage = true;
                        }
                    }
                    else
                    {
                        fwprintf(stderr, L"Multiple input files specified.\n\n");
                        bShowUsage = true;
                    }
                    break;

                case L'L':
                case L'l':
                    if (0 == (OPTION_LOGFILE & dwOptions))
                    {
                        if (++i < argc)
                        {
                            info.pszLogFile = argv[i];
                            dwOptions |= OPTION_LOGFILE;
                        }
                        else
                        {
                            fwprintf(stderr, L"<filename> expected following -L\n\n");
                            bShowUsage = true;
                        }
                    }
                    else
                    {
                        fwprintf(stderr, L"Multiple -L options specified.\n\n");
                        bShowUsage = true;
                    }
                    break;

                default:
                    fwprintf(stderr, L"Unknown option '%c' specified.\n\n", argv[i][1]);
                    SetExitCode(CSCPIN_EXIT_INVALID_PARAMETER);
                    bShowUsage = true;
            }
        }
        else if (NULL == info.pszFile && 0 == (OPTION_INPUTFILE & dwOptions))
        {
            //
            // Assume a file path without a cmd line switch is a single
            // file to be pinned or unpinned.
            //
            info.pszFile      = argv[i];
            info.bUseListFile = FALSE;
            dwOptions |= OPTION_INPUTFILE;
        }
        else
        {
            fwprintf(stderr, L"Multiple input files specified.\n\n");
            bShowUsage = true;
        }
    }
    //
    // Now validate what the user entered.
    //
    if (0 == (OPTION_INPUTFILE & dwOptions))
    {
        fwprintf(stderr, L"<filename> or -f <listfile> argument required.\n\n");
        bShowUsage = true;
    }
    else
    {
        if (!info.bUseListFile)
        {
            if (!info.bPinDefaultSet)
            {
                //
                // Not providing a listing file and didn't indicate
                // 'pin' or 'unpin' on the command line.
                //
                fwprintf(stderr, L"-p or -u argument required.\n\n");
                bShowUsage = true;
            }
        }
    }
    if (bShowUsage)
    {
        //
        // User input is not 100% valid.
        //
        SetExitCode(CSCPIN_EXIT_INVALID_PARAMETER);
        ShowUsage();
    }
    else
    {
        //
        // User input is valid. 
        //
        ConsoleInitialize();

        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            CCscPin cscpin(info);
            cscpin.Run();
            CoUninitialize();
        }
        if (ConsoleHasCtrlEventOccured())
        {
            SetExitCode(CSCPIN_EXIT_APPLICATION_ABORT);
        }
        ConsoleUninitialize();
    }

#if DBG
    fwprintf(stderr, L"Exit code = %d\n", GetExitCode());
#endif
    return GetExitCode();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\pin\print.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       print.h
//
//--------------------------------------------------------------------------
#ifndef __CSCPIN_PRINT_H_
#define __CSCPIN_PRINT_H_


class CPrint
{
    public:
        CPrint(BOOL bVerbose, LPCWSTR pszLogFile = NULL);
        ~CPrint(void);

        void PrintAlways(LPCWSTR pszFmt, ...) const;
        void PrintVerbose(LPCWSTR pszFmt, ...) const;

    private:
        FILE *m_pfLog;
        BOOL m_bVerbose;

        void _Print(LPCWSTR pszFmt, va_list args) const;
};


#endif // __CSCPIN_PRINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\diskcopy.h ===
#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shlapip.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlguid.h>
#include <shsemip.h>
#include <windowsx.h>
#include <fmifs.h>
#include <shfusion.h>

extern HINSTANCE g_hinst;

int SHCopyDisk(HWND hwnd, int nSrcDrive, int nDestDrive, DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\diskcopy.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>
#include "diskcopy.h"
#include "ids.h"
#include "help.h"

// SHChangeNotifySuspendResume
#include <shlobjp.h>
#include <strsafe.h>

#define WM_DONE_WITH_FORMAT     (WM_APP + 100)

// DISKINFO Struct
// Revisions:	02/04/98 dsheldon - added bDestInserted

typedef struct
{
    int     nSrcDrive;
    int     nDestDrive;
    UINT    nCylinderSize;
    UINT    nCylinders;
    UINT    nHeads;
    UINT    nSectorsPerTrack;
    UINT    nSectorSize;
    BOOL    bNotifiedWriting;
    BOOL    bFormatTried;
    
    HWND    hdlg;
    HANDLE  hThread;
    BOOL    bUserAbort;
    DWORD   dwError;
    
    BOOL	bDestInserted;
    
    LONG    cRef;
    
} DISKINFO;

DISKINFO* g_pDiskInfo = NULL;

int ErrorMessageBox(UINT uFlags);
void SetStatusText(int id);
BOOL PromptInsertDisk(LPCTSTR lpsz);

typedef struct _fmifs {
    HINSTANCE hDll;
    PFMIFS_DISKCOPY_ROUTINE DiskCopy;
} FMIFS;
typedef FMIFS *PFMIFS;


ULONG DiskInfoAddRef()
{
    return InterlockedIncrement(&(g_pDiskInfo->cRef));
}

ULONG DiskInfoRelease()
{
    Assert( 0 != (g_pDiskInfo->cRef) );
    ULONG cRef = InterlockedDecrement( &(g_pDiskInfo->cRef) );
    if ( 0 == cRef )
    {
        LocalFree(g_pDiskInfo);
        g_pDiskInfo = NULL;
    }
    return cRef;
}

BOOL LoadFMIFS(PFMIFS pFMIFS)
{
    BOOL fRet;
    
    // Load the FMIFS DLL and query for the entry points we need
    
    pFMIFS->hDll = LoadLibrary(TEXT("FMIFS.DLL"));
    
    if (NULL == pFMIFS->hDll)
    {
        fRet = FALSE;
    }
    else
    {        
        pFMIFS->DiskCopy = (PFMIFS_DISKCOPY_ROUTINE)GetProcAddress(pFMIFS->hDll,
            "DiskCopy");
        if (!pFMIFS->DiskCopy)
        {
            FreeLibrary(pFMIFS->hDll);
            pFMIFS->hDll = NULL;
            fRet = FALSE;
        }
        else
        {
            fRet = TRUE;
        }
    }
    
    return fRet;
}

void UnloadFMIFS(PFMIFS pFMIFS)
{
    FreeLibrary(pFMIFS->hDll);
    pFMIFS->hDll = NULL;
    pFMIFS->DiskCopy = NULL;
}

// DriveNumFromDriveLetterW: Return a drive number given a pointer to
//  a unicode drive letter.
// 02/03/98: dsheldon created
int DriveNumFromDriveLetterW(WCHAR* pwchDrive)
{
    Assert(pwchDrive != NULL);
    
    return ( ((int) *pwchDrive) - ((int) L'A') );
}

/*
Function: CopyDiskCallback

  Return Value:
		TRUE - Normally, TRUE should be returned if the Disk Copy procedure should
        continue after CopyDiskCallback returns. Note the HACK below, however!
        FALSE - Normally, this indicates that the Disk Copy procedure should be
        cancelled.
        
          
            !HACKHACK!
            
              The low-level Disk Copy procedure that invokes this callback is also used
              by the command-line DiskCopy utility. That utility's implementation of the
              callback always returns TRUE. For this reason, the low-level Disk Copy
              procedure will interpret TRUE as CANCEL when it is returned from callbacks
              that display a message box and allow the user to possibly RETRY an operation.
              Therefore, return TRUE after handling such messages to tell the Disk Copy
              procedure to abort, and return FALSE to tell Disk Copy to retry.
              
                TRUE still means 'continue' when returned from PercentComplete or Disk Insertion
                messages.
                
                  Revision:
                  02/03/98: dsheldon - modified code to handle retry/cancel for bad media,
                  write protected media, and disk being yanked out of drive during copy
                  
*/

BOOLEAN CopyDiskCallback( FMIFS_PACKET_TYPE PacketType, DWORD PacketLength, PVOID PacketData)
{
    int iDisk;
    
    // Quit if told to do so..
    if (g_pDiskInfo->bUserAbort)
        return FALSE;
    
    switch (PacketType) {
    case FmIfsPercentCompleted:
        {
            DWORD dwPercent = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)
                PacketData)->PercentCompleted;
            
            //
            // Hokey method of determining "writing"
            //
            if (dwPercent > 50 && !g_pDiskInfo->bNotifiedWriting)
            {
                g_pDiskInfo->bNotifiedWriting = TRUE;
                SetStatusText(IDS_WRITING);
            }
            
            SendDlgItemMessage(g_pDiskInfo->hdlg, IDD_PROBAR, PBM_SETPOS, dwPercent,0);
            break;
        }
    case FmIfsInsertDisk:
        
        switch(((PFMIFS_INSERT_DISK_INFORMATION)PacketData)->DiskType) {
        case DISK_TYPE_SOURCE:
        case DISK_TYPE_GENERIC:
            iDisk = IDS_INSERTSRC;
            break;
            
        case DISK_TYPE_TARGET:
            iDisk = IDS_INSERTDEST;
            g_pDiskInfo->bDestInserted = TRUE;
            break;
        case DISK_TYPE_SOURCE_AND_TARGET:
            iDisk = IDS_INSERTSRCDEST;
            break;
        }
        if (!PromptInsertDisk(MAKEINTRESOURCE(iDisk))) {
            g_pDiskInfo->bUserAbort = TRUE;
            return FALSE;
        }
        
        break;
        
        case FmIfsFormattingDestination:
            g_pDiskInfo->bNotifiedWriting = FALSE;      // Reset so we get Writing later
            SetStatusText(IDS_FORMATTINGDEST);
            break;
            
        case FmIfsIncompatibleFileSystem:
        case FmIfsIncompatibleMedia:
            g_pDiskInfo->dwError = IDS_COPYSRCDESTINCOMPAT;
            if (ErrorMessageBox(MB_RETRYCANCEL | MB_ICONERROR) == IDRETRY)
            {
                g_pDiskInfo->dwError = 0;
                return FALSE;	//Indicates RETRY - see HACK in function header
            }
            else
            {
                return TRUE;
            }
            break;
            
        case FmIfsMediaWriteProtected:
            g_pDiskInfo->dwError = IDS_DSTDISKBAD;
            if (ErrorMessageBox(MB_RETRYCANCEL | MB_ICONERROR) == IDRETRY)
            {
                g_pDiskInfo->dwError = 0;
                return FALSE;	//Indicates RETRY - see HACK in function header
            }
            else
            {
                return TRUE;
            }
            break;
            
        case FmIfsCantLock:
            g_pDiskInfo->dwError = IDS_ERROR_GENERAL;
            ErrorMessageBox(MB_OK | MB_ICONERROR);
            return FALSE;
            
        case FmIfsAccessDenied:
            g_pDiskInfo->dwError = IDS_SRCDISKBAD;
            ErrorMessageBox(MB_OK | MB_ICONERROR);
            return FALSE;
            
        case FmIfsBadLabel:
        case FmIfsCantQuickFormat:
            g_pDiskInfo->dwError = IDS_ERROR_GENERAL;
            ErrorMessageBox(MB_OK | MB_ICONERROR);
            return FALSE;
            
        case FmIfsIoError:
            switch(((PFMIFS_IO_ERROR_INFORMATION)PacketData)->DiskType) {
            case DISK_TYPE_SOURCE:
                g_pDiskInfo->dwError = IDS_SRCDISKBAD;
                break;
            case DISK_TYPE_TARGET:
                g_pDiskInfo->dwError = IDS_DSTDISKBAD;
                break;
            default:
                // BobDay - We should never get this!!
                Assert(0);
                g_pDiskInfo->dwError = IDS_ERROR_GENERAL;
                break;
            }
            
            if (ErrorMessageBox(MB_RETRYCANCEL | MB_ICONERROR) == IDRETRY)
            {
                g_pDiskInfo->dwError = 0;
                return FALSE;	//Indicates RETRY - see HACK in function header
            }
            else
            {
                return TRUE;
            }
            break;
            
            case FmIfsNoMediaInDevice:
                {
                    // Note that we get a pointer to the unicode
                    // drive letter in the PacketData argument
                    
                    // If the drives are the same, determine if we are
                    // reading or writing with the "dest inserted" flag
                    if (g_pDiskInfo->nSrcDrive == g_pDiskInfo->nDestDrive)
                    {
                        if (g_pDiskInfo->bDestInserted)
                            g_pDiskInfo->dwError = IDS_ERROR_WRITE;
                        else
                            g_pDiskInfo->dwError = IDS_ERROR_READ;
                    }
                    else
                    {
                        // Otherwise, use the drive letter to determine this
                        // ...Check if we're reading or writing
                        int nDrive = DriveNumFromDriveLetterW(
                            (WCHAR*) PacketData);
                        
                        Assert ((nDrive == g_pDiskInfo->nSrcDrive) ||
                            (nDrive == g_pDiskInfo->nDestDrive));
                        
                        // Check if the source or dest disk was removed and set
                        // error accordingly
                        
                        if (nDrive == g_pDiskInfo->nDestDrive)
                            g_pDiskInfo->dwError = IDS_ERROR_WRITE;
                        else
                            g_pDiskInfo->dwError = IDS_ERROR_READ;
                    }
                    
                    if (ErrorMessageBox(MB_RETRYCANCEL | MB_ICONERROR) == IDRETRY)
                    {
                        g_pDiskInfo->dwError = 0;
                        
                        // Note that FALSE is returned here to indicate RETRY
                        // See HACK in the function header for explanation.
                        return FALSE;
                    }
                    else
                    {
                        return TRUE;
                    }
                }
                break;
                
                
            case FmIfsFinished:
                if (((PFMIFS_FINISHED_INFORMATION)PacketData)->Success)
                {
                    g_pDiskInfo->dwError = 0;
                }
                else
                {
                    g_pDiskInfo->dwError = IDS_ERROR_GENERAL;
                }
                break;
                
            default:
                break;
    }
    return TRUE;
}


// nDrive == 0-based drive number (a: == 0)
LPITEMIDLIST GetDrivePidl(HWND hwnd, int nDrive)
{
    TCHAR szDrive[4];
    PathBuildRoot(szDrive, nDrive);    
    
    LPITEMIDLIST pidl;
    if (FAILED(SHParseDisplayName(szDrive, NULL, &pidl, 0, NULL)))
    {
        pidl = NULL;
    }
    
    return pidl;
}

DWORD CALLBACK CopyDiskThreadProc(LPVOID lpParam)
{
    FMIFS fmifs;
    LPITEMIDLIST pidlSrc = NULL;
    LPITEMIDLIST pidlDest = NULL;
    HWND hwndProgress = GetDlgItem(g_pDiskInfo->hdlg, IDD_PROBAR);
    
    // Disable change notifications for the src drive
    pidlSrc = GetDrivePidl(g_pDiskInfo->hdlg, g_pDiskInfo->nSrcDrive);
    if (NULL != pidlSrc)
    {
        SHChangeNotifySuspendResume(TRUE, pidlSrc, TRUE, 0);
    }
    
    if (g_pDiskInfo->nSrcDrive != g_pDiskInfo->nDestDrive)
    {
        // Do the same for the dest drive since they're different
        pidlDest = GetDrivePidl(g_pDiskInfo->hdlg, g_pDiskInfo->nDestDrive);
        
        if (NULL != pidlDest)
        {
            SHChangeNotifySuspendResume(TRUE, pidlDest, TRUE, 0);
        }
    }
    
    // Change notifications are disabled; do the copy
    EnableWindow(GetDlgItem(g_pDiskInfo->hdlg, IDD_FROM), FALSE);
    EnableWindow(GetDlgItem(g_pDiskInfo->hdlg, IDD_TO), FALSE);
    
    PostMessage(hwndProgress, PBM_SETRANGE, 0, MAKELONG(0, 100));
    
    g_pDiskInfo->bFormatTried = FALSE;
    g_pDiskInfo->bNotifiedWriting = FALSE;
    g_pDiskInfo->dwError = 0;
    g_pDiskInfo->bDestInserted = FALSE;
    
    if (LoadFMIFS(&fmifs))
    {
        TCHAR szSource[4];
        TCHAR szDestination[4];
        
        //
        // Now copy the disk
        //
        PathBuildRoot(szSource, g_pDiskInfo->nSrcDrive);
        PathBuildRoot(szDestination, g_pDiskInfo->nDestDrive);
        
        SetStatusText(IDS_READING);
        
        fmifs.DiskCopy(szSource, szDestination, FALSE, CopyDiskCallback);
        
        UnloadFMIFS(&fmifs);
    }
    
    PostMessage(g_pDiskInfo->hdlg, WM_DONE_WITH_FORMAT, 0, 0);
    
    // Resume any shell notifications we've suspended and free
    // our pidls (and send updatedir notifications while we're at
    // it)
    if (NULL != pidlSrc)
    {
        SHChangeNotifySuspendResume(FALSE, pidlSrc, TRUE, 0);
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlSrc, NULL);
        ILFree(pidlSrc);
        pidlSrc = NULL;
    }
    
    if (NULL != pidlDest)
    {
        Assert(g_pDiskInfo->nSrcDrive != g_pDiskInfo->nDestDrive);
        SHChangeNotifySuspendResume(FALSE, pidlDest, TRUE, 0);
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlDest, NULL);
        ILFree(pidlDest);
        pidlDest = NULL;
    }
    
    DiskInfoRelease();
    return 0;
}

HANDLE _GetDeviceHandle(LPTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes)
{
    return CreateFile(psz, // drive to open
        dwDesiredAccess,
        FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
        NULL,    // default security attributes
        OPEN_EXISTING,  // disposition
        dwFileAttributes,       // file attributes
        NULL);   // don't copy any file's attributes
}

BOOL DriveIdIsFloppy(int iDrive)
{
    BOOL fRetVal = FALSE;
    
    if (iDrive >= 0 && iDrive < 26)
    {        
        TCHAR szTemp[] = TEXT("\\\\.\\a:");
        szTemp[4] += (TCHAR)iDrive;
        
        HANDLE hDevice = _GetDeviceHandle(szTemp, FILE_READ_ATTRIBUTES, 0);
        
        if (INVALID_HANDLE_VALUE != hDevice)
        {
            NTSTATUS status;
            IO_STATUS_BLOCK ioStatus;
            FILE_FS_DEVICE_INFORMATION DeviceInfo;
            
            status = NtQueryVolumeInformationFile(hDevice, &ioStatus, &DeviceInfo, sizeof(DeviceInfo), FileFsDeviceInformation);
            
            if ((NT_SUCCESS(status)) && 
                (FILE_DEVICE_DISK & DeviceInfo.DeviceType) &&
                (FILE_FLOPPY_DISKETTE & DeviceInfo.Characteristics))
            {
                fRetVal = TRUE;
            }
            
            CloseHandle (hDevice);
        }
    }
    
    return fRetVal;
}

int ErrorMessageBox(UINT uFlags)
{
    int iRet;
    
    // if the user didn't abort and copy didn't complete normally, post an error box
    if (g_pDiskInfo->bUserAbort || !g_pDiskInfo->dwError) 
    {
        iRet = -1;
    }
    else
    {
        TCHAR szTemp[1024];
        LoadString(g_hinst, (int)g_pDiskInfo->dwError, szTemp, ARRAYSIZE(szTemp));
        iRet = ShellMessageBox(g_hinst, g_pDiskInfo->hdlg, szTemp, NULL, uFlags);
    } 
    return iRet;
}

void SetStatusText(int id)
{
    TCHAR szMsg[128];
    LoadString(g_hinst, id, szMsg, ARRAYSIZE(szMsg));
    SendDlgItemMessage(g_pDiskInfo->hdlg, IDD_STATUS, WM_SETTEXT, 0, (LPARAM)szMsg);
}

BOOL PromptInsertDisk(LPCTSTR lpsz)
{
    for (;;) {
        DWORD dwLastErrorSrc = 0;
        DWORD dwLastErrorDest = 0 ;
        
        TCHAR szPath[4];
        if (ShellMessageBox(g_hinst, g_pDiskInfo->hdlg, lpsz, NULL, MB_OKCANCEL | MB_ICONINFORMATION) != IDOK) {
            g_pDiskInfo->bUserAbort = TRUE;
            return FALSE;
        }
        
        PathBuildRoot(szPath, g_pDiskInfo->nSrcDrive);
        
        // make sure both disks are in
        if (GetFileAttributes(szPath) == (UINT)-1)
        {
            dwLastErrorDest = GetLastError();
        }
        
        if (g_pDiskInfo->nDestDrive != g_pDiskInfo->nSrcDrive) 
        {
            szPath[0] = TEXT('A') + g_pDiskInfo->nDestDrive;
            if (GetFileAttributes(szPath) == (UINT)-1)
                dwLastErrorDest = GetLastError();
        }
        
        if (dwLastErrorDest != ERROR_NOT_READY &&
            dwLastErrorSrc != ERROR_NOT_READY)
            break;
    }
    
    return TRUE;
}

HICON GetDriveInfo(int nDrive, LPTSTR pszName, UINT cchName)
{
    HICON hIcon = NULL;
    SHFILEINFO shfi;
    TCHAR szRoot[4];
    
    *pszName = 0;
    
    if (PathBuildRoot(szRoot, nDrive))
    {
        if (SHGetFileInfo(szRoot, FILE_ATTRIBUTE_DIRECTORY, &shfi, sizeof(shfi),
            SHGFI_ICON | SHGFI_SMALLICON | SHGFI_DISPLAYNAME))
        {
            StrCpyN(pszName, shfi.szDisplayName, cchName); // for display, truncation is fine
            hIcon = shfi.hIcon;
        }
        else
        {
            StrCpyN(pszName, szRoot, cchName); // for display, truncation is fine
        }
    }
    
    return hIcon;
}

int AddDriveToListView(HWND hwndLV, int nDrive, int nDefaultDrive)
{
    TCHAR szDriveName[64];
    LV_ITEM item;
    HICON hicon = GetDriveInfo(nDrive, szDriveName, ARRAYSIZE(szDriveName));
    HIMAGELIST himlSmall = ListView_GetImageList(hwndLV, LVSIL_SMALL);
    
    if (himlSmall && hicon)
    {
        item.iImage = ImageList_AddIcon(himlSmall, hicon);
        DestroyIcon(hicon);
    }
    else
    {
        item.iImage = 0;
    }
    
    item.mask = (nDrive == nDefaultDrive) ?
        LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE :
    LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    
    item.stateMask = item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.iItem = 26;     // add at end
    item.iSubItem = 0;
    
    item.pszText = szDriveName;
    item.lParam = (LPARAM)nDrive;
    
    return ListView_InsertItem(hwndLV, &item);
}

int GetSelectedDrive(HWND hwndLV)
{
    LV_ITEM item;
    item.iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);
    if (item.iItem >= 0)
    {
        item.mask = LVIF_PARAM;
        item.iSubItem = 0;
        ListView_GetItem(hwndLV, &item);
        return (int)item.lParam;
    }
    else
    {
        // implicitly selected the 0th item
        ListView_SetItemState(hwndLV, 0, LVIS_SELECTED, LVIS_SELECTED);
        return 0;
    }
}

void InitSingleColListView(HWND hwndLV)
{
    LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT rc;
    
    GetClientRect(hwndLV, &rc);
    col.cx = rc.right;
    //  - GetSystemMetrics(SM_CXVSCROLL)
    //        - GetSystemMetrics(SM_CXSMICON)
    //        - 2 * GetSystemMetrics(SM_CXEDGE);
    ListView_InsertColumn(hwndLV, 0, &col);
}

#define g_cxSmIcon  GetSystemMetrics(SM_CXSMICON)

void PopulateListView(HWND hDlg)
{
    HWND hwndFrom = GetDlgItem(hDlg, IDD_FROM);
    HWND hwndTo   = GetDlgItem(hDlg, IDD_TO);
    int iDrive;
    
    ListView_DeleteAllItems(hwndFrom);
    ListView_DeleteAllItems(hwndTo);
    for (iDrive = 0; iDrive < 26; iDrive++)
    {
        if (DriveIdIsFloppy(iDrive))
        {
            AddDriveToListView(hwndFrom, iDrive, g_pDiskInfo->nSrcDrive);
            AddDriveToListView(hwndTo, iDrive, g_pDiskInfo->nDestDrive);
        }
    }
}

void CopyDiskInitDlg(HWND hDlg)
{
    int iDrive;
    HWND hwndFrom = GetDlgItem(hDlg, IDD_FROM);
    HWND hwndTo   = GetDlgItem(hDlg, IDD_TO);
    HIMAGELIST himl;
    
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)g_pDiskInfo);
    
    SendMessage(hDlg, WM_SETICON, 0, (LPARAM)LoadImage(GetWindowInstance(hDlg), MAKEINTRESOURCE(IDI_DISKCOPY), IMAGE_ICON, 16, 16, 0));
    SendMessage(hDlg, WM_SETICON, 1, (LPARAM)LoadIcon(GetWindowInstance(hDlg), MAKEINTRESOURCE(IDI_DISKCOPY)));
    
    g_pDiskInfo->hdlg = hDlg;
    
    InitSingleColListView(hwndFrom);
    InitSingleColListView(hwndTo);
    
    himl = ImageList_Create(g_cxSmIcon, g_cxSmIcon, ILC_MASK, 1, 4);
    if (himl)
    {
        // NOTE: only one of these is not marked LVS_SHAREIMAGELIST
        // so it will only be destroyed once
        
        ListView_SetImageList(hwndFrom, himl, LVSIL_SMALL);
        ListView_SetImageList(hwndTo, himl, LVSIL_SMALL);
    }
    
    PopulateListView(hDlg);
}


void SetCancelButtonText(HWND hDlg, int id)
{
    TCHAR szText[80];
    LoadString(g_hinst, id, szText, ARRAYSIZE(szText));
    SetDlgItemText(hDlg, IDCANCEL, szText);
}

void DoneWithFormat()
{
    int id;
    
    EnableWindow(GetDlgItem(g_pDiskInfo->hdlg, IDD_FROM), TRUE);
    EnableWindow(GetDlgItem(g_pDiskInfo->hdlg, IDD_TO), TRUE);
    
    PopulateListView(g_pDiskInfo->hdlg);
    
    SendDlgItemMessage(g_pDiskInfo->hdlg, IDD_PROBAR, PBM_SETPOS, 0, 0);
    EnableWindow(GetDlgItem(g_pDiskInfo->hdlg, IDOK), TRUE);
    
    CloseHandle(g_pDiskInfo->hThread);
    SetCancelButtonText(g_pDiskInfo->hdlg, IDS_CLOSE);
    g_pDiskInfo->hThread = NULL;
    
    if (g_pDiskInfo->bUserAbort) 
    {
        id = IDS_COPYABORTED;
    } 
    else 
    {
        switch (g_pDiskInfo->dwError) 
        {
        case 0:
            id = IDS_COPYCOMPLETED;
            break;
            
        default:
            id = IDS_COPYFAILED;
            break;
        }
    }
    SetStatusText(id);
    SetCancelButtonText(g_pDiskInfo->hdlg, IDS_CLOSE);
    
    // reset variables
    g_pDiskInfo->dwError = 0;
    g_pDiskInfo->bUserAbort = 0;
}


#pragma data_seg(".text")
const static DWORD aCopyDiskHelpIDs[] = {  // Context Help IDs
    IDOK,         IDH_DISKCOPY_START,
        IDD_FROM,     IDH_DISKCOPY_FROM,
        IDD_TO,       IDH_DISKCOPY_TO,
        IDD_STATUS,   NO_HELP,
        IDD_PROBAR,   NO_HELP,
        
        0, 0
};
#pragma data_seg()

INT_PTR CALLBACK CopyDiskDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        CopyDiskInitDlg(hDlg);
        break;
        
    case WM_DONE_WITH_FORMAT:
        DoneWithFormat();
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aCopyDiskHelpIDs);
        return TRUE;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) aCopyDiskHelpIDs);
        return TRUE;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            // if there's an hThread that means we're in copy mode, abort
            // from that, otherwise, it means quit the dialog completely
            if (g_pDiskInfo->hThread)
            {
                g_pDiskInfo->bUserAbort = TRUE;
                
                if (WaitForSingleObject(g_pDiskInfo->hThread, 5000) == WAIT_TIMEOUT)
                {
                    DoneWithFormat();
                }
                CloseHandle(g_pDiskInfo->hThread);
                g_pDiskInfo->hThread = NULL;
            }
            else
            {
                EndDialog(hDlg, IDCANCEL);
            }
            break;
            
        case IDOK:
            {
                DWORD idThread;
                
                SetLastError(0);
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                
                // set cancel button to "Cancel"
                SetCancelButtonText(hDlg, IDS_CANCEL);
                
                g_pDiskInfo->nSrcDrive  = GetSelectedDrive(GetDlgItem(hDlg, IDD_FROM));
                g_pDiskInfo->nDestDrive = GetSelectedDrive(GetDlgItem(hDlg, IDD_TO));
                
                // remove all items except the drives we're using
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDD_FROM));
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDD_TO));
                AddDriveToListView(GetDlgItem(hDlg, IDD_FROM), g_pDiskInfo->nSrcDrive, g_pDiskInfo->nSrcDrive);
                AddDriveToListView(GetDlgItem(hDlg, IDD_TO), g_pDiskInfo->nDestDrive, g_pDiskInfo->nDestDrive);
                
                g_pDiskInfo->bUserAbort = FALSE;
                
                SendDlgItemMessage(hDlg, IDD_PROBAR, PBM_SETPOS, 0, 0);
                SendDlgItemMessage(g_pDiskInfo->hdlg, IDD_STATUS, WM_SETTEXT, 0, 0);
                
                Assert(g_pDiskInfo->hThread == NULL);
                
                DiskInfoAddRef();
                g_pDiskInfo->hThread = CreateThread(NULL, 0, CopyDiskThreadProc, g_pDiskInfo, 0, &idThread);
                if (!g_pDiskInfo->hThread)
                {
                    DiskInfoRelease();
                }
            }
            break;
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;
}

// ensure only one instance is running
HANDLE AnotherCopyRunning()
{
    HANDLE hMutex = CreateMutex(NULL, FALSE, TEXT("DiskCopyMutex"));

    if (hMutex && GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else
        CloseHandle(hMutex);
        hMutex = NULL;
    }

    return hMutex;
}
int SHCopyDisk(HWND hwnd, int nSrcDrive, int nDestDrive, DWORD dwFlags)
{
    int iRet = 0;

    HANDLE hMutex = AnotherCopyRunning();
    if (hMutex)
    {    
        g_pDiskInfo = (DISKINFO*)LocalAlloc(LPTR, sizeof(DISKINFO));
        if (g_pDiskInfo)
        {
            g_pDiskInfo->nSrcDrive = nSrcDrive;
            g_pDiskInfo->nDestDrive = nDestDrive;
            g_pDiskInfo->cRef = 1;
        
            iRet = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(DLG_DISKCOPYPROGRESS), hwnd, CopyDiskDlgProc, (LPARAM)g_pDiskInfo);
        
            DiskInfoRelease();
        }
        CloseHandle(hMutex);
    }
    
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\makeboot.cpp ===
#include "diskcopy.h"
#include "ids.h"
#include "help.h"

#include "makeboot.h"
#include <strsafe.h>

// todo: add check that we can only make boot disks on 3.5 disks

UINT _GetClassFromCP (UINT iOEMCP)
{
    for (int i = 0; i < ARRAYSIZE(rgCPtoClassMap); i++)
    {
        if (iOEMCP == rgCPtoClassMap[i].iCP)
        {
            return rgCPtoClassMap[i].iClass;
        }
    }
    return 0; // default        
}

UINT _GetKBFromLangId(WORD wLangId)
{
    for (int i = 0; i < ARRAYSIZE(rgLangIdtoKBMap); i++)
    {
        if (wLangId == rgLangIdtoKBMap[i].wLangId)
        {
            return rgLangIdtoKBMap[i].iKB;
        }
    }

    // if we don't get an exact match, try to match just the primary lang id
    for (int i = 0; i < ARRAYSIZE(rgLangIdtoKBMap); i++)
    {
        if (PRIMARYLANGID(wLangId) == PRIMARYLANGID(rgLangIdtoKBMap[i].wLangId))
        {
            return rgLangIdtoKBMap[i].iKB;
        }
    }

    // if all else fails, default to US keyboard
    return KEYBOARD_US;
}

UINT _GetClassFromKB (UINT iKB)
{
    for (int i = 0; i < ARRAYSIZE(rgKBtoClassMap); i++)
    {
        if (iKB == rgKBtoClassMap[i].iKB)
        {
            return rgKBtoClassMap[i].iClass;
        }
    }
    return KBCLASS_1; // default
}

BOOL _GetKeyboardID(UINT iKB, UINT* piID)
{
    BOOL fRet = FALSE;

    switch (iKB)
    {
    case KEYBOARD_HE:
        *piID = 400;
        fRet = TRUE;
        break;
    case KEYBOARD_TR:
        *piID = 179;
        fRet = TRUE;
        break;
    }
    return fRet;
}

typedef struct {
    UINT OEMCP;
    UINT KB;
} LANGSETTINGS;


HRESULT _GetAutoexecOEMCP(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{
    return StringCchPrintfA(pszBuffer, cchBuffer, "%d", pls->OEMCP);
}

HRESULT _GetAutoexecEGAFname(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{
    LoadStringA(hInstance, IDS_DOSBOOTDISK_AUTOEXEC_EGA_1 + _GetClassFromCP(pls->OEMCP), pszBuffer, cchBuffer);
    return S_OK;
}

HRESULT _GetConfigSysEGA(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{    
    LoadStringA(hInstance, IDS_DOSBOOTDISK_CONFIG_EGA_1 + _GetClassFromCP(pls->OEMCP), pszBuffer, cchBuffer);
    return S_OK;
}

HRESULT _GetAutoexecKeybCode(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{
    LoadStringA(hInstance, IDS_DOSBOOTDISK_KEYBOARD_CODE_US + pls->KB, pszBuffer, cchBuffer);
    return S_OK;
}

HRESULT _GetAutoexecKeybFname(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{
    LoadStringA(hInstance, IDS_DOSBOOTDISK_KEYBOARD_FNAME_1 + _GetClassFromKB(pls->KB), pszBuffer, cchBuffer);
    return S_OK;
}

HRESULT _GetConfigKeybID(HINSTANCE hInstance, LANGSETTINGS* pls, LPSTR pszBuffer, UINT cchBuffer)
{
    HRESULT hr = E_FAIL;
    UINT iID;
    if (_GetKeyboardID(pls->KB, &iID))
    {
        hr = StringCchPrintfA(pszBuffer, cchBuffer, "%d", iID);
    }

    return hr;
}


HANDLE _CreateSystemFile(HINSTANCE hInstance, UINT iDrive, UINT id)
{
    HANDLE handle = INVALID_HANDLE_VALUE;

    TCHAR szFname[MAX_PATH];
    LoadString(hInstance, id, szFname, ARRAYSIZE(szFname));

    TCHAR szPath[MAX_PATH];
    PathBuildRoot(szPath, iDrive);
    if (PathAppend(szPath, szFname))
    {
        handle = CreateFile(szPath, GENERIC_WRITE | GENERIC_READ, 0, 
                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    
    return handle;
}

HRESULT _WriteAutoexec(HINSTANCE hInstance, UINT iDrive, LANGSETTINGS* pls)
{
    HRESULT hr = E_FAIL;

    HANDLE hFile = _CreateSystemFile(hInstance, iDrive, IDS_DOSBOOTDISK_AUTOEXEC_FNAME);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (437 != pls->OEMCP && // use empty autoexec.bat on US locale
            932 != pls->OEMCP && // use empty autoexec.bat on Japanese locale
            949 != pls->OEMCP && // use empty autoexec.bat on Korean locale
            936 != pls->OEMCP && // use empty autoexec.bat on CHS locale
            950 != pls->OEMCP)   // use empty autoexec.bat on CHT locale
        {
            CHAR aszBufferOEMCP[4];
            CHAR aszBufferEGAFname[13];
            CHAR aszBufferKeybCode[3];
            CHAR aszBufferKeybFname[13];
            if (SUCCEEDED(_GetAutoexecOEMCP(hInstance, pls, aszBufferOEMCP, ARRAYSIZE(aszBufferOEMCP))) &&
                SUCCEEDED(_GetAutoexecEGAFname(hInstance, pls, aszBufferEGAFname, ARRAYSIZE(aszBufferEGAFname))) &&
                SUCCEEDED(_GetAutoexecKeybCode(hInstance, pls, aszBufferKeybCode, ARRAYSIZE(aszBufferKeybCode))) &&
                SUCCEEDED(_GetAutoexecKeybFname(hInstance, pls, aszBufferKeybFname, ARRAYSIZE(aszBufferKeybFname))))
            {
                CHAR aszTemplate[1000];
                CHAR aszKeyboardID[5];
                if (SUCCEEDED(_GetConfigKeybID(hInstance, pls, aszKeyboardID, ARRAYSIZE(aszKeyboardID))))
                {
                    LoadStringA(hInstance, IDS_DOSBOOTDISK_AUTOEXEC_TEMPLATE_WITH_CODE, aszTemplate, ARRAYSIZE(aszTemplate));
                }
                else
                {
                    LoadStringA(hInstance, IDS_DOSBOOTDISK_AUTOEXEC_TEMPLATE, aszTemplate, ARRAYSIZE(aszTemplate));
                }
                
                CHAR aszBuffer[1000];
                hr = StringCchPrintfA(aszBuffer, ARRAYSIZE(aszBuffer), aszTemplate, 
                                      aszBufferOEMCP, aszBufferEGAFname, aszBufferOEMCP, 
                                      aszBufferKeybCode, aszBufferKeybFname, aszKeyboardID);
                if (SUCCEEDED(hr))
                {
                    DWORD cbWritten;
                    WriteFile(hFile, aszBuffer, sizeof(CHAR) * lstrlenA(aszBuffer), &cbWritten, NULL);
                }
            }
        }
        CloseHandle(hFile);
    }

    return hr;
}

HRESULT _WriteConfigSys(HINSTANCE hInstance, UINT iDrive, LANGSETTINGS* pls)
{
    HRESULT hr = E_FAIL;

    HANDLE hFile = _CreateSystemFile(hInstance, iDrive, IDS_DOSBOOTDISK_CONFIG_FNAME);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (437 != pls->OEMCP && // use empty config.sys on US locale
            932 != pls->OEMCP && // use empty config.sys on Japanese locale
            949 != pls->OEMCP && // use empty config.sys on Korean locale
            936 != pls->OEMCP && // use empty config.sys on CHS locale
            950 != pls->OEMCP)   // use empty config.sys on CHT locale
        {
            CHAR aszTemplate[1000];
            CHAR aszBufferEGA[64];
            LoadStringA(hInstance, IDS_DOSBOOTDISK_CONFIG_TEMPLATE, aszTemplate, ARRAYSIZE(aszTemplate));
            if (SUCCEEDED(_GetConfigSysEGA(hInstance, pls, aszBufferEGA, ARRAYSIZE(aszBufferEGA))))
            {
                CHAR aszBuffer[1000];
                hr = StringCchPrintfA(aszBuffer, ARRAYSIZE(aszBuffer), aszTemplate, aszBufferEGA);
                if (SUCCEEDED(hr))
                {
                    DWORD cbWritten;
                    WriteFile(hFile, aszBuffer, sizeof(CHAR) * lstrlenA(aszBuffer), &cbWritten, NULL);
                    hr = S_OK;
                }
            }
        }
        CloseHandle(hFile);
    }
    return hr;
}


HRESULT _LoadUISettings (LANGSETTINGS* pls)
{
    pls->OEMCP = GetOEMCP();
    pls->KB = _GetKBFromLangId(LOWORD(GetKeyboardLayout(0)));
    if (KBCLASS_BLANK == _GetClassFromKB(pls->KB))
    {
        pls->KB = _GetKBFromLangId(GetSystemDefaultUILanguage());
    }
    return S_OK;
}

HRESULT _WriteDiskImage(HINSTANCE hInstance, UINT iDrive, BOOL* pfCancelled, FMIFS_CALLBACK pCallback)
{
    HRESULT hr = E_FAIL;
    HRSRC hrsrc = FindResourceW(hInstance, MAKEINTRESOURCEW(IDX_DOSBOOTDISK), L"BINFILE");
    if (hrsrc)
    {
        HGLOBAL hglob = LoadResource(hInstance, hrsrc);
        if (hglob)
        {
            BYTE* pbPtr = (BYTE*)hglob;
            DWORD cbGlob = SizeofResource(hInstance, hrsrc);
            
            TCHAR szDrive[] = TEXT("\\\\.\\a:");
            szDrive[4] += (TCHAR)iDrive;
            HANDLE hFloppyDrive = CreateFile(szDrive, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                             OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH, NULL );
            
            if (INVALID_HANDLE_VALUE ==  hFloppyDrive)
            {            
                pCallback(FmIfsAccessDenied, 0, NULL);
            }
            else
            {
                hr = S_OK;
                
                CHAR  TrackBuffer[TRACK_SIZE];
                DWORD  cBytesRead       = 0;
                DWORD  cBytesWritten    = 0;
                INT    iCurrentTrack;
                
                for( iCurrentTrack = 0; iCurrentTrack < TRACKS_ON_DISK && SUCCEEDED(hr) && !*pfCancelled; iCurrentTrack++ )
                {
                    DWORD cbRead;
                    cbRead = __min(cbGlob, TRACK_SIZE);
                    CopyMemory(TrackBuffer, pbPtr, cbRead);
                    pbPtr += cbRead;
                    cbGlob -= cbRead;
                    
                    if( ! WriteFile( hFloppyDrive, TrackBuffer, cbRead, &cBytesWritten, NULL ) )
                    {                        
                        pCallback(FmIfsIoError, 0, NULL);
                        hr = E_FAIL;                        
                    }
                    else
                    {                    
                        FMIFS_PERCENT_COMPLETE_INFORMATION pci;
                        pci.PercentCompleted = (100 * iCurrentTrack) / TRACKS_ON_DISK;                        
                        pCallback(FmIfsPercentCompleted, sizeof(FMIFS_PERCENT_COMPLETE_INFORMATION), &pci);
                    }
                }
                CloseHandle(hFloppyDrive);
            }
            FreeResource(hglob);
        }
    }
    return hr;
}

HRESULT MakeBootDisk(HINSTANCE hInstance, UINT iDrive, BOOL* pfCancelled, FMIFS_CALLBACK pCallback)
{
    HRESULT hr = _WriteDiskImage(hInstance, iDrive, pfCancelled, pCallback);
    // if we didn't cancel or fail, then place autoexec.bat and config.sys on the disk as well
    if (SUCCEEDED(hr) && !*pfCancelled)
    {
        LANGSETTINGS ls;
        hr = _LoadUISettings(&ls);
        if (SUCCEEDED(hr))
        {
            _WriteAutoexec(hInstance, iDrive, &ls);
            _WriteConfigSys(hInstance, iDrive, &ls);

            FMIFS_FINISHED_INFORMATION pfi;
            pfi.Success = TRUE;
            pCallback(FmIfsFinished, sizeof(FMIFS_FINISHED_INFORMATION), &pfi);
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\makeboot.h ===
#define BYTES_PER_SECTOR         512
#define SECTORS_PER_TRACK        18
#define TRACK_SIZE               (SECTORS_PER_TRACK * BYTES_PER_SECTOR)
#define TRACKS_ON_DISK           (80 * 2)  // * 2 because it is double-sided

#define CPCLASS_DEFAULT     99
#define CPCLASS_EGA         0
#define CPCLASS_EGA2        1
#define CPCLASS_EGA3        2
#define CPCLASS_EGA4        3
#define CPCLASS_HEBEGA      4

typedef struct {
    UINT iCP;
    UINT iClass;
} CLASSFROMCP;

const CLASSFROMCP rgCPtoClassMap[] =
{{1258, CPCLASS_DEFAULT},
{874, CPCLASS_DEFAULT},
{932, CPCLASS_DEFAULT},
{936, CPCLASS_DEFAULT},
{949, CPCLASS_DEFAULT},
{950, CPCLASS_DEFAULT},
{708, CPCLASS_DEFAULT},
{709, CPCLASS_DEFAULT},
{710, CPCLASS_DEFAULT},
{860, CPCLASS_DEFAULT},
{861, CPCLASS_DEFAULT},
{863, CPCLASS_DEFAULT},
{864, CPCLASS_DEFAULT},
{865, CPCLASS_DEFAULT},

{850, CPCLASS_EGA},
{852, CPCLASS_EGA},
{437, CPCLASS_EGA},

{869, CPCLASS_EGA2},
{737, CPCLASS_EGA2},
{857, CPCLASS_EGA2},

{866, CPCLASS_EGA3},
{775, CPCLASS_EGA3},
{855, CPCLASS_EGA3},

{720, CPCLASS_EGA4},

{862, CPCLASS_HEBEGA}};

#define KEYBOARD_US         0
#define KEYBOARD_GR         1
#define KEYBOARD_HE         2
#define KEYBOARD_FR         3
#define KEYBOARD_SP         4
#define KEYBOARD_IT         5
#define KEYBOARD_SV         6
#define KEYBOARD_NL         7
#define KEYBOARD_BR         8
#define KEYBOARD_NO         9
#define KEYBOARD_DK        10
#define KEYBOARD_SU        11
#define KEYBOARD_RU        12
#define KEYBOARD_CZ        13
#define KEYBOARD_PL        14
#define KEYBOARD_HU        15
#define KEYBOARD_PO        16
#define KEYBOARD_TR        17
#define KEYBOARD_GK        18
#define KEYBOARD_BL        19
#define KEYBOARD_BG        20
#define KEYBOARD_YU        21
#define KEYBOARD_BE        22
#define KEYBOARD_CF        23
#define KEYBOARD_UK        24
#define KEYBOARD_ET        25
#define KEYBOARD_SF        26
#define KEYBOARD_SG        27
#define KEYBOARD_IS        28
#define KEYBOARD_IME       29
#define KEYBOARD_RO        30
#define KEYBOARD_YC        31
#define KEYBOARD_LA        32
#define KEYBOARD_UR        33
#define KEYBOARD_SL        34

typedef struct {
    WORD wLangId;
    UINT iKB;
} KBFROMLANGID;

const KBFROMLANGID rgLangIdtoKBMap[] = 
{{MAKELANGID(LANG_AFRIKAANS,0), KEYBOARD_US},
{MAKELANGID(LANG_ALBANIAN,0),   KEYBOARD_US},
{0x45e,                         KEYBOARD_US}, // AMHARIC
{MAKELANGID(LANG_ARABIC,0),     KEYBOARD_US},
{MAKELANGID(LANG_ARMENIAN,0),   KEYBOARD_US},
{MAKELANGID(LANG_ASSAMESE,0),   KEYBOARD_US},
{MAKELANGID(LANG_AZERI,0),      KEYBOARD_US},
{MAKELANGID(LANG_BASQUE,0),     KEYBOARD_SP},
{MAKELANGID(LANG_BELARUSIAN,0), KEYBOARD_BL},
{MAKELANGID(LANG_BENGALI,0),    KEYBOARD_US},
{0x101a,                        KEYBOARD_US}, // BOSNIA/HERZEGOVINA
{MAKELANGID(LANG_BULGARIAN,0),  KEYBOARD_BG},
{0x455,                         KEYBOARD_US}, // BURMESE
{MAKELANGID(LANG_CATALAN,0),    KEYBOARD_SP},
{0x45c,                         KEYBOARD_US}, // CHEROKEE
{MAKELANGID(LANG_CHINESE,0),    KEYBOARD_US},
{MAKELANGID(LANG_CROATIAN,0),   KEYBOARD_YU},
{0x450,                         KEYBOARD_US}, // CYRILLIC
{MAKELANGID(LANG_CZECH,0),      KEYBOARD_CZ},
{MAKELANGID(LANG_DANISH,0),     KEYBOARD_DK},

{MAKELANGID(LANG_DUTCH,0),                     KEYBOARD_NL},
{MAKELANGID(LANG_DUTCH,SUBLANG_DUTCH_BELGIAN), KEYBOARD_BE},

{MAKELANGID(LANG_ENGLISH,0),                    KEYBOARD_US},
{0x4409,                                        KEYBOARD_US}, // ENGLISH / MALAYSIA
{MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_UK),   KEYBOARD_UK},
{MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_CAN),  KEYBOARD_CF},
{MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_EIRE), KEYBOARD_UK},
{0x1809,                                        KEYBOARD_UK}, // ENGLISH / IRELAND


{MAKELANGID(LANG_ESTONIAN,0), KEYBOARD_ET},
{MAKELANGID(LANG_FAEROESE,0), KEYBOARD_DK},
{MAKELANGID(LANG_FARSI,0),    KEYBOARD_US},
{MAKELANGID(LANG_FINNISH,0),  KEYBOARD_SU},

{MAKELANGID(LANG_FRENCH,0),                       KEYBOARD_FR},
{MAKELANGID(LANG_FRENCH,SUBLANG_FRENCH_BELGIAN),  KEYBOARD_BE},
{MAKELANGID(LANG_FRENCH,SUBLANG_FRENCH_CANADIAN), KEYBOARD_CF},
{MAKELANGID(LANG_FRENCH,SUBLANG_FRENCH_SWISS),    KEYBOARD_SF},

{0x462,                       KEYBOARD_US}, // FRISIAN
{0x83c,                       KEYBOARD_UK}, // GAELIC / IRELAND
{0x43c,                       KEYBOARD_UK}, // GAELIC / SCOTLAND
{0x456,                       KEYBOARD_SP}, // GALICIAN
{MAKELANGID(LANG_GEORGIAN,0), KEYBOARD_US},

{MAKELANGID(LANG_GERMAN,0),                    KEYBOARD_GR},
{MAKELANGID(LANG_GERMAN,SUBLANG_GERMAN_SWISS), KEYBOARD_SG},

{MAKELANGID(LANG_GREEK,0),      KEYBOARD_GK},
{MAKELANGID(LANG_GUJARATI,0),   KEYBOARD_US},
{MAKELANGID(LANG_HEBREW,0),     KEYBOARD_HE},
{MAKELANGID(LANG_HINDI,0),      KEYBOARD_US},
{MAKELANGID(LANG_HUNGARIAN,0),  KEYBOARD_HU},
{MAKELANGID(LANG_ICELANDIC,0),  KEYBOARD_IS},
{MAKELANGID(LANG_INDONESIAN,0), KEYBOARD_US},
{0x45e,                         KEYBOARD_US}, // INUKITUT
{MAKELANGID(LANG_ITALIAN,0),    KEYBOARD_IT},
{MAKELANGID(LANG_JAPANESE,0),   KEYBOARD_IME},
{MAKELANGID(LANG_KANNADA,0),    KEYBOARD_US},
{MAKELANGID(LANG_KASHMIRI,0),   KEYBOARD_US},
{MAKELANGID(LANG_KAZAK,0),      KEYBOARD_US},
{0x453,                         KEYBOARD_US}, // KHMER
{0x440,                         KEYBOARD_US}, // KIRGHIZ
{MAKELANGID(LANG_KONKANI,0),    KEYBOARD_US},
{MAKELANGID(LANG_KOREAN,0),     KEYBOARD_IME},
{0x454,                         KEYBOARD_US}, // LAO
{0x464,                         KEYBOARD_US}, // LATIN (VATICAN)
{MAKELANGID(LANG_LATVIAN,0),    KEYBOARD_US},
{MAKELANGID(LANG_LITHUANIAN,0), KEYBOARD_US},
{MAKELANGID(LANG_MACEDONIAN,0), KEYBOARD_US},
{MAKELANGID(LANG_MALAY,0),      KEYBOARD_US},
{MAKELANGID(LANG_MALAYALAM,0),  KEYBOARD_US},
{0x43e,                         KEYBOARD_US}, // MALAYSIAN
{0x43a,                         KEYBOARD_US}, // MALTESE
{MAKELANGID(LANG_MANIPURI,0),   KEYBOARD_US},
{MAKELANGID(LANG_MARATHI,0),    KEYBOARD_US},
{0x850,                         KEYBOARD_US}, // MONGOLIAN
{MAKELANGID(LANG_NEPALI,0),     KEYBOARD_US},
{MAKELANGID(LANG_NEUTRAL,0),    KEYBOARD_US},
{MAKELANGID(LANG_NORWEGIAN,0),  KEYBOARD_NO},
{MAKELANGID(LANG_ORIYA,0),      KEYBOARD_US},
{0x463,                         KEYBOARD_US}, // PASHTO
{MAKELANGID(LANG_POLISH,0),     KEYBOARD_PL},

{MAKELANGID(LANG_PORTUGUESE,0),                            KEYBOARD_PO},
{MAKELANGID(LANG_PORTUGUESE,SUBLANG_PORTUGUESE_BRAZILIAN), KEYBOARD_BR},

{MAKELANGID(LANG_PUNJABI,0),  KEYBOARD_US},
{0x417,                       KEYBOARD_US}, // RHAETO-ROMANIC
{MAKELANGID(LANG_ROMANIAN,0), KEYBOARD_RO},
{MAKELANGID(LANG_RUSSIAN,0),  KEYBOARD_RU},
{0x43b,                       KEYBOARD_US}, // SAMI (LAPPISH)
{MAKELANGID(LANG_SANSKRIT,0), KEYBOARD_US},

{MAKELANGID(LANG_SERBIAN,0),                        KEYBOARD_YC},
{MAKELANGID(LANG_SERBIAN,SUBLANG_SERBIAN_CYRILLIC), KEYBOARD_YC},
{MAKELANGID(LANG_SERBIAN,SUBLANG_SERBIAN_LATIN),    KEYBOARD_YU},

{MAKELANGID(LANG_SINDHI,0),     KEYBOARD_US},
{0x45b,                         KEYBOARD_US}, // SINHALESE
{MAKELANGID(LANG_SLOVAK,0),     KEYBOARD_SL},
{MAKELANGID(LANG_SLOVENIAN,0),  KEYBOARD_YU},
{0x42e,                         KEYBOARD_US}, // SORBIAN

{MAKELANGID(LANG_SPANISH,0),                                  KEYBOARD_SP},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_ARGENTINA),          KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_BOLIVIA),            KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_CHILE),              KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_COLOMBIA),           KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_COSTA_RICA),         KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_DOMINICAN_REPUBLIC), KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_ECUADOR),            KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_EL_SALVADOR),        KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_GUATEMALA),          KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_HONDURAS),           KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_MEXICAN),            KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_NICARAGUA),          KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_PANAMA),             KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_PARAGUAY),           KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_PERU),               KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_PUERTO_RICO),        KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_MODERN),             KEYBOARD_SP},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_URUGUAY),            KEYBOARD_LA},
{MAKELANGID(LANG_SPANISH,SUBLANG_SPANISH_VENEZUELA),          KEYBOARD_LA},

{0x430,                         KEYBOARD_US}, // SUTU
{MAKELANGID(LANG_SWAHILI,0),    KEYBOARD_US},
{MAKELANGID(LANG_SWEDISH,0),    KEYBOARD_SV},
{0x45a,                         KEYBOARD_US}, // SYRIAC
{0x428,                         KEYBOARD_US}, // TAJIK
{MAKELANGID(LANG_TAMIL,0),      KEYBOARD_US},
{MAKELANGID(LANG_TATAR,0),      KEYBOARD_US},
{MAKELANGID(LANG_TELUGU,0),     KEYBOARD_US},
{MAKELANGID(LANG_THAI,0),       KEYBOARD_US},
{0x451,                         KEYBOARD_US}, // TIBETAN
{0x431,                         KEYBOARD_US}, // TSONGA
{0x432,                         KEYBOARD_US}, // TSWANA
{MAKELANGID(LANG_TURKISH,0),    KEYBOARD_TR},
{0x442,                         KEYBOARD_US}, // TURKMEN
{MAKELANGID(LANG_UKRAINIAN,0),  KEYBOARD_UR},
{MAKELANGID(LANG_URDU,0),       KEYBOARD_US},
{MAKELANGID(LANG_UZBEK,0),      KEYBOARD_US},
{0x433,                         KEYBOARD_US}, // VENDA
{MAKELANGID(LANG_VIETNAMESE,0), KEYBOARD_US},
{0x452,                         KEYBOARD_US}, // WELSH
{0x434,                         KEYBOARD_US}, // XHOSA
{0x43d,                         KEYBOARD_US}, // YIDDISH
{0x435,                         KEYBOARD_US}};// ZULU

#define KBCLASS_1           0
#define KBCLASS_2           1
#define KBCLASS_3           2
#define KBCLASS_4           3
#define KBCLASS_BLANK       99

typedef struct {
    UINT iKB;
    UINT iClass;
} CLASSFROMKB;

const CLASSFROMKB rgKBtoClassMap[] =
{{KEYBOARD_US, KBCLASS_BLANK},
{KEYBOARD_GR, KBCLASS_1},
{KEYBOARD_HE, KBCLASS_4},
{KEYBOARD_FR, KBCLASS_1},
{KEYBOARD_SP, KBCLASS_1},
{KEYBOARD_IT, KBCLASS_1},
{KEYBOARD_SV, KBCLASS_1},
{KEYBOARD_NL, KBCLASS_1},
{KEYBOARD_BR, KBCLASS_1},
{KEYBOARD_NO, KBCLASS_1},
{KEYBOARD_DK, KBCLASS_1},
{KEYBOARD_SU, KBCLASS_1},
{KEYBOARD_RU, KBCLASS_3},
{KEYBOARD_CZ, KBCLASS_2},
{KEYBOARD_PL, KBCLASS_4},
{KEYBOARD_HU, KBCLASS_2},
{KEYBOARD_PO, KBCLASS_1},
{KEYBOARD_TR, KBCLASS_2},
{KEYBOARD_GK, KBCLASS_4},
{KEYBOARD_BL, KBCLASS_3},
{KEYBOARD_BG, KBCLASS_2},
{KEYBOARD_YU, KBCLASS_2},
{KEYBOARD_BE, KBCLASS_1},
{KEYBOARD_CF, KBCLASS_2},
{KEYBOARD_UK, KBCLASS_1},
{KEYBOARD_ET, KBCLASS_4},
{KEYBOARD_SF, KBCLASS_1},
{KEYBOARD_SG, KBCLASS_1},
{KEYBOARD_IS, KBCLASS_2},
{KEYBOARD_IME,KBCLASS_1},
{KEYBOARD_RO, KBCLASS_2},
{KEYBOARD_YC, KBCLASS_2},
{KEYBOARD_LA, KBCLASS_1},
{KEYBOARD_UR, KBCLASS_3},
{KEYBOARD_SL, KBCLASS_2}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cscui\sniff\main.cpp ===
#include "pch.h"
#pragma hdrstop

#include <tchar.h>      // _tprintf
#include <initguid.h>
#include "uuid.h"
#include <ccstock.h>

#include "util.h"
#include "config.h"
#include "security.h"

const TCHAR g_szKeyPolicy[]                     = TEXT("Software\\Policies\\Microsoft\\Windows\\NetCache");
const TCHAR g_szKeyPrefs[]                      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache");
const TCHAR g_szKeyCustomActions[]              = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache\\CustomGoOfflineActions");
const TCHAR g_szValEnabled[]                    = TEXT("Enabled");
const TCHAR g_szValEncrypted[]                  = TEXT("Encrypted");
const TCHAR g_szValGoOfflineAction[]            = TEXT("GoOfflineAction");
const TCHAR g_szValDefCacheSize[]               = TEXT("DefCacheSize");
const TCHAR g_szValNoConfigCache[]              = TEXT("NoConfigCache");
const TCHAR g_szValNoCacheViewer[]              = TEXT("NoCacheViewer");
const TCHAR g_szValNoMakeAvailableOffline[]     = TEXT("NoMakeAvailableOffline");
const TCHAR g_szValNoReminders[]                = TEXT("NoReminders");
const TCHAR g_szValNoConfigReminders[]          = TEXT("NoConfigReminders");
const TCHAR g_szValSyncAtLogoff[]               = TEXT("SyncAtLogoff");
const TCHAR g_szValReminderFreqMinutes[]        = TEXT("ReminderFreqMinutes");
const TCHAR g_szValInitialBalloonTimeout[]      = TEXT("InitialBalloonTimeoutSeconds");
const TCHAR g_szValReminderBalloonTimeout[]     = TEXT("ReminderBalloonTimeoutSeconds");
const TCHAR g_szValFirstPinWizardShown[]        = TEXT("FirstPinWizardShown");
const TCHAR g_szValExpandStatusDlg[]            = TEXT("ExpandStatusDlg");
const TCHAR g_szValFormatCscDb[]                = TEXT("FormatDatabase");
const TCHAR g_szValEventLoggingLevel[]          = TEXT("EventLoggingLevel");
const TCHAR g_szValPurgeAtLogoff[]              = TEXT("PurgeAtLogoff");
const TCHAR g_szValExtExclusionList[]           = TEXT("ExtExclusionList");
const TCHAR g_szValAlwaysPinSubFolders[]        = TEXT("AlwaysPinSubFolders");
const TCHAR g_szNA[]                            = TEXT("<n/a>");

const DWORD POL_CU    = 0x0001; // Current user
const DWORD POL_LM    = 0x0002; // Local machine
const DWORD PREF_CU   = 0x0004;
const DWORD PREF_LM   = 0x0008;
const DWORD PREF_BOTH = PREF_CU | PREF_LM;
const DWORD POL_BOTH  = POL_CU | POL_LM;
const DWORD REG_ALL   = PREF_BOTH | POL_BOTH;

const DWORD PREF   = 1;
const DWORD POLICY = 2;


LPTSTR GoOfflineActionText(
    int iValue,
    LPTSTR pszDest
    )
{
    LPCTSTR rgpsz[] = { TEXT("(Work offline)"),
                        TEXT("(No offline)") };

    if (iValue >= 0 && iValue < ARRAYSIZE(rgpsz))
        lstrcpy(pszDest, rgpsz[iValue]);
    else
        lstrcpy(pszDest, TEXT("<unknown>"));

    return pszDest;
}


LPTSTR SyncAtLogoffText(
    int iValue,
    LPTSTR pszDest
    )
{
    LPCTSTR rgpsz[] = { TEXT("(Part sync)"),
                        TEXT("(Full sync)") };

    if (iValue >= 0 && iValue < ARRAYSIZE(rgpsz))
        lstrcpy(pszDest, rgpsz[iValue]);
    else
        lstrcpy(pszDest, TEXT("<unknown>"));

    return pszDest;
}


LPTSTR DefCacheSizeText(
    int iValue,
    LPTSTR pszDest
    )
{
    wsprintf(pszDest, TEXT("(%2d.%02d %%)"), iValue / 100, iValue % 100);
    return pszDest;
}


LPCTSTR BoolText(bool b)
{
    static const LPCTSTR rgYN[] = { TEXT("No"), TEXT("Yes") };
    return rgYN[int(b)];
}



LPCTSTR 
RegValStr(
    HKEY hkeyRoot, 
    LPCTSTR pszSubkey, 
    LPCTSTR pszValue, 
    LPTSTR pszDest
    )
{
    DWORD dwValue = 0;
    DWORD cbData = sizeof(dwValue);
    DWORD dwType;

    DWORD dwError = SHGetValue(hkeyRoot,
                               pszSubkey,
                               pszValue,
                               &dwType,
                               (LPVOID)&dwValue,
                               &cbData);

    if (ERROR_SUCCESS == dwError)
    {
        wsprintf(pszDest, TEXT("%d"), dwValue);
    }
    else if (ERROR_FILE_NOT_FOUND == dwError)
    {
        lstrcpy(pszDest, TEXT("<none>"));
    }
    else
    {
        wsprintf(pszDest, TEXT("Err %d"), dwError);
    }
    return pszDest;
}


LPTSTR GetOsVersionInfoText(
    LPTSTR pszDest
    )
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    *pszDest = TEXT('\0');
    if (GetVersionEx(&osvi))
    {
        static const TCHAR szUnknown[] = TEXT("Unknown OS");
        static const struct
        {
            DWORD dwPlatform;
            DWORD dwMinorVersion;
            LPCTSTR pszPlatform;

        } rgPlatforms[] = {{ VER_PLATFORM_WIN32s,        (DWORD)-1, TEXT("Win32s")     },
                           { VER_PLATFORM_WIN32_WINDOWS,         0, TEXT("Windows 95") },
                           { VER_PLATFORM_WIN32_WINDOWS,        10, TEXT("Windows 98") },
                           { VER_PLATFORM_WIN32_NT,      (DWORD)-1, TEXT("Windows NT") }};

        static const struct
        {
            DWORD dwOS;
            LPCTSTR pszOS;

        } rgOS[] = {{ OS_WIN2000TERMINAL,   TEXT("Windows 2000 Terminal")        },
                    { OS_WIN2000PRO,        TEXT("Windows 2000 Professional")    },
                    { OS_WIN2000ADVSERVER,  TEXT("Windows 2000 Advanced Server") },
                    { OS_WIN2000DATACENTER, TEXT("Windows 2000 Data Center")     },
                    { OS_WIN2000SERVER,     TEXT("Windows 2000 Server")          },
                    { OS_WIN2000,           TEXT("Windows 2000")                 },
                    { OS_NT5,               TEXT("Windows NT")                   },
                    { OS_NT4,               TEXT("Windows NT")                   },
                    { OS_NT,                TEXT("Windows NT")                   },
                    { OS_MEMPHIS_GOLD,      TEXT("Windows 98")                   },
                    { OS_MEMPHIS,           TEXT("Windows 98 (beta)")            },
                    { OS_WIN95,             TEXT("Windows 95")                   },
                    { OS_WINDOWS,           TEXT("Windows")                      }};


        LPCTSTR pszPlatform = szUnknown;
        int i = 0;

        //
        // IsOS() is the shlwapi API for figuring out the OS type.  Currently, it
        // provides better granularity than GetVersionEx.
        //
        for (i = 0; i < ARRAYSIZE(rgOS); i++)
        {
            if (IsOS(rgOS[i].dwOS))
            {
                pszPlatform = rgOS[i].pszOS;
                break;
            }
        }
        //
        // If IsOS() wasn't able to determine the platform, take the platform from
        // the GetVersionEx results.
        //
        if (szUnknown == pszPlatform)
        {
            for (i = 0; i < ARRAYSIZE(rgPlatforms); i++)
            {
                if (rgPlatforms[i].dwPlatform == osvi.dwPlatformId)
                {
                    if ((DWORD)-1 == rgPlatforms[i].dwMinorVersion ||
                        osvi.dwMinorVersion == rgPlatforms[i].dwMinorVersion)
                    {
                        pszPlatform = rgPlatforms[i].pszPlatform;
                        break;
                    }
                }
            }
        }

        wsprintf(pszDest, TEXT("%s version %d.%d %s build %d\n\n"), pszPlatform, 
                                                                    osvi.dwMajorVersion,
                                                                    osvi.dwMinorVersion,
                                                                    osvi.szCSDVersion,
                                                                    osvi.dwBuildNumber);
    }
    return pszDest;
}


void DumpRegStats(void)
{
    TCHAR szScratch[MAX_PATH];
    CConfig &config = CConfig::GetSingleton();

    typedef bool (CConfig::*PBMF)(bool *bSetByPolicy) const;
    typedef int (CConfig::*PIMF)(bool *bSetByPolicy) const;
    typedef LPTSTR (*PDF)(int iValue, LPTSTR pszDest);

    struct 
    {
        LPCTSTR pszTitle;
        DWORD   dwReg;
        HKEY    hkeyRoot;
        LPCTSTR pszSubkey;

    } rgRegKeys[] = {{ TEXT("Policy (LM)"), POL_LM,  HKEY_LOCAL_MACHINE, g_szKeyPolicy   },
                     { TEXT("Policy (CU)"), POL_CU,  HKEY_CURRENT_USER,  g_szKeyPolicy   },
                     { TEXT("Pref (LM)"),   PREF_LM, HKEY_LOCAL_MACHINE, g_szKeyPrefs    },
                     { TEXT("Pref (CU)"),   PREF_CU, HKEY_CURRENT_USER,  g_szKeyPrefs    }};

    struct
    {
        LPCTSTR pszValue;
        DWORD  dwReg;
        PBMF pfnBool;
        PIMF pfnInt;
        PDF  pfnDesc;

    } rgRegValues[] = {
        { g_szValDefCacheSize,                POL_LM,             NULL,                                  (PIMF)&CConfig::DefaultCacheSize, &DefCacheSizeText },
        { g_szValEnabled,                     POL_LM,             &CConfig::CscEnabled,                     NULL, NULL },
        { g_szValNoConfigCache,               POL_BOTH,           &CConfig::NoConfigCache,               NULL, NULL },
        { g_szValNoCacheViewer,               POL_BOTH,           &CConfig::NoCacheViewer,               NULL, NULL },
        { g_szValNoMakeAvailableOffline,      POL_BOTH,           &CConfig::NoMakeAvailableOffline,      NULL, NULL },
        { g_szValGoOfflineAction,             PREF_CU | POL_BOTH, NULL,                                  &CConfig::GoOfflineAction, &GoOfflineActionText },
        { g_szValEventLoggingLevel,           REG_ALL,            NULL,                                  &CConfig::EventLoggingLevel, NULL },
        { g_szValFirstPinWizardShown,         PREF_CU,            (PBMF)&CConfig::FirstPinWizardShown,         NULL, NULL },
        { g_szValNoReminders,                 POL_BOTH | PREF_CU, &CConfig::NoReminders,                 NULL, NULL },
        { g_szValPurgeAtLogoff,               POL_LM,             &CConfig::PurgeAtLogoff,               NULL, NULL },
        { g_szValSyncAtLogoff,                POL_BOTH | PREF_CU, NULL,                                  &CConfig::SyncAtLogoff,  &SyncAtLogoffText },
        { g_szValInitialBalloonTimeout,       POL_BOTH,           NULL,                                  &CConfig::InitialBalloonTimeoutSeconds, NULL },
        { g_szValReminderBalloonTimeout,      POL_BOTH,           NULL,                                  &CConfig::ReminderBalloonTimeoutSeconds, NULL },
        { g_szValReminderFreqMinutes,         POL_BOTH | PREF_CU, NULL,                                  &CConfig::ReminderFreqMinutes, NULL },
        { g_szValAlwaysPinSubFolders,         POL_LM,             &CConfig::AlwaysPinSubFolders,         NULL,  NULL }              
                      };


    _tprintf(TEXT("Registry Information:\n\n"));
    _tprintf(TEXT("%-30s%15s%15s%15s%15s%15s\n"),
             TEXT("Value"),
             rgRegKeys[0].pszTitle,
             rgRegKeys[1].pszTitle,
             rgRegKeys[2].pszTitle,
             rgRegKeys[3].pszTitle,
             TEXT("Result"));

    for (int iVal = 0; iVal < ARRAYSIZE(rgRegValues); iVal++)
    {
        PBMF pfnBool = rgRegValues[iVal].pfnBool;
        PIMF pfnInt  = rgRegValues[iVal].pfnInt;

        _tprintf(TEXT("%-30s"), rgRegValues[iVal].pszValue);

        for (int iKey = 0; iKey < ARRAYSIZE(rgRegKeys); iKey++)
        {
            if (rgRegValues[iVal].dwReg & rgRegKeys[iKey].dwReg)
            {
                _tprintf(TEXT("%15s"), RegValStr(rgRegKeys[iKey].hkeyRoot,
                                                 rgRegKeys[iKey].pszSubkey,
                                                 rgRegValues[iVal].pszValue,
                                                 szScratch));
            }
            else
            {
                _tprintf(TEXT("%15s"), g_szNA);
            }
        }
        int iValue = 0;
        if (NULL != pfnBool)
            iValue = (config.*pfnBool)(NULL);
        else
            iValue = (config.*pfnInt)(NULL);

        _tprintf(TEXT("%15d"), iValue);
        if (NULL != rgRegValues[iVal].pfnDesc)
            _tprintf(TEXT(" %s"), (*rgRegValues[iVal].pfnDesc)(iValue, szScratch));
        _tprintf(TEXT("\n"));
    }
    _tprintf(TEXT("\n"));

    CConfig::OfflineActionIter iter = config.CreateOfflineActionIter();
    CConfig::OfflineActionInfo oai;
    _tprintf(TEXT("Offline action exceptions.  Default is %s:\n\n"), GoOfflineActionText(config.GoOfflineAction(), szScratch));
    _tprintf(TEXT("%-30s%s\n"), TEXT("Server"), TEXT("Action"));

    while(S_OK == iter.Next(&oai))
    {
        _tprintf(TEXT("%-30s%s\n"), oai.szServer, GoOfflineActionText(oai.iAction, szScratch));
    }
}



LPTSTR GetMachineName(
    LPTSTR pszDest,
    UINT cchDest
    )
{
    ULONG cchComputer = cchDest;
    GetComputerName(pszDest, &cchComputer);
    return pszDest;
}

LPTSTR FormatDateTime(
    const SYSTEMTIME& time,
    LPTSTR pszDest,
    UINT cchDest
    )
{
    LPTSTR pszWrite = pszDest;

    GetDateFormat(LOCALE_USER_DEFAULT,
                  DATE_SHORTDATE,
                  &time,
                  NULL,
                  pszWrite,
                  cchDest);

    lstrcat(pszWrite, TEXT(" "));
    int len = lstrlen(pszWrite);
    pszWrite += len;
    cchDest -= len;
    GetTimeFormat(LOCALE_USER_DEFAULT,
                  LOCALE_NOUSEROVERRIDE,
                  &time,
                  NULL,
                  pszWrite,
                  cchDest);

    return pszDest; 
}


LPTSTR GetCurrentDateTime(
    LPTSTR pszDest,
    UINT cchDest
    )
{
    SYSTEMTIME now;
    GetLocalTime(&now);
    return FormatDateTime(now, pszDest, cchDest);
}




LPTSTR
Int64ToCommaSepString(
    LONGLONG n,
    LPTSTR pszOut,
    int cchOut
    )
{
    ULONG ulTemp;
    UNICODE_STRING s;
    NUMBERFMTW nfmtW; 
    LPWSTR pszFmtOutW;
    int cchFmtOut;
    WCHAR szTextW[30];
    WCHAR szSep[5];
    //
    // Convert the 64-bit int to a text string.
    //
    s.Length        = 0;
    s.MaximumLength = ARRAYSIZE(szTextW);
    s.Buffer        = szTextW;
    RtlInt64ToUnicodeString(n, 10, &s);
    //
    // Format the number with commas according to locale conventions.
    //
    nfmtW.NumDigits     = 0;
    nfmtW.LeadingZero   = 0;
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    RtlInitUnicodeString(&s, szSep);
    RtlUnicodeStringToInteger(&s, 10, &ulTemp);
    nfmtW.Grouping      = UINT(ulTemp);
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmtW.lpDecimalSep  = nfmtW.lpThousandSep = szSep;
    nfmtW.NegativeOrder = 0;

#ifndef UNICODE
    //
    // If ansi build we need a wide-char buffer as format destination.
    //
    WCHAR szNumW[30];
    pszFmtOutW = szNumW;
    cchFmtOut  = ARRAYSIZE(szNumW);
#else
    //
    // If unicode build we can format directly to the destination buffer.
    //
    pszFmtOutW = pszOut;
    cchFmtOut  = cchOut;
#endif

    GetNumberFormatW(LOCALE_USER_DEFAULT,
                     0,
                     szTextW,
                     &nfmtW,
                     pszFmtOutW,
                     cchFmtOut);
#ifndef UNICODE
    //
    // If ansi build, need extra step to convert formatted number string
    // (wide char) back to ansi.
    //
    WideCharToMultiByte(CP_ACP,
                        0,
                        pszFmtOutW,
                        -1,
                        pszOut,
                        cchOut,
                        NULL,
                        NULL);
#endif
    return pszOut;
}


void PrintFileStatusFlags(void)
{
    struct
    {
        DWORD dwFlags;
        LPCTSTR pszText;

    } rgMap[] = {{ FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED,   TEXT("Data locally modified")   },
                 { FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED, TEXT("Attrib locally modified") },
                 { FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED,   TEXT("Time locally modified")   },
                 { FLAG_CSC_COPY_STATUS_STALE,                   TEXT("Stale")                   },
                 { FLAG_CSC_COPY_STATUS_LOCALLY_DELETED,         TEXT("Locally deleted")         },
                 { FLAG_CSC_COPY_STATUS_SPARSE,                  TEXT("Sparse")                  },
                 { FLAG_CSC_COPY_STATUS_ORPHAN,                  TEXT("Orphan")                  },
                 { FLAG_CSC_COPY_STATUS_SUSPECT,                 TEXT("Suspect")                 },
                 { FLAG_CSC_COPY_STATUS_LOCALLY_CREATED,         TEXT("Locally created")         },
                 { 0x00010000,                                   TEXT("User has READ access")    },
                 { 0x00020000,                                   TEXT("User has WRITE access")   },
                 { 0x00040000,                                   TEXT("Guest has READ access")   },
                 { 0x00080000,                                   TEXT("Guest has WRITE access")  },
                 { 0x00100000,                                   TEXT("Other has READ access")   },
                 { 0x00200000,                                   TEXT("Other has WRITE access")  },       
                 { FLAG_CSC_COPY_STATUS_IS_FILE,                 TEXT("Entry is a file")         },
                 { FLAG_CSC_COPY_STATUS_FILE_IN_USE,             TEXT("File in use")             },
                };

    _tprintf(TEXT("\nFile status flags ------------------------\n\n"));
    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        _tprintf(TEXT("0x%08X  %s\n"), rgMap[i].dwFlags, rgMap[i].pszText);
    }
    _tprintf(TEXT("\n\n"));
}


void PrintShareStatusFlags(void)
{
    struct
    {
        DWORD dwFlags;
        LPCTSTR pszText;

    } rgMap[] = {{ FLAG_CSC_SHARE_STATUS_MANUAL_REINT,      TEXT("Manual Caching")             }, // 0x00000000
                 { FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE,  TEXT("Modified offline")           }, // 0x00000001
                 { FLAG_CSC_SHARE_STATUS_AUTO_REINT,        TEXT("Auto Caching")               }, // 0x00000040
                 { FLAG_CSC_SHARE_STATUS_VDO,               TEXT("Virtually Disconnected Ops") }, // 0x00000080
                 { FLAG_CSC_SHARE_STATUS_NO_CACHING,        TEXT("No Caching")                 }, // 0x000000C0
                 { FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS, TEXT("Finds in progress")          }, // 0x00000200
                 { FLAG_CSC_SHARE_STATUS_FILES_OPEN,        TEXT("Open files")                 }, // 0x00000400
                 { FLAG_CSC_SHARE_STATUS_CONNECTED,         TEXT("Connected")                  }, // 0x00000800
                 { FLAG_CSC_SHARE_MERGING,                  TEXT("Merging")                    }, // 0x40000000
                 { FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP,   TEXT("Disconnected Op")            }, // 0x80000000
                };

    _tprintf(TEXT("\nShare status flags -------------------\n\n"));
    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        _tprintf(TEXT("%30s0x%08X  %s\n"), TEXT(""), rgMap[i].dwFlags, rgMap[i].pszText);
    }
    _tprintf(TEXT("\n\n"));
}


void PrintHintFlags(void)
{
    struct
    {
        DWORD dwFlags;
        LPCTSTR pszText;

    } rgMap[] = {{ FLAG_CSC_HINT_PIN_USER,                  TEXT("Pin User")           }, // 0x00000001
                 { FLAG_CSC_HINT_PIN_INHERIT_USER,          TEXT("Pin Inherit User")   }, // 0x00000002
                 { FLAG_CSC_HINT_PIN_INHERIT_SYSTEM,        TEXT("Pin Inherit System") }, // 0x00000004
                 { FLAG_CSC_HINT_CONSERVE_BANDWIDTH,        TEXT("Conserve Bandwidth") }, // 0x00000008
                 { FLAG_CSC_HINT_PIN_SYSTEM,                TEXT("Pin System")         }, // 0x00000010
                };

    _tprintf(TEXT("\nFile hint flags -------------------\n\n"));
    for (int i = 0; i < ARRAYSIZE(rgMap); i++)
    {
        _tprintf(TEXT("0x%08X  %s\n"), rgMap[i].dwFlags, rgMap[i].pszText);
    }
    _tprintf(TEXT("\n\n"));
}


void DumpCacheStats(void)
{
    DWORD dwStatus;
    WIN32_FIND_DATA fd;
    TCHAR szScratch[MAX_PATH];
    BOOL bEnabled = CSCIsCSCEnabled();
    CSCSPACEUSAGEINFO sui;

    ZeroMemory(&sui, sizeof(sui));
    GetCscSpaceUsageInfo(&sui);

    _tprintf(TEXT("Cache information:\n\n"));

    _tprintf(TEXT("CSC enabled.........: %s\n"), BoolText(boolify(CSCIsCSCEnabled())));
    _tprintf(TEXT("Volume..............: %s\n"), sui.szVolume);
    _tprintf(TEXT("Bytes on volume.....: %s\n"), Int64ToCommaSepString(sui.llBytesOnVolume, szScratch, ARRAYSIZE(szScratch)));
    _tprintf(TEXT("Bytes in cache......: %s\n"), Int64ToCommaSepString(sui.llBytesTotalInCache, szScratch, ARRAYSIZE(szScratch)));
    _tprintf(TEXT("Bytes used in cache.: %s\n"), Int64ToCommaSepString(sui.llBytesUsedInCache, szScratch, ARRAYSIZE(szScratch)));
    _tprintf(TEXT("Files in cache......: %d\n"), sui.dwNumFilesInCache);
    _tprintf(TEXT("Directories in cache: %d\n\n"), sui.dwNumDirsInCache);

    CCscFindHandle hFind(CacheFindFirst(NULL, &fd, &dwStatus, NULL, NULL, NULL));
    if (hFind.IsValid())
    {
        BOOL bResult = TRUE;
        CSCSHARESTATS ss;
        CSCCACHESTATS cs;
        CSCGETSTATSINFO si = { SSEF_NONE, SSUF_NONE, true, false };

        ZeroMemory(&cs, sizeof(cs));

        _tprintf(TEXT("%-30s%-12s%10s%10s%10s%10s%10s%10s%10s%10s%10s%12s\n"),
                 TEXT("Share"),
                 TEXT("Status"),
                 TEXT("Files"),
                 TEXT("Dirs"),
                 TEXT("Pinned"),
                 TEXT("Modified"),
                 TEXT("Sparse"),
                 TEXT("USER"),
                 TEXT("GUEST"),
                 TEXT("OTHER"),
                 TEXT("Offline?"),
                 TEXT("OpenFiles?"));
        do
        {
            cs.cShares++;
            if (bResult = _GetShareStatistics(fd.cFileName, 
                                              &si,
                                              &ss)) 
            {
                _tprintf(TEXT("%-30s0x%08X  %10d%10d%10d%10d%10d%10d%10d%10d%10s%12s\n"),
                         fd.cFileName,
                         dwStatus,
                         ss.cTotal - ss.cDirs,
                         ss.cDirs,
                         ss.cPinned,
                         ss.cModified,
                         ss.cSparse,
                         ss.cAccessUser,
                         ss.cAccessGuest,
                         ss.cAccessOther,
                         BoolText(ss.bOffline),
                         BoolText(ss.bOpenFiles));

                cs.cTotal               += ss.cTotal;
                cs.cPinned              += ss.cPinned;
                cs.cModified            += ss.cModified;
                cs.cSparse              += ss.cSparse;
                cs.cDirs                += ss.cDirs;
                cs.cAccessUser          += ss.cAccessUser;
                cs.cAccessGuest         += ss.cAccessGuest;
                cs.cAccessOther         += ss.cAccessOther;
                cs.cSharesOffline       += int(ss.bOffline);
                cs.cSharesWithOpenFiles += int(ss.bOpenFiles);
            }
        }
        while(bResult && CacheFindNext(hFind, &fd, &dwStatus, NULL, NULL, NULL));

        _tprintf(TEXT("%-30s%-12s%10d%10d%10d%10d%10d%10d%10d%10d%10d%12d\n\n"),
                 TEXT("SUMMARY"),
                 TEXT(""),
                 cs.cTotal - cs.cDirs,
                 cs.cDirs,
                 cs.cPinned,
                 cs.cModified,
                 cs.cSparse,
                 cs.cAccessUser,
                 cs.cAccessGuest,
                 cs.cAccessOther,
                 cs.cSharesOffline,
                 cs.cSharesWithOpenFiles);
    }
}


void DumpFileInformation(LPCTSTR pszFile)
{
    TCHAR szExpanded[MAX_PATH*2];
    ExpandEnvironmentStrings(pszFile, szExpanded, ARRAYSIZE(szExpanded));

    HANDLE hFile = CreateFile(szExpanded,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    
    if (INVALID_HANDLE_VALUE != hFile)
    {
        BY_HANDLE_FILE_INFORMATION fi;
        if (GetFileInformationByHandle(hFile, &fi))
        {
            TCHAR szScratch[80];
            ULARGE_INTEGER llSize = { fi.nFileSizeLow, fi.nFileSizeHigh };
            FILETIME localfiletime;
            SYSTEMTIME systime;
            FileTimeToLocalFileTime(&fi.ftLastWriteTime, &localfiletime);
            FileTimeToSystemTime(&localfiletime, &systime);

            _tprintf(TEXT("File.......: %s\n"), szExpanded);
            _tprintf(TEXT("Size.......: %s bytes\n"), Int64ToCommaSepString(llSize.QuadPart, szScratch, ARRAYSIZE(szScratch)));
            _tprintf(TEXT("Created....: %s\n\n"), FormatDateTime(systime, szScratch, ARRAYSIZE(szScratch)));
        }        

        CloseHandle(hFile);
    }
    else
    {
        _tprintf(TEXT("ERROR %d opening %s\n\n"), GetLastError(), szExpanded);
    }
}



void PrintOneEnumEntry(LPCTSTR pszPath, DWORD dwStatus, DWORD dwPinCount, DWORD dwHintFlags)
{
    _tprintf(TEXT("0x%08X    %d    0x%08X  %s\n"), dwStatus, dwPinCount, dwHintFlags, pszPath);
}


void EnumTree(LPTSTR pszPath, LPTSTR pszPathToPrint)
{
    WIN32_FIND_DATA fd;
    DWORD dwStatus, dwPinCount, dwHintFlags;

    CCscFindHandle hFind(CacheFindFirst(pszPath, &fd, &dwStatus, &dwPinCount, &dwHintFlags, NULL));
    if (hFind.IsValid())
    {
        do
        {
            if (!PathIsDotOrDotDot(pszPath))
            {
                const bool bIsDir = 0 != (FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes);
                PathCombine(pszPathToPrint, pszPath, fd.cFileName);
                if (bIsDir)
                {
                    lstrcat(pszPathToPrint, TEXT("  [DIR]"));
                }
                PrintOneEnumEntry(pszPathToPrint, dwStatus, dwPinCount, dwHintFlags);
                if (bIsDir)
                {
                    PathAppend(pszPath, fd.cFileName);
                    EnumTree(pszPath, pszPathToPrint);
                }
            }
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, NULL));
    }
    PathRemoveFileSpec(pszPath);
}


void EnumFiles(void)
{
    WIN32_FIND_DATA fd;
    DWORD dwStatus, dwPinCount, dwHintFlags;

    _tprintf(TEXT("Status      PinCnt Hints       Name\n"));
    CCscFindHandle hFind(CacheFindFirst(NULL, &fd, &dwStatus, &dwPinCount, &dwHintFlags, NULL));
    if (hFind.IsValid())
    {
        do
        {
            //
            // We create only one path and print-path buffer that we pass
            // into the recursive EnumTree() function.  This way we don't have
            // a path buffer on each call stack as we recurse.
            //
            TCHAR szPath[MAX_PATH * 2];        // Working path buffer.
            TCHAR szPathToPrint[MAX_PATH * 2]; // For printing only.

            wsprintf(szPathToPrint, TEXT("%s  [SHARE]"), fd.cFileName);
            PrintOneEnumEntry(szPathToPrint, dwStatus, dwPinCount, dwHintFlags);

            lstrcpyn(szPath, fd.cFileName, ARRAYSIZE(szPath));
            EnumTree(szPath, szPathToPrint);
        }
        while(CacheFindNext(hFind, &fd, &dwStatus, &dwPinCount, &dwHintFlags, NULL));
    }
    _tprintf(TEXT("\n\n"));
}



void ShowUsage(void)
{
    _tprintf(TEXT("\aUsage: cscsniff [-f] [-c] [-r] [-e] [-a]\n\n"));
    _tprintf(TEXT("\t-f = Show file information.\n"));
    _tprintf(TEXT("\t-c = Show cache information.\n"));
    _tprintf(TEXT("\t-r = Show registry information.\n"));
    _tprintf(TEXT("\t-e = Enumerate all files.\n"));
    _tprintf(TEXT("\t-a = Show ALL output.\n\n"));
    _tprintf(TEXT("Default is -f -c -r\n"));
}


void __cdecl main(int argc, char **argv)
{

//    if (!IsCurrentUserAnAdminMember())
//    {
//        _tprintf(TEXT("\aYou must be an administrator on this computer to run cscsniff.\n"));
//        return;
//    }

    const char chDash  = '-';
    const char chSlash = '/';

    const DWORD SHOW_CACHEINFO = 0x00000001;
    const DWORD SHOW_REGINFO   = 0x00000002;
    const DWORD SHOW_FILEINFO  = 0x00000004;
    const DWORD SHOW_ENUMFILES = 0x00000008;
    const DWORD SHOW_DEFAULT   = SHOW_CACHEINFO | SHOW_REGINFO | SHOW_FILEINFO;
    const DWORD SHOW_ALL       = SHOW_DEFAULT | SHOW_ENUMFILES;

    DWORD dwShow = 0;

    for (int i = 1; i < argc; i++)
    {
        if (chDash == argv[i][0] || chSlash == argv[i][0])
        {
            switch(argv[i][1])
            {
                case 'C':
                case 'c':
                    dwShow |= SHOW_CACHEINFO;
                    break;

                case 'R':
                case 'r':
                    dwShow |= SHOW_REGINFO;
                    break;

                case 'F':
                case 'f':
                    dwShow |= SHOW_FILEINFO;
                    break;

                case 'E':
                case 'e':
                    dwShow |= SHOW_ENUMFILES;
                    break;

                case 'A':
                case 'a':
                    dwShow |= SHOW_ALL;
                    break;

                default:
                    ShowUsage();
                    return;
            }
        }
    }
                
    if (0 == dwShow)
    {
        dwShow = SHOW_DEFAULT;
    }

                          
    TCHAR szScratch[MAX_PATH];
    TCHAR szComputer[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR szDateTime[80];
    _tprintf(TEXT("Status of CSC for %s (%s)\n\n"), 
             GetMachineName(szComputer, ARRAYSIZE(szComputer)), 
             GetCurrentDateTime(szDateTime, ARRAYSIZE(szDateTime)));

    _tprintf(TEXT("Operating system: %s\n\n"), GetOsVersionInfoText(szScratch));

    if (dwShow & SHOW_FILEINFO)
    {
        _tprintf(TEXT("Binary file information:\n\n"));
        DumpFileInformation(TEXT("%systemroot%\\system32\\CSCDLL.DLL"));
        DumpFileInformation(TEXT("%systemroot%\\system32\\CSCUI.DLL"));
    }

    if (dwShow & SHOW_CACHEINFO)
    {
        DumpCacheStats();        
        PrintShareStatusFlags();
    }
    if (dwShow & SHOW_ENUMFILES)
    {
        EnumFiles();
        PrintFileStatusFlags();
        PrintHintFlags();
    }

    if (dwShow & SHOW_REGINFO)
        DumpRegStats();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\dll.cpp ===
//
// Dll.cpp
//
// Dll API functions for FldrClnr.dll
//
//

#include <windows.h>
#include <shlwapi.h>
#include <shfusion.h>

extern HINSTANCE g_hinst;


//
// Dll functions
//

STDAPI_(BOOL) DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hinst = hDll;
            SHFusionInitializeFromModule(hDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            SHFusionUninitialize();
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}

//
// Create task object here when installing the dll
//
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    //
    // Add the task to the Scheduled tasks folder
    //       
    return S_OK;
}

STDAPI DllRegisterServer(void)
{
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\ids.h ===
#define DLG_DISKCOPYPROGRESS    1086

#define IDI_DISKCOPY            1

#define IDX_DOSBOOTDISK         1

#define IDC_STATIC              -1

// CopyDisk text strings
#define IDS_DISKCOPYMENU        0x10C0
#define IDS_INSERTDEST          0x10C1
#define IDS_INSERTSRC           0x10C2
#define IDS_INSERTSRCDEST       0x10C3
#define IDS_FORMATTINGDEST      0x10C4
#define IDS_COPYSRCDESTINCOMPAT 0x10C5
#define IDS_SRCDISKBAD          0x10C6
#define IDS_DSTDISKBAD          0x10C7
#define IDS_READING             0x10C8
#define IDS_WRITING             0x10c9
#define IDS_SRCDISKDMF          0x10ca
#if defined(DBCS) && !defined(NEC_98)
#define IDS_SRCDISK1024         0x10cb
#endif

#define IDD_STATUS              100
#define IDD_PROBAR              104
#define IDD_FROM                0x3202
#define IDD_TO                  0x3203

#define IDS_ERROR_READ          0x4000
#define IDS_ERROR_WRITE         0x4001
#define IDS_ERROR_FORMAT        0x4002
#define IDS_ERROR_GENERAL       0x4003

#define IDS_COPYCOMPLETED       0x4010
#define IDS_COPYABORTED         0x4011
#define IDS_COPYFAILED          0x4012


#define IDS_CANCEL              0x4020
#define IDS_CLOSE               0x4021

#define IDS_HELPSTRING          0x5001
#define IDS_VERBSTRING          0x5002

// disk image strings

#define IDS_DOSBOOTDISK_FIRST                       0x6000
#define IDS_DOSBOOTDISK_AUTOEXEC_FNAME              (IDS_DOSBOOTDISK_FIRST + 0)
#define IDS_DOSBOOTDISK_CONFIG_FNAME                (IDS_DOSBOOTDISK_FIRST + 1)
#define IDS_DOSBOOTDISK_AUTOEXEC_TEMPLATE           (IDS_DOSBOOTDISK_FIRST + 2)
#define IDS_DOSBOOTDISK_AUTOEXEC_TEMPLATE_WITH_CODE (IDS_DOSBOOTDISK_FIRST + 3)
#define IDS_DOSBOOTDISK_CONFIG_TEMPLATE             (IDS_DOSBOOTDISK_FIRST + 4)

#define IDS_DOSBOOTDISK_CONFIG_EGA_1          (IDS_DOSBOOTDISK_FIRST + 10)
#define IDS_DOSBOOTDISK_CONFIG_EGA_2          (IDS_DOSBOOTDISK_FIRST + 11)
#define IDS_DOSBOOTDISK_CONFIG_EGA_3          (IDS_DOSBOOTDISK_FIRST + 12)
#define IDS_DOSBOOTDISK_CONFIG_EGA_4          (IDS_DOSBOOTDISK_FIRST + 13)
#define IDS_DOSBOOTDISK_CONFIG_EGA_H          (IDS_DOSBOOTDISK_FIRST + 14)

#define IDS_DOSBOOTDISK_AUTOEXEC_EGA_1        (IDS_DOSBOOTDISK_FIRST + 20)
#define IDS_DOSBOOTDISK_AUTOEXEC_EGA_2        (IDS_DOSBOOTDISK_FIRST + 21)
#define IDS_DOSBOOTDISK_AUTOEXEC_EGA_3        (IDS_DOSBOOTDISK_FIRST + 22)
#define IDS_DOSBOOTDISK_AUTOEXEC_EGA_4        (IDS_DOSBOOTDISK_FIRST + 23)
#define IDS_DOSBOOTDISK_AUTOEXEC_EGA_H        (IDS_DOSBOOTDISK_FIRST + 24)

#define IDS_DOSBOOTDISK_KEYBOARD_CODE_US      (IDS_DOSBOOTDISK_FIRST + 100)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_GR      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 1)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_HE      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 2)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_FR      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 3)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SP      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 4)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_IT      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 5)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SV      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 6)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_NL      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 7)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_BR      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 8)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_NO      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 9)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_DK      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 10)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SU      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 11)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_RU      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 12)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_CZ      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 13)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_PL      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 14)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_HU      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 15)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_PO      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 16)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_TR      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 17)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_GK      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 18)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_BL      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 19)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_BG      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 20)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_YU      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 21)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_BE      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 22)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_CF      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 23)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_UK      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 24)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_ET      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 25)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SF      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 26)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SG      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 27)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_IS      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 28)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_IME     (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 29)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_RO      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 30)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_YC      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 31)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_LA      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 32)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_UR      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 33)
#define IDS_DOSBOOTDISK_KEYBOARD_CODE_SL      (IDS_DOSBOOTDISK_KEYBOARD_CODE_US + 34)

#define IDS_DOSBOOTDISK_KEYBOARD_FNAME_1      (IDS_DOSBOOTDISK_FIRST + 200)
#define IDS_DOSBOOTDISK_KEYBOARD_FNAME_2      (IDS_DOSBOOTDISK_KEYBOARD_FNAME_1 + 1)
#define IDS_DOSBOOTDISK_KEYBOARD_FNAME_3      (IDS_DOSBOOTDISK_KEYBOARD_FNAME_1 + 2)
#define IDS_DOSBOOTDISK_KEYBOARD_FNAME_4      (IDS_DOSBOOTDISK_KEYBOARD_FNAME_1 + 3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\diskcopy\shellext.cpp ===
#include "diskcopy.h"
#include <shlwapip.h>
#include "ids.h"
#include <strsafe.h>

#define INITGUID
#include <initguid.h>
// {59099400-57FF-11CE-BD94-0020AF85B590}
DEFINE_GUID(CLSID_DriveMenuExt, 0x59099400L, 0x57FF, 0x11CE, 0xBD, 0x94, 0x00, 0x20, 0xAF, 0x85, 0xB5, 0x90);

void DoRunDllThing(int _iDrive);
BOOL DriveIdIsFloppy(int _iDrive);

HINSTANCE g_hinst = NULL;

LONG g_cRefThisDll = 0;         // Reference count of this DLL.

//----------------------------------------------------------------------------

class CDriveMenuExt : public IContextMenu, IShellExtInit
{
public:
    CDriveMenuExt();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);
    
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);
    
private:
    ~CDriveMenuExt();
    INT _DriveFromDataObject(IDataObject *pdtobj);
    
    
    LONG        _cRef;
    INT         _iDrive;
};

CDriveMenuExt::CDriveMenuExt(): _cRef(1)
{    
}

CDriveMenuExt::~CDriveMenuExt()
{
}

STDMETHODIMP_(ULONG) CDriveMenuExt::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDriveMenuExt::Release()
{
    Assert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CDriveMenuExt::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDriveMenuExt, IContextMenu),
            QITABENT(CDriveMenuExt, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

INT CDriveMenuExt::_DriveFromDataObject(IDataObject *pdtobj)
{
    INT _iDrive = -1;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (pdtobj && SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        if (DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0) == 1)
        {
            TCHAR szFile[MAX_PATH];
            
            DragQueryFile((HDROP)medium.hGlobal, 0, szFile, ARRAYSIZE(szFile));
            
            Assert(lstrlen(szFile) == 3); // we are on the "Drives" class
            
            _iDrive = DRIVEID(szFile);
        }
        
        ReleaseStgMedium(&medium);
    }
    return _iDrive;
}

STDMETHODIMP CDriveMenuExt::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    _iDrive = _DriveFromDataObject(pdtobj);
    if ((_iDrive >= 0) &&
        (_iDrive < 26) &&
        !DriveIdIsFloppy(_iDrive))
    {
        _iDrive = -1; // Copy Disk only works on floppies
    }
    
    return S_OK;
}

STDMETHODIMP CDriveMenuExt::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int cEntries = 0;
    if (_iDrive >= 0 &&
        _iDrive < 26)
    {
        TCHAR szMenu[64];
        LoadString(g_hinst, IDS_DISKCOPYMENU, szMenu, ARRAYSIZE(szMenu));
        
        // this will end up right above "Format Disk..."
        InsertMenu(hmenu, indexMenu++, MF_SEPARATOR | MF_BYPOSITION, idCmdFirst, szMenu);
        InsertMenu(hmenu, indexMenu++, MF_STRING | MF_BYPOSITION, idCmdFirst + 1, szMenu);
        cEntries = 2;
    }
    return ResultFromShort(cEntries);
}

STDMETHODIMP CDriveMenuExt::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;
    if (HIWORD(pici->lpVerb) == 0)
    {
        DoRunDllThing(_iDrive);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

STDMETHODIMP CDriveMenuExt::GetCommandString(UINT_PTR idCmd, UINT uType,
                                             UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    switch(uType)
    {
    case GCS_HELPTEXTA:
        LoadStringA(g_hinst, IDS_HELPSTRING, pszName, cchMax);
        break;
    case GCS_VERBA:
        LoadStringA(g_hinst, IDS_VERBSTRING, pszName, cchMax);
        break;
    case GCS_HELPTEXTW:
        return(LoadStringW(g_hinst, IDS_HELPSTRING, (LPWSTR)pszName, cchMax));
        break;
    case GCS_VERBW:
        LoadStringW(g_hinst, IDS_VERBSTRING, (LPWSTR)pszName, cchMax);
        break;
    case GCS_VALIDATEA:
    case GCS_VALIDATEW:
    default:
        break;
    }
    return S_OK;
}

STDAPI CDriveMenuExt_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;
    
    CDriveMenuExt *pdme = new CDriveMenuExt;
    if (!pdme)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pdme->QueryInterface(riid, ppv);
    pdme->Release();
    return hr;
}

// static class factory (no allocs!)

class ClassFactory : public IClassFactory
{
public:
    ClassFactory() : _cRef(1) {}
    ~ClassFactory() {}
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    
    // IClassFactory
    STDMETHODIMP CreateInstance (IUnknown *punkOuter, REFIID riid, void **ppv);
    STDMETHODIMP LockServer(BOOL fLock);
private:
    LONG        _cRef;
};

STDMETHODIMP_(ULONG) ClassFactory::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) ClassFactory::Release()
{
    Assert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP ClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = static_cast<IClassFactory*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP ClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CDriveMenuExt_CreateInstance(punkOuter, riid, ppv);
}

STDMETHODIMP ClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        InterlockedIncrement(&g_cRefThisDll);
    }
    else
    {
        Assert( 0 != g_cRefThisDll );
        InterlockedDecrement(&g_cRefThisDll);
    }
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
    
    if (IsEqualGUID(rclsid, CLSID_DriveMenuExt))
    {
        ClassFactory* ccf = new ClassFactory;
        if (ccf)
        {
            hr = ccf->QueryInterface(riid, ppv);
            ccf->Release();
        }
    }
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll == 0 ? S_OK : S_FALSE;
}


TCHAR const c_szParamTemplate[] = TEXT("%s,DiskCopyRunDll %d");

void DoRunDllThing(int _iDrive)
{
    if (_iDrive >= 0 && _iDrive < 26)
    {
        TCHAR szModule[MAX_PATH];
        int cchModule = GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule));
        
        if (cchModule > 0 &&
            cchModule < ARRAYSIZE(szModule))
        {
            TCHAR szParam[MAX_PATH + ARRAYSIZE(c_szParamTemplate)];
            if (SUCCEEDED(StringCchPrintf(szParam, ARRAYSIZE(szParam),
                                          c_szParamTemplate, szModule, _iDrive)))
            {
                SHELLEXECUTEINFO shexinfo = {0};
                shexinfo.cbSize = sizeof (shexinfo);
                shexinfo.fMask = SEE_MASK_DOENVSUBST;
                shexinfo.nShow = SW_SHOWNORMAL;
                shexinfo.lpFile = L"%windir%\\system32\\rundll32.exe";
                shexinfo.lpParameters = szParam;

                ShellExecuteEx(&shexinfo);
            }
        }
    }
}

// allow command lines to do diskcopy, use the syntax:
// rundll32.dll diskcopy.dll,DiskCopyRunDll

void WINAPI DiskCopyRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    int iDrive;
    if (StrToIntExA(pszCmdLine, STIF_DEFAULT, &iDrive) &&
        iDrive >= 0 &&
        iDrive < 26)
    {    
        SHCopyDisk(NULL, iDrive, iDrive, 0);
    }
}

void WINAPI DiskCopyRunDllW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pwszCmdLine, int nCmdShow)
{
    int iDrive;
    if (StrToIntExW(pwszCmdLine, STIF_DEFAULT, &iDrive) &&
        iDrive >= 0 &&
        iDrive < 26)
    {    
        SHCopyDisk(NULL, iDrive, iDrive, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\debug.h ===
#ifndef __debug_h__
#define __debug_h__


// For compatibility with WINNT build environment:
#if DBG
#define DEBUG 1
#endif

#ifdef DEBUG

#define DebugTrap  DebugBreak();

#ifdef LOTS_O_DEBUG
#include <objbase.h>
#include <objerror.h>

// Simple debug statements

#define DebugSz(sz) MessageBox (GetFocus(), sz, NULL, MB_OK)

void _DebugHr (HRESULT hr, LPTSTR lpszFile, DWORD dwLine);
#define DebugHr(hr) _DebugHr (hr, __FILE__, __LINE__)

#else //LOTS_O_DEBUG
#define DebugSz(sz)
#define DebugHr(hr)
#endif // LOTS_O_DEBUG


void _Assert (DWORD dw, LPSTR lpszExp, LPSTR lpszFile, DWORD dwLine);
void _AssertSz (DWORD dw, LPSTR lpszExp, LPTSTR lpsz, LPSTR lpszFile, DWORD dwLine);

#define Assert(dw) if (!(dw)) _Assert((dw), (#dw), __FILE__, __LINE__)
#define AssertSz(dw,sz) if (!(dw)) _AssertSz ((dw), (#dw), (sz), __FILE__, __LINE__)

#else // DEBUG

#define Assert(dw)
#define AssertSz(dw,sz)
#define DebugSz(sz)
#define DebugHr(hr)

#endif // DEBUG

#endif // __debug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\docprop.c ===
#include "priv.h"
#pragma hdrstop


const GUID CLSID_CDocProp = {0x3EA48300L, 0x8CF6, 0x101B, 0x84, 0xFB, 0x66, 0x6C, 0xCB, 0x9B, 0xCD, 0x32};
HRESULT CDocProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **);

// Global variables

UINT g_cRefDll = 0;         // Reference count of this DLL.
HANDLE g_hmodThisDll = NULL;    // Handle to this DLL itself.

STDAPI_(BOOL) DllEntry(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hmodThisDll = hDll;
        DisableThreadLibraryCalls(hDll);
        SHFusionInitializeFromModule(hDll);
        break;

        case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }
    return TRUE;
}

typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    HRESULT (*pfnCreate)(IUnknown *, REFIID, void **);
} OBJ_ENTRY;

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
const OBJ_ENTRY c_clsmap[] = {
    { &c_CFVtbl, &CLSID_CDocProp,   CDocProp_CreateInstance},
    // add more entries here
    { NULL, NULL, NULL}
};

// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();    // Class Factory keeps dll in memory
                return NOERROR;
            }
        }
    }
    // failure
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    Assert( 0 != g_cRefDll );
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}


typedef struct
{
    IShellExtInit           _ei;
    IShellPropSheetExt      _pse;
    int                     _cRef;                  // reference count
    IDataObject *           _pdtobj;                // data object
    TCHAR                   _szFile[MAX_PATH];
} CDocProp;


STDMETHODIMP_(UINT) CDocProp_PSE_AddRef(IShellPropSheetExt *pei)
{
    CDocProp *this = IToClass(CDocProp, _pse, pei);
    return ++this->_cRef;
}

STDMETHODIMP_(UINT) CDocProp_PSE_Release(IShellPropSheetExt *pei)
{
    CDocProp *this = IToClass(CDocProp, _pse, pei);

    if (--this->_cRef)
        return this->_cRef;

    if (this->_pdtobj)
        this->_pdtobj->lpVtbl->Release(this->_pdtobj);

    LocalFree((HLOCAL)this);
    DllRelease();
    return 0;
}

STDMETHODIMP CDocProp_PSE_QueryInterface(IShellPropSheetExt *pei, REFIID riid, void **ppvOut)
{
    CDocProp *this = IToClass(CDocProp, _pse, pei);

    if (IsEqualIID(riid, &IID_IShellPropSheetExt) ||
        IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvOut = (void *)pei;
    }
    else if (IsEqualIID(riid, &IID_IShellExtInit))
    {
        *ppvOut = (void *)&this->_ei;
    }
    else
    {
        *ppvOut = NULL;
        return E_NOINTERFACE;
    }

    this->_cRef++;
    return NOERROR;
}

#define NUM_PAGES 1

UINT CALLBACK PSPCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE psp)
{
    switch (uMsg) {
    case PSPCB_RELEASE:
        if (psp && psp->lParam)
        {
            LPALLOBJS lpallobjs = (LPALLOBJS)psp->lParam;
            if (0 == --lpallobjs->uPageRef)
            {
                if (lpallobjs->fOleInit)
                    CoUninitialize();

                // Free our structure so hope we don't get it again!
                FOfficeDestroyObjects(&lpallobjs->lpSIObj, &lpallobjs->lpDSIObj, &lpallobjs->lpUDObj);

                GlobalFree(lpallobjs);
            }
        }
        DllRelease();
        break;
    }
    return 1;
}

STDMETHODIMP CDocProp_PSE_AddPages(IShellPropSheetExt *ppse, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    CDocProp *this = IToClass(CDocProp, _pse, ppse);
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = this->_pdtobj->lpVtbl->GetData(this->_pdtobj, &fmte, &medium);
    if (hres == S_OK && (DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0) == 1))
    {
        WCHAR szPath[MAX_PATH];
        DWORD grfStgMode;
        IStorage *pstg = NULL;

        DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath));

        // Load the properties for this file
        grfStgMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

        if( GetFileAttributes( szPath ) & FILE_ATTRIBUTE_OFFLINE )
        {
            ReleaseStgMedium(&medium);
            return HRESULT_FROM_WIN32(ERROR_FILE_OFFLINE);
        }

        hres = StgOpenStorageEx(szPath, grfStgMode, STGFMT_STORAGE, 0, NULL, NULL, &IID_IStorage, (void**)&pstg);
        if (FAILED(hres))
        {
            // if we failed to open the file, try w/READ ONLY access
            grfStgMode = STGM_SHARE_EXCLUSIVE | STGM_READ;
            hres = StgOpenStorageEx(szPath, grfStgMode, STGFMT_STORAGE, 0, NULL, NULL, &IID_IStorage, (void**)&pstg);
        }


        if (SUCCEEDED(hres))
        {
            int i;

            // Allocate our main structure and make sure it is zero filled!
            LPALLOBJS lpallobjs = (LPALLOBJS)GlobalAlloc(GPTR, sizeof(ALLOBJS));
            if (lpallobjs)
            {
                PROPSHEETPAGE psp[NUM_PAGES];

                Assert( ARRAYSIZE(lpallobjs->szPath) == ARRAYSIZE(szPath) );
                StringCchCopy(lpallobjs->szPath, ARRAYSIZE(lpallobjs->szPath), szPath);

                // Initialize Office property code
                FOfficeCreateAndInitObjects( NULL, NULL, &lpallobjs->lpUDObj);

                lpallobjs->lpfnDwQueryLinkData = NULL;
                lpallobjs->dwMask = 0;

                // Fill in some stuff for the Office code
                lpallobjs->fFiledataInit = FALSE;

                // Initialize OLE
                lpallobjs->fOleInit = SUCCEEDED(CoInitialize(0));

                // Initialize the PropertySheets we're going to add
                FOfficeInitPropInfo(psp, PSP_USECALLBACK, (LPARAM)lpallobjs, PSPCallback);
                FLoadTextStrings();

                DwOfficeLoadProperties(pstg, NULL, NULL, lpallobjs->lpUDObj, 0, grfStgMode);

                // Try to add our new property pages
                for (i = 0; i < NUM_PAGES; i++) 
                {
                    HPROPSHEETPAGE  hpage = CreatePropertySheetPage(&psp[i]);
                    if (hpage) 
                    {
                        DllAddRef();            // matched in PSPCB_RELEASE
                        if (lpfnAddPage(hpage, lParam))
                        {
                            FAttach( lpallobjs, psp + i, hpage );
                            lpallobjs->uPageRef++;
                        }
                        else 
                            DestroyPropertySheetPage(hpage);
                    }
                }

                if (lpallobjs->uPageRef == 0)
                {
                    if (lpallobjs->fOleInit)
                        CoUninitialize();

                    // Free our structures
                    FOfficeDestroyObjects(&lpallobjs->lpSIObj, &lpallobjs->lpDSIObj, &lpallobjs->lpUDObj);
                    GlobalFree(lpallobjs);
                }

            }   // if (lpallobjs)
        }   // StgOpenStorage ... if (SUCCEEDED(hres))

        if (NULL != pstg )
        {
            pstg->lpVtbl->Release(pstg);
            pstg = NULL;
        }
        ReleaseStgMedium(&medium);
    }
    return S_OK;
}

STDMETHODIMP CDocProp_SEI_Initialize(IShellExtInit *pei, LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj, HKEY hkeyProgID)
{
    CDocProp *this = IToClass(CDocProp, _ei, pei);

    // Initialize can be called more than once.
    if (this->_pdtobj)
        this->_pdtobj->lpVtbl->Release(this->_pdtobj);

    // Duplicate the pdtobj pointer
    if (pdtobj) 
    {
        this->_pdtobj = pdtobj;
        pdtobj->lpVtbl->AddRef(pdtobj);
    }

    return NOERROR;
}

STDMETHODIMP_(UINT) CDocProp_SEI_AddRef(IShellExtInit *pei)
{
    CDocProp *this = IToClass(CDocProp, _ei, pei);
    return CDocProp_PSE_AddRef(&this->_pse);
}

STDMETHODIMP_(UINT) CDocProp_SEI_Release(IShellExtInit *pei)
{
    CDocProp *this = IToClass(CDocProp, _ei, pei);
    return CDocProp_PSE_Release(&this->_pse);
}

STDMETHODIMP CDocProp_SEI_QueryInterface(IShellExtInit *pei, REFIID riid, void **ppv)
{
    CDocProp *this = IToClass(CDocProp, _ei, pei);
    return CDocProp_PSE_QueryInterface(&this->_pse, riid, ppv);
}


extern IShellExtInitVtbl           c_CDocProp_SXIVtbl;
extern IShellPropSheetExtVtbl      c_CDocProp_SPXVtbl;

HRESULT CDocProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    CDocProp *pdp;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    pdp = LocalAlloc(LPTR, sizeof(CDocProp));
    if (pdp)
    {
        HRESULT hres;

        DllAddRef();

        pdp->_ei.lpVtbl = &c_CDocProp_SXIVtbl;
        pdp->_pse.lpVtbl = &c_CDocProp_SPXVtbl;
        pdp->_cRef = 1;

        hres = CDocProp_PSE_QueryInterface(&pdp->_pse, riid, ppvOut);
        CDocProp_PSE_Release(&pdp->_pse);

        return hres;        // S_OK or E_NOINTERFACE
    }
    return E_OUTOFMEMORY;
}

IShellPropSheetExtVtbl c_CDocProp_SPXVtbl = {
    CDocProp_PSE_QueryInterface, CDocProp_PSE_AddRef, CDocProp_PSE_Release,
    CDocProp_PSE_AddPages
};

IShellExtInitVtbl c_CDocProp_SXIVtbl = {
    CDocProp_SEI_QueryInterface, CDocProp_SEI_AddRef, CDocProp_SEI_Release,
    CDocProp_SEI_Initialize
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\extdef.h ===
// Forwards...

typedef struct _ALLOBJS ALLOBJS, *LPALLOBJS;

////////////////////////////////////////////////////////////////////////////////
//
// FOfficeInitPropInfo
//
// Purpose:
//  Initializes PropetySheet page structures, etc.
//
// Notes:
//  Use this routine to add the Summary, Statistics, Custom and Contents
//  Property pages to a pre-allocted array of PROPSHEETPAGEs.
//
////////////////////////////////////////////////////////////////////////////////
void FOfficeInitPropInfo (PROPSHEETPAGE * lpPsp, DWORD dwFlags, LPARAM lParam, LPFNPSPCALLBACK pfnCallback);

////////////////////////////////////////////////////////////////////////////////
//
// Attach
//
// Purpose:
//  Assigns HPROPSHEETPAGE to appropriate data block member.
//
////////////////////////////////////////////////////////////////////////////////
BOOL FAttach( LPALLOBJS lpallobjs, PROPSHEETPAGE* ppsp, HPROPSHEETPAGE hPage );

////////////////////////////////////////////////////////////////////////////////
//
// FLoadTextStrings
//
// Purpose:
//  Initializes and load test strings for dll
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FLoadTextStrings (void);

#include "offcapi.h"

////////////////////////////////////////////////////////////////////////////////
//
// Define the structure that is used to hold all instance data for the set of
// property sheet pages.
//
////////////////////////////////////////////////////////////////////////////////

// Max size for temp buffers & edit controls
#define BUFMAX          256 // Includes the NULL terminator.


// All the objects that dialogs need.
typedef struct _ALLOBJS
{
  LPSIOBJ         lpSIObj;
  LPDSIOBJ        lpDSIObj;
  LPUDOBJ         lpUDObj;
  WIN32_FIND_DATA filedata;
  BOOL            fFiledataInit;
  BOOL            fFindFileSuccess;    // Did it succeed
  DWQUERYLD       lpfnDwQueryLinkData;
  DWORD           dwMask;

  int             iMaxPageInit;         // what is the maximum page that was init?

  // Other stuff that needs to be per file...
  BOOL            fPropDlgChanged;          // Did the user make any changes?
  BOOL            fPropDlgPrompted;          // To make sure we don't prompt the user twice to apply changes

  // Global Buffers
  BOOL            fOleInit;
  UINT            uPageRef;
  TCHAR           szPath[MAX_PATH];

  // Variables used in Custom Dialog proc
  HWND            CDP_hWndBoolTrue;
  HWND            CDP_hWndBoolFalse;
  HWND            CDP_hWndGroup;
  HWND            CDP_hWndVal;
  HWND            CDP_hWndName;
  HWND            CDP_hWndLinkVal;
  HWND            CDP_hWndValText;
  HWND            CDP_hWndAdd;
  HWND            CDP_hWndDelete;
  HWND            CDP_hWndType;
  HWND            CDP_hWndCustomLV;
  DWORD           CDP_cLinks;                   // Link data
  TCHAR           CDP_sz[BUFMAX];               // Links the app supports
  int             CDP_iItem;                    // Index of currently selected item

  BOOL            CDP_fLink;                    // Link checkbox state
  BOOL            CDP_fAdd;                     // Add button state
  DWORD           CDP_iszType;                  // Index of currently selected type
  HIMAGELIST      CDP_hImlS;

} ALLOBJS, *LPALLOBJS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\debug.c ===
////////////////////////////////////////////////////////////////////////////////
//
// debug.c
//
////////////////////////////////////////////////////////////////////////////////
#include "priv.h"
#pragma hdrstop

#ifdef DEBUG

#ifndef WINNT
#include <windows.h>
#include "debug.h"
#endif

void
_Assert
  (DWORD dw, LPSTR lpszExp, LPSTR lpszFile, DWORD dwLine)
{
  DWORD dwT;
  TCHAR lpszT[256];
  StringCchPrintf(lpszT, ARRAYSIZE(lpszT), TEXT("Assertion %hs Failed.\n\n%hs, line# %ld\n\nYes to continue, No to debug, Cancel to exit"), lpszExp, lpszFile, dwLine);
  dwT = MessageBox (GetFocus(), lpszT, TEXT("Assertion Failed!"), MB_YESNOCANCEL);
  switch (dwT)
  {
    case IDCANCEL :
      //exit (1);
        FatalExit(1);
    case IDNO :
      DebugTrap;
  }
}

void
_AssertSz
  (DWORD dw, LPSTR lpszExp, LPTSTR lpsz, LPSTR lpszFile, DWORD dwLine)
{
  DWORD dwT;
  TCHAR lpszT[512];
  StringCchPrintf(lpszT, ARRAYSIZE(lpszT), TEXT("Assertion %hs Failed.\n\n%s\n%hs, line# %ld\n\nYes to continue, No to debug, Cancel to exit"), lpszExp, lpsz, lpszFile, dwLine);
  dwT = MessageBox (GetFocus(), lpszT, TEXT("Assertion Failed!"), MB_YESNOCANCEL);
  switch (dwT)
  {
    case IDCANCEL:
      //exit (1);
                FatalExit(1);
    case IDNO :
      DebugTrap;
  }
}

#ifdef LOTS_O_DEBUG
#include <windows.h>
#include <winerror.h>
#include <oleauto.h>
#include "debug.h"

void
_DebugHr
  (HRESULT hr, LPTSTR lpszFile, DWORD dwLine)
{
  TCHAR szHRESULT[512];

  switch (hr) {
    case S_OK :
      return;
    case STG_E_INVALIDNAME:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tBogus filename\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_INVALIDFUNCTION :
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tInvalid Function\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_FILENOTFOUND:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tFile not found\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_INVALIDFLAG:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tBogus flag\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_INVALIDPOINTER:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tBogus pointer\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_ACCESSDENIED:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tAccess Denied\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case STG_E_INSUFFICIENTMEMORY :
    case E_OUTOFMEMORY            :
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tInsufficient Memory\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case E_INVALIDARG :
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tInvalid argument\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case TYPE_E_UNKNOWNLCID:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tUnknown LCID\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case TYPE_E_CANTLOADLIBRARY:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tCan't load typelib or dll\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case TYPE_E_INVDATAREAD:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tCan't read file\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case TYPE_E_INVALIDSTATE:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tTypelib couldn't be opened\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    case TYPE_E_IOERROR:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tI/O error\n\n%s, line# %ld\n"),lpszFile, dwLine);
      break;
    default:
      StringCchPrintf(szHRESULT, ARRAYSIZE(szHRESULT), TEXT("\tUnknown HRESULT %lx (%ld) \n\n%s, line# %ld\n"),hr, hr, lpszFile, dwLine);
  }

  MessageBox (GetFocus(), szHRESULT, NULL, MB_OK);
  return;
}

#endif // LOTS_O_DEBUG

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\msohelp.h ===
//
// NOTE: If you change this file, you must notify UE.
//       Currently, you should notify JohnCal.
//       MartinTh. 041995.
//


// Auto Correct
#define IDH_dlgACorrInitCaps    108
#define IDH_dlgACorrCapDays     109
#define IDH_dlgACorrReplaceText 110
#define IDH_dlgACorrReplace     111
#define IDH_dlgACorrAdd         112
#define IDH_dlgACorrDelete      113
#define IDH_dlgACorrReplacementList 114
#define IDH_dlgACorrWith        115

// OLE Properties
#define IDH_GENERAL_ICON            200
#define IDH_GENERAL_NAME_BY_ICON    201
#define IDH_GENERAL_FILETYPE        202
#define IDH_GENERAL_LOCATION        203
#define IDH_GENERAL_FILESIZE        204
#define IDH_GENERAL_MSDOSNAME       205
#define IDH_GENERAL_CREATED         206
#define IDH_GENERAL_MODIFIED        207
#define IDH_GENERAL_ACCESSED        208
#define IDH_GENERAL_READONLY        209
#define IDH_GENERAL_HIDDEN          210
#define IDH_GENERAL_ARCHIVE         211
#define IDH_GENERAL_SYSTEM          212
#define IDH_GENERAL_ATTRIBUTES      213

#define IDH_SUMMARY_TITLE           28220
#define IDH_SUMMARY_SUBJECT         28221
#define IDH_SUMMARY_AUTHOR          28222
#define IDH_SUMMARY_MANAGER         28223
#define IDH_SUMMARY_COMPANY         28224
#define IDH_SUMMARY_CATEGORY        28225
#define IDH_SUMMARY_KEYWORDS        28226
#define IDH_SUMMARY_COMMENTS        28227
#define IDH_SUMMARY_TEMPLATE        28228
#define IDH_SUMMARY_SAVEPREVIEW     28229

#define IDH_STATISTICS_CREATED      28230
#define IDH_STATISTICS_MODIFIED     28231
#define IDH_STATISTICS_ACCESSED     28232
#define IDH_STATISTICS_LASTPRINT    28233
#define IDH_STATISTICS_LASTSAVEBY   28234
#define IDH_STATISTICS_REVISION     28235
#define IDH_STATISTICS_TOTALEDIT    28236
#define IDH_STATISTICS_LISTVIEW     28237

#define IDH_CONTENTS_LISTBOX        28240

#define IDH_CUSTOM_NAME             28251
#define IDH_CUSTOM_TYPE             28252
#define IDH_CUSTOM_VALUE            28253   // Edit field, when Link checkbox is clear
#define IDH_CUSTOM_LINKVALUE        28254   // Combo box, when Link checkbox is checked
#define IDH_CUSTOM_BOOLYES          28255
#define IDH_CUSTOM_ADDBUTTON        28257
#define IDH_CUSTOM_DELETEBUTTON     28258   // This button is both Delete and Modify
#define IDH_CUSTOM_LINKCHECK        28259
#define IDH_CUSTOM_LISTVIEW         28260

// Post Dialog
#define IDH_POSTDLG_FOLDERTREEVIEW  300
#define IDH_POSTDLG_OKBUTTON        301
#define IDH_POSTDLG_CANCELBUTTON    302

//AnswerWizard dialog
#define IDH_AW_SEARCH                                   5013479
#define IDH_AW_TYPEEDITBOX                              5013480
#define IDH_AW_TOPICLISTBOX                     5013481
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\internal.h ===
////////////////////////////////////////////////////////////////////////////////
//
// Internal.h
//
// MS Office Internal Interfaces.  These interfaces are not supported
// for client code.
//
// Change history:
//
// Date         Who             What
// --------------------------------------------------------------------------
// 07/13/94     B. Wentz        Created file
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __Internal_h__
#define __Internal_h__

#include "offcapi.h"
#include "proptype.h"

  // Flag to | into Id's passed to Summary and Document Summary objects
  // to get a real pointer to data, not a copy.
#define PTRWIZARD       0x1000

  // Flag to | into flags passed to User-defined property streams to get
  // a real pointer to the data, not a copy.
#define UD_PTRWIZARD    0x0002

#ifdef __cplusplus
extern TEXT("C") {
#endif

    // Create a UDPROP structure.
  LPUDPROP LpudpropCreate ( void );

    // Free a UDPROP structure.
  VOID VUdpropFree (LPUDPROP *lplpudp);

    // Create a temporary copy of the User-Defined property data
  BOOL FMakeTmpUDProps (LPUDOBJ lpUDObj);

    // Swap the "temp" copy with the real copy of User-Defined property data
  BOOL FSwapTmpUDProps (LPUDOBJ lpUDObj);

    // Delete the "temp" copy of the data
  BOOL FDeleteTmpUDProps (LPUDOBJ lpUDObj);

    // Look up a node in the UD props
  LPUDPROP PASCAL LpudpropFindMatchingName (LPUDOBJ lpUDObj, LPTSTR lpsz);

  BOOL FUserDefCreate (LPUDOBJ FAR *lplpUDObj, const void *prglpfn[]);

    // Clear the data stored in object, but do not destroy the object.
  BOOL FUserDefClear (LPUDOBJ lpUDObj);

    // Destroy object,
  BOOL FUserDefDestroy (LPUDOBJ FAR *lplp);
  

     // Misc internal calls & defines

  void PASCAL FreeUDData (LPUDOBJ lpUDObj, BOOL fTmp);
  BOOL PASCAL FAddPropToList (LPUDOBJ lpUDObj, LPPROPVARIANT lppropvar, STATPROPSTG *lpstatpropstg, LPUDPROP lpudprop);
  void PASCAL AddNodeToList (LPUDOBJ lpUDObj, LPUDPROP lpudprop);

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __Internal_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\offcapi.h ===
#ifndef __offcapi_h__
#define __offcapi_h__
#pragma pack( push, 4 )

//////////////////////////////////////////////////////////////////////////////
//  FILE   : OFFCAPI.H
//  PURPOSE: Client apps of office.dll include this file for structs and exports.
//  HOW TO USE:
//      Either you can link the office.lib (import lib) with your app
//      or you can LoadLibrary and GetProcAddress the reqd office routine.
// INIT   :
//      Before using any of the office.dll supplied features, you must init it
//      using Office(ioffcInit,&officeinfo). See below for more details.
//
// FEATURE LIST:
//  IntelliSearch
//  Shared FileNew
//  Extended doc properties
//  Office Visual (cool title bar)
//  Threaded status indicator
//  AutoCorrect
//
//////////////////////////////////////////////////////////////////////////////

#ifndef INC_OLE2
#define INC_OLE2
#include <windows.h>
#include <objbase.h>
#include <oleauto.h>
#endif // INC_OLE2

#define DLLIMPORT
#define DLLEXPORT


#ifdef DLLBUILD
#define DLLFUNC DLLEXPORT
#define OFC_CALLTYPE _stdcall
#else // !DLLBUILD
#define DLLFUNC DLLIMPORT
#ifndef OFC_CALLTYPE
#define OFC_CALLTYPE __stdcall
#endif // OFC_CALLTYPE
#endif // DLLBUILD
#define OFC_CALLBACK __stdcall



#define ioffcInit       0
#define ioffcISearch     1
#define ioffcGetVer             2
//Next two are debug only ioffcs
#define ioffcISearchDebug 3
#define ioffcISearchInputFileTest       4
#define ioffcUninit     5
#define ioffcISearchInWinHelp           6
#define ioffcCanDoMSNConnect            7
#define ioffcDoMSNConnect                       8
#define ioffcAWVBAHelp                  9

//iseachinfo is used to call IntelliSearch using Office()
//hwnd is the parent window for the IS dlg
//IS callback is for selection checking.First parameter is the topicID. If
//the app can do the ghosting/demo then it returns True. If not in the right
//selection for the demo then return the error text at second buffer for display
//by IS. The third argument is the size of this error buffer.
//cisdb is count of the isdb tables you want the IS to be done on (normally 1)
//pstz[] is the array of ptrs to the path and name of the isdb tables.
typedef struct _isearchinfo
        {
        HWND hwnd;
        union
                {
                BOOL ((OFC_CALLBACK *pfnISCallback)(int, TCHAR *, int));
                struct
                        {
                        unsigned fMOM:1;
                        unsigned fDetachNote:1;
                        unsigned fAWTabOnTop:1;
                        unsigned unused:29;
                        } async;
                } callData;
        UINT cisdb;//count of the IS dbs
        TCHAR *pstz[1];
        }ISEARCHINFO;

//use MSOAWVBAHELPINFO when calling Office(ioffcAWVBAHelp,)
//This will display the vba help as usual. In case user asks for
//AnswerWizard it would have setup winhelp to do that
typedef struct _msoawvbahelpinfo
        {
        TCHAR *pszVBAHelpfilename; //name of the vba help file
        UINT idVBAHelp; //id of the help to be displayed
        ISEARCHINFO isearchinfo;
        }MSOAWVBAHELPINFO;
//the following two are sent as wParam when fDetachNote is set to true
#define wISDetaching    0xfffffffe      //when the dll is detached
#define wISInited               0xffffffff      //when the init was successful

//_ver is used to get the office.dll version no. using Office()
typedef struct _ver
        {
        long rmjV;
        long rmmV;
        long rupV;
        }VER;

typedef struct _isdebinfo
        {
        HWND hwnd;
        }ISDEBINFO;

//msomsninfo is used to communicate MSN connection related info.
//Use it when calling ioffcDoMSNConnection.
//Right now it just needs the hwnd of the apps main window.
typedef struct _msomsninfo
        {
        HWND hwnd;
        }MSOMSNINFO;

#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
LRESULT OFC_CALLTYPE Office(UINT ioffc, void *lpv);
//It returns the message number that you will get for ISearch ghosting.
UINT OFC_CALLTYPE MsoGetWmGhost();
#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

/***********************************************************************
Office() is called with ioffc.

1) ioffc=ioffcInit :: Performs the office.dll initialisation.
-----------------
set lpv=&officeinfo.
set all the fields of officeinfo.
 hinst -> hInstance of your app
 PAlloc and FreeP -> provide these tow functions for mem alloc and free
 if you set PAlloc=NULL then office will use its own alloc and free
 pstzOfficeIntlDll is currently ignored
returns TRUE on success else FALSE

2) ioffc=ioffcUninit :: Performs the office.dll UNInitialisation/cleanup before
                                quitting.Call this before closing your app.
-----------------
set lpv=NULL.
call Office(ioffcUninit,NULL).

3) ioffc=ioffcISearch :: Performs IntelliSearch (FOR TESTING USE ONLY)
--------------------
set lpv=&isearchinfo.
returns -1 for no action and topicID if app needs to act.
NOTE: THIS API IS FOR INTERNAL debug USE ONLY. ALL THE APPS SHOULD
CALL ioffcISearchInWinHelp described below for intellisearch.

4) ioffc=ioffcGetVer :: Use this to get the version number of the dll
----------------
set lpv=&ver
returns with all the fields of ver set.

5) ioffcISearchDebug and ioffcISearchInputFileTest are for DEBUG/Test only.
--------------------
6) ioffcISearchInWinHelp - Performs IntelliSearch as a tab in WinHelp browser.
-----------------------
Call Office(ioffcISearchInWinHelp, pisearchinfo). All the fields of the
isearchinfo struct should be set as follows:
        hwnd -> callers main window
        fMOM -> set by MOM (Microsoft Office Manager) fFalse for others
        fDetachNote -> set this to fTrue if you need to get the wmGhost message
                with wParam (0xfffffff) when WinHelp frees the office.dll.
                Currently used by MOM only      so you should set it to fFalse;
        cisdb ->count of the databases
        pstz[] -> array of ptrs to database names.

Office will return TRUE or FALSE based on whether it could launch WinHelp
or not.
Ghosting: In WinHelp ISearch works in a separate app(WinHelp).Its like a
modeless dialog. User can choose a ghosting topic anytime. Office will post
a wmGhost message to the hwnd that was provided in isearchinfo. To get the
wmGhost value apps should call MsoGetWmGhost() anytime after calling
Office(ioffcInit). An app can have a global wmGhost and set it either after
ioffcInit or before/after calling IntelliSearch for the first time. Look for the
wmGhost message in the WndProc. The wParam will have the topic that needs
to be ghosted. If the app is not in a state to do the given ghosting, just
give the error. There is no communication back to office.dll

7) ioffcCanDoMSNConnect
-----------------------
Call this to find out if you mso95 can do MSN connection or not. If
Set lpv=NULL. This will return TRUE if we can do the MSN connection, false
otherwise. Grey the menu if false.

8) ioffcDoMSNConnect
--------------------
Call this to do the MSN connection by mso95.
Set msomsninfo.hwnd=Handle of your main window.
Set lpv=&msomsninfo. This will bring up the choose topic dialog and connect
the user to MSN if s/he selects connect.

***********************************************************************/

#ifdef DEBUG
/**********************************************************************
EnumOfficeAllocs is provided for clients to get a list of all
the memory allocated by office.dll at idle.
Provide a ptr to a function which will be called repeatedly for
each memory block that office has allocated.
**********************************************************************/
#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
VOID OFC_CALLTYPE EnumOfficeAllocs(void (OFC_CALLBACK *)(void *, int));
#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus
#endif //DEBUG


//*******************************************************************
/* File New Dialog APIs */
//*******************************************************************
#define NFN_SHOWNEWGROUP   0x0001       /* Show the Template/Document group box. */
#define NFN_DOCUMENT       0x0002       /* Document was chosen. */
#define NFN_TEMPLATE       0x0004       /* Template was chosen. */
#define NFN_SHOWMETAFILE   0x0008       /* The lpstrNoPreview is a path to a MF */
#define NFN_NOUITEST                    0x0010  /* Do not show UI, just count templates. */
#define NFN_RETURNONONE         0x0020  /* Count number of templates. */
#define NFN_REMEMBERTAB         0x0040  /* Remember the tab category. */
#define NFN_VIEW_ICON           0x0080  /* Start or ended in icon view. */
#define NFN_VIEW_LIST           0x0100  /* Start or ended in list view. */
#define NFN_VIEW_REPORT         0x0200  /* Start or ended in report view. */
#define NFN_SORT_NAME      0x0400       /* Sort by name. */
#define NFN_SORT_TYPE           0x0800  /* Sort by type. */
#define NFN_SORT_SIZE           0x1000  /* Sort by size. */
#define NFN_SORT_MOD                    0x2000  /* Sort by date. */
#define NFN_SORT_DESCENDING 0x4000      /* Sort in descending order. */
#define NFN_PLAINPREVIEW        0x8000  /* No anti-aliased preview. */


#define NFT_SHOWMETAFILE        0x0001  /* Same as NFN_* for nft:s. */

/* RETURN CODES */
#define NFNRC_FAILURE   -2              // Something went wrong... out of memory?
#define NFNRC_CANCEL            -1              // User canceled the dialog.
#define NFNRC_OK                        0               // User selected template file.
// >0 : NFT return codes.

typedef struct tagNFT
        {
        LPCTSTR          lpszName;
        LPCTSTR          lpszType;
        DWORD                   dwReturnCode;
        DWORD                   dwPosition;
        LPCTSTR          lpszApplication;
        LPCTSTR          lpszCommand;
        LPCTSTR          lpszTopic;
        LPCTSTR          lpszDDEExec;
        LPCTSTR          lpszPreview;
        DWORD                   dwFlags;                        /* NFT_SHOWMETAFILE: Text or MF */
        } NFT;

#if 0
// This structure is not Win64-compliant (bad alignment)
// Fortunately, we don't use it.
typedef struct tagNFN
   {
        DWORD                   lStructSize;                    // Size of the structure.
        HWND                    hwndOwner;           // Parent window of the dialog.
        HINSTANCE       hInstance;           // Modula handle of the calling process.
        LPCTSTR          lpstrFilter;         // File filter, e.g. "*.dot\0*.wiz\0\0"
        LPTSTR                   lpstrFile;           // File name buffer. Provided by caller.
        DWORD                   nMaxFile;            // Size of lpstrFile.
        LPTSTR                   lpstrFileTitle;      // File name without the path.
        DWORD                   nMaxFileTitle;       // Size of lpstrFileTitle.
        LPCTSTR          lpstrTitle;          // Dialog title.
        LPTSTR                   lpstrCategory;       // Default category.
        DWORD                   nMaxCategory;                   // Max size of category buffer.
        DWORD                   Flags;               // Flags. See NFN_* above.
        WORD                    nFileOffset;         // Index into lpstrFile for file name.
        WORD                    nFileExtension;      // Index into lpstrFile for extension.
        LPTSTR                   lpstrRegNFT;                    // Registry key of default items.
        NFT                     *lpNFT;                                 // Explicit enties for non-file templates.
        WORD                    cNFT;                                           // Count of non-file templates.
        LPCTSTR          lpstrNoPreview;         // Msg to use if no thumbnail in template.
        POINT                   ptCenter;                               // Position to display dialog.
        }NEWFILENAME;
#else
typedef struct tagNFN NEWFILENAME;              // opaque definition
#endif

#define EnumTemplates(pszPath, pfnCallback, pData)      EnumFileSystem(TRUE, \
                                                        pszPath, (DWORD)(~FILE_ATTRIBUTE_DIRECTORY), \
                                                        TRUE, pfnCallback, pData)
#define EnumTemplatesEx(pszPath, pfnCallback, pData)    EnumFileSystemEx(TRUE, \
        pszPath, (DWORD)(~FILE_ATTRIBUTE_DIRECTORY), \
        TRUE, pfnCallback, pData)


#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
TCHAR * OFC_CALLTYPE SharedTemplatesPath(TCHAR sz[], long cchMax);
TCHAR * OFC_CALLTYPE LocalTemplatesPath(TCHAR sz[], long cchMax);
LONG OFC_CALLTYPE SetLocalTemplatesPath(LPCTSTR pszPath);
LONG OFC_CALLTYPE SetSharedTemplatesPath(LPCTSTR pszPath);
BOOL OFC_CALLTYPE FIsPlaceHolder(LPCTSTR lpszFileName);
long OFC_CALLTYPE GetNewFileName(NEWFILENAME *pNfn, NFT *pNFT);
TCHAR * OFC_CALLTYPE GetTemplatesPath(TCHAR szPath[], long cchMax, int iId);

/* Window procedure used for sub-classinf the new dialog */
long FAR PASCAL CoreNewWndProc(HWND hwnd,
                                         UINT wMsgId,
                                         WPARAM wParam,
                                         LPARAM lParam);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus


///////////////////////////////////////////////////////////////////////////////
// THUMBNAIL FUNCTIONS
// Overview:
///////////////////////////////////////////////////////////////////////////////
typedef struct tagTHUMBNAIL THUMBNAIL;
typedef struct tagPREVIEWPARAM {
        HDC hdc;
        THUMBNAIL *pNail;
        DWORD dwExtX;
        DWORD dwExtY;
        RECT rcCrop;
        POINT ptOffset;
        BOOL fImprove;
        BOOL fUsePalette;
    BOOL fDie;
        BOOL fFitWithin;
        void (PASCAL *lpprocCleanUp)(struct tagPREVIEWPARAM *);
        LPVOID pData;
} PREVIEWPARAM;


#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
THUMBNAIL * OFC_CALLTYPE LoadThumbnail(LPSTORAGE pIStorage);
THUMBNAIL * OFC_CALLTYPE MakeThumbnail(WORD wType, LPVOID pPicture);
LPSTORAGE OFC_CALLTYPE OpenDocFileA(LPCTSTR lpszDocFile);
void      OFC_CALLTYPE DestroyThumbnail(THUMBNAIL *lpTN);
DWORD     WINAPI PreviewThumbnail(LPVOID lParam);
HBRUSH          OFC_CALLTYPE HbrCreateHalftoneBrush(HDC hdc, COLORREF Color);
HPALETTE  OFC_CALLTYPE HPalCreateHalftone(HDC hdc,
                                                                                                                                  const PALETTEENTRY *pShared,
                                                                                                                                  const DWORD nEntries,
                                                                                                                                  const BYTE dH,
                                                                                                                                  const BYTE dS,
                                                                                                                                  const BYTE dV);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus




////////////////////////////////////////////////////////////////////////////////
// EXTENDED OLE DOC PROPERTIES APIs follow
// Overview:
//              To use extended ole properties do the following
//              1.Open your file
//              2.Call FOfficeCreateAndInitObjects: This will create 3 objects which are
//                      siobj (sum info obj
//                      dsiobj (doc sum info obj)
//                      udobj (user defined data or custom obj)
//               and provides a pointer to each of these.
//               To make any subsequent calls, you will have to provide the pointer to the
//               appropriate object.
//              3.Before you close a file call FOfficeDestroyObjects.
////////////////////////////////////////////////////////////////////////////////
//
// Summary Information interface API.
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in SUMINFO.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPSIOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "SumInfo" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   SIVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPSIOBJ    - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

#include <objbase.h>
#include <oleauto.h>
  // Apps should use these for "Create" calls to fill out rglpfn
#define ifnCPConvert    0               // Index of Code Page Converter
#define ifnFSzToNum     1               // Index of Sz To Num routine
#define ifnFNumToSz     2               // Index of Num To Sz routine
#define ifnFUpdateStats 3               // Index of routine to update statistics
#define ifnMax          4               // Max index

  // Predefined Security level values for Property Sets in the standard
#define SECURITY_NONE                   0x0     /* No security */
#define SECURITY_PASSWORD               0x1     /* Password-protected */
#define SECURITY_READONLYRECOMMEND      0x2     /* Read-only access recommened */
#define SECURITY_READONLYENFORCED       0x4     /* Read-only access enforced */
#define SECURITY_LOCKED                 0x8     /* Locked for annotations */


  // Define a platform-independent VT_LPxSTR value.

typedef enum _VARENUM_EX
{
    VT_LPTSTR  = VT_LPWSTR
} VARENUM_EX;

  // The types supported by the User-Defined properties

typedef enum _UDTYPES
{
  wUDlpsz    = VT_LPTSTR,
  wUDdate    = VT_FILETIME,
  wUDdw      = VT_I4,
  wUDfloat   = VT_R8,
  wUDbool    = VT_BOOL,
  wUDinvalid = VT_VARIANT        // VT_VARIANT is invalid because it
                                 // must always be combined with VT_VECTOR
} UDTYPES;

#ifdef OLE_PROPS
#include "SInfoI.h"

  // Use the real Vtbl for OLE objects
#define SIVTBLSTRUCT struct ISumInfo

  // For OLE objects, first param is pointer to interface class
#define LPSIOBJ ISumInfo FAR *

#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus

    // Must support IUnknown methods for OLE objects....
  HRESULT OFC_CALLTYPE HrSumInfoQueryInterface (IUnknown FAR *,
                                             REFIID riid,
                                             LPVOID FAR* ppvObj);
  ULONG OFC_CALLTYPE UlSumInfoAddRef (IUnknown FAR *);
  ULONG OFC_CALLTYPE UlSumInfoRelease (IUnkown FAR *);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#else  // !OLE_PROPS

  // Create a placeholder Vtbl for non-OLE objects.
#define SIVTBLSTRUCT struct _SIVTBLSTRUCT { void FAR *lpVtbl; } SIVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPSIOBJ LPOFFICESUMINFO

// For more information on the thumbnail look in OLE 2 Programmer's Reference, Volume 1, pp 874-875.

typedef struct tagSINAIL
{
   DWORD cbData;     // size of *pdata
   DWORD cftag;      // either 0,-1,-2,-3, or positive. This decides the size of pFMTID.
   BYTE *pbFMTID;    // bytes representing the FMTID
   BYTE *pbData;     // bytes representing the data
} SINAIL;

typedef SINAIL FAR * LPSINAIL;

// Note about tagSINAIL:
//
// if cftag is
//             0 - pFMTID is NULL i.e. no format name
//            -1 - Windows built-in Clipboard format. pFMTID points to a DWORD (e.g. CF_DIB)
//            -2 - Macintosh Format Value.            pFMTID points to a DWORD
//            -3 - FMTID.                             pFMTID points to 16 bytes
//            >0 - Length of string.                  pFMTID points to cftag bytes
//

#endif // OLE_PROPS

  // Summary info data.  Callers should *never* access this data directly,
  // always use the supplied API's.
typedef struct _OFFICESUMINFO {

  SIVTBLSTRUCT;                             // Vtbl goes here for OLE objs,
                                            // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  ULONG               m_ulRefCount;         // Reference count
  LPVOID              m_lpData;             // Pointer to the real data
  HPROPSHEETPAGE      m_hPage;              // Handle of property page.
  
} OFFICESUMINFO, FAR * LPOFFICESUMINFO;

#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus

//
// Indices to pass to API routines to get the specifc data.
//
  // Strings
#define SI_TITLE        0
#define SI_SUBJECT      1
#define SI_AUTHOR       2
#define SI_KEYWORDS     3
#define SI_COMMENTS     4
#define SI_TEMPLATE     5
#define SI_LASTAUTH     6
#define SI_REVISION     7
#define SI_APPNAME      8
#define SI_STRINGLAST   8

  // Times
#define SI_TOTALEDIT    0
#define SI_LASTPRINT    1
#define SI_CREATION     2
#define SI_LASTSAVE     3
#define SI_TIMELAST     3

  // Integer stats
#define SI_PAGES        0
#define SI_WORDS        1
#define SI_CHARS        2
#define SI_SECURITY     3
#define SI_INTLAST      3




//
// Standard I/O routines
//
    // Indicates if the summary info data has changed.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //
    // Return value:
    //
    //   TRUE -- the data has changed, and should be saved.
    //   FALSE -- the data has not changed.
    //
  BOOL OFC_CALLTYPE FSumInfoShouldSave (LPSIOBJ lpSIObj);

//
// Data manipulation
//
    // Get the size of a given string property.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object.
    //   iw - specifies which string to get the size of and should be
    //        one of the following values:
    //      SI_TITLE
    //      SI_SUBJECT
    //      SI_AUTHOR
    //      SI_KEYWORDS
    //      SI_COMMENTS
    //      SI_TEMPLATE
    //      SI_LASTAUTH
    //      SI_REVISION
    //      SI_APPNAME
    //
    //   pdw - pointer to a dword, will contain cb on return
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error.
  BOOL OFC_CALLTYPE FCbSumInfoString (LPSIOBJ lpSIObj, WORD iw, DWORD *pdw);
    // Get a given time property.
    //
    // Parameters:
    //
    //   lpSIObj - pointer to a Summary Info object
    //   iw - specifies which time to get and should be
    //        one of the following values:
    //      SI_TOTALEDIT
    //      SI_LASTPRINT
    //      SI_CREATION
    //      SI_LASTSAVE
    //
    //   lpTime - buffer to hold filetime
    //
    // Return value:
    //
    //   The function returns TRUE on succes.
    //   The function returns FALSE on error (bogus argument, or the time
    //   requested doesn't exist - i.e. has not been set, or loaded).
    //
    //  NOTE:    The filetime will be based Coordinated Universal Time (UTC).
    //           This ensures that the time is displayed correctly all over the
    //           world.
    //
    // NOTE: FOR SI_TOTALEDIT lpTime WILL ACTUALLY BE THE TIME
    //       THE FILE HAS BEEN EDITED, NOT A DATE.  THE TIME
    //       WILL BE EXPRESSED IN UNITS OF 100ns.  I KNOW THIS IS
    //       A WEIRD UNIT TO USE, BUT WE HAVE TO DO THAT FOR BACK-
    //       WARDS COMPATABILITY REASONS WITH 16-BIT WORD 6.
    //
    //       OFFICE provides a utility routine to convert a number of
    //       units of 100ns into minutes. Call Convert100nsToMin.
    //
  BOOL OFC_CALLTYPE FSumInfoGetTime (LPSIOBJ lpSIObj,
                                           WORD iw,
                                           LPFILETIME lpTime);

    // Set the time property to a given value
    //
    // Parameters:
    //
    //   lpSIObj - pointer to a Summary Info object
    //   iw - specifies which time to set and should be
    //        one of the following values:
    //      SI_TOTALEDIT
    //      SI_LASTPRINT
    //      SI_CREATION
    //      SI_LASTSAVE
    //
    //   lpTime - buffer containing new filetime
    //
    //   NOTE:    The filetime should be based Coordinated Universal Time (UTC).
    //            This ensures that the time is displayed correctly all over the
    //            world.
    //
    // Return value:
    //
    //   The function returns TRUE on succes.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
    // NOTE: FOR SI_TOTALEDIT lpTime WILL BE INTERPRETED AS THE TIME
    //       THE FILE HAS BEEN EDITED, NOT A DATE.  THE TIME SHOULD
    //       BE EXPRESSED IN UNITS OF 100ns.  I KNOW THIS IS
    //       A WEIRD UNIT TO USE, BUT WE HAVE TO DO THAT FOR BACK-
    //       WARDS COMPATABILITY REASONS WITH 16-BIT WORD 6.
    //
    //       ALSO NOTE THAT THE TIME WILL BE SHOW IN MINUTES IN THE
    //       PROPERTIES DIALOG.
    //
    //       OFFICE provides a utility routine to convert a number of
    //       minutes into units of 100ns. Call ConvertMinTo100ns
    //
  BOOL OFC_CALLTYPE FSumInfoSetTime (LPSIOBJ lpSIObj, WORD iw, LPFILETIME lpTime);

    // Get an integer property
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   iw - specifies which integer to get and should be
    //        one of the following values:
    //      SI_PAGES
    //      SI_WORDS
    //      SI_CHARS
    //      SI_SECURITY
    //
    //   pdw - pointer to a dword, will contain the int on return
    // Return value:
    //
    //   The function returns TRUE on succes, FALSE on error.
  BOOL OFC_CALLTYPE FDwSumInfoGetInt (LPSIOBJ lpSIObj, WORD iw, DWORD *pdw);

    // Set an integer property to a given value
    //
    // Parameters:
    //
    //   lpSIObj - pointer to Summary Info object
    //   iw - specifies which integer to set and should be
    //        one of the following values:
    //      SI_PAGES
    //      SI_WORDS
    //      SI_CHARS
    //      SI_SECURITY
    //
    //   dw - the value
    //
    // Return value:
    //
    //   The function returns TRUE on success.
    //   The function returns FALSE on error.
    //
    // Note: The function will dirty the object on success.
    //
  BOOL OFC_CALLTYPE FSumInfoSetInt (LPSIOBJ lpSIObj, WORD iw, DWORD dw);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus


////////////////////////////////////////////////////////////////////////////////
//
// MS Office Document Summary Information
//
// The Document Summary Information follows the serialized format for
// property sets defined in Appendix B ("OLE Property Sets") of
// "OLE 2 Programmer's Reference, Volume 1"
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in DOCSUMINFO.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPDSIOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "DocSum" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   DSIVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPDSIOBJ   - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

#ifdef OLE_PROPS
#include "DocSumI.h"

  // Use the real Vtbl for OLE objects
#define DSIVTBLSTRUCT struct IDocSum


  // For OLE objects, first param is pointer to interface class
#define LPDSIOBJ IDocSum FAR *

#else  // !OLE_PROPS

  // Create a placeholder Vtbl for non-OLE objects.
#define DSIVTBLSTRUCT struct _DSIVTBLSTRUCT { void FAR *lpVtbl; } DSIVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPDSIOBJ LPDOCSUMINFO

#endif // OLE_PROPS

  // Our object
typedef struct _DOCSUMINFO {

  DSIVTBLSTRUCT;                            // Vtbl goes here for OLE objs,
                                            // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  ULONG               m_ulRefCount;         // Reference count
  LPVOID              m_lpData;             // Pointer to the real data
  HPROPSHEETPAGE      m_hPage;              // Handle of property page.

} DOCSUMINFO, FAR * LPDOCSUMINFO;


#ifdef __cplusplus
extern TEXT("C") {
#endif

//
// Indices to pass to API routines to get the specifc data.
//

  // Strings
#define DSI_CATEGORY    0
#define DSI_FORMAT      1
#define DSI_MANAGER     2
#define DSI_COMPANY     3
#define DSI_STRINGLAST  3

  // Integer statistics
#define DSI_BYTES       0
#define DSI_LINES       1
#define DSI_PARAS       2
#define DSI_SLIDES      3
#define DSI_NOTES       4
#define DSI_HIDDENSLIDES 5
#define DSI_MMCLIPS     6
#define DSI_INTLAST     6


//
// Standard I/O routines
//

 BOOL FCbDocSumString (LPDSIOBJ lpDSIObj, WORD iw, DWORD *pdw);


    // Indicates if the Document Summary Infodata has changed.
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //
    // Return value:
    //
    //   TRUE -- the data has changed, and should be saved.
    //   FALSE -- the data has not changed.
    //
  BOOL OFC_CALLTYPE FDocSumShouldSave (LPDSIOBJ lpDSIObj);

//
// Data manipulation routines
//

  //
  // How Heading and Document parts work:
  //
  // Heading:
  // --------
  // Heading is a list of non-indented headings that will be
  // displayed in the "Contents" ply.
  //
  // Associated with each Heading is the number of document parts
  // that goes with the particular heading -- this is the concept of a
  // Heading Pair.
  //
  // Document Parts:
  // ---------------
  // Document Parts is a list of parts associated with a heading.
  //
  // Example (as it could be implemented in Microsoft Excel):
  // ----------------------------------------------
  // Worksheets
  //     Sheet1
  //     Sheet2
  // Modules
  //     Module1                             Figure 1
  // Charts
  //     Chart1
  //     Chart2
  //     Chart3
  //
  // Thus the Heading Pairs would be:
  //
  // Heading Pair
  //    string                           count
  //------------------------------------
  // Worksheets            2
  // Modules               1                 Figure 2
  // Charts                3
  //
  //
  // And the Document Parts would be:
  //
  // Document Parts
  //--------------------------
  // Sheet1
  // Sheet2
  // Module1
  // Chart1                                  Figure 3
  // Chart2
  // Chart3
  //
  //
  // Note: Headings and Document Parts are not restricted to be parts of
  //       a document, but can be whatever the client wants.  Car models,
  //       car makes, customers, etc...
  //
  //       The above is just an example.
  //



    // Get an integer property
    //
    // Parameters:
    //
    //   lpDSIObj - pointer to Document Summary Info object
    //   iw - specifies which integer to get and should be
    //        one of the following values:
    //      DSI_BYTES
    //      DSI_LINES
    //      DSI_PARAS
    //      DSI_SLIDES
    //      DSI_NOTES
    //      DSI_HIDDENSLIDES
    //      DSI_MMCLIPS
    //
    //   pdw - pointer to dword, will contain integer
    //
    // Return value:
    //
    //   The function returns TRUE on success, FALSE on error
    //
  BOOL OFC_CALLTYPE FDwDocSumGetInt (LPDSIOBJ lpDSIObj, WORD iw, DWORD *pdw);

    // Determine if the actual values of the LINKED user defined properties has changed
         // This function should only be called right after loading the properties to
         // see if the caller should update the link values.
         //
         // NOTE: The function works by checking the value of the PID_LINKSDIRTY property.
         //       When this function is called the property will be set to FALSE, so that
         //       flag is cleared next time the properties are saved.
         //
         // NOTE: Only the app that created the file that are being loaded should call this
         //       function.  I.e. Excel calls this for .xls files, noone else does, etc...
     //
     // Parameters:
     //
     //     lpDSIObj - pointer to Document Summary Info object
     //
     // Return value:
     //
     //     The function returns TRUE if the link values have changed.
     //     The function returns FALSE if the link value have not
     //     changed, or on error.
     //
  BOOL OFC_CALLTYPE FLinkValsChanged(LPDSIOBJ lpDSIObj);

#ifdef __cplusplus
}; // extern "C"
#endif


////////////////////////////////////////////////////////////////////////////////
//
// MS Office User Defined Property Information
//
// The User Defined Property Information follows the serialized format for
// property sets defined in Appendix B ("OLE Property Sets") of
// "OLE 2 Programmer's Reference, Volume 1"
//
// Notes:
//  - define OLE_PROPS to build OLE 2 interface objects too.
//
// The actual data is stored in USERPROP.  The layout of the first
// 3 entries must not be changed, since it will be overlayed with
// other structures.  All property exchange data structures have
// this format.
//
// The first parameter of all functions must be LPUDOBJ in order for these
// functions to work as OLE objects.
//
// All functions defined here have "UserDef" in them.
//
// Several macros are used to hide the stuff that changes in this
// file when it is used to support OLE 2 objects.
// They are:
//   UDPVTBLSTRUCT - For OLE, expands to the pointer to the interface Vtbl
//              - Otherwise, expands to dummy struct same size as Vtbl
//   LPUDOBJ    - For OLE, expands to a pointer to the interface which is
//                just the lpVtbl portion of the data, to be overlayed later.
//              - Otherwise, expands to a pointer to the whole data
//
////////////////////////////////////////////////////////////////////////////////

#ifdef OLE_PROPS
#include "UserPrpI.h"

  // Use the real Vtbl for OLE objects
#define UDPVTBLSTRUCT struct IUserDef

  // For OLE objects, first param is pointer to interface class
#define LPUDOBJ IUserDef FAR *

#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus

    // Must support IUnknown methods for OLE objects....
  HRESULT OFC_CALLTYPE HrUserDefQueryInterface (IUnknown FAR *,
                                             REFIID riid,
                                             LPVOID FAR* ppvObj);
  ULONG OFC_CALLTYPE UlUserDefAddRef (IUnknown FAR *);
  ULONG OFC_CALLTYPE UlUserDefRelease (IUnkown FAR *);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#else  // !OLE_PROPS

  // Create a placeholder Vtbl for non-OLE objects.
#define UDPVTBLSTRUCT struct _UDPVTBLSTRUCT { void FAR *lpVtbl; } UDPVTBLSTRUCT

  // For non-OLE objects, first param is pointer to real data.
#define LPUDOBJ LPUSERPROP

#endif // OLE_PROPS

  // User-defined property data.  Callers should *never* access this
  // data directly, always use the supplied API's.

typedef struct _USERPROP {

  UDPVTBLSTRUCT;                            // Vtbl goes here for OLE objs,
                                            // Must be here for overlays to work!
  BOOL                m_fObjChanged;        // Indicates the object has changed
  ULONG               m_ulRefCount;         // Reference count
  LPVOID              m_lpData;             // Pointer to the real data
  HPROPSHEETPAGE      m_hPage;              // Handle of property page.

} USERPROP, FAR * LPUSERPROP;


//
// Interface API's for User Property Information.
//
#ifdef __cplusplus
extern TEXT("C") {
#endif

//
// Standard I/O routines
//
    // Indicates if the data has changed, meaning a write is needed.
  BOOL OFC_CALLTYPE FUserDefShouldSave (LPUDOBJ lpUDObj);

//
// Routines to query and modify data.
//
  //
  // How User-defined properties work:
  //
  // See the OLE Property Exchange spec for full details.
  //
  // Each User-defined type has a string "Name" and integer Property Id
  // value associated with it.  The Property Id's are sequential, but
  // are only good for the current object in memory (i.e. you can't count
  // on the Property Id value remaining the same between loads of the
  // data.  The string will remain the same, if it has not been changed
  // or deleted.)
  // Currently, the User-defined types can have 5 types for the value:
  // String, Date, Integer, float and boolean.  When setting and getting the values, you
  // must make sure that the type stored matches what you expect to
  // retreive.  For Int's, the LPVOID should be the int itself, not
  // a pointer.  In all other cases, the LPVOID should point to a buffer
  // of appropriate size for the type.
  //

  // Masks used for querying property data.  Note that these are
  // mutually exclusive.
#define UD_STATIC       0x00
#define UD_LINK         0x01


    // Returns the type of the given Property Value from the string
    // Returns wUDInvalid on error
  UDTYPES OFC_CALLTYPE UdtypesUserDefType (LPUDOBJ lpUDObj, LPTSTR lpsz);

    // This will return the Property Value for the given Property string.
    // lpszProp is the property string
    // lpv is a buffer to hold the value, of size cbMax.
    // pfLink tells if the value is a link,
    // pfIMoniker tells if the value is a moniker.
    // pfLinkInvalid tells if the link is invalid
    // dwMask is used to specify whether the value returned is the
    //  static value, link name or IMoniker name.
    // Function returns NULL on error.
    // WARNING! Be very careful calling this.  Be sure that the
    // buffer and return value match the type for the Property Value!
  LPVOID OFC_CALLTYPE LpvoidUserDefGetPropVal (LPUDOBJ lpUDObj,
                                            LPTSTR lpszProp,
                                            DWORD dwMask,
                                            BOOL *pfLink,
                                            BOOL *pfLinkInvalid);

    // This acts exactly as the above routine (LpvoidUserDefGetPropVal),
    // except that it returns the value in the forma of a PropVariant.

  LPPROPVARIANT OFC_CALLTYPE LppropvarUserDefGetPropVal
                                            (LPUDOBJ lpUDObj,
                                             LPTSTR lpszProp,
                                             BOOL *pfLink,
                                             BOOL *pfLinkInvalid);


    // Set the value of a given property to a new value.
    // Be careful when setting properties that are linked - be sure
    // that the type the iterator is set to matches what the link is to.
    // If udtype == wUDinvalid, the type of the iterator will not change,
    // the value will be assumed to be the current type.
    //
         // fLinkInvalid : If the link is no longer valid, set this flag to true.
         //                A special icon will displayed in the listview and the last
         //                known value and type will be used.  Thus the values passed
         //                to this function will be ignored in this case.
         //
         //                If fLinkInvalid is true, but the iterator is not a link,
         //                the function will return FALSE
    //
    //                If fLinkInvalid is true the value will _not_ be changed.
         //
         // NOTE: If udtype == wUDDate you can set the value to 0 (not NULL)
         //       This will be interpreted as an invalid date and the date will
         //              be displayed as the empty string in the list box.

  BOOL OFC_CALLTYPE FUserDefChangeVal (LPUDOBJ lpUDObj,
                                               LPTSTR lpszProp,
                                               UDTYPES udtype,
                                               LPVOID lpv,
                                                         BOOL fLinkInvalid);


//
// Routines to create and remove data from the Property Set.
//

    // This will add a new Property to the set, with the given
    // Property string.  This function can also be used to modify
    // an existing property.
    //
    // lpUDObj      - pointer to the UD properties
    // lpszPropName - name of property to be added/modified
    // lpvVal       - value of the property
    // udtype       - value type
    // lpszLinkMonik - name of the link/moniker
    // fLink        - true if the property is a link
    // fHidden      - true if the property is hidden
    //
    // NOTE: If udtype == wUDbool, lpv must point to a DWORD, but the
    //       HIWORD must be 0.
    //
    // WARNING: Be sure that the type matches what the lpv really is!
    //
    // The caller is responsible for freeing any memory
    // associated with a property value after it is added to the
    // User-defined Property object.
    //
         // NOTE: If udtype == wUDDate you can set the value to 0 (not NULL)
         //       This will be interpreted as an invalid date and the date will
         //              be displayed as the empty string in the list box.
    //
    // The function returns a pointer to the PropVariant created for this
    // new value, or NULL if there is an error.
    //

    LPPROPVARIANT OFC_CALLTYPE LppropvarUserDefAddProp
                        (LPUDOBJ lpUDObj,
                         LPTSTR lpszPropName,
                         LPVOID lpvVal,
                         UDTYPES udtype,
                         LPTSTR lpszLinkMonik,
                         BOOL fLink,
                         BOOL fHidden);

    // This will delete a Property from the set given a Property string.
  BOOL OFC_CALLTYPE FUserDefDeleteProp (LPUDOBJ lpUDObj, LPTSTR lpsz);

//
// Routines to iterate through the User-defined properties
//
// Notes: Adding and deleting elements invalidates the iterator.
//
    // An iterator for User-defined Properties
  typedef struct _UDITER FAR * LPUDITER;

    // Create a User-defined Properties iterator
  LPUDITER OFC_CALLTYPE LpudiUserDefCreateIterator (LPUDOBJ lpUDObj);

    // Destroy a User-defined Properties iterator
  BOOL OFC_CALLTYPE FUserDefDestroyIterator (LPUDITER *lplpUDIter);

    // Determine if an iterator is still valid
  BOOL OFC_CALLTYPE FUserDefIteratorValid (LPUDITER lpUDIter);

    // Iterate to the next element
         // Returns TRUE if we could get to the next element, FALSE otherwise.
  BOOL OFC_CALLTYPE FUserDefIteratorNext (LPUDITER lpUDIter);

    // Returns true if the iterator is a link, false otherwise
  DLLEXPORT BOOL OFC_CALLTYPE FUserDefIteratorIsLink (LPUDITER lpUDIter);

    // This will return the Property Value for the given iterator
    // lpv is a buffer to hold the value, of size cbMax.
    // dwMask is used to specify whether the value returned is the
    //  static value, link name or IMoniker name.
    // pfLink tells if the value is a link,
    // pfIMoniker tells if the value is a moniker.
    // pfLinkInvalid tells if the link is invalid.
    // Function returns NULL on error.
    // WARNING! Be very careful calling this.  Be sure that the
    // buffer and return value match the type for the Property Value!

  LPPROPVARIANT OFC_CALLTYPE LppropvarUserDefGetIteratorVal
                                              (LPUDITER lpUDIter,
                                               BOOL *pfLink,
                                               BOOL *pfLinkInvalid );


    // This will return the Property String (name) for the property
  LPTSTR OFC_CALLTYPE LpszUserDefIteratorName (LPUDITER lpUDIter);

//
// Misc. utility routines
//

  // Routines dealing with hidden Properties.

    // Hide a Property based on the Property string.
  BOOL OFC_CALLTYPE FUserDefMakeHidden (LPUDOBJ lpUDObj, LPTSTR lpsz);

#ifdef __cplusplus
}; // extern "C"
#endif


#ifdef __cplusplus
extern TEXT("C") {
#endif

  // Commands for DWQUERYLD
#define QLD_CLINKS      1  /* Return the number of links */
#define QLD_LINKNAME    2  /* Return a pointer to the string for index */
#define QLD_LINKTYPE    3  /* Returns the type of the value of the index */
#define QLD_LINKVAL     4  /* Return value for the index, use same
                              rules as for LPVOIDs in UserDef functions */

  // This functions should respond to the above commands by returning the
  // appropriate value.  For commands that require an index, the
  // lpszName parameter will be the Name of the link item previously
  // retrieved from the index, if it is not NULL.
  // lplpvBuf is the buffer supplied by "us" (the dll) to copy the
  // value to.  Use the function LpvOfficeCopyValToBuffer() to
  // copy the data.  This parameter will be NULL for QLD_CLINKS and
  // QLD_VALTYPE
typedef DWORD_PTR (OFC_CALLBACK *DWQUERYLD)(DWORD dwCommand, DWORD dwi, LPVOID *lplpvBuf, LPTSTR lpszName);







  // Masks for different options
#define OSPD_ALLOWLINKS         0x1    // The Custom dialog will allow fields to be linked if this is set.
#define OSPD_NOSAVEPREVIEW      0x2    // Don't show the Save Preview Picture checkbox
#define OSPD_SAVEPREVIEW_ON     0x4    // Save Preview Picture should be on by default

    // LPUDObj is a pointer to a pointer to a user-defined property object.
    // If *lplpUDObj == NULL, an object will be created by the dialog as needed.
    // Note that the object will use the same malloc & free routines as
    // the lpSIObj uses.
    //
    // lpszFileName is the fully qualified name of the storage as it appears
    // in the filesystem.  This can be NULL if no file exists.
    //
    // dwMask contains either 0 or a set of valid flags for various options.
    //
    // LPFN_DWQLD is a callback, that when given a dwCommand of 0
    // returns the number of links, and for any other number 0 < NumLinks,
    // places the link data & static value in the lpld buffer and returns non-0
    // if the function succeeded.
    //
    // The storage for the buffer is to be allocated by the app, and a pointer
    // to that storage passed back.
    //
    // pptCtr - POINT struct filled with the coordinates of the center
    //          of the dialog.  Used to make sure we are using sticky
    //          dialog coordinates.  If pPoint->x == -1, we ignore and use
    //          the default position for the dialog.
    //
    //          pptCtr will be filled with the coordinates of the new position
    //          of the dialog on returning.
    //
    //          The coordinates should be in client area coordinates, i.e. in
    //          hWndParent coordinates.
    //
    // lpszCaption - caption for the dialog.  This should be the filename as it is
    //               displayed in the apps document title bar.
    //               The properties dialog caption will be as follows:
    //
    //               <foo> Properties
    //
    //               where foo is the string pointed to by lpszCaption.
    //
    // The function returns TRUE on success, FALSE on error or if the user hit Cancel.
    //
    // Note: It's the caller's resposibility to invalidate any links (if appropriate)
    //       before calling this function.
    //
    // Note: If lpfnDwQueryLinkData is NULL, the caller must invalidate any linked properties.
    //
  BOOL OFC_CALLTYPE FOfficeShowPropDlg (HWND hWndParent,
                                     LPTSTR lpszFileName,
                                     LPSIOBJ lpSIObj,
                                     LPDSIOBJ lpDSIObj,
                                     LPUDOBJ FAR *lplpUDObj,
                                              DWORD dwMask,
                                     DWQUERYLD lpfnDwQueryLinkData,
                                     LPPOINT pptCtr,
                                     LPTSTR lpszCaption);

    // Creates and initializes all non-NULL objects.
    // Create the object and return it.  Caller responsible for destruction.
    //
    // rglpfn is an array, with the following callbacks supplied by the user:
    //
    //  Code Page Conversion
    //
    //  rglpfn[ifnCPConvert] = (BOOL) (OFC_CALLBACK *lpfnFCPConvert) (LPSTR lpsz,
    //                                                  DWORD dwFrom,
    //                                                  DWORD dwTo,
    //                                                  BOOL fMacintosh)
    //    lpsz is a 0 terminated C string, dwFrom is the code page
    //    lpsz is currently stored as, dwTo is the code page it should
    //    be converted to, fMacintosh indicates whether dwFrom is a Mac
    //    or Windows code page identifier.
    //
    //  Convert an sz to a double
    //
    //  rglpfn[ifnFSzToNum] = (BOOL) (OFC_CALLBACK *lpfnFSzToNum)(
    //                                   double *lpdbl,
    //                                   LPSTR lpszNum)
    //
    //   lpdbl - pointer to a double, this is set by the app
    //   lpszNum - zero-terminated string representing the number
    //
    //  Convert a double to an sz
    //
    //  rglpfn[ifnFNumToSz] = (BOOL) (OFC_CALLBACK *lpfnFNumToSz)(
    //                                   double *lpdbl,
    //                                   LPSTR lpszNum,
    //                                   DWORD cbMax)
    //   lpdbl   - pointer to a double
    //   lpszNum - on return a zero-terminated string representing the number
    //   cbMax   - Max number of bytes in lpszNum
    //
    //   Update the statistics on the Statistics tab
    //
    //   rglpfn[ifnFUpdateStats] = (BOOL) (OFC_CALLBACK *lpfnFUpdateStats)(
    //                                       HWND hwndParent,
    //                                       LPSIOBJ lpSIObj,
    //                                       LPDSIOBJ lpDSIObj)
    //
    //      hwndParent - window of the properties dialog, so that the app
    //                   can put up an alert, letting the user know the the
    //                   data is being updated.
    //
    //      lpSIObj, lpDSIObj - objects to update
    //
    //   Note:  If the app does not want to set the statistics before bringing up
    //          the dialog, they can provide this callback function.  If the
    //          function pointer is not NULL, the function will be called the first
    //          time the user clicks on the Statistics tab.  The app should then update
    //          all appropriate statistics for the tab and return TRUE on success, FALSE
    //          on failure.  If the function pointer is NULL, the existing data will be
    //          used.
    //
    //  Note:
    //         Only rglpfn[ifnCPConvert] must be non-NULL.  If it is NULL, the
    //         function will return FALSE, and the objects will not be created.
    //
    //         rglpfn[ifnFSzToNum] and rglpfn[ifnFNumToSz] must either both be
    //         non-NULL, or NULL.  Otherwise, the function will return FALSE, and
    //         the objects will not be created.  If both functions are NULL, there
    //         will be no floating point support in OLE Extended Properties (i.e. on
    //         the Custom tab), but integers will be supported.
    //

  
  BOOL OFC_CALLTYPE FOfficeCreateAndInitObjects (LPSIOBJ *lplpSIObj,
                                                 LPDSIOBJ *lplpDSIObj,
                                                 LPUDOBJ *lplpUDObj);

    // Clear any non-null objects
  BOOL OFC_CALLTYPE FOfficeClearObjects (LPSIOBJ lpSIObj,
                                             LPDSIOBJ lpDSIObj,
                                             LPUDOBJ lpUDObj);

    // Destroy any non-null objects
  BOOL OFC_CALLTYPE FOfficeDestroyObjects (LPSIOBJ *lplpSIObj,
                                               LPDSIOBJ *lplpDSIObj,
                                               LPUDOBJ *lplpUDObj);


  // Use these functions to set the dirty flag of the given object.
  // Note: It's the caller's responsibility to make sure that the
  //       object is non-NULL
  VOID OFC_CALLTYPE OfficeDirtyUDObj(LPUDOBJ lpUDObj, BOOL fDirty);


// Flags for Load & Save
#define OIO_ANSI                0x0001 // The storage is an ANSI storage (UNICODE is the default)
#define OIO_SAVEIFCHANGEONLY    0x0002 // Only streams that are dirty should be saved.
#define OIO_SAVESIMPLEDOCFILE   0x0004 // The storage is a simple DOC file.

    // Populate the objects with data.  lpStg is the root stream.
    // Returns the number of streams loaded.
    // dwFlags: OIO_ANSI specifies that lpStg is an ANSI storage (UNICODE is the default)
    //
    // The function returns the following:
    //
#define MSO_IO_ERROR   0     // The stream(s) were found, but the load failed
#define MSO_IO_NOSTM   1     // The stream(s) were not found
#define MSO_IO_SUCCESS 2     // The stream(s) were found, and the load succeeded
    //
    // NOTE: The caller can load either the summary info stream (lpSIObj != NULL), or
    //       the Document Summary Info stream (lpDSIObj != NULL && lpUDObj != NULL) or
    //       both.
    //
    // NOTE: If the caller asks to load both streams, MSO_IO_NOSTM will not be returned, as
    //       long as one of the streams exists.

  DWORD OFC_CALLTYPE DwOfficeLoadProperties (LPSTORAGE lpStg,
                                                 LPSIOBJ lpSIObj,
                                                 LPDSIOBJ lpDSIObj,
                                                 LPUDOBJ lpUDObj,
                                                 DWORD dwFlags,
                                                 DWORD grfMode);

    // Write the data in the given objects.  lpStg is the root stream.
    // Returns the number of streams saved.
    // dwFlags: OIO_ANSI specifies that lpStg is an ANSI storage (UNICODE is the default)
    //
    //          OIO_SAVEIFCHANGEONLY specificies that only streams that are
    //           "dirty" will be saved.  Do NOT specify this if you are
    //           saving to a tmp file.  Also do not attempt to "outsmart"
    //           the save by passing NULL objects, use this flag instead.
    //
    //          OIO_SAVESIMPLEDOCFILE specifies that the storage is a simple DOC file.
    //
  DWORD OFC_CALLTYPE DwOfficeSaveProperties (LPSTORAGE lpStg,
                                                 LPSIOBJ lpSIObj,
                                                 LPDSIOBJ lpDSIObj,
                                                 LPUDOBJ lpUDObj,
                                                 DWORD dwFlags,
                                                 DWORD grfStgMode);


////////////////////////////////////////////////////
// VB support routines - see spec for details.
////////////////////////////////////////////////////

    // Creates a Builtin property collection and returns it.
    // pParent is the parent IDispatch object.
    // The new IDispatch object is returned via pvarg.
  BOOL OFC_CALLTYPE FGetBuiltinPropCollection (LCID lcid,
                                                   LPSIOBJ lpSIObj,
                                                   LPDSIOBJ lpDSIObj,
                                                   IDispatch *pParent,
                                                   VARIANT *pvarg);

    // Creates a Custom property collection and returns it.
    // pParent is the parent IDispatch object.
    // The new IDispatch object is returned via pvarg.
  BOOL OFC_CALLTYPE FGetCustomPropCollection (LCID lcid,
                                                  LPUDOBJ lpUDObj,
                                                  IDispatch *pParent,
                                                  VARIANT *pvarg);

#ifdef __cplusplus
}; // extern "C"
#endif

/////////////////////////////////////////////////////////////////////////
// Progress Report Thermometer (PRT) routines and data structure       //
/////////////////////////////////////////////////////////////////////////
/* Usage:
1.  Most of the functions are performed asynchronously, which means that
        your call causes a message to be sent to a (low-priority) thread,
        that later performs the operation you requested.  This implies that
        you don't really know when the thing your requested is going to happen.
        Thus, you should not touch the status line window until you are
        sure the thread is done painting in it.  Since this implies you need
        some synchronization, the EndPRT function (described below) is
        made synchronous--after it returns, you are guaranteed the thread
        will not touch the window until you call StartPRT again.

        All the functions except StartPRT are BOOL--they return TRUE in case of success
        and FALSE in case of failure.  StartPRT return NULL in case of failure.
        The kinds of failures that may occur are described below, next to each stub.

        Multiple progress report thermometers can be run in different windows
        at one time.

2.      A few notes on drawing:  the PRT functions do not validate any areas
        of your window, nor do they change any attributes of the Device Context
        for the window that you pass in to StartPRT or they get with GetDC (which
        they do if the hdc you pass in to StartPRT is NULL).  So, if you want the
        device context attributes (e.g., font) to other than standard,
        you have to take care of that.  UpdatePRT assumes the window has
        been untouched since the last PRT call (i.e., it draws the minimum
        needed).  RedrawPRT and StartPRT repaint the whole window.

3.  The data structure. As there are variables my functions need to share
        and access, and we can't package them into a class (as we are working
        in C, not in C++), for every instance of a progress indicator we
        allocate a data structure in StartPRT, whose pointer will always
        be the first argument UpdatePRT, RedrawPRT and EndPRT.
        The data structure's name is PRT; the application need
        not worry/know about what the data structure contains.  All it needs
        to do is save its pointer (of type LPPRT) returned by StartPRT and keep
        it around until calling EndPRT.  EndPRT will free it.

4.  StartPRT.  To be called every time you need a new progress report.
        Redraws the window completely, putting eveyrthing needed into it.
        Aside from the pointer to PRT structure, takes:
        1) HWND hwnd--the handle to the window where the progress report
                needs to appear.  UNTIL CALLING EndPRT, THE APPLICATION SHOULD
                NOT TOUCH THIS WINDOW.  See RedrawPRT for information on how
                to process WM_PAINT messages to it.
        2) HDC hdc--optional handle to the window's client area device context, with the
                attributes you want selected into it (you cannot change the text
                background color, because the window has to be all background
                cvBtnFace.  All the other attributes can be changed).  If it is NULL,
                we will get the DC by GetDC(hwnd) every time we draw and release it when
                done drawing.  See also "A Few Notes on Drawing" above.
        2) WORD nMost--the number of "little things" it has to accomplish.
                Used a scaling factor--i.e., the progress report tells the user
                that nDone/nMost things are done.  The user will not have
                any idea what nMost is, since the ratio nDone/nMost is all
                that is reflected in the indicator.  E.g., if the application has
                37 disk blocks to write (assuming every write takes about the
                same time), nMost should be 37.
        3) lpszTitle. A string, to appear as a title to the left of the
                progress indicator.  E.g., "Saving the data:"  Note that the string
                has to remain unchanged and readable until the call to EndPRT for
                that instance.
    4) WORD nFrame -- This is a bitfield that indicates which sides of the
            status bar should be painted with a 3D style side. Use the PRT_FRAME_?
                macros to select the side. Use PRT_FRAM_HIDE to do not want a fram. Use
                PRT_FRAME_SHOW if you want a complete frame around the status bar. Note
                that you want to use PRT_FRAME_TOP if you are displaying the status
                barat the bottom of the window, because the window border itself will
                provide the left, right and bottom side of the status bar.

        Returns the pointer to the new prt data structure
        (see "The Data Structure" above).
        Fails and returns NULL if:
        1) Cannot allocate the new data structure.
        2) For some strange reason synchronization failed or it was not able
                to communicate to the thread.

5.  UpdatePRT.  To be called whenever you've made some progress.  Aside
        from the pointer to PRT structure, takes one argument--WORD nDone,
        which is to indicate how much you accomplished.  In order for
        things to work well, nDone should be not greater than nMost and
        at least as big as nDone with which you previously called us
        (after all, we are a progress indicator, not a regress indicator).
    If nDone is greater than nMost, it will force nDone to equal nMost,
        i.e., simply fill up the indicator to its capacity.

        Assumes the window hasn't been touched since the last PRT call--i.e.,
        draws the minimum needed to indicate the change.

        Returns FALSE if:
        1) The pointer to the PRT was not writeable.
        2) it had trouble communicating with the thread.

6.  RedrawPRT.  To be called whenever you need the window repainted
        (remember, the application is not allowed to touch the window),
        i.e., whenever you get the WM_PAINT message for that window.  Make
        sure to validate the rectangle by calling BeginPaint--EndPaint before
        that (otherwise you will keep getting WM_PAINT messages RedrawPRT
        doesn't validate anything).  Redraws the entire window--the little
        white line on top, the title and the thermometer.  Takes no arguments
        other than the pointer to PRT.

        Returns FALSE if:
        1) The pointer to the PRT was not writeable.
        2) it had trouble communicating with the thread.

7.  AdjustPRT. To be called when either one of the input parameters of
    StartPRT are to be changed, i.e. the title, the hdc, and/or the
    progress extent (nMost). Use zero or NULL to keep the existing
        value, e.g. AdjustPRT(lpprt, NULL, 0, "xyz") will only change the
        title. Note that this api will only change the internal state of
        the progress bar. A call to RedrawPRT() or      UpdatePRT() may be
        needed to updated the screen, depending on the input parameters:

    1) Title and HDC: RedrawPRT() must be called to force the change
        to be updated on the screen.

    2) nMost: RedrawPRT() is not needed, as the next call to UpdatePRT()
    will use the new value. Note that changing this value will not
    result in that a fewer number of boxes is painted when UpdatePRT() is
    called, even if nMost is increased. Use RedrawPRT() to completely redraw
    the progress bar with the correct (possibly shortened) length.

8.  EndPRT.  To be called when you don't want the progress report any more,
        and need to draw in the window.  Is the only
        synchronous procedure--doesn't return until it is sure the thread
        will not touch the window any more.  Thus, you might have to wait
        a little bit for the thread to finish painting.  But, if it
        succeeded, you are guaranteed that the thread will not mess with the
        window any more.

        Takes no arguments other than the pointer to PRT.  Frees that pointer.

        Returns FALSE if:
        1) The pointer to the PRT was not writeable.
        2) It has trouble communticating with the thread, or if it had to wait
        for the thread to finish painting for more than PRT_WAIT_TIMEOUT
        milliseconds (in which case it gives up waiting).  You are NOT
        guaranteed that the thread will not touch your window if EndPRT
        returned FALSE.
*/

/* Data structure where PRT stores its info */
typedef struct tagPRT * LPPRT;

#define PRT_FRAME_LEFT          0x01
#define PRT_FRAME_RIGHT         0x02
#define PRT_FRAME_TOP           0x04
#define PRT_FRAME_BOTTOM        0x08
#define PRT_FRAME_HIDE          0x00
#define PRT_FRAME_SHOW          (PRT_FRAME_LEFT|PRT_FRAME_TOP|PRT_FRAME_RIGHT|PRT_FRAME_BOTTOM)


#ifdef __cplusplus
extern TEXT("C") {
#endif
    LPPRT OFC_CALLTYPE StartPRT(HWND hwnd, HDC hdc,
                                        const DWORD nMost,
                                                                                LPCTSTR lpszTitle,
                                                                                const WORD nFrame);
        BOOL  OFC_CALLTYPE UpdatePRT(LPPRT lpprt, const DWORD nDone);
        BOOL  OFC_CALLTYPE RedrawPRT(LPPRT lpprt);
    BOOL  OFC_CALLTYPE AdjustPRT(LPPRT lprrt, HDC hdc,
                                         const DWORD nMost,
                                                                                 LPCTSTR lpszTitle,
                                                                                 const WORD nFrame);
        BOOL  OFC_CALLTYPE EndPRT(LPPRT lpprt);
#ifdef __cplusplus
}; //Extern "C"
#endif

//-------------------------------------------------------------------------
//      Below are the comments for the stylized title bar funcitons
//
//      1. SetTitleBar:
//      Initializes the stylized title bar or turns it off.
//
//      Parameters:
//      hwnd--the window for which you want the stylized title bar on/off.
//      This window has to have the standard for overlapped window
//      border, caption, system menu, and the minimize/maximize/kill
//      buttons on the right of the title bar.
//
//      fStylized--TRUE if you want the stylized title bar on, FALSE if you
//      want it off.
//
//  Return value: TRUE on success, FALSE on failure.
//
//      NOTES:
//      You should evenutally turn the stylized title bar off for every
//      window for which it was turned on.  If the window receives the
//      WM_DESTROY message, and after the original window procedure's
//      processing of that message the stylized title bar is still on,
//      the title bar will be turned off by the title bar window procedure.
//      This is done to make sure we re-claim the memory.  However, you should
//      rather do it yourself.  Read the next paragraph.
//
//      This function subclasses the window procedure for hwnd when turning on
//      the stylized title bar, and unsubclasses it when turning it off.
//      You want to make sure that unsubclassing takes place in the opposite
//      order than subclassing.  Do it yourself--then you are safer.
//
//      Do NOT free the office dll until the title bar is turned off!
//
//      Error handling:  if, at any point, the stylized title bar can not be
//      successfully drawn, the standard system title bar will be drawn
//                instead.
//
//                2. SetTitleBarMDI():
//                This api should be used by standard MDI applications instead of
//                SetTitleBar(). Word and Excel would _not_ use it for example, since
//                they have implemented their own MDI support (heck, they invented it
//                in the first place).
//
//                Note that this API  must be called _after_ the MDI client window has
//                been created. It is used just like SetTitleBar() in all other respects.
//
//                3. MsoSetNCAWParam():
//                This api is used by Word to accomplish the impossible - to make their
//                main window look active while it is not (Word is bringing up pop-up
//                dialogs that are now owned by the top-level window, which of course
//                causes the main window to be in-active). Note that this is relying on
//                a side effect in the system and may or may not work in future (or
//                other) versions of Windows (a mega hack in other words.. ;-).
//-----------------------------------------------------------------------------
#ifdef __cplusplus
extern TEXT("C") {
#endif
BOOL OFC_CALLTYPE SetTitleBar(HWND hwnd, BOOL fStylized);
BOOL OFC_CALLTYPE SetTitleBarMDI(HWND hwnd,
                                                                                                          HWND hwndMDIClient,
                                                                                                          BOOL fStylized);
VOID OFC_CALLTYPE MsoSetNCAWParam(WPARAM wParam);
#ifdef __cplusplus
}; // Extern "C"
#endif

/*---------------------------------------------------------------
        AUTOCORRECT STUFF
----------------------------------------------------------------*/
#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
typedef VOID (OFC_CALLBACK *VRECORDVAR)(BOOL fInitCap, BOOL fCapDays, BOOL fReplaceText);
typedef VOID (OFC_CALLBACK *VRECORDREPL)(int, TCHAR rgSrc[], TCHAR rgDst[]);
typedef VOID (OFC_CALLBACK *VACADJUST)(int isz, int disz);

// Values passed in pfnRecordRepl (callback of OFCInitAutoCorrect) when ACXcept
#define rgchACXAdd              ((TCHAR *) -1)
#define rgchACXDelete   ((TCHAR *) -2)

// Initialize AutoCorrect
LPVOID OFC_CALLTYPE OFCInitAutoCorrect(VRECORDVAR pfnRecordVar, VRECORDREPL pfnRecordRepl, int fFullServices, VACADJUST pfnACAdjust);

// Free all AutoCorrect structures (call on exiting)
VOID OFC_CALLTYPE OFCFreeAutoCorrect(void);

// Get pointers to original AC and ACX buffers read from Registry
BOOL FOFCGetAutoCorrectBuffers(TCHAR FAR * FAR *pchAC, TCHAR FAR * FAR *pchACX, DWORD FAR *pcb);

// Check for AutoCorrection of character ch
// returns: True if there is a correction in pchTo, False if no autocorrection
// ch should already be in the buffer when this is called
BOOL OFC_CALLTYPE FOFCAutoCorrect(TCHAR FAR *hpchBuffer, long cchHpch, DWORD ch, TCHAR pchTo[], long *pcchTo, long *pcchSelection);
int OFC_CALLTYPE CchOFCAutoCorrectString(TCHAR FAR *hpch, long cchHpch, int ichReplaceStart, TCHAR FAR *hpchBuf, long cchBuf);
int OFC_CALLTYPE IOFCTriggerFromXchXch(int xch1, int xch2);

// Return the count of items in the ReplacementList
long OFC_CALLTYPE OFCAutoCorrectListCount(void);

// Get item i from ReplacementList
// fTrue=success, fFalse means invalid i
BOOL OFC_CALLTYPE FOFCGetAutoCorrectItemSz(long i, TCHAR szFrom[], long cchFrom, TCHAR szTo[], long cchTo);

// Add a replacement
BOOL OFC_CALLTYPE FOFCAddAutoCorrection(TCHAR FAR *hpchFrom, long cchFrom, TCHAR FAR *hpchTo, long cchTo, short grfac, int *pi);

// Flags for Shared Office AutoCorrect bit mask grfac
#define facACTextRepl                   0x0000                                  // Regular AC repl
#define facACX                          0x0001                                  // AC Exception
#define facACStatic                     0x1000                                  // Do not free storage
#define facACStaticTextRepl             (facACTextRepl|facACStatic)
#define facACStaticACX                  (facACX|facACStatic)

// Delete replacement i
// fTrue=success, fFalse means invalid i
BOOL OFC_CALLTYPE FOFCDeleteAutoCorrection(long i);


// Add new AutoCorrect Exception (ACX)
BOOL OFC_CALLTYPE FOFCAddACXception(int iacx, TCHAR *pch, int cch,
                                                                                        short grfac);

// Return the index for the AutoCorrect Exception (ACX)
BOOL OFC_CALLTYPE FOFCLookupACXception(int iacx, TCHAR *pch, int cch,
                                                                                           int *pisz);

// Delete existing AutoCorrect Exception (ACX)
BOOL OFC_CALLTYPE FOFCDeleteACXception(int isz);


// Get AutoCorrect settings
VOID OFC_CALLTYPE OFCGetAutoCorrectVars(BOOL *pfInitCap, BOOL *pfCapDays, BOOL *pfReplaceText);

// Set AutoCorrect settings
VOID OFC_CALLTYPE OFCSetAutoCorrectVars(BOOL fInitCap, BOOL fCapDays, BOOL fReplaceText);

// Find a Replacement and return in i
// fTrue=found replacement, fFalse means couldn't find the replacement
BOOL OFC_CALLTYPE FOFCLookupAutoCorrectReplacement(TCHAR rgchFrom[], long cchFrom, long *pi);

typedef struct _AUTOCORRDLGARG {
        HWND  hwndParent; // Parent window of dialog
        LPPOINT pptCtr;      // Center point of dialog

} AUTOCORRDLGARG, FAR * PAUTOCORRDLGARG;

// Bring up the Auto Correct dialog
BOOL OFC_CALLTYPE FOFCAutoCorrectDlg(PAUTOCORRDLGARG pArgs);

// Save the Auto Correct settings to the registry.
// Should only be called after programmatic changes.
VOID OFC_CALLTYPE OFCSaveAutoCorrectSettings(void);

// Synchronize the Auto Correct settings to the Registry.
// Can be callled even if no programatic changes.
VOID OFC_CALLTYPE OFCSyncAutoCorrectSettings(void);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

/*-------------------------------------------------------------------------
        POST DOCUMENT Functions
--------------------------------------------------------------------------*/
#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus

// Mail Systems
#define OFC_MSEXCHANGE   1 // Microsoft Exchange
#define OFC_16_BIT_NOTES 2 // 16 bit Lotus Notes

// Function: FOFCMailSystemInstalled
//
// Purpose:      Detects if a Mail system is installed
//
// Input:    dwSystem - one of the Mail Systems constants
//
// Returns:  True if the system is installed, FALSE otherwise
//
// NOTE: DO NOT CALL THIS FUNCTION TO FIGURE OUT IF APP CAN POST DOCUMENTS.
//       CALL DwOFCCanPostDoc INSTEAD.
//
BOOL OFC_CALLTYPE FOFCMailSystemInstalled(DWORD dwSystem);


// Function: DwOFCCanPostDoc
//
// Purpose: Check if Post Doc support can be added.
//
// Parameters: None.
//
// The function returns:
#define OFC_NO_POSTDOC                  0               // No Post Doc support
#define OFC_EMS_POSTDOC                 1               // EMS Post Doc support
#define OFC_NOTES16_POSTDOC             2               // 16 Bit Notes Post Doc support
// NOTE: All other values are reserved for current and future use
//
DWORD OFC_CALLTYPE DwOFCCanPostDoc();

// Function: DwOFCPostDoc.
//
// Purpose: Posts the document to either EMS or Notes.
//
// Parameters:
//
//      pszFilename - points to a file on disk to be posted,
//                    i.e. a temporary copy of the file in memory.
//
//      pszClassName - Class name of the document (E.g. Word.Document.6).  This can be NULL.
//                     If NULL, the message icon will be a generic document icon.
//
//      lpSIObj, lpDSIObj, lpUDObj - contains all the extended properties.  These can be
//                                   the pointers stored in memory since they should con-
//                                   tain the same info as in the file on disk.
//
//
//      pszMessSubj  - This will be the subject of the message as it appears in the folder.
//                     This should be the real filename, i.e. foo.ext. The file extension
//                     should be correct, i.e. .XLS, .DOC, .PPT, .MDB, etc.  The reason is that
//                     the filename is used to look up the correct icon via the registry.
//                     This can be a long filename.
//
// !!! NOTE:  THE NEXT 2 PARAMETERS ARE IGNORED.  APP CAN PASS WHATEVER THEY WANT. !!!
//      pszRecording - the name of the selected database will be copied into this buffer.
//                     Caller can use this for recording.
//
//      cbRecMax     - number o' bytes in pszRecording.
//
// !!! END O' IGNORANCE !!!
//
//      lhSession - it is the caller's responsibility to log in to EMS.
//                  If lhSession is 0 (invalid session), DwOFCPostDoc will return an error.
//                  lhSession will be typecast to a LPMAPISESSION pointer.
//
//       NOTE:    - the session handle should be an Extended MAPI session handle.
//
//       NOTE:    - at this point we are not posting to Notes.
//
//      hwndParent - Parent window handle
//
// The function returns:
#define OFC_ERROR               0           // An error occurred, document was not posted
#define OFC_CANCEL              1           // User cancelled dialog
#define OFC_SUCCESS             2           // Document was posted successfully
#define OFC_NO_FOLDERS          3           // No folders were found in the storage.
#define OFC_NO_STORAGE          4           // There was no public subscription storage
//
// OFC_ERROR: Function was called when there was no system detected (neither EMS nor Notes
//            on user's machine).
//            Function was called without first having called DwOFCCanPostDoc.
//            Function was called without first logging onto EMS
//            Mail system calls failed.
//            pszFileName was NULL.
//            pszMessSubj was NULL.
//
DWORD OFC_CALLTYPE DwOFCPostDoc(LPTSTR pszFilename,      // full path of file on disk to post
                      LPTSTR pszAppName,   // Name of the application
                                                    LPSIOBJ lpSIObj,    // Summary Info object
                                                         LPDSIOBJ lpDSIObj,  // Document Summary Info object
                                                    LPUDOBJ lpUDObj,    // User Defined properties object
                                                    LPTSTR pszMessSubj,  // Message Subject
                                                    LPTSTR pszRecording, //       Ignored
                                                    DWORD cbRecMax,     //          "
                                                    LPVOID lhSession,   // Session handle
                                    HWND hwndParent);   // Parent window handle


//       NOTES F/X
//
// How to:
//
//          1) The app gets a message from Notes to create an OLE 1 object.
//          2) The app creates the object, and gets a SetData message from Notes.
//          3) In the SetData function, the app should detect that it's Notes
//             asking.
//          4) Part of the SetData code should be a call to MsoHLoadPropertiesFromNotes.
//             This function returns a handle that should be stored with the object.
//          5) When the user either updates or closes the object, the app
//             should call MsoWritePropertiesToNotes passing the handle from step 4.
//          6) Whenever the user closes an object created in step 2, MsoNotesTerm
//             should be called.  The app should then set the stored handle to NULL.
//
// NOTES: Notes F/X is not supported on NT.
//


// Function:   MsoLoadPropertiesFromNotes
//
// Purpose:    Reads the properties from a Notes record, and stuffs
//             them into the OLE Extended properties
//
// Parameters: hclip    - handle containing the data passed to the SetData function
//             lpSIObj  - pointer to a Summary Info object
//             lpDSIObj - pointer to a Document Summary Info object
//             lpUDObj  - pointer to a User Defined object
//
// Returns:    A handle which the caller must store and use in the call to
//             MsoWritePropertiesToNotes.
//
// Note:       It's the caller's responsibility to store the returned handle
//             with the appropriate object.  I.e. doc 1 and doc 2 will have
//             different handles.
//
HANDLE OFC_CALLTYPE MsoHLoadPropertiesFromNotes(HANDLE hclip,
                                                     LPSIOBJ lpSIObj,
                                                     LPDSIOBJ lpDSIObj,
                                                     LPUDOBJ lpUDObj);

// Function:   MsoWritePropertiesToNotes
//
// Purpose:    Stuffs the OLE Extended properties into a Notes record.
//
//
// Parameters: hNote    - handle to a Notes note.  This is the handle
//                        returned by MsoLoadPropertiesFromNotes
//
//             lpSIObj  - pointer to a Summary Info object
//             lpDSIObj - pointer to a Document Summary Info object
//             lpUDObj  - pointer to a User Defined object
//             pszClassName - string containing the document's class name (e.g. Excel.Sheet.5)
//                            This can be NULL.
//
// Returns:    Nuthin'.
//
VOID OFC_CALLTYPE MsoWritePropertiesToNotes(HANDLE hNote,
                                                    LPSIOBJ lpSIObj,
                                                    LPDSIOBJ lpDSIObj,
                                                    LPUDOBJ lpUDObj,
                                                    LPTSTR pszClassName);
// Function:   MsoHUpdatePropertiesInNotes
//
// Purpose:    Update the data in Notes
//
// Parameters: hNote    - handle to a Notes note.  This is the handle
//                        returned by MsoLoadPropertiesFromNotes
//
// Returns:    A handle. The caller must use set the lphandle of the
//             GetData method to point to the returned handle.
//             The returned handle will be NULL on failure.
//
// How To:     When the user selects File/Update from the OLE Server App. the server's
//             GetData method will be invoked twice; first with cfFormat == cfNative,
//             then with cfFormat set to the appropriate format for displaying the
//             object.  Then, once Notes sees that the server is registrered to
//             recognize the RequestDataFormats message, the GetData method will be
//             invoked a third time with cfFormat == NoteshNote.  In response, the
//             app should call this function.
//
HANDLE OFC_CALLTYPE MsoHUpdatePropertiesInNotes(HANDLE hNote);

// Function:   MsoNotesTerm
//
// Purpose:    To terminate the Notes session
//
// Parameters: None.
//
// Returns:    Nuthin'.
//
// Note:       This function should be called whenever a object
//             generated (as requested by Notes) is closed.
//
VOID OFC_CALLTYPE MsoNotesTerm();
#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus



#pragma pack( pop )

#endif // __offcapi_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\offglue.h ===
#ifndef _OFFGLUE_H_
#define _OFFGLUE_H_
#define fTrue   TRUE
#define fFalse FALSE
#define MsoImageList_Create ImageList_Create
#define MsoImageList_Destroy ImageList_Destroy
#define MsoImageList_ReplaceIcon ImageList_ReplaceIcon
#define InvalidateVBAObjects(x,y,z)

typedef struct _num
{
    CHAR    rgb[8];
} NUM;

typedef struct _ulargeint
   {
      union
      {
         struct
         {
            DWORD dw;
            DWORD dwh;
         };
         struct
         {
            WORD w0;
            WORD w1;
            WORD w2;
            WORD w3;

         };
      };
   } ULInt;


// Macro to release a COM interface
#define RELEASEINTERFACE( punk )            \
        if( punk != NULL )                  \
        {                                   \
            (punk)->lpVtbl->Release(punk);  \
            punk = NULL;                    \
        }

// Determine the elements in a fixed-sized vector
#define NUM_ELEMENTS( vector ) ( sizeof(vector) / sizeof( (vector)[0] ) )


#ifdef __cplusplus
extern TEXT("C") {
#endif // __cplusplus
//Wrapper functions to the client supplied mem alloc and free
int CchGetString();

// Function to convert a ULInt to an sz without leading zero's
// Returns cch -- not including zero-terminator
WORD CchULIntToSz(ULInt, TCHAR *, WORD );

// Function to scan memory for a given value
BOOL FScanMem(LPBYTE pb, byte bVal, DWORD cb);

BOOL FFreeAndCloseisdbhead();
//Displays an alert using the give ids
int IdDoAlert(HWND, int ids, int mb);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif // _OFFGLUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\priv.h ===
#define STRICT
#define CONST_VTABLE

#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>       // commdlg IDs
#include <shellapi.h>
#include <commctrl.h>
#include <windowsx.h>
#include <shlobj.h>
#include <malloc.h>

#undef Assert
#include "debug.h"
#include "resource.h"

#include "offglue.h"
#include "plex.h"
#include "extdef.h"
#include "offcapi.h"
#include "proptype.h"
#include "debug.h"
#include "internal.h"
#include "strings.h"
#include "propvar.h"
#include <shfusion.h>
#include <winnls.h>
#include <prsht.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shlapip.h>
#include <strsafe.h>


STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

extern HANDLE g_hmodThisDll;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\offglue.c ===
#include "priv.h"
#pragma hdrstop

#include "limits.h"

/*********** STRINGS - Should _not_ be localized */
#define SZOFCROOT       TEXT("Software\\Microsoft\\Microsoft Office\\95\\")
#define SZOFCSHAREDROOT TEXT("Software\\Microsoft\\Shared Tools\\")
const TCHAR vcszCreateShortcuts[] = SZOFCROOT TEXT("Shell Folders");
const TCHAR vcszKeyAnthem[] = SZOFCROOT TEXT("Anthem");
const TCHAR vcszKeyFileNewNFT[] = SZOFCROOT TEXT("FileNew\\NFT");
const TCHAR vcszKeyFileNewLocal[] = SZOFCROOT TEXT("FileNew\\LocalTemplates");
const TCHAR vcszKeyFileNewShared[] = SZOFCROOT TEXT("FileNew\\SharedTemplates");
const TCHAR vcszKeyFileNew[] = SZOFCROOT TEXT("FileNew");
const TCHAR vcszFullKeyFileNew[] = TEXT("HKEY_CURRENT_USER\\") SZOFCROOT TEXT("FileNew");
const TCHAR vcszKeyIS[] = SZOFCROOT TEXT("IntelliSearch");
const TCHAR vcszSubKeyISToWHelp[] = TEXT("towinhelp");
const TCHAR vcszSubKeyAutoInitial[] = TEXT("CorrectTwoInitialCapitals");
const TCHAR vcszSubKeyAutoCapital[] = TEXT("CapitalizeNamesOfDays");
const TCHAR vcszSubKeyReplace[] = TEXT("ReplaceText");
const TCHAR vcszIntlPrefix[] = TEXT("MSO5");
const TCHAR vcszDllPostfix[] = TEXT(".DLL");
const TCHAR vcszName[] = TEXT("Name");
const TCHAR vcszType[] = TEXT("Type");
const TCHAR vcszApp[] =  TEXT("Application");
const TCHAR vcszCmd[] =  TEXT("Command");
const TCHAR vcszTopic[] = TEXT("Topic");
const TCHAR vcszDde[] =  TEXT("DDEExec");
const TCHAR vcszRc[] =   TEXT("ReturnCode");
const TCHAR vcszPos[] =  TEXT("Position");
const TCHAR vcszPrevue[] = TEXT("Preview");
const TCHAR vcszFlags[] = TEXT("Flags");
const TCHAR vcszNFT[] = TEXT("NFT");
const TCHAR vcszMicrosoft[] = TEXT("Microsoft");
const TCHAR vcszElipsis[] = TEXT(" ...");
const TCHAR vcszLocalPath[] = TEXT("C:\\Microsoft Office\\Templates");
const TCHAR vcszAllFiles[] = TEXT("*.*\0\0");
const TCHAR vcszSpace[] = TEXT("  ");
const TCHAR vcszMSNInstalled[] = TEXT("SOFTWARE\\Microsoft\\MOS\\SoftwareInstalled");
const TCHAR vcszMSNDir[] = SZOFCROOT TEXT("Microsoft Network");
const TCHAR vcszMSNLocDir[] = TEXT("Local Directory");
const TCHAR vcszMSNNetDir[] = TEXT("Network Directory");
const TCHAR vcszMSNFiles[] = TEXT("*.mcc\0\0");
const TCHAR vcszShellFolders[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const TCHAR vcszUserShellFolders[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR vcszDefaultShellFolders[] = TEXT(".Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const TCHAR vcszDefaultUserShellFolders[] = TEXT(".Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR vcszMyDocs[] = TEXT("Personal");
const TCHAR vcszNoTracking[] = SZOFCROOT TEXT("Options\\NoTracking");
const TCHAR vcszOldDocs[] = SZOFCROOT TEXT("Old Doc");
#ifdef WAIT3340
const TCHAR vcszMSHelp[]= TEXT("SOFTWARE\\Microsoft\\Windows\\Help");
#endif

BOOL fChicago = TRUE;                 // Are we running on Chicago or what!!

/*--------------------------------------------------------------------
 *  offglue.c
    Util routines taken from office.c
--------------------------------------------------------------------*/

//
// FUNCTION: FScanMem
//
// Purpose: To scan memory for a given value.
//
// Parameters: pb - pointer to memory
//                  bVal - value to scan for
//                  cb - cb pointed to by pb
//
// Returns: TRUE iff all the memory has the value cbVal.
//              FALSE otherwise.
//
BOOL FScanMem(LPBYTE pb, byte bVal, DWORD cb)
{
    DWORD i;
    for (i = 0; i < cb; ++i)
        {
          if (*pb++ != bVal)
              return FALSE;
        }
    return TRUE;
}


int CchGetString(ids,rgch,cchMax)
int ids;
TCHAR rgch[];
int cchMax;
{
    return(LoadString(g_hmodThisDll, ids, rgch, cchMax));
}

#define SZRES_BUFMAX 100

int ScanDateNums(TCHAR *pch, TCHAR *pszSep, unsigned int aiNum[], int cNum, int iYear)
{
    int i = 0;
    TCHAR    *pSep;

    if (cNum < 1)
        return 1;

    do
    {
        aiNum[i] = wcstol(pch, &pch, 10);
        if ( 0 == aiNum[i] )
        {
            if( i != iYear )
            {
                return 0;
            }
        }

        i ++;

        if (i < cNum)
        {
            while (isspace(*pch))
            {
                pch++;
            }

            /* check the separator */
            pSep = pszSep;
            while (*pSep && (*pSep == *pch))
            {
                pSep++, pch++;
            }

            if (*pSep && (*pSep != *pch))
                return 0;
        }

    } while (*pch && (i < cNum));

    return 1;
}


//
// Displays the actual alert
//
static int DoMessageBox(HWND hwnd, TCHAR *pszText, TCHAR *pszTitle, UINT fuStyle)
{
   int res;
   res = MessageBox((hwnd == NULL) ? GetFocus() : hwnd, pszText, pszTitle, fuStyle);
   return(res);
}
//--------------------------------------------------------------------------
// Displays the give ids as an alert
//--------------------------------------------------------------------------
int IdDoAlert(HWND hwnd, int ids, int mb)
{
        TCHAR rgch[258];
        TCHAR rgchM[258];

        CchGetString(ids, rgch, 258);
        CchGetString(idsMsftOffice, rgchM, 258);
   return(DoMessageBox (hwnd, rgch, rgchM, mb));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\plex.c ===
/*---------------------------------------------------------------------------
FILE : PLEX.C
AUTHOR: STOLEN FROM EXCEL modified by NavPal
 This file contains routines used to manipulate the PL (pronounced:
 "plex") structures.
----------------------------------------------------------------------------*/
#include "priv.h"
#pragma hdrstop

/*-----------------------------------------------------------------------
|	FInRange
|		Simple little routine that tells you if a number lies within a
|		range.
|	
|	
|	Arguments:
|		w:			Number to check
|		wFirst:	First number in the range	
|		wLast:	Last number in the range
|		
|	Returns:
|		fTrue if the number is in range
|		
|	Keywords: in range check
-----------------------------------------------------------------------*/
BOOL FInRange(w, wFirst, wLast)
int w;
int wFirst, wLast;
{
	Assert(wLast >= wFirst);
	return(w >= wFirst && w <= wLast);
}

#ifdef DEBUG
/*----------------------------------------------------------------------------
|	FValidPl
|
|	Checks for a valid PL structure.
|
|	Arguments:
|		ppl		PL to check
|
|	Returns:
|		fTrue if the PL looks reasonable.
----------------------------------------------------------------------------*/
BOOL FValidPl(pvPl)
VOID *pvPl;
{
    PL * ppl;

    ppl = (PL *) pvPl;

	if (ppl== NULL ||
			ppl->cbItem == 0 ||
			ppl->iMac < 0 ||
			ppl->iMax < 0 ||
			ppl->iMax < ppl->iMac)
    {
		return(fFalse);
    }

	return(fTrue);
}
#endif //DEBUG

/*----------------------------------------------------------------------------
|	CbPlAlloc
|
|	Returns amount of memory allocated to the given PL
|
|	Arguments:
|		ppl		PL to return info for.
|
|	Returns:
|		memory allocated to the PL
----------------------------------------------------------------------------*/
int CbPlAlloc(pvPl)
VOID *pvPl;
{
    PL * ppl;
    ppl = (PL *) pvPl;

	if (ppl == NULL)
		return(0);

	Assert(FValidPl(ppl));

	return(WAlign(cbPL + (ppl->iMax * ppl->cbItem)));
}
/*----------------------------------------------------------------------------
|	FreePpl
|
|	Frees a PL.
|
|	Arguments:
|		ppl		PL to free
|
|	Returns:
|		Nothing.
----------------------------------------------------------------------------*/
void FreePpl(pvPl)
VOID *pvPl;
{

    Assert(FValidPl(pvPl));

    LocalFree(pvPl);
}
/*----------------------------------------------------------------------------
|	PplAlloc
|
|	Allocates and initializes a PL.
|
|	Arguments:
|		cbItem		sizeof structure in the PL
|		dAlloc		number of items to allocate at a time
|		iMax		number of items in initial allocation
|
|	Returns:
|		Pointer to PL.
|
|	Notes:
|		returns NULL if OOM
----------------------------------------------------------------------------*/
VOID *PplAlloc(cbItem, dAlloc, iMax)
unsigned cbItem;
int dAlloc;
unsigned iMax;
{
	PL *ppl;
	long cb;

	if (iMax > 32767) /* not too likely, but what the heck. */
		return(NULL);

	Assert((cbItem>=1 && cbItem<=65535u) && FInRange(dAlloc, 1, 31));

	cb = WAlign((long) cbPL + (long) cbItem * (long) iMax);

	ppl = (PL *) LocalAlloc( LPTR, cb );
	if(ppl==NULL)
		return(NULL);

	ppl->cbItem = cbItem;
	ppl->dAlloc = dAlloc;
	ppl->iMax = iMax;
	ppl->fUseCount = fFalse;

    Assert(FValidPl(ppl));

    return(ppl);
}
/*----------------------------------------------------------------------------
|	IAddPl
|
|	Adds an item to a PL.
|
|	Arguments:
|		pppl		Pointer to PL.  May change if reallocated.
|		pv		New item to add.
|
|	Returns:
|		Index of new item.
|
|	Notes:
|		returns -1 if OOM
----------------------------------------------------------------------------*/
int IAddPl(ppvPl, pv)
VOID  **ppvPl;
VOID  *pv;
{
	int cbItem;
	int iMac;
	PL *ppl, *pplNew;

	ppl = *ppvPl;

    Assert(FValidPl(ppl));

    cbItem = ppl->cbItem;
	iMac = ppl->iMac;

	if (iMac == ppl->iMax)
	{
		pplNew = PplAlloc(cbItem, ppl->dAlloc, iMac + ppl->dAlloc);
		if(pplNew==NULL)
			return(-1);

		pplNew->fUseCount = ppl->fUseCount;
		CopyMemory( pplNew->rg, ppl->rg, iMac * cbItem); 
	     /* pplNew->iMac = iMac;  /* This is not needed because hppl->iMac will be over-written later */
		FreePpl(ppl);
		*ppvPl = ppl = pplNew;
	}

	CopyMemory( &ppl->rg[iMac * cbItem], pv, cbItem );
	ppl->iMac = iMac + 1;

	Assert(FValidPl(*ppvPl));

    return(iMac);
}
/*----------------------------------------------------------------------------
|	RemovePl
|
|	Removes an item from a PL.
|
|	Arguments:
|		ppl		PL to remove item from
|		i		index of item to remove
|
|	Returns:
|		fTrue if an item was removed (only fFalse for use count plexes).
----------------------------------------------------------------------------*/
BOOL RemovePl(pvPl, i)
VOID *pvPl;
int i;
{
	int iMac;
	int cbItem;
	BYTE *p;
    PL * ppl;

    ppl = (PL *) pvPl;

	Assert(FValidPl(ppl) && i < ppl->iMac);

    iMac = ppl->iMac;
	cbItem = ppl->cbItem;
	p = &ppl->rg[i * cbItem];
	if (i != iMac - 1)
	{
		CopyMemory( p, p+cbItem, (iMac - i - 1) * cbItem );
	}
	ppl->iMac = iMac - 1;

    Assert(FValidPl(ppl));

    return fTrue;
}
/*----------------------------------------------------------------------------
|	ILookupPl
|
|	Searches a PL for an item.
|
|	Arguments:
|		ppl		PL to lookup into
|		p		item to lookup
|		pfnSgn		Comparison function
|
|	Returns:
|		index of item, if found.
|		-1 if not found.
----------------------------------------------------------------------------*/
int ILookupPl(pvPl, pvItem, pfnSgn)
VOID *pvPl;
VOID *pvItem;
int (*pfnSgn)();
{
	int i;
	BYTE *p;
    PL * ppl;

    ppl = (PL *) pvPl;

	if (ppl == NULL)
		return(-1);

	Assert(FValidPl(ppl));

	for (i = 0, p = ppl->rg; i < ppl->iMac; i++, p += ppl->cbItem)
	{
	    if ((*(int (*)(void *, void *))pfnSgn)(p, pvItem) == sgnEQ)
        {
		    return(i);
        }
	}

	return(-1);
}

/*----------------------------------------------------------------------------
|	PLookupPl
|
|	Searches a PL for an item
|
|	Arguments:
|		ppl		PL to search
|		pItem		item to search for
|		pfnSgn		comparison function
|
|	Returns:
|		Pointer to item, if found
|		Null, if not found
----------------------------------------------------------------------------*/
VOID *PLookupPl(pvPl, pvItem, pfnSgn)
VOID *pvPl;
VOID *pvItem;
int (*pfnSgn)();
{
	int i;

	if ((i = ILookupPl(pvPl, pvItem, pfnSgn)) == -1)
		return(NULL);

	return(&((PL *)pvPl)->rg[i * ((PL *)pvPl)->cbItem]);
}

/*----------------------------------------------------------------------------
|	FLookupSortedPl
|
|	Searches a sorted PL for an item.
|
|	Arguments:
|		hppl		PL to lookup into
|		hpItem		Item to lookup
|		pi			Index of found item (or insertion location if not)
|		pfnSgn		Comparison function
|
|	Returns:
|		index of item, if found.
|		index of location to insert if not found.
----------------------------------------------------------------------------*/
int FLookupSortedPl(hpvPl, hpvItem, pi, pfnSgn)
VOID *hpvPl;
VOID *hpvItem;
int *pi;
int (*pfnSgn)();
{
	int sgn;
	unsigned iMin, iMid, iMac;
	int cbItem;
	BYTE *hprg;
	BYTE *hpMid;
    PL * hppl;

    hppl = (PL *) hpvPl;

	if ((hppl)==NULL)
	{
		*pi = 0;
		return(fFalse);
	}

	Assert(FValidPl(hppl));
	Assert(!hppl->fUseCount);

	sgn = 1;
	cbItem = hppl->cbItem;
	iMin = iMid = 0;
	iMac = hppl->iMac;
	hprg = hppl->rg;
	while (iMin != iMac)
		{
		iMid = iMin + (iMac-iMin)/2;
		Assert(iMid != iMac);

		hpMid = hprg + iMid*cbItem;
		if ((sgn = (*(int (*)(void *, void *))pfnSgn)(hpMid, hpvItem)) == 0)
			break;

		/* Too low, look in upper interval */
		if (sgn < 0)
			iMin = ++iMid;
		/* Too high, look in lower interval */
		else
			iMac = iMid;
		}

	/* Not found, return index of location to insert it */
	*pi = iMid;
	return(sgn == 0);
}

/*----------------------------------------------------------------------------
|	IAddNewPl
|
|	Adds an item to a PL, creating the PL if it's initially NULL.
|
|	Arguments:
|		phppl		pointer to PL
|		hp		pointer to item to add
|		cbItem		size of item
|
|	Returns:
|		the index of item added, if successful
|		-1, if out-of-memory
----------------------------------------------------------------------------*/
int IAddNewPl(phpvPl, hpv, cbItem)
VOID **phpvPl;
VOID *hpv;
int cbItem;
{
	int i;
    PL ** phppl;

    phppl = (PL **) phpvPl;

	Assert(((*phppl)==NULL) || !(*phppl)->fUseCount);

	i = -1;

	if ((*phppl)==NULL)
	{
		*phppl = PplAlloc(cbItem, 5, 5);
	}

	if((*phppl)!=NULL)
	{
		Assert((*phppl)->cbItem == cbItem);
		i = IAddPl((VOID **)phppl, hpv);
	}

	return(i);
}

/*----------------------------------------------------------------------------
|	IAddNewPlPos
|
|	Inserts an item into a plex at a specific position.
|
|	Arguments:
|		the index of the item added, if successful
|		-1 if out-of-memory
----------------------------------------------------------------------------*/
int IAddNewPlPos(phpvPl, hpv, cbItem, i)
VOID **phpvPl;
VOID *hpv;
int cbItem;
int i;
{
	BYTE *hpT;
    PL ** phppl;

    phppl = (PL **) phpvPl;

	Assert(((*phppl)==NULL) || !(*phppl)->fUseCount);

	if (IAddNewPl((VOID **)phppl, hpv, cbItem) == -1)
		return(-1);

	Assert(i < (*phppl)->iMac);

	hpT = &(*phppl)->rg[i * cbItem];
//	bltbh(hpT, hpT + cbItem, ((*phppl)->iMac - i - 1) * cbItem);
//	bltbh(hpv, hpT, cbItem);
	CopyMemory( hpT + cbItem, hpT, ((*phppl)->iMac - i - 1) * cbItem );
	CopyMemory( hpT, hpv, cbItem );

    Assert(FValidPl(*phppl));

    return(i);
}

int IAddPlSort(phpvPl, hpv, pfnSgn)
VOID **phpvPl;
VOID *hpv;
int (*pfnSgn)();
{
	int i;

#ifdef DEBUG
	int iOld;
#endif

	Assert((*phpvPl)!=NULL);

	if (FLookupSortedPl(*phpvPl, hpv, &i, pfnSgn))
		return(-1);

#ifdef DEBUG
	iOld = i;
#endif

	i = IAddNewPlPos(phpvPl, hpv, (*(PL **)phpvPl)->cbItem, i);

#ifdef DEBUG
	Assert(i == -1 || i == iOld);
#endif

	return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\plex.h ===
/*
 *      plex.h
 *
 *      Structures and definitions for using plexs.
 */

#ifndef __plex__
#define __plex__

#define WAlign(w) (((w)+1)&~1)
/*      comparison return values
 */
#define sgnGT   1
#define sgnEQ   0
#define sgnLT   (-1)
#define sgnNE  2

/*----------------------------------------------------------------------------
|       PL structure
|
|       The PL (pronounced "plex") structure is used to efficiently
|       manipulate variable sized arrays.
|
|       Fields:
|               iMax            number of allocated items
|               fUseCount use count plex (not all plex API's work w/ UseCount plexes)
|               iMac            last used allocated item
|               cbItem          sizeof item
|               dAlloc          number of items to allocate at a time
|               dgShift         data group to the plex should be
|                               allocated in
|               rg              the array of items
|
| WARNING: this structure also in winpm\excel.inc & mac\excel.i
|
----------------------------------------------------------------------------*/
typedef struct _pl
                {
                WORD    iMax : 15,
                                fUseCount : 1;
                SHORT   iMac;
                WORD    cbItem;
                WORD    dAlloc:5,
                                unused:11;
                BYTE    rg[1];
                }
        PL;

/*----------------------------------------------------------------------------
|       DEFPL macro
|
|       Used to define a specific plex.
|
|       Arguments:
|               PLTYP           name of the plex type
|               TYP             type of item stored in the plex
|               iMax            name to use for the iMax field
|               iMac            name to use for the iMac field
|               rg              name to use for the rg field
----------------------------------------------------------------------------*/
#define DEFPL(PLTYP,TYP,iMax,iMac,rg) \
        typedef struct PLTYP\
                { \
                WORD iMax : 15, \
                        fUseCount : 1; \
                SHORT iMac; \
                WORD cbItem; \
                WORD dAlloc:5, \
                        unused:11; \
                TYP rg[1]; \
                } \
            PLTYP;


/*----------------------------------------------------------------------------
|       DEFPL2 macro
|
|       Used to define a specific plex.
|
|       Arguments:
|               PLST            name of the plex struct
|               PLTYP           name of the plex type
|               TYP             type of item stored in the plex
|               iMax            name to use for the iMax field
|               iMac            name to use for the iMac field
|               rg              name to use for the rg field
----------------------------------------------------------------------------*/
#define DEFPL2(PLST,PLTYP,TYP,iMax,iMac,rg) \
        typedef struct PLST\
                { \
                WORD iMax : 15, \
                        fUseCount : 1; \
                SHORT iMac; \
                WORD cbItem; \
                WORD dAlloc:5, \
                        dgShift:3, \
                        unused:8; \
                TYP rg[1]; \
                } \
            PLTYP;


// a FORPLEX was expanded by hand in bar.c:FHptbFromBarId for speed --
// if you change this then you may need to change that
#define FORPLEX(hp, hpMac, hppl) \
                        for ((hpMac) = ((hp) = (VOID HUGE *)((PL HUGE *)(hppl))->rg) + \
                                                 ((PL HUGE *)(hppl))->iMac; \
                                 LOWORD(hp) < LOWORD(hpMac); (hp)++)

#define cbPL ((int)&((PL *)0)->rg)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

VOID *PplAlloc(unsigned, int, unsigned);
int IAddPl(VOID **, VOID *);
VOID FreePpl(VOID *);
BOOL RemovePl(VOID *, int);
int IAddPlSort(VOID **, VOID *, int (*pfnSgn)());
BOOL FLookupSortedPl(VOID *, VOID *, int *, int (*pfnSgn)());
int ILookupPl(VOID *, VOID *, int (*pfnSgn)());
VOID *PLookupPl(VOID *, VOID *, int (*pfnSgn)());
int CbPlAlloc(VOID *);
int IAddNewPlPos(VOID **, VOID *, int, int);

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif /* __plex__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\propdlg.c ===
////////////////////////////////////////////////////////////////////////////////
//
// propdlg.c
//
// The Properties dialog for MS Office.
//
// Change history:
//
// Date         Who             What
// --------------------------------------------------------------------------
// 06/09/94     B. Wentz        Created file
// 01/16/95     martinth        Finished sticky dlg stuff.
//                              We have to call ApplyStickyDlgCoor
//                              in the first WM_INITDIALOG, don't ask me why,
//                              but otherwise we have redraw problems.  Likewise,
//                              we have to call SetStickyDlgCoor in the first
//                              PSN_RESET/PSN_APPLY, I have no idea why, since
//                              the main dialog shouldn't have been deleted but
//                              it is.  Thus we have to add calls everywhere.
//                              Could it be that the tabs are getting deleted
//                              one by one and the dialog changes size?  Dunno.
//                              But this works, so change at your own risk!;-)
// 07/08/96     MikeHill        Ignore unsupported (non-UDTYPE) properties.
////////////////////////////////////////////////////////////////////////////////

#include "priv.h"
#pragma hdrstop

int ScanDateNums(TCHAR *pch, TCHAR *pszSep, unsigned int aiNum[], int cNum, int iYear);
BOOL PASCAL FConvertDate(LPTSTR lpstz, DWORD cchMax, LPFILETIME lpft);

#include "propdlg.h"
#include "strings.h"
#include "msohelp.h"

// Max size of time/date string
#define TIMEDATEMAX     256

// Check button actions
#define CLEAR   0
#define CHECKED 1
#define GREYED  2

// Number of property sheet pages
#define PAGESMAX        5


// Max size for "short" temp buffers
#define SHORTBUFMAX     128

// The pages
#define itabCUSTOM          0
#define itabFIRST           itabCUSTOM

// Defines for printing file sizes
#define DELIMITER   TEXT(',')

#define iszBYTES               0
#define iszORDERKB             1
#define iszORDERMB             2
#define iszORDERGB             3
#define iszORDERTB             4

static TCHAR rgszOrders[iszORDERTB+1][SHORTBUFMAX];
//  "bytes",        // iszBYTES
//  "KB",           // iszORDERKB
//  "MB",           // iszORDERMB
//  "GB",           // iszORDERGB
//  "TB"            // iszORDERTB

// note that szBYTES is defined above...
#define iszPAGES         1
#define iszPARA          2
#define iszLINES         3
#define iszWORDS         4
#define iszCHARS         5
#define iszSLIDES        6
#define iszNOTES         7
#define iszHIDDENSLIDES  8
#define iszMMCLIPS       9
#define iszFORMAT        10

// Strings for the statistics listbox
static TCHAR rgszStats[iszFORMAT+1][SHORTBUFMAX];
//  "Bytes:",             // iszBYTES
//  "Pages:",             // iszPAGES
//  "Paragraphs:",        // iszPARA
//  "Lines:",             // iszLINES
//  "Words:",             // iszWORDS
//  "Characters:",        // iszCHARS
//  "Slides:",            // iszSLIDES
//  "Notes:",             // iszNOTES
//  "Hidden Slides:",     // iszHIDDENSLIDES
//  "Multimedia Clips:",  // iszMMCLIPS
//  "Presentation Format:"// iszFORMAT

#define BASE10          10


// Number of pre-defined custom names
#define NUM_BUILTIN_CUSTOM_NAMES 27

#define iszTEXT         0
#define iszDATE         1
#define iszNUM          2
#define iszBOOL         3
#define iszUNKNOWN      4

// Strings for the types of user-defined properties
static TCHAR rgszTypes[iszUNKNOWN+1][SHORTBUFMAX];
//  "Text",               // iszTEXT
//  "Date",               // iszDATE
//  "Number",             // iszNUM
//  "Yes or No",          // iszBOOL
//  "Unknown"             // iszUNKNOWN

#define iszNAME         0
#define iszVAL          1
#define iszTYPE         2

// Strings for the column headings for the statistics tab
static TCHAR rgszStatHeadings[iszVAL+1][SHORTBUFMAX];
//  "Statistic Name",     // iszNAME
//  "Value"               // iszVAL

// Strings for the column headings for custom tab
static TCHAR rgszHeadings[iszTYPE+1][SHORTBUFMAX];
//  "Property Name",      // iszNAME
//  "Value",              // iszVAL
//  "Type"                // iszTYPE

#define iszTRUE  0
#define iszFALSE 1

// Strings for Booleans
static TCHAR rgszBOOL[iszFALSE+1][SHORTBUFMAX];
//  "Yes",       // iszTRUE
//  "No"         // iszFALSE

#define iszADD          0
#define iszMODIFY       1

// Strings for the Add button
static TCHAR rgszAdd[iszMODIFY+1][SHORTBUFMAX];
//  "Add",        // iszADD
//  "Modify"      // iszMODIFY

#define iszVALUE     0
#define iszSOURCE    1

// Strings for the source/value caption
static TCHAR rgszValue[iszSOURCE+1][SHORTBUFMAX];
//  "Value:",     // iszVALUE
//  "Source:"     // iszSOURCE

// Date formatting codes
#define MMDDYY  TEXT('0')
#define DDMMYY  TEXT('1')
#define YYMMDD  TEXT('2')
#define OLEEPOCH 1900
#define SYSEPOCH 1601
#define ONECENTURY 100
#define YEARINCENTURY(year)     ((year) % ONECENTURY)
#define CENTURYFROMYEAR(year)   ((year) - YEARINCENTURY(year))

//
// Global data, to be deleted when FShowOfficePropDlg exits
//
static LPTSTR glpstzName;
static LPTSTR glpstzValue;
static int giLinkIcon;
static int giInvLinkIcon;
static int giBlankIcon;
static HBRUSH hBrushPropDlg = NULL;

const TCHAR g_szHelpFile[] = TEXT("windows.hlp");

//
// Internal prototypes
//
INT_PTR CALLBACK FGeneralDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FSummaryDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FStatisticsDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FCustomDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FContentsDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FPropHeaderDlgProc (HWND hwnd, UINT message, LONG lParam);
//static int  CALLBACK ListViewCompareFunc(LPARAM, LPARAM, LPARAM);

void PASCAL SetEditValLpsz (LPPROPVARIANT lppropvar, HWND hdlg, DWORD dwID );
BOOL PASCAL GetEditValLpsz (LPPROPVARIANT lppropvar, HWND hDlg, DWORD dwId);
BOOL PASCAL FAllocAndGetValLpstz (HWND hDlg, DWORD dwId, LPTSTR *lplpstz);
BOOL PASCAL FAllocString (LPTSTR *lplpstz, DWORD cb);
void PASCAL ClearEditControl (HWND hDlg, DWORD dwId);

UDTYPES PASCAL UdtypesGetNumberType (LPTSTR lpstz, NUM *lpnumval,
                                     BOOL (*lpfnFSzToNum)(NUM *, LPTSTR));

void PASCAL PrintTimeInDlg (HWND hDlg, DWORD dwId, FILETIME *pft);

void PASCAL PrintEditTimeInDlg (HWND hDlg, FILETIME *pft);

void PASCAL PopulateUDListView (HWND hWnd, LPUDOBJ lpUDObj);
void PASCAL AddUDPropToListView (LPUDOBJ lpUDObj, HWND hWnd, LPTSTR lpszName, LPPROPVARIANT lppropvar, int iItem,
                                 BOOL fLink, BOOL fLinkInvalid, BOOL fMakeVisible);
VOID PASCAL InitListView (HWND hDlg, int irgLast, TCHAR rgsz[][SHORTBUFMAX], BOOL fImageList);

WORD PASCAL WUdtypeToSz (LPPROPVARIANT lppropvar, LPTSTR sz, DWORD cchMax,
                         BOOL (*lpfnFNumToSz)(NUM *, LPTSTR, DWORD));
BOOL PASCAL FSwapControls (HWND hWndVal, HWND hWndLinkVal, HWND hWndBoolTrue, HWND hWndBoolFalse, HWND hWndGroup, HWND hWndType, HWND hWndValText, BOOL fLink, BOOL fBool);
VOID PASCAL PopulateControls (LPUDOBJ lpUDObj, LPTSTR szName, DWORD cLinks, DWQUERYLD lpfnDwQueryLinkData, HWND hDlg,
                              HWND hWndName, HWND hWndVal, HWND hWndValText, HWND hWndLink, HWND hWndLinkVal, HWND hWndType,
                              HWND hWndBoolTrue, HWND hWndBoolFalse, HWND hWndGroup, HWND hWndAdd, HWND hWndDelete, BOOL *pfLink, BOOL *pfAdd);
BOOL PASCAL FSetupAddButton (DWORD iszType, BOOL fLink, BOOL *pfAdd, HWND hWndAdd, HWND hWndVal, HWND hWndName, HWND hDlg);
BOOL PASCAL FCreateListOfLinks (DWORD cLinks, DWQUERYLD lpfnDwQueryLinkData, HWND hWndLinkVal);
BOOL PASCAL FSetTypeControl (UDTYPES udtype, HWND hWndType);
void PASCAL DeleteItem (LPUDOBJ lpUDObj, HWND hWndLV, int iItem, TCHAR sz[]);
void PASCAL ResetTypeControl (HWND hDlg, DWORD dwId, DWORD *piszType);
BOOL PASCAL FDisplayConversionWarning (HWND hDlg);
BOOL PASCAL FLoadTextStrings (void);
BOOL FGetCustomPropFromDlg(LPALLOBJS lpallobjs, HWND hDlg);
VOID SetCustomDlgDefButton(HWND hDlg, int IDNew);
INT PASCAL ISavePropDlgChanges(LPALLOBJS, HWND, HWND);

/* WinHelp stuff. */
static const DWORD rgIdhGeneral[] =
{
    IDD_ITEMICON,     IDH_GENERAL_ICON,
        IDD_NAME,         IDH_GENERAL_NAME_BY_ICON,
        IDD_FILETYPE,     IDH_GENERAL_FILETYPE,
        IDD_FILETYPE_LABEL,     IDH_GENERAL_FILETYPE,
        IDD_LOCATION,     IDH_GENERAL_LOCATION,
        IDD_LOCATION_LABEL,     IDH_GENERAL_LOCATION,
        IDD_FILESIZE,     IDH_GENERAL_FILESIZE,
        IDD_FILESIZE_LABEL,     IDH_GENERAL_FILESIZE,
        IDD_FILENAME,     IDH_GENERAL_MSDOSNAME,
        IDD_FILENAME_LABEL,     IDH_GENERAL_MSDOSNAME,
        IDD_CREATED,      IDH_GENERAL_CREATED,
        IDD_CREATED_LABEL,      IDH_GENERAL_CREATED,
        IDD_LASTMODIFIED, IDH_GENERAL_MODIFIED,
        IDD_LASTMODIFIED_LABEL, IDH_GENERAL_MODIFIED,
        IDD_LASTACCESSED, IDH_GENERAL_ACCESSED,
        IDD_LASTACCESSED_LABEL, IDH_GENERAL_ACCESSED,
        IDD_ATTRIBUTES_LABEL, IDH_GENERAL_ATTRIBUTES,
        IDD_READONLY,     IDH_GENERAL_READONLY,
        IDD_HIDDEN,       IDH_GENERAL_HIDDEN,
        IDD_ARCHIVE,      IDH_GENERAL_ARCHIVE,
        IDD_SYSTEM,       IDH_GENERAL_SYSTEM
};

static const DWORD rgIdhSummary[] =
{
    IDD_SUMMARY_TITLE,    IDH_SUMMARY_TITLE,
        IDD_SUMMARY_TITLE_LABEL,    IDH_SUMMARY_TITLE,
        IDD_SUMMARY_SUBJECT,  IDH_SUMMARY_SUBJECT,
        IDD_SUMMARY_SUBJECT_LABEL,  IDH_SUMMARY_SUBJECT,
        IDD_SUMMARY_AUTHOR,   IDH_SUMMARY_AUTHOR,
        IDD_SUMMARY_AUTHOR_LABEL,   IDH_SUMMARY_AUTHOR,
        IDD_SUMMARY_MANAGER,  IDH_SUMMARY_MANAGER,
        IDD_SUMMARY_MANAGER_LABEL,  IDH_SUMMARY_MANAGER,
        IDD_SUMMARY_COMPANY,  IDH_SUMMARY_COMPANY,
        IDD_SUMMARY_COMPANY_LABEL,  IDH_SUMMARY_COMPANY,
        IDD_SUMMARY_CATEGORY, IDH_SUMMARY_CATEGORY,
        IDD_SUMMARY_CATEGORY_LABEL, IDH_SUMMARY_CATEGORY,
        IDD_SUMMARY_KEYWORDS, IDH_SUMMARY_KEYWORDS,
        IDD_SUMMARY_KEYWORDS_LABEL, IDH_SUMMARY_KEYWORDS,
        IDD_SUMMARY_COMMENTS, IDH_SUMMARY_COMMENTS,
        IDD_SUMMARY_COMMENTS_LABEL, IDH_SUMMARY_COMMENTS,
        IDD_SUMMARY_TEMPLATE, IDH_SUMMARY_TEMPLATE,
        IDD_SUMMARY_TEMPLATETEXT, IDH_SUMMARY_TEMPLATE,
        IDD_SUMMARY_SAVEPREVIEW, IDH_SUMMARY_SAVEPREVIEW
};

static const DWORD rgIdhStatistics[] =
{
    IDD_STATISTICS_CREATED,    IDH_STATISTICS_CREATED,
        IDD_STATISTICS_CREATED_LABEL,    IDH_STATISTICS_CREATED,
        IDD_STATISTICS_CHANGED,    IDH_STATISTICS_MODIFIED,
        IDD_STATISTICS_CHANGED_LABEL,    IDH_STATISTICS_MODIFIED,
        IDD_STATISTICS_ACCESSED,   IDH_STATISTICS_ACCESSED,
        IDD_STATISTICS_ACCESSED_LABEL,   IDH_STATISTICS_ACCESSED,
        IDD_STATISTICS_LASTPRINT,  IDH_STATISTICS_LASTPRINT,
        IDD_STATISTICS_LASTPRINT_LABEL,  IDH_STATISTICS_LASTPRINT,
        IDD_STATISTICS_LASTSAVEBY, IDH_STATISTICS_LASTSAVEBY,
        IDD_STATISTICS_LASTSAVEBY_LABEL, IDH_STATISTICS_LASTSAVEBY,
        IDD_STATISTICS_REVISION,   IDH_STATISTICS_REVISION,
        IDD_STATISTICS_REVISION_LABEL,   IDH_STATISTICS_REVISION,
        IDD_STATISTICS_TOTALEDIT,  IDH_STATISTICS_TOTALEDIT,
        IDD_STATISTICS_TOTALEDIT_LABEL,  IDH_STATISTICS_TOTALEDIT,
        IDD_STATISTICS_LVLABEL,   IDH_STATISTICS_LISTVIEW,
        IDD_STATISTICS_LISTVIEW,   IDH_STATISTICS_LISTVIEW
};

static const DWORD rgIdhContents[] =
{
    IDD_CONTENTS_LISTBOX_LABEL, IDH_CONTENTS_LISTBOX,
        IDD_CONTENTS_LISTBOX, IDH_CONTENTS_LISTBOX
};

static const DWORD rgIdhCustom[] =
{
    IDD_CUSTOM_NAME,      IDH_CUSTOM_NAME,
        IDD_CUSTOM_NAME_LABEL,      IDH_CUSTOM_NAME,
        IDD_CUSTOM_TYPE,      IDH_CUSTOM_TYPE,
        IDD_CUSTOM_TYPE_LABEL,      IDH_CUSTOM_TYPE,
        IDD_CUSTOM_VALUE,     IDH_CUSTOM_VALUE,
        IDD_CUSTOM_VALUETEXT,     IDH_CUSTOM_VALUE,
        IDD_CUSTOM_LINKVALUE, IDH_CUSTOM_LINKVALUE,
        IDD_CUSTOM_BOOLTRUE,  IDH_CUSTOM_BOOLYES,
        IDD_CUSTOM_BOOLFALSE, IDH_CUSTOM_BOOLYES,
        IDD_CUSTOM_ADD,       IDH_CUSTOM_ADDBUTTON,
        IDD_CUSTOM_DELETE,    IDH_CUSTOM_DELETEBUTTON,
        IDD_CUSTOM_LINK,      IDH_CUSTOM_LINKCHECK,
        IDD_CUSTOM_LISTVIEW,  IDH_CUSTOM_LISTVIEW,
        IDD_CUSTOM_LISTVIEW_LABEL,  IDH_CUSTOM_LISTVIEW
};

void FOfficeInitPropInfo(PROPSHEETPAGE * lpPsp, DWORD dwFlags, LPARAM lParam, LPFNPSPCALLBACK pfnCallback)
{
    lpPsp[itabCUSTOM-itabFIRST].dwSize = sizeof(PROPSHEETPAGE);
    lpPsp[itabCUSTOM-itabFIRST].dwFlags = dwFlags;
    lpPsp[itabCUSTOM-itabFIRST].hInstance = g_hmodThisDll;
    lpPsp[itabCUSTOM-itabFIRST].pszTemplate = MAKEINTRESOURCE (IDD_CUSTOM);
    lpPsp[itabCUSTOM-itabFIRST].pszIcon = NULL;
    lpPsp[itabCUSTOM-itabFIRST].pszTitle = NULL;
    lpPsp[itabCUSTOM-itabFIRST].pfnDlgProc = FCustomDlgProc;
    lpPsp[itabCUSTOM-itabFIRST].pfnCallback = pfnCallback;
    lpPsp[itabCUSTOM-itabFIRST].pcRefParent = NULL;
    lpPsp[itabCUSTOM-itabFIRST].lParam = lParam;
    
}

////////////////////////////////////////////////////////////////////////////////
//
// Attach
//
// Purpose:
//  Assigns HPROPSHEETPAGE to appropriate data block member.
//
////////////////////////////////////////////////////////////////////////////////
BOOL FAttach( LPALLOBJS lpallobjs, PROPSHEETPAGE* ppsp, HPROPSHEETPAGE hPage )
{
    #define ASSIGN_PAGE_HANDLE( pfn, phpage ) \
        if( ppsp->pfnDlgProc == pfn ) { *(phpage) = hPage ; return TRUE ; }

    ASSIGN_PAGE_HANDLE( FCustomDlgProc,     &lpallobjs->lpUDObj->m_hPage );

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// PropPageInit
//
// Purpose:
//  Keep track which pages have been init, such that we can know when we
//  can do the apply.
//
////////////////////////////////////////////////////////////////////////////////
void PropPageInit(LPALLOBJS lpallobjs, int iPage)
{
    if (iPage > lpallobjs->iMaxPageInit)
        lpallobjs->iMaxPageInit = iPage;
}

////////////////////////////////////////////////////////////////////////////////
//
// ApplyChangesBackToFile
//
// Purpose:
//     See if this is now the time to apply the changes back to the file
//
////////////////////////////////////////////////////////////////////////////////
BOOL ApplyChangesBackToFile(
    HWND hDlg, 
    BOOL bFinalEdit /* user clicked OK rather than Apply*/, 
    LPALLOBJS lpallobjs, 
    int iPage)
{
    HRESULT     hres;
    BOOL        fOK = FALSE;
    LPSTORAGE   lpStg;
    WCHAR       wszPath[ MAX_PATH ];
    
    if (iPage != lpallobjs->iMaxPageInit)
        return TRUE;    // no errors
    
    hres = StringCchCopy(wszPath, ARRAYSIZE(wszPath), lpallobjs->szPath);
    if (SUCCEEDED(hres))
    {
        hres = StgOpenStorageEx(wszPath,STGM_READWRITE|STGM_SHARE_EXCLUSIVE,STGFMT_ANY,0,NULL,NULL,
                                &IID_IStorage, (void**)&lpStg );
    }

    if (SUCCEEDED(hres) && lpStg)
    {
        fOK = (BOOL)DwOfficeSaveProperties( lpStg,
            lpallobjs->lpSIObj,
            lpallobjs->lpDSIObj,
            lpallobjs->lpUDObj,
            0,          // Flags
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE
            );
        
        // Release the Storage (we don't need to commit it;
        // it's in dicrect-mode).
        
        lpStg->lpVtbl->Release (lpStg);
        lpStg= NULL;
        
        
        //
        // if we did properly save out the properties, than we should
        // clear the we have changed things flag...
        //
        if (fOK)
        {
            lpallobjs->fPropDlgChanged = FALSE;
            lpallobjs->fPropDlgPrompted = FALSE;
        }
    }   // if (SUCCEEDED(hres) && lpStorage)
    
    if (!fOK)
    {
        UINT nMsgFlags = bFinalEdit ? MB_OKCANCEL /* give option to not dismiss page*/ : MB_OK;
        
        if (ShellMessageBox(g_hmodThisDll, GetParent(hDlg),
            MAKEINTRESOURCE(idsErrorOnSave), NULL,
            nMsgFlags | MB_ICONHAND, PathFindFileName(lpallobjs->szPath)) == IDOK)
        {
            fOK = TRUE;
        }
        PropSheet_UnChanged(GetParent(hDlg), hDlg);
    }
   
    return fOK;
}   // ApplyChangesBackToFile

int  gOKButtonID;  // need this to store the ID of the OK button, since it's not in the dlg template

////////////////////////////////////////////////////////////////////////////////
//
// FCustomDlgProc
//
// Purpose:
//  Custom tab control
//
////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK FCustomDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPALLOBJS lpallobjs = (LPALLOBJS)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (message)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE *ppspDlg = (PROPSHEETPAGE *) lParam;
            int irg;
            HICON hIcon, hInvIcon;
            
            lpallobjs = (LPALLOBJS)ppspDlg->lParam;
            
            PropPageInit(lpallobjs, itabCUSTOM);
            
            SetWindowLongPtr(hDlg, DWLP_USER, ppspDlg->lParam);
            gOKButtonID = LOWORD(SendMessage(hDlg, DM_GETDEFID, 0L, 0L));
            
            AssertSz ((sizeof(NUM) == (sizeof(FILETIME))), TEXT("Ok, who changed base type sizes?"));
            
            //
            // Fill out the Name dropdown
            //
            for (irg = 0; irg < NUM_BUILTIN_CUSTOM_NAMES; ++irg)
            {
                if (CchGetString( idsCustomName1+ irg,
                    lpallobjs->CDP_sz,
                    sizeof(lpallobjs->CDP_sz))
                    )
                {
                    SendDlgItemMessage(hDlg, IDD_CUSTOM_NAME, CB_ADDSTRING, 0, (LPARAM)lpallobjs->CDP_sz);
                }
                // else, just don't add it
            }
            
            //
            // Fill out the type drop-down & select the text type
            //
            for (irg = 0; irg <= iszBOOL; irg++)
            {
                SendDlgItemMessage(hDlg, IDD_CUSTOM_TYPE, CB_ADDSTRING, 0, (LPARAM) rgszTypes[irg]);
            }
            
            ResetTypeControl (hDlg, IDD_CUSTOM_TYPE, &lpallobjs->CDP_iszType);
            
            //
            // Set the link checkbox to be off.
            //
            lpallobjs->CDP_fLink = FALSE;
            
            SendDlgItemMessage( hDlg,
                IDD_CUSTOM_LINK,
                BM_SETCHECK,
                (WPARAM) lpallobjs->CDP_fLink,
                0
                );

            ShowWindow( GetDlgItem( hDlg, IDD_CUSTOM_LINK ), SW_HIDE );
            
            SendDlgItemMessage( hDlg,
                IDD_CUSTOM_VALUETEXT,
                WM_SETTEXT,
                0,
                (LPARAM) rgszValue[iszVALUE]
                );
            
            //
            // Hang on to the window handle of the value edit control & others
            //
            lpallobjs->CDP_hWndVal = GetDlgItem (hDlg, IDD_CUSTOM_VALUE);
            lpallobjs->CDP_hWndName = GetDlgItem (hDlg, IDD_CUSTOM_NAME);
            lpallobjs->CDP_hWndLinkVal = GetDlgItem (hDlg, IDD_CUSTOM_LINKVALUE);
            lpallobjs->CDP_hWndValText = GetDlgItem (hDlg, IDD_CUSTOM_VALUETEXT);
            lpallobjs->CDP_hWndBoolTrue = GetDlgItem (hDlg, IDD_CUSTOM_BOOLTRUE);
            lpallobjs->CDP_hWndBoolFalse = GetDlgItem (hDlg, IDD_CUSTOM_BOOLFALSE);
            lpallobjs->CDP_hWndGroup = GetDlgItem (hDlg, IDD_CUSTOM_GBOX);
            lpallobjs->CDP_hWndAdd = GetDlgItem (hDlg, IDD_CUSTOM_ADD);
            lpallobjs->CDP_hWndDelete = GetDlgItem (hDlg, IDD_CUSTOM_DELETE);
            lpallobjs->CDP_hWndType = GetDlgItem (hDlg, IDD_CUSTOM_TYPE);
            lpallobjs->CDP_hWndCustomLV = GetDlgItem(hDlg, IDD_CUSTOM_LISTVIEW);
            InitListView (lpallobjs->CDP_hWndCustomLV, iszTYPE, rgszHeadings, TRUE);
            
            //
            // Initially disable the Add & Delete buttons
            //
            EnableWindow (lpallobjs->CDP_hWndAdd, FALSE);
            EnableWindow (lpallobjs->CDP_hWndDelete, FALSE);
            lpallobjs->CDP_fAdd = TRUE;
            
            //
            // Don't let the user enter too much text
            // If you change this value, you must change the buffer
            // size (szDate) in FConvertDate
            //
            SendMessage (lpallobjs->CDP_hWndVal, EM_LIMITTEXT, BUFMAX-1, 0);
            SendMessage (lpallobjs->CDP_hWndName, EM_LIMITTEXT, BUFMAX-1, 0);
            
            //
            // Add the link icon to the image list
            //
            hIcon = LoadIcon (g_hmodThisDll, MAKEINTRESOURCE (IDD_LINK_ICON));
            hInvIcon = LoadIcon (g_hmodThisDll, MAKEINTRESOURCE (IDD_INVLINK_ICON));
            if (hIcon != NULL)
            {
                lpallobjs->CDP_hImlS = ListView_GetImageList( lpallobjs->CDP_hWndCustomLV, TRUE );
                giLinkIcon = MsoImageList_ReplaceIcon( lpallobjs->CDP_hImlS, -1, hIcon );
                Assert ((giLinkIcon != -1));
                
                giInvLinkIcon = MsoImageList_ReplaceIcon (lpallobjs->CDP_hImlS, -1, hInvIcon);
                Assert ((giInvLinkIcon != -1));
            }
            else
            {
                DebugSz (TEXT("Icon load failed"));
            }
            
            //
            // Make a temporary copy of the custom data
            //
            FMakeTmpUDProps (lpallobjs->lpUDObj);
            
            //
            // Fill in the list view box with any data from the object
            //
            PopulateUDListView (lpallobjs->CDP_hWndCustomLV, lpallobjs->lpUDObj);
            
            //
            // See if the client supports links - turn off checkbox if they don't
            //
            lpallobjs->CDP_cLinks = 0;

            if (!lpallobjs->CDP_cLinks)
            {
                EnableWindow (GetDlgItem (hDlg, IDD_CUSTOM_LINK), FALSE);
                EnableWindow (lpallobjs->CDP_hWndLinkVal, FALSE);
            }
            
            return TRUE;
            break;
      }
      
    case WM_CTLCOLORBTN     :
    case WM_CTLCOLORDLG     :
    case WM_CTLCOLORSTATIC  :
        if (hBrushPropDlg == NULL)
            break;
        DeleteObject(hBrushPropDlg);
        if ((hBrushPropDlg = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) == NULL)
            break;
        SetBkColor ((HDC) wParam, GetSysColor (COLOR_BTNFACE));
        SetTextColor((HDC) wParam, GetSysColor(COLOR_WINDOWTEXT));
        return (INT_PTR) hBrushPropDlg;
        
    case WM_SYSCOLORCHANGE:
        PostMessage(lpallobjs->CDP_hWndCustomLV, WM_SYSCOLORCHANGE, wParam, lParam);
        return TRUE;
        break;
        
        //
        // This message is posted when ever the user does something with the
        // Name field.  That allows the system to finish what they are doing
        // and fill in the edit field if they have to.  See bug 2820.
        //
    case WM_USER+0x1000:
        if (!(lpallobjs->CDP_fLink && (lpallobjs->lpfnDwQueryLinkData == NULL)))
        {
            lpallobjs->CDP_iszType = (int)SendMessage (lpallobjs->CDP_hWndType, CB_GETCURSEL, 0, 0);
            FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
            if (FAllocAndGetValLpstz (hDlg, IDD_CUSTOM_NAME, &glpstzName))
            {
                LPUDPROP lpudp = LpudpropFindMatchingName (lpallobjs->lpUDObj, glpstzName);
                if (lpudp != NULL)
                {
                    if (lpallobjs->CDP_fAdd)
                    {
                        SendMessage (lpallobjs->CDP_hWndAdd, WM_SETTEXT, 0, (LPARAM) rgszAdd[iszMODIFY]);
                        lpallobjs->CDP_fAdd = FALSE;
                    }
                }
            }
            EnableWindow(lpallobjs->CDP_hWndDelete, FALSE);   // If the user touches the Name field, disable Delete button
            // Are we showing an invalid link?
            if (lpallobjs->CDP_fLink && !IsWindowEnabled(GetDlgItem(hDlg,IDD_CUSTOM_LINK)))
            {
                // Turn off the link checkbox
                lpallobjs->CDP_fLink = FALSE;
                SendDlgItemMessage (hDlg, IDD_CUSTOM_LINK, BM_SETCHECK, (WPARAM) lpallobjs->CDP_fLink, 0);
                if (lpallobjs->CDP_cLinks)   // Could be that the app is allowing links
                    EnableWindow (GetDlgItem (hDlg, IDD_CUSTOM_LINK), TRUE);
                // Clear the value window
                ClearEditControl (lpallobjs->CDP_hWndVal, 0);
                FSwapControls (lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndLinkVal, lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse,
                    lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndType, lpallobjs->CDP_hWndValText, FALSE, FALSE);
            }
        }
        return(TRUE);
        break;
        
    case WM_COMMAND :
        switch (HIWORD (wParam))
        {
        case BN_CLICKED :
            switch (LOWORD (wParam))
            {
            case IDD_CUSTOM_ADD :
                if (FGetCustomPropFromDlg(lpallobjs, hDlg))
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                }
                
                return(FALSE);     // return 0 'cuz we process the message
                break;
                
            case IDD_CUSTOM_DELETE :
                //              Assert (fItemSel);
                
                //              fItemSel = FALSE;                 // We're about to delete it!
                DeleteItem (lpallobjs->lpUDObj, lpallobjs->CDP_hWndCustomLV, lpallobjs->CDP_iItem, lpallobjs->CDP_sz);
                
                // Turn off the link checkbox if it was on.
                lpallobjs->CDP_fLink = FALSE;
                SendDlgItemMessage (hDlg, IDD_CUSTOM_LINK, BM_SETCHECK, (WPARAM) lpallobjs->CDP_fLink, 0);
                ClearEditControl (lpallobjs->CDP_hWndVal, 0);
                
                FSwapControls (lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndLinkVal, lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse,
                    lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndType, lpallobjs->CDP_hWndValText, FALSE, FALSE);
                
                FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
                ResetTypeControl (hDlg, IDD_CUSTOM_TYPE, &lpallobjs->CDP_iszType);
                SendMessage(lpallobjs->CDP_hWndName, CB_SETEDITSEL, 0, MAKELPARAM(0,-1));     // Select entire string
                SendMessage(lpallobjs->CDP_hWndName, WM_CLEAR, 0, 0);
                SetFocus(lpallobjs->CDP_hWndName);
                //              lpallobjs->fPropDlgChanged = TRUE;
                PropSheet_Changed(GetParent(hDlg), hDlg);
                return(FALSE);     // return 0 'cuz we process the message
                break;
                
            case IDD_CUSTOM_LINK :
                {
                    BOOL fMod = FALSE;
                    // Should never get a message from a disabled control
                    Assert (lpallobjs->CDP_cLinks);
                    
                    lpallobjs->CDP_fLink = !lpallobjs->CDP_fLink;
                    SendDlgItemMessage (hDlg, IDD_CUSTOM_LINK, BM_SETCHECK, (WPARAM) lpallobjs->CDP_fLink, 0);
                    
                    // If the link box is checked, the value edit needs to change
                    // to a combobox filled with link data
                    if (lpallobjs->CDP_fLink)
                    {
                        Assert ((lpallobjs->lpfnDwQueryLinkData != NULL));
                        
                        FCreateListOfLinks (lpallobjs->CDP_cLinks, lpallobjs->lpfnDwQueryLinkData, lpallobjs->CDP_hWndLinkVal);
                        SendMessage (lpallobjs->CDP_hWndLinkVal, CB_SETCURSEL, 0, 0);
                        FSetTypeControl ((*lpallobjs->lpfnDwQueryLinkData) (QLD_LINKTYPE, 0, NULL, NULL), lpallobjs->CDP_hWndType);
                    }
                    else
                        ClearEditControl (lpallobjs->CDP_hWndVal, 0);
                    
                    FSwapControls (lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndLinkVal, lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse,
                        lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndType, lpallobjs->CDP_hWndValText, lpallobjs->CDP_fLink, FALSE);
                    
                    // HACK, we don't want FSetupAddButton to change the text of the add
                    // button
                    if (!lpallobjs->CDP_fAdd)
                        fMod = lpallobjs->CDP_fAdd = TRUE;
                    // Set up the "Add" button correctly
                    FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
                    if (fMod)
                        lpallobjs->CDP_fAdd = FALSE;
                    return(FALSE);     // return 0 'cuz we process the message
                    break;
                }
            case IDD_CUSTOM_BOOLTRUE:
            case IDD_CUSTOM_BOOLFALSE:
                {
                    BOOL fMod = FALSE;
                    lpallobjs->CDP_iszType = (int)SendMessage (lpallobjs->CDP_hWndType, CB_GETCURSEL, 0, 0);
                    
                    // HACK, we don't want FSetupAddButton to change the text of the add
                    // button
                    if (!lpallobjs->CDP_fAdd)
                        fMod = lpallobjs->CDP_fAdd = TRUE;
                    FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
                    if (fMod)
                        lpallobjs->CDP_fAdd = FALSE;
                    
                    return(FALSE);
                }
                
            default:
                return(TRUE);
            }
            
            case CBN_CLOSEUP:
                // Hack!!
                // We need to post a message to ourselves to check if the user's
                // actions entered text in the edit field.
                PostMessage(hDlg, WM_USER+0x1000, 0L, 0L);
                return(FALSE);
                
            case CBN_SELCHANGE :
                switch (LOWORD (wParam))
                {
                case IDD_CUSTOM_NAME  :
                    // Hack!!
                    // We need to post a message to ourselves to check if the user's
                    // actions entered text in the edit field.
                    PostMessage(hDlg, WM_USER+0x1000, 0L, 0L);
                    return(FALSE);     // return 0 'cuz we process the message
                    break;
                    
                case IDD_CUSTOM_TYPE :
                    {
                        BOOL fMod = FALSE;
                        // If the user picks the Boolean type from the combo box,
                        // we must replace the edit control for the value
                        // with radio buttons.  If the Link checkbox is set,
                        // the type depends on the link value, not user selection
                        lpallobjs->CDP_iszType = (int)SendMessage ((HWND) lParam, CB_GETCURSEL, 0, 0);
                        FSwapControls (lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndLinkVal, lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse,
                            lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndType, lpallobjs->CDP_hWndValText, lpallobjs->CDP_fLink, (lpallobjs->CDP_iszType == iszBOOL));
                        // HACK: FSwapControls() resets the type selection to be
                        // the first one (since all other clients need that to
                        // happen).  In this case, the user has selected a new
                        // type, so we need to force it manually to what they picked.
                        SendMessage (lpallobjs->CDP_hWndType, CB_SETCURSEL, lpallobjs->CDP_iszType, 0);
                        // HACK: FSetupAddButton will change the Add button to
                        // say "Add" if lpallobjs->CDP_fAdd is FALSE.  Since we just changed
                        // the button to "Modify", fake it out to not change
                        // the Add button by flipping lpallobjs->CDP_fAdd, then flipping it back.
                        if (!lpallobjs->CDP_fAdd)
                            fMod = lpallobjs->CDP_fAdd = TRUE;
                        
                        FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
                        if (fMod)
                            lpallobjs->CDP_fAdd = FALSE;
                        return(FALSE);     // return 0 'cuz we process the message
                    }
                case IDD_CUSTOM_LINKVALUE :
                    // If the user has the "Link" box checked and starts picking
                    // link values, make sure that the "Type" combobox is updated
                    // to the type of the static value of the link.
                    {
                        DWORD irg;
                        
                        AssertSz (lpallobjs->CDP_fLink, TEXT("Link box must be checked in order for this dialog to be visible!"));
                        
                        // Get the link value from the combobox, and store
                        // the link name and static value.
                        irg = (int)SendMessage (lpallobjs->CDP_hWndLinkVal, CB_GETCURSEL, 0, 0);
                        
                        Assert ((lpallobjs->lpfnDwQueryLinkData != NULL));
                        
                        // REVIEW: If apps really need the name, we can get it here....
                        FSetTypeControl ((*lpallobjs->lpfnDwQueryLinkData) (QLD_LINKTYPE, irg, NULL, NULL), lpallobjs->CDP_hWndType);
                        return(FALSE);     // return 0 'cuz we process the message
                    }
                default:
                    return TRUE;      // we didn't process message
                }
                
                case CBN_EDITCHANGE:     // The user typed their own
                    switch (LOWORD (wParam))
                    {
                    case IDD_CUSTOM_NAME  :
                        // Hack!!
                        // We need to post a message to ourselves to check if the user's
                        // actions entered text in the edit field.
                        PostMessage(hDlg, WM_USER+0x1000, 0L, 0L);
                        return(FALSE);     // return 0 'cuz we process the message
                        break;
                    default:
                        return(TRUE);
                        break;
                    }
                    
                    case EN_UPDATE :
                        switch (LOWORD (wParam))
                        {
                            
                        case IDD_CUSTOM_VALUE :
                            {
                                BOOL fMod = FALSE;
                                
                                if (FAllocAndGetValLpstz (hDlg, IDD_CUSTOM_NAME, &glpstzName))
                                {
                                    LPUDPROP lpudp = LpudpropFindMatchingName (lpallobjs->lpUDObj, glpstzName);
                                    if (lpudp != NULL)
                                    {
                                        if (lpallobjs->CDP_fAdd)
                                        {
                                            SendMessage (lpallobjs->CDP_hWndAdd, WM_SETTEXT, 0, (LPARAM) rgszAdd[iszMODIFY]);
                                            lpallobjs->CDP_fAdd = FALSE;
                                        }
                                    }
                                    // HACK: FSetupAddButton will change the Add button to
                                    // say "Add" if lpallobjs->CDP_fAdd is FALSE.  Since we just changed
                                    // the button to "Modify", fake it out to not change
                                    // the Add button by flipping lpallobjs->CDP_fAdd, then flipping it back.
                                    if (!lpallobjs->CDP_fAdd)
                                        fMod = lpallobjs->CDP_fAdd = TRUE;
                                    
                                    FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
                                    if (fMod)
                                        lpallobjs->CDP_fAdd = FALSE;
                                }
                                return(FALSE);     // return 0 'cuz we process the message
                            }
                        default:
                            return TRUE;      // we didn't process message
                        }
                        
                        case EN_KILLFOCUS :
                            switch (LOWORD (wParam))
                            {
                                // If the user finishes entering text in the Name edit control,
                                // be really cool and check to see if the name they entered
                                // is a property that is already defined.  If it is,
                                // change the Add button to Modify.
                            case IDD_CUSTOM_NAME :
                                if (FAllocAndGetValLpstz (hDlg, IDD_CUSTOM_NAME, &glpstzName))
                                {
                                    LPUDPROP lpudp = LpudpropFindMatchingName (lpallobjs->lpUDObj, glpstzName);
                                    if (lpudp != NULL)
                                    {
                                        if (lpallobjs->CDP_fAdd)
                                        {
                                            SendMessage (lpallobjs->CDP_hWndAdd, WM_SETTEXT, 0, (LPARAM) rgszAdd[iszMODIFY]);
                                            lpallobjs->CDP_fAdd = FALSE;
                                        }
                                    }
                                }
                                return FALSE;
                                
                            default:
                                return TRUE;
                            }
                            default:
                                return TRUE;
        } // switch
        
    case WM_DESTROY:
        MsoImageList_Destroy(lpallobjs->CDP_hImlS);
        return FALSE;
        
    case WM_NOTIFY :
        
        switch (((NMHDR FAR *) lParam)->code)
        {
        case LVN_ITEMCHANGING :
            // If an item is gaining focus, put it in the edit controls at
            // the top of the dialog.
            if (((NM_LISTVIEW FAR *) lParam)->uNewState & LVIS_SELECTED)
            {
                Assert ((((NM_LISTVIEW FAR *) lParam) != NULL));
                lpallobjs->CDP_iItem = ((NM_LISTVIEW FAR *) lParam)->iItem;
                ListView_GetItemText (lpallobjs->CDP_hWndCustomLV, lpallobjs->CDP_iItem, 0, lpallobjs->CDP_sz, BUFMAX);
                PopulateControls (lpallobjs->lpUDObj, lpallobjs->CDP_sz, lpallobjs->CDP_cLinks, lpallobjs->lpfnDwQueryLinkData, hDlg,
                    GetDlgItem (hDlg, IDD_CUSTOM_NAME), lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndValText,
                    GetDlgItem (hDlg, IDD_CUSTOM_LINK), lpallobjs->CDP_hWndLinkVal, lpallobjs->CDP_hWndType,
                    lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse, lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndDelete, &lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd);
                
                return FALSE;
            }
            return TRUE;
            break;
            
        case PSN_APPLY :
            if (IsWindowEnabled(lpallobjs->CDP_hWndAdd))
                FGetCustomPropFromDlg(lpallobjs, hDlg);
            // Swap the temp copy to be the real copy.
            FDeleteTmpUDProps (lpallobjs->lpUDObj);
            
            if (FUserDefShouldSave (lpallobjs->lpUDObj)
                || lpallobjs->fPropDlgChanged )
            {
                if( !ApplyChangesBackToFile(hDlg, (BOOL)((PSHNOTIFY*)lParam)->lParam, lpallobjs, itabCUSTOM) )
                {
                    PostMessage( GetParent(hDlg), PSM_SETCURSEL, (WPARAM)-1, (LPARAM)lpallobjs->lpUDObj->m_hPage );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }
            }
            return PSNRET_NOERROR;
            
        case PSN_RESET :
            if (lpallobjs->fPropDlgChanged && !lpallobjs->fPropDlgPrompted)
            {
                if (ISavePropDlgChanges(lpallobjs, hDlg, ((NMHDR FAR *)lParam)->hwndFrom) != IDNO)
                {
                    return(TRUE);
                }
            }
            // User cancelled the changes, so just delete the tmp stuff.
            FSwapTmpUDProps (lpallobjs->lpUDObj);
            FDeleteTmpUDProps (lpallobjs->lpUDObj);
            return TRUE;
            
        case PSN_SETACTIVE :
            return TRUE;
            
        default:
            break;
        } // switch
        break;
        
        case WM_CONTEXTMENU:
            WinHelp((HANDLE)wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR)rgIdhCustom);
            break;
            
        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR)rgIdhCustom);
            break;
    } // switch
    
    return FALSE;
    
} // FCustomDlgProc

//
// FGetCustomPropFromDlg
//
// Purpose: To get a custom property from the dialog.
//          I.e. the user hit Add/Modify.
//
BOOL FGetCustomPropFromDlg(LPALLOBJS lpallobjs, HWND hDlg)
{
    UDTYPES udtype;
    NUM dbl;
    LPVOID lpv;
    int iItemT;
    LPTSTR lpstzName;
    LPVOID lpvSaveAsDword;
    DWORD cch;
    BOOL f;
    
    lpstzName = NULL;
    cch = 0;
    
    if (FAllocAndGetValLpstz (hDlg, IDD_CUSTOM_NAME, &glpstzName))
    {
        LPUDPROP lpudp;
        
        lpallobjs->CDP_fLink = FALSE; // just to be sure.
        Assert(lpallobjs->CDP_fLink == TRUE || lpallobjs->CDP_fLink == FALSE);
        
        // HACK: If the user enters a name that is already
        // a property name, the default action of the object
        // is to replace the data, treating it as an update.
        // This will cause there to be 2 names in the listview
        // though unless we just update the original one.  So, first
        // see if the new name is in the list already, and if
        // it is, find it in the listview and set up to update it.
        
        lpudp = LpudpropFindMatchingName (lpallobjs->lpUDObj, glpstzName);
        if (lpudp != NULL)
        {
            LV_FINDINFO lvfi;
            
            lvfi.flags = LVFI_STRING;
            lvfi.psz = glpstzName;
            iItemT = ListView_FindItem (lpallobjs->CDP_hWndCustomLV, -1, &lvfi);
        }
        else
        {
            iItemT = -1;
        }
        
        // Let's get the type, since this might be a MODIFY case
        
        lpallobjs->CDP_iszType = (int)SendMessage(lpallobjs->CDP_hWndType, CB_GETCURSEL,0, 0);
        
        // If the user has checked the link box, then the value
        // must come from the client.
        
        if (lpallobjs->CDP_fLink)
        {
            DWORD irg;
            
            // Get the link name from the combobox, and store
            // the link name and static value.
            
            irg = (int)SendMessage (lpallobjs->CDP_hWndLinkVal, CB_GETCURSEL, 0, 0);
            
            Assert ((lpallobjs->lpfnDwQueryLinkData != NULL));
            Assert (((irg < lpallobjs->CDP_cLinks) && ((int) irg >= 0)));
            
            cch = (DWORD)SendMessage (lpallobjs->CDP_hWndLinkVal, CB_GETLBTEXTLEN, irg, 0)+1; // Include the null-terminator
            
            if (!FAllocString (&lpstzName, cch))
                return(FALSE);
            
            SendMessage (lpallobjs->CDP_hWndLinkVal, CB_GETLBTEXT, irg, (LPARAM) lpstzName );
            
            // Set up the static type and value for display
            // in the listbox
            
            udtype = (UDTYPES) (*lpallobjs->lpfnDwQueryLinkData) (QLD_LINKTYPE, irg, NULL, lpstzName);
            (*lpallobjs->lpfnDwQueryLinkData) (QLD_LINKVAL, irg, &lpv, lpstzName);
            
            //
            // HACK alert
            //
            // We want lpv to point to the value, not to be overloaded in the case of a dword or bool.
            //
            
            if ((udtype == wUDdw) || (udtype == wUDbool))
            {
                lpvSaveAsDword = lpv; // Really a DWORD
                lpv = &lpvSaveAsDword;
            }
        }
        
        else
        {
            if (lpallobjs->CDP_iszType != iszBOOL)
            {
                if (!FAllocAndGetValLpstz (hDlg, IDD_CUSTOM_VALUE, &glpstzValue))
                    return(FALSE);
            }
            
            // Convert the type in the combobox to a UDTYPES
            
            switch (lpallobjs->CDP_iszType)
            {
            case iszTEXT :
                udtype = wUDlpsz;
                (LPTSTR) lpv = glpstzValue;
                break;
                
            case iszNUM :
                udtype = UdtypesGetNumberType (glpstzValue, &dbl,
                    ((LPUDINFO)lpallobjs->lpUDObj->m_lpData)->lpfnFSzToNum);
                switch (udtype)
                {
                case wUDdw :
                    lpv = (DWORD *) &dbl;
                    break;
                    
                case wUDfloat :
                    (NUM *) lpv = &dbl;
                    break;
                    
                default :
                    (LPTSTR) lpv = glpstzValue;
                    
                    // If the user doesn't want to convert the value to text, they can press "Cancel" and try again.
                    
                    if (FDisplayConversionWarning (hDlg))
                    {
                        SetFocus(lpallobjs->CDP_hWndType);
                        return(FALSE);
                    }
                    udtype = wUDlpsz;
                    
                }   // switch (udtype)
                break;
                
                case iszDATE :
                    
                    if (FConvertDate (glpstzValue, lstrlen(glpstzValue) + 1, (LPFILETIME) &dbl))
                    {
                        udtype = wUDdate;
                        (NUM *) lpv = &dbl;
                    }
                    else
                    {
                        udtype = wUDlpsz;
                        (LPTSTR) lpv = glpstzValue;
                        // If the user doesn't want to convert the value to text, they can press "Cancel" and try again.
                        if (FDisplayConversionWarning (hDlg))
                        {
                            SetFocus(lpallobjs->CDP_hWndType);
                            return(FALSE);
                        }
                    }
                    break;
                    
                case iszBOOL :
                    {
                        udtype = wUDbool;
                        f = (BOOL)(SendMessage (lpallobjs->CDP_hWndBoolTrue, BM_GETSTATE, 0, 0) & BST_CHECKED);
                        lpv = &f;
                        break;
                    }
                    
                default :
                    AssertSz (0,TEXT("IDD_CUSTOM_TYPE combobox is whacked!"));
                    udtype = wUDinvalid;
                    
            }   // switch (lpallobjs->CDP_iszType)
            
        }   // if (lpallobjs->CDP_fLink) ... else
        
        
        // If we got valid input, add the property to the object
        // and listbox.
        
        if (udtype != wUDinvalid)
        {
            // The PropVariant created when we add this property.
            LPPROPVARIANT lppropvar = NULL;
            
            // The link data (link name itself) would have
            // been stored above if the property was a link.
            // This stores the static value that will eventually
            // appear in the list view.
            
            lppropvar = LppropvarUserDefAddProp (lpallobjs->lpUDObj, glpstzName, lpv, udtype,
                (lpstzName != NULL) ? lpstzName : NULL,
                (lpstzName != NULL) ? TRUE : FALSE, FALSE);
            
            // HACK alert
            //
            // Here we want lpv be overloaded in the case of a dword or bool, since
            // AddUDPropToListView calls WUdtypeToSz which assumes lpv is overloaded.
            //
            
            if ((udtype == wUDdw) || (udtype == wUDbool))
            {
                lpv = *(LPVOID *)lpv;
            }
            
            if (lppropvar)
            {
                AddUDPropToListView (lpallobjs->lpUDObj, lpallobjs->CDP_hWndCustomLV, glpstzName, lppropvar, iItemT, lpallobjs->CDP_fLink, fTrue, fTrue);
            }
            
            // For links, dealloc the buffer.
            
            if (lpallobjs->CDP_fLink)
            {
                LocalFree(lpv);
                lpv = NULL;
            }
            
            // Clear out the edit fields and disable the Add button again
            SetCustomDlgDefButton(hDlg, gOKButtonID);
            EnableWindow (lpallobjs->CDP_hWndAdd, FALSE);
            SendMessage(lpallobjs->CDP_hWndName, CB_SETEDITSEL, 0, MAKELPARAM(0,-1));     // Select entire string
            SendMessage(lpallobjs->CDP_hWndName, WM_CLEAR, 0, 0);
            EnableWindow (lpallobjs->CDP_hWndDelete, FALSE);
            // See bug 213
            //                    if (fLink)
            //                    {
            //                      fLink = !fLink;
            //                      SendDlgItemMessage (hDlg, IDD_CUSTOM_LINK, BM_SETCHECK, (WPARAM) fLink, 0);
            //                    }
            FSwapControls (lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndLinkVal,
                lpallobjs->CDP_hWndBoolTrue, lpallobjs->CDP_hWndBoolFalse,
                lpallobjs->CDP_hWndGroup, lpallobjs->CDP_hWndType,
                lpallobjs->CDP_hWndValText, lpallobjs->CDP_fLink, lpallobjs->CDP_iszType == iszBOOL);
            FSetupAddButton (lpallobjs->CDP_iszType, lpallobjs->CDP_fLink, &lpallobjs->CDP_fAdd, lpallobjs->CDP_hWndAdd, lpallobjs->CDP_hWndVal, lpallobjs->CDP_hWndName, hDlg);
            
            // wUDbool doesn't use the edit control....
            if (lpallobjs->CDP_iszType != iszBOOL)
                ClearEditControl (lpallobjs->CDP_hWndVal, 0);
            
        }   // if (udtype != wUDinvalid)
        
        SendDlgItemMessage(hDlg, IDD_CUSTOM_TYPE, CB_SETCURSEL, lpallobjs->CDP_iszType,0);
        SetFocus(lpallobjs->CDP_hWndName);
        //          lpallobjs->fPropDlgChanged = TRUE;
        if (lpstzName != NULL)
        {
            LocalFree(lpstzName);
        }
        return(TRUE);
    }
    return(FALSE);
    
}

/////////////////////////////////////////////////////////////////////////
//
// SetCustomDlgDefButton
//
// Set the new default button
//
/////////////////////////////////////////////////////////////////////////
VOID SetCustomDlgDefButton(HWND hDlg, int IDNew)
{
    int IDOld;
    
    if ((IDOld = LOWORD(SendMessage(hDlg, DM_GETDEFID, 0L, 0L))) != IDNew)
    {
        // Set the new default push button's control ID.
        SendMessage(hDlg, DM_SETDEFID, IDNew, 0L);
        
        // Set the new style.
        SendDlgItemMessage(hDlg, IDNew, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
        
        SendDlgItemMessage(hDlg, IDOld, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// FAllocAndGetValLpstz
//
// Purpose:
//  Gets the value from the edit box into the local buffer.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FAllocAndGetValLpstz (
                                  HWND hDlg,                           // Handle of dialog control is in
                                  DWORD dwId,                          // Id of control
                                  LPTSTR *lplpstz)                      // Buffer
{
    DWORD cch;
    
    cch = (DWORD)SendDlgItemMessage (hDlg, dwId, WM_GETTEXTLENGTH, 0, 0);
    cch++;
    
    if (FAllocString (lplpstz, cch))
    {
        // Get the entry.  Remember to null-terminate it.
        cch = (DWORD)SendDlgItemMessage (hDlg, dwId, WM_GETTEXT, cch, (LPARAM) *lplpstz );
        (*lplpstz)[cch] = TEXT('\0');
        
        return TRUE;
    }
    
    return FALSE;
    
} // FAllocAndGetValLpstz

////////////////////////////////////////////////////////////////////////////////
//
// FAllocString
//
// Purpose:
//  Allocates a string big enough to to hold cch char's.  Only allocates if needed.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FAllocString (
                          LPTSTR *lplpstz,
                          DWORD cch)
{
    // Figure out how many bytes we need to allocate.
    
    DWORD cbNew = (cch * sizeof(TCHAR));
    
    // And how many bytes we need to free.
    
    DWORD cbOld = *lplpstz == NULL
        ? 0
        : (lstrlen (*lplpstz) + 1) * sizeof(TCHAR);
    
    
    // If we need to free or allocate data.
    
    if (*lplpstz == NULL || cbNew > cbOld)
    {
        LPTSTR lpszNew;
        
        // Allocate the new data.
        
        lpszNew = LocalAlloc( LPTR, cbNew);
        if (lpszNew == NULL)
        {
            return FALSE;
        }
        
        // Free the old data.
        
        if (*lplpstz != NULL)
        {
            LocalFree(*lplpstz);
        }
        
        *lplpstz = lpszNew;
        
    }
    
    // Make this a valid (empty) string.
    
    **lplpstz = TEXT('\0');
    
    return TRUE;
    
} // FAllocString


////////////////////////////////////////////////////////////////////////////////
//
// ClearEditControl
//
// Purpose:
//  Clears any text from an edit control
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL
ClearEditControl
(HWND hDlg,                           // Dialog handle
 DWORD dwId)                          // Id of edit control
{
    // Really cheesey.  Clear the edit control by selecting
    // everything then clearing the selection
    if (dwId == 0)
    {
        SendMessage (hDlg, EM_SETSEL, 0, -1);
        SendMessage (hDlg, WM_CLEAR, 0, 0);
    }
    else
    {
        SendDlgItemMessage (hDlg, dwId, EM_SETSEL, 0, -1);
        SendDlgItemMessage (hDlg, dwId, WM_CLEAR, 0, 0);
    }
    
} // ClearEditControl

////////////////////////////////////////////////////////////////////////////////
//
// UdtypesGetNumberType
//
// Purpose:
//  Gets the number type from the string and returns the value, either
//  a float or dword in numval.
//
////////////////////////////////////////////////////////////////////////////////
UDTYPES PASCAL
UdtypesGetNumberType
(LPTSTR lpstz,                                   // String containing the number
 NUM *lpnumval,                              // The value of the number
 BOOL (*lpfnFSzToNum)(NUM *, LPTSTR))   // Sz To Num routine, can be null
{
    TCHAR *pc;
    
    errno = 0;
    *(DWORD *) lpnumval = wcstol(lpstz, &pc, 10);
    
    if ((!errno) && (*pc == TEXT('\0')))
        return wUDdw;
    
    // Try doing a float conversion if int fails
    
    if (lpfnFSzToNum != NULL)
    {
        if ((*lpfnFSzToNum)(lpnumval, lpstz))
            return wUDfloat;
    }
    
    return wUDinvalid;
    
} // UdtypesGetNumberType


////////////////////////////////////////////////////////////////////////////////
//
// YearIndexFromShortDateFormat
//
// 
//  Determines the zero-based position index of the year component
//  of a textual representation of the date based on the specified date format.
//  This value may be used as the iYear arg to ScanDateNums function.
//
////////////////////////////////////////////////////////////////////////////////
int YearIndexFromShortDateFormat( TCHAR chFmt )
{
    switch( chFmt )
    {
        case MMDDYY:
        case DDMMYY:
            return 2;
        case YYMMDD:
            return 0;
    }
    return -1;
}

////////////////////////////////////////////////////////////////////////////////
//
//  IsGregorian
//
//  Purpose:
//      Reports whether the specified calendar is a gregorian calendar.
//
////////////////////////////////////////////////////////////////////////////////
BOOL IsGregorian( CALID calid )
{
    switch (calid)
    {
        case CAL_GREGORIAN:
        case CAL_GREGORIAN_US:
        case CAL_GREGORIAN_ME_FRENCH:
        case CAL_GREGORIAN_ARABIC:
        case CAL_GREGORIAN_XLIT_ENGLISH:
        case CAL_GREGORIAN_XLIT_FRENCH:
            return TRUE;

        //  these are non-gregorian:
        //case CAL_JAPAN
        //case CAL_TAIWAN
        //case CAL_KOREA
        //case CAL_HIJRI
        //case CAL_THAI
        //case CAL_HEBREW
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
//  GregorianYearFromAbbreviatedYear
//
//  Purpose:
//      Based on current locale settings, calculates the year corresponding to the
//  specified 1- or 2-digit abbreviated value.
//
////////////////////////////////////////////////////////////////////////////////
int GregorianYearFromAbbreviatedYear( LCID lcid, CALID calid, int nAbbreviatedYear )
{
    TCHAR szData[16];   
    LONG  nYearHigh = -1;
    int   nBaseCentury;
    int   nYearInCentury = 0;

    //  We're handling two-digit values for gregorian calendars only
    if (nAbbreviatedYear < 100)
    {
        // We don't support non-gregorian date windowing here 
        // because that would be insanely complex and prone to error -ccooney 2000/02/04
        if( !IsGregorian( calid )
            || !GetCalendarInfo( lcid, calid, CAL_ITWODIGITYEARMAX|CAL_RETURN_NUMBER,
                              NULL, 0, &nYearHigh ) )
        {
            // In the absence of a default, use 2029 as the cutoff, just like monthcal.
            nYearHigh = 2029;
        }

        //
        //  Copy the century of nYearHigh into nAbbreviatedYear.
        //
        nAbbreviatedYear += (nYearHigh - nYearHigh % 100);
        //
        //  If it exceeds the max, then drop to previous century.
        //
        if (nAbbreviatedYear > nYearHigh)
            nAbbreviatedYear -= 100;
    }

    return nAbbreviatedYear;
}

////////////////////////////////////////////////////////////////////////////////
//
// FConvertDate
//
// Purpose:
//  Converts the given string to a date.
//
////////////////////////////////////////////////////////////////////////////////
BOOL 
PASCAL 
FConvertDate( 
    LPTSTR lpstz,                         // String having the date
    DWORD cchMax,
    LPFILETIME lpft                      // The date in FILETIME format
    )
{
    
    FILETIME ft;
    SYSTEMTIME st;
    TCHAR szSep[3];
    TCHAR szFmt[10];
    TCHAR szCalID[8];
    unsigned int ai[3];
    int   iYear =-1; // index of ai member that represents the year value
    CALID calid;
    TCHAR szDate[256];
    TCHAR szMonth[256];
    TCHAR *pch;
    TCHAR *pchT;
    DWORD cch;
    DWORD i;


    if (!(GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_IDATE, szFmt, ARRAYSIZE(szFmt))) ||
        !(GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_SDATE, szSep, ARRAYSIZE(szSep))) ||
        !(GetLocaleInfo (LOCALE_USER_DEFAULT, LOCALE_ICALENDARTYPE, szCalID, ARRAYSIZE(szCalID))) )
        return FALSE;

    iYear = YearIndexFromShortDateFormat(szFmt[0]);
    
    // Augh!  It's an stz so we need to pass the DWORDs at the start
    if (!ScanDateNums(lpstz, szSep, ai, sizeof(ai)/sizeof(unsigned int),iYear))
    {
        // Could be that the string contains the short version of the month, e.g. 03-Mar-95
        StringCchCopy( szDate, ARRAYSIZE(szDate), lpstz ); // don't care if it truncates
        pch = szDate;
        
        // Let's get to the first character of the month, if there is one
        while(((IsCharAlphaNumeric(*pch) && !IsCharAlpha(*pch)) || (*pch == szSep[0])) && (*pch != 0))
        {
            ++pch;
        }
        
        // If we got to the end of the string, there really was an error
        if (*pch == 0)
            return(FALSE);
        
        // Let's find the length of the month string
        pchT = pch+1;
        while ((*pchT != szSep[0]) && (*pchT != 0))
        {
            ++pchT;
        }
        cch = (DWORD)(pchT - pch);
        
        // Loop through all the months and see if we match one
        // There can be 13 months
        for (i = 1; i <= 13; ++i)
        {
            if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SABBREVMONTHNAME1+i-1,
                szMonth, ARRAYSIZE(szMonth)))
            {
                return(FALSE);
            }
            
            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                pch, cch, szMonth, lstrlen(szMonth)) == 2)
            {
                break;
            }
        }
        
        if (i > 13)
            return(FALSE);
        
        // We found the month. wsprintf zero-terminates
        if (FAILED(StringCchPrintf(pch, cch, TEXT("%u"), i)))
            return(FALSE);

        pch += lstrlen( pch );
        while (*pch++ = *(pch+1));
        
        // Try and convert again
        if (!ScanDateNums(szDate, szSep, ai, 3, iYear))
            return(FALSE);
        
    } // if (!ScanDateNums(lpstz, szSep, ai, 3))
    
    ZeroMemory(&st, sizeof(st));
    
    switch (szFmt[0])
    {
    case MMDDYY:
        st.wMonth = (WORD)ai[0];
        st.wDay = (WORD)ai[1];
        st.wYear = (WORD)ai[2];
        break;
    case DDMMYY:
        st.wDay = (WORD)ai[0];
        st.wMonth = (WORD)ai[1];
        st.wYear = (WORD)ai[2];
        break;
    case YYMMDD:
        st.wYear = (WORD)ai[0];
        st.wMonth = (WORD)ai[1];
        st.wDay = (WORD)ai[2];
        break;
    default:
        return FALSE;
    }
    
    if (st.wYear < ONECENTURY)
    {
        calid = wcstol( szCalID, NULL, 10 );
        st.wYear = (WORD)GregorianYearFromAbbreviatedYear( 
            LOCALE_USER_DEFAULT, calid, st.wYear );
    }
    
    if (!SystemTimeToFileTime (&st, &ft))
        return(FALSE);

    return(LocalFileTimeToFileTime(&ft, lpft));
    
} // FConvertDate


////////////////////////////////////////////////////////////////////////////////
//
// PopulateUDListView
//
// Purpose:
//  Populates the entire ListView with the User-defined properties
//  in the given object.
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL
PopulateUDListView
(HWND hWnd,                   // Handle of list view window
 LPUDOBJ lpUDObj)             // UD Prop object
{
    LPUDITER lpudi;
    LPPROPVARIANT lppropvar;
    BOOL fLink;
    BOOL fLinkInvalid;
    
    // Iterate through the list of user-defined properties, adding each
    // one to the listview.
    
    for( lpudi = LpudiUserDefCreateIterator (lpUDObj);
    FUserDefIteratorValid (lpudi);
    FUserDefIteratorNext (lpudi)
        )
    {
        // Get the name of this property.
        
        LPTSTR tszPropertyName = LpszUserDefIteratorName( lpudi );
        
        // If the property has no name, or the name indicates that it
        // is a hidden property, then move on to the next property.
        
        if( tszPropertyName == NULL
            ||
            *tszPropertyName == HIDDENPREFIX )
        {
            continue;
        }
        
        lppropvar = LppropvarUserDefGetIteratorVal (lpudi, &fLink, &fLinkInvalid);
        if (lppropvar == NULL)
            return;
        
        // If this isn't a supported type, don't display it.
        if( !ISUDTYPE(lppropvar->vt) )
            continue;
                
        //
        // In the Shell, we want all links to show up as invalid, so set that here...
        //
        
        fLinkInvalid = TRUE;
        
        AddUDPropToListView (lpUDObj, hWnd, LpszUserDefIteratorName (lpudi ), lppropvar, -1, fLink, fLinkInvalid, FALSE);
        
    } // for( lpudi = LpudiUserDefCreateIterator (lpUDObj); ...
    
    FUserDefDestroyIterator (&lpudi);
    
} // PopulateUDListView


////////////////////////////////////////////////////////////////////////////////
//
// AddUDPropToListView
//
// Purpose:
//  Adds the given property to the list view or updates an existing one
//  if iItem >= 0
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL AddUDPropToListView (
                                 LPUDOBJ lpUDObj,
                                 HWND hWnd,                   // Handle of list view
                                 LPTSTR lpszName,             // Name of property
                                 LPPROPVARIANT lppropvar,     // The property value.
                                 int iItem,                   // Index to add item at
                                 BOOL fLink,                  // Indicates the value is a link
                                 BOOL fLinkInvalid,           // Is the link invalid?
                                 BOOL fMakeVisible)           // Should the property be forced to be visible
{
    LV_ITEM lvi;
    TCHAR sz[BUFMAX];
    WORD irg;
    BOOL fSuccess;
    BOOL fUpdate;
    
    // If iItem >= 0, then the item should be updated, otherwise,
    // it should be added.
    
    if (fUpdate = (iItem >= 0))
    {
        lvi.iItem = iItem;
        if (fLink)
            lvi.iImage = (fLinkInvalid) ? giInvLinkIcon : giLinkIcon;
        else
            lvi.iImage = giBlankIcon;
        
        lvi.mask = LVIF_IMAGE;
        lvi.iSubItem = iszNAME;
        
        fSuccess = ListView_SetItem (hWnd, &lvi);
        Assert (fSuccess);           // We don't *really* care, just want to know when it happens
    }
    else
    {
        // This always adds to the end of the list....
        lvi.iItem = ListView_GetItemCount (hWnd);
        
        // First add the label to the list
        lvi.iSubItem = iszNAME;
        lvi.pszText = lpszName;
        
        if (fLink)
            lvi.iImage = (fLinkInvalid) ? giInvLinkIcon : giLinkIcon;
        else
            lvi.iImage = giBlankIcon;
        lvi.mask = LVIF_TEXT | LVIF_IMAGE;
        
        lvi.iItem = ListView_InsertItem (hWnd, &lvi);
        if (lvi.iItem == 0)
            ListView_SetItemState(hWnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    
    // Convert the data to a string and print it
    
    lvi.mask = LVIF_TEXT;
    irg = WUdtypeToSz (lppropvar, sz, BUFMAX, ((LPUDINFO)lpUDObj->m_lpData)->lpfnFNumToSz);
    lvi.pszText = sz;
    lvi.iSubItem = iszVAL;
    fSuccess = ListView_SetItem (hWnd, &lvi);
    Assert (fSuccess);           // We don't *really* care, just want to know when it happens
    
    // Put the type in the listview
    
    lvi.iSubItem = iszTYPE;
    lvi.pszText = (LPTSTR) rgszTypes[irg];
    fSuccess = ListView_SetItem (hWnd, &lvi);
    Assert (fSuccess);           // We don't *really* care, just want to know when it happens
    if (fMakeVisible)
    {
        fSuccess = ListView_EnsureVisible(hWnd, lvi.iItem, FALSE);
        Assert (fSuccess);           // We don't *really* care, just want to know when it happens
    }
    
} // AddUDPropToListView


////////////////////////////////////////////////////////////////////////////////
//
// InitListView
//
// Purpose:
//  Initializes a list view control
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL
InitListView
(HWND hWndLV,                   // Handle of parent dialog
 int irgLast,                 // Index of last column in array
 TCHAR rgsz[][SHORTBUFMAX],    // Array of column headings
 BOOL fImageList)              // Should the listview have an image list
{
    HICON hIcon;
    RECT rect;
    HIMAGELIST hImlS;
    LV_COLUMN lvc;
    int irg;
    
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    
    // Initially force all columns to be the same size & fill the control.
    GetClientRect(hWndLV, &rect);
    // Subtract fudge factor
    lvc.cx = (rect.right-rect.left)/(irgLast+1)-(GetSystemMetrics(SM_CXVSCROLL)/(irgLast+1));
    
    // Add in all the columns.
    for (irg = 0; irg <= irgLast; irg++)
    {
        lvc.pszText = rgsz[irg];
        lvc.iSubItem = irg;
        ListView_InsertColumn (hWndLV, irg, &lvc);
    }
    
    if (!fImageList)
        return;
    
    hIcon = LoadIcon (g_hmodThisDll, MAKEINTRESOURCE (IDD_BLANK_ICON));
    if (hIcon != NULL)
    {
        hImlS = MsoImageList_Create (16, 16, TRUE, ICONSMAX, 0);
        ListView_SetImageList (hWndLV, hImlS, LVSIL_SMALL);
        giBlankIcon = MsoImageList_ReplaceIcon (hImlS, -1, hIcon);
        Assert ((giBlankIcon != -1));
    }
    
} // InitListView


////////////////////////////////////////////////////////////////////////////////
//
// FSwapControls
//
// Purpose:
//  Swaps the controls needed to display link info.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL
FSwapControls
(HWND hWndVal,                        // Handle of Value window
 HWND hWndLinkVal,                    // Handle of Link Value Combo box
 HWND hWndBoolTrue,                   // Handle of True radio button
 HWND hWndBoolFalse,                  // Handle of False radio button
 HWND hWndGroup,                      // Handle of Group box
 HWND hWndType,                       // Handle of Type window
 HWND hWndValText,
 BOOL fLink,                          // Flag indicating a link
 BOOL fBool)                          // Flag indicating a bool
{
    if (fLink)
    {
        SendMessage (hWndValText, WM_SETTEXT, 0, (LPARAM) rgszValue[iszSOURCE]);
        ShowWindow (hWndVal, SW_HIDE);
        ShowWindow (hWndBoolTrue, SW_HIDE);
        ShowWindow (hWndBoolFalse, SW_HIDE);
        ShowWindow (hWndGroup, SW_HIDE);
        ShowWindow (hWndLinkVal, SW_SHOW);
        EnableWindow (hWndType, FALSE);
        ClearEditControl (hWndVal, 0);
    }
    else
    {
        SendMessage (hWndValText, WM_SETTEXT, 0, (LPARAM) rgszValue[iszVALUE]);
        ShowWindow (hWndLinkVal, SW_HIDE);
        EnableWindow (hWndType, TRUE);
        
        if (fBool)
        {
            ShowWindow (hWndVal, SW_HIDE);
            ShowWindow (hWndBoolTrue, SW_SHOW);
            ShowWindow (hWndBoolFalse, SW_SHOW);
            ShowWindow (hWndGroup, SW_SHOW);
            SendMessage (hWndBoolTrue, BM_SETCHECK, (WPARAM) CHECKED, 0);
            SendMessage (hWndBoolFalse, BM_SETCHECK, (WPARAM) CLEAR, 0);
            SendMessage (hWndType, CB_SETCURSEL, iszBOOL, 0);
            ClearEditControl (hWndVal, 0);
        }
        else
        {
            ShowWindow (hWndVal, SW_SHOW);
            EnableWindow(hWndVal, TRUE);
            ShowWindow (hWndBoolTrue, SW_HIDE);
            ShowWindow (hWndBoolFalse, SW_HIDE);
            ShowWindow (hWndGroup, SW_HIDE);
            SendMessage (hWndType, CB_SETCURSEL, iszTEXT, 0);
        }
    }
    
    return TRUE;
    
} // FSwapControls

////////////////////////////////////////////////////////////////////////////////
//
// PopulateControls
//
// Purpose:
//  Populates the edit controls with the appropriate date from the object
//
////////////////////////////////////////////////////////////////////////////////
VOID PASCAL PopulateControls (
                              LPUDOBJ lpUDObj,                     // Pointer to object
                              LPTSTR szName,                        // Name of the item to populate controls with
                              DWORD cLinks,                        // Number of links
                              DWQUERYLD lpfnDwQueryLinkData,       // Pointer to app link callback
                              HWND hDlg,                           // Handle of the dialog
                              HWND hWndName,                       // Handle of the Name window
                              HWND hWndVal,                        // Handle of Value window
                              HWND hWndValText,                    // Handle of Value LTEXT
                              HWND hWndLink,                       // Handle of Link checkbox
                              HWND hWndLinkVal,                    // Handle of Link Value window
                              HWND hWndType,                       // Handle of Type window
                              HWND hWndBoolTrue,                   // Handle of True radio button
                              HWND hWndBoolFalse,                  // Handle of False radio button
                              HWND hWndGroup,                      // Handle of Group window
                              HWND hWndAdd,                        // Handle of Add button
                              HWND hWndDelete,                     // Handle of Delete button
                              BOOL *pfLink,                        // Indicates that the value is a link
                              BOOL *pfAdd)                         // Indicates the state of the Add button
{
    UDTYPES udtype;
    LPVOID lpv;
    LPPROPVARIANT lppropvar;            // A property from the UDObj linked-list.
    BOOL f,fT;
    TCHAR sz[BUFMAX];
    LPUDPROP lpudp;
    
    // Grab the type for the string and set up the dialog to have the right
    // controls to display it.
    udtype = UdtypesUserDefType (lpUDObj, szName);
    AssertSz ((udtype != wUDinvalid), TEXT("User defined properties or ListView corrupt"));
    
    // Get a name-specified property from the UD linked-list.
    
    lppropvar = LppropvarUserDefGetPropVal (lpUDObj, szName, pfLink, &fT);
    Assert (lppropvar != NULL || udtype == wUDbool || udtype == wUDdw);
    if (lppropvar == NULL)
        return;
    
    lpv = LpvoidUserDefGetPropVal (lpUDObj, szName, UD_STATIC | UD_PTRWIZARD, pfLink, &fT);
    Assert((lpv != NULL) || (udtype == wUDbool) || (udtype == wUDdw));
    
    FSwapControls (hWndVal, hWndLinkVal, hWndBoolTrue, hWndBoolFalse, hWndGroup, hWndType, hWndValText, *pfLink, (udtype == wUDbool));
    
    SendMessage (hWndType, CB_SETCURSEL, (WPARAM) WUdtypeToSz (lppropvar, (TCHAR *) sz, BUFMAX,
        ((LPUDINFO)lpUDObj->m_lpData)->lpfnFNumToSz), 0);
    SendMessage (hWndLink, BM_SETCHECK, (WPARAM) *pfLink, 0);
    if (cLinks)                       // Let's make sure we enable the window if links are allowed
        EnableWindow(hWndLink, TRUE);
    
    if (*pfLink)
    {
        FCreateListOfLinks (cLinks, lpfnDwQueryLinkData, hWndLinkVal);
        lpv = LpvoidUserDefGetPropVal (lpUDObj, szName, UD_LINK | UD_PTRWIZARD, pfLink, &fT);
        Assert (lpv != NULL || udtype == wUDbool || udtype == wUDdw);
        AssertSz ((lpv != NULL), TEXT("Dialog is corrupt in respect to Custom Properties database"));
        
        // This code is added for bug 188 and the code is ugly !! :)
        lpudp = LpudpropFindMatchingName (lpUDObj, szName);
        if ((lpudp != NULL) && (lpudp->fLinkInvalid))
        {
            SetCustomDlgDefButton(hDlg, IDD_CUSTOM_DELETE);
            SendMessage(hWndName, WM_SETTEXT, 0, (LPARAM)szName);
            SendMessage(hWndVal, WM_SETTEXT, 0, (LPARAM)lpv);
            EnableWindow(hWndDelete, TRUE);
            EnableWindow(hWndAdd, FALSE);
            EnableWindow(hWndLink, FALSE);
            EnableWindow(hWndType, FALSE);
            ShowWindow(hWndLinkVal, SW_HIDE);
            ShowWindow(hWndVal, SW_SHOW);
            EnableWindow(hWndVal, FALSE);
            return;
        }
        
        // Select the current link for this property in the combobox.  If the link
        // name no longer exists (there's some contrived cases where this can
        // happen) then this will select nothing.
        SendMessage (hWndLinkVal, CB_SELECTSTRING, 0, (LPARAM) lpv);
        EnableWindow(hWndLink, TRUE);
    }
    else if (udtype == wUDbool)
    {
        SendMessage ((lpv) ? hWndBoolTrue : hWndBoolFalse, BM_SETCHECK, CHECKED, 0);
        SendMessage ((lpv) ? hWndBoolFalse : hWndBoolTrue, BM_SETCHECK, CLEAR, 0);
        EnableWindow(hWndType, TRUE);
    }
    else
    {
        SendMessage (hWndVal, WM_SETTEXT, 0, (LPARAM) sz);
        EnableWindow (hWndVal, TRUE);
        EnableWindow(hWndType, TRUE);
    }
    
    if (*pfAdd)
    {
        SendMessage (hWndAdd, WM_SETTEXT, 0, (LPARAM) rgszAdd[iszMODIFY]);
        *pfAdd = FALSE;
    }
    
    // HACK: Because the EN_UPDATE handler for hWndName checks fAdd to
    // see if the button should be set to Add, when we set the text
    // in the edit control, the button will change to Add unless
    // fAdd is set to TRUE.  Temporarily set the flag to TRUE to force
    // the button to not change.  Restore the original value after the
    // text has been set.
    f = *pfAdd;
    *pfAdd = TRUE;
    SendMessage (hWndName, WM_SETTEXT, 0, (LPARAM) szName);
    *pfAdd = f;
    // If we can fill the data in the controls, turn on the
    // Delete button too.
    EnableWindow (hWndDelete, TRUE);
    SetCustomDlgDefButton(hDlg, gOKButtonID);
    EnableWindow (hWndAdd, FALSE);
} // PopulateControls


////////////////////////////////////////////////////////////////////////////////
//
// FSetupAddButton
//
// Purpose:
//  Sets up the Add button correctly based on the type & flags.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL
FSetupAddButton
(DWORD iszType,                       // Index of the type in combobox
 BOOL fLink,                          // Indicates a link
 BOOL *pfAdd,                         // Indicates if the Add button is showing
 HWND hWndAdd,                        // Handle of Add button
 HWND hWndVal,                        // Handle of value button
 HWND hWndName,                       // Handle of Name
 HWND hDlg)                           // Handle of dialog
{
    // Once the user starts typing, we can enable the Add button
    // if there is text in the name & the value (unless this
    // is a link or boolean, in which case we don't care about
    // the value).
    BOOL f;
    
    if ((iszType != iszBOOL) && (!fLink))
    {
        if (SendMessage (hWndVal, EM_LINELENGTH, 0, 0) != 0)
        {
            f = (SendMessage (hWndName, WM_GETTEXTLENGTH, 0, 0) != 0);
            if (f)
                SetCustomDlgDefButton(hDlg, IDD_CUSTOM_ADD);
            else
                SetCustomDlgDefButton(hDlg, gOKButtonID);
            EnableWindow (hWndAdd, f);
        }
        else
        {
            SetCustomDlgDefButton(hDlg, gOKButtonID);
            EnableWindow (hWndAdd, FALSE);
        }
    }
    // If it's a bool or link, just check to see that the name
    // has stuff in it.
    else
    {
        f = SendMessage (hWndName, WM_GETTEXTLENGTH, 0, 0) != 0;
        if (f)
            SetCustomDlgDefButton(hDlg, IDD_CUSTOM_ADD);
        else
            SetCustomDlgDefButton(hDlg, gOKButtonID);
        EnableWindow (hWndAdd, f);
    }
    
    if (!*pfAdd)
    {
        SendMessage (hWndAdd, WM_SETTEXT, 0, (LPARAM) rgszAdd[iszADD]);
        *pfAdd = TRUE;
    }
    
    return TRUE;
    
}  // FSetupAddButton


////////////////////////////////////////////////////////////////////////////////
//
// WUdtypeToSz
//
// Purpose:
//  Converts the given type into a string representation.  Returns the
//  index in the type combobox of the type.
//
////////////////////////////////////////////////////////////////////////////////
WORD PASCAL WUdtypeToSz (
                         LPPROPVARIANT lppropvar,    // Value with the type to be converted.
                         LPTSTR psz,                 // Buffer to put converted val in
                         DWORD cchMax,               // Size of buffer (in chars)
                         BOOL (*lpfnFNumToSz)(NUM *, LPTSTR, DWORD))
{
    SYSTEMTIME st;
    WORD irg;
    FILETIME ft;
    
    Assert (lppropvar != NULL);
    
    switch (lppropvar->vt)
    {
    case wUDlpsz :
        StringCchCopy(psz, cchMax, lppropvar->pwszVal );    // don't care if it truncates
        irg = iszTEXT;
        break;
        
    case wUDdate :
        if (FScanMem((LPBYTE)&lppropvar->filetime,
            0, sizeof(FILETIME))) // if the date struct is all 0's
        {
            *psz = 0;                       // display the empty string
        }
        else if (!FileTimeToLocalFileTime(&lppropvar->filetime, &ft)
            || !FileTimeToSystemTime (&ft, &st)
            || (!GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, psz, cchMax)))
        {
#ifdef DEBUG
            DWORD dwErr = GetLastError();    
#endif DEBUG            
            irg = iszUNKNOWN;
            *psz = 0;
            break;
        }
        
        irg = iszDATE;
        break;
        
    case wUDdw :
        Assert(cchMax >= 11);
        Assert(lppropvar->vt == VT_I4);
        
        StringCchPrintf(psz, cchMax, TEXT("%ld"), lppropvar->lVal); // don't care if it truncates
        irg = iszNUM;
        break;
        
    case wUDfloat :
        if (lpfnFNumToSz != NULL)
            irg = (*lpfnFNumToSz)((NUM*)&lppropvar->dblVal, psz, cchMax) ? iszNUM : iszUNKNOWN;
        else
        {
            irg = iszUNKNOWN;
            *psz = 0;
        }
        break;
        
    case wUDbool :
        // don't care if it truncates
        StringCchCopy( psz, cchMax, lppropvar->boolVal ? (LPTSTR) &rgszBOOL[iszTRUE] : (LPTSTR) &rgszBOOL[iszFALSE] );
        irg = iszBOOL;
        break;
        
    default :
        irg = iszUNKNOWN;
        
    } // switch
    
    return irg;
    
} // WUdtypeToSz


////////////////////////////////////////////////////////////////////////////////
//
// FCreateListOfLinks
//
// Purpose:
//  Creates the dropdown list of linkable items.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FCreateListOfLinks(
                               DWORD cLinks,                                // Number of links
                               DWQUERYLD lpfnDwQueryLinkData,               // Link data callback
                               HWND hWndLinkVal)                            // Link Value window handle
{
    DWORD irg;
    LPTSTR lpstz;
    
    // If the combobox is already filled, don't fill it
    if (irg = (int)SendMessage(hWndLinkVal, CB_GETCOUNT,0, 0))
    {
        Assert(irg == cLinks);
        return(TRUE);
    }
    
    lpstz = NULL;
    
    // Call back the client app to get the list of linkable
    // values, and put them in the value combobox.
    for (irg = 0; irg < cLinks; irg++)
    {
        lpstz = (TCHAR *) ((*lpfnDwQueryLinkData) (QLD_LINKNAME, irg, &lpstz, NULL));
        if (lpstz != NULL)
        {
            SendMessage (hWndLinkVal, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) lpstz);
            LocalFree(lpstz);
            // REVIEW: We probably ought to figure out a way to be more efficient here....
        }
    }
    
    return TRUE;
    
} // FCreateListOfLinks


////////////////////////////////////////////////////////////////////////////////
//
// FSetTypeControl
//
// Purpose:
//  Sets the type control to have the given type selected.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FSetTypeControl (
                             UDTYPES udtype,                      // Type to set the type to
                             HWND hWndType)                       // Handle of type control
{
    WORD iType;
    
    switch (udtype)
    {
    case wUDlpsz :
        iType = iszTEXT;
        break;
    case wUDfloat :
    case wUDdw    :
        iType = iszNUM;
        break;
    case wUDbool  :
        iType = iszBOOL;
        break;
    case wUDdate :
        iType = iszDATE;
        break;
    default:
        return FALSE;
    }
    SendMessage (hWndType, CB_SETCURSEL, (WPARAM) iType, 0);
    
    return TRUE;
    
} // FSetTypeControl


////////////////////////////////////////////////////////////////////////////////
//
// DeleteItem
//
// Purpose:
//  Deletes an item from the UD object and the listview.
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL DeleteItem (
                        LPUDOBJ lpUDObj,
                        HWND hWndLV,
                        int iItem,
                        TCHAR sz[])
{
    int i;
    
    ListView_DeleteItem (hWndLV, iItem);
    FUserDefDeleteProp (lpUDObj, sz);
    
    // We just nuked the item with the focus, so let's get the new one
    // if there are still items in the listview
    if ((i = ListView_GetItemCount(hWndLV)) != 0)
    {
        // Figure out the index of the item to get the focus
        i = (i == iItem) ? iItem - 1 : iItem;
        ListView_SetItemState(hWndLV, i, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    
} // DeleteItem


////////////////////////////////////////////////////////////////////////////////
//
// ResetTypeControl
//
// Purpose:
//  Resets the value of the type control to Text.
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL ResetTypeControl (
                              HWND hDlg,                           // Handle of dialog
                              DWORD dwId,                          // Id of control
                              DWORD *piszType)                     // The type we've reset to
{
    SendDlgItemMessage (hDlg, dwId, CB_SETCURSEL, iszTEXT, 0);
    *piszType = iszTEXT;
} // ResetTypeControl


////////////////////////////////////////////////////////////////////////////////
//
// FDisplayConversionWarning
//
// Purpose:
//  Displays a warning about types being converted.  Returns TRUE if
//  the user presses "Cancel"
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FDisplayConversionWarning(HWND hDlg)                   // Handle of parent window
{
    return (IdDoAlert(hDlg, idsPEWarningText, MB_ICONEXCLAMATION | MB_OKCANCEL) == IDCANCEL);
} // FDisplayConversionWarning


////////////////////////////////////////////////////////////////////////////////
//
// LoadTextStrings
//
// Purpose:
//  Loads all of the text needed by the dialogs from the DLL.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL FLoadTextStrings (void)
{
    register int cLoads = 0;
    register int cAttempts = 0;
    
    // CchGetString returns a cch, so make it into a 1 or 0
    // then add up the results,making sure we load as many as
    // we try.

    cLoads += (CchGetString (idsPEB, rgszOrders[iszBYTES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEKB, rgszOrders[iszORDERKB], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEMB, rgszOrders[iszORDERMB], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEGB, rgszOrders[iszORDERGB], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPETB, rgszOrders[iszORDERTB], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPEBytes, rgszStats[iszBYTES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEPages, rgszStats[iszPAGES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEPara, rgszStats[iszPARA], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPELines, rgszStats[iszLINES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEWords, rgszStats[iszWORDS], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEChars, rgszStats[iszCHARS], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPESlides, rgszStats[iszSLIDES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPENotes, rgszStats[iszNOTES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEHiddenSlides, rgszStats[iszHIDDENSLIDES], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEMMClips, rgszStats[iszMMCLIPS], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEFormat, rgszStats[iszFORMAT], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPEText, rgszTypes[iszTEXT], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEDate, rgszTypes[iszDATE], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPENumber, rgszTypes[iszNUM], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEBool, rgszTypes[iszBOOL], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEUnknown, rgszTypes[iszUNKNOWN], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPEStatName, rgszStatHeadings[iszNAME], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEValue, rgszStatHeadings[iszVAL], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPEPropName, rgszHeadings[iszNAME], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEValue, rgszHeadings[iszVAL], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEType, rgszHeadings[iszTYPE], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPETrue, rgszBOOL[iszTRUE], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEFalse, rgszBOOL[iszFALSE], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPEAdd, rgszAdd[iszADD], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEModify, rgszAdd[iszMODIFY], SHORTBUFMAX) && TRUE);
    cAttempts++;
    
    cLoads += (CchGetString (idsPESource, rgszValue[iszSOURCE], SHORTBUFMAX) && TRUE);
    cAttempts++;
    cLoads += (CchGetString (idsPEValueColon, rgszValue[iszVALUE], BUFMAX) && TRUE);
    cAttempts++;
    
    
    return (cLoads == cAttempts);
    
} // LoadTextStrings

//
// Function: ISavePropDlgChanges
//
// Parameters:
//
//    hwndDlg - dialog window handle
//    hwndFrom - window handle from the NMHDR struct (see code above)
//
// Returns:
//
//       TRUE since we handled the message.
//
// History:
//
//    Created 09/16/94  martinth
//
int PASCAL ISavePropDlgChanges(LPALLOBJS lpallobjs, HWND hwndDlg, HWND hwndFrom)
{
    TCHAR   sz[BUFMAX];
    int     iRet = IDABORT; // MessageBox return.
    LRESULT lRet = 0L;      // (FALSE == dismiss property sheet).
    
    if (CchGetString(idsCustomWarning, sz, ARRAYSIZE(sz)) == 0)
        return(FALSE);
    
    lpallobjs->fPropDlgPrompted = TRUE;  // no warning next time!
    iRet = MessageBox( hwndDlg, sz, TEXT("Warning"),
                       MB_ICONEXCLAMATION | MB_YESNOCANCEL );    

    switch( iRet )
    {
    case IDYES:
        PropSheet_Apply(hwndFrom);  // Let's get them changes
        break;
    // case IDNO:                   // do nothing
    case IDCANCEL:                  // cancel and disallow sheet destroy.
	lRet = TRUE;
        break;
    }
    SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, lRet );
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\propdlg.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by propdlg.rc
//
#define ICONSMAX                        3
#define IDD_LINE_1                      1000
#define IDD_LINE_2                      1001
#define IDD_LINE_3                      1002
#define IDD_SUMMARY_SAVEPREVIEW         1004
#define IDD_STATISTICS_LVLABEL          1005
#define IDD_LINK_ICON                   1997
#define IDD_BLANK_ICON                  1998
#define IDD_INVLINK_ICON                1999
#define DLG_FILEPROP                    2000
#define IDD_NAME                        2001
#define IDD_FILETYPE                    2002
#define IDD_FILESIZE                    2003
#define IDD_LOCATION                    2004
#define IDD_FILENAME                    2005
#define IDD_CREATED                     2006
#define IDD_LASTMODIFIED                2007
#define IDD_LASTACCESSED                2008
#define IDD_READONLY                    2009
#define IDD_HIDDEN                      2010
#define IDD_ARCHIVE                     2011
#define IDD_SYSTEM                      2012
#define IDD_ITEMICON                    2013
#define IDD_SUMMARY                     2100
#define IDD_SUMMARY_TITLE               2101
#define IDD_SUMMARY_SUBJECT             2102
#define IDD_SUMMARY_AUTHOR              2103
#define IDD_SUMMARY_KEYWORDS            2104
#define IDD_SUMMARY_COMMENTS            2105
#define IDD_SUMMARY_TEMPLATE            2106
#define IDD_SUMMARY_CATEGORY            2107
#define IDD_SUMMARY_APPLY               2108
#define IDD_SUMMARY_TEMPLATETEXT        2109
#define IDD_SUMMARY_MANAGER             2110
#define IDD_SUMMARY_COMPANY             2111
#define IDD_STATISTICS                  2200
#define IDD_STATISTICS_CREATED          2201
#define IDD_STATISTICS_ACCESSED         2202
#define IDD_STATISTICS_CHANGED          2203
#define IDD_STATISTICS_LASTPRINT        2204
#define IDD_STATISTICS_LASTSAVEBY       2205
#define IDD_STATISTICS_REVISION         2206
#define IDD_STATISTICS_TOTALEDIT        2207
#define IDD_STATISTICS_LISTVIEW         2209
#define IDD_CUSTOM                      2300
#define IDD_CUSTOM_NAME                 2301
#define IDD_CUSTOM_TYPE                 2302
#define IDD_CUSTOM_VALUE                2303
#define IDD_CUSTOM_LINKVALUE            2304
#define IDD_CUSTOM_LINK                 2305
#define IDD_CUSTOM_LISTVIEW             2306
#define IDD_CUSTOM_ADD                  2307
#define IDD_CUSTOM_DELETE               2308
#define IDD_CUSTOM_BOOLTRUE             2309
#define IDD_CUSTOM_BOOLFALSE            2310
#define IDD_CUSTOM_GBOX                 2311
#define IDD_CUSTOM_VALUETEXT            2312
#define IDD_CONTENTS                    2400
#define IDD_CONTENTS_LISTBOX            2401
#define IDD_SUMMARY_TITLE_LABEL         2402
#define IDD_SUMMARY_SUBJECT_LABEL       2403
#define IDD_SUMMARY_AUTHOR_LABEL        2404
#define IDD_SUMMARY_MANAGER_LABEL       2405
#define IDD_SUMMARY_COMPANY_LABEL       2406
#define IDD_SUMMARY_CATEGORY_LABEL      2407
#define IDD_SUMMARY_KEYWORDS_LABEL      2408
#define IDD_SUMMARY_COMMENTS_LABEL      2409
#define IDD_STATISTICS_CREATED_LABEL    2410
#define IDD_STATISTICS_CHANGED_LABEL    2411
#define IDD_STATISTICS_ACCESSED_LABEL   2412
#define IDD_STATISTICS_LASTPRINT_LABEL  2413
#define IDD_STATISTICS_LASTSAVEBY_LABEL 2414
#define IDD_STATISTICS_REVISION_LABEL   2415
#define IDD_STATISTICS_TOTALEDIT_LABEL  2416
#define IDD_CUSTOM_NAME_LABEL           2417
#define IDD_CUSTOM_TYPE_LABEL           2418
#define IDD_CUSTOM_LISTVIEW_LABEL       2419
#define IDD_CONTENTS_LISTBOX_LABEL      2420
#define IDD_FILETYPE_LABEL              2421
#define IDD_FILESIZE_LABEL              2422
#define IDD_LOCATION_LABEL              2423
#define IDD_FILENAME_LABEL              2424
#define IDD_CREATED_LABEL               2425
#define IDD_LASTMODIFIED_LABEL          2426
#define IDD_LASTACCESSED_LABEL          2427
#define IDD_ATTRIBUTES_LABEL            2428

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\proptype.h ===
////////////////////////////////////////////////////////////////////////////////
//
// proptype.h
//
// Base types common to OLE Property Exchange and OLE Property Sets.
// See "OLE 2 Programmer's Reference, Volume 1", Appendix B for the
// published format for Property Sets.  The types defined here
// follow that format.
//
// Notes:
//  All strings in objects are stored in the following format:
//   DWORD size of buffer, DWORD length of string, string data, terminating 0.
//  The size of the buffer is inclusive of the DWORD, the length is not but
//  does include the ending 0.
//
//  EXTREMELY IMPORTANT!  All strings buffers must align on 32-bit boundaries.
//  Whenever one is allocated, the macro CBALIGN32 should be used to add
//  enough bytes to pad it out.
//
// Change history:
//
// Date         Who             What
// --------------------------------------------------------------------------
// 06/01/94     B. Wentz        Created file
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __proptype_h__
#define __proptype_h__

#include <objbase.h>
#include <oleauto.h>
#include "offcapi.h"
#include "plex.h"

  // Property Id's for Summary Info, as defined in OLE 2 Prog. Ref.
#define PID_TITLE               0x00000002L
#define PID_SUBJECT             0x00000003L
#define PID_AUTHOR              0x00000004L
#define PID_KEYWORDS            0x00000005L
#define PID_COMMENTS            0x00000006L
#define PID_TEMPLATE            0x00000007L
#define PID_LASTAUTHOR          0x00000008L
#define PID_REVNUMBER           0x00000009L
#define PID_EDITTIME            0x0000000aL
#define PID_LASTPRINTED         0x0000000bL
#define PID_CREATE_DTM          0x0000000cL
#define PID_LASTSAVE_DTM        0x0000000dL
#define PID_PAGECOUNT           0x0000000eL
#define PID_WORDCOUNT           0x0000000fL
#define PID_CHARCOUNT           0x00000010L
#define PID_THUMBNAIL           0x00000011L
#define PID_APPNAME             0x00000012L
#define PID_DOC_SECURITY        0x00000013L

  // Range of PId's we understand
#define PID_SIFIRST             0x00000002L
#define PID_SILAST              0x00000013L
#define NUM_SI_PROPERTIES       (PID_SILAST - PID_SIFIRST + 1)

  // Property Id's for Document Summary Info, as define in OLE Property Exchange spec
#define PID_CATEGORY            0x00000002L
#define PID_PRESFORMAT          0x00000003L
#define PID_BYTECOUNT           0x00000004L
#define PID_LINECOUNT           0x00000005L
#define PID_PARACOUNT           0x00000006L
#define PID_SLIDECOUNT          0x00000007L
#define PID_NOTECOUNT           0x00000008L
#define PID_HIDDENCOUNT         0x00000009L
#define PID_MMCLIPCOUNT         0x0000000aL
#define PID_SCALE               0x0000000bL
#define PID_HEADINGPAIR         0x0000000cL
#define PID_DOCPARTS            0x0000000dL
#define PID_MANAGER             0x0000000eL
#define PID_COMPANY             0x0000000fL
#define PID_LINKSDIRTY          0x00000010L

  // Range of PID's we understand
#define PID_DSIFIRST            0x00000002L
#define PID_DSILAST             0x00000010L
#define NUM_DSI_PROPERTIES      (PID_DSILAST - PID_DSIFIRST + 1)

  // Beginning of the User-Defined range of properties.
#define PID_UDFIRST             0x00000002L

  // Predefined Property Id's in the standard
#define PID_DICT                0x00000000L  /* Property Id for the Property Set Dictionary */
#define PID_DOC_CODEPAGE        0x00000001L  /* Property Id for the Code Page */

  // Property Id masks to identify links and IMonikers
#define PID_LINKMASK            0x01000000L
#define PID_IMONIKERMASK        0x10000000L

  // Predefined Clipboard Format Identifiers in the standard
#define CFID_NONE        0L     /* No format name */
#define CFID_WINDOWS    -1L     /* Windows built-in clipboard format */
#define CFID_MACINTOSH  -2L     /* Macintosh format value */
#define CFID_FMTID      -3L     /* A FMTID */
 

  // Type for linked-lists.
typedef struct _LLIST *LPLLIST;
typedef struct _LLIST
{
  LPLLIST lpllistNext;
  LPLLIST lpllistPrev;
} LLIST;

  // Cache struct for linked-list routines
typedef struct _LLCACHE
{
  DWORD idw;
  LPLLIST lpllist;
} LLCACHE, FAR * LPLLCACHE;

  // Structure to hold the document headings
typedef struct _xheadpart
{
  BOOL fHeading;           // Is this node a heading??
  DWORD dwParts;           // Number of sections for this heading
  DWORD iHeading;          // Which heading does this document part belong to
  LPTSTR lpstz;             // The heading or the document part
} XHEADPART;

DEFPL (PLXHEADPART, XHEADPART, ixheadpartMax, ixheadpartMac, rgxheadpart);
typedef PLXHEADPART *LPPLXHEADPART;
typedef XHEADPART *LPXHEADPART;

  // Structure for linked list of User-defined properties
  // Note: This structure and everything it points to is allocated
  // with CoTaskMemAlloc.

typedef struct _UDPROP *LPUDPROP;
typedef struct _UDPROP
{
  LLIST         llist;
  LPTSTR        lpstzName;
  PROPID        propid;
  LPPROPVARIANT lppropvar;
  LPTSTR        lpstzLink;
  BOOL          fLinkInvalid;
} UDPROP;              

//
// Our internal data for Summary Info
//
  // Max number of strings we store
#define cSIStringsMax           0x13      // The is actual PID of last string + 1
                                          // makes it easy to lookup string based on PID in array

  // Max number of filetimes we store, the offset to subtract from the index
#define cSIFTMax                0x4       // same as for cSIStringsMax
#define cSIFTOffset             0xa

// These are used to indicate whether a property has been set or not
#define bEditTime  1
#define bLastPrint 2
#define bCreated   4
#define bLastSave  8
#define bPageCount 16
#define bWordCount 32
#define bCharCount 64
#define bSecurity  128

  // Max number of VT_I4's we store
#define cdwSIMax                0x6    // same as for cSIStringsMax
#define cdwSIOffset             0xe

#define ifnSIMax                  4

// Used for OLE Automation
typedef struct _docprop
{
   LPVOID pIDocProp;              // Pointer to a DocumentProperty object
} DOCPROP;

DEFPL (PLDOCPROP, DOCPROP, idocpropMax, idocpropMac, rgdocprop);

// SummaryInformation data.

typedef struct _SINFO
{
  PROPVARIANT rgpropvar[ NUM_SI_PROPERTIES ];         // The actual properties.

  BOOL     fSaveSINail;         // Should we save the thumbnail?
  BOOL     fNoTimeTracking;     // Is time tracking disabled (Germany)

  BOOL (*lpfnFCPConvert)(LPTSTR, DWORD, DWORD, BOOL); // Code page converter
  BOOL (*lpfnFSzToNum)(NUM *, LPTSTR);                // Convert sz to double
  BOOL (*lpfnFNumToSz)(NUM *, LPTSTR, DWORD);         // Convert double to sz
  BOOL (*lpfnFUpdateStats)(HWND, LPSIOBJ, LPDSIOBJ);  // Update stats on stat tab

} SINFO, FAR * LPSINFO;

  // Macro to access the SINFO structure within the OFFICESUMINFO structure.
#define GETSINFO(lpSInfo) ( (LPSINFO) lpSInfo->m_lpData )

  // Indices into SINFO.rgpropvar array.
#define PVSI_TITLE               0x00L
#define PVSI_SUBJECT             0x01L
#define PVSI_AUTHOR              0x02L
#define PVSI_KEYWORDS            0x03L
#define PVSI_COMMENTS            0x04L
#define PVSI_TEMPLATE            0x05L
#define PVSI_LASTAUTHOR          0x06L
#define PVSI_REVNUMBER           0x07L
#define PVSI_EDITTIME            0x08L
#define PVSI_LASTPRINTED         0x09L
#define PVSI_CREATE_DTM          0x0aL
#define PVSI_LASTSAVE_DTM        0x0bL
#define PVSI_PAGECOUNT           0x0cL
#define PVSI_WORDCOUNT           0x0dL
#define PVSI_CHARCOUNT           0x0eL
#define PVSI_THUMBNAIL           0x0fL
#define PVSI_APPNAME             0x10L
#define PVSI_DOC_SECURITY        0x11L


//
// Our internal data for Document Summary Info
//
  // Max number of strings we store.
#define cDSIStringsMax          0x10   // same as for cSIStringsMax

  // Max number of VT_I4's we store
#define cdwDSIMax               0xe    // same as for cSIStringsMax

// These are used to indicate whether a property has been set or not
#define bByteCount   1
#define bLineCount   2
#define bParCount    4
#define bSlideCount  8
#define bNoteCount   16
#define bHiddenCount 32
#define bMMClipCount 64

#define ifnDSIMax                  1    // DSIObj only has one callback

typedef struct _DSINFO
{
  PROPVARIANT   rgpropvar[ NUM_DSI_PROPERTIES ];
  BYTE          bPropSet;

  BOOL (*lpfnFCPConvert)(LPTSTR, DWORD, DWORD, BOOL); // Code page converter

} DSINFO, FAR * LPDSINFO;

  // Macro to access the DSINFO structure within the OFFICESUMINFO structure.
#define GETDSINFO(lpDSInfo) ( (LPDSINFO) lpDSInfo->m_lpData )

  // Indices into ALLOBJS.propvarDocSumInfo array.
#define PVDSI_CATEGORY            0x00L
#define PVDSI_PRESFORMAT          0x01L
#define PVDSI_BYTECOUNT           0x02L
#define PVDSI_LINECOUNT           0x03L
#define PVDSI_PARACOUNT           0x04L
#define PVDSI_SLIDECOUNT          0x05L
#define PVDSI_NOTECOUNT           0x06L
#define PVDSI_HIDDENCOUNT         0x07L
#define PVDSI_MMCLIPCOUNT         0x08L
#define PVDSI_SCALE               0x09L
#define PVDSI_HEADINGPAIR         0x0AL
#define PVDSI_DOCPARTS            0x0BL
#define PVDSI_MANAGER             0x0CL
#define PVDSI_COMPANY             0x0DL
#define PVDSI_LINKSDIRTY          0x0EL


//
// Our internal data for User-defined properties
//

#define ifnUDMax                  ifnMax

  // The prefix for hidden property names
#define HIDDENPREFIX TEXT('_')

  // An iterator for User-defined Properties
typedef struct _UDITER
{
  LPUDPROP lpudp;
} UDITER;

typedef struct _UDINFO
{
    // Real object data
  DWORD     dwcLinks;                   // Number of links
  DWORD     dwcProps;                   // Number of user-defined properties
  LPUDPROP  lpudpHead;                  // Head of list of properties
  LPUDPROP  lpudpCache;
  CLSID     clsid;                      // The ClassID from the property set.

    // Temporary object data
  DWORD     dwcTmpLinks;                // Number of links
  DWORD     dwcTmpProps;                // Number of user-defined properties
  LPUDPROP  lpudpTmpHead;               // Head of list of properties
  LPUDPROP  lpudpTmpCache;

    // Application callback functions
  BOOL (*lpfnFCPConvert)(LPTSTR, DWORD, DWORD, BOOL); // Code page converter
  BOOL (*lpfnFSzToNum)(NUM *, LPTSTR);             // Convert sz to double
  BOOL (*lpfnFNumToSz)(NUM *, LPTSTR, DWORD);      // Convert double to sz

} UDINFO, FAR * LPUDINFO;

  // Macro to access the UDINFO structure within the OFFICESUMINFO structure.
#define GETUDINFO(lpUDInfo) ( (LPUDINFO) lpUDInfo->m_lpData )


  // Number of PIds we do understand.
#define cSIPIDS                   18
//Number of doc sum Pids
#define cDSIPIDS   16

#endif // __proptype_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\propio.c ===
////////////////////////////////////////////////////////////////////////////////
//
// Propio.c
//
// MS Office Properties IO
//
// Notes:
//  Because the Document Summary and User-defined objects both store
//  their data in one stream (different sections though), one of these
//  needs to also be responsible for saving any other sections that
//  we don't understand at this time.  The rule used here is that
//  if the Document Summary object exists, it will store the
//  unknown data, otherwise the User-defined object will.
//
// Change history:
//
// Date         Who             What
// --------------------------------------------------------------------------
// 07/26/94     B. Wentz        Created file
// 07/08/96     MikeHill        Add all properties to the UDProp list
//                              (not just props that are UDTYPEs).
//
////////////////////////////////////////////////////////////////////////////////

#include "priv.h"
#pragma hdrstop

#include <stdio.h>      // for sprintf
#include <shlwapi.h>

#ifdef DEBUG
#define typSI  0
#define typDSI 1
#define typUD  2
typedef struct _xopro
{
  int typ;
        union{
          LPSIOBJ lpSIObj;
          LPDSIOBJ lpDSIObj;
          LPUDOBJ lpUDObj;
        };
} XOPRO;
// Plex of xopros
DEFPL (PLXOPRO, XOPRO, ixoproMax, ixoproMac, rgxopro);
#endif

// The constant indicating that the object uses Intel byte-ordering.
#define wIntelByteOrder  0xFFFE

#ifndef CP_WINUNICODE
#define CP_WINUNICODE   1200
#endif

// The name of the Document Summary Information stream.

const GUID FMTID_SummaryInformation = {0xf29f85e0L,0x4ff9,0x1068,0xab,0x91,0x08,0x00,0x2b,0x27,0xb3,0xd9};
const GUID FMTID_DocumentSummaryInformation = {0xd5cdd502L,0x2e9c,0x101b,0x93,0x97,0x08,0x00,0x2b,0x2c,0xf9,0xae};
const GUID FMTID_UserDefinedProperties = {0xd5cdd505L,0x2e9c,0x101b,0x93,0x97,0x08,0x00,0x2b,0x2c,0xf9,0xae};

  // Internal prototypes
static DWORD PASCAL DwLoadDocAndUser (LPDSIOBJ lpDSIObj, LPUDOBJ  lpUDObj, LPSTORAGE lpStg, DWORD dwFlags, BOOL fIntOnly);
static DWORD PASCAL DwSaveDocAndUser (LPDSIOBJ lpDSIObj, LPUDOBJ  lpUDObj, LPSTORAGE lpStg, DWORD dwFlags);
static DWORD PASCAL DwLoadPropSetRange (LPPROPERTYSETSTORAGE  lpPropertySetStorage, REFFMTID pfmtid, UINT FAR * lpuCodePage, PROPID propidFirst, PROPID propidLast, PROPVARIANT rgpropvar[], DWORD grfStgMode);
static DWORD PASCAL DwSavePropSetRange (LPPROPERTYSETSTORAGE lpPropertySetStorage, UINT uCodePage, REFFMTID pfmtid, PROPID propidFirst, PROPID propidLast, PROPVARIANT rgpropvarOriginal[], PROPID propidSkip, DWORD grfStgMode);
static BOOL  PASCAL FReadDocParts(LPSTREAM lpStm, LPDSIOBJ lpDSIObj);
static BOOL  PASCAL FReadAndInsertDocParts(LPSTREAM lpStm, LPDSIOBJ lpDSIObj);
static BOOL  PASCAL FReadHeadingPairs(LPSTREAM lpStm, LPDSIOBJ lpDSIObj);
static BOOL  PASCAL FReadAndInsertHeadingPairs(LPSTREAM lpStm, LPDSIOBJ lpDSIObj);
static BOOL  PASCAL FLoadUserDef(LPUDOBJ lpUDObj, LPPROPERTYSETSTORAGE lpPropertySetStorage, UINT *puCodePage, BOOL fIntOnly, DWORD grfStgMode);
static BOOL  PASCAL FSaveUserDef(LPUDOBJ lpUDObj, LPPROPERTYSETSTORAGE lpPropertySetStorage, UINT uCodePage, DWORD grfStgMode );


BOOL OFC_CALLBACK FCPConvert( LPTSTR lpsz, DWORD dwFrom, DWORD dwTo, BOOL fMacintosh )
{
    return TRUE;
}

BOOL OFC_CALLBACK FSzToNum(double *lpdbl, LPTSTR lpsz)
{
    LPTSTR lpDec;
    LPTSTR lpTmp;
    double mult;

    //
    // First, find decimal point
    //

    for (lpDec = lpsz; *lpDec && *lpDec!=TEXT('.'); lpDec++)
    {
        ;
    }

    *lpdbl = 0.0;
    mult = 1.0;

    //
    // Do integer part
    //

    for (lpTmp = lpDec - 1; lpTmp >= lpsz; lpTmp--)
    {
        //
        // check for negative sign
        //

        if (*lpTmp == TEXT('-'))
        {
            //
            // '-' sign should only be at beginning of string
            //

            if (lpTmp == lpsz)
            {
                if (*lpdbl > 0.0)
                {
                    *lpdbl *= -1.0;
                }
                continue;
            }
            else
            {
                *lpdbl = 0.0;
                return FALSE;
            }
        }

        //
        // check for positive sign
        //

        if (*lpTmp == TEXT('+'))
        {
            //
            // '+' sign should only be at beginning of string
            //

            if (lpTmp == lpsz)
            {
                if (*lpdbl < 0.0)
                {
                    *lpdbl *= -1.0;
                }
                continue;
            }
            else
            {
                *lpdbl = 0.0;
                return FALSE;
            }
        }


        if ( (*lpTmp < TEXT('0')) || (*lpTmp > TEXT('9')) )
        {
            *lpdbl = 0.0;
            return FALSE;
        }

        *lpdbl += (mult * (double)(*lpTmp - TEXT('0')));
        mult *= 10.0;
    }

    //
    // Do decimal part
    //

    mult = 0.1;
    if (*lpDec)
    {
        for (lpTmp = lpDec + 1; *lpTmp; lpTmp++)
        {
            if ((*lpTmp < TEXT('0')) || (*lpTmp > TEXT('9')))
            {
                *lpdbl = 0.0;
                return FALSE;
            }

            *lpdbl += (mult * (double)(*lpTmp - TEXT('0')));
            mult *= 0.1;
        }
    }
    return TRUE;
}

BOOL OFC_CALLBACK FNumToSz(double *lpdbl, LPTSTR lpsz, DWORD cbMax)
{
    StringCbPrintf(lpsz, cbMax, TEXT("%g"), *lpdbl);
    return TRUE;
}

BOOL OFC_CALLBACK FUpdateStats(HWND hwndParent, LPSIOBJ lpSIObj, LPDSIOBJ lpDSIObj)
{
   return TRUE;
}

const void *rglpfnProp[] = {
    (void *) FCPConvert,
    (void *) FSzToNum,
    (void *) FNumToSz,
    (void *) FUpdateStats
};


////////////////////////////////////////////////////////////////////////////////
//
// FOfficeCreateAndInitObjects
//
// Purpose:
//  Creates and initializes all non-null args.
//
////////////////////////////////////////////////////////////////////////////////
DLLFUNC BOOL OFC_CALLTYPE FOfficeCreateAndInitObjects(LPSIOBJ *lplpSIObj, LPDSIOBJ *lplpDSIObj, LPUDOBJ *lplpUDObj)
{
    if (!FUserDefCreate (lplpUDObj, rglpfnProp))
    {
        FOfficeDestroyObjects(lplpSIObj, lplpDSIObj, lplpUDObj);
        return FALSE;
    }

    return TRUE;
} // FOfficeCreateAndInitObjects


////////////////////////////////////////////////////////////////////////////////
//
// FOfficeClearObjects
//
// Purpose:
//  Clear any non-null objects
//
////////////////////////////////////////////////////////////////////////////////
DLLFUNC BOOL OFC_CALLTYPE FOfficeClearObjects (
   LPSIOBJ  lpSIObj,
   LPDSIOBJ lpDSIObj,
   LPUDOBJ  lpUDObj)
{
    FUserDefClear (lpUDObj);

    return TRUE;

} // FOfficeClearObjects

////////////////////////////////////////////////////////////////////////////////
//
// FOfficeDestroyObjects
//
// Purpose:
//  Destroy any non-null objects
//
////////////////////////////////////////////////////////////////////////////////
DLLFUNC BOOL OFC_CALLTYPE FOfficeDestroyObjects (
   LPSIOBJ  *lplpSIObj,
   LPDSIOBJ *lplpDSIObj,
   LPUDOBJ  *lplpUDObj)
{
    FUserDefDestroy (lplpUDObj);
    return TRUE;

} // FOfficeDestroyObjects


////////////////////////////////////////////////////////////////////////////////
//
// DwOfficeLoadProperties
//
// Purpose:
//  Populate the objects with data.  lpStg is the root stream.
//
////////////////////////////////////////////////////////////////////////////////

UINT gdwFileCP = CP_ACP;

DLLFUNC DWORD OFC_CALLTYPE DwOfficeLoadProperties (
   LPSTORAGE lpStg,                     // Pointer to root storage
   LPSIOBJ   lpSIObj,                   // Pointer to Summary Obj
   LPDSIOBJ  lpDSIObj,                  // Pointer to Document Summary obj
   LPUDOBJ   lpUDObj,                   // Pointer to User-defined Obj
   DWORD     dwFlags,                   // Flags
   DWORD     grfStgMode)                // STGM flags with which to open the property set
{
    HRESULT hr = E_FAIL;
    BOOL    fSuccess = FALSE;

    LPPROPERTYSETSTORAGE lpPropertySetStorage = NULL;

    // Validate the inputs.

    if (lpStg == NULL)
        goto Exit;


    // Get the IPropertySetStorage from the IStorage.

    hr = lpStg->lpVtbl->QueryInterface( lpStg,
                                        &IID_IPropertySetStorage,
                                        &lpPropertySetStorage );
    if (FAILED (hr))
    {
        AssertSz (0, TEXT("Couldn't query for IPropertySetStorage"));
        goto Exit;
    }

    if (lpUDObj != NULL)
    {
        // Make sure we start with an empty object.

        FUserDefClear (lpUDObj);
        OfficeDirtyUDObj(lpUDObj, FALSE);

        // Load the properties into a linked-list.

        if (!FLoadUserDef (lpUDObj,
                           lpPropertySetStorage,
                           &gdwFileCP,
                           FALSE,  // Not integers only.
                           grfStgMode))
        {
            goto Exit;
        }

        OfficeDirtyUDObj (lpUDObj, FALSE);
    }

    // If none of the property sets had a code-page property, set it to
    // the current system default.

    if (gdwFileCP == CP_ACP)
        gdwFileCP = GetACP();

    fSuccess = TRUE;

Exit:

    RELEASEINTERFACE( lpPropertySetStorage );

    if (fSuccess)
    {
        return (MSO_IO_SUCCESS);
    }
    else
    {
        DebugHr (hr);
        FOfficeClearObjects (lpSIObj, lpDSIObj, lpUDObj);
        OfficeDirtyUDObj (lpUDObj, FALSE);
        return (MSO_IO_ERROR);
    }

} // DwOfficeLoadProperties

////////////////////////////////////////////////////////////////////////////////
//
// DwOfficeSaveProperties
//
// Purpose:
//  Write the data in the given objects.  lpStg is the root stream.
//
////////////////////////////////////////////////////////////////////////////////

DLLFUNC DWORD OFC_CALLTYPE DwOfficeSaveProperties (
   LPSTORAGE lpStg,                     // Pointer to root storage
   LPSIOBJ   lpSIObj,                   // Pointer to Summary Obj
   LPDSIOBJ  lpDSIObj,                  // Pointer to Document Summary obj
   LPUDOBJ   lpUDObj,                   // Pointer to User-defined Obj
   DWORD     dwFlags,                   // Flags
   DWORD     grfStgMode)                // STGM flags with which to open the property set
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr = E_FAIL;
    BOOL fSuccess = FALSE;
    LPPROPERTYSETSTORAGE lpPropertySetStorage = NULL;

    // Validate the inputs.

    if (lpStg == NULL)
    {
        AssertSz (0, TEXT("Invalid inputs to DwOfficeSaveProperties"));
        goto Exit;
    }

    // Get the IPropertySetStorage from the IStorage.

    hr = lpStg->lpVtbl->QueryInterface( lpStg,
                                        &IID_IPropertySetStorage,
                                        &lpPropertySetStorage );
    if (FAILED (hr))
    {
        AssertSz (0, TEXT("Couldn't query for IPropertySetStorage"));
        goto Exit;
    }

    //  ---------------------------------
    //  Save the User-Defined properties.
    //  ---------------------------------

    if (lpUDObj != NULL)
    {
        if (((dwFlags & OIO_SAVEIFCHANGEONLY) && (FUserDefShouldSave (lpUDObj))) ||
            !(dwFlags & OIO_SAVEIFCHANGEONLY))
        {
            if (!FSaveUserDef (lpUDObj,
                               lpPropertySetStorage,
                               GetACP(),
                               grfStgMode))
            {
                AssertSz (0, TEXT("Could not save UserDefined properties"));
                goto Exit;
            }
        }
    }


    //
    // Exit
    //

    fSuccess = TRUE;

Exit:

    RELEASEINTERFACE( lpPropertySetStorage );

    if (fSuccess)
    {
        OfficeDirtyUDObj (lpUDObj, FALSE);
        return (TRUE);
    }
    else
    {
        DebugHr (hr);
        return (FALSE);
    }

} // DwOfficeSaveProperties


///////////////////////////////////////////////////////
//
//  DwLoadPropSetRange
//
//  Purpose:
//      Load a range of properties (specified by the first and
//      last property ID) from a given PropertySetStorage.  All 
//      strings are converted to the appropriate system format
//      (LPTSTRs).
//
//  Inputs:
//      LPPROPERTYSETSTORAGE    - The set of property storage objects.
//      REFFMTID                - The Format ID of the desired property set
//      UINT *                  - A location to put the PID_CODEPAGE.  This
//                                should be initialized by the caller to a
//                                valid default, in case the PID_CODEPAGE
//                                does not exist.
//      PROPID                  - The first property in the range.
//      PROPID                  - The last property in the range.
//      PROPVARIANT[]           - An array of PropVariants, large enough
//                                for the (pidLast-pidFirst+1) properties.
//      DWORD                   - Flags from the STGM enumeration to use when
//                                opening the property storage.
//
//  Output:
//      An MSO error code.
//
//  Note:
//      When strings are converted to the system format, their
//      VarTypes are converted too.  E.g., if an ANSI VT_LPSTR is
//      read from a property set, the string will be converted
//      to Unicode, and the VarType will be changed to VT_LPWSTR.
//
////////////////////////////////////////////////////////////////////////////////

static DWORD PASCAL DwLoadPropSetRange (
   LPPROPERTYSETSTORAGE  lpPropertySetStorage,
   REFFMTID              pfmtid,
   UINT FAR *            lpuCodePage,
   PROPID                propidFirst,
   PROPID                propidLast,
   PROPVARIANT           rgpropvar[],
   DWORD                 grfStgMode)
{
    //  ------
    //  Locals
    //  ------

    DWORD dwResult = MSO_IO_ERROR;      // The return code.
    HRESULT hr;                         // OLE errors
    ULONG ulIndex;                      // Index into the rgpropvar
                                        // The requested IPropertyStorage
    LPPROPERTYSTORAGE lpPropertyStorage;
    PROPSPEC FAR * rgpropspec;          // The PropSpecs for the ReadMultiple
    PROPVARIANT propvarCodePage;        // A PropVariant with which to read the PID_CODEPAGE

                                        // The total number of properties to read.
    ULONG cProps = propidLast - propidFirst + 1;

    //  ----------
    //  Initialize
    //  ----------

    Assert (lpPropertySetStorage != NULL);
    Assert (lpPropertySetStorage->lpVtbl != NULL);
    Assert (propidLast >= propidFirst);

    lpPropertyStorage = NULL;
    PropVariantInit( &propvarCodePage );

    // Initialize the PropVariants, so that if we
    // early-exit, we'll return VT_EMPTY for all the properties.

    for (ulIndex = 0; ulIndex < cProps; ulIndex++)
        PropVariantInit (&rgpropvar[ulIndex]);

    // Allocate an array of PropSpecs.

    rgpropspec = LocalAlloc( LPTR, cProps * sizeof (*rgpropspec) );
    if (rgpropspec == NULL)
    {
        AssertSz (0, TEXT("Couldn't alloc rgpropspec"));
        goto Exit;
    }

    //  ----------------------
    //  Open the property set.
    //  ----------------------

    hr = lpPropertySetStorage->lpVtbl->Open(
                                    lpPropertySetStorage,     // this pointer
                                    pfmtid,                   // Identifies propset
                                    grfStgMode,               // STGM_ flags
                                    &lpPropertyStorage );     // Result

    if (FAILED(hr))
    {
        // We couldn't open the property set.
        if( hr == STG_E_FILENOTFOUND )
        {
            // No problem, it just didn't exist.
            dwResult = MSO_IO_SUCCESS;
            goto Exit;
        }
        else
        {
            AssertSz (0, TEXT("Couldn't open property set"));
            goto Exit;
        }
    }

    //  -------------------
    //  Read the properties
    //  -------------------

    // Initialize the local PropSpec array in preparation for a ReadMultiple.
    // The PROPIDs range from propidFirst to propidLast.

    for (ulIndex = 0; ulIndex < cProps; ulIndex++)
    {
            rgpropspec[ ulIndex ].ulKind = PRSPEC_PROPID;
            rgpropspec[ ulIndex ].propid = ulIndex + propidFirst;
    }


    // Read in the properties

    hr = lpPropertyStorage->lpVtbl->ReadMultiple (
                                        lpPropertyStorage,  // 'this' pointer
                                        cProps,             // count
                                        rgpropspec,         // Props to read
                                        rgpropvar);         // Buffers for props

    // Did we fail to read anything?

    if (hr != S_OK)
    {
        // If S_FALSE, no problem; none of the properties existed.
        if (hr == S_FALSE)
        {
            dwResult = MSO_IO_SUCCESS;
            goto Exit;
        }
        else
        {
            // Otherwise, we have a problem.
            AssertSz (0, TEXT("Couldn't read from property set"));
            goto Exit;
        }
    }

    //  -----------------
    //  Get the Code-Page
    //  -----------------

    rgpropspec[0].ulKind = PRSPEC_PROPID;
    rgpropspec[0].propid = PID_CODEPAGE;

    hr = lpPropertyStorage->lpVtbl->ReadMultiple (
                                        lpPropertyStorage,  // 'this' pointer
                                        1,                  // count
                                        rgpropspec,         // Props to read
                                        &propvarCodePage);  // Buffer for prop

    // We only set the code page if we actually read it.

    if (hr == S_OK
        &&
        propvarCodePage.vt == VT_I2)
    {
        *lpuCodePage = propvarCodePage.iVal;
    }
    //*lpuCodePage = GetACP() ;


    //  ---------------------------
    //  Correct the string formats.
    //  ---------------------------

    // E.g., if this is a Unicode system, convert LPSTRs to LPWSTRs.

    for (ulIndex = 0; ulIndex < cProps; ulIndex++)
    {
        // Is this is vector of Variants?

        if (rgpropvar[ ulIndex ].vt == (VT_VARIANT | VT_VECTOR))
        {
            // Loop through each element of the vector, converting
            // any elements which are strings.

            ULONG ulVectorIndex;

            for (ulVectorIndex = 0;
                 ulVectorIndex < rgpropvar[ ulIndex ].capropvar.cElems;
                 ulVectorIndex++)
            {
                if (PROPVAR_STRING_CONVERSION_REQUIRED (
                                    &rgpropvar[ulIndex].capropvar.pElems[ulVectorIndex],
                                    *lpuCodePage
                                    ))
                {
                    // Convert the PropVariant string, putting it in a new
                    // PropVariant.

                    PROPVARIANT propvarConvert;
                    PropVariantInit (&propvarConvert);

                    if (!FPropVarConvertString (&propvarConvert,
                                                &rgpropvar[ulIndex].capropvar.pElems[ulVectorIndex],
                                                *lpuCodePage ))
                    {
                        AssertSz (0, TEXT("Couldn't convert string"));
                        goto Exit;
                    }

                    // Clear the old PropVar, and copy in the new one.

                    PropVariantClear (&rgpropvar[ulIndex].capropvar.pElems[ulVectorIndex]);
                    rgpropvar[ulIndex].capropvar.pElems[ulVectorIndex] = propvarConvert;
                }
            }   // for (ulVectorIndex = 0; ...
        }   // if ((rgpropvar[ ulIndex ].vt == (VT_VARIANT | VT_VECTOR))

        // This isn't a Variant Vector, but is it a string
        // of some kind which requires conversion?

        else if (PROPVAR_STRING_CONVERSION_REQUIRED (
                                &rgpropvar[ ulIndex ],
                                *lpuCodePage))
        {
            // Convert the PropVariant string into a new PropVariant
            // buffer.  The string may be a singleton, or a vector.

            PROPVARIANT propvarConvert;
            PropVariantInit (&propvarConvert);

            if (!FPropVarConvertString (&propvarConvert,
                                        &rgpropvar[ ulIndex ],
                                        *lpuCodePage ))
            {
                AssertSz (0, TEXT("Couldn't convert string"));
                goto Exit;
            }

            // Free the old PropVar and load the new one.

            PropVariantClear (&rgpropvar[ ulIndex ]);
            rgpropvar[ ulIndex ] = propvarConvert;

        }   // else if (PROPVAR_STRING_CONVERSION_REQUIRED ( ...
    }   // for (ulIndex = 0; ulIndex < cProps; ulIndex++)


    //  ----
    //  Exit
    //  ----

    dwResult = MSO_IO_SUCCESS;

Exit:

    // Release the code-page just in case somebody put the wrong type
    // there (like a blob).

    PropVariantClear (&propvarCodePage);

    // Release the PropSpecs and the IPropertyStorage

    if (rgpropspec != NULL)
    {
        LocalFree(rgpropspec);
    }

    RELEASEINTERFACE (lpPropertyStorage);

    // If we failed, free the PropVariants.

    if (dwResult != MSO_IO_SUCCESS)
    {
        FreePropVariantArray( cProps, rgpropvar );
        DebugHr( hr );
    }

    return (dwResult);


} // DwLoadPropSetRange

////////////////////////////////////////////////////////////////////////////////
//
//  Wrap of IPropertySetStorage::Create
//
//  Each new ANSI property set created by docprop must set PID_CODEPAGE to CP_UTF8
//  to avoid ansi<->unicode roundtripping issues.
//
HRESULT _CreatePropertyStorage( 
    LPPROPERTYSETSTORAGE psetstg, 
    REFFMTID rfmtid,
    CLSID* pclsid, 
    DWORD grfMode,
    UINT*  /*IN OUT*/ puCodePage,
    IPropertyStorage** ppstg )
{
    
    
    DWORD grfFlags = (CP_WINUNICODE == (*puCodePage)) ? 
                            PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI;

    HRESULT hr = psetstg->lpVtbl->Create( psetstg, rfmtid, pclsid, grfFlags, grfMode, ppstg );
    if( SUCCEEDED( hr ) )
    {
        if( PROPSETFLAG_ANSI == grfFlags )
        {
            PROPSPEC    propspec = { PRSPEC_PROPID, PID_CODEPAGE };
            PROPVARIANT varCP;
            varCP.vt    = VT_I2;
            varCP.iVal  = (SHORT)CP_UTF8;
            if( SUCCEEDED( (*ppstg)->lpVtbl->WriteMultiple( *ppstg, 1, &propspec, &varCP, PID_UDFIRST ) ) )
                *puCodePage = (UINT)MAKELONG(varCP.iVal, 0);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////
//
//  DwSavePropSetRange
//
//  Purpose:
//      Save a range of properties to a Property Set Storage.
//      The properties to be saved are provided in an
//      array of PropVariants, and their property IDs are
//      specified by the first and last PID for the range.
//      The caller may also specify that a property be
//      "skipped", i.e., not written.
//
//  Inputs:
//      LPPROPERTYSETSTORAGE    - The Property Set Storage
//      UINT                    - The code page with which the strings
//                                should be written.
//      REFFMTID                - The GUID identifying the Property Storage
//                                within the Property Set Storage.
//      PROPID                  - The PID to assign to the first property.
//      PROPID                  - The PID to assign to the last property
//      PROPVARIANT []          - The propeties to write.  All strings
//                                are assumed to be in the system format
//                                (e.g. VT_LPWSTRs for NT).  This array
//                                is returned un-modified to the caller.
//      PROPID                  - If non-zero, identifies a property
//                                which should not be written, even if
//                                it is non-empty.  If the property exists
//                                in the property set, it will be deleted.
//                                (This was added to provide a way to skip
//                                the PID_THUMBNAIL.)
//      DWORD                   - Flags from the STGM enumeration to use when
//                                opening the property storage.
//
//  Output:
//      An MSO error code.
//
//  Notes:
//      - If the code page is Unicode, all strings are written as LPWSTRs,
//        otherwise, they are written as LPSTRs.
//      - Only non-empty properties are written.
//
//  Implementation:
//      This routine creates a new PropVariant array which is the
//      subset of the caller's PropVariant array which must actually
//      be written (i.e, it doesn't include the VT_EMPTY properties
//      or the 'propidSkip').
//
//      We allocate as little extra memory as possible.  For example,
//      if we have to write a string, we'll copy the pointer to the
//      string into the subset PropVariant array.  Thus we'll have 
//      two pointers to the string.
//
//      If a string to be written must be converted first (to another
//      code-page), then the original PropVariant array will continue
//      pointing to the original string, and the subset PropVariant
//      array will point to the converted string (and must consequently
//      be freed).
//
////////////////////////////////////////////////////////////////////////////////

static DWORD PASCAL DwSavePropSetRange (
   LPPROPERTYSETSTORAGE  lpPropertySetStorage,
   UINT                  uCodePage,
   REFFMTID              pfmtid,
   PROPID                propidFirst,
   PROPID                propidLast,
   PROPVARIANT           rgpropvarOriginal[],
   PROPID                propidSkip,
   DWORD                 grfStgMode)
{
    //  ------
    //  Locals
    //  ------

    DWORD   dwResult = MSO_IO_ERROR;    // The functions return code.
    HRESULT hr;                         // OLE results.
                                        // The Property Storage to write to
    LPPROPERTYSTORAGE lpPropertyStorage = NULL;

    ULONG cOriginal;    // The size of rgpropvarOriginal,
    ULONG cNew;         //    and the number which must actually be written.
    ULONG ulIndex;      // Index into rgpropvarOriginal

    PROPSPEC FAR * rgpropspecNew = NULL;// PropSpecs for the WriteMultiple
    LPPROPVARIANT  rgpropvarNew = NULL; // The sub-set of rgpropvarOrigianl we must write.

    // The following array has an entry for each entry in rgpropvarNew.
    // Each entry identifies the corresponding entry in rgpropvarOriginal.
    // E.g. rgMapNewToOriginal[0] is the index in rgpropvarOriginal of
    // the first property to be written.

    ULONG  *rgMapNewToOriginal = NULL;

    //  ----------
    //  Initialize
    //  ----------

    cOriginal = propidLast - propidFirst + 1;
    cNew = 0;

    Assert (cOriginal <= max(NUM_SI_PROPERTIES, NUM_DSI_PROPERTIES));

    Assert (lpPropertySetStorage != NULL);
    Assert (lpPropertySetStorage->lpVtbl != NULL);
    Assert (propidLast >= propidFirst);
    Assert (rgpropvarOriginal != NULL);

    // Allocate an array of PropSpecs for the WriteMultiple.

    rgpropspecNew = LocalAlloc( LPTR, cOriginal * sizeof (*rgpropspecNew));
    if (rgpropspecNew == NULL)
    {
        AssertSz (0, TEXT("Couldn't alloc rgpropspecNew"));
        goto Exit;
    }

    // Allocate an array of PropVariants which will hold the subset
    // of the caller's properties which must be written.
    // Initialize to zeros so that we don't think we have memory
    // to free in the error path.

    rgpropvarNew = LocalAlloc( LPTR, cOriginal * sizeof (*rgpropvarNew));
    if (rgpropvarNew == NULL)
    {
        AssertSz (0, TEXT("Couldn't alloc rgpropvarNew"));
        goto Exit;
    }

    // Allocate the look-up-table which maps entries in rgpropvarNew
    // to rgpropvarOriginal

    rgMapNewToOriginal = LocalAlloc( LPTR, cOriginal * sizeof(*rgMapNewToOriginal));
    if (rgMapNewToOriginal == NULL)
    {
        AssertSz (0, TEXT("Couldn't alloc rgMapNewToOriginal"));
        goto Exit;
    }

    //  -------------------------
    //  Open the Property Storage
    //  -------------------------

    hr = lpPropertySetStorage->lpVtbl->Open(
                                    lpPropertySetStorage,     // this pointer
                                    pfmtid,
                                    grfStgMode,
                                    &lpPropertyStorage );


    // If it didn't exist, create it.

    if( hr == STG_E_FILENOTFOUND )
    {
        hr = _CreatePropertyStorage( lpPropertySetStorage, 
                                     pfmtid,
                                     NULL,
                                     STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                     &uCodePage,
                                     &lpPropertyStorage );
    }

    // Check the result of the open/create.

    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't open property set"));
        goto Exit;
    }


    //  ---------------------------------------------------
    //  Copy the properties to be written into rgpropvarNew
    //  ---------------------------------------------------

    // Loop through all the properties in rgpropvarOriginal

    for (ulIndex = 0; ulIndex < cOriginal; ulIndex++)
    {
        // Is this property extant and not the one to skip?

        if (rgpropvarOriginal[ ulIndex ].vt != VT_EMPTY
            &&
            ( propidSkip == 0
              ||
              propidSkip != propidFirst + ulIndex )
           )
        {
            // We have a property which must be written.

            BOOL    fVector;
            VARTYPE vt;

            // Record a mapping from the new index to the original.

            rgMapNewToOriginal[ cNew ] = ulIndex;

            // Add an entry to the PropSpec array.

            rgpropspecNew[ cNew ].ulKind = PRSPEC_PROPID;
            rgpropspecNew[ cNew ].propid = propidFirst + ulIndex;

            // Get the underlying VarType.

            fVector = (rgpropvarOriginal[ ulIndex ].vt & VT_VECTOR) ? TRUE : FALSE;
            vt      = rgpropvarOriginal[ ulIndex ].vt & ~VT_VECTOR;

            // If this property is a vector of variants, some of those
            // elements may be strings which need to be converted.

            if ((vt == VT_VARIANT) && fVector)
            {
                ULONG ulVectorIndex;

                // We'll inintialize the capropvar.pElems in rgpropvarNew
                // so that it points to the one in rgpropvarOriginal.  We'll
                // only allocate if a conversion is necessary.  I.e., we handle
                // pElems as a copy-on-write.

                rgpropvarNew[ cNew ] = rgpropvarOriginal[ ulIndex ];

                // Loop through the elements of the vector.

                for (ulVectorIndex = 0;
                     ulVectorIndex < rgpropvarNew[ cNew ].capropvar.cElems;
                     ulVectorIndex++)
                {
                    // Is this a string requiring a code-page conversion?

                    if (PROPVAR_STRING_CONVERSION_REQUIRED(
                                        &rgpropvarOriginal[ulIndex].capropvar.pElems[ulVectorIndex],
                                        uCodePage ))
                    {
                        // We must convert this string.  Have we allocated a pElems yet?

                        if (rgpropvarNew[cNew].capropvar.pElems
                            == rgpropvarOriginal[ulIndex].capropvar.pElems)
                        {
                            // Allocate a new pElems for rgpropvarNew

                            rgpropvarNew[cNew].capropvar.pElems
                                = CoTaskMemAlloc (rgpropvarNew[cNew].capropvar.cElems
                                                  * sizeof(*rgpropvarNew[cNew].capropvar.pElems));
                            if (rgpropvarNew[cNew].capropvar.pElems == NULL)
                            {
                                AssertSz (0, TEXT("Couldn't allocate pElems"));
                                goto Exit;
                            }

                            // Initialize it to match that in rgpropvarOriginal

                            CopyMemory( rgpropvarNew[cNew].capropvar.pElems,
                                        rgpropvarOriginal[ulIndex].capropvar.pElems,
                                        rgpropvarNew[cNew].capropvar.cElems * sizeof(*rgpropvarNew[cNew].capropvar.pElems)
                                      );
                        }

                        // Now, we can convert this string from rgpropvarOriginal into
                        // rgpropvarNew.

                        PropVariantInit (&rgpropvarNew[cNew].capropvar.pElems[ulVectorIndex]);
                        if (!FPropVarConvertString(&rgpropvarNew[cNew].capropvar.pElems[ulVectorIndex],
                                                   &rgpropvarOriginal[ulIndex].capropvar.pElems[ulVectorIndex],
                                                   uCodePage))
                        {
                            AssertSz(0, TEXT("Couldn't convert code page of string"));
                            goto Exit;
                        }

                    }   // if (PROPVAR_STRING_CONVERSION_REQUIRED( ...
                }   // for (ulVectorIndex = 0; ...
            }   // if (vt == VT_VARIANT && fVector)

            // This isn't a variant vector, but is it some type of string
            // property for which we must make a conversion?

            else if (PROPVAR_STRING_CONVERSION_REQUIRED (
                                        &rgpropvarOriginal[ ulIndex ],
                                        uCodePage))
            {
                PropVariantInit (&rgpropvarNew[cNew]);
                if (!FPropVarConvertString (&rgpropvarNew[cNew],
                                            &rgpropvarOriginal[ulIndex],
                                            uCodePage))
                {
                    AssertSz (0, TEXT("Couldn't convert string"));
                    goto Exit;
                }

            }   // else if (PROPVAR_STRING_CONVERSION_REQUIRED ( ...

            // If neither of the above special-cases were triggered,
            // then simply copy the PropVariant structure (but not
            // any referred-to data).  We save memory by not duplicating
            // the referred-to data, but we must be careful in the exit
            // not to free it.

            else
            {
                rgpropvarNew[cNew] = rgpropvarOriginal[ulIndex];

            }   // if ((vt == VT_VARIANT) && fVector) ... else


            // We're done copying/converting this property from rgpropvarOriginal
            // into rgpropvarNew.

            cNew++;

        }   // if (rgpropvarOriginal[ ulIndex ].vt != VT_EMPTY ...
    }   // for (ulIndex = 0; ulIndex < cProps; ulIndex++)


    //  ------------------------
    //  Write out the properties
    //  ------------------------

    
    // Write out properties if we found any.

    if (cNew > 0)
    {
        hr = lpPropertyStorage->lpVtbl->WriteMultiple (
                                            lpPropertyStorage,  // 'this' pointer
                                            cNew,               // Count
                                            rgpropspecNew,      // Props to write
                                            rgpropvarNew,       // The props
                                            PID_UDFIRST);

        if (FAILED(hr))
        {
            AssertSz (0, TEXT("Couldn't write properties"));
            goto Exit;
        }
    }   // if (cNew > 0)

    //  ---------------------
    //  Delete the propidSkip
    //  ---------------------

    // If the caller specified a PID to skip, then it should
    // be deleted from the property set as well.

    if (propidSkip != 0)
    {
        rgpropspecNew[0].ulKind = PRSPEC_PROPID;
        rgpropspecNew[0].propid = propidSkip;

        hr = lpPropertyStorage->lpVtbl->DeleteMultiple (
                                            lpPropertyStorage,  // this pointer
                                            1,                  // Delete one property
                                            rgpropspecNew );    // The prop to delete
        if (FAILED(hr))
        {
            AssertSz (0, TEXT("Couldn't delete the propidSkip"));
            goto Exit;
        }
    }


    //  ----
    //  Exit
    //  ----

    dwResult = MSO_IO_SUCCESS;

Exit:

    // Clear any of the properties in rgpropvarNew for which new
    // buffers were allocated.  Then free the rgpropvarNew array itself.
    // We know that buffers were allocated for rgpropvarNew if it's contents
    // don't match rgpropvarOriginal.

    if (rgpropvarNew != NULL)
    {
        // Loop through rgpropvarNew

        for (ulIndex = 0; ulIndex < cNew; ulIndex++)
        {
            // Was memory allocated for this rgpropvarNew?

            if (memcmp (&rgpropvarNew[ ulIndex ],
                        &rgpropvarOriginal[ rgMapNewToOriginal[ulIndex] ],
                        sizeof(rgpropvarNew[ ulIndex ])))
            {
                // Is this a variant vector?

                if (rgpropvarNew[ulIndex].vt == (VT_VECTOR | VT_VARIANT))
                {
                    ULONG ulVectIndex;

                    // Loop through the variant vector and free any PropVariants
                    // that were allocated.  We follow the same principle, if the
                    // entry in rgpropvarNew doesn't match the entry in 
                    // rgpropvarOriginal, we must have allocated new memory.

                    for (ulVectIndex = 0;
                         ulVectIndex < rgpropvarNew[ulIndex].capropvar.cElems;
                         ulVectIndex++)
                    {
                        if (memcmp(&rgpropvarNew[ ulIndex ].capropvar.pElems[ ulVectIndex ],
                                   &rgpropvarOriginal[ rgMapNewToOriginal[ulIndex] ].capropvar.pElems[ ulVectIndex ],
                                   sizeof(rgpropvarNew[ ulIndex ].capropvar.pElems[ ulVectIndex ])))
                        {
                            PropVariantClear (&rgpropvarNew[ulIndex].capropvar.pElems[ulVectIndex]);
                        }
                    }

                    // Unconditionally free the pElems buffer.

                    CoTaskMemFree (rgpropvarNew[ulIndex].capropvar.pElems);

                }   // if (rgpropvarNew[ulIndex].vt == (VT_VECTOR | VT_VARIANT))

                // This isn't a variant vector

                else
                {
                    // But does the rgpropvarNew have private memory (i.e.
                    // a converted string buffer)?

                    if (memcmp (&rgpropvarNew[ ulIndex ],
                                &rgpropvarOriginal[ rgMapNewToOriginal[ulIndex] ],
                                sizeof(rgpropvarNew[ ulIndex ])))
                    {
                        PropVariantClear (&rgpropvarNew[ulIndex]);
                    }
                }   // if (rgpropvarNew[ulIndex].vt == (VT_VECTOR | VT_VARIANT)) ... else
            }   // if (rgpropvarNew[ulIndex] ...
        }   // for (ulIndex = 0; ulIndex < cNew; ulIndex++)

        // Free the rgpropvarNew array itself.

        LocalFree(rgpropvarNew);

    }   // if (rgpropvarNew != NULL)

    // Free the remaining arrays and release the Property Storage interface.

    if (rgpropspecNew != NULL)
    {
        LocalFree(rgpropspecNew);
    }

    if (rgMapNewToOriginal != NULL)
    {
        LocalFree(rgMapNewToOriginal);
    }

    RELEASEINTERFACE (lpPropertyStorage);


    // And we're done.

    return (dwResult);

} // DwSavePropSetRange


////////////////////////////////////////////////////////////////////////////////
//
//  FLoadUserDef
//
//  Purpose:
//      Load the User-Defined properties (those in the second section of
//      the DocumentSummaryInformation property set).  There can be any number
//      of these properties, and the user specifies they're name, value, and
//      type (from a limited subset of the VarTypes).  Since this is
//      variable-sized, the properties are loaded into a linked-list.
//
//  Inputs:
//      LPUDOBJ                 - All User-Defined data (including the properties).
//                                Its m_lpData must point to a valid UDINFO structure.
//      LPPROPERTYSETSTORAGE    - The Property Set Storage in which we'll find the
//                                UD property storage.
//      UINT*                   - The PID_CODEPAGE, if it exists.  Left unmodified
//                                if it doesn't exist. All string properties will
//                                converted to this format.  This must be intialized
//                                by the caller to a valid default.
//      BOOL                    - Only load integer values.
//      DWORD                   - Flags from the STGM enumeration to use when opening
//                                the property storage.
//
////////////////////////////////////////////////////////////////////////////////

static BOOL PASCAL FLoadUserDef  (
   LPUDOBJ              lpUDObj,
   LPPROPERTYSETSTORAGE lpPropertySetStorage,
   UINT                 *puCodePage,
   BOOL                 fIntOnly,        // Load Int Properties only?
   DWORD                grfStgMode)
{

    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;   // Return code to the caller.
    HRESULT hr;                 // Error codes for OLE calls.

    LPPROPERTYSTORAGE   lpPropertyStorage = NULL;   // The UD property storage
    LPENUMSTATPROPSTG   lpEnum = NULL;              // Enumerates the UD property storage
    STATPROPSETSTG      statpropsetstg;             // Holds the ClassID from the property storage

                                                    // Used in ReadMultiple call.
    PROPSPEC            rgpropspec[ DEFAULT_IPROPERTY_COUNT ];
                                                    // A subset of the UD properties
    PROPVARIANT         rgpropvar[ DEFAULT_IPROPERTY_COUNT ];
                                                    // Stats on a subset of the UD properties
    STATPROPSTG         rgstatpropstg[ DEFAULT_IPROPERTY_COUNT ];
    ULONG         ulIndex;                          // Index into the above arrays.

    PROPSPEC      propspec;         // PropSpec for reading the code-page
    LPUDPROP      lpudprop = NULL;  // A single UD property (points to the PropVariant)
    ULONG         cEnumerated = 0;  // Number of properties found in an enumeration


    //  --------------
    //  Initialization
    //  --------------

    Assert (!fIntOnly); // No longer used.
    Assert (lpUDObj != NULL && GETUDINFO(lpUDObj) != NULL);
    Assert (puCodePage != NULL);

    // We need to zero-out the PropVariant and StatPropStg
    // arrays so that we don't think they need to be freed
    // in the Exit block.

    ZeroMemory(rgpropvar, sizeof (rgpropvar));
    ZeroMemory(rgstatpropstg, sizeof (rgstatpropstg));


    //  -----------------------------------------
    //  Get the PropertyStorage and an Enumerator
    //  -----------------------------------------

    // Open the IPropertyStorage and check for errors.

    hr = lpPropertySetStorage->lpVtbl->Open(
                                    lpPropertySetStorage,     // this pointer
                                    &FMTID_UserDefinedProperties,
                                    grfStgMode,
                                    &lpPropertyStorage );

    if (FAILED(hr))
    {
        // We couldn't open the property set.
        if( hr == STG_E_FILENOTFOUND )
        {
            // No problem, it just didn't exist.
            fSuccess = TRUE;
            goto Exit;
        }
        else
        {
            AssertSz (0, TEXT("Couldn't open property set"));
            goto Exit;
        }
    }
    
    // Save the property storage's class ID (identifying the application
    // which is primarily responsible for it).  We do this because
    // we may later delete the existing property set.

    hr = lpPropertyStorage->lpVtbl->Stat (lpPropertyStorage, &statpropsetstg);
    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't Stat the Property Storage"));
        goto Exit;
    }

    GETUDINFO(lpUDObj)->clsid = statpropsetstg.clsid;


    // Get the IEnum interface and check for errors.

    hr = lpPropertyStorage->lpVtbl->Enum(
                                    lpPropertyStorage,
                                    &lpEnum );
    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't enumerate the PropertyStorage"));
        goto Exit;
    }

    //  ------------------
    //  Read the Code Page
    //  ------------------

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_CODEPAGE;

    hr = lpPropertyStorage->lpVtbl->ReadMultiple (lpPropertyStorage, 1, &propspec, &rgpropvar[0]);
    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't get property set"));
    }

    // If this is a valid PID_CODEPAGE, give it to the caller.

    if (hr == S_OK && rgpropvar[0].vt == VT_I2)
    {
        *puCodePage = (UINT)MAKELONG(rgpropvar[0].iVal, 0);
    }
    PropVariantClear (&rgpropvar[0]);


    //  -------------------------------------------------------------
    //  Loop through the properties and add to the UDPROPS structure.
    //  -------------------------------------------------------------

    // This loop executes once for each enumeration.  Each enumeration
    // gets multiple STATPROPSTGs, so within this loop an inner loop
    // will process each property.  This two-level looping mechanism is
    // used in order to reduce the number of ReadMultiples.

    // Use the IEnum to load the first set of STATPROPSTGs.

    hr = lpEnum->lpVtbl->Next (lpEnum, DEFAULT_IPROPERTY_COUNT, rgstatpropstg, &cEnumerated);
    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't get next StatPropStg"));
        goto Exit;
    }
    Assert (cEnumerated <= DEFAULT_IPROPERTY_COUNT);

    // If the last IEnum returned properties, process them here.
    // At the end of this while loop, we re-call the IEnum, thus continuing
    // until no properties are left to be enumerated.

    while (cEnumerated)
    {
        //  ------------------------------
        //  Read this batch of properties.
        //  ------------------------------

        for (ulIndex = 0; ulIndex < cEnumerated; ulIndex++)
        {
            rgpropspec[ ulIndex ].ulKind = PRSPEC_PROPID;
            rgpropspec[ ulIndex ].propid = rgstatpropstg[ ulIndex ].propid;

        }


        // Read the properties.

        hr = lpPropertyStorage->lpVtbl->ReadMultiple(
                                        lpPropertyStorage,
                                        cEnumerated,
                                        rgpropspec,
                                        rgpropvar );
        if (FAILED(hr))
        {
            AssertSz (0, TEXT("Couldn't read from property set"));
            goto Exit;
        }

        //  ------------------------------------------------------
        //  Loop through the properties, adding them to the UDOBJ.
        //  ------------------------------------------------------

        for (ulIndex = 0; ulIndex < cEnumerated; ulIndex++)
        {
            // Convert string PropVariants to the right code page.
            // We won't worry about Variants which are strings, because
            // this is not a legal type for the UD properties.

            if (PROPVAR_STRING_CONVERSION_REQUIRED (
                            &rgpropvar[ ulIndex ],
                            *puCodePage))
            {
                // Convert the string in the PropVariant, putting the
                // result in a temporary PropVariant.

                PROPVARIANT propvarConvert;
                PropVariantInit (&propvarConvert);

                if (!FPropVarConvertString (&propvarConvert,
                                            &rgpropvar[ulIndex],
                                            *puCodePage))
                {
                    AssertSz (0, TEXT("Couldn't convert string"));
                    goto Exit;
                }

                // Free the old PropVariant, and load in the converted
                // one.

                PropVariantClear (&rgpropvar[ ulIndex ]);
                rgpropvar[ ulIndex ] = propvarConvert;
            }

            // Allocate a new UDPROP structure, which will be added to the
            // linked-list.

            lpudprop = LpudpropCreate();
            if (lpudprop == NULL)
            {
                goto Exit;
            }

            // Add this UDPROP to the linked-list.  On success, this will assume
            // responsibility for the PropVariant and STATPROPSTG buffers, and
            // will NULL out our pointers accordingly.

            if (!FAddPropToList (lpUDObj,
                                 &rgpropvar[ ulIndex ],
                                 &rgstatpropstg[ ulIndex ],
                                 lpudprop))
            {
                goto Exit;
            }

            lpudprop = NULL;

        }   // for (ulIndex = 0; ulIndex < cEnumerated; ulIndex++)


        //  ---------------------
        //  Get a new enumeration
        //  ---------------------

        // We've processed all the properties in the last enumeration, let's get
        // a new set (if there are any).  If there are no more, cEnumerated, will be
        // zero, and we'll break out of the outer while loop.

        FreePropVariantArray( cEnumerated, rgpropvar );

        hr = lpEnum->lpVtbl->Next (lpEnum, DEFAULT_IPROPERTY_COUNT, rgstatpropstg, &cEnumerated);
        if (FAILED(hr))
        {
            AssertSz (0, TEXT("Couldn't get next StatPropStg"));
            goto Exit;
        }

    }   // while (cEnumerated)


    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    // Free any properties with buffers.  This will only happen
    // if there was an error.

    if (cEnumerated > 0)
    {
        FreePropVariantArray (cEnumerated, rgpropvar);
    }

    // Again if there was an error, we must free the UDPROP object.

    if (lpudprop)
    {
        VUdpropFree (&lpudprop);
    }

    // Free any name buffers we still have from the enumerations.
    // Once again, this is only necessary if there was an error.

    for (ulIndex = 0; ulIndex < cEnumerated; ulIndex++)
    {
        if (rgstatpropstg[ ulIndex ].lpwstrName != NULL)
        {
            CoTaskMemFree (rgstatpropstg[ ulIndex ].lpwstrName);
        }
    }

    // Release the Property Storage and Enumeration interfaces.

    RELEASEINTERFACE (lpEnum);
    RELEASEINTERFACE (lpPropertyStorage);


    return fSuccess;

} // FLoadUserDef


////////////////////////////////////////////////////////////////////////////////
//
//  FSaveUserDef
//
//  Purpose:
//      Save the User-Defined properties to the second section of
//      the DocumentSummaryInformation property set.
//  
//  Inputs:
//      LPUDOBJ                 - All UD data (including the properties)
//                                It's m_lpData must point to a valid UDINFO structure.
//      LPPROPERTYSETSTORAGE    - The Property Set Storage
//      UINT                    - The code page in which strings should be
//                                written.  If Unicode, all strings are
//                                written as LPWSTRs, otherwise all strings
//                                are written as LPSTRs.
//      DWORD                   - Flags from the STGM enumeration to use when
//                                opening the property storage.
//
//  Outputs:
//      TRUE if successful.
//
//  Pre-conditions:
//      The properties to be written are all from the UDTYPES
//      enumeration.
//
//  Implementation:
//      Properties which are links to application data require special
//      handling.  First, the property value is written (along with its
//      name).  Then, the application-defined link name is
//      written (e.g. the Bookmark name in Word).  The link name
//      is written using the same PID as was the link value, except that
//      the PID_LINKMASK is ORed in.  The link name property has no name
//      in the property set dictionary.
//
////////////////////////////////////////////////////////////////////////////////

static
BOOL PASCAL FSaveUserDef  (
   LPUDOBJ              lpUDObj,
   LPPROPERTYSETSTORAGE lpPropertySetStorage,
   UINT                 uCodePage,
   DWORD                grfStgMode)
{
    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;  // What to return to the caller.
    HRESULT hr;                // OLE result codes.

    BOOL fLink, fLinkInvalid;

                                            // The UD Property Storage
    LPPROPERTYSTORAGE lpPropertyStorage = NULL;
    LPUDITER          lpudi = NULL;         // Iterates the linked-list of UDPROPs
    LPPROPVARIANT     lppropvar = NULL;     // A property from the linked-list
    ULONG             ulIndex;              // Generic index into arrays
    PROPID            propid;               // The PID to assign to the next property

    // Arrays to be used in the WriteMultiple.  The array of BOOLs
    // indicate which elements of the PropVariant array must be freed.

    ULONG             ulPropIndex = 0;
    PROPSPEC          rgpropspec[ DEFAULT_IPROPERTY_COUNT ];
    PROPVARIANT       rgpropvar[ DEFAULT_IPROPERTY_COUNT ];
    BOOL              rgfFreePropVar[ DEFAULT_IPROPERTY_COUNT ];

    // Arrays to be used in the WritePropertyNames.

    ULONG             ulNameIndex = 0;
    PROPID            rgpropidName[ DEFAULT_IPROPERTY_COUNT ];
    LPWSTR            rglpwstrName[ DEFAULT_IPROPERTY_COUNT ];

    //  ----------
    //  Initialize
    //  ----------

    Assert (lpUDObj != NULL && GETUDINFO(lpUDObj) != NULL);
    Assert (lpPropertySetStorage != NULL && lpPropertySetStorage->lpVtbl != NULL);

    // Initialize the necessary arrays, so that we don't unnecessarily
    // free something in the Error path.

    ZeroMemory(rgpropvar, sizeof(rgpropvar));
    ZeroMemory(rgfFreePropVar, sizeof(rgfFreePropVar));
    ZeroMemory(rglpwstrName, sizeof(rglpwstrName));

    // Delete the existing property set and create a new empty one.
    // We must do this because we don't know which of the
    // existing properties need to be deleted, we only know what
    // the current set of properties should be.

    hr = lpPropertySetStorage->lpVtbl->Delete(
                                    lpPropertySetStorage,
                                    &FMTID_UserDefinedProperties );
    if (FAILED(hr))
    {
        if (hr != STG_E_FILENOTFOUND)
        {
            AssertSz (0, TEXT("Couldn't remove old properties"));
            goto Exit;
        }
    }

    hr = _CreatePropertyStorage( lpPropertySetStorage,
                                 &FMTID_UserDefinedProperties,
                                 &GETUDINFO(lpUDObj)->clsid,
                                 grfStgMode,
                                 &uCodePage,
                                 &lpPropertyStorage );

    if (FAILED(hr))
    {
        AssertSz (0, TEXT("Couldn't open User-Defined property set"));
        goto Exit;
    }


    // Create an iterator which we use to enumerate the properties
    // (UDPROPs) in the linked-list.

    lpudi = LpudiUserDefCreateIterator (lpUDObj);

    //  ------------------------------------------------------------------
    //  Loop through the properties and write them to the UD property set.
    //  ------------------------------------------------------------------

    // We use a two-layer loop.  The inner loop batches a group of properties
    // in a PropVariant array, and then writes them to the Property Storage.
    // The outer loop repeats this process until there are no more properties.
    // This two-layer mechanism is desirable so that we reduce the number
    // of WriteMultiple calls.

    propid = PID_UDFIRST;
    fLink = FALSE;

    while (TRUE)
    {

        //  ------------------------------------------
        //  Batch up a set of properties to be written
        //  ------------------------------------------

        ulPropIndex = ulNameIndex = 0;

        // We will break out of this loop when we have no more properties
        // or if we have enough for a WriteMultiple.

        while (FUserDefIteratorValid (lpudi))
        {
            Assert (lpudi->lpudp != NULL);

            //  ----------------------------------------------------------------------
            //  Create entries in the arrays for WriteMultiple and WritePropertyNames.
            //  ----------------------------------------------------------------------

            // If fLink is TRUE, it means that we've written out the
            // property, and now we need to write out the link name
            // (with the PID_LINKMASK ORed into the propid).

            if (!fLink)
            {
                // We aren't writing a link.  So let's get the
                // property from the linked-list (we know it exists because
                // FUserDefIteratorValid was true).

                lppropvar 
                    = LppropvarUserDefGetIteratorVal (lpudi, NULL, NULL);
                if (lppropvar == NULL)
                {
                    AssertSz (0, TEXT("Invalid PropVariant in iterator"));
                    goto Exit;
                }

                // Copy this propvariant into the array which will be used for
                // the WriteMultiple.  Note that we do not copy any referenced
                // buffer (e.g. we don't copy the string buffer if this is a string).

                rgpropvar[ ulPropIndex ] = *lppropvar;

                // If this property has a name, prepare to write it.

                if (lpudi->lpudp->lpstzName != NULL)
                {
                    // Add this name to rglpwstrName & rgpropidName.

                    // Add this name to the list of those to be written.

                    rglpwstrName[ ulNameIndex ] = lpudi->lpudp->lpstzName;

                    // Add this propid to the list of those with names.

                    rgpropidName[ ulNameIndex ] = propid;

                }   // if (lpudi->lpudp->lpstzName != NULL)
            }   // if (!fLink)

            else
            {
                // We are processing a link name.  I.e., we've written the
                // property value, now we need to write the name of the link,
                // as a property, with the PID_LINKSMASK bit set in the PID.

                Assert (lpudi->lpudp->lpstzLink != NULL);

                // Create a entry in the PropVariant.

                rgpropvar[ ulPropIndex ].vt = VT_LPTSTR;
                (LPTSTR) rgpropvar[ ulPropIndex ].pszVal = lpudi->lpudp->lpstzLink;
            }

            // rgpropvar[ulPropIndex] now holds the property to be written,
            // whether it is a real property or a link name.

            //  ------------------------------------
            //  Convert strings to the proper format.
            //  -------------------------------------

            // (This could also convert the type from LPWSTR to LPSTR, or vice-versa).

            // We don't have to worry about strings in vectors or in 
            // variant vectors, because these are illegal types for this
            // property set.

            if (rgpropvar[ ulPropIndex ].vt == VT_LPTSTR)
            {
                // If this string needs to be converted do so, putting the converted
                // string in a new buffer.  So,
                // the caller's PropVariant still points to the old buffer,
                // and our rgpropvar points to the new buffer.

                if (PROPVAR_STRING_CONVERSION_REQUIRED (
                                    &rgpropvar[ ulPropIndex ],
                                    uCodePage))
                {                             
                    // Convert the string into a temporary PropVariant.

                    PROPVARIANT propvarConvert;
                    PropVariantInit (&propvarConvert);

                    if (!FPropVarConvertString (&propvarConvert, 
                                                &rgpropvar[ ulPropIndex ],
                                                uCodePage ))
                    {
                        AssertSz (0, TEXT("Couldn't convert string"));
                        goto Exit;
                    }

                    // Load this new PropVariant into rgpropvar, but don't
                    // delete the old buffer (so that we leave the linked-list
                    // of UDPROPs intact).

                    rgpropvar[ ulPropIndex ] = propvarConvert;

                    // Since we just created a new buffer, we must remember to free it.
                    rgfFreePropVar[ ulPropIndex ] = TRUE;

                }   // if (PROPVAR_STRING_CONVERSION_REQUIRED ( ...
            }   // if (rgpropvar[ ulPropIndex ].vt == VT_LPTSTR)


            //  --------------------------
            //  Finish this loop iteration
            //  --------------------------

            // Set up the PropSpec.

            rgpropspec[ ulPropIndex ].ulKind = PRSPEC_PROPID;
            rgpropspec[ ulPropIndex ].propid = propid;

            // If this is a link name, set the bit in the PID.

            if (fLink)
            {
                rgpropspec[ ulPropIndex ].propid |= PID_LINKMASK;
            }

            // Advance the property index.  And if we set a name, advance
            // the name index.

            ulPropIndex++;
            if (rglpwstrName[ ulNameIndex ] != NULL)
            {
                ulNameIndex++;
            }

            // If we've just processed a link, or this is a property
            // which is not linked to application content, then move on to the next property
            // in the iterator.  If we've just processed a property value that
            // is linked, set fLink so that on the next pass through
            // this loop, we'll write out the link name.

            if (fLink || !FUserDefIteratorIsLink (lpudi))
            {
                fLink = FALSE;
                propid++;
                FUserDefIteratorNext (lpudi);
            }
            else
            {
                fLink = TRUE;
            }

            // If there's no more room in the WriteMultiple arrays,
            // then write out the properties.  We'll return to this
            // inner loop when that's complete.

            if (ulPropIndex >= DEFAULT_IPROPERTY_COUNT)
            {
                break;
            }
        }   // while (FUserDefIteratorValid (lpudi))

        // If broke out of the previous loop becuase there were no
        // more properties, then we can break out of the outer loop
        // as well -- we're done.

        if (ulPropIndex == 0)
        {
            break;
        }

        //  ---------------------
        //  Write the properties.
        //  ---------------------

        hr = lpPropertyStorage->lpVtbl->WriteMultiple (
                                            lpPropertyStorage,  // 'this' pointer
                                            ulPropIndex,        // Number of properties
                                            rgpropspec,         // Property specifiers
                                            rgpropvar,          // The properties
                                            PID_UDFIRST);       // Not used.
        if (FAILED(hr))
        {
            AssertSz (0, TEXT("Couldn't write properties"));
            goto Exit;
        }

        // If we created any new buffers during string conversion,
        // free them now.

        for (ulIndex = 0; ulIndex < ulPropIndex; ulIndex++)
        {
            if (rgfFreePropVar[ ulIndex ])
            {
                PropVariantClear (&rgpropvar[ ulIndex ]);
                rgfFreePropVar[ ulIndex ] = FALSE;
            }
        }

        //  ----------------
        //  Write the Names.
        //  ----------------

        if (ulNameIndex != 0)
        {

            hr = lpPropertyStorage->lpVtbl->WritePropertyNames (
                                                lpPropertyStorage,  // 'this' pointer
                                                ulNameIndex,        // Number of names
                                                rgpropidName,       // PIDs for these names
                                                rglpwstrName );     // The names
            if (FAILED(hr))
            {
                AssertSz (0, TEXT("Couldn't write property names"));
                goto Exit;
            }
        }   // if (ulNameIndex != 0)

        // Clear the names array.

        for (ulIndex = 0; ulIndex < ulNameIndex; ulIndex++)
        {
            rglpwstrName[ ulIndex ] = NULL;
        }
    }


    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    // Free the iterator

    if (lpudi)
    {
        FUserDefDestroyIterator (&lpudi);
    }

    // Free any memory that was allocated for PropVariants.

    for (ulIndex = 0; ulIndex < ulPropIndex; ulIndex++)
    {
        if (rgfFreePropVar[ ulIndex ])
        {
            PropVariantClear (&rgpropvar[ ulIndex ]);
        }
    }

    // Release the UD Property Storage.

    RELEASEINTERFACE (lpPropertyStorage);

    return (fSuccess);

}   // FSaveUserDef
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\propvar.c ===
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//
//  File:       PropVar.c
//
//  Purpose:    This file provides Office-aware routines which 
//              operate on PropVariants.  They are Office-aware in
//              that they only operate on the subset of
//              VarTypes which are used by Office.
//
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////


#include "priv.h"
#pragma hdrstop


/////////////////////////////////////////////////////////////////////////////////
//
//  Function:   FPropVarLoad
//
//  Purpse:     Load data into a PropVariant.  If the target PropVariant
//              already contains data, it will be freed.
//
//              Note that new memory is allocated, if necessary, to hold
//              the data in the PropVariant.  Also note that the
//              resulting PropVariant should be freed by the caller using
//              PropVariantClear.
//
//  Inputs:     LPPROPVARIANT - to be loaded.  This should be a valid
//                              (i.e. intialized) PropVariant.
//              VARTYPE       - of the new PropVariant (must be a member of
//                              the limited set used by Office).
//              LPVOID        - Either the data to be loaded, or a pointer
//                              to such data, depending on the type.
//
//  Output:     TRUE if and only if successful.
//
/////////////////////////////////////////////////////////////////////////////////


BOOL
FPropVarLoad
    ( LPPROPVARIANT     lppropvar,
      VARTYPE           vt,
      LPVOID const      lpv )
{
    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;   // Return code
    ULONG   cch, cb;

    //  ----------
    //  Initialize
    //  ----------

    Assert (lppropvar != NULL);
    Assert (lpv != NULL);

    // Free any data currently in the PropVariant.

    PropVariantClear (lppropvar);

    //  ---------------------------------------------------
    //  Set the value of the PropVariant based on the type.
    //  ---------------------------------------------------

    switch (vt)
    {
        // Strings

        case VT_LPTSTR:

            // Determine the character and byte count.

            cch = lstrlen(lpv);    // Doesn't include the NULL.
            cb = (cch + 1) * sizeof(TCHAR);       // *Does* include the NULL.

            // Allocate memory in the PropVariant.

            lppropvar->pwszVal = CoTaskMemAlloc (cb);
            if (lppropvar->pwszVal == NULL)
            {
                goto Exit;
            }

            // Copy the string to the PropVariant and terminate it.

            StringCchCopy( (LPTSTR)lppropvar->pwszVal, cch + 1, lpv );
            lppropvar->pwszVal[cch] = TEXT('\0');

            break;

        // DWORDs

        case VT_I4:

            lppropvar->lVal = *(DWORD*) lpv;
            break;

        // FileTime

        case VT_FILETIME:

            CopyMemory( &lppropvar->filetime, lpv, sizeof(FILETIME) );
            break;

        // Double

        case VT_R8:
            CopyMemory( &lppropvar->dblVal, lpv, sizeof(double) );
            break;

        // Bool

        case VT_BOOL:
            lppropvar->boolVal = *(VARIANT_BOOL*) lpv ? VARIANT_TRUE : VARIANT_FALSE;
            break;

        // Invalid type.

        default:
            goto Exit;
    }

    // Set the VT of the PropVariant, and we're done.

    lppropvar->vt = vt;

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:
    return (fSuccess);

}   // FPropVarLoad



////////////////////////////////////////////////////////////////////////////////
//
//  Function:   FCoStrToWStr
//
//  Purpose:    Convert a COM string (ANSI) to a COM wide-string.
//              ("COM" because the string is allocated using
//              the COM heap).
//
//  Inputs:     LPWSTR* - The converted string.
//              LPSTR   - The original string.
//              UINT    - The ANSI code page.
//
//  Output:     TRUE if and only if successful.
//
////////////////////////////////////////////////////////////////////////////////

BOOL
FCoStrToWStr( LPWSTR            *lplpwstr,
              const LPSTR       lpstr,
              UINT              uCodePage)
{
    //  ------
    //  Locals
    //  ------

    BOOL fSuccess = FALSE;  // Return value.
    ULONG cchBuffer = 0;    // Size of converted string (includes NULL).

    Assert (lpstr != NULL && lplpwstr != NULL);

    //  ------------------
    //  Convert the string
    //  ------------------

    // Make two passes.  The first will calculate the
    // size of the target buffer, the second will actually
    // make the conversion.

    *lplpwstr = NULL;

    while (TRUE)
    {
        cchBuffer = MultiByteToWideChar(
                        uCodePage,          // Source code page
                        0,                  // Default flags
                        lpstr,              // Source string
                        -1,                 // Default length
                        *lplpwstr,          // Destination string
                        cchBuffer );        // Max dest string characters.

        // Is this the second pass (when the conversion should
        // have taken place)?

        if (*lplpws