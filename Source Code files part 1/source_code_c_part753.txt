ttached.
 */
#define DDVP_AUTOFLIP				0x00000001l

/*
 * Perform conversion using the ddpfOutputFormat information.
 */
#define DDVP_CONVERT				0x00000002l

/*
 * Perform cropping using the specified rectangle.
 */
#define DDVP_CROP				0x00000004l

/*
 * Indicates that interlaced fields should be interleaved in memory.
 */
#define DDVP_INTERLEAVE				0x00000008l

/*
 * Indicates that the data should be mirrored left to right as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORLEFTRIGHT			0x00000010l

/*
 * Indicates that the data should be mirrored top to bottom as it's
 * written into the frame buffer.
 */
#define DDVP_MIRRORUPDOWN			0x00000020l

/*
 * Perform pre-scaling/zooming based on the pre-scale parameters.
 */
#define DDVP_PRESCALE				0x00000040l

/*
 * Ignore input of even fields.
 */
#define DDVP_SKIPEVENFIELDS			0x00000080l

/*
 * Ignore input of odd fields.
 */
#define DDVP_SKIPODDFIELDS			0x00000100l

/*
 * Drive the graphics VSYNCs using the video port VYSNCs.
 */
#define DDVP_SYNCMASTER				0x00000200l

/*
 * The ddpfVBIOutputFormatFormat member contains data that should be used
 * to convert the data within the vertical blanking interval.
 */
#define DDVP_VBICONVERT				0x00000400l

/*
 * Indicates that data within the vertical blanking interval
 * should not be scaled.
 */
#define DDVP_VBINOSCALE				0x00000800l

/*
 * Indicates that these bob/weave decisions should not be
 * overriden by other interfaces.
 */
#define DDVP_OVERRIDEBOBWEAVE			0x00001000l

/*
 * Indicates that the video data should ignore the left and right
 * cropping coordinates when cropping the VBI data.
 */
#define DDVP_IGNOREVBIXCROP			0x00002000l

/*
 * Indicates that interleaving can be disabled for data within the
 * vertical blanking interval.
 */
#define DDVP_VBINOINTERLEAVE			0x00004000l

/*
 * Indicates that the video port should use the hardware
 * de-interlacing hardware.
 */
#define DDVP_HARDWAREDEINTERLACE		0x00008000l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETINPUTFORMAT/GETOUTPUTFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * Return formats for the video data
 */
#define DDVPFORMAT_VIDEO			0x00000001l

/*
 * Return formats for the VBI data
 */
#define DDVPFORMAT_VBI				0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag to disable the VBI/video-only check
 */
#define DDVPFORMAT_NOFAIL			0x08000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT SETTARGETSURFACE FLAGS
 *
 ****************************************************************************/

/*
 * Surface should receive video data (and VBI data if a surface
 * is not explicitly attached for that purpose)
 */
#define DDVPTARGET_VIDEO			0x00000001l

/*
 * Surface should receive VBI data
 */
#define DDVPTARGET_VBI				0x00000002l


/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT WAITFORSYNC FLAGS
 *
 ****************************************************************************/

/*
 * Waits until the beginning of the next VSYNC
 */
#define DDVPWAIT_BEGIN				0x00000001l

/*
 * Waits until the end of the next/current VSYNC
 */
#define DDVPWAIT_END				0x00000002l

/*
 * Waits until the beginning of the specified line
 */
#define DDVPWAIT_LINE				0x00000003l

/****************************************************************************
 *
 * DIRECTDRAWVIDEOPORT FLIP FLAGS
 *
 ****************************************************************************/

/*
 * Flips the normal video surface
 */
#define DDVPFLIP_VIDEO				0x00000001l

/*
 * Flips the VBI surface
 */
#define DDVPFLIP_VBI				0x00000002l

/****************************************************************************
 *
 * DIRIRECTDRAWVIDEOPORT GETVIDEOSIGNALSTATUS VALUES
 *
 ****************************************************************************/

/*
 * No video signal is present at the video port
 */
#define DDVPSQ_NOSIGNAL				0x00000001l

/*
 * A valid video signal is present at the video port
 */
#define DDVPSQ_SIGNALOK				0x00000002l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Flags
 *
 ****************************************************************************/

/*
 * The specified height/width refer to the size of the video port data
 * written into memory, after prescaling has occured.
 */
#define DDVPB_VIDEOPORT				0x00000001l

/*
 * The specified height/width refer to the source size of the overlay.
 */
#define DDVPB_OVERLAY				0x00000002l

/*
 * This is a query for the device to return which caps this device requires.
 */
#define DDVPB_TYPE				0x00000004l

/****************************************************************************
 *
 * VIDEOPORTBANDWIDTH Caps
 *
 ****************************************************************************/

/*
 * The bandwidth for this device is dependant on the overlay source size.
 */
#define DDVPBCAPS_SOURCE			0x00000001l

/*
 * The bandwidth for this device is dependant on the overlay destination
 * size.
 */
#define DDVPBCAPS_DESTINATION			0x00000002l

/****************************************************************************
 *
 * DDVIDEOPORTCONTAINER CreateVideoPort flags
 *
 ****************************************************************************/

/*
 * The process only wants to control the VBI portion of the video stream.
 */
#define DDVPCREATE_VBIONLY			0x00000001l

/*
 * The process only wants to control the non-VBI (video) portion of
 * the video stream.
 */
#define DDVPCREATE_VIDEOONLY			0x00000002l
//@@BEGIN_MSINTERNAL

/*
 * Internal flag indicating interface is for the IDirectDrawVidoePortNotify object
 */
#define DDVPCREATE_NOTIFY			0x80000000l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DDVIDEOPORTSTATUS flags
 *
 ****************************************************************************/

/*
 * The video port interface is only controlling the VBI portion of the
 * video stream
 */
#define DDVPSTATUS_VBIONLY			0x00000001l

/*
 * The video port interface is only controlling the video portion of the
 * video stream
 */
#define DDVPSTATUS_VIDEOONLY			0x00000002l


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\edevctrl.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    EDevCtrl.h

Abstract:

    This header contain structures and peroperty sets for 
    interfacing to an external device, like a DV.
    The code is modeled after DirectShow's Vcrctrl Sample 
    (VCR Control Filter). It contain IAMExtDevice, 
    IAMExtTransport, and IAMTimecodeReader interfaces, and 
    a new interface IAMAdvancedAVControl() is added
    for additional advanced device controls.

    Note:  (From DShow DDK)
        The VCR control sample filter, Vcrctrl, is a simple 
        implementation of the external device control interfaces 
        that DirectShow provides. Vcrctrl provides basic transport 
        control and SMPTE timecode-reading capabilities for certain 
        Betacam and SVHS videocassette recorders with RS-422 or RS-232 
        serial interfaces (see source code for specific machine types 
        supported).

    Note:  some methods in IAM* interfaces may not be 
           used and will return not implemented.           

Created:

    September 23, 1998    

    Yee J. Wu


Revision:

   0.6

--*/

#ifndef __EDevCtrl__
#define __EDevCtrl__

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
   struct {
	 WORD   wFrameRate;
	 WORD   wFrameFract;
	 DWORD  dwFrames;
	 };
   DWORDLONG  qw;
   } TIMECODE;



typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE
    {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
    }	TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

// Device Capabilities
typedef struct tagDEVCAPS{
    long CanRecord;
    long CanRecordStrobe;
    long HasAudio;
    long HasVideo;
    long UsesFiles;
    long CanSave;
    long DeviceType;
    long TCRead;
    long TCWrite;
    long CTLRead;
    long IndexRead;
    long Preroll;
    long Postroll;
    long SyncAcc;
    long NormRate;
    long CanPreview;
    long CanMonitorSrc;
    long CanTest;
    long VideoIn;
    long AudioIn;
    long Calibrate;
    long SeekType;
    long SimulatedHardware;        // private
} DEVCAPS, *PDEVCAPS;

// transport status
typedef struct tagTRANSPORTSTATUS{
    long Mode;
    long LastError;
    long RecordInhibit;
    long ServoLock;
    long MediaPresent;
    long MediaLength;
    long MediaSize;
    long MediaTrackCount;
    long MediaTrackLength;
    long MediaTrackSide;
    long MediaType;
    long LinkMode;
    long NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

// transport basic parameters
typedef struct tagTRANSPORTBASICPARMS{
    long TimeFormat;
    long TimeReference;
    long Superimpose;
    long EndStopAction;
    long RecordFormat;
    long StepFrames;
    long SetpField;
    long Preroll;
    long RecPreroll;
    long Postroll;
    long EditDelay;
    long PlayTCDelay;
    long RecTCDelay;
    long EditField;
    long FrameServo;
    long ColorFrameServo;
    long ServoRef;
    long WarnGenlock;
    long SetTracking;
    TCHAR VolumeName[40];
    long Ballistic[20];
    long Speed;
    long CounterFormat;
    long TunerChannel;
    long TunerNumber;
    long TimerEvent;
    long TimerStartDay;
    long TimerStartTime;
    long TimerStopDay;
    long TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

// transport video parameters
typedef struct tagTRANSPORTVIDEOPARMS{
    long OutputMode;
    long Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

// transport audio parameters
typedef struct tagTRANSPORTAUDIOPARMS{
    long EnableOutput;
    long EnableRecord;
    long EnableSelsync;
    long Input;
    long MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;


// low level machine status structure filled in after
// REQUEST_STATUS command from above.  This structure would
// grow in a full implementation
typedef struct tagVCRSTATUS{
	BOOL bCassetteOut;	// OATRUE means no cassette
	BOOL bLocal;		// OATRUE means front panel switch in local
} VCRSTATUS;

typedef VCRSTATUS far *PVCRSTATUS;



//---------------------------------------------------------
// STATIC_PROPSETID_VIDCAP_EXT_DEVICE
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)


// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_EXTDEVICE_ID,           // ID (such as Symbolic Lin) that can uniquely idenfy this device
    KSPROPERTY_EXTDEVICE_VERSION,      // Device model number and version (such AV/C VCR Subunit Spec. 2.01)
    KSPROPERTY_EXTDEVICE_POWER_STATE,  // Return current device power state.
    KSPROPERTY_EXTDEVICE_PORT,         // Can use this to return DEV_PORT_1394
    KSPROPERTY_EXTDEVICE_CAPABILITIES, // Device specific capabilities  

} KSPROPERTY_EXTDEVICE;


typedef struct {
    KSPROPERTY Property;
 
    union {
        // Client is responsible for allocating this.
        DEVCAPS  Capabilities;          // May need to expand on the existing structure
		ULONG    DevPort;               // 
        ULONG    PowerState;            // On, off standby
        WCHAR    pawchString[MAX_PATH]; // ID and version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;

} KSPROPERTY_EXTDEVICE_S, *PKSPROPERTY_EXTDEVICE_S;


//---------------------------------------------------------
// STATIC_PROPSETID_VIDCAP_EXT_TRANSPORT
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)



// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_EXTXPORT_CAPABILITIES,       // Transport specific capability 
    KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // MPEG, D-VHS, Analog VHS etc. 
    KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // MPEG, D-VHS, Analog VHS etc. 
    KSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // Eject, open tray, close tray
    KSPROPERTY_EXTXPORT_MEDIUM_INFO,        // cassettte_type and tape_grade_and_write_protect    
    KSPROPERTY_EXTXPORT_STATE,              // Get/Set transport mode and state
    KSPROPERTY_EXTXPORT_STATE_NOTIFY,       // NOTIFY: Mode + State (Table 4-8) 
    KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // Request VCR subunit to search for a specific timecode on the medium
    KSPROPERTY_EXTXPORT_ATN_SEARCH,         // Request VCR subunit to search for a specific ATN on the medium
    KSPROPERTY_EXTXPORT_RTC_SEARCH,         // Request VCR subunit to search for a specific RelativeTimeCounter on the medium

    //
    // Implemented for testing purpose
    // Will remove this later...
    //
    KSPROPERTY_RAW_AVC_CMD,                 // Send/Rcv raw AVC commnad with a FCP packet.

} KSPROPERTY_EXTXPORT;

typedef struct {
    BOOL  MediaPresent;      // TRUE/FALSE
    ULONG MediaType;         // DVCR standard, small, medium; VHS; VHS-C; unknown
    BOOL  RecordInhibit;     // TRUE/FALSE
} MEDIUM_INFO, *PMEDIUM_INFO;


typedef struct {
    ULONG Mode;              // LOAD MEDIUM, RECORD, PLAY or WIND
    ULONG State;             // Vary depend on mode (Table 4-8) 
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    KSPROPERTY Property;

    union {    
        ULONG      Capabilities;     // May need to expand on the existing structure
        ULONG      SignalMode;       // MPEG, D-VHS, Analog VHS etc.
        ULONG      LoadMedium;       // Eject, open tray, close tray
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;

        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;       // hour:minute:second:frame
        DWORD dwAbsTrackNumber; // absolute track number


       //
       // Implemented for testing purpose
       // Will remove this later or will keep this for 
       // packet specific command.
       //
       struct {
           ULONG   PayloadSize;
           BYTE    Payload[512];  // This is only for testing sending AVC command from User mode.
       } RawAVC;

     } u;
     
} KSPROPERTY_EXTXPORT_S, *PKSPROPERTY_EXTXPORT_S;



//---------------------------------------------------------
// PROPSETID_TIMECODE
//---------------------------------------------------------
// This guid and interface is defined in strmif.h 
#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)


// KS properties and structure for this interface
typedef enum {
    KSPROPERTY_TIMECODE_READER,  // Timecode for the current medium position
    KSPROPERTY_ATN_READER,       // Absolute track number the current medium position
    KSPROPERTY_RTC_READER,       // Relative time counter for the current medium position

} KSPROPERTY_TIMECODE;


typedef struct {
    KSPROPERTY Property;

    TIMECODE_SAMPLE TimecodeSamp;
     
} KSPROPERTY_TIMECODE_S, *PKSPROPERTY_TIMECODE_S;



//---------------------------------------------------------
//  External Device Command event notification
//---------------------------------------------------------

#define STATIC_KSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", KSEVENTSETID_EXTDEV_Command);
#define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)

typedef enum {
    KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
    KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
    KSEVENT_EXTDEV_COMMAND_BUSRESET,
    KSEVENT_EXTDEV_TIMECODE_UPDATE,
    KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,    // Notify mode of operation change (VCR,OFF,Camera)
    KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,   // XPrt state change
    KSEVENT_EXTDEV_NOTIFY_REMOVAL,           // Notify device removal
    KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE,     // Notify medium (tape) is removed or added

} KSEVENT_DEVCMD;


#endif // __EDevCTrl__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\dsprv.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       dsconf.h
 *  Content:    DirectSound configuration interface include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/19/1998   dereks  Created.
 *  10/3/2001   duganp  Added the comments below.
 *
 *  Description:
 *
 *  This file provides an internal interface to certain parts of
 *  DirectSound's state and configuration, for use by other groups
 *  within Microsoft.  Currently it is used by RTC, DirectPlayVoice,
 *  mmsys.cpl, dxdiag.exe, and various internal test apps.
 *
 *  There is sample code demonstrating how to use this interface in
 *  multimedia\directx\dsound\dsound\dsmgr.
 *
 *  This interface is not public because it provides some low-level
 *  "plumbing" functionality which is only of use to other MS APIs
 *  that interact with DirectSound.  Eventually this functionality
 *  will be rolled into new audio APIs and the need for backdoors
 *  will disappear.
 *
 *  IMPORTANT NOTE: If you plan to use this interface, watch out for
 *  the two CONFLICTING definitions of IKsPropertySet in our headers.
 *  The correct IKsPropertySet has a Get() method first and then a
 *  Set() method (as defined in dsound.h and various other places).
 *  The other IKsPropertySet has Set() before Get() (as defined in
 *  ksproxy.h and various other places).  If you pull in the wrong
 *  definition of IKsPropertySet, your vtable won't match dsound's
 *  and your method calls will fail.
 *
 *@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __DSCONF_INCLUDED__
#define __DSCONF_INCLUDED__

#ifndef __DSOUND_INCLUDED__
#error dsound.h not included
#endif // __DSOUND_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//@@BEGIN_MSINTERNAL

//
// DirectSound Mixer Properties {84624F80-25EC-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundMixer, 0x84624f80, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
} DSPROPERTY_DIRECTSOUNDMIXER;

typedef enum
{
    DIRECTSOUNDMIXER_SRCQUALITY_WORST,
    DIRECTSOUNDMIXER_SRCQUALITY_PC,
    DIRECTSOUNDMIXER_SRCQUALITY_BASIC,
    DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED,
} DIRECTSOUNDMIXER_SRCQUALITY;

#define DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA
{
    GUID                        DeviceId;   // DirectSound device id
    DIRECTSOUNDMIXER_SRCQUALITY Quality;    // SRC quality
} DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA;

#define DIRECTSOUNDMIXER_ACCELERATIONF_NORING0MIX   0x00000001
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS  0x00000002
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D       0x00000004
#define DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS 0x00000008

#define DIRECTSOUNDMIXER_ACCELERATIONF_FULL         0x00000000
#define DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD     0x00000008
#define DIRECTSOUNDMIXER_ACCELERATIONF_NONE         0x0000000F

#ifdef WINNT
#define DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT      DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD
#else // WINNT
#define DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT      DIRECTSOUNDMIXER_ACCELERATIONF_FULL
#endif // WINNT

typedef struct _DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA
{
    GUID    DeviceId;   // DirectSound device id
    ULONG   Flags;      // Acceleration flags
} DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA;

//@@END_MSINTERNAL

//
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
//@@BEGIN_MSINTERNAL
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1 = 0,
//@@END_MSINTERNAL
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A = 1,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1 = 2,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1 = 3,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W = 4,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A = 5,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W = 6,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A = 7,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W = 8,
//@@BEGIN_MSINTERNAL
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE = 9,
    DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_A = 10,
    DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_W = 11,
//@@END_MSINTERNAL
} DSPROPERTY_DIRECTSOUNDDEVICE;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W
//@@BEGIN_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_W
//@@END_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
//@@BEGIN_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_A
//@@END_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
//@@BEGIN_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_A
//@@END_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1
//@@BEGIN_MSINTERNAL
#define DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1
//@@END_MSINTERNAL
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

//@@BEGIN_MSINTERNAL
typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
{
    GUID    DeviceId;   // DirectSound device id
    BOOL    Present;    // Presence switch
} DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA
{
    GUID                        DeviceId;   // DirectSound device id
    DIRECTSOUNDDEVICE_TYPE      DeviceType; // Device type
    BOOL                        Present;    // Presence switch
} DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA;

#if DIRECTSOUND_VERSION < 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA
#endif // DIRECTSOUND_VERSION < 0x0700
//@@END_MSINTERNAL

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA;
//@@BEGIN_MSINTERNAL
typedef DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_A_DATA,
                                                              *PDSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_A_DATA;
//@@END_MSINTERNAL

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
{
    LPWSTR                      DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA;
//@@BEGIN_MSINTERNAL
typedef DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA DSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_W_DATA,
                                                              *PDSPROPERTY_DIRECTSOUNDDEVICE_USERWAVEDEVICEMAPPING_W_DATA;
//@@END_MSINTERNAL

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, LPVOID);

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW
#else // UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1 Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

//@@BEGIN_MSINTERNAL

//
// Basic DirectSound Acceleration Properties {1AEAA606-35F0-11D1-B161-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundBasicAcceleration, 0x1aeaa606, 0x35f0, 0x11d1, 0xb1, 0x61, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT,
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION;

typedef enum
{
    DIRECTSOUNDBASICACCELERATION_NONE,
    DIRECTSOUNDBASICACCELERATION_SAFE,
    DIRECTSOUNDBASICACCELERATION_STANDARD,
    DIRECTSOUNDBASICACCELERATION_FULL,
} DIRECTSOUNDBASICACCELERATION_LEVEL;

typedef struct _DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA
{
    GUID                                DeviceId;   // DirectSound device id
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level;      // Basic acceleration level
} DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, *PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA,
  DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA, *PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA;

//
// DirectSound Debug Properties {F2957840-260C-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundDebug, 0xf2957840, 0x260c, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A,
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W,
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A,
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W,
} DSPROPERTY_DIRECTSOUNDDEBUG;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME     0x00000001
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTPROCESSTHREADID  0x00000002
#define DIRECTSOUNDDEBUG_DPFINFOF_PRINTFILELINE         0x00000004
#define DIRECTSOUNDDEBUG_DPFINFOF_LOGTOFILEONLY         0x00000008

#define DIRECTSOUNDDEBUG_DPFINFOF_DEFAULT               DIRECTSOUNDDEBUG_DPFINFOF_PRINTFUNCTIONNAME

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    CHAR    LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
{
    ULONG   Flags;              // DPF flags
    ULONG   DpfLevel;           // DPF level
    ULONG   BreakLevel;         // Break level
    WCHAR   LogFile[MAX_PATH];  // Log file
} DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
{
    HRESULT ResultCode;     // Result code
    LPSTR   String;         // Result code in string form
    LPSTR   Explanation;    // Result code description
} DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
{
    HRESULT ResultCode;     // Result code
    LPWSTR  String;         // Result code in string form
    LPWSTR  Explanation;    // Result code description
} DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA
#define DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA
#endif // UNICODE

#define DIRECTSOUNDDEBUG_DPFLEVEL_DEFAULT   0
#define DIRECTSOUNDDEBUG_BREAKLEVEL_DEFAULT 0

//
// DirectSound Persistent Data {1BE55C3E-36AB-11d1-B162-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundPersistentData, 0x1be55c3e, 0x36ab, 0x11d1, 0xb1, 0x62, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A,
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W,
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPSTR   SubKeyName;         // Optional subkey name
    LPSTR   ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
{
    GUID    DeviceId;           // DirectSound device id
    LPWSTR  SubKeyName;         // Optional subkey name
    LPWSTR  ValueName;          // Value name
    ULONG   RegistryDataType;   // Data type
    LPVOID  Data;               // Data pointer
    ULONG   DataSize;           // Size of data buffer, in bytes
} DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, *PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#define PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA
#endif // UNICODE

//
// DirectSound Buffer Properties {50393DEA-51AD-11d2-91B2-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundBuffer, 0x50393dea, 0x51ad, 0x11d2, 0x91, 0xb2, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
} DSPROPERTY_DIRECTSOUNDBUFFER;

typedef struct _DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA
{
    LPDIRECTSOUNDBUFFER Buffer;     // Buffer object pointer
    GUID                DeviceId;   // DirectSound device ID
} DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA, *PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA;

//
// DirectSound Object Properties {4BE334F0-1C8E-4D91-8C17-5889D6F0B154}
//

DEFINE_GUID(DSPROPSETID_DirectSound, 0x4be334f0, 0x1c8e, 0x4d91, 0x8c, 0x17, 0x58, 0x89, 0xd6, 0xf0, 0xb1, 0x54);

typedef enum
{
    DSPROPERTY_DIRECTSOUND_OBJECTS,
    DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS
} DSPROPERTY_DIRECTSOUND;

#pragma warning(disable:4200)           // Disable the nag about the Objects[0] arrays below

typedef struct _DIRECTSOUND_INFO
{
    LPDIRECTSOUND           DirectSound;
    GUID                    DeviceId;
} DIRECTSOUND_INFO;

typedef struct _DSPROPERTY_DIRECTSOUND_OBJECTS_DATA
{
    GUID                    DeviceId;   // [in]  DirectSound device ID (or GUID_NULL for all DS objects)
    ULONG                   Count;      // [out] Count of DirectSound objects matching this DeviceId
    DIRECTSOUND_INFO        Objects[0]; // [out] Information about each DirectSound object
} DSPROPERTY_DIRECTSOUND_OBJECTS_DATA, *PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA;

typedef struct _DIRECTSOUNDCAPTURE_INFO
{
    LPDIRECTSOUNDCAPTURE    DirectSoundCapture;
    GUID                    DeviceId;
} DIRECTSOUNDCAPTURE_INFO;

typedef struct _DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA
{
    GUID                    DeviceId;   // [in]  DirectSoundCapture device ID (or GUID_NULL for all DSC objects)
    ULONG                   Count;      // [out] Count of DirectSoundCapture objects matching this DeviceId
    DIRECTSOUNDCAPTURE_INFO Objects[0]; // [out] Information about each DirectSoundCapture object
} DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA, *PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA;

//@@END_MSINTERNAL

#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSCONF_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\mmdet.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    mmdet.h

Abstract:
    MM detection module header, borrowed from KyleB's net detection base

Author:

    bryanw 18-Oct-1997

--*/


#ifndef _MMDET_H_
#define _MMDET_H_

#define DEVIDSTR_SB                 TEXT( "*PNPb000" ) // Sound Blaster wave
#define DEVIDSTR_SB2                TEXT( "*PNPb001" ) // Sound Blaster 2 wave
#define DEVIDSTR_SBPRO              TEXT( "*PNPb002" ) // Sound Blaster Pro wave
#define DEVIDSTR_SB16               TEXT( "*PNPb003" ) // Sound Blaster 16 wave
#define DEVIDSTR_MV                 TEXT( "*PNPb004" ) // Media Vision Thunder Board
#define DEVIDSTR_ADLIB              TEXT( "*PNPb005" ) // Adlib
#define DEVIDSTR_MPU401             TEXT( "*PNPb006" ) // MPU-401 midi
#define DEVIDSTR_SNDSYS             TEXT( "*PNPb007" ) // Windows Sound System
#define DEVIDSTR_CPQBA              TEXT( "*PNPb008" ) // Compaq Business Audio
                                                     
#define DEVIDSTR_PAS16              TEXT( "*PNPb00d" ) // PAS-16 variations
#define DEVIDSTR_PAS16_WITH_SCSI    TEXT( "*PNPb00e" ) // PAS-16 + SCSI
#define DEVIDSTR_PAS_ORIGINAL       TEXT( "*PNPb018" ) // MV Pro Audio Spectrum (original)
#define DEVIDSTR_PAS_PLUS           TEXT( "*PNPb019" ) // PAS Plus variations

#define DEVIDSTR_OPTI82C928         TEXT( "*PNPb01a" )
#define DEVIDSTR_OPTI82C929         TEXT( "*PNPb01b" )
#define DEVIDSTR_OPTI82C930         TEXT( "*PNPb01c" )
                                                     
#define DEVIDSTR_PA3D               TEXT( "*PNPb00b" ) // Media Vision ProAudio3D
#define DEVIDSTR_MQMPU401           TEXT( "*PNPb00c" ) // MusicQuest MPU-401 midi
#define DEVIDSTR_JAZZ               TEXT( "*PNPb00f" ) // Media Vision OEM Jazz-16
#define DEVIDSTR_VXP500             TEXT( "*PNPb010" ) // Auravision VxP500 based video cap.
#define DEVIDSTR_ADLIBOPL3          TEXT( "*PNPb020" ) // Adlib OPL3 midi
#define DEVIDSTR_GAMEPORT           TEXT( "*PNPb02f" ) // Game port

#define DEVIDSTR_AZTECH_PRO16           TEXT( "*AZT1608" )
#define DEVIDSTR_AZTECH_NOVA16          TEXT( "*AZT1605" )
#define DEVIDSTR_AZTECH_WASHINGTON16    TEXT( "*AZT2316" )
                                                        
#define DEVIDSTR_ESS4881                TEXT( "*ESS4881" )
#define DEVIDSTR_ESS6881                TEXT( "*ESS6881" )
#define DEVIDSTR_ESS1481                TEXT( "*ESS1481" )
#define DEVIDSTR_ESS1681                TEXT( "*ESS1681" )
#define DEVIDSTR_ESS1781                TEXT( "*ESS1781" )
#define DEVIDSTR_ESS1881                TEXT( "*ESS1881" )

ULONG
WINAPI
MmDetectAdapters(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );
    
typedef
ULONG
(*PFNMMDETECTADAPTERS)(
    IN HDEVINFO DeviceInfoSet,
    IN DI_FUNCTION InstallFunction
    );

#if (!defined( _NTDDK_ ) && !defined( NT_INCLUDED ))
typedef ULONG INTERFACE_TYPE,*PINTERFACE_TYPE;
#endif
typedef
VOID 
(*PFNMMDETECTIRQCALLBACK)(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG Context
    );

USHORT
WINAPI
MmDetectIRQ( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN USHORT InterruptMask,
    IN PFNMMDETECTIRQCALLBACK SetInterrupt,
    IN PFNMMDETECTIRQCALLBACK ClearInterrupt,
    IN ULONG Context 
    );
    
#if (defined( _CFGMGR32_H_ ))
ULONG
WINAPI
MmRegisterDetectedDevice( 
    IN HDEVINFO DeviceInfoSet,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PTSTR DeviceId,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
VOID
WINAPI    
MmAvoidDetectedResources( 
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN PMEM_RESOURCE MemResources,
    IN int MemResourceCount,
    IN PIO_RESOURCE IoResources,
    IN int IoResourceCount,
    IN PIRQ_RESOURCE IrqResources,
    IN int IrqResourceCount,
    IN PDMA_RESOURCE DmaResources,
    IN int DmaResourceCount
    );
    
#endif    

#endif // _MMDET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\mmsysp.h ===
/*==========================================================================
 *
 *  mmsysp.h -- Internal include file for Multimedia API's
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */
#ifndef _INC_MMSYSP
#define _INC_MMSYSP
#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */
#ifdef _WIN32
#ifndef _WINMM_
#define WINMMAPI        DECLSPEC_IMPORT
#else
#define WINMMAPI
#endif
#define _loadds
#define _huge
#endif
#ifdef  BUILDDLL
#undef  WINAPI
#define WINAPI            _loadds FAR PASCAL
#undef  CALLBACK
#define CALLBACK          _loadds FAR PASCAL
#endif  /* ifdef BUILDDLL */
/* Multimedia messages */
#define WM_MM_RESERVED_FIRST    0x03A0
#define WM_MM_RESERVED_LAST     0x03DF
/* 0x3BA is open */
#define MM_MCISYSTEM_STRING 0x3CA
#if(WINVER <  0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for MEVT_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_MOREDATA      0x3CC          /* MIM_DONE w/ pending events */

/* 0x3CF is open */

#endif /* WINVER <  0x0400 */
/* 3D8 - 3DF are reserved for Haiku */

#ifdef _WIN32
#define WINMMDEVICECHANGEMSGSTRINGA "winmm_devicechange"
#define WINMMDEVICECHANGEMSGSTRINGW L"winmm_devicechange"
#ifdef UNICODE
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGW
#else
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGA
#endif
#else
#define WINMMDEVICECHANGEMSGSTRING "winmm_devicechange"
#endif
#ifndef MMNODRV
#endif  /* ifndef MMNODRV */
#define CALLBACK_THUNK      0x00040000l    /* dwCallback is a Ring0 Thread Handle */
#define CALLBACK_EVENT16    0x00060000l    /* dwCallback is an EVENT under Win16*/

#ifdef  BUILDDLL
typedef void (FAR PASCAL DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#else   /* ifdef BUILDDLL */
#endif  /* ifdef BUILDDLL */
#ifndef MMNOMMSYSTEM
WINMMAPI UINT WINAPI mmsystemGetVersion(void);
void FAR CDECL _loadds OutputDebugStrF(LPCSTR pszFormat, ...);
void WINAPI winmmUntileBuffer(DWORD dwTilingInfo);
DWORD WINAPI winmmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);
BOOL WINAPI mmShowMMCPLPropertySheet(HWND hWnd, LPSTR szPropSheetID, LPSTR szTabName, LPSTR szCaption);
#endif  /* ifndef MMNOMMSYSTEM */
#ifndef MMNOSOUND
#if(WINVER <  0x0400)
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */
#endif /* WINVER <  0x0400 */
#define SND_LOPRIORITY  0x10000000L /* low priority sound */
#define SND_EVENTTIME   0x20000000L /* dangerous event time */
#define SND_VALIDFLAGS  0x001720DF  // Set of valid flag bits.  Anything outside
                                    // this range will raise an error
#define SND_SNDPLAYSOUNDF_VALID 0x20FF
#define SND_PLAYSOUNDF_VALID    0x301720DFL
#endif  /* ifndef MMNOSOUND */
#ifndef MMNOWAVE
#if(WINVER <  0x0400)
#define  WAVE_MAPPED               0x0004
#define  WAVE_FORMAT_DIRECT        0x0008
#define  WAVE_FORMAT_DIRECT_QUERY  (WAVE_FORMAT_QUERY | WAVE_FORMAT_DIRECT)
#endif /* WINVER <  0x0400 */
#ifndef _WIN32
#define  WAVE_SHARED               0x8000
#endif
#define  WAVE_VALID                0x800F
#define WHDR_MAPPED     0x00001000  /* thunked header */
#define WHDR_VALID      0x0000101F  /* valid flags */
#endif  /* ifndef MMNOWAVE */
#ifndef MMNOMIDI
#if(WINVER <  0x0400)
#define MIM_MOREDATA      MM_MIM_MOREDATA
#define MOM_POSITIONCB    MM_MOM_POSITIONCB
#endif /* WINVER <  0x0400 */
#if(WINVER <  0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_STATUS      0x00000020L
#endif /* WINVER <  0x0400 */
#define MIDI_IO_CONTROL     0x00000008L
#define MIDI_IO_INPUT       0x00000010L  /*future*/
#define MIDI_IO_OWNED       0x00004000L
#define MIDI_IO_SHARED      0x00008000L
#define MIDI_I_VALID        0xC027
#define MIDI_O_VALID        0xC00E
#define MIDI_CACHE_VALID    (MIDI_CACHE_ALL | MIDI_CACHE_BESTFIT | MIDI_CACHE_QUERY | MIDI_UNCACHE)
#if(WINVER <  0x0400)
#define MIDICAPS_STREAM          0x0008  /* driver supports midiStreamOut directly */
#endif /* WINVER <  0x0400 */
/* 3.1 style MIDIHDR for parameter validation */
typedef struct midihdr31_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD_PTR   dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD_PTR   reserved;             /* reserved for driver */
} MIDIHDR31, *PMIDIHDR31, NEAR *NPMIDIHDR31, FAR *LPMIDIHDR31;
#if(WINVER <  0x0400)
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
    DWORD       dwParms[1];           /* Parameters if this is a long event */
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */
} MIDISTRMBUFFVER;
#endif /* WINVER <  0x0400 */
#define MHDR_SENDING    0x00000020
#define MHDR_MAPPED     0x00001000       /* thunked header */
#define MHDR_SHADOWHDR  0x00002000       /* MIDIHDR is 16-bit shadow */
#define MHDR_VALID      0x0000302F       /* valid flags */
/*#define MHDR_VALID      0xFFFF000F       /* valid flags */

#define MHDR_SAVE       0x00003000       /* Save these flags */
                                         /* past driver calls */
#if(WINVER <  0x0400)
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */

#define MEVT_F_SHORT        0x00000000L
#define MEVT_F_LONG         0x80000000L
#define MEVT_F_CALLBACK     0x40000000L

#define MEVT_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define MEVT_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define MEVT_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define MEVT_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define MEVT_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

#define MEVT_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define MEVT_COMMENT        ((BYTE)0x82)    /* parm = comment data                 */
#define MEVT_VERSION        ((BYTE)0x84)    /* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */

#define MIDISTRM_ERROR      (-2)

/* */
/* Structures and defines for midiStreamProperty */
/* */
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L

/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

#endif /* WINVER <  0x0400 */
#define MIDIPROP_PROPVAL    0x3FFFFFFFL
#if(WINVER <  0x0400)
WINMMAPI MMRESULT WINAPI midiStreamOpen( OUT LPHMIDISTRM phms, IN LPUINT puDeviceID, IN DWORD cMidi, IN DWORD_PTR dwCallback, IN DWORD_PTR dwInstance, IN DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiStreamClose( IN HMIDISTRM hms);

WINMMAPI MMRESULT WINAPI midiStreamProperty( IN HMIDISTRM hms, OUT LPBYTE lppropdata, IN DWORD dwProperty);
WINMMAPI MMRESULT WINAPI midiStreamPosition( IN HMIDISTRM hms, OUT LPMMTIME lpmmt, IN UINT cbmmt);

WINMMAPI MMRESULT WINAPI midiStreamOut( IN HMIDISTRM hms, IN LPMIDIHDR pmh, IN UINT cbmh);
WINMMAPI MMRESULT WINAPI midiStreamPause( IN HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamRestart( IN HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamStop( IN HMIDISTRM hms);

#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiConnect( IN HMIDI hmi, IN HMIDIOUT hmo, IN LPVOID pReserved);
WINMMAPI MMRESULT WINAPI midiDisconnect( IN HMIDI hmi, IN HMIDIOUT hmo, IN LPVOID pReserved);
#endif
#endif /* WINVER <  0x0400 */
#endif  /* ifndef MMNOMIDI */
#ifndef MMNOAUX
#endif  /* ifndef MMNOAUX */
#ifndef MMNOMIXER
#define MIXER_OBJECTF_TYPEMASK  0xF0000000L
#define MIXERCAPS_SUPPORTF_xxx          0x00000000L
#define MIXER_OPENF_VALID       (MIXER_OBJECTF_TYPEMASK | CALLBACK_TYPEMASK)
#define MIXER_GETLINEINFOF_VALID            (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINEINFOF_QUERYMASK)
#define MIXER_GETIDF_VALID      (MIXER_OBJECTF_TYPEMASK)
#define MIXERCONTROL_CONTROLF_VALID     0x80000003L
#define MIXER_GETLINECONTROLSF_VALID    (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINECONTROLSF_QUERYMASK)
#define MIXER_GETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_GETCONTROLDETAILSF_QUERYMASK)
#define MIXER_SETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_SETCONTROLDETAILSF_QUERYMASK)
#endif /* ifndef MMNOMIXER */
#ifndef MMNOTIMER
#ifdef  BUILDDLL
typedef void (FAR PASCAL TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#else   /* ifdef BUILDDLL */
#endif  /* ifdef BUILDDLL */
#define TIME_CALLBACK_TYPEMASK      0x00F0
#endif  /* ifndef MMNOTIMER */
#ifndef MMNOJOY
#if(WINVER <  0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;                /* size of structure */
    DWORD dwFlags;               /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;                /* rudder/4th axis position */
    DWORD dwUpos;                /* 5th axis position */
    DWORD dwVpos;                /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;           /* reserved for communication between winmm & driver */
    DWORD dwReserved2;           /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER <  0x0400 */
#if(WINVER <  0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx( IN UINT uJoyID, OUT LPJOYINFOEX pji);
#endif /* WINVER <  0x0400 */
UINT WINAPI joySetCalibration(UINT uJoyID, LPUINT puXbase,
              LPUINT puXdelta, LPUINT puYbase, LPUINT puYdelta,
              LPUINT puZbase, LPUINT puZdelta);
#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyConfigChanged( IN DWORD dwFlags );
#endif
#endif  /* ifndef MMNOJOY */
#ifndef MMNOMMIO
#define MMIO_OPEN_VALID 0x0003FFFF      /* valid flags for mmioOpen */
#define MMIO_FLUSH_VALID MMIO_EMPTYBUF  /* valid flags for mmioFlush */
#define MMIO_ADVANCE_VALID (MMIO_WRITE | MMIO_READ)     /* valid flags for mmioAdvance */
#define MMIO_FOURCC_VALID MMIO_TOUPPER  /* valid flags for mmioStringToFOURCC */
#define MMIO_DESCEND_VALID (MMIO_FINDCHUNK | MMIO_FINDRIFF | MMIO_FINDLIST)
#define MMIO_CREATE_VALID (MMIO_CREATERIFF | MMIO_CREATELIST)

#define MMIO_WIN31_TASK 0x80000000
#define MMIO_VALIDPROC      0x10070000  /* valid for mmioInstallIOProc */
#endif  /* ifndef MMNOMMIO */
#ifndef MMNOMCI
#define MCI_SOUND                       0x0812
#define MCI_WIN32CLIENT                 0x0857
/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L


/* parameter block for MCI_SOUND command message */
#ifdef _WIN32

typedef struct tagMCI_SOUND_PARMSA {
    DWORD_PTR   dwCallback;
    LPCSTR      lpstrSoundName;
} MCI_SOUND_PARMSA, *PMCI_SOUND_PARMSA, *LPMCI_SOUND_PARMSA;
typedef struct tagMCI_SOUND_PARMSW {
    DWORD_PTR   dwCallback;
    LPCWSTR     lpstrSoundName;
} MCI_SOUND_PARMSW, *PMCI_SOUND_PARMSW, *LPMCI_SOUND_PARMSW;
#ifdef UNICODE
typedef MCI_SOUND_PARMSW MCI_SOUND_PARMS;
typedef PMCI_SOUND_PARMSW PMCI_SOUND_PARMS;
typedef LPMCI_SOUND_PARMSW LPMCI_SOUND_PARMS;
#else
typedef MCI_SOUND_PARMSA MCI_SOUND_PARMS;
typedef PMCI_SOUND_PARMSA PMCI_SOUND_PARMS;
typedef LPMCI_SOUND_PARMSA LPMCI_SOUND_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;
#endif

#endif  /* ifndef MMNOMCI */
/****************************************************************************

                        audiosrv MME PNP definitions

****************************************************************************/
#define MMDEVICEINFO_REMOVED 0x00000001

#define PAD_POINTER(p)          (PVOID)((((DWORD_PTR)(p))+7)&(~0x7))

typedef struct _MMDEVICEINTERFACEINFO {
    LONG            cPnpEvents;
    DWORD           fdwInfo;
    DWORD           SetupPreferredAudioCount;
    WCHAR           szName[1];
} MMDEVICEINTERFACEINFO, *PMMDEVICEINTERFACEINFO;

//  Note:  This structure MMNPNPINFO is used with a global file mapping, and
//         it is also used by DirectSound.
//
//         Don't modify unless absolutely necessary!!!

typedef struct _MMPNPINFO {
    DWORD                   cbSize;
    LONG                    cPnpEvents;
    LONG                    cPreferredDeviceChanges;
    LONG                    cDevInterfaces;
    HWND                    hwndNotify;
/*  MMDEVINTERFACEINFO      DevInfo[0]; */
} MMPNPINFO, *PMMPNPINFO;

#ifdef _WIN32
#define MMGLOBALPNPINFONAMEA "Global\\mmGlobalPnpInfo"
#define MMGLOBALPNPINFONAMEW L"Global\\mmGlobalPnpInfo"
#ifdef UNICODE
#define MMGLOBALPNPINFONAME MMGLOBALPNPINFONAMEW
#else
#define MMGLOBALPNPINFONAME MMGLOBALPNPINFONAMEA
#endif
#else
#define MMGLOBALPNPINFONAME "Global\\mmGlobalPnpInfo"
#endif


/****************************************************************************

                        GFX support

    A series of functions to support the GFX features of the control panel

****************************************************************************/

#define GFXTYPE_INVALID          0
#define GFXTYPE_RENDER           1
#define GFXTYPE_CAPTURE          2
#define GFXTYPE_RENDERCAPTURE    3

#define GFX_MAXORDER             (0x1000 - 1)

typedef struct _DEVICEINTERFACELIST
{
    LONG Count;
    PWSTR DeviceInterface[1];
} DEVICEINTERFACELIST, *PDEVICEINTERFACELIST;


WINMMAPI
LONG
WINAPI
gfxCreateZoneFactoriesList
(
    OUT PDEVICEINTERFACELIST *ppDeviceInterfaceList
);


WINMMAPI
LONG
WINAPI
gfxCreateGfxFactoriesList
(
     IN PCWSTR ZoneFactoryDi,
     OUT PDEVICEINTERFACELIST *ppDeviceInterfaceList
);


WINMMAPI
LONG
WINAPI
gfxDestroyDeviceInterfaceList
(
    IN PDEVICEINTERFACELIST pDiList
);


typedef LONG (CALLBACK* GFXENUMCALLBACK)(PVOID Context, DWORD Id, PCWSTR GfxFactoryDi, REFCLSID rclsid, ULONG Type, ULONG Order);

WINMMAPI
LONG
WINAPI
gfxEnumerateGfxs
(
    IN PCWSTR pstrZoneDeviceInterface,
    IN GFXENUMCALLBACK pGfxEnumCallback,
    IN PVOID Context
);


WINMMAPI
LONG
WINAPI
gfxRemoveGfx
(
    IN DWORD Id
);


WINMMAPI
LONG
WINAPI
gfxAddGfx
(
    IN PCWSTR ZoneFactoryDi,
    IN PCWSTR GfxFactoryDi,
    IN ULONG Type,
    IN ULONG Order,
    OUT PDWORD pNewId
);


WINMMAPI
LONG
WINAPI
gfxModifyGfx
(
    IN DWORD Id,
    IN ULONG Order
);

WINMMAPI
LONG
WINAPI
gfxOpenGfx
(
    IN DWORD dwGfxId,
    OUT HANDLE *pFileHandle
);

typedef struct _GFXREMOVEREQUEST {
    DWORD IdToRemove;
    LONG Error;
} GFXREMOVEREQUEST, *PGFXREMOVEREQUEST;


typedef struct _GFXMODIFYREQUEST {
    DWORD IdToModify;
    ULONG NewOrder;
    LONG Error;
} GFXMODIFYREQUEST, *PGFXMODIFYREQUEST;


typedef struct _GFXADDREQUEST {
    PWSTR ZoneFactoryDi;
    PWSTR GfxFactoryDi;
    ULONG Type;
    ULONG Order;
    DWORD NewId;
    LONG Error;
} GFXADDREQUEST, *PGFXADDREQUEST;


WINMMAPI
LONG
WINAPI
gfxBatchChange
(
    PGFXREMOVEREQUEST paGfxRemoveRequests,
    ULONG cGfxRemoveRequests,
    PGFXMODIFYREQUEST paGfxModifyRequests,
    ULONG cGfxModifyRequests,
    PGFXADDREQUEST paGfxAddRequests,
    ULONG cGfxAddRequests
);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif
#endif  /* _INC_MMSYSP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\propertyhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Helpers for implementation of ISpecifyPropertyPages and IPersistStream
//

#pragma once
#include "ocidl.h"

// Paste these declarations into your class methods to implement the interfaces.  Replace DSFXZZZ with the name of your struct.
// These assume that you implement GetAllParameters/SetAllParameters interfaces with a struct and that you have a public m_fDirty
// member variable that you use to hold the dirty state of your object for persistence.

/*
    // ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID * pPages) { return PropertyHelp::GetPages(CLSID_DirectSoundPropZZZ, pPages); }

    // IPersistStream
    STDMETHOD(IsDirty)(void) { return m_fDirty ? S_OK : S_FALSE; }
    STDMETHOD(Load)(IStream *pStm) { return PropertyHelp::Load(this, DSFXZZZ(), pStm); }
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty) { return PropertyHelp::Save(this, DSFXZZZ(), pStm, fClearDirty); }
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize) { if (!pcbSize) return E_POINTER; pcbSize->QuadPart = sizeof(DSFXZZZ); return S_OK; }
*/

// Load, Save, and GetPages are actually implemented in the following functions.

namespace PropertyHelp
{
    HRESULT GetPages(const CLSID &rclsidPropertyPage, CAUUID * pPages);

    template<class O, class S> HRESULT Load(O *pt_object, S &t_struct, IStream *pStm)
    {
        ULONG cbRead;
        HRESULT hr;

        if (pStm==NULL)
        	return E_POINTER;

        hr = pStm->Read(&t_struct, sizeof(t_struct), &cbRead);
        if (hr != S_OK || cbRead < sizeof(t_struct))
            return E_FAIL;

        hr = pt_object->SetAllParameters(&t_struct);
        pt_object->m_fDirty = false;
        return hr;
    }

    template<class O, class S> HRESULT Save(O *pt_object, S &t_struct, IStream *pStm, BOOL fClearDirty)
    {
        HRESULT hr; 

        if (pStm==NULL)
        	return E_POINTER;

        hr = pt_object->GetAllParameters(&t_struct);
        if (FAILED(hr))
            return hr;

        ULONG cbWritten;
        hr = pStm->Write(&t_struct, sizeof(t_struct), &cbWritten);
        if (hr != S_OK || cbWritten < sizeof(t_struct))
            return E_FAIL;

        if (fClearDirty)
            pt_object->m_fDirty = false;
        return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\mmddkp.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif

#ifdef  NOMIDIDEV       /* ;Internal */
#define MMNOMIDIDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOWAVEDEV       /* ;Internal */
#define MMNOWAVEDEV     /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOAUXDEV        /* ;Internal */
#define MMNOAUXDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTIMERDEV      /* ;Internal */
#define MMNOTIMERDEV        /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOJOYDEV        /* ;Internal */
#define MMNOJOYDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOMCIDEV        /* ;Internal */
#define MMNOMCIDEV      /* ;Internal */
#endif              /* ;Internal */
#ifdef  NOTASKDEV       /* ;Internal */
#define MMNOTASKDEV     /* ;Internal */
#endif              /* ;Internal */

/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#ifndef DRVM_MAPPER
#define DRVM_MAPPER             (0x2000)
#endif
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal */
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal */
#define DRVM_MAPPER_CONSOLEVOICECOM_GET           (DRVM_MAPPER+23)
#define DRVM_MAPPER_CONSOLEVOICECOM_SET           (DRVM_MAPPER+24) /* ;Internal */

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal */
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal */
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal */
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal */
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal */
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal */
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#define DRV_QUERYSTRINGID            (DRV_RESERVED + 14)
#define DRV_QUERYSTRINGIDSIZE        (DRV_RESERVED + 15)
#define DRV_QUERYIDFROMSTRINGID      (DRV_RESERVED + 16)

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
#ifdef  BUILDDLL                                            /* ;Internal */
typedef VOID (FAR PASCAL TASKCALLBACK) (DWORD_PTR dwInst);  /* ;Internal */
#else                                                       /* ;Internal */
typedef VOID (TASKCALLBACK) (DWORD_PTR dwInst);
#endif  // ifdef BUILDDLL                                   /* ;Internal */

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\msacm.h ===
//==========================================================================;
//
//  msacm.h
//
//  Copyright (c) 1992-2002 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACM
#define _INC_ACM        /* #defined if msacm.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_MMREG) || (_INC_MMREG < 142)
#ifndef RC_INVOKED
#error MMREG.H version 142 or greater to be included first
#endif
#endif

#if defined(WIN32) && !defined(_WIN32)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _WIN32 because application defined WIN32")
#endif
#define _WIN32
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _UNICODE because application defined UNICODE")
#endif
#define _UNICODE
#endif

#include "pshpack1.h"   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef DRV_MAPPER_PREFERRED_INPUT_GET
#define DRV_MAPPER_PREFERRED_INPUT_GET  (DRV_USER + 0)
#endif

#ifndef DRV_MAPPER_PREFERRED_OUTPUT_GET
#define DRV_MAPPER_PREFERRED_OUTPUT_GET (DRV_USER + 2)
#endif


#ifndef DRVM_MAPPER_STATUS
#define DRVM_MAPPER             (0x2000)
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#endif

#ifndef WIDM_MAPPER_STATUS
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
#endif

#ifndef WODM_MAPPER_STATUS
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
    #define ACMAPI              WINAPI
#else
#ifdef _WINDLL
    #define ACMAPI              _far _pascal _loadds
#else
    #define ACMAPI              _far _pascal
#endif
#endif


//--------------------------------------------------------------------------;
//
//  ACM General API's and Defines
//
//
//
//
//--------------------------------------------------------------------------;

//
//  there are four types of 'handles' used by the ACM. the first three
//  are unique types that define specific objects:
//
//  HACMDRIVERID: used to _identify_ an ACM driver. this identifier can be
//  used to _open_ the driver for querying details, etc about the driver.
//
//  HACMDRIVER: used to manage a driver (codec, filter, etc). this handle
//  is much like a handle to other media drivers--you use it to send
//  messages to the converter, query for capabilities, etc.
//
//  HACMSTREAM: used to manage a 'stream' (conversion channel) with the
//  ACM. you use a stream handle to convert data from one format/type
//  to another--much like dealing with a file handle.
//
//
//  the fourth handle type is a generic type used on ACM functions that
//  can accept two or more of the above handle types (for example the
//  acmMetrics and acmDriverID functions).
//
//  HACMOBJ: used to identify ACM objects. this handle is used on functions
//  that can accept two or more ACM handle types.
//
DECLARE_HANDLE(HACMDRIVERID);
typedef HACMDRIVERID       *PHACMDRIVERID;
typedef HACMDRIVERID   FAR *LPHACMDRIVERID;

DECLARE_HANDLE(HACMDRIVER);
typedef HACMDRIVER         *PHACMDRIVER;
typedef HACMDRIVER     FAR *LPHACMDRIVER;

DECLARE_HANDLE(HACMSTREAM);
typedef HACMSTREAM         *PHACMSTREAM;
typedef HACMSTREAM     FAR *LPHACMSTREAM;

DECLARE_HANDLE(HACMOBJ);
typedef HACMOBJ            *PHACMOBJ;
typedef HACMOBJ        FAR *LPHACMOBJ;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Error Codes
//
//  Note that these error codes are specific errors that apply to the ACM
//  directly--general errors are defined as MMSYSERR_*.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

#define ACMERR_BASE         (512)
#define ACMERR_NOTPOSSIBLE  (ACMERR_BASE + 0)
#define ACMERR_BUSY         (ACMERR_BASE + 1)
#define ACMERR_UNPREPARED   (ACMERR_BASE + 2)
#define ACMERR_CANCELED     (ACMERR_BASE + 3)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Window Messages
//
//  These window messages are sent by the ACM or ACM drivers to notify
//  applications of events.
//
//  Note that these window message numbers will also be defined in
//  mmsystem.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MM_ACM_OPEN         (MM_STREAM_OPEN)  // conversion callback messages
#define MM_ACM_CLOSE        (MM_STREAM_CLOSE)
#define MM_ACM_DONE         (MM_STREAM_DONE)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmGetVersion()
//
//  the ACM version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

DWORD ACMAPI acmGetVersion
(
    void
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmMetrics()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
);

#define ACM_METRIC_COUNT_DRIVERS            1
#define ACM_METRIC_COUNT_CODECS             2
#define ACM_METRIC_COUNT_CONVERTERS         3
#define ACM_METRIC_COUNT_FILTERS            4
#define ACM_METRIC_COUNT_DISABLED           5
#define ACM_METRIC_COUNT_HARDWARE           6
#define ACM_METRIC_COUNT_LOCAL_DRIVERS      20
#define ACM_METRIC_COUNT_LOCAL_CODECS       21
#define ACM_METRIC_COUNT_LOCAL_CONVERTERS   22
#define ACM_METRIC_COUNT_LOCAL_FILTERS      23
#define ACM_METRIC_COUNT_LOCAL_DISABLED     24
#define ACM_METRIC_HARDWARE_WAVE_INPUT      30
#define ACM_METRIC_HARDWARE_WAVE_OUTPUT     31
#define ACM_METRIC_MAX_SIZE_FORMAT          50
#define ACM_METRIC_MAX_SIZE_FILTER          51
#define ACM_METRIC_DRIVER_SUPPORT           100
#define ACM_METRIC_DRIVER_PRIORITY          101


//--------------------------------------------------------------------------;
//
//  ACM Drivers
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef BOOL (CALLBACK *ACMDRIVERENUMCB)
(
    HACMDRIVERID            hadid,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);

#define ACM_DRIVERENUMF_NOTIFY      0x10000000L     // ;Internal
#define ACM_DRIVERENUMF_REMOVED	    0x20000000L	    // ;Internal
#define ACM_DRIVERENUMF_NOLOCAL     0x40000000L
#define ACM_DRIVERENUMF_DISABLED    0x80000000L
#define ACM_DRIVERENUMF_VALID       0xF0000000L     // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverID()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverID
);

#define ACM_DRIVERIDF_VALID         (0L)        /* ;Internal */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverAdd()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

MMRESULT ACMAPI acmDriverAddW
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

#ifdef _UNICODE
#define acmDriverAdd        acmDriverAddW
#else
#define acmDriverAdd        acmDriverAddA
#endif
#else
MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);
#endif

#define ACM_DRIVERADDF_NAME         0x00000001L
#define ACM_DRIVERADDF_NOTIFY       0x00000002L  // ;Internal
#define ACM_DRIVERADDF_FUNCTION     0x00000003L  // lParam is a procedure
#define ACM_DRIVERADDF_NOTIFYHWND   0x00000004L  // lParam is notify hwnd
#define ACM_DRIVERADDF_TYPEMASK     0x00000007L  // driver type mask
#define ACM_DRIVERADDF_LOCAL        0x00000000L  // is local to current task
#define ACM_DRIVERADDF_GLOBAL       0x00000008L  // is global
#define ACM_DRIVERADDF_32BIT        0x80000000L  // ;Internal
#define ACM_DRIVERADDF_PNP	    0x40000000L	//  ;Internal
#define ACM_DRIVERADDF_VALID        (ACM_DRIVERADDF_TYPEMASK | /* ;Internal */ \
                                     ACM_DRIVERADDF_GLOBAL) /* ;Internal */ 



//
//  prototype for ACM driver procedures that are installed as _functions_
//  or _notifations_ instead of as a standalone installable driver.
//
typedef LRESULT (CALLBACK *ACMDRIVERPROC)(DWORD_PTR, HACMDRIVERID, UINT, LPARAM, LPARAM);
typedef ACMDRIVERPROC FAR *LPACMDRIVERPROC;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverRemove()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
);

#define ACM_DRIVERREMOVEF_UNINSTALL 0x00000001L	    // ;Internal
#define ACM_DRIVERREMOVEF_VALID     (1L)	    // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad, 
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
);

#define ACM_DRIVEROPENF_VALID       (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
);

#define ACM_DRIVERCLOSEF_VALID      (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
);


//
//
//
//
#define ACMDM_USER                  (DRV_USER + 0x0000)
#define ACMDM_RESERVED_LOW          (DRV_USER + 0x2000)
#define ACMDM_RESERVED_HIGH         (DRV_USER + 0x2FFF)

#define ACMDM_BASE                  ACMDM_RESERVED_LOW

#define ACMDM_DRIVER_ABOUT          (ACMDM_BASE + 11)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverPriority
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);


#define ACM_DRIVERPRIORITYF_ENABLE      0x00000001L
#define ACM_DRIVERPRIORITYF_DISABLE     0x00000002L
#define ACM_DRIVERPRIORITYF_ABLEMASK    0x00000003L
#define ACM_DRIVERPRIORITYF_BEGIN       0x00010000L
#define ACM_DRIVERPRIORITYF_END         0x00020000L
#define ACM_DRIVERPRIORITYF_DEFERMASK   0x00030000L

#define ACM_DRIVERPRIORITYF_VALID       0x00030003L     // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  ACMDRIVERDETAILS
//
//  the ACMDRIVERDETAILS structure is used to get various capabilities from
//  an ACM driver (codec, converter, filter).
//
#define ACMDRIVERDETAILS_SHORTNAME_CHARS    32
#define ACMDRIVERDETAILS_LONGNAME_CHARS     128
#define ACMDRIVERDETAILS_COPYRIGHT_CHARS    80
#define ACMDRIVERDETAILS_LICENSING_CHARS    128
#define ACMDRIVERDETAILS_FEATURES_CHARS     512

#ifdef _WIN32
typedef struct tACMDRIVERDETAILSA
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSA, *PACMDRIVERDETAILSA, FAR *LPACMDRIVERDETAILSA;

typedef struct tACMDRIVERDETAILSW
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    WCHAR           szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    WCHAR           szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    WCHAR           szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    WCHAR           szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    WCHAR           szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSW, *PACMDRIVERDETAILSW, FAR *LPACMDRIVERDETAILSW;

#ifdef _UNICODE
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW
#else
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSA
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSA
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSA
#endif
#else
typedef struct tACMDRIVERDETAILS
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILS, *PACMDRIVERDETAILS, FAR *LPACMDRIVERDETAILS;
#endif

//
//  ACMDRIVERDETAILS.fccType
//
//  ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC: the FOURCC used in the fccType
//  field of the ACMDRIVERDETAILS structure to specify that this is an ACM
//  codec designed for audio.
//
//
//  ACMDRIVERDETAILS.fccComp
//
//  ACMDRIVERDETAILS_FCCCOMP_UNDEFINED: the FOURCC used in the fccComp
//  field of the ACMDRIVERDETAILS structure. this is currently an unused
//  field.
//
#define ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC mmioFOURCC('a', 'u', 'd', 'c')
#define ACMDRIVERDETAILS_FCCCOMP_UNDEFINED  mmioFOURCC('\0', '\0', '\0', '\0')


//
//  the following flags are used to specify the type of conversion(s) that
//  the converter/codec/filter supports. these are placed in the fdwSupport
//  field of the ACMDRIVERDETAILS structure. note that a converter can
//  support one or more of these flags in any combination.
//
//  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver supports
//  conversions from one format tag to another format tag. for example, if a
//  converter compresses WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, then this bit
//  should be set.
//
//  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the driver
//  supports conversions on the same format tag. as an example, the PCM
//  converter that is built into the ACM sets this bit (and only this bit)
//  because it converts only PCM formats (bits, sample rate).
//
//  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver supports
//  transformations on a single format. for example, a converter that changed
//  the 'volume' of PCM data would set this bit. 'echo' and 'reverb' are
//  also filter types.
//
//  ACMDRIVERDETAILS_SUPPORTF_HARDWARE: this flag is set if the driver supports
//  hardware input and/or output through a waveform device.
//
//  ACMDRIVERDETAILS_SUPPORTF_ASYNC: this flag is set if the driver supports
//  async conversions.
//
//
//  ACMDRIVERDETAILS_SUPPORTF_LOCAL: this flag is set _by the ACM_ if a
//  driver has been installed local to the current task. this flag is also
//  set in the fdwSupport argument to the enumeration callback function
//  for drivers.
//
//  ACMDRIVERDETAILS_SUPPORTF_DISABLED: this flag is set _by the ACM_ if a
//  driver has been disabled. this flag is also passed set in the fdwSupport
//  argument to the enumeration callback function for drivers.
//
#define ACMDRIVERDETAILS_SUPPORTF_CODEC     0x00000001L
#define ACMDRIVERDETAILS_SUPPORTF_CONVERTER 0x00000002L
#define ACMDRIVERDETAILS_SUPPORTF_FILTER    0x00000004L
#define ACMDRIVERDETAILS_SUPPORTF_HARDWARE  0x00000008L
#define ACMDRIVERDETAILS_SUPPORTF_ASYNC     0x00000010L
#define ACMDRIVERDETAILS_SUPPORTF_NOTIFY    0x10000000L     // ;Internal
#define ACMDRIVERDETAILS_SUPPORTF_LOCAL     0x40000000L
#define ACMDRIVERDETAILS_SUPPORTF_DISABLED  0x80000000L


#ifdef _WIN32
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmDriverDetailsW
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmDriverDetails    acmDriverDetailsW
#else
#define acmDriverDetails    acmDriverDetailsA
#endif
#else
MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
);
#endif

#define ACM_DRIVERDETAILSF_VALID    (0L)        // ;Internal


 
//--------------------------------------------------------------------------;
//
//  ACM Format Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagDetails()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATTAGDETAILS_FORMATTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFORMATTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSA, *PACMFORMATTAGDETAILSA, FAR *LPACMFORMATTAGDETAILSA;

typedef struct tACMFORMATTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSW, *PACMFORMATTAGDETAILSW, FAR *LPACMFORMATTAGDETAILSW;

#ifdef _UNICODE
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW
#else
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSA
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSA
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSA
#endif
#else
typedef struct tACMFORMATTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILS, *PACMFORMATTAGDETAILS, FAR *LPACMFORMATTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatTagDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatTagDetails     acmFormatTagDetailsW
#else
#define acmFormatTagDetails     acmFormatTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATTAGDETAILSF_INDEX         0x00000000L
#define ACM_FORMATTAGDETAILSF_FORMATTAG     0x00000001L
#define ACM_FORMATTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FORMATTAGDETAILSF_QUERYMASK     0x0000000FL

#define ACM_FORMATTAGDETAILSF_VALID         (ACM_FORMATTAGDETAILSF_QUERYMASK)   /* ;Internal */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    ACMFORMATTAGENUMCBW     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBW
#define acmFormatTagEnum        acmFormatTagEnumW
#else
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBA
#define acmFormatTagEnum        acmFormatTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FORMATTAGENUMF_VALID    (0L)        // ;Internal


//--------------------------------------------------------------------------;
//
//  ACM Formats
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATDETAILS_FORMAT_CHARS   128

#ifdef _WIN32
typedef struct tACMFORMATDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSA, *PACMFORMATDETAILSA, FAR *LPACMFORMATDETAILSA;

typedef struct tACMFORMATDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSW, *PACMFORMATDETAILSW, FAR *LPACMFORMATDETAILSW;

#ifdef _UNICODE
#define ACMFORMATDETAILS    ACMFORMATDETAILSW
#define PACMFORMATDETAILS   PACMFORMATDETAILSW
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSW
#else
#define ACMFORMATDETAILS    ACMFORMATDETAILSA
#define PACMFORMATDETAILS   PACMFORMATDETAILSA
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSA
#endif
#else
typedef struct tACMFORMATDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILS, *PACMFORMATDETAILS, FAR *LPACMFORMATDETAILS;
#endif


#ifdef _WIN32
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatDetails    acmFormatDetailsW
#else
#define acmFormatDetails    acmFormatDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATDETAILSF_INDEX        0x00000000L
#define ACM_FORMATDETAILSF_FORMAT       0x00000001L
#define ACM_FORMATDETAILSF_QUERYMASK    0x0000000FL

#define ACM_FORMATDETAILSF_VALID        (ACM_FORMATDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSA     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFORMATENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSW     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATENUMCB     ACMFORMATENUMCBW
#define acmFormatEnum       acmFormatEnumW
#else
#define ACMFORMATENUMCB     ACMFORMATENUMCBA
#define acmFormatEnum       acmFormatEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FORMATENUMF_WFORMATTAG       0x00010000L
#define ACM_FORMATENUMF_NCHANNELS        0x00020000L
#define ACM_FORMATENUMF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATENUMF_WBITSPERSAMPLE   0x00080000L
#define ACM_FORMATENUMF_CONVERT          0x00100000L
#define ACM_FORMATENUMF_SUGGEST          0x00200000L
#define ACM_FORMATENUMF_HARDWARE         0x00400000L
#define ACM_FORMATENUMF_INPUT            0x00800000L
#define ACM_FORMATENUMF_OUTPUT           0x01000000L

#define ACM_FORMATENUMF_VALID           (0x01FF0000L)    // ;Internal

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatSuggest()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
);

#define ACM_FORMATSUGGESTF_WFORMATTAG       0x00010000L
#define ACM_FORMATSUGGESTF_NCHANNELS        0x00020000L
#define ACM_FORMATSUGGESTF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATSUGGESTF_WBITSPERSAMPLE   0x00080000L

#define ACM_FORMATSUGGESTF_TYPEMASK         0x00FF0000L
#define ACM_FORMATSUGGESTF_VALID            (ACM_FORMATSUGGESTF_TYPEMASK) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
#define ACMHELPMSGSTRINGA       "acmchoose_help"
#define ACMHELPMSGSTRINGW       L"acmchoose_help"
#define ACMHELPMSGCONTEXTMENUA  "acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTMENUW  L"acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTHELPA  "acmchoose_contexthelp"
#define ACMHELPMSGCONTEXTHELPW  L"acmchoose_contexthelp"
#ifdef _UNICODE
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGW
#define ACMHELPMSGCONTEXTMENU   ACMHELPMSGCONTEXTMENUW
#define ACMHELPMSGCONTEXTHELP   ACMHELPMSGCONTEXTHELPW
#else
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGA
#define ACMHELPMSGCONTEXTMENU   ACMHELPMSGCONTEXTMENUA
#define ACMHELPMSGCONTEXTHELP   ACMHELPMSGCONTEXTHELPA
#endif
#else
#define ACMHELPMSGSTRING        "acmchoose_help"
#define ACMHELPMSGCONTEXTMENU   "acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTHELP   "acmchoose_contexthelp"
#endif

//
//  MM_ACM_FORMATCHOOSE is sent to hook callbacks by the Format Chooser
//  Dialog...
//
#define MM_ACM_FORMATCHOOSE             (0x8000)

#define FORMATCHOOSE_MESSAGE            0
#define FORMATCHOOSE_FORMATTAG_VERIFY   (FORMATCHOOSE_MESSAGE+0)
#define FORMATCHOOSE_FORMAT_VERIFY      (FORMATCHOOSE_MESSAGE+1)
#define FORMATCHOOSE_CUSTOM_VERIFY      (FORMATCHOOSE_MESSAGE+2)

#define FORMATCHOOSE_FORMATTAG_ADD      (FORMATCHOOSE_MESSAGE+3)    // ;Internal
#define FORMATCHOOSE_FORMAT_ADD         (FORMATCHOOSE_MESSAGE+4)    // ;Internal

#ifdef _WIN32
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCW
#else
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//
//
//
#ifdef _WIN32
typedef struct tACMFORMATCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCA pfnHook;   // ptr to hook function

} ACMFORMATCHOOSEA, *PACMFORMATCHOOSEA, FAR *LPACMFORMATCHOOSEA;

typedef struct tACMFORMATCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCWSTR         pszTitle;           // dialog box title bar
    
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCW pfnHook;   // ptr to hook function

} ACMFORMATCHOOSEW, *PACMFORMATCHOOSEW, FAR *LPACMFORMATCHOOSEW;

#ifdef _UNICODE
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEW
#else
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEA
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEA
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEA
#endif
#else
typedef struct tACMFORMATCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFORMATCHOOSE, *PACMFORMATCHOOSE, FAR *LPACMFORMATCHOOSE;
#endif

//
//  ACMFORMATCHOOSE.fdwStyle
//
//
//
#define ACMFORMATCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFORMATCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT       0x00000040L
#define ACMFORMATCHOOSE_STYLEF_CONTEXTHELP           0x00000080L
#define ACMFORMATCHOOSE_STYLEF_VALID                (0x000000FCL) // ;Internal

#ifdef _WIN32
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafmtc
);

MMRESULT ACMAPI acmFormatChooseW
(
    LPACMFORMATCHOOSEW      pafmtc
);

#ifdef _UNICODE
#define acmFormatChoose     acmFormatChooseW
#else
#define acmFormatChoose     acmFormatChooseA
#endif
#else
MMRESULT ACMAPI acmFormatChoose
(
    LPACMFORMATCHOOSE       pafmtc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Filter Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERTAGDETAILS_FILTERTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFILTERTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSA, *PACMFILTERTAGDETAILSA, FAR *LPACMFILTERTAGDETAILSA;

typedef struct tACMFILTERTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSW, *PACMFILTERTAGDETAILSW, FAR *LPACMFILTERTAGDETAILSW;

#ifdef _UNICODE
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW
#else
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSA
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSA
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSA
#endif
#else
typedef struct tACMFILTERTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILS, *PACMFILTERTAGDETAILS, FAR *LPACMFILTERTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterTagDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFilterTagDetails     acmFilterTagDetailsW
#else
#define acmFilterTagDetails     acmFilterTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERTAGDETAILSF_INDEX         0x00000000L
#define ACM_FILTERTAGDETAILSF_FILTERTAG     0x00000001L
#define ACM_FILTERTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FILTERTAGDETAILSF_QUERYMASK     0x0000000FL

#define ACM_FILTERTAGDETAILSF_VALID         (ACM_FILTERTAGDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    ACMFILTERTAGENUMCBW     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBW
#define acmFilterTagEnum    acmFilterTagEnumW
#else
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBA
#define acmFilterTagEnum    acmFilterTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FILTERTAGENUMF_VALID        (0L)        // ;Internal


//--------------------------------------------------------------------------;
//
//  ACM Filters
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERDETAILS_FILTER_CHARS   128

#ifdef _WIN32
typedef struct tACMFILTERDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSA, *PACMFILTERDETAILSA, FAR *LPACMFILTERDETAILSA;

typedef struct tACMFILTERDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSW, *PACMFILTERDETAILSW, FAR *LPACMFILTERDETAILSW;

#ifdef _UNICODE
#define ACMFILTERDETAILS    ACMFILTERDETAILSW
#define PACMFILTERDETAILS   PACMFILTERDETAILSW
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSW
#else
#define ACMFILTERDETAILS    ACMFILTERDETAILSA
#define PACMFILTERDETAILS   PACMFILTERDETAILSA
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSA
#endif
#else
typedef struct tACMFILTERDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILS, *PACMFILTERDETAILS, FAR *LPACMFILTERDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   fdwDetails
);
#ifdef _UNICODE
#define acmFilterDetails    acmFilterDetailsW
#else
#define acmFilterDetails    acmFilterDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERDETAILSF_INDEX        0x00000000L
#define ACM_FILTERDETAILSF_FILTER       0x00000001L
#define ACM_FILTERDETAILSF_QUERYMASK    0x0000000FL

#define ACM_FILTERDETAILSF_VALID        (ACM_FILTERDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSA     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSW     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    ACMFILTERENUMCBW        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERENUMCB     ACMFILTERENUMCBW
#define acmFilterEnum       acmFilterEnumW
#else
#define ACMFILTERENUMCB     ACMFILTERENUMCBA
#define acmFilterEnum       acmFilterEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FILTERENUMF_DWFILTERTAG         0x00010000L

#define ACM_FILTERENUMF_VALID               0x00010000L     // ;Internal



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  MM_ACM_FILTERCHOOSE is sent to hook callbacks by the Filter Chooser
//  Dialog...
//
#define MM_ACM_FILTERCHOOSE             (0x8000)

#define FILTERCHOOSE_MESSAGE            0
#define FILTERCHOOSE_FILTERTAG_VERIFY   (FILTERCHOOSE_MESSAGE+0)
#define FILTERCHOOSE_FILTER_VERIFY      (FILTERCHOOSE_MESSAGE+1)
#define FILTERCHOOSE_CUSTOM_VERIFY      (FILTERCHOOSE_MESSAGE+2)

#define FILTERCHOOSE_FILTERTAG_ADD      (FILTERCHOOSE_MESSAGE+3)    // ;Internal
#define FILTERCHOOSE_FILTER_ADD         (FILTERCHOOSE_MESSAGE+4)    // ;Internal

#ifdef _WIN32
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCW
#else
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//  ACMFILTERCHOOSE
//
//
#ifdef _WIN32
typedef struct tACMFILTERCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCA pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEA, *PACMFILTERCHOOSEA, FAR *LPACMFILTERCHOOSEA;

typedef struct tACMFILTERCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCWSTR         pszTitle;

    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCW pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEW, *PACMFILTERCHOOSEW, FAR *LPACMFILTERCHOOSEW;

#ifdef _UNICODE
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEW
#else
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEA
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEA
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEA
#endif
#else
typedef struct tACMFILTERCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFILTERCHOOSE, *PACMFILTERCHOOSE, FAR *LPACMFILTERCHOOSE;
#endif

//
//  ACMFILTERCHOOSE.fdwStyle
//
//
#define ACMFILTERCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFILTERCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT    0x00000040L
#define ACMFILTERCHOOSE_STYLEF_CONTEXTHELP           0x00000080L
#define ACMFILTERCHOOSE_STYLEF_VALID                (0x000000FCL) // ;Internal

#ifdef _WIN32
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafltrc
);

MMRESULT ACMAPI acmFilterChooseW
(
    LPACMFILTERCHOOSEW      pafltrc
);

#ifdef _UNICODE
#define acmFilterChoose     acmFilterChooseW
#else
#define acmFilterChoose     acmFilterChooseA
#endif
#else
MMRESULT ACMAPI acmFilterChoose
(
    LPACMFILTERCHOOSE       pafltrc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Stream API's
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
#ifdef  _WIN64
#define _DRVRESERVED    15
#else
#define _DRVRESERVED    10
#endif  // _WIN64

typedef struct tACMSTREAMHEADER
{
    DWORD           cbStruct;               // sizeof(ACMSTREAMHEADER)
    DWORD           fdwStatus;              // ACMSTREAMHEADER_STATUSF_*
    DWORD_PTR       dwUser;                 // user instance data for hdr
    LPBYTE          pbSrc;
    DWORD           cbSrcLength;
    DWORD           cbSrcLengthUsed;
    DWORD_PTR       dwSrcUser;              // user instance data for src
    LPBYTE          pbDst;
    DWORD           cbDstLength;
    DWORD           cbDstLengthUsed;
    DWORD_PTR       dwDstUser;              // user instance data for dst
    DWORD           dwReservedDriver[_DRVRESERVED];   // driver reserved work space

} ACMSTREAMHEADER, *PACMSTREAMHEADER, FAR *LPACMSTREAMHEADER;

//
//  ACMSTREAMHEADER.fdwStatus
//
//  ACMSTREAMHEADER_STATUSF_DONE: done bit for async conversions.
//
#define ACMSTREAMHEADER_STATUSF_DONE        0x00010000L
#define ACMSTREAMHEADER_STATUSF_PREPARED    0x00020000L
#define ACMSTREAMHEADER_STATUSF_INQUEUE     0x00100000L

#define ACMSTREAMHEADER_STATUSF_VALID       0x00130000L     // ;Internal


MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,       // pointer to stream handle
    HACMDRIVER              had,        // optional driver handle
    LPWAVEFORMATEX          pwfxSrc,    // source format to convert
    LPWAVEFORMATEX          pwfxDst,    // required destination format
    LPWAVEFILTER            pwfltr,     // optional filter
    DWORD_PTR               dwCallback, // callback
    DWORD_PTR               dwInstance, // callback instance data
    DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
);

#define ACM_STREAMOPENF_QUERY           0x00000001
#define ACM_STREAMOPENF_ASYNC           0x00000002
#define ACM_STREAMOPENF_NONREALTIME     0x00000004
#define ACM_STREAMOPENF_VALID           (CALLBACK_TYPEMASK | 0x00000007L) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM              has,
    DWORD                   fdwClose
);

#define ACM_STREAMCLOSEF_VALID          (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamSize()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
);

#define ACM_STREAMSIZEF_SOURCE          0x00000000L
#define ACM_STREAMSIZEF_DESTINATION     0x00000001L
#define ACM_STREAMSIZEF_QUERYMASK       0x0000000FL

#define ACM_STREAMSIZEF_VALID           (ACM_STREAMSIZEF_QUERYMASK) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamReset()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM              has,
    DWORD                   fdwReset
);

#define ACM_STREAMRESETF_VALID          (0L)        // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamMessage
(
    HACMSTREAM              has,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamConvert()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
);

#define ACM_STREAMCONVERTF_BLOCKALIGN   0x00000004
#define ACM_STREAMCONVERTF_START        0x00000010
#define ACM_STREAMCONVERTF_END          0x00000020
#define ACM_STREAMCONVERTF_VALID        (ACM_STREAMCONVERTF_BLOCKALIGN | /* ;Internal */ \
                                         ACM_STREAMCONVERTF_END | /* ;Internal */ \
                                         ACM_STREAMCONVERTF_START) /* ;Internal */ 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamPrepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);

#define ACM_STREAMPREPAREF_VALID        (0L)        // ;Internal



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamUnprepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);
                                       
#define ACM_STREAMUNPREPAREF_VALID      (0L)        // ;Internal


#include "poppack.h"    /* Revert to default packing */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\synth.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    synth.h

Abstract:

    This include file defines constants and types for
    the Microsoft midi synthesizer driver

    This header file is shared between the low level driver and the
    kernel mode driver.

Author:

    Robin Speed (RobinSp) 20-Oct-92

Revision History:

--*/

#define STR_DRIVERNAME L"synth"
#define STR_MV_DRIVERNAME L"mvopl3"
#define STR_OPL3_DEVICENAME L"\\Device\\opl3.mid"
#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 *  Why on earth isn't there a type for sharing short data?
 */

 typedef struct {
     unsigned short IoPort;
     unsigned short PortData;
 } SYNTH_DATA, *PSYNTH_DATA;

/* positions within FM */
#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/*
**  Special IOCTL
*/

#define IOCTL_MIDI_SET_OPL3_MODE CTL_CODE(IOCTL_SOUND_BASE, IOCTL_MIDI_BASE + 0x000A, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\segment.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-1999.
//
//--------------------------------------------------------------------------;
//
// segment.cpp : implementation of various graph segment extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <bdamedia.h>

#include "devices.h"
#include "seg.h"

#include "closedcaptioning.h"
#include "MSViddataservices.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidClosedCaptioning, CClosedCaptioning)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServices, CDataServices)

// VWSegment
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = &std_arity1_member(&IMSVidGraphSegment::EnumFilters);
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#else
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = NULL;
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#endif

namespace MSVideoControl {
// work around compiler bug as per above description
void CtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    VWGraphSegment::Fetch = new std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT>(&IMSVidGraphSegment::EnumFilters);
}

// work around compiler bug as per above description
void DtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    delete VWGraphSegment::Fetch;
}

VWSegmentContainer VWGraphSegment::Container(void) {
    VWSegmentContainer g;
    HRESULT hr = (*this)->get_Container(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

MSVidSegmentType VWGraphSegment::Type(void) {
    MSVidSegmentType t;
    HRESULT hr = (*this)->get_Type(&t);
    ASSERT(SUCCEEDED(hr));
    return t;
}

DSGraph VWGraphSegment::Graph(void) {
    DSGraph g;
    HRESULT hr = (Container())->get_Graph(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::Category(void) {
    GUID2 g;
    HRESULT hr = (*this)->get_Category(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::ClassID(void) {
    GUID2 g;
    HRESULT hr = (*this)->GetClassID(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - segment.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\sndblst.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992  Microsoft Corporation

Module Name:

    sndblst.h

Abstract:

    This include file defines constants and types for
    the Sound blaster card.

	This header file is shared between the low level driver and the
	kernel driver.

Revision History:

--*/

#define SOUND_DEF_DMACHANNEL   1        // DMA channel no
#define SOUND_DEF_DMACHANNEL16 5        // DMA channel no 5
#define SOUND_DEF_INT          7
#define SOUND_DEF_PORT         0x220
#define SOUND_DEF_MPU401_PORT  0x330

#define NUMBER_OF_SOUND_PORTS (0x10)
#define NUMBER_OF_MPU401_PORTS (0x02)

/*
**  Registry value names
*/

#define SOUND_REG_DMACHANNEL16 (L"DmaChannel16")
#define SOUND_REG_MPU401_PORT  (L"MPU401 Port")
#define SOUND_REG_DSP_VERSION  (L"DSP Version")
#define SOUND_REG_REALBUFFERSIZE (L"Actual Dma Buffer Size")

/*
**  Sound blaster midi mappings
*/

#define SNDBLST_MAPPER_OPL3 TEXT("SNDBLST OPL3")
#define SNDBLST_MAPPER_ADLIB TEXT("SNDBLST AD LIB")


/*
**  Registry 'return' codes
*/

#define SOUND_CONFIG_THUNDER             0x80000001
#define SOUND_CONFIG_MPU401_PORT_INUSE   0x80000002
#define SOUND_CONFIG_BAD_MPU401_PORT     0x80000003

/*
**  String ids (strings in sndblst.dll)
*/

#define IDS_AUX_LINE_PNAME                                   100
#define IDS_AUX_CD_PNAME                                     101
#define IDS_SYNTH_PNAME                                      102
#define IDS_WAVEIN_PNAME                                     103
#define IDS_WAVEOUT_PNAME                                    104
#define IDS_MIXER_PNAME                                      105

#define IDS_CONTROL_AGCMIC_LONG_NAME                         106
#define IDS_CONTROL_AGCMIC_SHORT_NAME                        107
#define IDS_CONTROL_METERRECORD_LONG_NAME                    108
#define IDS_CONTROL_METERRECORD_SHORT_NAME                   109
#define IDS_CONTROL_MUTEAUX_LONG_NAME                        110
#define IDS_CONTROL_MUTEAUX_SHORT_NAME                       111
#define IDS_CONTROL_MUTEINTERNAL_LONG_NAME                   112
#define IDS_CONTROL_MUTEINTERNAL_SHORT_NAME                  113
#define IDS_CONTROL_MUTELINEOUT_LONG_NAME                    114
#define IDS_CONTROL_MUTELINEOUT_SHORT_NAME                   115
#define IDS_CONTROL_MUTEMIC_SHORT_NAME                       116
#define IDS_CONTROL_MUTEMIC_LONG_NAME                        117
#define IDS_CONTROL_MUTEMIDIOUT_LONG_NAME                    118
#define IDS_CONTROL_MUTEMIDIOUT_SHORT_NAME                   119
#define IDS_CONTROL_MUTEWAVEOUT_LONG_NAME                    120
#define IDS_CONTROL_MUTEWAVEOUT_SHORT_NAME                   121
#define IDS_CONTROL_MUXLINEOUT_LONG_NAME                     122
#define IDS_CONTROL_MUXLINEOUT_SHORT_NAME                    123
#define IDS_CONTROL_MUXWAVEIN_LONG_NAME                      124
#define IDS_CONTROL_MUXWAVEIN_SHORT_NAME                     125
#define IDS_CONTROL_PEAKVOICEINAUX_LONG_NAME                 126
#define IDS_CONTROL_PEAKVOICEINAUX_SHORT_NAME                127
#define IDS_CONTROL_PEAKVOICEINMIC_LONG_NAME                 128
#define IDS_CONTROL_PEAKVOICEINMIC_SHORT_NAME                129
#define IDS_CONTROL_PEAKWAVEINAUX_LONG_NAME                  130
#define IDS_CONTROL_PEAKWAVEINAUX_SHORT_NAME                 131
#define IDS_CONTROL_PEAKWAVEININTERNAL_LONG_NAME             132
#define IDS_CONTROL_PEAKWAVEININTERNAL_SHORT_NAME            133
#define IDS_CONTROL_PEAKWAVEINMIC_LONG_NAME                  134
#define IDS_CONTROL_PEAKWAVEINMIC_SHORT_NAME                 135
#define IDS_CONTROL_PEAKWAVEOUT_LONG_NAME                    136
#define IDS_CONTROL_PEAKWAVEOUT_SHORT_NAME                   137
#define IDS_CONTROL_VOICEINMUX_LONG_NAME                     138
#define IDS_CONTROL_VOICEINMUX_SHORT_NAME                    139
#define IDS_CONTROL_VOLBASS_LONG_NAME                        140
#define IDS_CONTROL_VOLBASS_SHORT_NAME                       141
#define IDS_CONTROL_VOLLINEOUTAUX_LONG_NAME                  142
#define IDS_CONTROL_VOLLINEOUTAUX_SHORT_NAME                 143
#define IDS_CONTROL_VOLLINEOUTINTERNAL_LONG_NAME             144
#define IDS_CONTROL_VOLLINEOUTINTERNAL_SHORT_NAME            145
#define IDS_CONTROL_VOLLINEOUTMIC_LONG_NAME                  146
#define IDS_CONTROL_VOLLINEOUTMIC_SHORT_NAME                 147
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_LONG_NAME              148
#define IDS_CONTROL_VOLLINEOUTMIDIOUT_SHORT_NAME             149
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_LONG_NAME              150
#define IDS_CONTROL_VOLLINEOUTWAVEOUT_SHORT_NAME             151
#define IDS_CONTROL_VOLLINEOUT_LONG_NAME                     152
#define IDS_CONTROL_VOLLINEOUT_SHORT_NAME                    153
#define IDS_CONTROL_VOLRECORD_LONG_NAME                      154
#define IDS_CONTROL_VOLRECORD_SHORT_NAME                     155
#define IDS_CONTROL_VOLTREBLE_LONG_NAME                      156
#define IDS_CONTROL_VOLTREBLE_SHORT_NAME                     157
#define IDS_CONTROL_VOLVOICEINAUX_LONG_NAME                  158
#define IDS_CONTROL_VOLVOICEINAUX_SHORT_NAME                 159
#define IDS_CONTROL_VOLVOICEINMIC_LONG_NAME                  160
#define IDS_CONTROL_VOLVOICEINMIC_SHORT_NAME                 161
#define IDS_CONTROL_VOLWAVEINAUX_LONG_NAME                   162
#define IDS_CONTROL_VOLWAVEINAUX_SHORT_NAME                  163
#define IDS_CONTROL_VOLWAVEININTERNAL_LONG_NAME              164
#define IDS_CONTROL_VOLWAVEININTERNAL_SHORT_NAME             165
#define IDS_CONTROL_VOLWAVEINMIC_LONG_NAME                   166
#define IDS_CONTROL_VOLWAVEINMIC_SHORT_NAME                  167
#define IDS_CONTROL_VOLWAVEINMIDIOUT_LONG_NAME               168
#define IDS_CONTROL_VOLWAVEINMIDIOUT_SHORT_NAME              169
#define IDS_DESTLINEOUT_LONG_NAME                            170
#define IDS_DESTLINEOUT_SHORT_NAME                           171
#define IDS_DESTVOICEIN_LONG_NAME                            172
#define IDS_DESTVOICEIN_SHORT_NAME                           173
#define IDS_DESTWAVEIN_LONG_NAME                             174
#define IDS_DESTWAVEIN_SHORT_NAME                            175
#define IDS_SRCAUX_LONG_NAME                                 176
#define IDS_SRCAUX_SHORT_NAME                                177
#define IDS_SRCINTERNALCD_LONG_NAME                          178
#define IDS_SRCINTERNALCD_SHORT_NAME                         179
#define IDS_SRCMICOUT_LONG_NAME                              180
#define IDS_SRCMICOUT_SHORT_NAME                             181
#define IDS_SRCMIDIOUT_LONG_NAME                             182
#define IDS_SRCMIDIOUT_SHORT_NAME                            183
#define IDS_SRCWAVEOUT_LONG_NAME                             184
#define IDS_SRCWAVEOUT_SHORT_NAME                            185
#define IDS_CONTROL_MIXERWAVEIN_LONG_NAME                    186
#define IDS_CONTROL_MIXERWAVEIN_SHORT_NAME                   187
#define IDS_CONTROL_VOLGAIN_SHORT_NAME                       188
#define IDS_CONTROL_VOLGAIN_LONG_NAME                        189
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\soundcfg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1990  Microsoft Corporation

Module Name:

    soundcfg.h

Abstract:

    This include file defines common strings and values for sound driver
	configuration.

Author:

    Robin Speed (RobinSp) 17-Oct-92

Revision History:
--*/

#define SOUND_REG_PORT (L"Port")
#define SOUND_REG_DMACHANNEL (L"DmaChannel")
#define SOUND_REG_INTERRUPT (L"Interrupt")
#define SOUND_REG_INPUTSOURCE (L"Input Source")
#define SOUND_REG_DMABUFFERSIZE (L"Dma Buffer Size")
#define SOUND_REG_CONFIGERROR (L"Configuration Error")
#define SOUND_REG_LOADTYPE (L"Load Type")
#define SOUND_REG_PNPDEVICE (L"PnP Device")

    //
    //  Values for Load Type
    //

    #define SOUND_LOADTYPE_NORMAL  0x00
    #define SOUND_LOADTYPE_CONFIG  0x01  // Fail load but return config data

#define SOUND_REG_SYNTH_TYPE (L"Synth Type")

    //
    //  Values for synth type
    //

    #define SOUND_SYNTH_TYPE_ADLIB  0x01
    #define SOUND_SYNTH_TYPE_OPL3   0x02
    #define SOUND_SYNTH_TYPE_NONE   0x03

#define SOUND_MIXER_SETTINGS_NAME (L"Mixer Settings")


//
// Errors
//

#define SOUND_CONFIG_ERROR      0x00000000
#define SOUND_CONFIG_OK         0xFFFFFFFF
#define SOUND_CONFIG_NOCARD     0x00000001
#define SOUND_CONFIG_BADINT     0x00000002
#define SOUND_CONFIG_BADDMA     0x00000003
#define SOUND_CONFIG_BADCARD    0x00000004
#define SOUND_CONFIG_RESOURCE   0x00000005

#define SOUND_CONFIG_BADPORT    0x00000006
#define SOUND_CONFIG_PORT_INUSE 0x00000007
#define SOUND_CONFIG_DMA_INUSE  0x00000008
#define SOUND_CONFIG_INT_INUSE  0x00000009

#define SOUND_CONFIG_NOINT      0x0000000A
#define SOUND_CONFIG_NODMA      0x0000000B


#define PARMS_SUBKEY                  L"Parameters"
#define SOUND_DEVICES_SUBKEY          L"Devices"
#define SOUND_DRIVER_PARMS            L"DriverParameters"

#define REG_VALUENAME_LEFTMASTER      L"LeftMasterVolumeAtten"
#define REG_VALUENAME_RIGHTMASTER     L"RightMasterVolumeAtten"
#define REG_VALUENAME_LEFTLINEIN      L"LeftLineInAtten"
#define REG_VALUENAME_RIGHTLINEIN     L"RightLineInAtten"
#define REG_VALUENAME_LEFTDAC         L"LeftDACAtten"
#define REG_VALUENAME_RIGHTDAC        L"RightDACAtten"
#define REG_VALUENAME_LEFTMICMIX      L"LeftMicMixAtten"
#define REG_VALUENAME_RIGHTMICMIX     L"RightMicMixAtten"
#define REG_VALUENAME_LEFTADC         L"LeftADCAtten"
#define REG_VALUENAME_RIGHTADC        L"RightADCAtten"
#define REG_VALUENAME_LEFTSYNTH       L"LeftSynthAtten"
#define REG_VALUENAME_RIGHTSYNTH      L"RightSynthAtten"


//
// Input source selection
//

#define INPUT_LINEIN            0
#define INPUT_AUX               1
#define INPUT_MIC               2
#define INPUT_OUTPUT            3

//
// Default volume settings on initial install
//

#define DEF_ADC_VOLUME    0x24000000
#define DEF_DAC_VOLUME    0x24000000
#define DEF_SYNTH_VOLUME  0x24000000
#define DEF_AUX_VOLUME    0x24000000
#define DEF_MICMIX_VOLUME 0x00000000

/****************************************************************************

 Device Types

 ***************************************************************************/

//
// Device type flags used in the local info structure
//

#define WAVE_IN             0x01    // Wave in device
#define WAVE_OUT            0x02    // Wave out device
#define MIDI_IN             0x03    // Midi in device
#define MIDI_OUT            0x04    // Midi out device
#define AUX_DEVICE          0x05    // aux device
#define MIXER_DEVICE        0x06    // Mixer device
#define SYNTH_DEVICE        0x07    // Synth device (adlib or opl3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\vjoydapi.h ===
/****************************************************************************
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
 *
 *  File: vjoydapi.h
 *  Content: VJOYDAPI service equates and structures
 *
 ***************************************************************************/

#define REGSTR_KEY_JOYFIXEDKEY "<FixedKey>"

#define MULTIMEDIA_OEM_ID 0x0440                /*  MS Reserved OEM # 34   */
#define VJOYD_DEVICE_ID (MULTIMEDIA_OEM_ID + 9)   /*  VJOYD API Device       */
#define VJOYD_Device_ID VJOYD_DEVICE_ID

#define VJOYD_Ver_Major 1
#define VJOYD_Ver_Minor 3                   /*  0=Win95 1=DX3 2=DX5 3=DX5a and DX7a */

/*
 *  VJOYDAPI_Get_Version
 *
 *  ENTRY:
 *   AX = 0
 *
 *  RETURNS:
 *  SUCCESS: AX == TRUE
 *  ERROR: AX == FALSE
 */
#define VJOYDAPI_GetVersion 0
#define VJOYDAPI_IOCTL_GetVersion VJOYDAPI_GetVersion

/*
 *  VJOYDAPI_GetPosEx
 *
 *  ENTRY:
 *  AX = 1
 *  DX = joystick id (0->15)
 *  ES:BX = pointer to JOYINFOEX struct
 *
 *  RETURNS:
 *  SUCCESS: EAX == MMSYSERR_NOERROR
 *  ERROR: EAX == JOYERR_PARMS
 *  JOYERR_UNPLUGGED
 */
#define VJOYDAPI_GetPosEx 1
#define VJOYDAPI_IOCTL_GetPosEx VJOYDAPI_GetPosEx

/*
 *  VJOYDAPI_GetPos
 *
 *  ENTRY:
 *  AX = 2
 *  DX = joystick id (0->15)
 *  ES:BX = pointer to JOYINFO struct
 *
 *  RETURNS:
 *  SUCCESS: EAX == MMSYSERR_NOERROR
 *  ERROR: EAX == JOYERR_PARMS
 *  JOYERR_UNPLUGGED
 */
#define VJOYDAPI_GetPos 2
#define VJOYDAPI_IOCTL_GetPos VJOYDAPI_GetPos
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\vjoyd.inc ===
;***************************************************************************
;  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;  PURPOSE.
;  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
;  File: vjoyd.h
;  Content: include file for describing VJoyD mini-driver communications
;*************************************************************************
ifndef WCHAR
endif
ifndef UNICODE_STRING

UNICODE_STRING	STRUC
us_Length	DB	SIZE WORD DUP (?)
us_MaximumLength	DB	SIZE WORD DUP (?)
us_Buffer	DD	?
UNICODE_STRING	ENDS
endif
INCLUDE vjoydapi.INC
Begin_Service_Table VJOYD
;   *  Win95 Gold services
;
    VJOYD_Service   VJOYD_Register_Device_Driver, LOCAL
    VJOYD_Service   VJOYD_GetPosEx_Service, LOCAL
;   *  DInput services (for internal use only)
;
    VJOYD_Service   VJOYD_GetInitParams_Service, LOCAL
    VJOYD_Service   VJOYD_Poll_Service, LOCAL
    VJOYD_Service   VJOYD_Escape_Service, LOCAL
    VJOYD_Service   VJOYD_CtrlMsg_Service, LOCAL
    VJOYD_Service   VJOYD_SetGain_Service, LOCAL
    VJOYD_Service   VJOYD_SendFFCommand_Service, LOCAL
    VJOYD_Service   VJOYD_GetFFState_Service, LOCAL
    VJOYD_Service   VJOYD_DownloadEffect_Service, LOCAL
    VJOYD_Service   VJOYD_DestroyEffect_Service, LOCAL
    VJOYD_Service   VJOYD_StartEffect_Service, LOCAL
    VJOYD_Service   VJOYD_StopEffect_Service, LOCAL
    VJOYD_Service   VJOYD_GetEffectStatus_Service, LOCAL
;   *  Interrupt polling
;   *  Mini-drivers should call this if they are interrupt driven at the
;   *  time they are notified of a change.
;
    VJOYD_Service   VJOYD_DeviceUpdateNotify_Service, LOCAL
;   *  Screen saver (internal only)
;
    VJOYD_Service   VJOYD_JoystickActivity_Service, LOCAL
;   *  Registry access
;
    VJOYD_Service   VJOYD_OpenTypeKey_Service, LOCAL
    VJOYD_Service   VJOYD_OpenConfigKey_Service, LOCAL
;   *  Gameport provider (not fully supported)
;
    VJOYD_Service   VJOYD_NewGameportDevNode, LOCAL
;   *  Config Changed
;
    VJOYD_Service   VJOYD_ConfigChanged_Service, LOCAL
End_Service_Table VJOYD
VJOYD_Init_Order	EQU	<UNDEFINED_INIT_ORDER>
MAX_MSJSTICK	EQU	(16)
S_OK	EQU	00000000H
S_FALSE	EQU	00000001H
E_FAIL	EQU	80004005H
E_INVALIDARG	EQU	80000003H
VJ_OK	EQU	S_OK                      ; A complete success
VJ_FALSE	EQU	S_FALSE                ; A success but not without some difficulties
VJ_DEFAULT	EQU	VJ_FALSE             ; Mini-driver does not understand
VJ_INCOMPLETE	EQU	VJ_FALSE          ; Some requested poll data was not returned
VJERR_FAIL	EQU	E_FAIL
VJERR_NEED_DEVNODE	EQU	VJERR_FAIL   ; Need more resources
VJERR_BAD_DEVNODE	EQU	VJERR_FAIL    ; Last resources were insufficient
VJERR_INVALIDPARAM	EQU	E_INVALIDARG
VJERR_FAIL_HID	EQU	80070052H       ; The device is HID, so fail VJoyD polls: MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_DUP_NAME)
VJERR_FAIL_OOM	EQU	<E_OUTOFMEMORY>    ; An out of memory condition cause a failure
VJERR_FAIL_DRVLOAD	EQU	VJERR_FAIL   ; mini driver failed to load, internal error
VJERR_FAIL_POWER	EQU	VJERR_FAIL     ; the power state of the device caused a failure
;  Driver Config flags
;  Interface attributes (result is combination of OEM flag and VJOYD)
VJDF_UNIT_ID	EQU	00000001H        ; unit id is valid
VJDF_ISHID	EQU	00000002H          ; This is a HID device, so refuse polls
VJDF_SENDSNOTIFY	EQU	00000004H    ; Driver calls VJOYD_DeviceUpdateNotify_Service
VJDF_NEWIF	EQU	00000080H          ; use new interface (will be set by VJOYD on registration if new i/f used)
VJDF_USAGES	EQU	00000010H         ; usages are valid
VJDF_GENERICNAME	EQU	00000020H    ; The lpszOEMName string is generic name, not a whole string
;  Interface requirements
VJDF_NONVOLATILE	EQU	00000100H    ; This value should not be deleted on boot
;  Devnode requirement flags
VJDF_NODEVNODE	EQU	00010000H      ; does not get its resources via CFG_MGR
VJDF_ISANALOGPORTDRIVER	EQU	00020000H ; it plugs into a standard gameport
VJDF_NOCHAINING	EQU	00040000H     ; one devnode per device
MAX_JOYSTICKOEMVXDNAME	EQU	260      ; max oem vxd name length (including NULL)
POV_MIN	EQU	0
POV_MAX	EQU	1
;***************************************************************************
;  @doc DDK |
;  @struct JOYHWCAPS |
;  The <t JOYHWCAPS> structure is defined only because previous versions of
;  this file defined it.  There is no reason this should be needed.
;**************************************************************************

JOYHWCAPS	STRUC
dwMaxButtons	DD	?
dwMaxAxes	DD	?
dwNumAxes	DD	?
szOEMVxD	DB	MAX_JOYSTICKOEMVXDNAME DUP (?)
JOYHWCAPS	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct JOYPOLLDATA |
;  The <t JOYPOLLDATA> structure is used to collect sensor data
;  from a DX5 mini-driver.
;  @field DWORD | dwX |
;  The X axis value.
;  @field DWORD | dwY |
;  The X axis value.
;  @field DWORD | dwZ |
;  The X axis value.
;  @field DWORD | dwR |
;  The X axis value.
;  @field DWORD | dwU |
;  The X axis value.
;  @field DWORD | dwV |
;  The X axis value.
;  @field DWORD | dwPOV0 |
;  The first point of view value.
;  @field DWORD | dwPOV1 |
;  The second point of view value.
;  @field DWORD | dwPOV2 |
;  The third point of view value.
;  @field DWORD | dwPOV3 |
;  The fourth point of view value.
;  @field DWORD | dwBTN0 |
;  The first DWORD of button bits. (Buttons 1 to 32 )
;  @field DWORD | dwBTN1 |
;  The second DWORD of button bits. (Buttons 33 to 64 )
;  @field DWORD | dwBTN2 |
;  The third DWORD of button bits. (Buttons 65 to 96 )
;  @field DWORD | dwBTN3 |
;  The fourth DWORD of button bits. (Buttons 97 to 128 )
;  @field DWORD | dwReserved0 |
;  The first reserved DWORD.
;  @field DWORD | dwReserved1 |
;  The second reserved DWORD.
;**************************************************************************

VJPOLLDATA	STRUC
dwX	DD	?
dwY	DD	?
dwZ	DD	?
dwR	DD	?
dwU	DD	?
dwV	DD	?
dwPOV0	DD	?
dwPOV1	DD	?
dwPOV2	DD	?
dwPOV3	DD	?
dwBTN0	DD	?
dwBTN1	DD	?
dwBTN2	DD	?
dwBTN3	DD	?
dwReserved0	DD	?
dwReserved1	DD	?
VJPOLLDATA	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct JOYOEMHWCAPS |
;  The <t JOYOEMHWCAPS> structure is used to pass driver capabilites
;  @field DWORD | dwMaxButtons |
;  The number of buttons supported by the device.
;  @field DWORD | dwMaxAxes |
;  The highest axis supported by the device.
;  For example a device with X, Y and R has 3 axes but the highest
;  one is axis 4 so dwMaxAxes is 4.
;  @field DWORD | dwNumAxes |
;  The number of axes supported by the device.
;  For example a device with X, Y and R has 3 so dwNumAxes is 3.
;**************************************************************************

JOYOEMHWCAPS	STRUC
dwMaxButtons	DD	?
dwMaxAxes	DD	?
dwNumAxes	DD	?
JOYOEMHWCAPS	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct VJPOLLREG |
;  The <t VJPOLLREG> structure is used by a mini-driver to register polling
;  and other general purpose callbacks with VJoyD for DX5 interface mini-
;  drivers.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJPOLLREG>)
;  @field JOYPOLLRTN | fpPoll |
;  Poll callback.  Used for all device polling.
;  @field CMCONFIGHANDLER | fpCfg |
;  Standard configuration manager callback.
;  @field INITIALIZERTN | fpInitialize |
;  Initialization callback.  This callback replaces and extends the JoyId
;  callback used with Win95 interface mini-drivers.
;  @field ESCAPERTN | fpEscape |
;  Escape callback.  May be sent to a device in response to an application
;  calling the Escape member.
;  @field CTRLMSGRTN | fpCtrlMsg |
;  Control message callback.  Used to send notifications from VJoyD to mini-
;  drivers.
;**************************************************************************

VJPOLLREG	STRUC
dwSize	DD	?
fpPoll	DD	?
fpCfg	DD	?
fpInitialize	DD	?
fpEscape	DD	?
fpCtrlMsg	DD	?
VJPOLLREG	ENDS
;***************************************************************************
;  @doc DDK |
;  @struct VJFORCEREG |
;  The <t VJFORCEREG> structure is used by a mini-driver to register force
;  feedback related callbacks with VJoyD for DX5 interface.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJFORCEREG>)
;  @field SETGAINRTN | fpSetFFGain |
;  Set Force Feedback Gain callback.
;  @field SENDFFCOMMANDRTN | fpSendFFCommand |
;  Send Force Feedback Command callback.
;  @field GETFFSTATERTN | fpGetFFState |
;  Get Force Feedback state callback.
;  @field DOWNLOADEFFECTRTN | fpDownloadEff |
;  Download effect callback.
;  @field DESTROYEFFECTRTN | fpDestroyEff |
;  Destroy effect callback.
;  @field STARTEFFECTRTN | fpStartEff |
;  Start effect callback.
;  @field STOPEFFECTRTN | fpStopEff |
;  Stop effect callback.
;  @field GETEFFECTSTATUSRTN | fpGetStatusEff |
;  Get effect status callback.
;**************************************************************************

VJFORCEREG	STRUC
dwSize	DD	?
fpSetFFGain	DD	?
fpSendFFCommand	DD	?
fpGetFFState	DD	?
fpDownloadEff	DD	?
fpDestroyEff	DD	?
fpStartEff	DD	?
fpStopEff	DD	?
fpGetStatusEff	DD	?
VJFORCEREG	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJDEVICEDESC |
;  The <t VJDEVICEDESC > structure is used to describe a DX5 DDI
;  device. This structure has been extended since DX5. See the
;  VJDEVICEDESC_DX5 structure for the previous version.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJDEVICEDESC>).
;  @field LPSTR | lpszOEMType |
;  Points to a null terminated string containing the text used to
;  describe the device as stored in the OEMName entry in the
;  registry. Renamed in Win98 (was lpszOEMName), is unused for
;  DX5 drivers.
;  @field DWORD | dwUnitId |
;  Specifies the unit id of this device.
;  @field LPJOYOEMHWCAPS | lpHWCaps |
;  Points to a <t JOYOEMHWCAPS> structure which contains the device
;  hardware capabilities.
;  @field LPJOYREGHWCONFIG | lpHWConfig |
;  Points to a <t JOYREGHWCONFIG> structure which contains the
;  configuration and calibration data for the device. Is unused for
;  DX5 drivers.
;  @field UNICODE_STRING | FileName |
;  An optional filename associated with the device. This is used for
;  HID devices to allow them to be accessed directly through the HID
;  stack without the joyGetPosEx restrictions. Added Win98.
;  @field USAGE_AND_PAGE | Usages |
;  An array of HID usages to describe what HID axis description has
;  been used for each WinMM axis. Added Win98. The elements are:
;  Usages[0] - X
;  Usages[1] - Y
;  Usages[2] - Z
;  Usages[3] - R
;  Usages[4] - U
;  Usages[5] - V
;  Usages[6] - POV0
;  Usages[7] - POV1
;  Usages[8] - POV2
;  Usages[9] - POV3
;  @field LPSTR | lpszOEMName |
;  Points to a null terminated string containing a friendly name
;  for the device. Added Win98.
;**************************************************************************

VJDEVICEDESC	STRUC
dwSize	DD	?
lpszOEMType	DD	?
dwUnitId	DD	?
lpHWCaps	DD	?
lpHWConfig	DD	?
FileName	DB	SIZE UNICODE_STRING DUP (?)
Usages	DD	10 DUP (?)
lpszOEMName	DD	?
VJDEVICEDESC	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJDEVICEDESC_DX5 |
;  The <t VJDEVICEDESC_DX5 > structure is used to describe a DX5 DDI
;  device. This is the DX5 version of the structure.
;  @field DWORD | dwSize |
;  Must be set to sizeof(<t VJDEVICEDESC_DX5>).
;  @field LPSTR | lpszOEMName |
;  This field is ignored.
;  @field DWORD | dwUnitId |
;  Specifies the unit id of this device.
;  @field LPJOYOEMHWCAPS | lpHWCaps |
;  Points to a <t JOYOEMHWCAPS> structure which contains the device
;  hardware capabilities.
;  @field LPJOYREGHWCONFIG | lpHWConfig |
;  This field is unused in DX5.
;**************************************************************************

VJDEVICEDESC_DX5	STRUC
dwSize	DD	?
lpszOEMName	DD	?
dwUnitId	DD	?
lpHWCaps	DD	?
lpHWConfig	DD	?
VJDEVICEDESC_DX5	ENDS
;***************************************************************************
;  @doc DDK
;  @struct VJREGDRVINFO |
;  The <t VJREGDRVINFO > structure is used to register a DX5 DDI
;  driver with VJoyD.
;  @field DWORD | dwSize |
;  The size of the structure.
;  @field DWORD | dwFunction |
;  The type of registration to be performed
;  It must be one of the <c VJRT_*> values.
;  @field DWORD | dwFlags |
;  Flags associated with this registration
;  It consists of one or more <c VJDF_*> flag values.
;  @field LPSTR | lpszOEMCallout |
;  The name of the driver associated with this registration,
;  for example "msanalog.vxd"
;  @field DWORD | dwFirmwareRevision |
;  Specifies the firmware revision of the device.
;  If the revision is unknown a value of zero should be used.
;  @field DWORD | dwHardwareRevision |
;  Specifies the hardware revision of the device.
;  If the revision is unknown a value of zero should be used.
;  @field DWORD | dwDriverVersion |
;  Specifies the version number of the device driver.
;  If the revision is unknown a value of zero should be used.
;  @field LPVJDEVICEDESC | lpDeviceDesc |
;  Optional pointer to a <t VJDEVICEDESC > structure
;  that describes the configuration properties of the device.
;  This allows drivers to supply the description of the device
;  rather than use the registry for this purpose.
;  If no description is available then the field should be
;  set to <c NULL>.
;  @field LPVJPOLLREG | lpPollReg |
;  Optional pointer to a <t VJPOLLREG > structure
;  that contains the most common driver callbacks.
;  Only a very strange driver would not need to register any
;  of these callbacks but if that was the case, then the field
;  should be set to <c NULL>.
;  @field LPVJFORCEREG | lpForceReg |
;  Optional pointer to a <t VJFORCEREG > structure
;  that contains all of the force feedback specific callbacks.
;  If the ring 0 driver does not support force feedback then
;  the field should be set to <c NULL>.
;  @field DWORD | dwReserved |
;  Reserved, must be set to zero.
;**************************************************************************

VJREGDRVINFO	STRUC
dwSize	DD	?
dwFunction	DD	?
dwFlags	DD	?
lpszOEMCallout	DD	?
dwFirmwareRevision	DD	?
dwHardwareRevision	DD	?
dwDriverVersion	DD	?
lpDeviceDesc	DD	?
lpPollReg	DD	?
lpForceReg	DD	?
dwReserved	DD	?
VJREGDRVINFO	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\vjoydapi.inc ===
;***************************************************************************
;  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;  PURPOSE.
;  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
;  File: vjoydapi.h
;  Content: VJOYDAPI service equates and structures
;*************************************************************************
MULTIMEDIA_OEM_ID	EQU	0440H                ;  MS Reserved OEM # 34
VJOYD_DEVICE_ID	EQU	(MULTIMEDIA_OEM_ID+9)   ;  VJOYD API Device
VJOYD_Ver_Major	EQU	1
VJOYD_Ver_Minor	EQU	3                   ;  0=Win95 1=DX3 2=DX5 3=DX5a and DX7a
;  VJOYDAPI_Get_Version
;  ENTRY:
;   AX = 0
;  RETURNS:
;  SUCCESS: AX == TRUE
;  ERROR: AX == FALSE
VJOYDAPI_GetVersion	EQU	0
VJOYDAPI_IOCTL_GetVersion	EQU	VJOYDAPI_GetVersion
;  VJOYDAPI_GetPosEx
;  ENTRY:
;  AX = 1
;  DX = joystick id (0->15)
;  ES:BX = pointer to JOYINFOEX struct
;  RETURNS:
;  SUCCESS: EAX == MMSYSERR_NOERROR
;  ERROR: EAX == JOYERR_PARMS
;  JOYERR_UNPLUGGED
VJOYDAPI_GetPosEx	EQU	1
VJOYDAPI_IOCTL_GetPosEx	EQU	VJOYDAPI_GetPosEx
;  VJOYDAPI_GetPos
;  ENTRY:
;  AX = 2
;  DX = joystick id (0->15)
;  ES:BX = pointer to JOYINFO struct
;  RETURNS:
;  SUCCESS: EAX == MMSYSERR_NOERROR
;  ERROR: EAX == JOYERR_PARMS
;  JOYERR_UNPLUGGED
VJOYDAPI_GetPos	EQU	2
VJOYDAPI_IOCTL_GetPos	EQU	VJOYDAPI_GetPos
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\acdapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    acdapi.h

Abstract:

    Exported routines from the Implicit Connection
    Driver (rasacd.sys) for use by transports to allow a
    user space process to dynamically create a network
    connection upon a network unreachable error.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDAPI_
#define _ACDAPI_

//
// A callback from the automatic connection
// driver to the transport to continue the
// connection process.
//
typedef VOID (*ACD_CONNECT_CALLBACK)(
    IN BOOLEAN,
    IN PVOID *);

typedef VOID
(*ACD_NEWCONNECTION)(
    IN PACD_ADDR pszAddr,
    IN PACD_ADAPTER pAdapter
    );

typedef BOOLEAN
(*ACD_STARTCONNECTION)(
    IN ULONG ulDriverId,
    IN PACD_ADDR pszAddr,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    );

//
// A callback to allow the caller
// to rummage around in the parameters
// to find the right request to cancel.
// To cancel the connection, the
// ACD_CANCEL_CALLBACK routine returns
// TRUE.
//
typedef BOOLEAN (*ACD_CANCEL_CALLBACK)(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    );

typedef BOOLEAN
(*ACD_CANCELCONNECTION)(
    IN ULONG ulDriverId,
    IN PACD_ADDR pszAddr,
    IN ACD_CANCEL_CALLBACK pProc,
    IN PVOID pArg
    );

//
// The structure a transport client receives
// when it binds (IOCTL_INTERNAL_ACD_BIND) with the driver.
//
typedef struct {
    LIST_ENTRY ListEntry;
    //
    // Provided by the transport.
    //
    KSPIN_LOCK SpinLock;
    ULONG ulDriverId;
    //
    // Filled in by rasacd.sys.
    //
    BOOLEAN fEnabled;
    ACD_NEWCONNECTION lpfnNewConnection;
    ACD_STARTCONNECTION lpfnStartConnection;
    ACD_CANCELCONNECTION lpfnCancelConnection;
} ACD_DRIVER, *PACD_DRIVER;

//
// Internal IOCTL definitions
//
#define IOCTL_INTERNAL_ACD_BIND  \
            _ACD_CTL_CODE(0x1234, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_ACD_UNBIND  \
            _ACD_CTL_CODE(0x1235, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_ACD_QUERY_STATE \
            _ACD_CTL_CODE(0x1236, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  // ifndef _ACDAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\trace.cpp ===
//
// trace.cpp -- global vars for trace.h
// copyright (c) Microsoft Corp. 1998
//
// this file should be include in stdafx.cpp

#ifdef DEBUG
#include "tstring.h"
#include <ostream>
#include <fstream>
#include "trace.h"
#include <process.h>


DWORD dwTraceLevel = 0;  // default to trace_error
tostream* tdbgout;
DWORD dwTraceIndent = 0;

typedef basic_oftstream<TCHAR> tfstream;

void DebugInit(LPCTSTR pszModule) {
        if (!pszModule) {
                dwTraceLevel = TRACE_ERROR;
        tdbgout = new TdbgStream;
                return;
        }
        CRegKey c;
        TCHAR szLogFile[MAX_PATH + 1];
        szLogFile[0] = 0;
        CString keyname(_T("SOFTWARE\\Debug\\"));
        keyname += pszModule;
        DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
        if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwTraceLevel, _T("Trace"));
                if (rc != ERROR_SUCCESS) {
                        dwTraceLevel = 1;
                }
                DWORD len = sizeof(szLogFile);
                rc = c.QueryValue(szLogFile, _T("LogFile"), &len);
                if (rc != ERROR_SUCCESS) {
                        szLogFile[0] = 0;
                }
                if(_tcslen(szLogFile)){
                    TCHAR szPID[MAX_PATH+1];
                    _itot(_getpid(), szPID, 10);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), szPID);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), _T(".log"));
                }
        }
    if (!_tcslen(szLogFile)) {
        tdbgout = new TdbgStream;
    } else {
        USES_CONVERSION;
        tdbgout = new tfstream(T2CA(szLogFile), std::ios::out);
    }
}

void DebugTerm(void) {
    dbgDump.flush();
    delete tdbgout;
    tdbgout = NULL;
}

#endif

// end of file - trace.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\multimedia\inc\vjoyd.h ===
/****************************************************************************
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1998 Microsoft Corporation. All Rights Reserved.
 *
 *  File: vjoyd.h
 *  Content: include file for describing VJoyD mini-driver communications
 *
 *
 ***************************************************************************/

#ifndef __VJOYD_INCLUDED__
#define __VJOYD_INCLUDED__

/*
 *  define all types and macros necessary to include dinputd.h
 */
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef FAR
#define FAR
#endif
#ifndef NEAR
#define NEAR
#endif

#ifndef DWORD
typedef ULONG DWORD;
#endif
typedef DWORD FAR *LPDWORD;

#ifndef LPVOID
typedef void FAR *LPVOID;
#endif
#ifndef PVOID
typedef void FAR *PVOID;
#endif

typedef long LONG;
typedef long FAR *LPLONG;

typedef char FAR *LPSTR;

#ifndef WCHAR
typedef unsigned short WCHAR;
typedef unsigned short FAR *PWCHAR;
#endif

#ifndef UNICODE_STRING
typedef struct UNICODE_STRING { /* us */
    WORD Length;
    WORD MaximumLength;
    PWCHAR Buffer;
} UNICODE_STRING, FAR *PUNICODE_STRING;
#endif

#define DIJ_RINGZERO

#define _INC_MMSYSTEM

/*
 *  Make joyConfigChanged compile 
 */
#ifndef WINMMAPI
#define WINMMAPI __declspec(dllimport)
#endif
#ifndef MMRESULT
typedef UINT MMRESULT; /* error return code, 0 means no error */
#endif
#ifndef WINAPI
#define WINAPI
#endif

#include <winerror.h>
#include <dinput.h>
#include <dinputd.h>
#include <configmg.h>
#include "vjoydapi.h"

/*
 *  Make sure HID types have been defined
 */
#ifndef USAGE
typedef USHORT USAGE;
typedef USHORT FAR *PUSAGE;
#endif

#ifndef USAGE_AND_PAGE
typedef struct USAGE_AND_PAGE {
    USAGE Usage;
    USAGE UsagePage;
} USAGE_AND_PAGE;
typedef struct USAGE_AND_PAGE FAR *PUSAGE_AND_PAGE;
#endif

/*
 *  joystick ports
 */
#define MIN_JOY_PORT 0x200
#define MAX_JOY_PORT 0x20F
#define DEFAULT_JOY_PORT 0x201

/* 
 *  Poll types 
 *  passed in the type field to a Win95 interface poll callback
 */
#define JOY_OEMPOLL_POLL1 0
#define JOY_OEMPOLL_POLL2 1
#define JOY_OEMPOLL_POLL3 2
#define JOY_OEMPOLL_POLL4 3
#define JOY_OEMPOLL_POLL5 4
#define JOY_OEMPOLL_POLL6 5
#define JOY_OEMPOLL_GETBUTTONS 6
#define JOY_OEMPOLL_PASSDRIVERDATA 7 

/*
 *  Axis numbers used for single axis (JOY_OEMPOLL_POLL1) polls
 */
#define JOY_AXIS_X 0
#define JOY_AXIS_Y 1
#define JOY_AXIS_Z 2
#define JOY_AXIS_R 3
#define JOY_AXIS_U 4
#define JOY_AXIS_V 5

/*
 *  joystick error return values
 */
#define JOYERR_BASE 160
#define JOYERR_NOERROR (0)                  /*  no error */
#define JOYERR_PARMS (JOYERR_BASE+5)        /*  bad parameters */
#define JOYERR_NOCANDO (JOYERR_BASE+6)      /*  request not completed */
#define JOYERR_UNPLUGGED (JOYERR_BASE+7)    /*  joystick is unplugged */

/* 
 *  constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages
 */
#define JOY_BUTTON1 0x0001
#define JOY_BUTTON2 0x0002
#define JOY_BUTTON3 0x0004
#define JOY_BUTTON4 0x0008

/*
 *  constants used with JOYINFOEX structure 
 */
#define JOY_POVCENTERED (WORD) -1
#define JOY_POVFORWARD 0
#define JOY_POVRIGHT 9000
#define JOY_POVBACKWARD 18000
#define JOY_POVLEFT 27000

#define POV_UNDEFINED (DWORD) -1

/*
 *  List of services available for calling by VxDs
 *  Note, many of these are for internal use only.
 */
#define VJOYD_Service Declare_Service
#pragma warning (disable:4003) /* turn off not enough params warning */

/*MACROS*/
Begin_Service_Table(VJOYD)

    /*
     *  Win95 Gold services
     */
    VJOYD_Service ( VJOYD_Register_Device_Driver, LOCAL )
    VJOYD_Service ( VJOYD_GetPosEx_Service, LOCAL )

    /*
     *  DInput services (for internal use only)
     */
    VJOYD_Service ( VJOYD_GetInitParams_Service, LOCAL )
    VJOYD_Service ( VJOYD_Poll_Service, LOCAL )
    VJOYD_Service ( VJOYD_Escape_Service, LOCAL )
    VJOYD_Service ( VJOYD_CtrlMsg_Service, LOCAL )
    VJOYD_Service ( VJOYD_SetGain_Service, LOCAL )
    VJOYD_Service ( VJOYD_SendFFCommand_Service, LOCAL )
    VJOYD_Service ( VJOYD_GetFFState_Service, LOCAL )
    VJOYD_Service ( VJOYD_DownloadEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_DestroyEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_StartEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_StopEffect_Service, LOCAL )
    VJOYD_Service ( VJOYD_GetEffectStatus_Service, LOCAL )

    /*
     *  Interrupt polling
     *  Mini-drivers should call this if they are interrupt driven at the 
     *  time they are notified of a change.
     */
    VJOYD_Service ( VJOYD_DeviceUpdateNotify_Service, LOCAL )

    /*
     *  Screen saver (internal only)
     */
    VJOYD_Service ( VJOYD_JoystickActivity_Service, LOCAL )

    /*
     *  Registry access
     */
    VJOYD_Service ( VJOYD_OpenTypeKey_Service, LOCAL )
    VJOYD_Service ( VJOYD_OpenConfigKey_Service, LOCAL )

    /*
     *  Gameport provider (not fully supported)
     */
    VJOYD_Service ( VJOYD_NewGameportDevNode, LOCAL )

    /*
     *  Config Changed
     */
    VJOYD_Service ( VJOYD_ConfigChanged_Service, LOCAL )

End_Service_Table(VJOYD)
/*ENDMACROS*/

#define VJOYD_Init_Order UNDEFINED_INIT_ORDER

#pragma warning (default:4003) /* restore not enough params warning */

#ifndef HRESULT
typedef LONG HRESULT;
#endif

#define MAX_MSJSTICK (16)
#define MAX_POLL MAX_MSJSTICK

/*
 *  VJoyD sends this system control message to a mini-driver when it needs 
 *  the mini-driver to register it's callbacks and properties.
 *  A mini-driver that can be loaded by some mechanism other than by VJoyD 
 *  should perform it's registration only in response to this message rather 
 *  than in response to SYS_DYNAMIC_DEVICE_INIT or SYS_DYNAMIC_DEVICE_REINIT.
 *  
 *  alias BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL
 */
#define VJOYD_REINIT_PRIVATE_SYSTEM_CONTROL 0x70000000

#define JOY_OEMPOLLRC_OK 1
#define JOY_OEMPOLLRC_FAIL 0

/*  
 *  Error codes 
 *  These are custom names for standard HRESULTs
 */

#define VJ_OK S_OK                      /* A complete success */
#define VJ_FALSE S_FALSE                /* A success but not without some difficulties */
#define VJ_DEFAULT VJ_FALSE             /* Mini-driver does not understand */
#define VJ_INCOMPLETE VJ_FALSE          /* Some requested poll data was not returned */

#define VJERR_FAIL E_FAIL
#define VJERR_NEED_DEVNODE VJERR_FAIL   /* Need more resources */
#define VJERR_BAD_DEVNODE VJERR_FAIL    /* Last resources were insufficient */
#define VJERR_INVALIDPARAM E_INVALIDARG

#define VJERR_FAIL_HID 0x80070052       /* The device is HID, so fail VJoyD polls: MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_DUP_NAME) */

#define VJERR_FAIL_OOM E_OUTOFMEMORY    /* An out of memory condition cause a failure */
#define VJERR_FAIL_DRVLOAD VJERR_FAIL   /* mini driver failed to load, internal error */
#define VJERR_FAIL_POWER VJERR_FAIL     /* the power state of the device caused a failure */

/*
 *  Driver Config flags
 */

/*
 *  Interface attributes (result is combination of OEM flag and VJOYD)
 */
#define VJDF_UNIT_ID 0x00000001L        /* unit id is valid */
#define VJDF_ISHID 0x00000002L          /* This is a HID device, so refuse polls */
#define VJDF_SENDSNOTIFY 0x00000004L    /* Driver calls VJOYD_DeviceUpdateNotify_Service */
#define VJDF_NEWIF 0x00000080L          /* use new interface (will be set by VJOYD on registration if new i/f used) */
#define VJDF_USAGES 0x00000010L         /* usages are valid */
#define VJDF_GENERICNAME 0x00000020L    /* The lpszOEMName string is generic name, not a whole string */

/*
 *  Interface requirements
 */
#define VJDF_NONVOLATILE 0x00000100L    /* This value should not be deleted on boot */

/*
 *  Devnode requirement flags
 */
#define VJDF_NODEVNODE 0x00010000L      /* does not get its resources via CFG_MGR */
#define VJDF_ISANALOGPORTDRIVER 0x00020000L /* it plugs into a standard gameport */
#define VJDF_NOCHAINING 0x00040000L     /* one devnode per device */

/*
 *  Polling flags
 *  These flags are passed to and from DX5 interface mini-driver poll
 *  callbacks.
 *  The low WORD contains flags detailing which elements are being requested 
 *  or provided; whereas the high WORD contains flags detailing the attributes 
 *  of the data.
 */
#define JOYPD_X             0x00000001
#define JOYPD_Y             0x00000002
#define JOYPD_Z             0x00000004
#define JOYPD_R             0x00000008
#define JOYPD_U             0x00000010
#define JOYPD_V             0x00000020
#define JOYPD_POV0          0x00000040
#define JOYPD_POV1          0x00000080
#define JOYPD_POV2          0x00000100
#define JOYPD_POV3          0x00000200
#define JOYPD_BTN0          0x00000400
#define JOYPD_BTN1          0x00000800
#define JOYPD_BTN2          0x00001000
#define JOYPD_BTN3          0x00002000
#define JOYPD_RESERVED0     0x00004000
#define JOYPD_RESERVED1     0x00008000

#define JOYPD_ELEMENT_MASK  0x0000FFFF

#define JOYPD_POSITION      0x00010000
#define JOYPD_VELOCITY      0x00020000
#define JOYPD_ACCELERATION  0x00040000
#define JOYPD_FORCE         0x00080000

#define JOYPD_ATTRIB_MASK   0x000F0000

#define MAX_JOYSTICKOEMVXDNAME 260      /* max oem vxd name length (including NULL) */

#define POV_MIN 0
#define POV_MAX 1

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYHWCAPS |
 *
 *  The <t JOYHWCAPS> structure is defined only because previous versions of 
 *  this file defined it.  There is no reason this should be needed.
 *
 ****************************************************************************/
typedef struct JOYHWCAPS {
    DWORD dwMaxButtons;
    DWORD dwMaxAxes;
    DWORD dwNumAxes;
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME];
} JOYHWCAPS; 
typedef struct JOYHWCAPS FAR *LPJOYHWCAPS;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYPOLLDATA |
 *
 *  The <t JOYPOLLDATA> structure is used to collect sensor data
 *  from a DX5 mini-driver.
 *
 *  @field DWORD | dwX |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwY |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwZ |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwR |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwU |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwV |
 *
 *  The X axis value.
 *
 *  @field DWORD | dwPOV0 |
 *
 *  The first point of view value.
 *
 *  @field DWORD | dwPOV1 |
 *
 *  The second point of view value.
 *
 *  @field DWORD | dwPOV2 |
 *
 *  The third point of view value.
 *
 *  @field DWORD | dwPOV3 |
 *
 *  The fourth point of view value.
 *
 *  @field DWORD | dwBTN0 |
 *
 *  The first DWORD of button bits. (Buttons 1 to 32 )
 *
 *  @field DWORD | dwBTN1 |
 *
 *  The second DWORD of button bits. (Buttons 33 to 64 )
 *
 *  @field DWORD | dwBTN2 |
 *
 *  The third DWORD of button bits. (Buttons 65 to 96 )
 *
 *  @field DWORD | dwBTN3 |
 *
 *  The fourth DWORD of button bits. (Buttons 97 to 128 )
 *
 *  @field DWORD | dwReserved0 |
 *
 *  The first reserved DWORD.
 *
 *  @field DWORD | dwReserved1 |
 *
 *  The second reserved DWORD.
 *
 *
 ****************************************************************************/
typedef struct VJPOLLDATA {
    DWORD dwX;
    DWORD dwY;
    DWORD dwZ;
    DWORD dwR;
    DWORD dwU;
    DWORD dwV;
    DWORD dwPOV0;
    DWORD dwPOV1;
    DWORD dwPOV2;
    DWORD dwPOV3;
    DWORD dwBTN0;
    DWORD dwBTN1;
    DWORD dwBTN2;
    DWORD dwBTN3;
    DWORD dwReserved0;
    DWORD dwReserved1;
} VJPOLLDATA;
typedef struct VJPOLLDATA FAR *LPVJPOLLDATA;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYOEMPOLLDATA |
 *
 *  The <t JOYOEMPOLLDATA> structure is used to collect sensor data
 *  from a pre-DX5 mini-driver.
 *
 *  @field DWORD | id |
 *
 *  The id of the joystick to be polled.
 *
 *  @field DWORD | do_other |
 *
 *  If the poll type is JOY_OEMPOLL_POLL1, this is the axis to be 
 *  polled.
 *  If the poll type is JOY_OEMPOLL_POLL3, this is zero if the poll 
 *  is X,Y,Z or non-zero if the poll is X,Y,R.
 *  If the poll type is JOY_OEMPOLL_POLL5, this is zero if the poll 
 *  is X,Y,Z,R,U or non-zero if the poll is X,Y,Z,R,V.
 *  If the poll type is JOY_OEMPOLL_PASSDRIVERDATA poll, this DWORD 
 *  is the value set in the dwReserved2 field by the caller.
 *  Otherwise this values is undefined and should be ignored
 *
 *  @field JOYPOS | jp |
 *
 *  Values to hold the X,Y,Z,R,U,V values.
 *  Note for a JOY_OEMPOLL_POLL1 poll type the requested axis value
 *  should always be returned in jp.dwX.
 *
 *  @field DWORD | dwPOV |
 *
 *  The Point Of View value if not supported through button combos 
 *  or an axis value.
 *  Note, should be left as POV_UNDEFINED if not used.
 *
 *  @field DWORD | dwButtons |
 *
 *  Bitmask of the button values.
 *
 *  @field DWORD | dwButtonNumber |
 *
 *  The one-based bit position of the lowest numbered button pressed.
 *  Zero if no buttons are pressed.
 *
 *
 ****************************************************************************/
typedef struct JOYOEMPOLLDATA {
    DWORD id;
    DWORD do_other;
    JOYPOS jp;
    DWORD dwPOV;
    DWORD dwButtons;
    DWORD dwButtonNumber;
} JOYOEMPOLLDATA;
typedef struct JOYOEMPOLLDATA FAR *LPJOYOEMPOLLDATA;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct JOYOEMHWCAPS |
 *
 *  The <t JOYOEMHWCAPS> structure is used to pass driver capabilites
 *
 *  @field DWORD | dwMaxButtons |
 *
 *  The number of buttons supported by the device.
 *
 *  @field DWORD | dwMaxAxes |
 *
 *  The highest axis supported by the device.
 *  For example a device with X, Y and R has 3 axes but the highest
 *  one is axis 4 so dwMaxAxes is 4.
 *
 *  @field DWORD | dwNumAxes |
 *
 *  The number of axes supported by the device.
 *  For example a device with X, Y and R has 3 so dwNumAxes is 3.
 *
 *
 ****************************************************************************/
typedef struct JOYOEMHWCAPS {
    DWORD dwMaxButtons;
    DWORD dwMaxAxes;
    DWORD dwNumAxes;
} JOYOEMHWCAPS;
typedef struct JOYOEMHWCAPS FAR *LPJOYOEMHWCAPS;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct DID_INITPARAMS |
 *
 *  The <t DID_INITPARAMS> structure is used to pass details of the 
 *  joystick being initialized to a particular id in DX5 drivers.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t DID_INITPARAMS>)
 *
 *  @field DWORD | dwFlags |
 *
 *  Flags associated with the call.
 *
 *  It will be either:
 *  VJIF_BEGIN_ACCESS if the id association is being made, or
 *  VJIF_END_ACCESS if the id association is being broken.
 *  Other flags may be defined in the future so all other values
 *  should be refused.
 *
 *  @field DWORD | dwUnitId |
 *
 *  The id for which polling support is being requested.
 *
 *  @field DWORD | dwDevnode |
 *
 *  The Devnode containing hardware resources to use for this id.
 *
 *  @field JOYREGHWSETTINGS | hws |
 *
 *  The hardware settings flags applied to this device.
 *
 *
 ****************************************************************************/
typedef struct DID_INITPARAMS {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwUnitId;
    DWORD dwDevnode;
    JOYREGHWSETTINGS hws;
} DID_INITPARAMS;
typedef struct DID_INITPARAMS FAR *LPDID_INITPARAMS;

/*
 *  DX1 callbacks
 */
typedef int (__stdcall *JOYOEMPOLLRTN)( int type, LPJOYOEMPOLLDATA pojd );
typedef int (__stdcall *JOYOEMHWCAPSRTN)( int joyid, LPJOYOEMHWCAPS pohwcaps );
typedef int (__stdcall *JOYOEMJOYIDRTN)( int joyid, BOOL inuse );
/*
 *  General callbacks
 */
typedef HRESULT (__stdcall *JOYPOLLRTN)( DWORD dwDeviceID, LPDWORD lpdwMask, LPVJPOLLDATA lpPollData );
typedef HRESULT (__stdcall *INITIALIZERTN)( DWORD dwDeviceID, LPDID_INITPARAMS lpInitParams );
typedef HRESULT (__stdcall *ESCAPERTN)( DWORD dwDeviceID, DWORD dwEffectID, LPDIEFFESCAPE lpEscape );
typedef HRESULT (__stdcall *CTRLMSGRTN)( DWORD dwDeviceID, DWORD dwMsgId, DWORD dwParam );
/*
 *  Force feedback callbacks
 */
typedef HRESULT (__stdcall *SETGAINRTN)( DWORD dwDeviceID, DWORD dwGain );
typedef HRESULT (__stdcall *SENDFFCOMMANDRTN)( DWORD dwDeviceID, DWORD dwState );
typedef HRESULT (__stdcall *GETFFSTATERTN)( DWORD dwDeviceID, LPDIDEVICESTATE lpDeviceState );
typedef HRESULT (__stdcall *DOWNLOADEFFECTRTN)( DWORD dwDeviceID, DWORD dwInternalEffectType, LPDWORD lpdwDnloadID, LPDIEFFECT lpEffect, DWORD dwFlags );
typedef HRESULT (__stdcall *DESTROYEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID );
typedef HRESULT (__stdcall *STARTEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID, DWORD dwMode, DWORD dwIterations );
typedef HRESULT (__stdcall *STOPEFFECTRTN)( DWORD dwDeviceID, DWORD dwDnloadID );
typedef HRESULT (__stdcall *GETEFFECTSTATUSRTN)( DWORD dwDeviceID, DWORD dwDnloadID, LPDWORD lpdwStatusCode );
/*
 *  Gameport Emulation callbacks
 */
typedef HRESULT (__stdcall *JOYOEMGPEMULCTRL)( DWORD port, DWORD inuse );
typedef DWORD JOYOEMGPEMULTRAP;
typedef HRESULT (__stdcall *JOYOEMGPPROVRTN)( DWORD function, DWORD dwParam );

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct VJPOLLREG |
 *
 *  The <t VJPOLLREG> structure is used by a mini-driver to register polling 
 *  and other general purpose callbacks with VJoyD for DX5 interface mini-
 *  drivers.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJPOLLREG>)
 *
 *  @field JOYPOLLRTN | fpPoll |
 *
 *  Poll callback.  Used for all device polling.
 *
 *  @field CMCONFIGHANDLER | fpCfg |
 *
 *  Standard configuration manager callback.
 *
 *  @field INITIALIZERTN | fpInitialize |
 *
 *  Initialization callback.  This callback replaces and extends the JoyId 
 *  callback used with Win95 interface mini-drivers.
 *
 *  @field ESCAPERTN | fpEscape |
 *
 *  Escape callback.  May be sent to a device in response to an application 
 *  calling the Escape member.
 *
 *  @field CTRLMSGRTN | fpCtrlMsg |
 *
 *  Control message callback.  Used to send notifications from VJoyD to mini-
 *  drivers.
 *
 ****************************************************************************/
typedef struct VJPOLLREG {
    DWORD dwSize;
    JOYPOLLRTN fpPoll;
    CMCONFIGHANDLER fpCfg;
    INITIALIZERTN fpInitialize;
    ESCAPERTN fpEscape;
    CTRLMSGRTN fpCtrlMsg;
} VJPOLLREG;
typedef struct VJPOLLREG FAR *LPVJPOLLREG;

/****************************************************************************
 *
 *  @doc DDK |
 *
 *  @struct VJFORCEREG |
 *
 *  The <t VJFORCEREG> structure is used by a mini-driver to register force 
 *  feedback related callbacks with VJoyD for DX5 interface.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJFORCEREG>)
 *
 *  @field SETGAINRTN | fpSetFFGain |
 *
 *  Set Force Feedback Gain callback.
 *
 *  @field SENDFFCOMMANDRTN | fpSendFFCommand |
 *
 *  Send Force Feedback Command callback.
 *
 *  @field GETFFSTATERTN | fpGetFFState |
 *
 *  Get Force Feedback state callback.
 *
 *  @field DOWNLOADEFFECTRTN | fpDownloadEff |
 *
 *  Download effect callback.
 *
 *  @field DESTROYEFFECTRTN | fpDestroyEff |
 *
 *  Destroy effect callback.
 *
 *  @field STARTEFFECTRTN | fpStartEff |
 *
 *  Start effect callback.
 *
 *  @field STOPEFFECTRTN | fpStopEff |
 *
 *  Stop effect callback.
 *
 *  @field GETEFFECTSTATUSRTN | fpGetStatusEff |
 *
 *  Get effect status callback.
 *
 *
 ****************************************************************************/
typedef struct VJFORCEREG {
    DWORD dwSize;
    SETGAINRTN fpSetFFGain;
    SENDFFCOMMANDRTN fpSendFFCommand;
    GETFFSTATERTN fpGetFFState;
    DOWNLOADEFFECTRTN fpDownloadEff;
    DESTROYEFFECTRTN fpDestroyEff;
    STARTEFFECTRTN fpStartEff;
    STOPEFFECTRTN fpStopEff;
    GETEFFECTSTATUSRTN fpGetStatusEff;
} VJFORCEREG;
typedef struct VJFORCEREG FAR *LPVJFORCEREG;
 

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJDEVICEDESC |
 *
 *  The <t VJDEVICEDESC > structure is used to describe a DX5 DDI
 *  device. This structure has been extended since DX5. See the 
 *  VJDEVICEDESC_DX5 structure for the previous version.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJDEVICEDESC>).
 *
 *  @field LPSTR | lpszOEMType |
 *
 *  Points to a null terminated string containing the text used to 
 *  describe the device as stored in the OEMName entry in the 
 *  registry. Renamed in Win98 (was lpszOEMName), is unused for
 *  DX5 drivers.
 *
 *  @field DWORD | dwUnitId |
 *
 *  Specifies the unit id of this device.
 *
 *  @field LPJOYOEMHWCAPS | lpHWCaps |
 *
 *  Points to a <t JOYOEMHWCAPS> structure which contains the device 
 *  hardware capabilities.
 *
 *  @field LPJOYREGHWCONFIG | lpHWConfig |
 *
 *  Points to a <t JOYREGHWCONFIG> structure which contains the 
 *  configuration and calibration data for the device. Is unused for
 *  DX5 drivers.
 *
 *  @field UNICODE_STRING | FileName |
 *
 *  An optional filename associated with the device. This is used for
 *  HID devices to allow them to be accessed directly through the HID
 *  stack without the joyGetPosEx restrictions. Added Win98.
 *
 *  @field USAGE_AND_PAGE | Usages |
 *
 *  An array of HID usages to describe what HID axis description has 
 *  been used for each WinMM axis. Added Win98. The elements are:
 *
 *  Usages[0] - X
 *  Usages[1] - Y
 *  Usages[2] - Z
 *  Usages[3] - R
 *  Usages[4] - U
 *  Usages[5] - V
 *  Usages[6] - POV0
 *  Usages[7] - POV1
 *  Usages[8] - POV2
 *  Usages[9] - POV3
 *
 *
 *  @field LPSTR | lpszOEMName |
 *
 *  Points to a null terminated string containing a friendly name 
 *  for the device. Added Win98.
 *
 *
 ****************************************************************************/
typedef struct VJDEVICEDESC {
    DWORD dwSize;
    LPSTR lpszOEMType;
    DWORD dwUnitId;
    LPJOYOEMHWCAPS lpHWCaps;
    LPJOYREGHWCONFIG lpHWConfig;
    UNICODE_STRING FileName;
    USAGE_AND_PAGE Usages[10];
    LPSTR lpszOEMName;
} VJDEVICEDESC ;
typedef struct VJDEVICEDESC FAR *LPVJDEVICEDESC;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJDEVICEDESC_DX5 |
 *
 *  The <t VJDEVICEDESC_DX5 > structure is used to describe a DX5 DDI
 *  device. This is the DX5 version of the structure.
 *
 *  @field DWORD | dwSize |
 *
 *  Must be set to sizeof(<t VJDEVICEDESC_DX5>).
 *
 *  @field LPSTR | lpszOEMName |
 *
 *  This field is ignored.
 *
 *  @field DWORD | dwUnitId |
 *
 *  Specifies the unit id of this device.
 *
 *  @field LPJOYOEMHWCAPS | lpHWCaps |
 *
 *  Points to a <t JOYOEMHWCAPS> structure which contains the device 
 *  hardware capabilities.
 *
 *  @field LPJOYREGHWCONFIG | lpHWConfig |
 *
 *  This field is unused in DX5.
 *
 *
 ****************************************************************************/
typedef struct VJDEVICEDESC_DX5 {
    DWORD dwSize;
    LPSTR lpszOEMName;
    DWORD dwUnitId;
    LPJOYOEMHWCAPS lpHWCaps;
    LPJOYREGHWCONFIG lpHWConfig;
} VJDEVICEDESC_DX5;
typedef struct VJDEVICEDESC_DX5 FAR *LPVJDEVICEDESC_DX5;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJREGDRVINFO |
 *
 *  The <t VJREGDRVINFO > structure is used to register a DX5 DDI
 *  driver with VJoyD.
 *
 *  @field DWORD | dwSize |
 *
 *  The size of the structure.
 *
 *  @field DWORD | dwFunction |
 *
 *  The type of registration to be performed
 *  It must be one of the <c VJRT_*> values.
 *
 *  @field DWORD | dwFlags |
 *
 *  Flags associated with this registration
 *  It consists of one or more <c VJDF_*> flag values.
 *
 *  @field LPSTR | lpszOEMCallout |
 *
 *  The name of the driver associated with this registration,
 *  for example "msanalog.vxd"
 *
 *  @field DWORD | dwFirmwareRevision |
 *
 *  Specifies the firmware revision of the device.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field DWORD | dwHardwareRevision |
 *
 *  Specifies the hardware revision of the device.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field DWORD | dwDriverVersion |
 *
 *  Specifies the version number of the device driver.
 *  If the revision is unknown a value of zero should be used.
 *
 *  @field LPVJDEVICEDESC | lpDeviceDesc |
 *
 *  Optional pointer to a <t VJDEVICEDESC > structure
 *  that describes the configuration properties of the device.
 *  This allows drivers to supply the description of the device 
 *  rather than use the registry for this purpose.
 *  If no description is available then the field should be 
 *  set to <c NULL>.
 *
 *  @field LPVJPOLLREG | lpPollReg |
 *
 *  Optional pointer to a <t VJPOLLREG > structure
 *  that contains the most common driver callbacks.
 *  Only a very strange driver would not need to register any 
 *  of these callbacks but if that was the case, then the field 
 *  should be set to <c NULL>.
 *
 *  @field LPVJFORCEREG | lpForceReg |
 *
 *  Optional pointer to a <t VJFORCEREG > structure
 *  that contains all of the force feedback specific callbacks.
 *  If the ring 0 driver does not support force feedback then 
 *  the field should be set to <c NULL>.
 *
 *  @field DWORD | dwReserved |
 *
 *  Reserved, must be set to zero.
 *
 ****************************************************************************/
typedef struct VJREGDRVINFO {
    DWORD dwSize;
    DWORD dwFunction;
    DWORD dwFlags;
    LPSTR lpszOEMCallout;
    DWORD dwFirmwareRevision;
    DWORD dwHardwareRevision;
    DWORD dwDriverVersion;
    LPVJDEVICEDESC lpDeviceDesc;
    LPVJPOLLREG lpPollReg;
    LPVJFORCEREG lpForceReg;
    DWORD dwReserved;
} VJREGDRVINFO;
typedef struct VJREGDRVINFO FAR *LPVJREGDRVINFO;

/****************************************************************************
 *
 *  @doc DDK
 *
 *  @struct VJCFGCHG |
 *
 *  The <t VJCFGCHG > structure is passed in the dwParam of a CtrlMsg
 *  callback when the dwMsg type is VJCM_CONFIGCHANGED.
 *
 *  @field DWORD | dwSize |
 *
 *  The size of the structure.
 *
 *  @field DWORD | dwChangeType |
 *
 *  The type of change which has been made
 *  It must be one of the <c VJCMCT_*> values.
 *  Currently the only supported value is VJCMCT_GENERAL.
 *
 *  @field DWORD | dwTimeOut |
 *
 *  The dwTimeOut value from the user data registry values.
 *  This value is passed as a convenience to drivers which use it as
 *  there are no other driver values in this structure.
 *
 ****************************************************************************/
typedef struct VJCFGCHG {
    DWORD dwSize;
    DWORD dwChangeType;
    DWORD dwTimeOut;
} VJCFGCHG;
typedef struct VJCFGCHG FAR *LPVJCFGCHG;

/*
 *  Control messages
 */
#define VJCM_PASSDRIVERDATA 1 /* dwParam = DWORD to pass to driver */
#define VJCM_CONFIGCHANGED 2 /* dwParam = PVJCFGCHG pointer to config changed structure */

/*
 *  Config changed types
 */
#define VJCMCT_GENERAL 0x00010000L
#define VJCMCT_CONFIG 0x00020000L
#define VJCMCT_TYPEDATA 0x00030000L
#define VJCMCT_OEMDEFN 0x00040000L
#define VJCMCT_GLOBAL 0x00050000L

/*
 *  Masks
 */
#define VJCMCTM_MAJORMASK 0x00ff0000L
#define VJCMCTM_MINORMASK 0x0000ffffL

/*
 *  Registration types
 */
#define VJRT_LOADED 1 /* Driver has been loaded */
#define VJRT_CHANGE 2 /* NOT IMPLEMENTED! Modify anything except driver and initialization parameters */
#define VJRT_PLUG 3 /* New instance of a device, New in Win98 */
#define VJRT_UNPLUG 4 /* Device instance is gone, New in Win98 */

/*
 *  Driver Initialize dwFlags
 */
#define VJIF_BEGIN_ACCESS 0x00000001L
#define VJIF_END_ACCESS 0x00000002L

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\afd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Afd.h

Abstract:

    Contains structures and declarations for AFD.  AFD stands for the
    Ancillary Function Driver.  This driver enhances the functionality
    of TDI so that it is a sufficiently rich interface to support
    user-mode sockets and XTI DLLs.

Author:

    David Treadwell (davidtr)    20-Feb-1992

Revision History:

--*/

#ifndef _AFD_
#define _AFD_

//
// If WINSOCK2.H has not been included, then just embed the definition
// of the WSABUF and QOS structures here. This makes building AFD.SYS
// much easier.
//


#ifndef _WINSOCK2API_

typedef struct _WSABUF {
    ULONG len;
    PCHAR buf;
} WSABUF, *LPWSABUF;

#include <qos.h>


typedef struct _QualityOfService
{
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF        ProviderSpecific;      /* additional provider specific stuff */
} QOS, *LPQOS;

#define MSG_TRUNC       0x0100
#define MSG_CTRUNC      0x0200
#define MSG_BCAST       0x0400
#define MSG_MCAST       0x0800
#endif

#define AFD_DEVICE_NAME L"\\Device\\Afd"

//
// Endpoint flags computed based on Winsock2 provider flags
// and socket type
//

typedef struct _AFD_ENDPOINT_FLAGS {
    union {
        struct {
            BOOLEAN     ConnectionLess :1;
            BOOLEAN     :3;                 // This spacing makes strcutures
                                            // much more readable (hex) in the 
                                            // debugger and has no effect
                                            // on the generated code as long
                                            // as number of flags is less than
                                            // 8 (we still take up full 32 bits
                                            // because of aligment requiremens
                                            // of most other fields)
            BOOLEAN     MessageMode :1;
            BOOLEAN     :3;
            BOOLEAN     Raw :1;
            BOOLEAN     :3;
            BOOLEAN     Multipoint :1;
            BOOLEAN     :3;
            BOOLEAN     C_Root :1;
            BOOLEAN     :3;
            BOOLEAN     D_Root :1;
            BOOLEAN     :3;
        };
        ULONG           EndpointFlags;      // Flags are as fine as bit fields,
                                            // but create problems when we need
                                            // to cast them to boolean.
    };
#define AFD_ENDPOINT_FLAG_CONNECTIONLESS	0x00000001
#define AFD_ENDPOINT_FLAG_MESSAGEMODE		0x00000010
#define AFD_ENDPOINT_FLAG_RAW			    0x00000100

//
// Old AFD_ENDPOINT_TYPE mappings. Flags make things clearer at
// at the TDI level and after all Winsock2 switched to provider flags
// instead of socket type anyway (ATM for example needs connection oriented
// raw sockets, which can only be reflected by SOCK_RAW+SOCK_STREAM combination
// which does not exists).
//
#define AfdEndpointTypeStream			0
#define AfdEndpointTypeDatagram			(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeRaw				(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE|\
                                            AFD_ENDPOINT_FLAG_RAW)
#define AfdEndpointTypeSequencedPacket	(AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeReliableMessage	(AFD_ENDPOINT_FLAG_MESSAGEMODE)

//
// New multipoint semantics
//
#define AFD_ENDPOINT_FLAG_MULTIPOINT	    0x00001000
#define AFD_ENDPOINT_FLAG_CROOT			    0x00010000
#define AFD_ENDPOINT_FLAG_DROOT			    0x00100000

#define AFD_ENDPOINT_VALID_FLAGS		    0x00111111

} AFD_ENDPOINT_FLAGS;

//
// Structures used on NtCreateFile() for AFD.
//

typedef struct _AFD_OPEN_PACKET {
	AFD_ENDPOINT_FLAGS __f;
#define afdConnectionLess  __f.ConnectionLess
#define afdMessageMode     __f.MessageMode
#define afdRaw             __f.Raw
#define afdMultipoint      __f.Multipoint
#define afdC_Root          __f.C_Root
#define afdD_Root          __f.D_Root
#define afdEndpointFlags   __f.EndpointFlags
    LONG  GroupID;
    ULONG TransportDeviceNameLength;
    WCHAR TransportDeviceName[1];
} AFD_OPEN_PACKET, *PAFD_OPEN_PACKET;

// *** the XX is to ensure natural alignment of the open packet part
//     of the EA buffer

#define AfdOpenPacket "AfdOpenPacketXX"
#define AFD_OPEN_PACKET_NAME_LENGTH (sizeof(AfdOpenPacket) - 1)

//
// The input structure for IOCTL_AFD_BIND
//
typedef struct _AFD_BIND_INFO {
    ULONG                       ShareAccess;
#define AFD_NORMALADDRUSE		0	// Do not reuse address if
									// already in use but allow
									// subsequent reuse by others
									// (this is a default)
#define AFD_REUSEADDRESS		1	// Reuse address if necessary
#define AFD_WILDCARDADDRESS     2   // Address is a wildcard, no checking
                                    // can be performed by winsock layer.
#define AFD_EXCLUSIVEADDRUSE	3	// Do not allow reuse of this
									// address (admin only).
	TRANSPORT_ADDRESS			Address;
} AFD_BIND_INFO, *PAFD_BIND_INFO;

//
// The output strucuture is TDI_ADDRESS_INFO
// The address handle is returned via IoStatus->Information
//

//
// The input structure for IOCTL_AFD_START_LISTEN.
//

typedef struct _AFD_LISTEN_INFO {
    BOOLEAN     SanActive;
    ULONG MaximumConnectionQueue;
    BOOLEAN UseDelayedAcceptance;
} AFD_LISTEN_INFO, *PAFD_LISTEN_INFO;

//
// The output structure for IOCTL_AFD_WAIT_FOR_LISTEN.
//

typedef struct _AFD_LISTEN_RESPONSE_INFO {
    LONG Sequence;
    TRANSPORT_ADDRESS RemoteAddress;
} AFD_LISTEN_RESPONSE_INFO, *PAFD_LISTEN_RESPONSE_INFO;

//
// The input structure for IOCTL_AFD_ACCEPT.
//

typedef struct _AFD_ACCEPT_INFO {
    BOOLEAN     SanActive;
    LONG Sequence;
    HANDLE AcceptHandle;
} AFD_ACCEPT_INFO, *PAFD_ACCEPT_INFO;


typedef struct _AFD_SUPER_ACCEPT_INFO {
    BOOLEAN     SanActive;
    BOOLEAN     FixAddressAlignment;
    HANDLE      AcceptHandle;
    ULONG       ReceiveDataLength;
    ULONG       LocalAddressLength;
    ULONG       RemoteAddressLength;
} AFD_SUPER_ACCEPT_INFO, *PAFD_SUPER_ACCEPT_INFO;


//
// The input structure for IOCTL_AFD_DEFER_ACCEPT.
//

typedef struct _AFD_DEFER_ACCEPT_INFO {
    LONG Sequence;
    BOOLEAN Reject;
} AFD_DEFER_ACCEPT_INFO, *PAFD_DEFER_ACCEPT_INFO;

//
// Flags and input structure for IOCTL_AFD_PARTIAL_DISCONNECT.
//

#define AFD_PARTIAL_DISCONNECT_SEND 0x01
#define AFD_PARTIAL_DISCONNECT_RECEIVE 0x02
#define AFD_ABORTIVE_DISCONNECT 0x4
#define AFD_UNCONNECT_DATAGRAM 0x08

typedef struct _AFD_PARTIAL_DISCONNECT_INFO {
    ULONG DisconnectMode;
    LARGE_INTEGER Timeout;
} AFD_PARTIAL_DISCONNECT_INFO, *PAFD_PARTIAL_DISCONNECT_INFO;

typedef struct _AFD_SUPER_DISCONNECT_INFO {
    ULONG  Flags;           // Same as TransmitFile
} AFD_SUPER_DISCONNECT_INFO, *PAFD_SUPER_DISCONNECT_INFO;

//
// Structures for IOCTL_AFD_POLL.
//

typedef struct _AFD_POLL_HANDLE_INFO {
    HANDLE Handle;
    ULONG PollEvents;
    NTSTATUS Status;
} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;

typedef struct _AFD_POLL_INFO {
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO Handles[1];
} AFD_POLL_INFO, *PAFD_POLL_INFO;

#define AFD_POLL_RECEIVE_BIT            0   //0001
#define AFD_POLL_RECEIVE                (1 << AFD_POLL_RECEIVE_BIT)
#define AFD_POLL_RECEIVE_EXPEDITED_BIT  1   //0002
#define AFD_POLL_RECEIVE_EXPEDITED      (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
#define AFD_POLL_SEND_BIT               2   //0004
#define AFD_POLL_SEND                   (1 << AFD_POLL_SEND_BIT)
#define AFD_POLL_DISCONNECT_BIT         3   //0008
#define AFD_POLL_DISCONNECT             (1 << AFD_POLL_DISCONNECT_BIT)
#define AFD_POLL_ABORT_BIT              4   //0010
#define AFD_POLL_ABORT                  (1 << AFD_POLL_ABORT_BIT)
#define AFD_POLL_LOCAL_CLOSE_BIT        5   //0020
#define AFD_POLL_LOCAL_CLOSE            (1 << AFD_POLL_LOCAL_CLOSE_BIT)
#define AFD_POLL_CONNECT_BIT            6   //0040
#define AFD_POLL_CONNECT                (1 << AFD_POLL_CONNECT_BIT)
#define AFD_POLL_ACCEPT_BIT             7   //0080
#define AFD_POLL_ACCEPT                 (1 << AFD_POLL_ACCEPT_BIT)
#define AFD_POLL_CONNECT_FAIL_BIT       8   //0100
#define AFD_POLL_CONNECT_FAIL           (1 << AFD_POLL_CONNECT_FAIL_BIT)
#define AFD_POLL_QOS_BIT                9   //0200
#define AFD_POLL_QOS                    (1 << AFD_POLL_QOS_BIT)
#define AFD_POLL_GROUP_QOS_BIT          10  //0400
#define AFD_POLL_GROUP_QOS              (1 << AFD_POLL_GROUP_QOS_BIT)

#define AFD_POLL_ROUTING_IF_CHANGE_BIT  11  //0800
#define AFD_POLL_ROUTING_IF_CHANGE      (1 << AFD_POLL_ROUTING_IF_CHANGE_BIT)
#define AFD_POLL_ADDRESS_LIST_CHANGE_BIT 12 //1000
#define AFD_POLL_ADDRESS_LIST_CHANGE    (1 << AFD_POLL_ADDRESS_LIST_CHANGE_BIT)
#define AFD_NUM_POLL_EVENTS             13
#define AFD_POLL_ALL                    ((1 << AFD_NUM_POLL_EVENTS) - 1)

#define AFD_POLL_SANCOUNTS_UPDATED  0x80000000


//
// Structure for querying receive information.
//

typedef struct _AFD_RECEIVE_INFORMATION {
    ULONG BytesAvailable;
    ULONG ExpeditedBytesAvailable;
} AFD_RECEIVE_INFORMATION, *PAFD_RECEIVE_INFORMATION;

//
// Structure for quering the TDI handles for an AFD endpoint.
//

#define AFD_QUERY_ADDRESS_HANDLE 1
#define AFD_QUERY_CONNECTION_HANDLE 2


typedef struct _AFD_HANDLE_INFO {
    HANDLE TdiAddressHandle;
    HANDLE TdiConnectionHandle;
} AFD_HANDLE_INFO, *PAFD_HANDLE_INFO;

//
// Structure and manifests for setting information in AFD.
//

typedef struct _AFD_INFORMATION {
    ULONG InformationType;
    union {
        BOOLEAN Boolean;
        ULONG Ulong;
        LARGE_INTEGER LargeInteger;
    } Information;
} AFD_INFORMATION, *PAFD_INFORMATION;

#define AFD_INLINE_MODE          0x01
#define AFD_NONBLOCKING_MODE     0x02
#define AFD_MAX_SEND_SIZE        0x03
#define AFD_SENDS_PENDING        0x04
#define AFD_MAX_PATH_SEND_SIZE   0x05
#define AFD_RECEIVE_WINDOW_SIZE  0x06
#define AFD_SEND_WINDOW_SIZE     0x07
#define AFD_CONNECT_TIME         0x08
#define AFD_CIRCULAR_QUEUEING    0x09
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_REPORT_PORT_UNREACHABLE 0x0B

//
// Structure for the transmit file IOCTL.
//


typedef struct _AFD_TRANSMIT_FILE_INFO {
    LARGE_INTEGER Offset;
    LARGE_INTEGER WriteLength;
    ULONG SendPacketLength;
    HANDLE FileHandle;
    PVOID Head;
    ULONG HeadLength;
    PVOID Tail;
    ULONG TailLength;
    ULONG Flags;
} AFD_TRANSMIT_FILE_INFO, *PAFD_TRANSMIT_FILE_INFO;

//
// Flags for the TransmitFile API.
//

#define AFD_TF_DISCONNECT           0x01
#define AFD_TF_REUSE_SOCKET         0x02
#define AFD_TF_WRITE_BEHIND         0x04

#define AFD_TF_USE_DEFAULT_WORKER   0x00
#define AFD_TF_USE_SYSTEM_THREAD    0x10
#define AFD_TF_USE_KERNEL_APC       0x20
#define AFD_TF_WORKER_KIND_MASK     0x30


//
// Flag definitions for the AfdFlags field in the AFD_SEND_INFO,
// AFD_SEND_DATAGRAM_INFO, AFD_RECV_INFO, and AFD_RECV_DATAGRAM_INFO
// structures.
//

#define AFD_NO_FAST_IO      0x0001      // Always fail Fast IO on this request.
#define AFD_OVERLAPPED      0x0002      // Overlapped operation.

//
// Structure for connected sends.
//

typedef struct _AFD_SEND_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_SEND_INFO, *PAFD_SEND_INFO;

//
// Structure for unconnected datagram sends.
//

typedef struct _AFD_SEND_DATAGRAM_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    TDI_REQUEST_SEND_DATAGRAM   TdiRequest;
    TDI_CONNECTION_INFORMATION  TdiConnInfo;
} AFD_SEND_DATAGRAM_INFO, *PAFD_SEND_DATAGRAM_INFO;

//
// Structure for connected recvs.
//

typedef struct _AFD_RECV_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_RECV_INFO, *PAFD_RECV_INFO;

//
// Structure for receiving datagrams on unconnected sockets.
//

typedef struct _AFD_RECV_DATAGRAM_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    PVOID Address;
    PULONG AddressLength;
} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;


//
// Structure for receiving datagram messages.
//
typedef struct _AFD_RECV_MESSAGE_INFO {
    AFD_RECV_DATAGRAM_INFO dgi;
    PVOID   ControlBuffer;
    PULONG  ControlLength;
    PULONG  MsgFlags;
} AFD_RECV_MESSAGE_INFO, *PAFD_RECV_MESSAGE_INFO;

#define AFD_MAX_TDI_FAST_ADDRESS 32

//
// Structure for event select.
//

typedef struct _AFD_EVENT_SELECT_INFO {
    HANDLE Event;
    ULONG PollEvents;
} AFD_EVENT_SELECT_INFO, *PAFD_EVENT_SELECT_INFO;

//
// Output structure for enum network events.
//

typedef struct _AFD_ENUM_NETWORK_EVENTS_INFO {
    ULONG PollEvents;
    NTSTATUS EventStatus[AFD_NUM_POLL_EVENTS];
} AFD_ENUM_NETWORK_EVENTS_INFO, *PAFD_ENUM_NETWORK_EVENTS_INFO;

//
// Structures for QOS and grouping.
//


typedef struct _AFD_QOS_INFO {
    QOS Qos;
    BOOLEAN GroupQos;
} AFD_QOS_INFO, *PAFD_QOS_INFO;

//
// Group membership type.
//

typedef enum _AFD_GROUP_TYPE {
    GroupTypeNeither = 0,
    GroupTypeConstrained = SG_CONSTRAINED_GROUP,
    GroupTypeUnconstrained = SG_UNCONSTRAINED_GROUP
} AFD_GROUP_TYPE, *PAFD_GROUP_TYPE;

//
// Note that, for totally slimy reasons, the following
// structure must be exactly eight bytes long (the size
// of a LARGE_INTEGER). See msafd\socket.c and afd\misc.c
// for the gory details.
//

typedef struct _AFD_GROUP_INFO {
    LONG GroupID;
    AFD_GROUP_TYPE GroupType;
} AFD_GROUP_INFO, *PAFD_GROUP_INFO;

//
// Structure for validating group membership.
//

typedef struct _AFD_VALIDATE_GROUP_INFO {
    LONG GroupID;
    TRANSPORT_ADDRESS RemoteAddress;
} AFD_VALIDATE_GROUP_INFO, *PAFD_VALIDATE_GROUP_INFO;

//
// Structure for querying connect data on an unaccepted connection.
//

typedef struct _AFD_UNACCEPTED_CONNECT_DATA_INFO {
    LONG Sequence;
    ULONG ConnectDataLength;
    BOOLEAN LengthOnly;

} AFD_UNACCEPTED_CONNECT_DATA_INFO, *PAFD_UNACCEPTED_CONNECT_DATA_INFO;

typedef struct _AFD_TRANSPORT_IOCTL_INFO {
    HANDLE  Handle;
    PVOID   InputBuffer;
    ULONG   InputBufferLength;
    ULONG   IoControlCode;
    ULONG   AfdFlags;
    ULONG   PollEvent;
} AFD_TRANSPORT_IOCTL_INFO, *PAFD_TRANSPORT_IOCTL_INFO;


typedef struct _AFD_CONNECT_JOIN_INFO {
    BOOLEAN     SanActive;
    HANDLE  RootEndpoint;       // Root endpoint for joins
    HANDLE  ConnectEndpoint;    // Connect/leaf endpoint for async connects
    TRANSPORT_ADDRESS   RemoteAddress; // Remote address
} AFD_CONNECT_JOIN_INFO, *PAFD_CONNECT_JOIN_INFO;

typedef struct _AFD_SUPER_CONNECT_INFO {
    BOOLEAN     SanActive;
    TRANSPORT_ADDRESS   RemoteAddress; // Remote address
} AFD_SUPER_CONNECT_INFO, *PAFD_SUPER_CONNECT_INFO;


#ifndef _WINSOCK2API_
typedef struct _TRANSMIT_PACKETS_ELEMENT {
    ULONG dwElFlags;
#define TP_MEMORY   1
#define TP_FILE     2
#define TP_EOP      4
    ULONG cLength;
    union {
        struct {
            LARGE_INTEGER nFileOffset;
            HANDLE        hFile;
        };
        PVOID             pBuffer;
    };
} TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#else
typedef struct _TRANSMIT_PACKETS_ELEMENT TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#endif

typedef struct _AFD_TPACKETS_INFO {
    LPTRANSMIT_PACKETS_ELEMENT  ElementArray;
    ULONG                       ElementCount;
    ULONG                       SendSize;
    ULONG                       Flags;
} AFD_TPACKETS_INFO, *PAFD_TPACKETS_INFO;

//
// AFD IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by AFD's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      ntos\afd\dispatch.c!
//

#define FSCTL_AFD_BASE                  FILE_DEVICE_NETWORK
#define _AFD_CONTROL_CODE(request,method) \
                ((FSCTL_AFD_BASE)<<12 | (request<<2) | method)
#define _AFD_REQUEST(ioctl) \
                ((((ULONG)(ioctl)) >> 2) & 0x03FF)

#define _AFD_BASE(ioctl) \
                ((((ULONG)(ioctl)) >> 12) & 0xFFFFF)

#define AFD_BIND                    0
#define AFD_CONNECT                 1
#define AFD_START_LISTEN            2
#define AFD_WAIT_FOR_LISTEN         3
#define AFD_ACCEPT                  4
#define AFD_RECEIVE                 5
#define AFD_RECEIVE_DATAGRAM        6
#define AFD_SEND                    7
#define AFD_SEND_DATAGRAM           8
#define AFD_POLL                    9
#define AFD_PARTIAL_DISCONNECT      10

#define AFD_GET_ADDRESS             11
#define AFD_QUERY_RECEIVE_INFO      12
#define AFD_QUERY_HANDLES           13
#define AFD_SET_INFORMATION         14
#define AFD_GET_REMOTE_ADDRESS      15
#define AFD_GET_CONTEXT             16
#define AFD_SET_CONTEXT             17

#define AFD_SET_CONNECT_DATA        18
#define AFD_SET_CONNECT_OPTIONS     19
#define AFD_SET_DISCONNECT_DATA     20
#define AFD_SET_DISCONNECT_OPTIONS  21

#define AFD_GET_CONNECT_DATA        22
#define AFD_GET_CONNECT_OPTIONS     23
#define AFD_GET_DISCONNECT_DATA     24
#define AFD_GET_DISCONNECT_OPTIONS  25

#define AFD_SIZE_CONNECT_DATA       26
#define AFD_SIZE_CONNECT_OPTIONS    27
#define AFD_SIZE_DISCONNECT_DATA    28
#define AFD_SIZE_DISCONNECT_OPTIONS 29

#define AFD_GET_INFORMATION         30
#define AFD_TRANSMIT_FILE           31
#define AFD_SUPER_ACCEPT            32

#define AFD_EVENT_SELECT            33
#define AFD_ENUM_NETWORK_EVENTS     34

#define AFD_DEFER_ACCEPT            35
#define AFD_WAIT_FOR_LISTEN_LIFO    36
#define AFD_SET_QOS                 37
#define AFD_GET_QOS                 38
#define AFD_NO_OPERATION            39
#define AFD_VALIDATE_GROUP          40
#define AFD_GET_UNACCEPTED_CONNECT_DATA 41

#define AFD_ROUTING_INTERFACE_QUERY  42
#define AFD_ROUTING_INTERFACE_CHANGE 43
#define AFD_ADDRESS_LIST_QUERY      44
#define AFD_ADDRESS_LIST_CHANGE     45
#define AFD_JOIN_LEAF               46
#define AFD_TRANSPORT_IOCTL         47
#define AFD_TRANSMIT_PACKETS        48
#define AFD_SUPER_CONNECT           49
#define AFD_SUPER_DISCONNECT        50
#define AFD_RECEIVE_MESSAGE         51

//
// SAN switch specific AFD function numbers
//
#define AFD_SWITCH_CEMENT_SAN       52
#define AFD_SWITCH_SET_EVENTS       53
#define AFD_SWITCH_RESET_EVENTS     54
#define AFD_SWITCH_CONNECT_IND      55
#define AFD_SWITCH_CMPL_ACCEPT      56
#define AFD_SWITCH_CMPL_REQUEST     57
#define AFD_SWITCH_CMPL_IO          58
#define AFD_SWITCH_REFRESH_ENDP     59
#define AFD_SWITCH_GET_PHYSICAL_ADDR 60
#define AFD_SWITCH_ACQUIRE_CTX      61
#define AFD_SWITCH_TRANSFER_CTX     62
#define AFD_SWITCH_GET_SERVICE_PID  63
#define AFD_SWITCH_SET_SERVICE_PROCESS  64
#define AFD_SWITCH_PROVIDER_CHANGE  65
#define AFD_SWITCH_ADDRLIST_CHANGE	66
#define AFD_NUM_IOCTLS				67



#define IOCTL_AFD_BIND                    _AFD_CONTROL_CODE( AFD_BIND, METHOD_NEITHER )
#define IOCTL_AFD_CONNECT                 _AFD_CONTROL_CODE( AFD_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_START_LISTEN            _AFD_CONTROL_CODE( AFD_START_LISTEN, METHOD_NEITHER )
#define IOCTL_AFD_WAIT_FOR_LISTEN         _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN, METHOD_BUFFERED )
#define IOCTL_AFD_ACCEPT                  _AFD_CONTROL_CODE( AFD_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_RECEIVE                 _AFD_CONTROL_CODE( AFD_RECEIVE, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_DATAGRAM        _AFD_CONTROL_CODE( AFD_RECEIVE_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_SEND                    _AFD_CONTROL_CODE( AFD_SEND, METHOD_NEITHER )
#define IOCTL_AFD_SEND_DATAGRAM           _AFD_CONTROL_CODE( AFD_SEND_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_POLL                    _AFD_CONTROL_CODE( AFD_POLL, METHOD_BUFFERED )
#define IOCTL_AFD_PARTIAL_DISCONNECT      _AFD_CONTROL_CODE( AFD_PARTIAL_DISCONNECT, METHOD_NEITHER )

#define IOCTL_AFD_GET_ADDRESS             _AFD_CONTROL_CODE( AFD_GET_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_RECEIVE_INFO      _AFD_CONTROL_CODE( AFD_QUERY_RECEIVE_INFO, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_HANDLES           _AFD_CONTROL_CODE( AFD_QUERY_HANDLES, METHOD_NEITHER )
#define IOCTL_AFD_SET_INFORMATION         _AFD_CONTROL_CODE( AFD_SET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_GET_REMOTE_ADDRESS      _AFD_CONTROL_CODE( AFD_GET_REMOTE_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONTEXT             _AFD_CONTROL_CODE( AFD_GET_CONTEXT, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONTEXT             _AFD_CONTROL_CODE( AFD_SET_CONTEXT, METHOD_NEITHER )

#define IOCTL_AFD_SET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_SET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_SET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_GET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_GET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_SIZE_CONNECT_DATA       _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_CONNECT_OPTIONS    _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_DATA    _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_OPTIONS _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_INFORMATION         _AFD_CONTROL_CODE( AFD_GET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_FILE           _AFD_CONTROL_CODE( AFD_TRANSMIT_FILE, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_ACCEPT            _AFD_CONTROL_CODE( AFD_SUPER_ACCEPT, METHOD_NEITHER )

#define IOCTL_AFD_EVENT_SELECT            _AFD_CONTROL_CODE( AFD_EVENT_SELECT, METHOD_NEITHER )
#define IOCTL_AFD_ENUM_NETWORK_EVENTS     _AFD_CONTROL_CODE( AFD_ENUM_NETWORK_EVENTS, METHOD_NEITHER )

#define IOCTL_AFD_DEFER_ACCEPT            _AFD_CONTROL_CODE( AFD_DEFER_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_WAIT_FOR_LISTEN_LIFO    _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN_LIFO, METHOD_BUFFERED )
#define IOCTL_AFD_SET_QOS                 _AFD_CONTROL_CODE( AFD_SET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_GET_QOS                 _AFD_CONTROL_CODE( AFD_GET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_NO_OPERATION            _AFD_CONTROL_CODE( AFD_NO_OPERATION, METHOD_NEITHER )
#define IOCTL_AFD_VALIDATE_GROUP          _AFD_CONTROL_CODE( AFD_VALIDATE_GROUP, METHOD_BUFFERED )
#define IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA _AFD_CONTROL_CODE( AFD_GET_UNACCEPTED_CONNECT_DATA, METHOD_NEITHER )

#define IOCTL_AFD_ROUTING_INTERFACE_QUERY  _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ROUTING_INTERFACE_CHANGE _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_ADDRESS_LIST_QUERY       _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ADDRESS_LIST_CHANGE      _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_JOIN_LEAF                _AFD_CONTROL_CODE( AFD_JOIN_LEAF, METHOD_NEITHER )
#define IOCTL_AFD_TRANSPORT_IOCTL          _AFD_CONTROL_CODE( AFD_TRANSPORT_IOCTL, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_PACKETS         _AFD_CONTROL_CODE( AFD_TRANSMIT_PACKETS, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_CONNECT            _AFD_CONTROL_CODE( AFD_SUPER_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_DISCONNECT         _AFD_CONTROL_CODE( AFD_SUPER_DISCONNECT, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_MESSAGE          _AFD_CONTROL_CODE( AFD_RECEIVE_MESSAGE, METHOD_NEITHER )




//
// SAN support
//
//

//
// SAN IOCTL control codes.
//

#define IOCTL_AFD_SWITCH_CEMENT_SAN     _AFD_CONTROL_CODE( AFD_SWITCH_CEMENT_SAN, METHOD_NEITHER )
/*++
Ioctl Description:
    Changes the AFD endpoint type to SAN to indicate that
    it is used for support of user mode SAN providers
    Associates switch context with the endpoint.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ingored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond to AFD
                                endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_SET_EVENTS     _AFD_CONTROL_CODE( AFD_SWITCH_SET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Sets the poll event on the san endpoint to report
    to the application via various forms of the select.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint (except
                                                AFD_POLL_EVENT_CONNECT_FAIL which
                                                just needs a bound endpoint).
                            SwitchContext   - switch context associated with endpoint (NULL
                                                for AFD_POLL_EVENT_CONNECT_FAIL) to validate
                                                the handle-endpoint association
                            EventBit        - event bit to set
                            Status          - associated status (for AFD_POLL_EVENT_CONNECT_FAIL)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_RESET_EVENTS   _AFD_CONTROL_CODE( AFD_SWITCH_RESET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Resets the poll event on the san endpoint so that it is no
    longer reported to the application via various forms of the select
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint
                            SwitchContext   - switch context associated with endpoint 
                                                to validate the handle-endpoint association
                            EventBit        - event bit to reset
                            Status          - associated status (ignored)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_CONNECT_IND    _AFD_CONTROL_CODE( AFD_SWITCH_CONNECT_IND, METHOD_OUT_DIRECT )
/*++
Ioctl Description:
    Implements connect indication from SAN provider.
    Picks up the accept from the listening endpoint queue
    or queues the indication an signals the application to come
    down with an accept.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONNECT_INFO):
                            ListenHandle    - handle of the listening endpoint
                            RemoteAddress   - remote and local addresses associated
                                                with indication incoming connection
    InputBufferLength - sizeof(AFD_SWITCH_CONNECT_INFO)+addresses
    OutputBuffer    - output parameters for the operation (AFD_SWITCH_ACCEPT_INFO):
                            AcceptHandle    - handle of the accepting endpoint
                            ReceiveLength   - length of the receive buffer supplied by
                                                the application in AcceptEx
                            
    OutputBufferLength - sizeof (AFD_SWITCH_ACCEPT_INFO)
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or listen socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or listen socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input or output buffers are of incorrect size.
        STATUS_CANCELLED    -  connection indication was cancelled (thread exited or
                                accepting and/or listening socket closed)
        other - failed when attempting to access listening socket, input or output buffers
    IoStatus.Information - sizeof (AFD_SWITCH_ACCEPT_INFO) in case of success.
--*/

#define IOCTL_AFD_SWITCH_CMPL_ACCEPT    _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_ACCEPT, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the acceptance of SAN connection
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the accepting endpoint
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - data to copy into the AcceptEx receive buffer
    OutputBufferLength - size of received data
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_LOCAL_DISCONNECT - accept was aborted by the application.
        other - failed when attempting to access accepte socket, input/output buffers, 
                or switch context.
    IoStatus.Information - Number of bytes copied into application's receive buffer.
--*/


#define IOCTL_AFD_SWITCH_CMPL_REQUEST   _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_REQUEST, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the redirected read/write request processed by SAN provider
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_REQUEST_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies the request to complete
                        RequestStatus - status with which to complete the request (
                                        STATUS_PENDING has special meaning, request
                                        is not completed - merely data is copied)
                        DataOffset - offset in the request buffer to read/write the data
    InputBufferLength - sizeof (AFD_SWITCH_REQUEST_INFO)
    OutputBuffer - switch buffer to read/write data
    OutputBufferLength - length of the buffer
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_CANCELLED - request to be completed has already been cancelled
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied from/to switch buffer.
--*/

#define IOCTL_AFD_SWITCH_CMPL_IO        _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_IO, METHOD_NEITHER )
/*++
Ioctl Description:
    Simulates async IO completion for the switch.
Arguments:
    Handle          - SAN socket handle on which to complete the IO.
    InputBuffer     - input parameters for the operation (IO_STATUS_BLOCK)
                        Status - final operation status
                        Information - associated information (number of bytes 
                                        transferred to/from request buffer(s))
    InputBufferLength - sizeof (IO_STATUS_BLOCK)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_INVALID_PARAMETER - input buffer is of invalid size.
        other - status of the IO operation or failure code when attempting to 
                    access input buffer.
    IoStatus.Information - information from the input buffer
--*/

#define IOCTL_AFD_SWITCH_REFRESH_ENDP   _AFD_CONTROL_CODE( AFD_SWITCH_REFRESH_ENDP, METHOD_NEITHER )
/*++
Ioctl Description:
    Refreshes endpoint so it can be used again in AcceptEx
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                        SocketHandle - Socket to refresh
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
    InputBufferLength - sizeof (AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR _AFD_CONTROL_CODE( AFD_SWITCH_GET_PHYSICAL_ADDR, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns physical address corresponding to provided virtual address.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - user mode virtual address
    InputBufferLength - access mode
    OutputBuffer    - Buffer to place physical address into.
    OutputBufferLength - sizeof (PHYSICAL_ADDRESS)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_BUFFER_TOO_SMALL - output buffer is of incorrect size.
        STATUS_INVALID_PARAMETER - invalid access mode.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - sizeof(PHYSICAL_ADDRESS).
--*/

#define IOCTL_AFD_SWITCH_ACQUIRE_CTX    _AFD_CONTROL_CODE( AFD_SWITCH_ACQUIRE_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests transfer of the socket context to the current process.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_ACQUIRE_CTX_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context to be associated with endpoint 
                                            when context transfered to the current process.
                        SocketCtxBuf  - buffer to receive current socket context from
                                            another process
                        SocketCtxBufSize - size of the buffer
    InputBufferLength - sizeof (AFD_SWITCH_ACQUIRE_CTX_INFO)
    OutputBuffer - buffer to receive data buffered on the socket in another process
                        and not yet delivered to the applicaiton
    OutputBufferLength - length of the receive buffer
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied to receive buffer.
--*/

#define IOCTL_AFD_SWITCH_TRANSFER_CTX   _AFD_CONTROL_CODE( AFD_SWITCH_TRANSFER_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests AFD to transfer endpoint into another process context
Arguments:
    InputBuffer     - input parameters for the operation (AFD_SWITCH_TRANSFER_CTX_INFO)
                        SocketHandle - Socket to transfer
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies corresponding acquire request,
                                        NULL if this is unsolicited request to transfer to
                                        the service process.
                        SocketCtxBuf - socket context to copy destination process
                                            acquire request context buffer
                        SocketCtxSize - size of the context buffer to copy
                        RcvBufferArray - array of buffered data to transfer to 
                                            destination process acquire request
                        RcvBufferCount - number of elements in the array.
    InputBufferLength - sizeof (AFD_SWITCH_TRANSFER_CTX_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - number of bytes copied from RcvBufferArray.
--*/

#define IOCTL_AFD_SWITCH_GET_SERVICE_PID _AFD_CONTROL_CODE( AFD_SWITCH_GET_SERVICE_PID, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns PID of the service process used for intermediate socket duplication.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - pid of the service process.
--*/

#define IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS _AFD_CONTROL_CODE( AFD_SWITCH_SET_SERVICE_PROCESS, METHOD_NEITHER )
/*++
Ioctl Description:
    Notifies AFD that this process will be used for handle duplication services
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_PROVIDER_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_PROVIDER_CHANGE, METHOD_NEITHER )
/*++
Ioctl Description:
        Notifies interested processes of SAN provider addition/deletion/change.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_ADDRLIST_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_ADDRLIST_CHANGE, METHOD_BUFFERED )
/*++
Ioctl Description:
        SAN specific version of address list change notifications.
        Capture provider installation/removal in addition to plain
        address list changes.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - Input parameters for the operation (AFD_TRANSPORT_IOCTL_INFO):
                        AfdFlags - operation flags (e.g. AFD_OVERLAPPED)
                        Handle  - unused
                        PollEvent - unused
                        IoControlCode - IOCTL_AFD_ADDRESS_LIST_CHANGE
                        InputBuffer - pointer to address family (AF_INET)
                        InputBufferLength - sizeof (USHORT)
                        
    InputBufferLength - sizeof (AFD_TRANSPORT_IOCTL_INFO)
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - 0 - regular address list change
                            otherwise, seq number of provider list change.
--*/

// Open packet that identifies SAN helper endpoint used
// for communication between SAN switch and AFD.
// This is EA name
//
#define AfdSwitchOpenPacket     "AfdSwOpenPacket"
#define AFD_SWITCH_OPEN_PACKET_NAME_LENGTH (sizeof(AfdSwitchOpenPacket)-1)

//
// Data passed in the open packet
// This is EA value
//
typedef struct _AFD_SWITCH_OPEN_PACKET {
    HANDLE      CompletionPort; // Completion port notify SAN switch
                                // of SAN io completions
    HANDLE      CompletionEvent;// Completion event to distinguish IO issued
                                // by SAN switch from application IO.
} AFD_SWITCH_OPEN_PACKET, *PAFD_SWITCH_OPEN_PACKET;

typedef struct _AFD_SWITCH_CONTEXT {
    LONG        EventsActive;   // Poll events activated by switch
    LONG        RcvCount;       // Count of polls for receive
    LONG        ExpCount;       // Count of polls for expedited
    LONG        SndCount;       // Count of polls for send
	BOOLEAN		SelectFlag;		// TRUE if app has done any form of select
} AFD_SWITCH_CONTEXT, *PAFD_SWITCH_CONTEXT;


//
// Information for associating AFD endpoint with SAN provider
//
typedef struct _AFD_SWITCH_CONTEXT_INFO {
    HANDLE      SocketHandle;   // Handle to associate with SAN provider
    PAFD_SWITCH_CONTEXT SwitchContext;  // Opaque context value maintained for the switch
} AFD_SWITCH_CONTEXT_INFO, *PAFD_SWITCH_CONTEXT_INFO;

//
// Information for connection indication from SAN provider to AFD
//
typedef struct _AFD_SWITCH_CONNECT_INFO {
    HANDLE              ListenHandle;   // Listening socket handle
    PAFD_SWITCH_CONTEXT SwitchContext;
    TRANSPORT_ADDRESS   RemoteAddress;  // Address of the remote peer wishing
                                        // to connect
} AFD_SWITCH_CONNECT_INFO, *PAFD_SWITCH_CONNECT_INFO;

//
// Information returned by the AFD to switch in response
// to connection indication
//
typedef struct _AFD_SWITCH_ACCEPT_INFO {
    HANDLE              AcceptHandle;   // Socket handle to use to accept connection
    ULONG               ReceiveLength;  // Length of the initial receive buffer (for AcceptEx)
} AFD_SWITCH_ACCEPT_INFO, *PAFD_SWITCH_ACCEPT_INFO;

//
// Information passed by the switch to signal network events on the
// endpoint (socket)
//
typedef struct _AFD_SWITCH_EVENT_INFO {
	HANDLE		SocketHandle;   // Socket handle on which to signal
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
	ULONG		EventBit;       // Event bit to set/reset (AFD_POLL_xxx_BIT constants)
    NTSTATUS    Status;         // Status code associated with the event (this
                                // is used for AFD_POLL_CONNECT_FAIL_BIT)
} AFD_SWITCH_EVENT_INFO, *PAFD_SWITCH_EVENT_INFO;


//
// Information passed by the switch to retreive parameters/complete
// redirected read/write request
//
typedef struct _AFD_SWITCH_REQUEST_INFO {
	HANDLE		SocketHandle;   // Socket handle on which request us active
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Request context that identifies it
    NTSTATUS    RequestStatus;  // Completion status of the request (STATUS_PENDING
                                // indicates that request should NOT be completed yet)
    ULONG       DataOffset;     // Offset from which to start copying data from/to
                                // application's buffer
} AFD_SWITCH_REQUEST_INFO, *PAFD_SWITCH_REQUEST_INFO;



//
// Access type (read access or write access) that's needed for an app buffer
// whose physical address is requested thru AfdSanFastGetPhysicalAddr
//
#define MEM_READ_ACCESS		1
#define MEM_WRITE_ACCESS	2


//
// Information passed between processes when socket is duplicated.
//
typedef struct _AFD_SWITCH_ACQUIRE_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context to be associated with the socket
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
} AFD_SWITCH_ACQUIRE_CTX_INFO, *PAFD_SWITCH_ACQUIRE_CTX_INFO;

typedef struct _AFD_SWITCH_TRANSFER_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Value that identifies corresponding acquire request
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
    LPWSABUF    RcvBufferArray; // Receive buffers to copy to destination process
    ULONG       RcvBufferCount; // Number of receive buffers
    NTSTATUS    Status;         // Status of transfer opertaion.
} AFD_SWITCH_TRANSFER_CTX_INFO, *PAFD_SWITCH_TRANSFER_CTX_INFO;

//
// Request from AFD to switch (passed via completion port)
//
#define AFD_SWITCH_REQUEST_CLOSE    0
/*++
Request Description:
    All references to the socket have been closed in all processes, safe
    to destroy the SAN provider socket and connection
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLOSE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0 (ignored)
--*/

#define AFD_SWITCH_REQUEST_READ     1
/*++
Request Description:
    Read request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_READ)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the receive buffer supplied by the application
--*/

#define AFD_SWITCH_REQUEST_WRITE    2
/*++
Request Description:
    Write request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_WRITE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the send data supplied by the application
--*/

#define AFD_SWITCH_REQUEST_TFCTX    3
/*++
Request Description:
    Another process requests ownership of the socket.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_TFCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - PID of the process requesting ownership.
--*/

#define AFD_SWITCH_REQUEST_CHCTX    4
/*++
Request Description:
    Relationship between socket handle and switch context has become invalid
    (application must have closed the original socket and using duplicated handle)
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CHCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle currently used by the application.
--*/

#define AFD_SWITCH_REQUEST_AQCTX    5
/*++
Request Description:
    Request to service process to acquire ownership of the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - NULL
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_AQCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle of the socket to be acquired.
--*/

#define AFD_SWITCH_REQUEST_CLSOC    6
/*++
Request Description:
    Request to service process to close the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLSOC)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0.
--*/


#define AFD_SWITCH_REQUEST_ID_SHIFT 3
#define AFD_SWITCH_REQUEST_TYPE_MASK    \
            ((1<<AFD_SWITCH_REQUEST_ID_SHIFT)-1)

#define AFD_SWITCH_MAKE_REQUEST_CONTEXT(_id,_type)      \
            UlongToPtr(((_id)<<AFD_SWITCH_REQUEST_ID_SHIFT)+(_type))

//
// Retrives request type from the request context
//
#define AFD_SWITCH_REQUEST_TYPE(_RequestContext)        \
        (((ULONG_PTR)(_RequestContext))&AFD_SWITCH_REQUEST_TYPE_MASK)

#endif // ndef _AFD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\acd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasacd.h

Abstract:

    This header file defines constants and types for accessing the NT
    Automatic Connection Driver (rasacd.sys).

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/

#ifndef _RASACD_
#define _RASACD_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define ACD_DEVICE_NAME   L"\\Device\\RasAcd"

//
// Address type.
//
typedef enum {
    ACD_ADDR_IP,            // IP address (128.95.1.4)
    ACD_ADDR_IPX,           // IPX node address ()
    ACD_ADDR_NB,            // NETBIOS name ("server")
    ACD_ADDR_INET,          // Internet hostname ("ftp.microsoft.com")
    ACD_ADDR_MAX
} ACD_ADDR_TYPE;

//
// Generic network address string.
//
#define ACD_ADDR_NB_LEN         16      // nb30.h/NCBNAMSZ
#define ACD_ADDR_IPX_LEN        6       // wsipx.h
#define ACD_ADDR_INET_LEN       1024    // wininet.h/INTERNET_MAX_PATH_LENGTH

typedef struct _ACD_ADDR {
    ACD_ADDR_TYPE fType;
    union {
        ULONG ulIpaddr;                         // IP address
        UCHAR cNode[ACD_ADDR_IPX_LEN];          // IPX address
        UCHAR cNetbios[ACD_ADDR_NB_LEN];        // NetBios server
        UCHAR szInet[ACD_ADDR_INET_LEN];        // Internet address
    };
} ACD_ADDR, *PACD_ADDR;

//
// Adapter information.
//
// Each transport passes up some identifier
// of which adapter over which a successful
// connection was made.
//
typedef enum {
    ACD_ADAPTER_LANA,
    ACD_ADAPTER_IP,
    ACD_ADAPTER_NAME,
    ACD_ADAPTER_MAC
} ACD_ADAPTER_TYPE;

#define ACD_ADAPTER_NAME_LEN    256

typedef struct _ACD_ADAPTER {
    enum ACD_ADAPTER_TYPE fType;
    union {
        UCHAR bLana;                            // NetBios LANA
        ULONG ulIpaddr;                         // IP address
        WCHAR szName[ACD_ADAPTER_NAME_LEN];     // for example, "NdisWan4"
        UCHAR cMac[6];                          // IPX mac address
    };
} ACD_ADAPTER, *PACD_ADAPTER;

//
// Connection notification structure.
//
// The automatic connection system service
// posts one of these to the automatic connection
// driver.  The request will be completed and
// this structure filled in by the driver when a
// new RAS connection is to be made.
//
#define ACD_NOTIFICATION_SUCCESS    0x00000001  // successful connection

typedef struct _ACD_NOTIFICATION {
    ACD_ADDR addr;                 // address of connection attempt
    ULONG ulFlags;                 // ACD_NOTIFICATION_* flags above
    ACD_ADAPTER adapter;           // adapter identifier
    HANDLE  Pid;                    // pid of the process requesting the conneciton
} ACD_NOTIFICATION, *PACD_NOTIFICATION;

#if defined(_WIN64)
typedef struct _ACD_NOTIFICATION_32 {

    ACD_ADDR addr;                 // address of connection attempt
    ULONG ulFlags;                 // ACD_NOTIFICATION_* flags above
    ACD_ADAPTER adapter;           // adapter identifier
    VOID * POINTER_32  Pid;        // pid of the process requesting the conneciton
} ACD_NOTIFICATION_32, *PACD_NOTIFICATION_32;
#endif

typedef struct _ACD_STATUS {
    BOOLEAN fSuccess;               // success or failure
    ACD_ADDR addr;                  // address of connection attempt
} ACD_STATUS, *PACD_STATUS;

typedef struct _ACD_ENABLE_ADDRESS {
    BOOLEAN fDisable;
    ACD_ADDR addr;
} ACD_ENABLE_ADDRESS, *PACD_ENABLE_ADDRESS;    

//
//
// IOCTL code definitions
//
#define FILE_DEVICE_ACD   0x000000f1
#define _ACD_CTL_CODE(function, method, access) \
            CTL_CODE(FILE_DEVICE_ACD, function, method, access)

//
// Set the notification mode for the driver.
//
#define IOCTL_ACD_RESET \
            _ACD_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Set the notification mode for the driver.
//
#define IOCTL_ACD_ENABLE \
            _ACD_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Wait for a connection request notification
// from the automatic connection driver.
//
#define IOCTL_ACD_NOTIFICATION \
            _ACD_CTL_CODE(2, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Inform the automatic connection driver that
// the connection attempt is progressing.
//
#define IOCTL_ACD_KEEPALIVE \
            _ACD_CTL_CODE(3, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Inform the automatic connection driver of
// the final status of the connection attempt.
//
#define IOCTL_ACD_COMPLETION \
            _ACD_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Generate an automatic connection attempt
// from user space.
//
#define IOCTL_ACD_CONNECT_ADDRESS \
            _ACD_CTL_CODE(5, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Disable an address so that any automatic connection attempts
// to this address are disabled. This is required so that we don't
// create a deadlock when attempting to dial vpn connection by name.
// We don't want the name resolution of the vpn destination to
// cause an autodial attempt.
//
#define IOCTL_ACD_ENABLE_ADDRESS \
            _ACD_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif  // ifndef _RASACD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\apiparam.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    apiparam.h

Abstract:

    Declaration of structures representing parameters to the API calls.
    Each structure contains all parameters for a corresponding call,
    except for any server name (PSZ Server) parameters.

Author:

    Shanku Niyogi (w-shanku) 11-Jan-1991

Revision History:

--*/

#ifndef _APIPARAMS_
#define _APIPARAMS_

#include <packon.h>                     // Pack structures.

//
// Access permission APIs.
//

typedef struct _XS_NET_ACCESS_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_ACCESS_ADD, *PXS_NET_ACCESS_ADD;

typedef struct _XS_NET_ACCESS_CHECK {
    LPSTR Reserved;
    LPSTR UserName;
    LPSTR Resource;
    WORD Operation;
    WORD Result;
} XS_NET_ACCESS_CHECK, *PXS_NET_ACCESS_CHECK;

typedef struct _XS_NET_ACCESS_DEL {
    LPSTR Resource;
} XS_NET_ACCESS_DEL, *PXS_NET_ACCESS_DEL;

typedef struct _XS_NET_ACCESS_ENUM {
    LPSTR BasePath;
    WORD Recursive;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_ACCESS_ENUM, *PXS_NET_ACCESS_ENUM;

typedef struct _XS_NET_ACCESS_GET_INFO {
    LPSTR Resource;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_ACCESS_GET_INFO, *PXS_NET_ACCESS_GET_INFO;

typedef struct _XS_NET_ACCESS_SET_INFO {
    LPSTR Resource;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_ACCESS_SET_INFO, *PXS_NET_ACCESS_SET_INFO;

typedef struct _XS_NET_ACCESS_GET_USER_PERMS {
    LPSTR UgName;
    LPSTR Resource;
    WORD Perms;
} XS_NET_ACCESS_GET_USER_PERMS, *PXS_NET_ACCESS_GET_USER_PERMS;

//
// Account APIs.
//

typedef struct _XS_I_NET_ACCOUNT_DELTAS {
    LPSTR ComputerName;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    LPBYTE RecordID;
    WORD Count;
    WORD Level;
    LPBYTE Buffer;
    WORD BufferLen;
    WORD EntriesRead;
    WORD TotalEntries;
    BYTE NextRecordID[24];
} XS_I_NET_ACCOUNT_DELTAS, *PXS_I_NET_ACCOUNT_DELTAS;

typedef struct _XS_I_NET_ACCOUNT_SYNC {
    LPSTR ComputerName;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    DWORD Reference;
    WORD Level;
    LPBYTE Buffer;
    WORD BufferLen;
    WORD EntriesRead;
    WORD TotalEntries;
    DWORD NextReference;
    BYTE LastRecordID[24];
} XS_I_NET_ACCOUNT_SYNC, *PXS_I_NET_ACCOUNT_SYNC;

//
// Alerter APIs.
//

typedef struct _XS_NET_ALERT_RAISE {
    LPSTR Event;
    LPBYTE Buffer;
    WORD BufLen;
    DWORD Timeout;
} XS_NET_ALERT_RAISE, *PXS_NET_ALERT_RAISE;

typedef struct _XS_NET_ALERT_START {
    LPSTR Event;
    LPSTR Recipient;
    WORD MaxData;
} XS_NET_ALERT_START, *PXS_NET_ALERT_START;

typedef struct _XS_NET_ALERT_STOP {
    LPSTR Event;
    LPSTR Recipient;
} XS_NET_ALERT_STOP, *PXS_NET_ALERT_STOP;

//
// Auditing APIs.
//

typedef struct _XS_NET_AUDIT_CLEAR {
    LPSTR BackupFile;
    LPSTR Reserved;
} XS_NET_AUDIT_CLEAR, *PXS_NET_AUDIT_CLEAR;

typedef struct _XS_NET_AUDIT_OPEN {
    WORD AuditLog;
    LPSTR Reserved;
} XS_NET_AUDIT_OPEN, *PXS_NET_AUDIT_OPEN;

typedef struct _XS_NET_AUDIT_READ {
    LPSTR Reserved1;
    LPBYTE LogHandleIn;
    BYTE LogHandleOut[16];
    DWORD Offset;
    WORD Reserved2;
    DWORD Reserved3;
    DWORD OffsetFlag;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_AUDIT_READ, *PXS_NET_AUDIT_READ;

//
// Character device APIs.
//

typedef struct _XS_NET_CHAR_DEV_CONTROL {
    LPSTR DevName;
    WORD OpCode;
} XS_NET_CHAR_DEV_CONTROL, *PXS_NET_CHAR_DEV_CONTROL;

typedef struct _XS_NET_CHAR_DEV_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} _XS_NET_CHAR_DEV_ENUM, *PXS_NET_CHAR_DEV_ENUM;

typedef struct _XS_NET_CHAR_DEV_GET_INFO {
    LPSTR DevName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_GET_INFO, *PXS_NET_CHAR_DEV_GET_INFO;

typedef struct _XS_NET_CHAR_DEV_Q_ENUM {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_Q_ENUM, *PXS_NET_CHAR_DEV_Q_ENUM;

typedef struct _XS_NET_CHAR_DEV_Q_GET_INFO {
    LPSTR QueueName;
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_CHAR_DEV_Q_GET_INFO, *PXS_NET_CHAR_DEV_Q_GET_INFO;

typedef struct _XS_NET_CHAR_DEV_Q_PURGE {
    LPSTR QueueName;
} XS_NET_CHAR_DEV_Q_PURGE, *PXS_NET_CHAR_DEV_Q_PURGE;

typedef struct _XS_NET_CHAR_DEV_Q_PURGE_SELF {
    LPSTR QueueName;
    LPSTR ComputerName;
} XS_NET_CHAR_DEV_Q_PURGE_SELF, *PXS_NET_CHAR_DEV_Q_PURGE_SELF;

typedef struct _XS_NET_CHAR_DEV_Q_SET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_CHAR_DEV_Q_SET_INFO, *PXS_NET_CHAR_DEV_Q_SET_INFO;

//
// Configuration APIs.
//

typedef struct _XS_NET_CONFIG_GET_2 {
    LPSTR Reserved;
    LPSTR Component;
    LPSTR Parameter;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Parmlen;
} XS_NET_CONFIG_GET_2, *PXS_NET_CONFIG_GET_2;

typedef struct _XS_NET_CONFIG_GET_ALL_2 {
    LPSTR Reserved;
    LPSTR Component;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_CONFIG_GET_ALL_2, *PXS_NET_CONFIG_GET_ALL_2;


//
// Connection API.
//

typedef struct _XS_NET_CONNECTION_ENUM {
    LPSTR Qualifier;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_CONNECTION_ENUM, *PXS_NET_CONNECTION_ENUM;

//
// Domain APIs.
//

typedef struct _XS_NET_GET_DC_NAME {
    LPSTR Domain;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_GET_DC_NAME, *PXS_NET_GET_DC_NAME;

typedef struct _XS_NET_LOGON_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_LOGON_ENUM, *PXS_NET_LOGON_ENUM;

//
// Error logging APIs.
//

typedef struct _XS_NET_ERROR_LOG_CLEAR {
    LPSTR BackupFile;
    LPSTR Reserved;
} XS_NET_ERROR_LOG_CLEAR, *PXS_NET_ERROR_LOG_CLEAR;

typedef struct _XS_NET_ERROR_LOG_READ {
    LPSTR Reserved1;
//    HLOG * ErrorLog;
    DWORD Offset;
    WORD Reserved2;
    DWORD Reserved3;
    DWORD OffsetFlag;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD TotalAvail;
} XS_NET_ERROR_LOG_READ, *PXS_NET_ERROR_LOG_READ;

typedef struct _XS_NET_ERROR_LOG_WRITE {
    LPSTR Reserved1;
    WORD Code;
    LPSTR Component;
    LPBYTE Buffer;
    WORD BufLen;
    LPSTR StrBuf;
    WORD StrBufLen;
    LPSTR Reserved2;
} XS_NET_ERROR_LOG_WRITE, *PXS_NET_ERROR_LOG_WRITE;

//
// File APIs.
//

typedef struct _XS_NET_FILE_CLOSE_2 {
    DWORD FileId;
} XS_NET_FILE_CLOSE_2, *PXS_NET_FILE_CLOSE_2;

typedef struct _XS_NET_FILE_ENUM_2 {
    LPSTR BasePath;
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD EntriesRemaining;
    LPBYTE ResumeKeyIn;
    BYTE ResumeKeyOut[8];
} XS_NET_FILE_ENUM_2, *PXS_NET_FILE_ENUM_2;

typedef struct _XS_NET_FILE_GET_INFO_2 {
    DWORD FileId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_FILE_GET_INFO_2, *PXS_NET_FILE_GET_INFO_2;

//
// Group APIs.
//

typedef struct _XS_NET_GROUP_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_GROUP_ADD, *PXS_NET_GROUP_ADD;

typedef struct _XS_NET_GROUP_DEL {
    LPSTR GroupName;
} XS_NET_GROUP_DEL, *PXS_NET_GROUP_DEL;

typedef struct _XS_NET_GROUP_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_GROUP_ENUM, *PXS_NET_GROUP_ENUM;

typedef struct _XS_NET_GROUP_ADD_USER {
    LPSTR GroupName;
    LPSTR UserName;
} XS_NET_GROUP_ADD_USER, *PXS_NET_GROUP_ADD_USER;

typedef struct _XS_NET_GROUP_DEL_USER {
    LPSTR GroupName;
    LPSTR UserName;
} XS_NET_GROUP_DEL_USER, *PXS_NET_GROUP_DEL_USER;

typedef struct _XS_NET_GROUP_GET_USERS {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_GROUP_GET_USERS, *PXS_NET_GROUP_GET_USERS;

typedef struct _XS_NET_GROUP_SET_USERS {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Entries;
} XS_NET_GROUP_SET_USERS, *PXS_NET_GROUP_SET_USERS;

typedef struct _XS_NET_GROUP_GET_INFO {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_GROUP_GET_INFO, *PXS_NET_GROUP_GET_INFO;

typedef struct _XS_NET_GROUP_SET_INFO {
    LPSTR GroupName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_GROUP_SET_INFO, *PXS_NET_GROUP_SET_INFO;

//
// Handle APIs.
//

typedef struct _XS_NET_HANDLE_GET_INFO {
    WORD Handle;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_HANDLE_GET_INFO, *PXS_NET_HANDLE_GET_INFO;

typedef struct _XS_NET_HANDLE_SET_INFO {
    WORD Handle;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_HANDLE_SET_INFO, *PXS_NET_HANDLE_SET_INFO;

//
// Mailslot APIs.
//

typedef struct _XS_DOS_MAKE_MAILSLOT {
    LPSTR Name;
    WORD MessageSize;
    WORD MailslotSize;
    WORD Mailslot;
} XS_DOS_MAKE_MAILSLOT, *PXS_DOS_MAKE_MAILSLOT;

typedef struct _XS_DOS_PEEK_MAILSLOT {
    WORD Mailslot;
    LPBYTE Buffer;
    WORD Returned;
    WORD NextSize;
    WORD NextPriority;
} XS_DOS_PEEK_MAILSLOT, *PXS_DOS_PEEK_MAILSLOT;

typedef struct _XS_DOS_DELETE_MAILSLOT {
    WORD Mailslot;
} XS_DOS_DELETE_MAILSLOT, *PXS_DOS_DELETE_MAILSLOT;

typedef struct _XS_DOS_MAILSLOT_INFO {
    WORD Mailslot;
    WORD MessageSize;
    WORD MailslotSize;
    WORD NextSize;
    WORD NextPriority;
    WORD Messages;
} XS_DOS_MAILSLOT_INFO, *PXS_DOS_MAILSLOT_INFO;

typedef struct _XS_DOS_READ_MAILSLOT {
    WORD Mailslot;
    LPBYTE Buffer;
    WORD Returned;
    WORD NextSize;
    WORD NextPriority;
    DWORD Timeout;
} XS_DOS_READ_MAILSLOT, *PXS_DOS_READ_MAILSLOT;

typedef struct _XS_DOS_WRITE_MAILSLOT {
    LPSTR Name;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Priority;
    WORD Class;
    DWORD Timeout;
} XS_DOS_WRITE_MAILSLOT, *PXS_DOS_WRITE_MAILSLOT;

//
// Message APIs.
//

typedef struct _XS_NET_MESSAGE_BUFFER_SEND {
    LPSTR Recipient;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_MESSAGE_BUFFER_SEND, *PXS_NET_MESSAGE_BUFFER_SEND;

typedef struct _XS_NET_MESSAGE_NAME_ADD {
    LPSTR MessageName;
    WORD FwdAction;
} XS_NET_MESSAGE_NAME_ADD, *PXS_NET_MESSAGE_NAME_ADD;

typedef struct _XS_NET_MESSAGE_NAME_DEL {
    LPSTR MessageName;
    WORD FwdAction;
} XS_NET_MESSAGE_NAME_DEL, *PXS_NET_MESSAGE_NAME_DEL;

typedef struct _XS_NET_MESSAGE_NAME_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_MESSAGE_NAME_ENUM, *PXS_NET_MESSAGE_NAME_ENUM;

typedef struct _XS_NET_MESSAGE_NAME_GET_INFO {
    LPSTR MessageName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_MESSAGE_NAME_GET_INFO, *PXS_NET_MESSAGE_NAME_GET_INFO;

//
// NetBIOS APIs.
//

typedef struct _XS_NET_BIOS_OPEN {
    LPSTR DevName;
    LPSTR Reserved;
    WORD OpenOpt;
    WORD DevHandle;
} XS_NET_BIOS_OPEN, *PXS_NET_BIOS_OPEN;

typedef struct _XS_NET_BIOS_CLOSE {
    WORD DevName;
    WORD Reserved;
} XS_NET_BIOS_CLOSE, *PXS_NET_BIOS_CLOSE;

typedef struct _XS_NET_BIOS_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_BIOS_ENUM, *PXS_NET_BIOS_ENUM;

typedef struct _XS_NET_BIOS_GET_INFO {
    LPSTR NetBiosName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_BIOS_GET_INFO, *PXS_NET_BIOS_GET_INFO;

typedef struct _XS_NET_BIOS_SUBMIT {
    WORD DevName;
    WORD NcbOpt;
//    NCB * NCBPointer;
} XS_NET_BIOS_SUBMIT, *PXS_NET_BIOS_SUBMIT;

//
// Path APIs.
//

typedef struct _XS_I_NET_PATH_CANONICALIZE {
    LPSTR PathName;
    LPSTR Outbuf;
    WORD OutbufLen;
    LPSTR Prefix;
    DWORD PathTypeOut;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_CANONICALIZE, *PXS_I_NET_PATH_CANONICALIZE;

typedef struct _XS_I_NET_PATH_COMPARE {
    LPSTR PathName1;
    LPSTR PathName2;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_COMPARE, *PXS_I_NET_PATH_COMPARE;

typedef struct _XS_I_NET_PATH_TYPE {
    LPSTR PathName;
    DWORD PathType;
    DWORD Flags;
} XS_I_NET_PATH_TYPE, *PXS_I_NET_PATH_TYPE;

typedef struct _XS_I_NET_NAME_CANONICALIZE {
    LPSTR Name;
    LPSTR Outbuf;
    DWORD OutbufLen;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_CANONICALIZE, *PXS_I_NET_NAME_CANONICALIZE;

typedef struct _XS_I_NET_NAME_COMPARE {
    LPSTR Name1;
    LPSTR Name2;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_COMPARE, *PXS_I_NET_NAME_COMPARE;

typedef struct _XS_I_NET_NAME_VALIDATE {
    LPSTR Name;
    WORD  NameType;
    DWORD Flags;
} XS_I_NET_NAME_VALIDATE, *PXS_I_NET_NAME_VALIDATE;

//
// Print Destination APIs.
//

typedef struct _XS_DOS_PRINT_DEST_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_DOS_PRINT_DEST_ADD, *PXS_DOS_PRINT_DEST_ADD;

typedef struct _XS_DOS_PRINT_DEST_CONTROL {
    LPSTR DestName;
    WORD Control;
} XS_DOS_PRINT_DEST_CONTROL, *PXS_DOS_PRINT_DEST_CONTROL;

typedef struct _XS_DOS_PRINT_DEST_DEL {
    LPSTR PrinterName;
} XS_DOS_PRINT_DEST_DEL, *PXS_DOS_PRINT_DEST_DEL;

typedef struct _XS_DOS_PRINT_DEST_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_DEST_ENUM, *PXS_DOS_PRINT_DEST_ENUM;

typedef struct _XS_DOS_PRINT_DEST_GET_INFO {
    LPSTR Name;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_DEST_GET_INFO, *PXS_DOS_PRINT_DEST_GET_INFO;

typedef struct _XS_DOS_PRINT_DEST_SET_INFO {
    LPSTR Name;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_DEST_SET_INFO, *PXS_DOS_PRINT_DEST_SET_INFO;

//
// Print job APIs.
//

typedef struct _XS_DOS_PRINT_JOB_CONTINUE {
    WORD JobId;
} XS_DOS_PRINT_JOB_CONTINUE, *PXS_DOS_PRINT_JOB_CONTINUE;

typedef struct _XS_DOS_PRINT_JOB_DEL {
    WORD JobId;
} XS_DOS_PRINT_JOB_DEL, *PXS_DOS_PRINT_JOB_DEL;

typedef struct _XS_DOS_PRINT_JOB_ENUM {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_JOB_ENUM, *PXS_DOS_PRINT_JOB_ENUM;

typedef struct _XS_DOS_PRINT_JOB_GET_ID {
//    HFILE File;
//    PPRIDINFO Info;
    WORD InfoLen;
} XS_DOS_PRINT_JOB_GET_ID, *PXS_DOS_PRINT_JOB_GET_ID;

typedef struct _XS_DOS_PRINT_JOB_GET_INFO {
    WORD JobId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_JOB_GET_INFO, *PXS_DOS_PRINT_JOB_GET_INFO;

typedef struct _XS_DOS_PRINT_JOB_PAUSE {
    WORD JobId;
} XS_DOS_PRINT_JOB_PAUSE, *PXS_DOS_PRINT_JOB_PAUSE;

typedef struct _XS_DOS_PRINT_JOB_SET_INFO {
    WORD JobId;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_JOB_SET_INFO, *PXS_DOS_PRINT_JOB_SET_INFO;

//
// Printer Queue APIs.
//

typedef struct _XS_DOS_PRINT_Q_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_DOS_PRINT_Q_ADD, *PXS_DOS_PRINT_Q_ADD;

typedef struct _XS_DOS_PRINT_Q_CONTINUE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_CONTINUE, *PXS_DOS_PRINT_Q_CONTINUE;

typedef struct _XS_DOS_PRINT_Q_DEL {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_DEL, *PXS_DOS_PRINT_Q_DEL;

typedef struct _XS_DOS_PRINT_Q_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Returned;
    WORD Total;
} XS_DOS_PRINT_Q_ENUM, *PXS_DOS_PRINT_Q_ENUM;

typedef struct _XS_DOS_PRINT_Q_GET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Needed;
} XS_DOS_PRINT_Q_GET_INFO, *PXS_DOS_PRINT_Q_GET_INFO;

typedef struct _XS_DOS_PRINT_Q_PAUSE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_PAUSE, *PXS_DOS_PRINT_Q_PAUSE;

typedef struct _XS_DOS_PRINT_Q_PURGE {
    LPSTR QueueName;
} XS_DOS_PRINT_Q_PURGE, *PXS_DOS_PRINT_Q_PURGE;

typedef struct _XS_DOS_PRINT_Q_SET_INFO {
    LPSTR QueueName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_DOS_PRINT_Q_SET_INFO, *PXS_DOS_PRINT_Q_SET_INFO;

//
// Remote APIs.
//

typedef struct _XS_NET_REMOTE_COPY {
    LPSTR SourcePath;
    LPSTR DestPath;
    LPSTR SourcePasswd;
    LPSTR DestPasswd;
    WORD Open;
    WORD Copy;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_COPY, *PXS_NET_REMOTE_COPY;

typedef struct _XS_NET_REMOTE_EXEC {
    LPSTR Reserved1;
    LPSTR FailName;
    WORD FailNameLen;
    WORD Async;
    LPSTR Args;
    LPSTR Envs;
    LPSTR ReturnCodes;
    LPSTR PgmName;
    LPSTR Reserved2;
    WORD RemoteExec;
} XS_NET_REMOTE_EXEC, *PXS_NET_REMOTE_EXEC;

typedef struct _XS_NET_REMOTE_MOVE {
    LPSTR SourcePath;
    LPSTR DestPath;
    LPSTR SourcePasswd;
    LPSTR DestPasswd;
    WORD Open;
    WORD Move;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_MOVE, *PXS_NET_REMOTE_MOVE;

typedef struct _XS_NET_REMOTE_TOD {
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_REMOTE_TOD, *PXS_NET_REMOTE_TOD;

//
// Server APIs.
//

typedef struct _XS_NET_SERVER_AUTHENTICATE {
    LPSTR Requestor;
    LPBYTE Caller;
    BYTE Primary[8];
} XS_NET_SERVER_AUTHENTICATE, *PXS_NET_SERVER_AUTHENTICATE;

typedef struct _XS_NET_SERVER_DISK_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SERVER_DISK_ENUM, *PXS_NET_SERVER_DISK_ENUM;

typedef struct _XS_NET_SERVER_ENUM_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
    DWORD ServerType;
    LPSTR Domain;
} XS_NET_SERVER_ENUM_2, *PXS_NET_SERVER_ENUM_2;

typedef struct _XS_NET_SERVER_ENUM_3 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
    DWORD ServerType;
    LPSTR Domain;
    LPSTR FirstNameToReturn;
} XS_NET_SERVER_ENUM_3, *PXS_NET_SERVER_ENUM_3;

typedef struct _XS_NET_SERVER_GET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SERVER_GET_INFO, *PXS_NET_SERVER_GET_INFO;

typedef struct _XS_NET_SERVER_PASSWORD_SET {
    LPSTR Requestor;
    LPBYTE Authenticator;
    BYTE RetAuth[12];
    LPBYTE Password;
} XS_NET_SERVER_PASSWORD_SET, *PXS_NET_SERVER_PASSWORD_SET;

typedef struct _XS_NET_SERVER_REQ_CHALLENGE {
    LPSTR Requestor;
    LPBYTE Caller;
    BYTE Primary[8];
} XS_NET_SERVER_REQ_CHALLENGE, *PXS_NET_SERVER_REQ_CHALLENGE;

typedef struct _XS_NET_SERVER_SET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_SERVER_SET_INFO, *PXS_NET_SERVER_SET_INFO;

//
// Service APIs.
//

typedef struct _XS_NET_SERVICE_CONTROL {
    LPSTR Service;
    WORD OpCode;
    WORD Arg;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_SERVICE_CONTROL, *PXS_NET_SERVICE_CONTROL;

typedef struct _XS_NET_SERVICE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SERVICE_ENUM, *PXS_NET_SERVICE_ENUM;

typedef struct _XS_NET_SERVICE_GET_INFO {
    LPSTR Service;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SERVICE_GET_INFO, *PXS_NET_SERVICE_GET_INFO;

typedef struct _XS_NET_SERVICE_INSTALL {
    LPSTR Service;
    LPBYTE FillSpace;
    LPBYTE RcvBuffer;
    BYTE RetBuffer[88];
} XS_NET_SERVICE_INSTALL, *PXS_NET_SERVICE_INSTALL;

//
// Session APIs.
//

typedef struct _XS_NET_SESSION_DEL {
    LPSTR ClientName;
    WORD Reserved;
} XS_NET_SESSION_DEL, *PXS_NET_SESSION_DEL;

typedef struct _XS_NET_SESSION_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SESSION_ENUM, *PXS_NET_SESSION_ENUM;

typedef struct _XS_NET_SESSION_GET_INFO {
    LPSTR ClientName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SESSION_GET_INFO, *PXS_NET_SESSION_GET_INFO;

//
// Share APIs.
//

typedef struct _XS_NET_SHARE_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_SHARE_ADD, *PXS_NET_SHARE_ADD;

typedef struct _XS_NET_SHARE_CHECK {
    LPSTR DeviceName;
    WORD Type;
} XS_NET_SHARE_CHECK, *PXS_NET_SHARE_CHECK;

typedef struct _XS_NET_SHARE_DEL {
    LPSTR NetName;
    WORD Reserved;
} XS_NET_SHARE_DEL, *PXS_NET_SHARE_DEL;

typedef struct _XS_NET_SHARE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_SHARE_ENUM, *PXS_NET_SHARE_ENUM;

typedef struct _XS_NET_SHARE_GET_INFO {
    LPSTR NetName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_SHARE_GET_INFO, *PXS_NET_SHARE_GET_INFO;

typedef struct _XS_NET_SHARE_SET_INFO {
    LPSTR NetName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_SHARE_SET_INFO, *PXS_NET_SHARE_SET_INFO;

//
// Statistics APIs.
//

typedef struct _XS_NET_STATISTICS_GET_2 {
    LPSTR Service;
    DWORD Reserved;
    WORD Level;
    DWORD Options;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_STATISTICS_GET_2, *PXS_NET_STATISTICS_GET_2;

//
// Use APIs.
//

typedef struct _XS_NET_USE_ADD {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
} XS_NET_USE_ADD, *PXS_NET_USE_ADD;

typedef struct _XS_NET_USE_DEL {
    LPSTR UseName;
    WORD Force;
} XS_NET_USE_DEL, *PXS_NET_USE_DEL;

typedef struct _XS_NET_USE_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USE_ENUM, *PXS_NET_USE_ENUM;

typedef struct _XS_NET_USE_GET_INFO {
    LPSTR UseName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USE_GET_INFO, *PXS_NET_USE_GET_INFO;

//
// User APIs.
//

typedef struct _XS_NET_USER_ADD_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_ADD_2, *PXS_NET_USER_ADD_2;

typedef struct _XS_NET_USER_DEL {
    LPSTR UserName;
} XS_NET_USER_DEL, *PXS_NET_USER_DEL;

typedef struct _XS_NET_USER_ENUM {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_ENUM, *PXS_NET_USER_ENUM;

typedef struct _XS_NET_USER_ENUM_2 {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    DWORD ResumeIn;
    DWORD ResumeOut;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_ENUM_2, *PXS_NET_USER_ENUM_2;

typedef struct _XS_NET_USER_GET_INFO {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USER_GET_INFO, *PXS_NET_USER_GET_INFO;

typedef struct _XS_NET_USER_SET_INFO {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
    WORD DataEncryption;
} XS_NET_USER_SET_INFO, *PXS_NET_USER_SET_INFO;

typedef struct _XS_NET_USER_SET_INFO_2 {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_SET_INFO_2, *PXS_NET_USER_SET_INFO_2;

typedef struct _XS_NET_USER_PASSWORD_SET_2 {
    LPSTR UserName;
    LPSTR OldPassword;
    LPSTR NewPassword;
    WORD DataEncryption;
    WORD PasswordLength;
} XS_NET_USER_PASSWORD_SET_2, *PXS_NET_USER_PASSWORD_SET_2;

typedef struct _XS_SAMOEMCHGPASSWORDUSER2_P {
    LPSTR  UserName;
    LPBYTE Buffer;
    WORD   BufLen;
} XS_SAMOEMCHGPASSWORDUSER2_P, *PXS_SAMOEMCHGPASSWORDUSER2_P;


typedef struct _XS_NET_USER_GET_GROUPS {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD EntriesRead;
    WORD TotalAvail;
} XS_NET_USER_GET_GROUPS, *PXS_NET_USER_GET_GROUPS;

typedef struct _XS_NET_USER_SET_GROUPS {
    LPSTR UserName;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Entries;
} XS_NET_USER_SET_GROUPS, *PXS_NET_USER_SET_GROUPS;

typedef struct _XS_NET_USER_MODALS_GET {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_USER_MODALS_GET, *PXS_NET_USER_MODALS_GET;

typedef struct _XS_NET_USER_MODALS_SET {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_USER_MODALS_SET, *PXS_NET_USER_MODALS_SET;

typedef struct _XS_NET_USER_VALIDATE {
    LPSTR Reserved;
    LPSTR UserName;
    LPSTR Password;
    WORD Privilege;
} XS_NET_USER_VALIDATE, *PXS_NET_USER_VALIDATE;

typedef struct _XS_NET_USER_VALIDATE_2 {
    LPSTR Reserved1;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD Reserved2;
    WORD TotalAvail;
} XS_NET_USER_VALIDATE_2, *PXS_NET_USER_VALIDATE_2;

//
// Workstation APIs.
//

typedef struct _XS_NET_WKSTA_GET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_GET_INFO, *PXS_NET_WKSTA_GET_INFO;

typedef struct _XS_NET_WKSTA_SET_INFO {
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD ParmNum;
} XS_NET_WKSTA_SET_INFO, *PXS_NET_WKSTA_SET_INFO;

typedef struct _XS_NET_WKSTA_SET_UID {
    LPSTR UserName;
    LPSTR Password;
    LPSTR Parms;
    WORD LogOff;
} XS_NET_WKSTA_SET_UID, *PXS_NET_WKSTA_SET_UID;

typedef struct _XS_NET_WKSTA_SET_UID_2 {
    LPSTR Reserved;
    LPSTR Domain;
    LPSTR UserName;
    LPSTR Password;
    LPSTR Parms;
    WORD LogoffForce;
    WORD Level;
    LPBYTE Buffer;
    WORD BufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_SET_UID_2, *PXS_NET_WKSTA_SET_UID_2;

typedef struct _XS_NET_WKSTA_USER_LOGON {
    LPSTR Reserved1;
    LPSTR Reserved2;
    WORD Level;
    LPBYTE InBuf;
    WORD InBufLen;
    LPBYTE OutBuf;
    WORD OutBufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_USER_LOGON, *PXS_NET_WKSTA_USER_LOGON;

typedef struct _XS_NET_WKSTA_USER_LOGOFF {
    LPSTR Reserved1;
    LPSTR Reserved2;
    WORD Level;
    LPBYTE InBuf;
    WORD InBufLen;
    LPBYTE OutBuf;
    WORD OutBufLen;
    WORD TotalAvail;
} XS_NET_WKSTA_USER_LOGOFF, *PXS_NET_WKSTA_USER_LOGOFF;

#include <packoff.h>

#endif  // ndef _APIPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\apinums.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1987-1991             **/
/********************************************************************/

#define API_WShareEnum          0
#define API_WShareGetInfo          1
#define API_WShareSetInfo          2
#define API_WShareAdd          3
#define API_WShareDel          4
#define API_NetShareCheck          5
#define API_WSessionEnum          6
#define API_WSessionGetInfo          7
#define API_WSessionDel          8
#define API_WConnectionEnum          9
#define API_WFileEnum          10
#define API_WFileGetInfo          11
#define API_WFileClose          12
#define API_WServerGetInfo          13
#define API_WServerSetInfo          14
#define API_WServerDiskEnum          15
#define API_WServerAdminCommand          16
#define API_NetAuditOpen          17
#define API_WAuditClear          18
#define API_NetErrorLogOpen          19
#define API_WErrorLogClear          20
#define API_NetCharDevEnum          21
#define API_NetCharDevGetInfo          22
#define API_WCharDevControl          23
#define API_NetCharDevQEnum          24
#define API_NetCharDevQGetInfo          25
#define API_WCharDevQSetInfo          26
#define API_WCharDevQPurge          27
#define API_WCharDevQPurgeSelf          28
#define API_WMessageNameEnum          29
#define API_WMessageNameGetInfo          30
#define API_WMessageNameAdd          31
#define API_WMessageNameDel          32
#define API_WMessageNameFwd          33
#define API_WMessageNameUnFwd          34
#define API_WMessageBufferSend          35
#define API_WMessageFileSend          36
#define API_WMessageLogFileSet          37
#define API_WMessageLogFileGet          38
#define API_WServiceEnum          39
#define API_WServiceInstall          40
#define API_WServiceControl          41
#define API_WAccessEnum          42
#define API_WAccessGetInfo          43
#define API_WAccessSetInfo          44
#define API_WAccessAdd          45
#define API_WAccessDel          46
#define API_WGroupEnum          47
#define API_WGroupAdd          48
#define API_WGroupDel          49
#define API_WGroupAddUser          50
#define API_WGroupDelUser          51
#define API_WGroupGetUsers          52
#define API_WUserEnum          53
#define API_WUserAdd          54
#define API_WUserDel          55
#define API_WUserGetInfo          56
#define API_WUserSetInfo          57
#define API_WUserPasswordSet          58
#define API_WUserGetGroups          59
#define API_DeadTableEntry          60
/* This line and number replaced a Dead Entry */
#define API_WWkstaSetUID          62
#define API_WWkstaGetInfo          63
#define API_WWkstaSetInfo          64
#define API_WUseEnum          65
#define API_WUseAdd          66
#define API_WUseDel          67
#define API_WUseGetInfo          68
#define API_WPrintQEnum          69
#define API_WPrintQGetInfo          70
#define API_WPrintQSetInfo          71
#define API_WPrintQAdd          72
#define API_WPrintQDel          73
#define API_WPrintQPause          74
#define API_WPrintQContinue          75
#define API_WPrintJobEnum          76
#define API_WPrintJobGetInfo          77
#define API_WPrintJobSetInfo_OLD          78
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintJobDel          81
#define API_WPrintJobPause          82
#define API_WPrintJobContinue          83
#define API_WPrintDestEnum          84
#define API_WPrintDestGetInfo          85
#define API_WPrintDestControl          86
#define API_WProfileSave          87
#define API_WProfileLoad          88
#define API_WStatisticsGet          89
#define API_WStatisticsClear          90
#define API_NetRemoteTOD          91
#define API_WNetBiosEnum          92
#define API_WNetBiosGetInfo          93
#define API_NetServerEnum          94
#define API_I_NetServerEnum          95
#define API_WServiceGetInfo          96
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintQPurge          103
#define API_NetServerEnum2          104
#define API_WAccessGetUserPerms          105
#define API_WGroupGetInfo          106
#define API_WGroupSetInfo          107
#define API_WGroupSetUsers          108
#define API_WUserSetGroups          109
#define API_WUserModalsGet          110
#define API_WUserModalsSet          111
#define API_WFileEnum2          112
#define API_WUserAdd2          113
#define API_WUserSetInfo2          114
#define API_WUserPasswordSet2          115
#define API_I_NetServerEnum2          116
#define API_WConfigGet2          117
#define API_WConfigGetAll2          118
#define API_WGetDCName          119
#define API_NetHandleGetInfo          120
#define API_NetHandleSetInfo          121
#define API_WStatisticsGet2          122
#define API_WBuildGetInfo          123
#define API_WFileGetInfo2          124
#define API_WFileClose2          125
#define API_WNetServerReqChallenge          126
#define API_WNetServerAuthenticate          127
#define API_WNetServerPasswordSet          128
#define API_WNetAccountDeltas          129
#define API_WNetAccountSync          130
#define API_WUserEnum2          131
#define API_WWkstaUserLogon          132
#define API_WWkstaUserLogoff          133
#define API_WLogonEnum          134
#define API_WErrorLogRead          135
#define API_WI_NetPathType          136
#define API_WI_NetPathCanonicalize          137
#define API_WI_NetPathCompare          138
#define API_WI_NetNameValidate          139
#define API_WI_NetNameCanonicalize          140
#define API_WI_NetNameCompare          141
#define API_WAuditRead          142
#define API_WPrintDestAdd          143
#define API_WPrintDestSetInfo          144
#define API_WPrintDestDel          145
#define API_WUserValidate2          146
#define API_WPrintJobSetInfo          147
#define API_TI_NetServerDiskEnum          148
#define API_TI_NetServerDiskGetInfo          149
#define API_TI_FTVerifyMirror          150
#define API_TI_FTAbortVerify          151
#define API_TI_FTGetInfo          152
#define API_TI_FTSetInfo          153
#define API_TI_FTLockDisk          154
#define API_TI_FTFixError          155
#define API_TI_FTAbortFix          156
#define API_TI_FTDiagnoseError          157
#define API_TI_FTGetDriveStats          158
/* This line and number replaced a Dead Entry */
#define API_TI_FTErrorGetInfo          160
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_NetAccessCheck          163
#define API_NetAlertRaise          164
#define API_NetAlertStart          165
#define API_NetAlertStop          166
#define API_NetAuditWrite          167
#define API_NetIRemoteAPI          168
#define API_NetServiceStatus          169
#define API_I_NetServerRegister          170
#define API_I_NetServerDeregister          171
#define API_I_NetSessionEntryMake          172
#define API_I_NetSessionEntryClear          173
#define API_I_NetSessionEntryGetInfo          174
#define API_I_NetSessionEntrySetInfo          175
#define API_I_NetConnectionEntryMake          176
#define API_I_NetConnectionEntryClear          177
#define API_I_NetConnectionEntrySetInfo          178
#define API_I_NetConnectionEntryGetInfo          179
#define API_I_NetFileEntryMake          180
#define API_I_NetFileEntryClear          181
#define API_I_NetFileEntrySetInfo          182
#define API_I_NetFileEntryGetInfo          183
#define API_AltSrvMessageBufferSend          184
#define API_AltSrvMessageFileSend          185
#define API_wI_NetRplWkstaEnum          186
#define API_wI_NetRplWkstaGetInfo          187
#define API_wI_NetRplWkstaSetInfo          188
#define API_wI_NetRplWkstaAdd          189
#define API_wI_NetRplWkstaDel          190
#define API_wI_NetRplProfileEnum          191
#define API_wI_NetRplProfileGetInfo          192
#define API_wI_NetRplProfileSetInfo          193
#define API_wI_NetRplProfileAdd          194
#define API_wI_NetRplProfileDel          195
#define API_wI_NetRplProfileClone          196
#define API_wI_NetRplBaseProfileEnum          197
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WIServerSetInfo          201
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
/* This line and number replaced a Dead Entry */
#define API_WPrintDriverEnum          205
#define API_WPrintQProcessorEnum          206
#define API_WPrintPortEnum          207
#define API_WNetWriteUpdateLog          208
#define API_WNetAccountUpdate          209
#define API_WNetAccountConfirmUpdate          210
#define API_WConfigSet          211
#define API_WAccountsReplicate          212
/*   213 is used by WfW  */
#define API_SamOEMChgPasswordUser2_P    214
#define API_NetServerEnum3              215
#define MAX_API         215
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\dhcpcapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpcapi.h

Abstract:

    This file contains function proto types for the DHCP CONFIG API
    functions.

Author:

    Madan Appiah (madana)  Dec-22-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _DHCPCAPI_
#define _DHCPCAPI_

#include <time.h>


HANDLE
APIENTRY
DhcpOpenGlobalEvent(
    VOID
    );

typedef enum _SERVICE_ENABLE {
    IgnoreFlag,
    DhcpEnable,
    DhcpDisable
} SERVICE_ENABLE, *LPSERVICE_ENABLE;

DWORD
APIENTRY
DhcpAcquireParameters(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpFallbackRefreshParams(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpReleaseParameters(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpEnableDynamicConfig(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpDisableDynamicConfig(
    LPWSTR AdapterName
    );

DWORD
APIENTRY
DhcpNotifyConfigChange(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled
    );

#define NOTIFY_FLG_DO_DNS           0x01
#define NOTIFY_FLG_RESET_IPADDR     0x02

DWORD
APIENTRY
DhcpNotifyConfigChangeEx(
    IN LPWSTR ServerName,
    IN LPWSTR AdapterName,
    IN BOOL IsNewIpAddress,
    IN DWORD IpIndex,
    IN DWORD IpAddress,
    IN DWORD SubnetMask,
    IN SERVICE_ENABLE DhcpServiceEnabled,
    IN ULONG Flags
);

//
// IP address lease apis for RAS .
//



typedef struct _DHCP_CLIENT_UID {
    LPBYTE ClientUID;
    DWORD ClientUIDLength;
} DHCP_CLIENT_UID, *LPDHCP_CLIENT_UID;

typedef struct _DHCP_LEASE_INFO {
    DHCP_CLIENT_UID ClientUID;
    DWORD IpAddress;
    DWORD SubnetMask;
    DWORD DhcpServerAddress;
    DWORD Lease;
    time_t LeaseObtained;
    time_t T1Time;
    time_t T2Time;
    time_t LeaseExpires;
} DHCP_LEASE_INFO, *LPDHCP_LEASE_INFO;

typedef struct _DHCP_OPTION_DATA {
    DWORD OptionID;
    DWORD OptionLen;
    LPBYTE Option;
} DHCP_OPTION_DATA, *LPDHCP_OPTION_DATA;

typedef struct _DHCP_OPTION_INFO {
    DWORD NumOptions;
    LPDHCP_OPTION_DATA OptionDataArray;
} DHCP_OPTION_INFO, *LPDHCP_OPTION_INFO;


typedef struct _DHCP_OPTION_LIST {
    DWORD NumOptions;
    LPWORD OptionIDArray;
} DHCP_OPTION_LIST, *LPDHCP_OPTION_LIST;

DWORD
DhcpLeaseIpAddress(
    DWORD AdapterIpAddress,
    LPDHCP_CLIENT_UID ClientUID,
    DWORD DesiredIpAddress,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_LEASE_INFO *LeaseInfo,
    LPDHCP_OPTION_INFO *OptionInfo
    );

DWORD
DhcpRenewIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo
    );

DWORD
DhcpReleaseIpAddressLease(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo
    );


//DOC
//DOC The following are the APIs needed for dhcp-class id UI.
//DOC

enum        /* anonymous */ {
    DHCP_CLASS_INFO_VERSION_0                     // first cut structure version
};

typedef     struct                 _DHCP_CLASS_INFO {
    DWORD                          Version;       // MUST BE DHCP_CLASS_INFO_VERSION_0
    LPWSTR                         ClassName;     // Name of the Class.
    LPWSTR                         ClassDescr;    // Description about the class
    LPBYTE                         ClassData;     // byte stream on the wire data.
    DWORD                          ClassDataLen;  // # of bytes in the ClassData (must be > 0)
} DHCP_CLASS_INFO, *PDHCP_CLASS_INFO, *LPDHCP_CLASS_INFO;

typedef
DWORD
(WINAPI *LPDHCPENUMCLASSES)(
    IN DWORD Flags,
    IN LPWSTR AdapterName,
    IN OUT DWORD *Size,
    IN OUT DHCP_CLASS_INFO *ClassesArray
);

//DOC DhcpEnumClasses enumerates the list of classes available on the system for configuration.
//DOC This is predominantly going to be used by the NetUI. (in which case the ClassData part of the
//DOC DHCP_CLASS_INFO structure is essentially useless).
//DOC Note that Flags is used for future use.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either ALL adapters.
//DOC The Size parameter is an input/output parameter. The input value is the # of bytes of allocated
//DOC space in the ClassesArray buffer.  On return, the meaning of this value depends on the return value.
//DOC If the function returns ERROR_SUCCESS, then, this parameter would return the # of elements in the
//DOC array ClassesArray.  If the function returns ERROR_MORE_DATA, then, this parameter refers to the
//DOC # of bytes space that is actually REQUIRED to hold the information.
//DOC In all other cases, the values in Size and ClassesArray dont mean anything.
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_MORE_DATA
//DOC ERROR_FILE_NOT_FOUND         The DHCP Client is not running and could not be started up.
//DOC ERROR_NOT_ENOUGH_MEMORY      This is NOT the same as ERROR_MORE_DATA
//DOC Win32 errors
//DOC
//DOC Remarks:
//DOC To notify DHCP that some class has changed, please use the DhcpHandlePnPEvent API.
DWORD
WINAPI
DhcpEnumClasses(                                  // enumerate the list of classes available
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AdapterName,   // currently must be AdapterGUID (cannot be NULL yet)
    IN OUT  DWORD                 *Size,          // input # of bytes available in BUFFER, output # of elements in array
    IN OUT  DHCP_CLASS_INFO       *ClassesArray   // pre-allocated buffer
);


enum        /* anonymous */ {                     // who are the recognized callers of this API
    DHCP_CALLER_OTHER  =  0,                      // un-specified user, not one of below
    DHCP_CALLER_TCPUI,                            // the TcpIp UI
    DHCP_CALLER_RAS,                              // the RAS Api
    DHCP_CALLER_API,                              // some one else via DHCP API
};

enum        /* anonymous */ {                     // supported structure versions..
    DHCP_PNP_CHANGE_VERSION_0  = 0                // first cut version structure
};

typedef     struct                 _DHCP_PNP_CHANGE {
    DWORD                          Version;       // MUST BE DHCP_PNP_CHANGE_VERSION_0
    BOOL                           DnsListChanged;// DNS Server list changed
    BOOL                           DomainChanged; // Domain Name changed
    BOOL                           HostNameChanged;  // the DNS Host name changed..
    BOOL                           ClassIdChanged;// ClassId changed
    BOOL                           MaskChanged;   // SubnetMask changed; CURRENTLY NOT USED
    BOOL                           GateWayChanged;// DefaultGateWay changed; CURRENTLY NOT USED
    BOOL                           RouteChanged;  // some STATIC route changed; CURRENTLY NOT USED
    BOOL                           OptsChanged;   // some options changed. CURRENTLY NOT USED
    BOOL                           OptDefsChanged;// some option definitions changed. CURRENTLY NOT USED
    BOOL                           DnsOptionsChanged; // some DNS specific options have changed.
} DHCP_PNP_CHANGE, *PDHCP_PNP_CHANGE, *LPDHCP_PNP_CHANGE;

typedef                                           // this typedef SHOULD match the following declaration.
DWORD
(WINAPI FAR *LPDHCPHANDLEPNPEVENT)(
    IN      DWORD                  Flags,
    IN      DWORD                  Caller,
    IN      LPWSTR                 AdapterName,
    IN      LPDHCP_PNP_CHANGE      Changes,
    IN      LPVOID                 Reserved
);

//DOC DhcpHandlePnpEvent can be called as an API by any process (excepting that executing within the
//DOC DHCP process itself) when any of the registry based configuration has changed and DHCP client has to
//DOC re-read the registry.  The Flags parameter is for future expansion.
//DOC The AdapterName can currently be only GUIDs but may soon be EXTENDED to be IpAddress strings or
//DOC h-w addresses or any other user friendly means of denoting the Adapter.  Note that if the Adapter
//DOC Name is NULL (not the empty string L""), then it refers to either GLOBAL parameters or ALL adapters
//DOC depending on which BOOL has been set. (this may not get done for BETA2).
//DOC The Changes structure gives the information on what changed.
//DOC Currently, only a few of the defined BOOLs would be supported (for BETA2 NT5).
//DOC
//DOC Return Values:
//DOC ERROR_DEVICE_DOES_NOT_EXIST  The AdapterName is illegal in the given context
//DOC ERROR_INVALID_PARAMETER
//DOC ERROR_CALL_NOT_SUPPORTED     The particular parameter that has changed is not completely pnp yet.
//DOC Win32 errors
DWORD
WINAPI
DhcpHandlePnPEvent(
    IN      DWORD                  Flags,         // MUST BE ZERO
    IN      DWORD                  Caller,        // currently must be DHCP_CALLER_TCPUI
    IN      LPWSTR                 AdapterName,   // currently must be the adapter GUID or NULL if global
    IN      LPDHCP_PNP_CHANGE      Changes,       // specify what changed
    IN      LPVOID                 Reserved       // reserved for future use..
);
//================================================================================
// end of file
//================================================================================
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\apiworke.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/*++

Revision History:

    16-Jan-1992 JohnRo
        The redirector always expects UNICODE for the transact parm name.

--*/

#ifndef _APIWORKE_
#define _APIWORKE_

/*
 * apiworke.h - General defines used by the API worker.
 */

#define REM_MAX_PARMS           360
#define BUF_INC                 200


#define REM_NO_SRV_RESOURCE     55
#define REM_NO_ADMIN_RIGHTS     44

#define REM_API_TIMEOUT         5000            /* 5 second timeout */

/* The REM_API_TXT is the text string that is copied into the parmater
 * packet of the redirector transaction IOCTl following "\\SERVERNAME".
 * The additional \0 is so that the password field is terminated.
 * APIEXTR is the length of this field.
 */
#define REM_APITXT      L"\\PIPE\\LANMAN\0"
#define APIEXTR         (sizeof(REM_APITXT))

/* The pointer identifiers in the descriptor stings are all lower case so
 * thet a quick check can be made for a pointer type. The IS_POINTER macro
 * just checks for > 'Z' for maximum speed.
 */

#define IS_POINTER(x)           ((x) > 'Z')


#define RANGE_F(x,y,z)          (((unsigned long)x >= (unsigned long)y) && \
                                 ((unsigned long)x < ((unsigned long)y + z)))

#endif // ndef _APIWORKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\dhcpapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dhcpapi.h

Abstract:

    This file contains the DHCP APIs proto-type and description. Also
    contains the data structures used by the DHCP APIs.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

    Cheng Yang (t-cheny)  18-Jun-1996  superscope

--*/

#ifndef _DHCPAPI_
#define _DHCPAPI_

#if defined(MIDL_PASS)
#define LPWSTR [string] wchar_t *
#endif

//
// DHCP data structures.
//

#ifndef _DHCP_

//
// the follwing typedef's are defined in dhcp.h also.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH    0
#define DHCP_DATE_TIME_ZERO_LOW     0

#define DHCP_DATE_TIME_INFINIT_HIGH 0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW  0xFFFFFFFF
#endif

#ifndef DHCP_ENCODE_SEED
#define  DHCP_ENCODE_SEED ((UCHAR)0xA5)
#endif

#ifdef __cplusplus
#define DHCP_CONST   const
#else
#define DHCP_CONST
#endif // __cplusplus

#if (_MSC_VER >= 800)
#define DHCP_API_FUNCTION    __stdcall
#else
#define DHCP_API_FUNCTION
#endif

//
// RPC security.
//

#define DHCP_SERVER_SECURITY            L"DhcpServerApp"
#define DHCP_SERVER_SECURITY_AUTH_ID    10
#define DHCP_NAMED_PIPE                 L"\\PIPE\\DHCPSERVER"
#define DHCP_SERVER_BIND_PORT           L""
#define DHCP_LPC_EP                     L"DHCPSERVERLPC"

#define DHCP_SERVER_USE_RPC_OVER_TCPIP  0x1
#define DHCP_SERVER_USE_RPC_OVER_NP     0x2
#define DHCP_SERVER_USE_RPC_OVER_LPC    0x4

#define DHCP_SERVER_USE_RPC_OVER_ALL (\
            DHCP_SERVER_USE_RPC_OVER_TCPIP | \
            DHCP_SERVER_USE_RPC_OVER_NP    | \
            DHCP_SERVER_USE_RPC_OVER_LPC)

#ifndef HARDWARE_TYPE_10MB_EITHERNET
#define HARDWARE_TYPE_10MB_EITHERNET     (1)
#endif


#define DHCP_RAS_CLASS_TXT    "RRAS.Microsoft"
#define DHCP_BOOTP_CLASS_TXT  "BOOTP.Microsoft"
#define DHCP_MSFT50_CLASS_TXT "MSFT 5.0"
#define DHCP_MSFT98_CLASS_TXT "MSFT 98"            
#define DHCP_MSFT_CLASS_TXT   "MSFT"


typedef DWORD DHCP_IP_MASK;
typedef DWORD DHCP_RESUME_HANDLE;

typedef struct _DHCP_IP_RANGE {
    DHCP_IP_ADDRESS StartAddress;
    DHCP_IP_ADDRESS EndAddress;
} DHCP_IP_RANGE, *LPDHCP_IP_RANGE;

typedef struct _DHCP_BINARY_DATA {
    DWORD DataLength;

#if defined(MIDL_PASS)
    [size_is(DataLength)]
#endif // MIDL_PASS
        BYTE *Data;

} DHCP_BINARY_DATA, *LPDHCP_BINARY_DATA;

typedef DHCP_BINARY_DATA DHCP_CLIENT_UID;

typedef struct _DHCP_HOST_INFO {
    DHCP_IP_ADDRESS IpAddress;      // minimum information always available
    LPWSTR NetBiosName;             // optional information
    LPWSTR HostName;                // optional information
} DHCP_HOST_INFO, *LPDHCP_HOST_INFO;

//
// Flag type that is used to delete DHCP objects.
//

typedef enum _DHCP_FORCE_FLAG {
    DhcpFullForce,
    DhcpNoForce
} DHCP_FORCE_FLAG, *LPDHCP_FORCE_FLAG;

//
// DWORD_DWORD - subtitute for LARGE_INTEGER
//

typedef struct _DWORD_DWORD {
    DWORD DWord1;
    DWORD DWord2;
} DWORD_DWORD, *LPDWORD_DWORD;

//
// Subnet State.
//
// Currently a Subnet scope can be Enabled or Disabled.
//
// If the state is Enabled State,
//  The server distributes address to the client, extends leases and
//  accepts releases.
//
// If the state is Disabled State,
//  The server does not distribute address to any new client, and does
//  extent (and sends NACK) old leases, but the servers accepts lease
//  releases.
//
// The idea behind this subnet state is, when the admin wants to stop
//  serving a subnet, he moves the state from Enbaled to Disabled so
//  that the clients from the subnets smoothly move to another servers
//  serving that subnet. When all or most of the clients move to
//  another server, the admin can delete the subnet without any force
//  if no client left in that subnet, otherwise the admin should use
//  full force to delete the subnet.
//

typedef enum _DHCP_SUBNET_STATE {
    DhcpSubnetEnabled = 0,
    DhcpSubnetDisabled,
    DhcpSubnetEnabledSwitched,    
    DhcpSubnetDisabledSwitched,
    DhcpSubnetInvalidState
} DHCP_SUBNET_STATE, *LPDHCP_SUBNET_STATE;

//
// Subnet related data structures.
//

typedef struct _DHCP_SUBNET_INFO {
    DHCP_IP_ADDRESS  SubnetAddress;
    DHCP_IP_MASK SubnetMask;
    LPWSTR SubnetName;
    LPWSTR SubnetComment;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE SubnetState;
} DHCP_SUBNET_INFO, *LPDHCP_SUBNET_INFO;

typedef struct _DHCP_IP_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_IP_ADDRESS Elements; //array
} DHCP_IP_ARRAY, *LPDHCP_IP_ARRAY;

typedef struct _DHCP_IP_CLUSTER {
    DHCP_IP_ADDRESS ClusterAddress; // First IP address of the cluster.
    DWORD ClusterMask;              // Cluster usage mask, 0xFFFFFFFF
                                    //  indicates the cluster is fully used.
} DHCP_IP_CLUSTER, *LPDHCP_IP_CLUSTER;

typedef struct _DHCP_IP_RESERVATION {
    DHCP_IP_ADDRESS ReservedIpAddress;
    DHCP_CLIENT_UID *ReservedForClient;
} DHCP_IP_RESERVATION, *LPDHCP_IP_RESERVATION;

typedef enum _DHCP_SUBNET_ELEMENT_TYPE_V5 {
    //
    // If you don't care about what you wan't to  get..
    // NB: These six lines should not be changed!
    //
    DhcpIpRanges,
    DhcpSecondaryHosts,
    DhcpReservedIps,
    DhcpExcludedIpRanges,
    DhcpIpUsedClusters,                     // read only

    //
    //  These are for IP ranges for DHCP ONLY
    //

    DhcpIpRangesDhcpOnly,

    //
    //  These are ranges that are BOTH DHCP & Dynamic BOOTP
    //

    DhcpIpRangesDhcpBootp,

    //
    //  These are ranges that are ONLY BOOTP
    //

    DhcpIpRangesBootpOnly,
} DHCP_SUBNET_ELEMENT_TYPE, *LPDHCP_SUBNET_ELEMENT_TYPE;

#define ELEMENT_MASK(E) ((((E) <= DhcpIpRangesBootpOnly) && (DhcpIpRangesDhcpOnly <= (E)))?(0):(E))

typedef struct _DHCP_SUBNET_ELEMENT_DATA {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION {
        [case(DhcpIpRanges)] DHCP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION {
        DHCP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA, *LPDHCP_SUBNET_ELEMENT_DATA;

#if !defined(MIDL_PASS)
typedef union _DHCP_SUBNET_ELEMENT_UNION
    DHCP_SUBNET_ELEMENT_UNION, *LPDHCP_SUBNET_ELEMENT_UNION;
#endif

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_SUBNET_ELEMENT_DATA Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY;

//
// DHCP Options related data structures.
//

typedef enum _DHCP_OPTION_DATA_TYPE {
    DhcpByteOption,
    DhcpWordOption,
    DhcpDWordOption,
    DhcpDWordDWordOption,
    DhcpIpAddressOption,
    DhcpStringDataOption,
    DhcpBinaryDataOption,
    DhcpEncapsulatedDataOption
} DHCP_OPTION_DATA_TYPE, *LPDHCP_OPTION_DATA_TYPE;


typedef struct _DHCP_OPTION_DATA_ELEMENT {
    DHCP_OPTION_DATA_TYPE    OptionType;
#if defined(MIDL_PASS)
    [switch_is(OptionType), switch_type(DHCP_OPTION_DATA_TYPE)]
    union _DHCP_OPTION_ELEMENT_UNION {
        [case(DhcpByteOption)] BYTE ByteOption;
        [case(DhcpWordOption)] WORD WordOption;
        [case(DhcpDWordOption)] DWORD DWordOption;
        [case(DhcpDWordDWordOption)] DWORD_DWORD DWordDWordOption;
        [case(DhcpIpAddressOption)] DHCP_IP_ADDRESS IpAddressOption;
        [case(DhcpStringDataOption)] LPWSTR StringDataOption;
        [case(DhcpBinaryDataOption)] DHCP_BINARY_DATA BinaryDataOption;
        [case(DhcpEncapsulatedDataOption)] DHCP_BINARY_DATA EncapsulatedDataOption;
        [default] ;
    } Element;
#else
    union _DHCP_OPTION_ELEMENT_UNION {
        BYTE ByteOption;
        WORD WordOption;
        DWORD DWordOption;
        DWORD_DWORD DWordDWordOption;
        DHCP_IP_ADDRESS IpAddressOption;
        LPWSTR StringDataOption;
        DHCP_BINARY_DATA BinaryDataOption;
        DHCP_BINARY_DATA EncapsulatedDataOption;
                // for vendor specific information option.
    } Element;
#endif // MIDL_PASS
} DHCP_OPTION_DATA_ELEMENT, *LPDHCP_OPTION_DATA_ELEMENT;

#if !defined(MIDL_PASS)
typedef union _DHCP_OPTION_ELEMENT_UNION
    DHCP_OPTION_ELEMENT_UNION, *LPDHCP_OPTION_ELEMENT_UNION;
#endif

typedef struct _DHCP_OPTION_DATA {
    DWORD NumElements; // number of option elements in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_DATA_ELEMENT Elements; //array
} DHCP_OPTION_DATA, *LPDHCP_OPTION_DATA;

typedef enum _DHCP_OPTION_TYPE {
    DhcpUnaryElementTypeOption,
    DhcpArrayTypeOption
} DHCP_OPTION_TYPE, *LPDHCP_OPTION_TYPE;

typedef struct _DHCP_OPTION {
    DHCP_OPTION_ID OptionID;
    LPWSTR OptionName;
    LPWSTR OptionComment;
    DHCP_OPTION_DATA DefaultValue;
    DHCP_OPTION_TYPE OptionType;
} DHCP_OPTION, *LPDHCP_OPTION;

typedef struct _DHCP_OPTION_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION Options;  // array
} DHCP_OPTION_ARRAY, *LPDHCP_OPTION_ARRAY;

typedef struct _DHCP_OPTION_VALUE {
    DHCP_OPTION_ID OptionID;
    DHCP_OPTION_DATA Value;
} DHCP_OPTION_VALUE, *LPDHCP_OPTION_VALUE;

typedef struct _DHCP_OPTION_VALUE_ARRAY {
    DWORD NumElements; // number of options in the pointed array
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_OPTION_VALUE Values;  // array
} DHCP_OPTION_VALUE_ARRAY, *LPDHCP_OPTION_VALUE_ARRAY;

typedef enum _DHCP_OPTION_SCOPE_TYPE {
    DhcpDefaultOptions,
    DhcpGlobalOptions,
    DhcpSubnetOptions,
    DhcpReservedOptions,
    DhcpMScopeOptions
} DHCP_OPTION_SCOPE_TYPE, *LPDHCP_OPTION_SCOPE_TYPE;

typedef struct _DHCP_RESERVED_SCOPE {
    DHCP_IP_ADDRESS ReservedIpAddress;
    DHCP_IP_ADDRESS ReservedIpSubnetAddress;
} DHCP_RESERVED_SCOPE, *LPDHCP_RESERVED_SCOPE;

typedef struct _DHCP_OPTION_SCOPE_INFO {
    DHCP_OPTION_SCOPE_TYPE ScopeType;
#if defined(MIDL_PASS)
    [switch_is(ScopeType), switch_type(DHCP_OPTION_SCOPE_TYPE)]
    union _DHCP_OPTION_SCOPE_UNION {
        [case(DhcpDefaultOptions)] ; // PVOID DefaultScopeInfo;
        [case(DhcpGlobalOptions)] ;  // PVOID GlobalScopeInfo;
        [case(DhcpSubnetOptions)] DHCP_IP_ADDRESS SubnetScopeInfo;
        [case(DhcpReservedOptions)] DHCP_RESERVED_SCOPE ReservedScopeInfo;
        [case(DhcpMScopeOptions)] LPWSTR MScopeInfo;
        [default] ;
    } ScopeInfo;
#else
    union _DHCP_OPTION_SCOPE_UNION {
        PVOID DefaultScopeInfo; // must be NULL
        PVOID GlobalScopeInfo;  // must be NULL
        DHCP_IP_ADDRESS SubnetScopeInfo;
        DHCP_RESERVED_SCOPE ReservedScopeInfo;
        LPWSTR  MScopeInfo;
    } ScopeInfo;
#endif // MIDL_PASS
} DHCP_OPTION_SCOPE_INFO, *LPDHCP_OPTION_SCOPE_INFO;

#if !defined(MIDL_PASS)
typedef union _DHCP_OPTION_SCOPE_UNION
    DHCP_OPTION_SCOPE_UNION, *LPDHCP_OPTION_SCOPE_UNION;
#endif

typedef struct _DHCP_OPTION_LIST {
    DWORD NumOptions;
#if defined(MIDL_PASS)
    [size_is(NumOptions)]
#endif // MIDL_PASS
        DHCP_OPTION_VALUE *Options;     // array
} DHCP_OPTION_LIST, *LPDHCP_OPTION_LIST;

//
// DHCP Client information data structures
//

typedef struct _DHCP_CLIENT_INFO {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
} DHCP_CLIENT_INFO, *LPDHCP_CLIENT_INFO;

typedef struct _DHCP_CLIENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY, *LPDHCP_CLIENT_INFO_ARRAY;

typedef enum _DHCP_CLIENT_SEARCH_TYPE {
    DhcpClientIpAddress,
    DhcpClientHardwareAddress,
    DhcpClientName
} DHCP_SEARCH_INFO_TYPE, *LPDHCP_SEARCH_INFO_TYPE;

typedef struct _DHCP_CLIENT_SEARCH_INFO {
    DHCP_SEARCH_INFO_TYPE SearchType;
#if defined(MIDL_PASS)
    [switch_is(SearchType), switch_type(DHCP_SEARCH_INFO_TYPE)]
    union _DHCP_CLIENT_SEARCH_UNION {
        [case(DhcpClientIpAddress)] DHCP_IP_ADDRESS ClientIpAddress;
        [case(DhcpClientHardwareAddress)] DHCP_CLIENT_UID ClientHardwareAddress;
        [case(DhcpClientName)] LPWSTR ClientName;
        [default] ;
    } SearchInfo;
#else
    union _DHCP_CLIENT_SEARCH_UNION {
        DHCP_IP_ADDRESS ClientIpAddress;
        DHCP_CLIENT_UID ClientHardwareAddress;
        LPWSTR ClientName;
    } SearchInfo;
#endif // MIDL_PASS
} DHCP_SEARCH_INFO, *LPDHCP_SEARCH_INFO;


#if !defined(MIDL_PASS)
typedef union _DHCP_CLIENT_SEARCH_UNION
    DHCP_CLIENT_SEARCH_UNION, *LPDHCP_CLIENT_SEARCH_UNION;
#endif // MIDL_PASS

//
// Mib Info structures.
//

typedef struct _SCOPE_MIB_INFO {
    DHCP_IP_ADDRESS Subnet;
    DWORD NumAddressesInuse;
    DWORD NumAddressesFree;
    DWORD NumPendingOffers;
} SCOPE_MIB_INFO, *LPSCOPE_MIB_INFO;

typedef struct _DHCP_MIB_INFO {
    DWORD Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Acks;
    DWORD Naks;
    DWORD Declines;
    DWORD Releases;
    DATE_TIME ServerStartTime;
    DWORD Scopes;
#if defined(MIDL_PASS)
    [size_is(Scopes)]
#endif // MIDL_PASS
    LPSCOPE_MIB_INFO ScopeInfo; // array.
} DHCP_MIB_INFO, *LPDHCP_MIB_INFO;

#define Set_APIProtocolSupport          0x00000001
#define Set_DatabaseName                0x00000002
#define Set_DatabasePath                0x00000004
#define Set_BackupPath                  0x00000008
#define Set_BackupInterval              0x00000010
#define Set_DatabaseLoggingFlag         0x00000020
#define Set_RestoreFlag                 0x00000040
#define Set_DatabaseCleanupInterval     0x00000080
#define Set_DebugFlag                   0x00000100
#define Set_PingRetries                 0x00000200
#define Set_BootFileTable               0x00000400
#define Set_AuditLogState               0x00000800

typedef struct _DHCP_SERVER_CONFIG_INFO {
    DWORD APIProtocolSupport;       // bit map of the protocols supported.
    LPWSTR DatabaseName;            // JET database name.
    LPWSTR DatabasePath;            // JET database path.
    LPWSTR BackupPath;              // Backup path.
    DWORD BackupInterval;           // Backup interval in mins.
    DWORD DatabaseLoggingFlag;      // Boolean database logging flag.
    DWORD RestoreFlag;              // Boolean database restore flag.
    DWORD DatabaseCleanupInterval;  // Database Cleanup Interval in mins.
    DWORD DebugFlag;                // Bit map of server debug flags.
} DHCP_SERVER_CONFIG_INFO, *LPDHCP_SERVER_CONFIG_INFO;

typedef enum _DHCP_SCAN_FLAG {
    DhcpRegistryFix,
    DhcpDatabaseFix
} DHCP_SCAN_FLAG, *LPDHCP_SCAN_FLAG;

typedef struct _DHCP_SCAN_ITEM {
    DHCP_IP_ADDRESS IpAddress;
    DHCP_SCAN_FLAG ScanFlag;
} DHCP_SCAN_ITEM, *LPDHCP_SCAN_ITEM;

typedef struct _DHCP_SCAN_LIST {
    DWORD NumScanItems;
#if defined(MIDL_PASS)
    [size_is(NumScanItems)]
#endif // MIDL_PASS
        DHCP_SCAN_ITEM *ScanItems;     // array
} DHCP_SCAN_LIST, *LPDHCP_SCAN_LIST;

typedef struct _DHCP_CLASS_INFO {
    LPWSTR                         ClassName;
    LPWSTR                         ClassComment;
    DWORD                          ClassDataLength;
    BOOL                           IsVendor;
    DWORD                          Flags;
#if defined(MIDL_PASS)
    [size_is(ClassDataLength)]
#endif // MIDL_PASS
    LPBYTE                         ClassData;
} DHCP_CLASS_INFO, *LPDHCP_CLASS_INFO;

typedef struct _DHCP_CLASS_INFO_ARRAY {
    DWORD                          NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif //MIDL_PASS
    LPDHCP_CLASS_INFO              Classes;
} DHCP_CLASS_INFO_ARRAY, *LPDHCP_CLASS_INFO_ARRAY;

//
// API proto types
//

//
// Subnet APIs
//

#ifndef     DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpCreateSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetSubnetInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_INFO * SubnetInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnets(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_IP_ARRAY *EnumInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElement(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElements(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElement(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteSubnet(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_FORCE_FLAG ForceFlag
    );

//
// Option APIs
//

DWORD DHCP_API_FUNCTION
DhcpCreateOption(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION * OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION * OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetOptionInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    LPDHCP_OPTION *OptionInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumOptions(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_ARRAY *Options,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveOption(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo,
    DHCP_CONST DHCP_OPTION_DATA * OptionValue
    );

DWORD DHCP_API_FUNCTION
DhcpSetOptionValues(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo,
    DHCP_CONST DHCP_OPTION_VALUE_ARRAY * OptionValues
    );

DWORD DHCP_API_FUNCTION
DhcpGetOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO *ScopeInfo,
    LPDHCP_OPTION_VALUE *OptionValue
    );

DWORD DHCP_API_FUNCTION
DhcpEnumOptionValues(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO *ScopeInfo,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    DWORD *OptionsRead,
    DWORD *OptionsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveOptionValue(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_OPTION_ID OptionID,
    DHCP_CONST DHCP_OPTION_SCOPE_INFO * ScopeInfo
    );

//
// Client APIs
//

DWORD DHCP_API_FUNCTION
DhcpCreateClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpSetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpGetClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *SearchInfo,
    LPDHCP_CLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteClientInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClients(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpGetClientOptions(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    );

DWORD DHCP_API_FUNCTION
DhcpGetMibInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerSetConfig(
    DHCP_CONST WCHAR *ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerGetConfig(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    );


DWORD DHCP_API_FUNCTION
DhcpScanDatabase(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    );

VOID DHCP_API_FUNCTION
DhcpRpcFreeMemory(
    PVOID BufferPointer
    );

DWORD DHCP_API_FUNCTION
DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    );

#endif   DHCPAPI_NO_PROTOTYPES
//
// new structures for NT4SP1
//

typedef struct _DHCP_IP_RESERVATION_V4 {
    DHCP_IP_ADDRESS  ReservedIpAddress;
    DHCP_CLIENT_UID *ReservedForClient;
    BYTE             bAllowedClientTypes;
} DHCP_IP_RESERVATION_V4, *LPDHCP_IP_RESERVATION_V4;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V4 {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION_V4 {
        [case(DhcpIpRanges)] DHCP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION_V4 *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION_V4 {
        DHCP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION_V4 *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA_V4, *LPDHCP_SUBNET_ELEMENT_DATA_V4;

#if !defined(MIDL_PASS)
typedef union _DHCP_SUBNET_ELEMENT_UNION_V4
    DHCP_SUBNET_ELEMENT_UNION_V4, *LPDHCP_SUBNET_ELEMENT_UNION_V4;
#endif

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_SUBNET_ELEMENT_DATA_V4 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4;


// DHCP_CLIENT_INFO:bClientType

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )
#define CLIENT_TYPE_RESERVATION_FLAG 0x4
#define CLIENT_TYPE_NONE            0x64
#define BOOT_FILE_STRING_DELIMITER  ','
#define BOOT_FILE_STRING_DELIMITER_W L','


typedef struct _DHCP_CLIENT_INFO_V4 {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    //
    // new fields for NT4SP1
    //

    BYTE   bClientType;          // CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP |
                                 // CLIENT_TYPE_NONE
} DHCP_CLIENT_INFO_V4, *LPDHCP_CLIENT_INFO_V4;

typedef struct _DHCP_CLIENT_INFO_ARRAY_V4 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO_V4 *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY_V4, *LPDHCP_CLIENT_INFO_ARRAY_V4;


typedef struct _DHCP_SERVER_CONFIG_INFO_V4 {
    DWORD APIProtocolSupport;       // bit map of the protocols supported.
    LPWSTR DatabaseName;            // JET database name.
    LPWSTR DatabasePath;            // JET database path.
    LPWSTR BackupPath;              // Backup path.
    DWORD BackupInterval;           // Backup interval in mins.
    DWORD DatabaseLoggingFlag;      // Boolean database logging flag.
    DWORD RestoreFlag;              // Boolean database restore flag.
    DWORD DatabaseCleanupInterval;  // Database Cleanup Interval in mins.
    DWORD DebugFlag;                // Bit map of server debug flags.

    // new fields for NT4 SP1

    DWORD  dwPingRetries;           // valid range: 0-5 inclusive
    DWORD  cbBootTableString;
#if defined( MIDL_PASS )
    [ size_is( cbBootTableString ) ]
#endif
    WCHAR  *wszBootTableString;
    BOOL   fAuditLog;               // TRUE to enable audit log

} DHCP_SERVER_CONFIG_INFO_V4, *LPDHCP_SERVER_CONFIG_INFO_V4;


//
// superscope info structure  (added by t-cheny)
//

typedef struct _DHCP_SUPER_SCOPE_TABLE_ENTRY {
    DHCP_IP_ADDRESS SubnetAddress; // subnet address
    DWORD  SuperScopeNumber;       // super scope group number
    DWORD  NextInSuperScope;       // index of the next subnet in the superscope
    LPWSTR SuperScopeName;         // super scope name
                                   // NULL indicates no superscope membership.
} DHCP_SUPER_SCOPE_TABLE_ENTRY, *LPDHCP_SUPER_SCOPE_TABLE_ENTRY;


typedef struct _DHCP_SUPER_SCOPE_TABLE
{
    DWORD cEntries;
#if defined( MIDL_PASS )
    [ size_is( cEntries ) ]
#endif;
    DHCP_SUPER_SCOPE_TABLE_ENTRY *pEntries;
} DHCP_SUPER_SCOPE_TABLE, *LPDHCP_SUPER_SCOPE_TABLE;

//
// NT4SP1 RPC interface
//

#ifndef     DHCPAPI_NO_PROTOTYPES

DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V4 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );


DWORD DHCP_API_FUNCTION
DhcpCreateClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpSetClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpGetClientInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_SEARCH_INFO *SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    );


DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClientsV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );


DWORD DHCP_API_FUNCTION
DhcpServerSetConfigV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    );

DWORD DHCP_API_FUNCTION
DhcpServerGetConfigV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    );


DWORD
DhcpSetSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST LPWSTR SuperScopeName,
    DHCP_CONST BOOL ChangeExisting
    );

DWORD
DhcpDeleteSuperScopeV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_CONST LPWSTR SuperScopeName
    );

DWORD
DhcpGetSuperScopeInfoV4(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
    );

#endif      DHCPAPI_NO_PROTOTYPES

typedef struct _DHCP_CLIENT_INFO_V5 {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DHCP_IP_MASK SubnetMask;
    DHCP_CLIENT_UID ClientHardwareAddress;
    LPWSTR ClientName;                  // optional.
    LPWSTR ClientComment;
    DATE_TIME ClientLeaseExpires;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    //
    // new fields for NT4SP1
    //

    BYTE   bClientType;          // CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP |
                                 // CLIENT_TYPE_NONE
    // new field for NT5.0
    BYTE   AddressState;         // OFFERED, DOOMED ...etc as given below
} DHCP_CLIENT_INFO_V5, *LPDHCP_CLIENT_INFO_V5;

// the following are four valid states for the record.  Note that only the last two
// bits must be used to find out the state... the higher bits are used as bit flags to
// indicate DNS stuff.
#define V5_ADDRESS_STATE_OFFERED       0x0
#define V5_ADDRESS_STATE_ACTIVE        0x1
#define V5_ADDRESS_STATE_DECLINED      0x2
#define V5_ADDRESS_STATE_DOOM          0x3

// DELETED => DNS DeRegistration pending
// UNREGISTERED => DNS Registration pending
// BOTH_REC => Both [Name->Ip] AND [Ip->Name] DNS registration would be done by server.

#define V5_ADDRESS_BIT_DELETED         0x80
#define V5_ADDRESS_BIT_UNREGISTERED    0x40
#define V5_ADDRESS_BIT_BOTH_REC        0x20

// Here are the flags that could be set/unset to affect DNS behaviour (option 81)
// If FLAG_ENABLED is not set, then this client is ignored for DNS updates or cleanups
// If update DOWNLEVEL is set, then DOWNLEVEL clients would have both A & Ptr records updated.
// If Cleanup expired is set, then the client's records would be cleaned up on delete.
// If UPDATE_BOTH_ALWAYS is set, all clients are treated like down level clients with both records updated.
//

// Some common cases:
// If you want updates to occur as requested by client, clear UPDATE_ALWAYS
// If you want updates to be only Ip->Name, clear FLAG_UPDATE_BOTH_ALWAYS
// If you want down level clients to be handled, set UPDATE_DOWNLEVEL
// If you want de-registrations on lease expiry, set CLEANUP_EXPIRED
// If you want any DNS activity at all, set ENABLED


#define DNS_FLAG_ENABLED               0x01
#define DNS_FLAG_UPDATE_DOWNLEVEL      0x02
#define DNS_FLAG_CLEANUP_EXPIRED       0x04
#define DNS_FLAG_UPDATE_BOTH_ALWAYS    0x10

typedef struct _DHCP_CLIENT_INFO_ARRAY_V5 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_CLIENT_INFO_V5 *Clients; // array of pointers
} DHCP_CLIENT_INFO_ARRAY_V5, *LPDHCP_CLIENT_INFO_ARRAY_V5;

#ifndef     DHCPAPI_NO_PROTOTYPES
// Newer NT50 Version of the function..
DWORD DHCP_API_FUNCTION
DhcpEnumSubnetClientsV5(
    DHCP_CONST  WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

//================================================================================
//  here is the NT 5.0 Beta2 stuff -- ClassId and Vendor specific stuff
//================================================================================

DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfoV5(                              // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptionsV5(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOptionV5(                               // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValueV5(                             // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValuesV5(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValueV5(                             // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValuesV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


DWORD
DhcpCreateClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
DhcpModifyClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;

#endif      DHCPAPI_NO_PROTOTYPES

#define     DHCP_OPT_ENUM_IGNORE_VENDOR           0x01
#define     DHCP_OPT_ENUM_USE_CLASSNAME           0x02

typedef     struct _DHCP_ALL_OPTIONS {
    DWORD                          Flags;         // must be zero -- not used..
    LPDHCP_OPTION_ARRAY            NonVendorOptions;
    DWORD                          NumVendorOptions;

#if defined(MIDL_PASS)
    [size_is(NumVendorOptions)]
#endif
    struct                         /* anonymous */ {
        DHCP_OPTION                Option;
        LPWSTR                     VendorName;
        LPWSTR                     ClassName;     // currently unused.
    }                             *VendorOptions;
} DHCP_ALL_OPTIONS, *LPDHCP_ALL_OPTIONS;


typedef     struct _DHCP_ALL_OPTION_VALUES {
    DWORD                          Flags;         // must be zero -- not used
    DWORD                          NumElements;   // the # of elements in array of Options below..
#if     defined(MIDL_PASS)
    [size_is(NumElements)]
#endif  MIDL_PASS
    struct                         /* anonymous */ {
        LPWSTR                     ClassName;     // for each user class (NULL if none exists)
        LPWSTR                     VendorName;    // for each vendor class (NULL if none exists)
        BOOL                       IsVendor;      // is this set of options vendor specific?
        LPDHCP_OPTION_VALUE_ARRAY  OptionsArray;  // list of options for the above pair: (vendor,user)
    }                             *Options;       // for each vendor/user class pair, one element in this array..
} DHCP_ALL_OPTION_VALUES, *LPDHCP_ALL_OPTION_VALUES;

#ifndef     DHCPAPI_NO_PROTOTYPES
// NT 50 Beta2 extended options api

DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS     *OptionStruct   // fill the fields of this structure
) ;
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;
#endif      DHCPAPI_NO_PROTOTYPES

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;

typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;

#endif      _ST_SRVR_H_

//DOC DhcpDsInit must be called exactly once per process.. this initializes the
//DOC memory and other structures for this process.  This initializes some DS
//DOC object handles (memory), and hence is slow as this has to read from DS.
DWORD
DhcpDsInit(
    VOID
);

//DOC DhcpDsCleanup undoes the effect of any DhcpDsInit.  This function should be
//DOC called exactly once for each process, and only at termination.  Note that
//DOC it is safe to call this function even if DhcpDsInit does not succeed.
VOID
DhcpDsCleanup(
    VOID
);

#define     DHCP_FLAGS_DONT_ACCESS_DS             0x01
#define     DHCP_FLAGS_DONT_DO_RPC                0x02
#define     DHCP_FLAGS_OPTION_IS_VENDOR           0x03


//DOC DhcpSetThreadOptions currently allows only one option to be set.  This is the
//DOC flag DHCP_FLAGS_DONT_ACCESS_DS.  This affects only the current executing thread.
//DOC When this function is executed, all calls made further DONT access the registry,
//DOC excepting the DhcpEnumServers, DhcpAddServer and DhcpDeleteServer calls.
DWORD
DhcpSetThreadOptions(                             // set options for current thread
    IN      DWORD                  Flags,         // options, currently 0 or DHCP_FLAGS_DONT_ACCESS_DS
    IN      LPVOID                 Reserved       // must be NULL, reserved for future
);

//DOC DhcpGetThreadOptions retrieves the current thread options as set by DhcpSetThreadOptions.
//DOC If none were set, the return value is zero.
DWORD
DhcpGetThreadOptions(                             // get current thread options
    OUT     LPDWORD                pFlags,        // this DWORD is filled with current optiosn..
    IN OUT  LPVOID                 Reserved       // must be NULL, reserved for future
);

#ifndef DHCPAPI_NO_PROTOTYPES
//DOC DhcpEnumServers enumerates the list of servers found in the DS.  If the DS
//DOC is not accessible, it returns an error. The only currently used parameter
//DOC is the out parameter Servers.  This is a SLOW call.
DWORD
DhcpEnumServers(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,    // output servers list
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpAddServer tries to add a new server to the existing list of servers in
//DOC the DS. The function returns error if the Server already exists in the DS.
//DOC The function tries to upload the server configuration to the DS..
//DOC This is a SLOW call.  Currently, the DsLocation and DsLocType are not valid
//DOC fields in the NewServer and they'd be ignored. Version must be zero.
DWORD
DhcpAddServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);

//DOC DhcpDeleteServer tries to delete the server from DS. It is an error if the
//DOC server does not already exist.  This also deletes any objects related to
//DOC this server in the DS (like subnet, reservations etc.).
DWORD
DhcpDeleteServer(
    IN      DWORD                  Flags,         // must be zero
    IN      LPVOID                 IdInfo,        // must be NULL
    IN      LPDHCP_SERVER_INFO     NewServer,     // input server information
    IN      LPVOID                 CallbackFn,    // must be NULL
    IN      LPVOID                 CallbackData   // must be NULL
);
#endif // DHCPAPI_NO_PROTOTYPES

#define     DHCP_ATTRIB_BOOL_IS_ROGUE             0x01
#define     DHCP_ATTRIB_BOOL_IS_DYNBOOTP          0x02
#define     DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC      0x03
#define     DHCP_ATTRIB_BOOL_IS_BINDING_AWARE     0x04
#define     DHCP_ATTRIB_BOOL_IS_ADMIN             0x05
#define     DHCP_ATTRIB_ULONG_RESTORE_STATUS      0x06

#define     DHCP_ATTRIB_TYPE_BOOL                 0x01
#define     DHCP_ATTRIB_TYPE_ULONG                0x02

typedef     ULONG                  DHCP_ATTRIB_ID, *PDHCP_ATTRIB_ID, *LPDHCP_ATTRIB_ID;

typedef     struct                 _DHCP_ATTRIB {
    DHCP_ATTRIB_ID                 DhcpAttribId;  // one of the DHCP_ATTRIB_*
    ULONG                          DhcpAttribType;// type of attrib
#if defined(MIDL_PASS)
    [switch_is(DhcpAttribType), switch_type(ULONG)]
    union                          {
    [case(DHCP_ATTRIB_TYPE_BOOL)]  BOOL  DhcpAttribBool;
    [case(DHCP_ATTRIB_TYPE_ULONG)] ULONG DhcpAttribUlong;
    };
#else MIDL_PASS
    union                          {              // predefined values..
    BOOL                           DhcpAttribBool;
    ULONG                          DhcpAttribUlong;
    };
#endif MIDL_PASS
}   DHCP_ATTRIB, *PDHCP_ATTRIB, *LPDHCP_ATTRIB;

typedef     struct                 _DHCP_ATTRIB_ARRAY {
    ULONG                          NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif MIDL_PASS
    LPDHCP_ATTRIB                  DhcpAttribs;
}   DHCP_ATTRIB_ARRAY, *PDHCP_ATTRIB_ARRAY, *LPDHCP_ATTRIB_ARRAY;

DWORD                                             // Status code
DhcpServerQueryAttribute(                         // get a server status
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      DHCP_ATTRIB_ID         DhcpAttribId,  // the attrib being queried
    OUT     LPDHCP_ATTRIB         *pDhcpAttrib    // fill in this field
);

DWORD                                             // Status code
DhcpServerQueryAttributes(                        // query multiple attributes
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved,    // reserved for future
    IN      ULONG                  dwAttribCount, // # of attribs being queried
    IN      DHCP_ATTRIB_ID         pDhcpAttribs[],// array of attribs
    OUT     LPDHCP_ATTRIB_ARRAY   *pDhcpAttribArr // Ptr is filled w/ array
);

DWORD                                             // Status code
DhcpServerRedoAuthorization(                      // retry the rogue server stuff
    IN      LPWSTR                 ServerIpAddr,  // String form of server IP
    IN      ULONG                  dwReserved     // reserved for future
);

DWORD
DhcpAuditLogSetParams(                            // set some auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
);

DWORD
DhcpAuditLogGetParams(                                // get the auditlogging params
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
);

typedef struct _DHCP_BOOTP_IP_RANGE {
    DHCP_IP_ADDRESS StartAddress;
    DHCP_IP_ADDRESS EndAddress;
    ULONG BootpAllocated;
    ULONG MaxBootpAllowed;
} DHCP_BOOTP_IP_RANGE, *LPDHCP_BOOT_IP_RANGE;

typedef struct _DHCP_SUBNET_ELEMENT_DATA_V5 {
    DHCP_SUBNET_ELEMENT_TYPE ElementType;
#if defined(MIDL_PASS)
    [switch_is(ELEMENT_MASK(ElementType)), switch_type(DHCP_SUBNET_ELEMENT_TYPE)]
    union _DHCP_SUBNET_ELEMENT_UNION_V5 {
        [case(DhcpIpRanges)] DHCP_BOOTP_IP_RANGE *IpRange;
        [case(DhcpSecondaryHosts)] DHCP_HOST_INFO *SecondaryHost;
        [case(DhcpReservedIps)] DHCP_IP_RESERVATION_V4 *ReservedIp;
        [case(DhcpExcludedIpRanges)] DHCP_IP_RANGE *ExcludeIpRange;
        [case(DhcpIpUsedClusters)] DHCP_IP_CLUSTER *IpUsedCluster;
        [default] ;
    } Element;
#else
    union _DHCP_SUBNET_ELEMENT_UNION_V5 {
        DHCP_BOOTP_IP_RANGE *IpRange;
        DHCP_HOST_INFO *SecondaryHost;
        DHCP_IP_RESERVATION_V4 *ReservedIp;
        DHCP_IP_RANGE *ExcludeIpRange;
        DHCP_IP_CLUSTER *IpUsedCluster;
    } Element;
#endif // MIDL_PASS
} DHCP_SUBNET_ELEMENT_DATA_V5, *LPDHCP_SUBNET_ELEMENT_DATA_V5;

typedef struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_SUBNET_ELEMENT_DATA_V5 Elements; //array
} DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5, *LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5;

#ifndef DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpAddSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumSubnetElementsV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveSubnetElementV5(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_CONST DHCP_SUBNET_ELEMENT_DATA_V5 * RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );
#endif // DHCPAPI_NO_PROTOTYPES

#define     DHCPCTR_SHARED_MEM_NAME   L"Global\\DHCPCTRS_SHMEM"

#pragma     pack(4)
typedef struct _DHCP_PERF_STATS {                     // performance statistics
    //
    // DO NOT CHANGE THIS ORDER -- THIS AFFECTS THE PERF COUNTER DEFINITION
    // ORDER IN DHCPDATA.C (under PERF directory)
    //
    ULONG   dwNumPacketsReceived;
    ULONG   dwNumPacketsDuplicate;
    ULONG   dwNumPacketsExpired;
    ULONG   dwNumMilliSecondsProcessed;
    ULONG   dwNumPacketsInActiveQueue;
    ULONG   dwNumPacketsInPingQueue;

    ULONG   dwNumDiscoversReceived;
    ULONG   dwNumOffersSent;

    ULONG   dwNumRequestsReceived;
    ULONG   dwNumInformsReceived;
    ULONG   dwNumAcksSent;
    ULONG   dwNumNacksSent;

    ULONG   dwNumDeclinesReceived;
    ULONG   dwNumReleasesReceived;

    //
    // This is not a counter value.. but there just to aid calculation of packet
    // processing time/ # of packets processed.
    //
    ULONG   dwNumPacketsProcessed;
} DHCP_PERF_STATS, *LPDHCP_PERF_STATS;
#pragma     pack()


typedef VOID (WINAPI *DHCP_CLEAR_DS_ROUTINE) (VOID);

VOID
WINAPI
DhcpDsClearHostServerEntries(
    VOID
);

typedef VOID (WINAPI *DHCP_MARKUPG_ROUTINE) (VOID);
VOID
WINAPI
DhcpMarkUpgrade(
    VOID
);

#define DHCP_ENDPOINT_FLAG_CANT_MODIFY 0x01

typedef struct _DHCP_BIND_ELEMENT {
    ULONG Flags;
    BOOL fBoundToDHCPServer;
    DHCP_IP_ADDRESS AdapterPrimaryAddress;
    DHCP_IP_ADDRESS AdapterSubnetAddress;
    LPWSTR IfDescription;
    ULONG IfIdSize;
#if defined (MIDL_PASS)
    [size_is(IfIdSize)]
#endif // MIDL_PASS
    LPBYTE IfId;    
} DHCP_BIND_ELEMENT, *LPDHCP_BIND_ELEMENT;

typedef struct _DHCP_BIND_ELEMENT_ARRAY {
    DWORD NumElements;
#if defined (MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
    LPDHCP_BIND_ELEMENT Elements; //array
} DHCP_BIND_ELEMENT_ARRAY, *LPDHCP_BIND_ELEMENT_ARRAY;


#ifndef DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpGetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY *BindElementsInfo
);

DWORD DHCP_API_FUNCTION
DhcpSetServerBindingInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    ULONG Flags,
    LPDHCP_BIND_ELEMENT_ARRAY BindElementInfo
);
#endif // DHCPAPI_NO_PROTOTYPES

DWORD
DhcpServerQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize, //in BYTES
    OUT LPWSTR Uname,
    IN ULONG DomainSize, // in BYTES
    OUT LPWSTR Domain
    );

DWORD
DhcpServerSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    );

DWORD
DhcpServerBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    );

DWORD
DhcpServerRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    );

#endif // _DHCPAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\dlcio.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
          (c) 1991  Nokia Data Systems AB

Module Name:

    ntccbs.h

Abstract:

    This file defines the internal DLC API data structures used by
    Windows/NT DLC.  Most parameter structures are copied directly,
    but here are also defined some new structures for internal use.
    
Author:

    Antti Saarenheimo   [o-anttis]          6-JUNE-1991

Revision History:

--*/

/*
    The commands in alphanumeric order (just saved here)

LLC_BUFFER_CREATE                            0x0025
LLC_BUFFER_FREE                              0x0027
LLC_BUFFER_GET                               0x0026
LLC_DIR_CLOSE_ADAPTER                        0x0004
LLC_DIR_CLOSE_DIRECT                         0x0034
LLC_DIR_INITIALIZE                           0x0020
LLC_DIR_INTERRUPT                            0x0000
LLC_DIR_OPEN_ADAPTER                         0x0003
LLC_DIR_OPEN_DIRECT                          0x0035
LLC_DIR_READ_LOG                             0x0008
LLC_DIR_SET_EXCEPTION_FLAGS                  0x002D
LLC_DIR_SET_FUNCTIONAL_ADDRESS               0x0007
LLC_DIR_SET_GROUP_ADDRESS                    0x0006
LLC_DIR_STATUS                               0x0021
LLC_DIR_TIMER_CANCEL                         0x0023
LLC_DIR_TIMER_CANCEL_GROUP                   0x002C
LLC_DIR_TIMER_SET                            0x0022
LLC_DLC_CLOSE_SAP                            0x0016
LLC_DLC_CLOSE_STATION                        0x001A
LLC_DLC_CONNECT_STATION                      0x001B
LLC_DLC_FLOW_CONTROL                         0x001D
LLC_DLC_MODIFY                               0x001C
LLC_DLC_OPEN_SAP                             0x0015
LLC_DLC_OPEN_STATION                         0x0019
LLC_DLC_REALLOCATE_STATIONS                  0x0017
LLC_DLC_RESET                                0x0014
LLC_DLC_SET_THRESHOLD                        0x0033
LLC_DLC_STATISTICS                           0x001E
LLC_READ                                     0x0031
LLC_READ_CANCEL                              0x0032
LLC_RECEIVE                                  0x0028
LLC_RECEIVE_CANCEL                           0x0029
LLC_RECEIVE_MODIFY                           0x002A
LLC_TRANSMIT_DIR_FRAME                       0x000A
LLC_TRANSMIT_FRAMES                          0x0009
LLC_TRANSMIT_I_FRAME                         0x000B
LLC_TRANSMIT_TEST_CMD                        0x0011
LLC_TRANSMIT_UI_FRAME                        0x000D
LLC_TRANSMIT_XID_CMD                         0x000E
LLC_TRANSMIT_XID_RESP_FINAL                  0x000F
LLC_TRANSMIT_XID_RESP_NOT_FINAL              0x0010

*/

//
//  Change this version number whenever the driver-acslan api has
//  been changed or both modules must be changed.
//
#define NT_DLC_IOCTL_VERSION        1

//
//  Defines the maximum number of buffer segments used in a transmit.
//  Max IBM token-ring frame may consist about 72 buffers ((18 * 4) * 256),
//  if the application uses 256 bytes as its buffer size.
//
#define MAX_TRANSMIT_SEGMENTS       128     // takes about 1 kB in stack!!!

//
//  We use three different CCB structures:  the first one is needed
//  to allocate space for whole ccb, if READ and RECEIVE parameter table
//  is catenated to CCB structure (=> we have only one output buffer).
//  The second input CCB buffer is used with the commands having no
//  input parameters except those in CCB parameter table field
//  (all close commands, DirTimerSet).
//  The last buffer is always returned by asynchronous dlc commands.
//
typedef struct _NT_DLC_CCB {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    OUT UCHAR       uchInformation;        // # successful transmits
    IN PVOID        pCcbAddress;
    IN ULONG        CommandCompletionFlag;
    union {
        IN PLLC_PARMS   pParameterTable; // pointer to the parameter table
        IN PVOID        pMdl;
        struct {
            IN USHORT       usStationId;    // Station id
            IN USHORT       usParameter;    // optional parameter
        } dlc;
        struct {
            IN USHORT       usParameter0;   // first optional parameter
            IN USHORT       usParameter1;   // second optional parameter
        } dir;
        IN UCHAR            auchBuffer[4];  // group/functional address
        IN ULONG            ulParameter;
    } u;
    ULONG           Reserved1;
    ULONG           Reserved2;

//  (I am still thinking about this):
//
//  The multiple frame transmit should return the number a successfully
//  sent frames or otherwise it's not useable for higher protocols.
//  We should actually free the transmit buffers only as far as the
//  transmits succeeds.  The buffers should not be released after the
//  first error, because then the data would be lost for ever.  The only thing
//  the user need to know is how many sequestial frames were sent successfully.
//  The number is also the index of the first failed frame, when one 
//  of the frames fails.  The frames are not necessary completed in 
//  same order, because the error may happed in DlcTransmit, LlcSendX or
//  asynchronoulsy (eg. link lost) => we need the index of the first
//  failing frame.  The frame must not be released, if its index is higher
//  than that of the first failed frame. A new error (async) be overwrite
//  an earlier (sync) error having higher sequency number.
//  Initially the number of successful frames is -1 and each frame of 
//  the multiple send needs a sequency number.  The last frame copies
//  own sequency number (added by one) to the CCB.
//
//  ULONG           cSuccessfulTransmits;   // REMOVE Reserved2!!!!!
//
} NT_DLC_CCB, *PNT_DLC_CCB;

typedef struct _NT_DLC_CCB_INPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;           // 
    IN ULONG        CommandCompletionFlag;
    union {
        IN OUT PLLC_PARMS   pParameterTable; // pointer to the parameter table
        struct {
            IN USHORT       usStationId;    // Station id
            IN USHORT       usParameter;    // optional parameter
        } dlc;
        struct {
            IN USHORT       usParameter0;   // first optional parameter
            IN USHORT       usParameter1;   // second optional parameter
        } dir;
        IN UCHAR            auchBuffer[4];  // group/functional address
        IN ULONG            ulParameter;
    } u;
} NT_DLC_CCB_INPUT, *PNT_DLC_CCB_INPUT;

typedef struct _NT_DLC_CCB_OUTPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;    // 
} NT_DLC_CCB_OUTPUT, *PNT_DLC_CCB_OUTPUT;

typedef struct _NT_DLC_TRANSMIT2_CCB_OUTPUT {
    IN UCHAR        uchAdapterNumber;      // Adapter 0 or 1
    IN UCHAR        uchDlcCommand;         // DLC command
    OUT UCHAR       uchDlcStatus;          // DLC command completion code
    UCHAR           uchReserved1;          // reserved for DLC DLL
    OUT PVOID       pCcbAddress;    // 
} NT_DLC_TRANSMIT2_CCB_OUTPUT, *PNT_DLC_CCB_TRANSMIT2_OUTPUT;
 
//
//  BUFFER.FREE
//
//  DlcCommand = 0x27
//
//  Internal NT DLC API data structure.
//
typedef struct _NT_DLC_BUFFER_FREE_PARMS {
    IN USHORT               Reserved1;
    OUT USHORT              cBuffersLeft;
    IN USHORT               BufferCount;
    IN USHORT               Reserved2;
    IN LLC_TRANSMIT_DESCRIPTOR    DlcBuffer[1];
} NT_DLC_BUFFER_FREE_PARMS, *PNT_DLC_BUFFER_FREE_PARMS;

typedef struct _NT_DLC_BUFFER_FREE_ALLOCATION {
    IN USHORT               Reserved1;
    OUT USHORT              cBuffersLeft;
    IN USHORT               BufferCount;
    IN USHORT               Reserved2;
    IN LLC_TRANSMIT_DESCRIPTOR    DlcBuffer[MAX_TRANSMIT_SEGMENTS];
} NT_DLC_BUFFER_FREE_ALLOCATION, *PNT_DLC_BUFFER_FREE_ALLOCATION;

typedef struct _NT_DLC_BUFFER_FREE_OUTPUT {
    IN USHORT               Reserved2;
    OUT USHORT              cBuffersLeft;
} NT_DLC_BUFFER_FREE_OUTPUT, *PNT_DLC_BUFFER_FREE_OUTPUT;

//
//  DLC_CONNECT_STATION
//
//  DlcCommand = 0x1b
// (copied by DLC API)
//
#define DLC_MAX_ROUTING_INFOMATION      18
typedef struct _NT_DLC_CONNECT_STATION_PARMS {
    IN LLC_CCB          Ccb;
    IN USHORT           Reserved;
    IN USHORT           StationId;
    IN UCHAR            aRoutingInformation[DLC_MAX_ROUTING_INFOMATION];
    IN USHORT           RoutingInformationLength;
} NT_DLC_CONNECT_STATION_PARMS, *PNT_DLC_CONNECT_STATION_PARMS;

//
//  DLC_FLOW_CONTROL
//
//  DlcCommand = 0x1d
// (copied by DLC API)
//
#define     LLC_VALID_FLOW_CONTROL_BITS 0xc0

//
//  This is special DOS DLC extensions to generate 
//  dlc local busy (dos dlc buffer) indication from 
//  dos dlc support dll.
//
#define     LLC_SET_LOCAL_BUSY_BUFFER   0x20
#define     LLC_DOS_DLC_FLOW_CONTROL    0x1f

typedef struct _NT_DLC_FLOW_CONTROL_PARMS {
    IN USHORT           StationId;
    IN UCHAR            FlowControlOption;
    IN UCHAR            Reserved;
} NT_DLC_FLOW_CONTROL_PARMS, *PNT_DLC_FLOW_CONTROL_PARMS;

//
//  DLC_SET_INFORMATION
//
//  This command is used to set the parameters of a link 
//  station or a sap. A null field in the station id struct
//  defines a 
//
//  DlcCommand = 0x1c
//

//
//  Info classes for datalink Set/Query Information
//
enum _DLC_INFO_CLASS_TYPES {
    DLC_INFO_CLASS_STATISTICS,          // get
    DLC_INFO_CLASS_STATISTICS_RESET,    // get and reset
    DLC_INFO_CLASS_DLC_TIMERS,          // get/set
    DLC_INFO_CLASS_DIR_ADAPTER,         // get
    DLC_INFO_CLASS_DLC_ADAPTER,         // get
    DLC_INFO_CLASS_PERMANENT_ADDRESS,   // get
    DLC_INFO_CLASS_LINK_STATION,        // set
    DLC_INFO_CLASS_DIRECT_INFO,         // set
    DLC_INFO_CLASS_GROUP,               // set
    DLC_INFO_CLASS_RESET_FUNCTIONAL,    // set
    DLC_INFO_CLASS_SET_GROUP,           // set / get 
    DLC_INFO_CLASS_SET_FUNCTIONAL,      // set / get
    DLC_INFO_CLASS_ADAPTER_LOG,         // get
    DLC_INFO_CLASS_SET_MULTICAST        // set
};
#define     DLC_MAX_GROUPS  127         // max for group saps

typedef struct _LinkStationInfoSet {
    IN UCHAR            TimerT1;
    IN UCHAR            TimerT2;
    IN UCHAR            TimerTi;
    IN UCHAR            MaxOut;
    IN UCHAR            MaxIn;
    IN UCHAR            MaxOutIncrement;
    IN UCHAR            MaxRetryCount;
    IN UCHAR            TokenRingAccessPriority;
    IN USHORT           MaxInformationField;
} DLC_LINK_PARAMETERS, * PDLC_LINK_PARAMETERS;

typedef struct _LLC_TICKS {
    UCHAR       T1TickOne;       // default short delay for response timer
    UCHAR       T2TickOne;       // default short delay for ack delay timer
    UCHAR       TiTickOne;       // default short delay for inactivity timer
    UCHAR       T1TickTwo;       // default short delay for response timer
    UCHAR       T2TickTwo;       // default short delay for ack delay timer
    UCHAR       TiTickTwo;       // default short delay for inactivity timer
} LLC_TICKS, *PLLC_TICKS;

typedef union _TR_BROADCAST_ADDRESS
{
    ULONG   ulAddress;
    UCHAR   auchAddress[4];
} TR_BROADCAST_ADDRESS, *PTR_BROADCAST_ADDRESS;

typedef struct _NT_DLC_SET_INFORMATION_PARMS {
    struct _DlcSetInfoHeader {
        IN USHORT           StationId;
        IN USHORT           InfoClass;
    } Header;
    union {
        // InfoClass = DLC_INFO_CLASS_LINK_STATION
        DLC_LINK_PARAMETERS LinkStation;

        // InfoClass = DLC_INFO_CLASS_GROUP
        struct _DlcSapInfoSet {
            IN UCHAR            GroupCount;
            IN UCHAR            GroupList[DLC_MAX_GROUPS];
        } Sap;

        // InfoClass = DLC_INFO_CLASS_DIRECT_STATION
        struct _DlcDirectStationInfoSet {
            IN ULONG            FrameMask;
        } Direct;

        // InfoClass = DLC_INFO_CLASS_DLC_TIMERS
        LLC_TICKS TimerParameters;

        // InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_SET_GROUP
        UCHAR   Buffer[1];
        
        // InfoClass = DLC_INFO_CLASS_SET_MULTICAST
        UCHAR   auchMulticastAddress[6];
      
        TR_BROADCAST_ADDRESS Broadcast;
    } Info;
} NT_DLC_SET_INFORMATION_PARMS, *PNT_DLC_SET_INFORMATION_PARMS;

typedef struct _DlcAdapterInfoGet {
            OUT UCHAR           MaxSap;
            OUT UCHAR           OpenSaps;
            OUT UCHAR           MaxStations;
            OUT UCHAR           OpenStations;
            OUT UCHAR           AvailStations;
} LLC_ADAPTER_DLC_INFO, *PLLC_ADAPTER_DLC_INFO;

//
//  This structure is tailored for DLC DirOpenAdapter and DirStatus 
//  functions.
//
typedef struct _LLC_ADAPTER_INFO { 
    UCHAR               auchNodeAddress[6];
    UCHAR               auchGroupAddress[4];
    UCHAR               auchFunctionalAddress[4];
    USHORT              usAdapterType; //  (struct may not be dword align!)
    USHORT              usReserved;
    USHORT              usMaxFrameSize;
    ULONG               ulLinkSpeed;
} LLC_ADAPTER_INFO, *PLLC_ADAPTER_INFO;

//
//  DLC_QUERY_INFOMATION
//
//  This command is used to set the parameters of a link 
//  station or a sap. A null field in the station id struct
//  defines a 
//
//  DlcCommand = 
//

typedef union _NT_DLC_QUERY_INFORMATION_OUTPUT {
// (Query dlc parameters not used by DLC)
//        // InfoClass = DLC_INFO_CLASS_STATION_INFO for link station
//        DLC_LINK_PARAMETERS Link;
//        // InfoClass = DLC_INFO_CLASS_DIRECT_INFO for direct station
//      struct _DlcDirectStationInfoGet {
//         OUT ULONG           FrameMask;
//      } Direct;

        // InfoClass = DLC_INFO_CLASS_DIR_ADAPTER;
        LLC_ADAPTER_INFO    DirAdapter;

        // InfoClass = DLC_INFO_CLASS_SAP
        struct _DlcSapInfoGet {
            OUT USHORT          MaxInformationField;
            OUT UCHAR           MaxMembers;
            OUT UCHAR           GroupCount;
            OUT UCHAR           GroupList[DLC_MAX_GROUPS];
        } Sap;

        // InfoClass = DLC_INFO_CLASS_LINK_STATION
        struct _DlcLinkInfoGet {
            OUT USHORT          MaxInformationField;
        } Link;

        // InfoClass = DLC_INFO_CLASS_DLC_ADAPTER
        LLC_ADAPTER_DLC_INFO    DlcAdapter;

//        struct _DlcInfoSetBroadcast Broadcast;

        // InfoClass = DLC_INFO_CLASS_DLC_TIMERS
        LLC_TICKS TimerParameters;

        // InfoClass = DLC_INFO_CLASS_ADAPTER_LOG
        LLC_ADAPTER_LOG AdapterLog;

        // InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL
        // InfoClass = DLC_INFO_CLASS_SET_GROUP
        UCHAR   Buffer[1];
} NT_DLC_QUERY_INFORMATION_OUTPUT, *PNT_DLC_QUERY_INFORMATION_OUTPUT;

typedef struct _NT_DLC_QUERY_INFORMATION_INPUT {
    IN USHORT           StationId;
    IN USHORT           InfoClass;
} NT_DLC_QUERY_INFORMATION_INPUT, *PNT_DLC_QUERY_INFORMATION_INPUT;

typedef union _NT_DLC_QUERY_INFORMATION_PARMS {
    NT_DLC_QUERY_INFORMATION_INPUT Header;
    NT_DLC_QUERY_INFORMATION_OUTPUT Info;
} NT_DLC_QUERY_INFORMATION_PARMS, *PNT_DLC_QUERY_INFORMATION_PARMS;

//
//  DLC_OPEN_SAP
//
//  DlcCommand = 0x15
//
typedef struct _NT_DLC_OPEN_SAP_PARMS {
    OUT USHORT          StationId;        // SAP or link station id
    IN USHORT           UserStatusValue;
    IN DLC_LINK_PARAMETERS LinkParameters;
    IN UCHAR            SapValue;
    IN UCHAR            OptionsPriority;
    IN UCHAR            StationCount;   
    IN UCHAR            Reserved1[7];
    IN ULONG            DlcStatusFlag;
    IN UCHAR            Reserved2[8];
    OUT UCHAR           AvailableStations;  // == StationCount
} NT_DLC_OPEN_SAP_PARMS, *PNT_DLC_OPEN_SAP_PARMS;

//
//  NT_DLC_OPEN_STATION
//
//  DlcCommand = 0x19
//
//
typedef struct _NT_DLC_OPEN_STATION_PARMS {
    IN OUT USHORT           LinkStationId;
    IN DLC_LINK_PARAMETERS  LinkParameters;
    IN UCHAR                aRemoteNodeAddress[6];
    IN UCHAR                RemoteSap;
} NT_DLC_OPEN_STATION_PARMS, *PNT_DLC_OPEN_STATION_PARMS;

//
//  NT_DLC_SET_TRESHOLD
//
//  DlcCommand = 0x33
//
//typedef struct _NT_DLC_SET_TRESHOLD_PARMS {
//    IN USHORT           StationId;
//    IN USHORT           Reserved;
//    IN ULONG            BufferTresholdSize;
//    IN PVOID            AlertEvent;
//} NT_DLC_SET_TRESHOLD_PARMS, *PNT_DLC_SET_TRESHOLD_PARMS;

//
//  DIR_OPEN_ADAPTER
//
//  DlcCommand = 0x03
//
//  OUT: Info.ulParameter  = BringUpDiagnostics;
//
#ifndef    MAX_PATH   // I don't want to include whole windows because of this
#define MAX_PATH    260
#endif
typedef struct _NT_DIR_OPEN_ADAPTER_PARMS {
    OUT LLC_ADAPTER_OPEN_PARMS  Adapter;
    IN  PVOID               pSecurityDescriptor;
    IN  PVOID               hBufferPoolHandle;
    IN  LLC_ETHERNET_TYPE   LlcEthernetType;
    IN  ULONG               NtDlcIoctlVersion;
    IN  LLC_TICKS           LlcTicks;
    IN  UCHAR               AdapterNumber;
    IN  UCHAR               uchReserved;
    IN  UNICODE_STRING      NdisDeviceName;
    IN  WCHAR               Buffer[ MAX_PATH ];
} NT_DIR_OPEN_ADAPTER_PARMS, *PNT_DIR_OPEN_ADAPTER_PARMS;

//
//  READ_CANCEL         (DlcCommand = 0x32)
//  DIR_TIMER_CANCEL    (DlcCommand = 0x23)
//
typedef struct _NT_DLC_CANCEL_COMMAND_PARMS {
    IN PVOID   CcbAddress;
} NT_DLC_CANCEL_COMMAND_PARMS, *PNT_DLC_CANCEL_COMMAND_PARMS;

//
//  RECEIVE_CANCEL
//
//  DlcCommand = 0x29
//
typedef struct _NT_DLC_RECEIVE_CANCEL_PARMS {
    PVOID   pCcb;
} NT_DLC_RECEIVE_CANCEL_PARMS, *PNT_DLC_RECEIVE_CANCEL_PARMS;

typedef struct _NT_DLC_COMMAND_CANCEL_PARMS {
    PVOID   pCcb;
} NT_DLC_COMMAND_CANCEL_PARMS, *PNT_DLC_COMMAND_CANCEL_PARMS;

//
//  TRANSMIT_DIR_FRAME
//  TRANSMIT_I_FRAME
//  TRANSMIT_TEST_CMD
//  TRANSMIT_UI_FRAME
//  TRANSMIT_XID_CMD
//  TRANSMIT_XID_RESP_FINAL
//  TRANSMIT_XID_RESP_NOT_FINAL
//  
typedef struct _NT_DLC_TRANSMIT_PARMS {
    IN USHORT       StationId;
    IN USHORT       FrameType;              // DLC frame or ethernet protocol
    IN UCHAR        RemoteSap OPTIONAL;     // used only for DLC types
    IN UCHAR        XmitReadOption;
    OUT UCHAR       FrameStatus;            // not returned by I or new xmit
    IN UCHAR        Reserved;
    IN ULONG        XmitBufferCount;
    IN LLC_TRANSMIT_DESCRIPTOR  XmitBuffer[1];
} NT_DLC_TRANSMIT_PARMS, *PNT_DLC_TRANSMIT_PARMS;

typedef struct _NT_DLC_TRANSMIT_ALLOCATION {
    IN USHORT       StationId;
    IN USHORT       FrameType;
    IN UCHAR        RemoteSap;
    IN UCHAR        XmitReadOption;
    OUT UCHAR       FrameStatus; 
    IN UCHAR        Reserved;
    IN ULONG        XmitBufferCount;
    IN LLC_TRANSMIT_DESCRIPTOR  XmitBuffer[MAX_TRANSMIT_SEGMENTS];
} NT_DLC_TRANSMIT_ALLOCATION;

typedef struct _NT_DLC_TRANSMIT_OUTPUT {
    OUT UCHAR           FrameStatus; 
} NT_DLC_TRANSMIT_OUTPUT, *PNT_DLC_TRANSMIT_OUTPUT;

enum _XMIT_READ_OPTION {
    DLC_CHAIN_XMIT_IN_LINK = 0,
    DLC_DO_NOT_CHAIN_XMIT = 1,
    DLC_CHAIN_XMIT_IN_SAP = 2
};
    
//
//  COMPLETE_COMMAND
//
//  DlcCommand = 0x??
//
//  The command is used to complete all synchronous commands.
//  The DLC API library calls the DLC device driver again with
//  these parameters, when a synchronous DLC command with 
//  COMMAND_COMPLETION_FLAG has completed.
//  The command completes immediately, but the orginal CCB pointer
//  and command completion flag are queued to the even queue
//  or completed immediately with a READ command.
//  The asynchronous commands are queued immediately when they 
//  completes, but their 
//
typedef struct _NT_DLC_COMPLETE_COMMAND_PARMS {
    IN PVOID    pCcbPointer;
    IN ULONG    CommandCompletionFlag;
    IN USHORT   StationId;
    IN USHORT   Reserved;
} NT_DLC_COMPLETE_COMMAND_PARMS, *PNT_DLC_COMPLETE_COMMAND_PARMS;


//
//  There is a small READ_INPUT parameter structure, because we
// do not want to copy all output parameters in every read request.
//  
//
typedef struct _NT_DLC_READ_INPUT {
    IN USHORT           StationId;
    IN UCHAR            OptionIndicator;
    IN UCHAR            EventSet;
    IN PVOID            CommandCompletionCcbLink;
} NT_DLC_READ_INPUT, * PNT_DLC_READ_INPUT;

//
//  This buffer is copied back to user memory, when read parameter table
//  is separate from CCB- table.
//
typedef LLC_READ_PARMS LLC_READ_OUTPUT_PARMS, *PLLC_READ_OUTPUT_PARMS;

//typedef struct _LLC_READ_OUTPUT_PARMS {
//    IN USHORT           usStationId;
//    IN UCHAR            uchOptionIndicator;
//    IN UCHAR            uchEventSet;
//    OUT UCHAR           uchEvent;
//    OUT UCHAR           uchCriticalSubset;
//    OUT ULONG           ulNotificationFlag;
//    union {
//        struct {
//            OUT USHORT          usCcbCount;
//            OUT PLLC_CCB        pCcbCompletionList;
//            OUT USHORT          usBufferCount;
//            OUT PLLC_BUFFER     pFirstBuffer;
//            OUT USHORT          usReceivedFrameCount;
//            OUT PLLC_BUFFER     pReceivedFrame;
//            OUT USHORT          usEventErrorCode;
//            OUT USHORT          usEventErrorData[3];
//        } Event;
//        struct {
//            OUT USHORT          usStationId;
//            OUT USHORT          usDlcStatusCode;
//            OUT UCHAR           uchFrmrData[5];
//            OUT UCHAR           uchAccessPritority;
//            OUT UCHAR           uchRemoteNodeAddress[6];
//            OUT UCHAR           uchRemoteSap;
//            OUT UCHAR           uchReserved;
//            OUT USHORT          usUserStatusValue;
//        } Status;
//    } Type;
//} LLC_READ_OUTPUT_PARMS, *PLLC_READ_OUTPUT_PARMS;

typedef struct _NT_DLC_READ_PARMS {
    IN USHORT           StationId;
    IN UCHAR            OptionIndicator;
    IN UCHAR            EventSet;
    OUT UCHAR           Event;
    OUT UCHAR           CriticalSubset;
    OUT ULONG           NotificationFlag;
    union {
        struct {
            OUT USHORT          CcbCount;
            OUT PVOID           pCcbCompletionList;
            OUT USHORT          BufferCount;
            OUT PLLC_BUFFER     pFirstBuffer;
            OUT USHORT          ReceivedFrameCount;
            OUT PLLC_BUFFER     pReceivedFrame;
            OUT USHORT          EventErrorCode;
            OUT USHORT          EventErrorData[3];
        } Event;
        struct {
            OUT USHORT          StationId;
            OUT USHORT          DlcStatusCode;
            OUT UCHAR           FrmrData[5];
            OUT UCHAR           AccessPritority;
            OUT UCHAR           RemoteNodeAddress[6];
            OUT UCHAR           RemoteSap;
            OUT UCHAR           Reserved;
            OUT USHORT          UserStatusValue;
        } Status;
    } u;
} NT_DLC_READ_PARMS, *PNT_DLC_READ_PARMS;

typedef struct _LLC_IOCTL_BUFFERS {
    USHORT  InputBufferSize;
    USHORT  OutputBufferSize;
} LLC_IOCTL_BUFFERS, *PLLC_IOCTL_BUFFERS;

//
//  This table is used by dlc driver and dlcapi dll modules.
//  In the application level debug version of dlc we link all modules
//  together and this table must be defined only once.  
//
#ifdef INCLUDE_IO_BUFFER_SIZE_TABLE

LLC_IOCTL_BUFFERS aDlcIoBuffers[IOCTL_DLC_LAST_COMMAND] = 
{
    {sizeof(NT_DLC_READ_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(LLC_RECEIVE_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_TRANSMIT_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_BUFFER_FREE_PARMS), 
     sizeof(NT_DLC_BUFFER_FREE_OUTPUT)},
    {sizeof(LLC_BUFFER_GET_PARMS), 
     sizeof(LLC_BUFFER_GET_PARMS)},
    {sizeof(LLC_BUFFER_CREATE_PARMS), 
     sizeof(PVOID)},
// DirInitialize included in DirClose
//    {sizeof( NT_DLC_CCB_INPUT ),
//     sizeof( NT_DLC_CCB_OUTPUT )},              // DIR.INITIALIZE
    {sizeof(LLC_DIR_SET_EFLAG_PARMS), 
     0},
    {sizeof( NT_DLC_CCB_INPUT ),
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.CLOSE.STATION
    {sizeof(NT_DLC_CONNECT_STATION_PARMS) + sizeof( NT_DLC_CCB ),
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_FLOW_CONTROL_PARMS), 
     0},
    {sizeof(NT_DLC_OPEN_STATION_PARMS), 
     sizeof( USHORT )},
    {sizeof( NT_DLC_CCB_INPUT ), 
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.RESET
    {sizeof(NT_DLC_COMMAND_CANCEL_PARMS), 
     0},                                        // READ.CANCEL
    {sizeof(NT_DLC_RECEIVE_CANCEL_PARMS), 
     0},
    {sizeof(NT_DLC_QUERY_INFORMATION_INPUT), 
     0},
    {sizeof( struct _DlcSetInfoHeader ), 
     0},
    {sizeof(NT_DLC_COMMAND_CANCEL_PARMS),       // TIMER.CANCEL
     0},
    {sizeof( NT_DLC_CCB_INPUT ),                // TIMER.CANCEL.GROUP
     sizeof( NT_DLC_CCB_OUTPUT )},              
    {sizeof( NT_DLC_CCB_INPUT ),                // DIR.TIMER.SET
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof(NT_DLC_OPEN_SAP_PARMS), 
     sizeof(NT_DLC_OPEN_SAP_PARMS)},
    {sizeof( NT_DLC_CCB_INPUT ),
     sizeof( NT_DLC_CCB_OUTPUT )},              // DLC.CLOSE.SAP
    {sizeof(LLC_DIR_OPEN_DIRECT_PARMS), 
     0},
    {sizeof( NT_DLC_CCB_INPUT ),               // DIR.CLOSE.DIRECT
     sizeof( NT_DLC_CCB_OUTPUT )},             
    {sizeof(NT_DIR_OPEN_ADAPTER_PARMS),         // DIR.OPEN.ADAPTER
     sizeof( LLC_ADAPTER_OPEN_PARMS )},
    {sizeof( NT_DLC_CCB_INPUT ),               // DIR.CLOSE.ADAPTER
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof( LLC_DLC_REALLOCATE_PARMS ),        // DLC.REALLOCATE
     sizeof( LLC_DLC_REALLOCATE_PARMS )},
    {sizeof( NT_DLC_READ_INPUT) + sizeof( LLC_CCB ),    // READ2
     sizeof( NT_DLC_READ_PARMS) + sizeof( LLC_CCB )},
    {sizeof( LLC_RECEIVE_PARMS) + sizeof( LLC_CCB ),    // RECEIVE2 
     sizeof( NT_DLC_CCB_OUTPUT )},
    {sizeof( NT_DLC_TRANSMIT_PARMS ) + sizeof( LLC_CCB ), // TRANSMIT2
     sizeof( NT_DLC_CCB_OUTPUT )}, 
    {sizeof( NT_DLC_COMPLETE_COMMAND_PARMS ),   // DLC.COMPLETE.COMMAND
     0},
//    {sizeof( LLC_TRACE_INITIALIZE_PARMS ) + sizeof( LLC_CCB ),
//     0},
//    {0, 0}
//    {sizeof( NT_NDIS_REQUEST_PARMS ),
//     sizeof( NT_NDIS_REQUEST_PARMS )}
};
#else

extern LLC_IOCTL_BUFFERS aDlcIoBuffers[];

#endif

//
//  All NT DLC API parameters in one structure
//
typedef union _NT_DLC_PARMS {
        NT_DLC_BUFFER_FREE_ALLOCATION   BufferFree;
        LLC_BUFFER_GET_PARMS            BufferGet;
        LLC_BUFFER_CREATE_PARMS         BufferCreate;
        NT_DLC_FLOW_CONTROL_PARMS       DlcFlowControl;
        NT_DLC_OPEN_STATION_PARMS       DlcOpenStation;
        NT_DLC_SET_INFORMATION_PARMS    DlcSetInformation;
        NT_DLC_QUERY_INFORMATION_PARMS  DlcGetInformation;
        NT_DLC_OPEN_SAP_PARMS           DlcOpenSap;
        LLC_DIR_SET_EFLAG_PARMS         DirSetExceptionFlags;
        NT_DLC_CANCEL_COMMAND_PARMS     DlcCancelCommand;
        NT_DLC_RECEIVE_CANCEL_PARMS     ReceiveCancel;
        USHORT                          StationId;
        NT_DLC_COMPLETE_COMMAND_PARMS   CompleteCommand;
        LLC_DLC_REALLOCATE_PARMS        DlcReallocate;
        LLC_DIR_OPEN_DIRECT_PARMS       DirOpenDirect;
        NT_DIR_OPEN_ADAPTER_PARMS       DirOpenAdapter;
//        NT_NDIS_REQUEST_PARMS           NdisRequest;
        LLC_DLC_STATISTICS_PARMS        DlcStatistics;
        LLC_ADAPTER_DLC_INFO            DlcAdapter;
        WCHAR                           UnicodePath[MAX_PATH];

        //
        //  At least DirTimerCancelGroup:
        //
        NT_DLC_CCB_INPUT                InputCcb;

        //
        //  Asynchronous parameters
        //
        //close sap/link/direct,reset, DirTimerSet;
        struct _ASYNC_DLC_PARMS {
            NT_DLC_CCB                          Ccb;
            union {
                UCHAR                           ByteBuffer[512];
                NT_DLC_CONNECT_STATION_PARMS    DlcConnectStation;
                NT_DLC_READ_INPUT               ReadInput;
                NT_DLC_READ_PARMS               Read;
                LLC_RECEIVE_PARMS               Receive;
                NT_DLC_TRANSMIT_ALLOCATION      Transmit;
//                NT_NDIS_REQUEST_PARMS           NdisRequest;
                LLC_TRACE_INITIALIZE_PARMS      TraceInitialize;
            } Parms;
        } Async;
} NT_DLC_PARMS, *PNT_DLC_PARMS;

LLC_STATUS
DlcCallDriver(
    IN UINT AdapterNumber,
    IN UINT IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
LLC_STATUS
NtAcsLan( 
    IN PLLC_CCB pCCB,
    IN PVOID pOrginalCcbAddress,
    OUT PLLC_CCB pOutputCcb,
    IN HANDLE EventHandle OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\dhcpds.h ===
//================================================================================
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  Author: RameshV
//  Description: This is the structure of the server information passed to
//  user via dhcpds.dll.
//================================================================================

#ifndef     _ST_SRVR_H_
#define     _ST_SRVR_H_

//BeginExport(typedef)
typedef     struct                 _DHCPDS_SERVER {
    DWORD                          Version;       // version of this structure -- currently zero
    LPWSTR                         ServerName;    // [DNS?] unique name for server
    DWORD                          ServerAddress; // ip address of server
    DWORD                          Flags;         // additional info -- state
    DWORD                          State;         // not used ...
    LPWSTR                         DsLocation;    // ADsPath to server object
    DWORD                          DsLocType;     // path relative? absolute? diff srvr?
}   DHCPDS_SERVER, *LPDHCPDS_SERVER, *PDHCPDS_SERVER;

typedef     struct                 _DHCPDS_SERVERS {
    DWORD                          Flags;         // not used currently.
    DWORD                          NumElements;   // # of elements in array
    LPDHCPDS_SERVER                Servers;       // array of server info
}   DHCPDS_SERVERS, *LPDHCPDS_SERVERS, *PDHCPDS_SERVERS;
//EndExport(typedef)

#endif      _ST_SRVR_H_

//================================================================================
//  end of file
//================================================================================
//========================================================================
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef CONVERT_NAMES
#define DhcpCreateSubnet DhcpCreateSubnetDS
#define DhcpSetSubnetInfo DhcpSetSubnetInfoDS
#define DhcpGetSubnetInfo DhcpGetSubnetInfoDS
#define DhcpEnumSubnets DhcpEnumSubnetsDS
#define DhcpDeleteSubnet DhcpDeleteSubnetDS
#define DhcpCreateOption DhcpCreateOptionDS
#define DhcpSetOptionInfo DhcpSetOptionInfoDS
#define DhcpGetOptionInfo DhcpGetOptionInfoDS
#define DhcpRemoveOption DhcpRemoveOptionDS
#define DhcpSetOptionValue DhcpSetOptionValueDS
#define DhcpGetOptionValue DhcpGetOptionValueDS
#define DhcpEnumOptionValues DhcpEnumOptionValuesDS
#define DhcpRemoveOptionValue DhcpRemoveOptionValueDS
#define DhcpEnumOptions DhcpEnumOptionsDS
#define DhcpSetOptionValues DhcpSetOptionValuesDS
#define DhcpAddSubnetElement DhcpAddSubnetElementDS
#define DhcpEnumSubnetElements DhcpEnumSubnetElementsDS
#define DhcpRemoveSubnetElement DhcpRemoveSubnetElementDS
#define DhcpAddSubnetElementV4 DhcpAddSubnetElementV4DS
#define DhcpEnumSubnetElementsV4 DhcpEnumSubnetElementsV4DS
#define DhcpRemoveSubnetElementV4 DhcpRemoveSubnetElementV4DS
#define DhcpSetSuperScopeV4 DhcpSetSuperScopeV4DS
#define DhcpGetSuperScopeInfoV4 DhcpGetSuperScopeInfoV4DS
#define DhcpDeleteSuperScopeV4 DhcpDeleteSuperScopeV4DS

#define DhcpSetClientInfo DhcpSetClientInfoDS
#define DhcpGetClientInfo DhcpGetClientInfoDS
#define DhcpSetClientInfoV4 DhcpSetClientInfoV4DS
#define DhcpGetClientInfoV4 DhcpGetClientInfoV4DS

#define DhcpCreateOptionV5 DhcpCreateOptionV5DS
#define DhcpSetOptionInfoV5 DhcpSetOptionInfoV5DS
#define DhcpGetOptionInfoV5 DhcpGetOptionInfoV5DS
#define DhcpEnumOptionsV5 DhcpEnumOptionsV5DS
#define DhcpRemoveOptionV5 DhcpRemoveOptionV5DS
#define DhcpSetOptionValueV5 DhcpSetOptionValueV5DS
#define DhcpSetOptionValuesV5 DhcpSetOptionValuesV5DS
#define DhcpGetOptionValueV5 DhcpGetOptionValueV5DS
#define DhcpEnumOptionValuesV5 DhcpEnumOptionValuesV5DS
#define DhcpRemoveOptionValueV5 DhcpRemoveOptionValueV5DS
#define DhcpCreateClass DhcpCreateClassDS
#define DhcpModifyClass DhcpModifyClassDS
#define DhcpDeleteClass DhcpDeleteClassDS
#define DhcpGetClassInfo DhcpGetClassInfoDS
#define DhcpEnumClasses DhcpEnumClassesDS
#define DhcpGetAllOptions DhcpGetAllOptionsDS
#define DhcpGetAllOptionValues DhcpGetAllOptionValuesDS

#endif  CONVERT_NAMES


//DOC Create an option in DS. Checkout DhcpDsCreateOptionDef for more info...
DWORD
DhcpCreateOptionV5(                               // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC Modify existing option's fields in the DS. See DhcpDsModifyOptionDef for more
//DOC details
DWORD
DhcpSetOptionInfoV5(                              // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


//DOC not yet supported at this level... (this is supported in a
//DOC DhcpDs function, no wrapper yet)
DWORD
DhcpGetOptionInfoV5(                              // retrieve option info from off ds structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory
) ;


//DOC See DhcpDsEnumOptionDefs for more info on this function.. but essentially, all this
//DOC does is to read thru the options and create a list of options..
DWORD
DhcpEnumOptionsV5(                                // create list of all options in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_ARRAY   *Options,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Delete an option from off the DS. See DhcpDsDeleteOptionDef for
//DOC more details.
DWORD
DhcpRemoveOptionV5(                               // remove an option from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


//DOC Set the specified option value in the DS.  For more information,
//DOC see DhcpDsSetOptionValue.
DWORD
DhcpSetOptionValueV5(                             // set the option value in ds
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


//DOC This function just calls the SetOptionValue function N times.. this is not
//DOC atomic (), but even worse, it is highly inefficient, as it creates the
//DOC required objects over and over again!!!!!
//DOC This has to be fixed..
DWORD
DhcpSetOptionValuesV5(                            // set a series of option values
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


//DOC This function retrives the value of an option from the DS.  For more info,
//DOC pl check DhcpDsGetOptionValue.
DWORD
DhcpGetOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue
) ;


//DOC Get the list of option values defined in DS. For more information,
//DOC check DhcpDsEnumOptionValues.
DWORD
DhcpEnumOptionValuesV5(                           // get list of options defined in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


//DOC Remove the option value from off the DS.  See DhcpDsRemoveOptionValue
//DOC for further information.
DWORD
DhcpRemoveOptionValueV5(                          // remove option value from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC Create a class in the DS.  Please see DhcpDsCreateClass for more
//DOC details on this function.
DWORD
DhcpCreateClass(                                  // create a class in DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Modify an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpModifyClass(                                  // modify existing class
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


//DOC Delete an existing class in DS.  Please see DhcpDsModifyClass for more
//DOC details on this function (this is just a wrapper).
DWORD
DhcpDeleteClass(                                  // delete a class from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


//DOC DhcpGetClassInfo completes the information provided for a class in struct
//DOC PartialClassInfo.  For more details pl see DhcpDsGetClassInfo.
DWORD
DhcpGetClassInfo(                                 // fetch complete info frm DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpEnumClasses(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


//DOC This is implemented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


//DOC This is implememented in the DHCPDS module, but not exported here yet..
DWORD
DhcpGetAllOptions(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
DhcpCreateOption(                                 // create a new option (must not exist)
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpSetOptionInfo(                                // Modify existing option's fields
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
DhcpGetOptionInfo(                                // retrieve the information from off the mem structures
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
DhcpEnumOptions(                                  // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
DhcpRemoveOption(                                 // remove the option definition from the registry
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
DhcpSetOptionValue(                               // replace or add a new option value
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
DhcpSetOptionValues(                              // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
DhcpGetOptionValue(                               // fetch the required option at required level
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
DhcpEnumOptionValues(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


//DOC This function sets the superscope of a subnet, thereby creating the superscope
//DOC if required.  Please see DhcpDsSetSScope for more details.
DWORD
DhcpSetSuperScopeV4(                              // set superscope in DS.
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


//DOC This function removes the superscope, and resets any subnet with this
//DOC superscope.. so that all those subnets end up with no superscopes..
//DOC Please see DhcpDsDelSScope for more details.
DWORD
DhcpDeleteSuperScopeV4(                           // delete subnet sscope from DS
    IN      LPWSTR                 ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


//DOC This function retrievs the supercsope info for each subnet that is
//DOC present for the given server.  Please see DhcpDsGetSScopeInfo for more
//DOC details on this..
DWORD
DhcpGetSuperScopeInfoV4(                          // get sscope tbl from DS
    IN      LPWSTR                 ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


//DOC This function creates a subnet in the DS with the specified params.
//DOC Please see DhcpDsServerAddSubnet for more details on this function.
DWORD
DhcpCreateSubnet(                                 // add subnet 2 DS for this srvr
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Modify existing subnet with new parameters... some restrictions apply.
//DOC Please see DhcpDsServerModifySubnet for further details.
DWORD
DhcpSetSubnetInfo(                                // modify existing subnet params
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpGetSubnetInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


//DOC Implemented in the DHCPDS module but not exported thru here
DWORD
DhcpEnumSubnets(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


//DOC This function deletes the subnet from the DS.  For further information, pl
//DOC see DhcpDsServerDelSubnet..
DWORD
DhcpDeleteSubnet(                                 // Del subnet from off DS
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function sets some particular information for RESERVATIONS only
//DOC all other stuff it just ignores and returns success..
DWORD
DhcpSetClientInfo(
    IN      LPWSTR                 ServerIpAddresess,
    IN      LPDHCP_CLIENT_INFO     ClientInfo
) ;


//DOC This function retrieves some particular client's information
//DOC for RESERVATIONS only.. For all other stuff it returns CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfo(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_SEARCH_INFO     SearchInfo,
    OUT      LPDHCP_CLIENT_INFO    *ClientInfo
) ;


//DOC This function sets the client informatoin for RESERVATIONS only in DS
//DOC For all toher clients it returns ERROR_SUCCESS w/o doing anything
DWORD
DhcpSetClientInfoV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_CLIENT_INFO_V4  ClientInfo
) ;


//DOC Thsi function sets the client information for RESERVATIONS only
//DOC For all others it returns ERROR_CALL_NOT_IMPLEMENTED
DWORD
DhcpGetClientInfoV4(
    IN     LPWSTR                  ServerIpAddress,
    IN     LPDHCP_SEARCH_INFO      SearchInfo,
    OUT    LPDHCP_CLIENT_INFO_V4  *ClientInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElement(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA  AddElementInfo
) ;


//DOC This function adds a subnet element to a subnet in the DS.
DWORD
DhcpAddSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElementsV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This is not yet implemented here..
DWORD
DhcpEnumSubnetElements(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElement(                          // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


//DOC This function removes either an exclusion, ip range or reservation
//DOC from the subnet... in the DS.
DWORD
DhcpRemoveSubnetElementV4(                        // remove subnet element
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;


#ifndef CONVERT_NAMES
#undef DhcpCreateSubnet
#undef DhcpSetSubnetInfo
#undef DhcpGetSubnetInfo
#undef DhcpEnumSubnets
#undef DhcpDeleteSubnet
#undef DhcpCreateOption
#undef DhcpSetOptionInfo
#undef DhcpGetOptionInfo
#undef DhcpRemoveOption
#undef DhcpSetOptionValue
#undef DhcpGetOptionValue
#undef DhcpEnumOptionValues
#undef DhcpRemoveOptionValue
#undef DhcpEnumOptions
#undef DhcpSetOptionValues
#undef DhcpAddSubnetElementV4
#undef DhcpEnumSubnetElementsV4
#undef DhcpRemoveSubnetElementV4
#undef DhcpAddSubnetElement
#undef DhcpEnumSubnetElements
#undef DhcpRemoveSubnetElement
#undef DhcpSetSuperScopeV4
#undef DhcpGetSuperScopeInfoV4
#undef DhcpDeleteSuperScopeV4

#undef DhcpSetClientInfo
#undef DhcpGetClientInfo
#undef DhcpSetClientInfoV4
#undef DhcpGetClientInfoV4

#undef DhcpCreateOptionV5
#undef DhcpSetOptionInfoV5
#undef DhcpGetOptionInfoV5
#undef DhcpEnumOptionsV5
#undef DhcpRemoveOptionV5
#undef DhcpSetOptionValueV5
#undef DhcpSetOptionValuesV5
#undef DhcpGetOptionValueV5
#undef DhcpEnumOptionValuesV5
#undef DhcpRemoveOptionValueV5
#undef DhcpCreateClass
#undef DhcpModifyClass
#undef DhcpDeleteClass
#undef DhcpGetClassInfo
#undef DhcpEnumClasses
#undef DhcpGetAllOptions
#undef DhcpGetAllOptionValues
#endif CONVERT_NAMES


#define     DHCP_SERVER_ANOTHER_ENTERPRISE        0x01
typedef     DHCPDS_SERVER          DHCP_SERVER_INFO;
typedef     PDHCPDS_SERVER         PDHCP_SERVER_INFO;
typedef     LPDHCPDS_SERVER        LPDHCP_SERVER_INFO;

typedef     DHCPDS_SERVERS         DHCP_SERVER_INFO_ARRAY;
typedef     PDHCPDS_SERVERS        PDHCP_SERVER_INFO_ARRAY;
typedef     LPDHCPDS_SERVERS       LPDHCP_SERVER_INFO_ARRAY;


//DOC DhcpEnumServersDS lists the servers found in the DS along with the
//DOC addresses and other information.  The whole server is allocated as a blob,
//DOC and should be freed in one shot.  No parameters are currently used, other
//DOC than Servers which will be an OUT parameter only.
DWORD
DhcpEnumServersDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    OUT     LPDHCP_SERVER_INFO_ARRAY *Servers,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpAddServerDS adds a particular server to the DS.  If the server exists,
//DOC then, this returns error.  If the server does not exist, then this function
//DOC adds the server in DS, and also uploads the configuration from the server
//DOC to the ds.
DWORD
DhcpAddServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDeleteServerDS deletes the servers from off the DS and recursively
//DOC deletes the server object..(i.e everything belonging to the server is deleted).
//DOC If the server does not exist, it returns an error.
DWORD
DhcpDeleteServerDS(
    IN      DWORD                  Flags,
    IN      LPVOID                 IdInfo,
    IN      LPDHCP_SERVER_INFO     NewServer,
    IN      LPVOID                 CallbackFn,
    IN      LPVOID                 CallbackData
) ;


//DOC DhcpDsInitDS initializes everything in this module.
DWORD
DhcpDsInitDS(
    DWORD                          Flags,
    LPVOID                         IdInfo
) ;


//DOC DhcpDsCleanupDS uninitiailzes everything in this module.
VOID
DhcpDsCleanupDS(
    VOID
) ;


//DOC This function is defined in validate.c
//DOC Only the stub is here.
DWORD
DhcpDsValidateService(                            // check to validate for dhcp
    IN      LPWSTR                 Domain,
    IN      DWORD                 *Addresses OPTIONAL,
    IN      ULONG                  nAddresses,
    IN      LPWSTR                 UserName,
    IN      LPWSTR                 Password,
    IN      DWORD                  AuthFlags,
    OUT     LPBOOL                 Found,
    OUT     LPBOOL                 IsStandAlone
);

//DOC DhcpDsGetLastUpdateTime is defined in upndown.c --> see there for more details.
DWORD
DhcpDsGetLastUpdateTime(                          // last update time for server
    IN      LPWSTR                 ServerName,    // this is server of interest
    IN OUT  LPFILETIME             Time           // fill in this w./ the time
);

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ftpd.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpd.h

    This file contains constants & type definitions shared between the
    FTPD Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _FTPD_H_
#define _FTPD_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


//
//  Service name.
//

#define FTPD_SERVICE_NAME_A              "FTPSVC"
#define FTPD_SERVICE_NAME_W             L"FTPSVC"


//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define FTPD_ANNOTATION_FILE_A           "~FTPSVC~.CKM"
#define FTPD_ANNOTATION_FILE_W          L"~FTPSVC~.CKM"


//
//  Name of the log file, used for logging file accesses.
//

#define FTPD_LOG_FILE_A                  "FTPSVC.LOG"
#define FTPD_LOG_FILE_W                 L"FTPSVC.LOG"


//
//  Configuration parameters registry key.
//

#define FTPD_PARAMETERS_KEY_A \
             "System\\CurrentControlSet\\Services\\FtpSvc\\Parameters"

#define FTPD_PARAMETERS_KEY_W \
            L"System\\CurrentControlSet\\Services\\FtpSvc\\Parameters"


//
//  Performance key.
//

#define FTPD_PERFORMANCE_KEY_A \
             "System\\CurrentControlSet\\Services\\FtpSvc\\Performance"

#define FTPD_PERFORMANCE_KEY_W \
            L"System\\CurrentControlSet\\Services\\FtpSvc\\Performance"


//
//  If this registry key exists under the FtpSvc\Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//

#define FTPD_ACCESS_KEY_A                "AccessCheck"
#define FTPD_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define FTPD_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define FTPD_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define FTPD_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define FTPD_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define FTPD_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define FTPD_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define FTPD_LOG_ANONYMOUS_A             "LogAnonymous"
#define FTPD_LOG_ANONYMOUS_W            L"LogAnonymous"

#define FTPD_LOG_NONANONYMOUS_A          "LogNonAnonymous"
#define FTPD_LOG_NONANONYMOUS_W         L"LogNonAnonymous"

#define FTPD_ANONYMOUS_USERNAME_A        "AnonymousUserName"
#define FTPD_ANONYMOUS_USERNAME_W       L"AnonymousUserName"

#define FTPD_HOME_DIRECTORY_A            "HomeDirectory"
#define FTPD_HOME_DIRECTORY_W           L"HomeDirectory"

#define FTPD_MAX_CONNECTIONS_A           "MaxConnections"
#define FTPD_MAX_CONNECTIONS_W          L"MaxConnections"

#define FTPD_READ_ACCESS_MASK_A          "ReadAccessMask"
#define FTPD_READ_ACCESS_MASK_W         L"ReadAccessMask"

#define FTPD_WRITE_ACCESS_MASK_A         "WriteAccessMask"
#define FTPD_WRITE_ACCESS_MASK_W        L"WriteAccessMask"

#define FTPD_CONNECTION_TIMEOUT_A        "ConnectionTimeout"
#define FTPD_CONNECTION_TIMEOUT_W       L"ConnectionTimeout"

#define FTPD_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define FTPD_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define FTPD_GREETING_MESSAGE_A          "GreetingMessage"
#define FTPD_GREETING_MESSAGE_W         L"GreetingMessage"

#define FTPD_EXIT_MESSAGE_A              "ExitMessage"
#define FTPD_EXIT_MESSAGE_W             L"ExitMessage"

#define FTPD_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define FTPD_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define FTPD_DEBUG_FLAGS_A               "DebugFlags"
#define FTPD_DEBUG_FLAGS_W              L"DebugFlags"

#define FTPD_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define FTPD_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define FTPD_LOWERCASE_FILES_A           "LowercaseFiles"
#define FTPD_LOWERCASE_FILES_W          L"LowercaseFiles"

#define FTPD_LOG_FILE_ACCESS_A           "LogFileAccess"
#define FTPD_LOG_FILE_ACCESS_W          L"LogFileAccess"

#define FTPD_LOG_FILE_DIRECTORY_A        "LogFileDirectory"
#define FTPD_LOG_FILE_DIRECTORY_W       L"LogFileDirectory"

#define FTPD_LISTEN_BACKLOG_A            "ListenBacklog"
#define FTPD_LISTEN_BACKLOG_W           L"ListenBacklog"

#define FTPD_ENABLE_LICENSING_A          "EnableLicensing"
#define FTPD_ENABLE_LICENSING_W         L"EnableLicensing"

#define FTPD_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define FTPD_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"

#define FTPD_ENABLE_PORT_ATTACK_A        "EnablePortAttack"
#define FTPD_ENABLE_PORT_ATTACK_W       L"EnablePortAttack"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define FTPD_ANONYMOUS_SECRET_A          "FTPD_ANONYMOUS_DATA"
#define FTPD_ANONYMOUS_SECRET_W         L"FTPD_ANONYMOUS_DATA"

#define FTPD_ROOT_SECRET_A               "FTPD_ROOT_DATA"
#define FTPD_ROOT_SECRET_W              L"FTPD_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define FTPD_SERVICE_NAME               FTPD_SERVICE_NAME_W
#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_W
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_W
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_W
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_W
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_W
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_W
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_W
#define FTPD_LOG_ANONYMOUS              FTPD_LOG_ANONYMOUS_W
#define FTPD_LOG_NONANONYMOUS           FTPD_LOG_NONANONYMOUS_W
#define FTPD_ANONYMOUS_USERNAME         FTPD_ANONYMOUS_USERNAME_W
#define FTPD_HOME_DIRECTORY             FTPD_HOME_DIRECTORY_W
#define FTPD_MAX_CONNECTIONS            FTPD_MAX_CONNECTIONS_W
#define FTPD_READ_ACCESS_MASK           FTPD_READ_ACCESS_MASK_W
#define FTPD_WRITE_ACCESS_MASK          FTPD_WRITE_ACCESS_MASK_W
#define FTPD_CONNECTION_TIMEOUT         FTPD_CONNECTION_TIMEOUT_W
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_W
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_W
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_W
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_W
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_W
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_W
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_W
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_W
#define FTPD_LOG_FILE_ACCESS            FTPD_LOG_FILE_ACCESS_W
#define FTPD_LOG_FILE                   FTPD_LOG_FILE_W
#define FTPD_LOG_FILE_DIRECTORY         FTPD_LOG_FILE_DIRECTORY_W
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_W
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_W
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_W
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_W

#else   // !UNICODE

#define FTPD_SERVICE_NAME               FTPD_SERVICE_NAME_A
#define FTPD_ANNOTATION_FILE            FTPD_ANNOTATION_FILE_A
#define FTPD_PARAMETERS_KEY             FTPD_PARAMETERS_KEY_A
#define FTPD_PERFORMANCE_KEY            FTPD_PERFORMANCE_KEY_A
#define FTPD_ACCESS_KEY                 FTPD_ACCESS_KEY_A
#define FTPD_ANONYMOUS_ONLY             FTPD_ANONYMOUS_ONLY_A
#define FTPD_LOG_ANONYMOUS              FTPD_LOG_ANONYMOUS_A
#define FTPD_LOG_NONANONYMOUS           FTPD_LOG_NONANONYMOUS_A
#define FTPD_ALLOW_ANONYMOUS            FTPD_ALLOW_ANONYMOUS_A
#define FTPD_ALLOW_GUEST_ACCESS         FTPD_ALLOW_GUEST_ACCESS_A
#define FTPD_ANONYMOUS_USERNAME         FTPD_ANONYMOUS_USERNAME_A
#define FTPD_HOME_DIRECTORY             FTPD_HOME_DIRECTORY_A
#define FTPD_MAX_CONNECTIONS            FTPD_MAX_CONNECTIONS_A
#define FTPD_READ_ACCESS_MASK           FTPD_READ_ACCESS_MASK_A
#define FTPD_WRITE_ACCESS_MASK          FTPD_WRITE_ACCESS_MASK_A
#define FTPD_CONNECTION_TIMEOUT         FTPD_CONNECTION_TIMEOUT_A
#define FTPD_MSDOS_DIR_OUTPUT           FTPD_MSDOS_DIR_OUTPUT_A
#define FTPD_GREETING_MESSAGE           FTPD_GREETING_MESSAGE_A
#define FTPD_EXIT_MESSAGE               FTPD_EXIT_MESSAGE_A
#define FTPD_MAX_CLIENTS_MSG            FTPD_MAX_CLIENTS_MSG_A
#define FTPD_DEBUG_FLAGS                FTPD_DEBUG_FLAGS_A
#define FTPD_ANNOTATE_DIRS              FTPD_ANNOTATE_DIRS_A
#define FTPD_ANONYMOUS_SECRET           FTPD_ANONYMOUS_SECRET_A
#define FTPD_LOWERCASE_FILES            FTPD_LOWERCASE_FILES_A
#define FTPD_LOG_FILE_ACCESS            FTPD_LOG_FILE_ACCESS_A
#define FTPD_LOG_FILE                   FTPD_LOG_FILE_A
#define FTPD_LOG_FILE_DIRECTORY         FTPD_LOG_FILE_DIRECTORY_A
#define FTPD_LISTEN_BACKLOG             FTPD_LISTEN_BACKLOG_A
#define FTPD_ENABLE_LICENSING           FTPD_ENABLE_LICENSING_A
#define FTPD_DEFAULT_LOGON_DOMAIN       FTPD_DEFAULT_LOGON_DOMAIN_A
#define FTPD_ENABLE_PORT_ATTACK         FTPD_ENABLE_PORT_ATTACK_A

#endif  // UNICODE


//
//  Values for LogFileAccess
//

#define FTPD_LOG_DISABLED   0
#define FTPD_LOG_SINGLE     1
#define FTPD_LOG_DAILY      2


//
// Structures for APIs
//

typedef struct _FTP_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} FTP_USER_INFO, * LPFTP_USER_INFO;

typedef struct _FTP_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} FTP_STATISTICS_0, * LPFTP_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    );

NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _FTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\hnetbcon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for hnetbcon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hnetbcon_h__
#define __hnetbcon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInternetConnectionDevice_FWD_DEFINED__
#define __IInternetConnectionDevice_FWD_DEFINED__
typedef interface IInternetConnectionDevice IInternetConnectionDevice;
#endif 	/* __IInternetConnectionDevice_FWD_DEFINED__ */


#ifndef __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__
#define __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__
typedef interface IInternetConnectionDeviceSharedConnection IInternetConnectionDeviceSharedConnection;
#endif 	/* __IInternetConnectionDeviceSharedConnection_FWD_DEFINED__ */


#ifndef __IInternetConnectionDeviceClient_FWD_DEFINED__
#define __IInternetConnectionDeviceClient_FWD_DEFINED__
typedef interface IInternetConnectionDeviceClient IInternetConnectionDeviceClient;
#endif 	/* __IInternetConnectionDeviceClient_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_hnetbcon_0000 */
/* [local] */ 

//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

EXTERN_C const CLSID CLSID_InternetConnectionBeaconService;





extern RPC_IF_HANDLE __MIDL_itf_hnetbcon_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetbcon_0000_v0_0_s_ifspec;

#ifndef __IInternetConnectionDevice_INTERFACE_DEFINED__
#define __IInternetConnectionDevice_INTERFACE_DEFINED__

/* interface IInternetConnectionDevice */
/* [unique][helpstring][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagICS_OS_VER
    {	WINDOWS_OS	= 1,
	WINME_OS	= 2,
	WINNT_OS	= 3,
	OTHER_OS	= 4,
	UNK_OS	= 5
    } 	ICS_OS_VER;


EXTERN_C const IID IID_IInternetConnectionDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6137-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsICSDeviceAvailable( 
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceNameInfo( 
            /* [string][out] */ LPOLESTR *ppszMachineName,
            /* [string][out] */ LPOLESTR *ppszDomainName,
            /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceSystemTime( 
            /* [out] */ FILETIME *pTime,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetICSDeviceOSVersion( 
            /* [out] */ ICS_OS_VER *pOSVersion,
            /* [out] */ DWORD *pdwOSMajorVersion,
            /* [out] */ DWORD *pdwOSMinorVersion,
            /* [out] */ DWORD *pdwOSBuildNumber,
            /* [string][out] */ LPOLESTR *ppszOSName,
            /* [string][out] */ LPOLESTR *ppszPlatformName,
            /* [in] */ BOOL fBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsICSDeviceAvailable )( 
            IInternetConnectionDevice * This,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceNameInfo )( 
            IInternetConnectionDevice * This,
            /* [string][out] */ LPOLESTR *ppszMachineName,
            /* [string][out] */ LPOLESTR *ppszDomainName,
            /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceSystemTime )( 
            IInternetConnectionDevice * This,
            /* [out] */ FILETIME *pTime,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetICSDeviceOSVersion )( 
            IInternetConnectionDevice * This,
            /* [out] */ ICS_OS_VER *pOSVersion,
            /* [out] */ DWORD *pdwOSMajorVersion,
            /* [out] */ DWORD *pdwOSMinorVersion,
            /* [out] */ DWORD *pdwOSBuildNumber,
            /* [string][out] */ LPOLESTR *ppszOSName,
            /* [string][out] */ LPOLESTR *ppszPlatformName,
            /* [in] */ BOOL fBlock);
        
        END_INTERFACE
    } IInternetConnectionDeviceVtbl;

    interface IInternetConnectionDevice
    {
        CONST_VTBL struct IInternetConnectionDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDevice_IsICSDeviceAvailable(This,fBlock)	\
    (This)->lpVtbl -> IsICSDeviceAvailable(This,fBlock)

#define IInternetConnectionDevice_GetICSDeviceNameInfo(This,ppszMachineName,ppszDomainName,ppszSharedAdapterName,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceNameInfo(This,ppszMachineName,ppszDomainName,ppszSharedAdapterName,fBlock)

#define IInternetConnectionDevice_GetICSDeviceSystemTime(This,pTime,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceSystemTime(This,pTime,fBlock)

#define IInternetConnectionDevice_GetICSDeviceOSVersion(This,pOSVersion,pdwOSMajorVersion,pdwOSMinorVersion,pdwOSBuildNumber,ppszOSName,ppszPlatformName,fBlock)	\
    (This)->lpVtbl -> GetICSDeviceOSVersion(This,pOSVersion,pdwOSMajorVersion,pdwOSMinorVersion,pdwOSBuildNumber,ppszOSName,ppszPlatformName,fBlock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_IsICSDeviceAvailable_Proxy( 
    IInternetConnectionDevice * This,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_IsICSDeviceAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceNameInfo_Proxy( 
    IInternetConnectionDevice * This,
    /* [string][out] */ LPOLESTR *ppszMachineName,
    /* [string][out] */ LPOLESTR *ppszDomainName,
    /* [string][out] */ LPOLESTR *ppszSharedAdapterName,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceNameInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceSystemTime_Proxy( 
    IInternetConnectionDevice * This,
    /* [out] */ FILETIME *pTime,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceSystemTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDevice_GetICSDeviceOSVersion_Proxy( 
    IInternetConnectionDevice * This,
    /* [out] */ ICS_OS_VER *pOSVersion,
    /* [out] */ DWORD *pdwOSMajorVersion,
    /* [out] */ DWORD *pdwOSMinorVersion,
    /* [out] */ DWORD *pdwOSBuildNumber,
    /* [string][out] */ LPOLESTR *ppszOSName,
    /* [string][out] */ LPOLESTR *ppszPlatformName,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDevice_GetICSDeviceOSVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDevice_INTERFACE_DEFINED__ */


#ifndef __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__
#define __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__

/* interface IInternetConnectionDeviceSharedConnection */
/* [unique][helpstring][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagICS_CONN_DIAL_STATE
    {	STARTING	= 1,
	CONNECTING	= 2,
	CONNECTED	= 3,
	DISCONNECTING	= 4,
	DISCONNECTED	= 5,
	STOPPED	= 6,
	PERMANENT	= 7,
	UNK_DIAL_STATE	= 8,
	CALLWAITING	= 9
    } 	ICS_CONN_DIAL_STATE;

typedef /* [v1_enum] */ 
enum tagICS_CONN_TYPE
    {	LAN	= 1,
	RAS	= 2,
	UNK_CONN_TYPE	= 3
    } 	ICS_CONN_TYPE;


EXTERN_C const IID IID_IInternetConnectionDeviceSharedConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6138-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDeviceSharedConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDialState( 
            /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInfo( 
            /* [out] */ ULONGLONG *pBytesSent,
            /* [out] */ ULONGLONG *pBytesRecv,
            /* [out] */ ULONGLONG *pPktsSent,
            /* [out] */ ULONGLONG *pPktsRecv,
            /* [out] */ ULONGLONG *pUptime,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionSpeed( 
            /* [out] */ DWORD *pdwBps,
            /* [in] */ BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionType( 
            /* [out] */ ICS_CONN_TYPE *pConnectionType,
            /* [in] */ BOOL fBlock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceSharedConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IInternetConnectionDeviceSharedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDialState )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionInfo )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ULONGLONG *pBytesSent,
            /* [out] */ ULONGLONG *pBytesRecv,
            /* [out] */ ULONGLONG *pPktsSent,
            /* [out] */ ULONGLONG *pPktsRecv,
            /* [out] */ ULONGLONG *pUptime,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionSpeed )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ DWORD *pdwBps,
            /* [in] */ BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionType )( 
            IInternetConnectionDeviceSharedConnection * This,
            /* [out] */ ICS_CONN_TYPE *pConnectionType,
            /* [in] */ BOOL fBlock);
        
        END_INTERFACE
    } IInternetConnectionDeviceSharedConnectionVtbl;

    interface IInternetConnectionDeviceSharedConnection
    {
        CONST_VTBL struct IInternetConnectionDeviceSharedConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDeviceSharedConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDeviceSharedConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDeviceSharedConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDeviceSharedConnection_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#define IInternetConnectionDeviceSharedConnection_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IInternetConnectionDeviceSharedConnection_GetDialState(This,pDialState,fBlock)	\
    (This)->lpVtbl -> GetDialState(This,pDialState,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionInfo(This,pBytesSent,pBytesRecv,pPktsSent,pPktsRecv,pUptime,fBlock)	\
    (This)->lpVtbl -> GetConnectionInfo(This,pBytesSent,pBytesRecv,pPktsSent,pPktsRecv,pUptime,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionSpeed(This,pdwBps,fBlock)	\
    (This)->lpVtbl -> GetConnectionSpeed(This,pdwBps,fBlock)

#define IInternetConnectionDeviceSharedConnection_GetConnectionType(This,pConnectionType,fBlock)	\
    (This)->lpVtbl -> GetConnectionType(This,pConnectionType,fBlock)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_Connect_Proxy( 
    IInternetConnectionDeviceSharedConnection * This);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_Disconnect_Proxy( 
    IInternetConnectionDeviceSharedConnection * This);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetDialState_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ICS_CONN_DIAL_STATE *pDialState,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetDialState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionInfo_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ULONGLONG *pBytesSent,
    /* [out] */ ULONGLONG *pBytesRecv,
    /* [out] */ ULONGLONG *pPktsSent,
    /* [out] */ ULONGLONG *pPktsRecv,
    /* [out] */ ULONGLONG *pUptime,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionSpeed_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ DWORD *pdwBps,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceSharedConnection_GetConnectionType_Proxy( 
    IInternetConnectionDeviceSharedConnection * This,
    /* [out] */ ICS_CONN_TYPE *pConnectionType,
    /* [in] */ BOOL fBlock);


void __RPC_STUB IInternetConnectionDeviceSharedConnection_GetConnectionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDeviceSharedConnection_INTERFACE_DEFINED__ */


#ifndef __IInternetConnectionDeviceClient_INTERFACE_DEFINED__
#define __IInternetConnectionDeviceClient_INTERFACE_DEFINED__

/* interface IInternetConnectionDeviceClient */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInternetConnectionDeviceClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04df6139-5610-11d4-9ec8-00b0d022dd1f")
    IInternetConnectionDeviceClient : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapterGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetConnectionDeviceClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetConnectionDeviceClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetConnectionDeviceClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetConnectionDeviceClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapterGuid )( 
            IInternetConnectionDeviceClient * This,
            /* [out] */ GUID **ppGuid);
        
        END_INTERFACE
    } IInternetConnectionDeviceClientVtbl;

    interface IInternetConnectionDeviceClient
    {
        CONST_VTBL struct IInternetConnectionDeviceClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetConnectionDeviceClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternetConnectionDeviceClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternetConnectionDeviceClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternetConnectionDeviceClient_GetAdapterGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetAdapterGuid(This,ppGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternetConnectionDeviceClient_GetAdapterGuid_Proxy( 
    IInternetConnectionDeviceClient * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IInternetConnectionDeviceClient_GetAdapterGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternetConnectionDeviceClient_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\hostannc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    hostannc.h

Abstract:

    This module defines the data structures related to host announcements.

Author:

    Larry Osterman (LarryO) 22-Oct-1990

Revision History:

    22-Oct-1991  LarryO

        Created

--*/

#ifndef _HOSTANNC_
#define _HOSTANNC_


typedef enum _MailslotType {
    MailslotTransaction = -2,
    OtherTransaction = -1,
    Illegal = 0,
    HostAnnouncement = 1,
    AnnouncementRequest = 2,
    InterrogateInfoRequest = 3,
    RelogonRequest = 4,
    Election = 8,
    GetBackupListReq = 9,
    GetBackupListResp = 10,
    BecomeBackupServer = 11,
    WkGroupAnnouncement = 12,
    MasterAnnouncement = 13,
    ResetBrowserState = 14,
    LocalMasterAnnouncement = 15,
    MaximumMailslotType
} MAILSLOTTYPE, *PMAILSLOTTYPE;

#define WORKSTATION_SIGNATURE       '\0'
#define SERVER_SIGNATURE            ' '
#define PRIMARY_DOMAIN_SIGNATURE    '\0'
#define PRIMARY_CONTROLLER_SIGNATURE '\x1B'
#define DOMAIN_CONTROLLER_SIGNATURE '\x1C'
#define MASTER_BROWSER_SIGNATURE    '\x1D'
#define BROWSER_ELECTION_SIGNATURE  '\x1E'
#define DOMAIN_ANNOUNCEMENT_NAME    "\x01\x02__MSBROWSE__\x02\x01"
//
//  The following values should be the minimum and maximum of the
//  mailslot transaction opcodes defined above.
//

#define MIN_TRANSACT_MS_OPCODE          MailslotTransaction
#define MAX_TRANSACT_MS_OPCODE          RelogonRequest

//
//  Common name for reserved, `internal' transactions
//

#define MAILSLOT_LANMAN_NAME SMB_MAILSLOT_PREFIX "\\LANMAN"
#define MAILSLOT_BROWSER_NAME SMB_MAILSLOT_PREFIX "\\BROWSE"
#define ANNOUNCEMENT_MAILSLOT_NAME     "\\\\*" ITRANS_MS_NAME


#include <packon.h>
//
// Each visible server on the net periodically emits a host announcement.
// This is a SMB TRANSACTION REQUEST on a reserved, "internal" name.
//

//
//  There are two versions of each of these structures defined.  The first,
//  is the actual "meat" of the structure, the second includes the announcement
//  type.
//

//
// Lan Manager announcement message.  This is used for opcodes:
//
//  HostAnnouncement to \MAILSLOT\LANMAN on the LANMAN domain name.
//

typedef struct _HOST_ANNOUNCE_PACKET_1 {
    UCHAR       CompatibilityPad;
    ULONG       Type;
    UCHAR       VersionMajor;   /* version of LM running on host */
    UCHAR       VersionMinor;   /*  "  "   "   "    "    "    "   */
    USHORT      Periodicity;   /* announcement cycle in secs   */
    CHAR        NameComment[LM20_CNLEN+1+LM20_MAXCOMMENTSZ+1];
} HOST_ANNOUNCE_PACKET_1, *PHOST_ANNOUNCE_PACKET_1;

typedef struct _HOST_ANNOUNCE_PACKET {
    UCHAR       AnnounceType;
    HOST_ANNOUNCE_PACKET_1 HostAnnouncement;
} HOST_ANNOUNCE_PACKET, *PHOST_ANNOUNCE_PACKET;

//
// General announcement message.  This is used for opcodes:
//
//  HostAnnouncement, WkGroupAnnouncement, and LocalMasterAnnouncement
//

typedef struct _BROWSE_ANNOUNCE_PACKET_1 {
    UCHAR       UpdateCount;    // Inc'ed when announce data changed.
    ULONG       Periodicity;    // announcement cycle in milliseconds

    UCHAR       ServerName[LM20_CNLEN+1];
    UCHAR       VersionMajor;
    UCHAR       VersionMinor;   /*  "  "   "   "    "    "    "   */
    ULONG       Type;           // Server type.
    DWORD       CommentPointer; // Not really a pointer, its a 32 bit number
    CHAR        Comment[LM20_MAXCOMMENTSZ+1];
} BROWSE_ANNOUNCE_PACKET_1, *PBROWSE_ANNOUNCE_PACKET_1;

typedef struct _BROWSE_ANNOUNCE_PACKET {
    UCHAR       BrowseType;
    BROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement;
} BROWSE_ANNOUNCE_PACKET, *PBROWSE_ANNOUNCE_PACKET;
//
//  The request announcement packet is sent by clients to request that
//  remote servers announce themselves.
//

typedef struct _REQUEST_ANNOUNCE_PACKET_1 {      // Contents of request announcement
    UCHAR    Flags;                 // Unused Flags
    CHAR     Reply[LM20_CNLEN+1];
}  REQUEST_ANNOUNCE_PACKET_1, *PREQUEST_ANNOUNCE_PACKET_1;

typedef struct _REQUEST_ANNOUNCE_PACKET {        /* Request announcement struct */
    UCHAR   Type;
    REQUEST_ANNOUNCE_PACKET_1    RequestAnnouncement;
} REQUEST_ANNOUNCE_PACKET, *PREQUEST_ANNOUNCE_PACKET;

#define HOST_ANNC_NAME(xx)     ((xx)->NameComment)
#define HOST_ANNC_COMMENT(xx)  ((xx)->NameComment + (strlen(HOST_ANNC_NAME(xx))+1))

#define BROWSE_ANNC_NAME(xx)     ((xx)->ServerName)
#define BROWSE_ANNC_COMMENT(xx)  ((xx)->Comment)

//
//  Definitions for Windows Browser
//

//
//  Request to retrieve a backup server list.
//

typedef struct _BACKUP_LIST_REQUEST_1 {
    UCHAR       RequestedCount;
    ULONG       Token;
} BACKUP_LIST_REQUEST_1, *PBACKUP_LIST_REQUEST_1;


typedef struct _BACKUP_LIST_REQUEST {
    UCHAR  Type;
    BACKUP_LIST_REQUEST_1 BackupListRequest;
} BACKUP_LIST_REQUEST, *PBACKUP_LIST_REQUEST;

//
//  Response containing a backup server list.
//

typedef struct _BACKUP_LIST_RESPONSE_1 {
    UCHAR       BackupServerCount;
    ULONG       Token;
    UCHAR       BackupServerList[1];
} BACKUP_LIST_RESPONSE_1, *PBACKUP_LIST_RESPONSE_1;

typedef struct _BACKUP_LIST_RESPONSE {
    UCHAR Type;
    BACKUP_LIST_RESPONSE_1 BackupListResponse;
} BACKUP_LIST_RESPONSE, *PBACKUP_LIST_RESPONSE;


//
//  Message indicating that a potential browser server should become a backup
//  server.
//

typedef struct _BECOME_BACKUP_1 {
    UCHAR       BrowserToPromote[1];
} BECOME_BACKUP_1, *PBECOME_BACKUP_1;

typedef struct _BECOME_BACKUP {
    UCHAR Type;
    BECOME_BACKUP_1 BecomeBackup;
} BECOME_BACKUP, *PBECOME_BACKUP;


//
//  Sent during the election process.
//

typedef struct _REQUEST_ELECTION_1 {
    UCHAR       Version;
    ULONG       Criteria;
    ULONG       TimeUp;
    ULONG       MustBeZero;
    UCHAR       ServerName[1];
} REQUEST_ELECTION_1, *PREQUEST_ELECTION_1;

typedef struct _REQUEST_ELECTION {
    UCHAR Type;
    REQUEST_ELECTION_1 ElectionRequest;
} REQUEST_ELECTION, *PREQUEST_ELECTION;

#define ELECTION_CR_OSTYPE      0xFF000000L // Native OS running on server
#define ELECTION_CR_OSWFW       0x01000000L //  Windows for workgroups server
#define ELECTION_CR_WIN_NT      0x10000000L //  Windows/NT Server
#define ELECTION_CR_LM_NT       0x20000000L //  Lan Manager for Windows/NT

#define ELECTION_CR_REVISION    0x00FFFF00L // Browser software revision
#define ELECTION_MAKE_REV(major, minor) (((major)&0xffL)<<16|((minor)&0xFFL)<<8)

#define ELECTION_CR_DESIRE      0x000000FFL // Desirability of becoming master.

//
//  Election desirability within criteria.
//
//  Most important is a running PDC, next is a configured domain master.
//
//  After that come running masters, then configured backups, then existing
//  running backups.
//
// Machines running WINS client are important because they are more capable
// of connecting to a PDC who's address was configured via DHCP.
//

#define ELECTION_DESIRE_AM_BACKUP  0x00000001L // Currently is backup
#define ELECTION_DESIRE_AM_CFG_BKP 0x00000002L // Always want to be
                                               //  master - set if backup &&
                                               //  MaintainServerList==YES
#define ELECTION_DESIRE_AM_MASTER  0x00000004L // Currently is master
#define ELECTION_DESIRE_AM_DOMMSTR 0x00000008L // Configured as domain master

#define ELECTION_DESIRE_WINS_CLIENT 0x00000020L // Transport running WINS client


#ifdef ENABLE_PSEUDO_BROWSER
#define ELECTION_DESIRE_AM_PSEUDO  0x00000040L // Machine is a Pseudo Server
#endif

#define ELECTION_DESIRE_AM_PDC     0x00000080L // Machine is a lanman NT server.

//
//  "Tickle" packet - sent to change state of browser.
//

typedef struct _RESET_STATE_1 {
    UCHAR       Options;
} RESET_STATE_1, *PRESET_STATE_1;

typedef struct _RESET_STATE {
    UCHAR Type;
    RESET_STATE_1 ResetStateRequest;
} RESET_STATE, *PRESET_STATE;

#define RESET_STATE_STOP_MASTER 0x01    // Stop being master
#define RESET_STATE_CLEAR_ALL   0x02    // Clear all browser state.
#define RESET_STATE_STOP        0x04    // Stop the browser service.

//
//  Master Announcement - Send from master to domain master.
//

typedef struct _MASTER_ANNOUNCEMENT_1 {
    UCHAR       MasterName[1];
} MASTER_ANNOUNCEMENT_1, *PMASTER_ANNOUNCEMENT_1;

typedef struct _MASTER_ANNOUNCEMENT {
    UCHAR Type;
    MASTER_ANNOUNCEMENT_1 MasterAnnouncement;
} MASTER_ANNOUNCEMENT, *PMASTER_ANNOUNCEMENT;


//
//  Definitions for Workstation interrogation and revalidation transactions
//

typedef struct _WKSTA_INFO_INTERROGATE_PACKET {
    UCHAR   CompatibilityPad;
    ULONG   Delay ;             // Number of milliseconds to wait before replying
    CHAR    ReturnMailslot[1] ; // Mailslot to reply to.
} WKSTA_INFO_INTERROGATE_PACKET, *PWKSTA_INFO_INTERROGATE_PACKET;

typedef struct _WKSTA_INFO_RESPONSE_PACKET {
    UCHAR   CompatibilityPad;
    UCHAR   VersionMajor;
    UCHAR   VersionMinor;
    USHORT  OsVersion ;
    CHAR    ComputerName[1] ;       // var-length ASCIIZ string */
#if 0
//
//  The following two ASCIIZ strings are not defined in the structure
//  but are concatenated to the end of the structure.
//
    CHAR        UserName[] ;
    CHAR        LogonDomain[] ;
#endif
} WKSTA_INFO_RESPONSE_PACKET, *PWKSTA_INFO_RESPONSE_PACKET;

typedef struct _WKSTA_RELOGON_REQUEST_PACKET {
    UCHAR   CompatibilityPad;
    ULONG   Delay ;
    ULONG   Flags ;
    CHAR    ReturnMailslot[1] ; // var-length ASCIIZ string
#if 0
//
//  The following ASCIIZ string is not defined in the structure
//  but is concatenated to the end of the structure.
//

    CHAR    DC_Name[] ;
#endif
} WKSTA_RELOGON_REQUEST_PACKET, *PWKSTA_RELOGON_REQUEST_PACKET;

//
//  Values for <wkrrq_flags> field */
//

#define WKRRQ_FLAG_LOGON_SERVER      0x1    // I'm your official logon server;
                                            // do a relogon to me.
                                            //

typedef struct _WKSTA_RELOGON_RESPONSE_PACKET {
    UCHAR   CompatibilityPad;
    USHORT  Status ;
    CHAR    ComputerName[1] ;   // var-length ASCIIZ string
} WKSTA_RELOGON_RESPONSE_PACKET, *PWKSTA_RELOGON_RESPONSE_PACKET;


//
//  Values for <wkrrs_status> field
//

#define WKRRS_STATUS_SUCCEEDED      0       // Operation succeeded
#define WKRRS_STATUS_DENIED         1       // Operation denied to caller
#define WKRRS_STATUS_FAILED         2       // Operation tried but failed

#define EXCESS_NAME_LEN (sizeof(ITRANS_MS_NAME) - \
                            FIELD_OFFSET(SMB_TRANSACTION_MAILSLOT, Buffer) )

//
//  This structure defines all of the types of requests that appear in messages
//  to the internal mailslot.
//

typedef struct _INTERNAL_TRANSACTION {
    UCHAR   Type;                               // Type of request.
    union {
        HOST_ANNOUNCE_PACKET_1           Announcement ;
        BROWSE_ANNOUNCE_PACKET_1         BrowseAnnouncement ;
        REQUEST_ANNOUNCE_PACKET_1        RequestAnnounce ;
        BACKUP_LIST_RESPONSE_1           GetBackupListResp ;
        BACKUP_LIST_REQUEST_1            GetBackupListRequest ;
        BECOME_BACKUP_1                  BecomeBackup ;
        REQUEST_ELECTION_1               RequestElection ;
        MASTER_ANNOUNCEMENT_1            MasterAnnouncement ;
        RESET_STATE_1                    ResetState ;

        WKSTA_INFO_INTERROGATE_PACKET    InterrogateRequest ;
        WKSTA_INFO_RESPONSE_PACKET       InterrogateResponse ;
        WKSTA_RELOGON_REQUEST_PACKET     RelogonRequest ;
        WKSTA_RELOGON_RESPONSE_PACKET    RelogonResponse ;
    } Union;
} INTERNAL_TRANSACTION, *PINTERNAL_TRANSACTION ;

#include <packoff.h>

#endif // _HOSTANNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\hnetcfg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for hnetcfg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __hnetcfg_h__
#define __hnetcfg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IHNetCfgMgr_FWD_DEFINED__
#define __IHNetCfgMgr_FWD_DEFINED__
typedef interface IHNetCfgMgr IHNetCfgMgr;
#endif 	/* __IHNetCfgMgr_FWD_DEFINED__ */


#ifndef __IHNetBridgeSettings_FWD_DEFINED__
#define __IHNetBridgeSettings_FWD_DEFINED__
typedef interface IHNetBridgeSettings IHNetBridgeSettings;
#endif 	/* __IHNetBridgeSettings_FWD_DEFINED__ */


#ifndef __IHNetFirewallSettings_FWD_DEFINED__
#define __IHNetFirewallSettings_FWD_DEFINED__
typedef interface IHNetFirewallSettings IHNetFirewallSettings;
#endif 	/* __IHNetFirewallSettings_FWD_DEFINED__ */


#ifndef __IHNetIcsSettings_FWD_DEFINED__
#define __IHNetIcsSettings_FWD_DEFINED__
typedef interface IHNetIcsSettings IHNetIcsSettings;
#endif 	/* __IHNetIcsSettings_FWD_DEFINED__ */


#ifndef __IHNetProtocolSettings_FWD_DEFINED__
#define __IHNetProtocolSettings_FWD_DEFINED__
typedef interface IHNetProtocolSettings IHNetProtocolSettings;
#endif 	/* __IHNetProtocolSettings_FWD_DEFINED__ */


#ifndef __IHNetConnection_FWD_DEFINED__
#define __IHNetConnection_FWD_DEFINED__
typedef interface IHNetConnection IHNetConnection;
#endif 	/* __IHNetConnection_FWD_DEFINED__ */


#ifndef __IHNetFirewalledConnection_FWD_DEFINED__
#define __IHNetFirewalledConnection_FWD_DEFINED__
typedef interface IHNetFirewalledConnection IHNetFirewalledConnection;
#endif 	/* __IHNetFirewalledConnection_FWD_DEFINED__ */


#ifndef __IHNetIcsPublicConnection_FWD_DEFINED__
#define __IHNetIcsPublicConnection_FWD_DEFINED__
typedef interface IHNetIcsPublicConnection IHNetIcsPublicConnection;
#endif 	/* __IHNetIcsPublicConnection_FWD_DEFINED__ */


#ifndef __IHNetIcsPrivateConnection_FWD_DEFINED__
#define __IHNetIcsPrivateConnection_FWD_DEFINED__
typedef interface IHNetIcsPrivateConnection IHNetIcsPrivateConnection;
#endif 	/* __IHNetIcsPrivateConnection_FWD_DEFINED__ */


#ifndef __IHNetBridge_FWD_DEFINED__
#define __IHNetBridge_FWD_DEFINED__
typedef interface IHNetBridge IHNetBridge;
#endif 	/* __IHNetBridge_FWD_DEFINED__ */


#ifndef __IHNetBridgedConnection_FWD_DEFINED__
#define __IHNetBridgedConnection_FWD_DEFINED__
typedef interface IHNetBridgedConnection IHNetBridgedConnection;
#endif 	/* __IHNetBridgedConnection_FWD_DEFINED__ */


#ifndef __IHNetPortMappingProtocol_FWD_DEFINED__
#define __IHNetPortMappingProtocol_FWD_DEFINED__
typedef interface IHNetPortMappingProtocol IHNetPortMappingProtocol;
#endif 	/* __IHNetPortMappingProtocol_FWD_DEFINED__ */


#ifndef __IHNetPortMappingBinding_FWD_DEFINED__
#define __IHNetPortMappingBinding_FWD_DEFINED__
typedef interface IHNetPortMappingBinding IHNetPortMappingBinding;
#endif 	/* __IHNetPortMappingBinding_FWD_DEFINED__ */


#ifndef __IHNetApplicationProtocol_FWD_DEFINED__
#define __IHNetApplicationProtocol_FWD_DEFINED__
typedef interface IHNetApplicationProtocol IHNetApplicationProtocol;
#endif 	/* __IHNetApplicationProtocol_FWD_DEFINED__ */


#ifndef __IEnumHNetBridges_FWD_DEFINED__
#define __IEnumHNetBridges_FWD_DEFINED__
typedef interface IEnumHNetBridges IEnumHNetBridges;
#endif 	/* __IEnumHNetBridges_FWD_DEFINED__ */


#ifndef __IEnumHNetFirewalledConnections_FWD_DEFINED__
#define __IEnumHNetFirewalledConnections_FWD_DEFINED__
typedef interface IEnumHNetFirewalledConnections IEnumHNetFirewalledConnections;
#endif 	/* __IEnumHNetFirewalledConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetIcsPublicConnections_FWD_DEFINED__
#define __IEnumHNetIcsPublicConnections_FWD_DEFINED__
typedef interface IEnumHNetIcsPublicConnections IEnumHNetIcsPublicConnections;
#endif 	/* __IEnumHNetIcsPublicConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetIcsPrivateConnections_FWD_DEFINED__
#define __IEnumHNetIcsPrivateConnections_FWD_DEFINED__
typedef interface IEnumHNetIcsPrivateConnections IEnumHNetIcsPrivateConnections;
#endif 	/* __IEnumHNetIcsPrivateConnections_FWD_DEFINED__ */


#ifndef __IEnumHNetApplicationProtocols_FWD_DEFINED__
#define __IEnumHNetApplicationProtocols_FWD_DEFINED__
typedef interface IEnumHNetApplicationProtocols IEnumHNetApplicationProtocols;
#endif 	/* __IEnumHNetApplicationProtocols_FWD_DEFINED__ */


#ifndef __IEnumHNetPortMappingProtocols_FWD_DEFINED__
#define __IEnumHNetPortMappingProtocols_FWD_DEFINED__
typedef interface IEnumHNetPortMappingProtocols IEnumHNetPortMappingProtocols;
#endif 	/* __IEnumHNetPortMappingProtocols_FWD_DEFINED__ */


#ifndef __IEnumHNetPortMappingBindings_FWD_DEFINED__
#define __IEnumHNetPortMappingBindings_FWD_DEFINED__
typedef interface IEnumHNetPortMappingBindings IEnumHNetPortMappingBindings;
#endif 	/* __IEnumHNetPortMappingBindings_FWD_DEFINED__ */


#ifndef __IEnumHNetBridgedConnections_FWD_DEFINED__
#define __IEnumHNetBridgedConnections_FWD_DEFINED__
typedef interface IEnumHNetBridgedConnections IEnumHNetBridgedConnections;
#endif 	/* __IEnumHNetBridgedConnections_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcon.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_hnetcfg_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_HNetCfgMgr;
EXTERN_C const CLSID CLSID_SharingManagerEnumPublicConnection;
EXTERN_C const CLSID CLSID_SharingManagerEnumPrivateConnection;
EXTERN_C const CLSID CLSID_SharingManagerEnumApplicationDefinition;
EXTERN_C const CLSID CLSID_SharingManagerEnumPortMapping;
EXTERN_C const CLSID CLSID_SharingApplicationDefinition;
EXTERN_C const CLSID CLSID_SharingApplicationConfiguration;
EXTERN_C const CLSID CLSID_NetSharingConfiguration;
























extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0000_v0_0_s_ifspec;

#ifndef __IHNetCfgMgr_INTERFACE_DEFINED__
#define __IHNetCfgMgr_INTERFACE_DEFINED__

/* interface IHNetCfgMgr */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetCfgMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6C-3032-11D4-9348-00C04F8EEB71")
    IHNetCfgMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIHNetConnectionForINetConnection( 
            /* [in] */ INetConnection *pNetConnection,
            /* [out] */ IHNetConnection **ppHNetConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIHNetConnectionForGuid( 
            /* [in] */ GUID *pGuid,
            /* [in] */ BOOLEAN fLanConnection,
            /* [in] */ BOOLEAN fCreateEntries,
            /* [out] */ IHNetConnection **ppHNetConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetCfgMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetCfgMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetCfgMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetCfgMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIHNetConnectionForINetConnection )( 
            IHNetCfgMgr * This,
            /* [in] */ INetConnection *pNetConnection,
            /* [out] */ IHNetConnection **ppHNetConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetIHNetConnectionForGuid )( 
            IHNetCfgMgr * This,
            /* [in] */ GUID *pGuid,
            /* [in] */ BOOLEAN fLanConnection,
            /* [in] */ BOOLEAN fCreateEntries,
            /* [out] */ IHNetConnection **ppHNetConnection);
        
        END_INTERFACE
    } IHNetCfgMgrVtbl;

    interface IHNetCfgMgr
    {
        CONST_VTBL struct IHNetCfgMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetCfgMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetCfgMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetCfgMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetCfgMgr_GetIHNetConnectionForINetConnection(This,pNetConnection,ppHNetConnection)	\
    (This)->lpVtbl -> GetIHNetConnectionForINetConnection(This,pNetConnection,ppHNetConnection)

#define IHNetCfgMgr_GetIHNetConnectionForGuid(This,pGuid,fLanConnection,fCreateEntries,ppHNetConnection)	\
    (This)->lpVtbl -> GetIHNetConnectionForGuid(This,pGuid,fLanConnection,fCreateEntries,ppHNetConnection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetCfgMgr_GetIHNetConnectionForINetConnection_Proxy( 
    IHNetCfgMgr * This,
    /* [in] */ INetConnection *pNetConnection,
    /* [out] */ IHNetConnection **ppHNetConnection);


void __RPC_STUB IHNetCfgMgr_GetIHNetConnectionForINetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetCfgMgr_GetIHNetConnectionForGuid_Proxy( 
    IHNetCfgMgr * This,
    /* [in] */ GUID *pGuid,
    /* [in] */ BOOLEAN fLanConnection,
    /* [in] */ BOOLEAN fCreateEntries,
    /* [out] */ IHNetConnection **ppHNetConnection);


void __RPC_STUB IHNetCfgMgr_GetIHNetConnectionForGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetCfgMgr_INTERFACE_DEFINED__ */


#ifndef __IHNetBridgeSettings_INTERFACE_DEFINED__
#define __IHNetBridgeSettings_INTERFACE_DEFINED__

/* interface IHNetBridgeSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridgeSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6D-3032-11D4-9348-00C04F8EEB71")
    IHNetBridgeSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumBridges( 
            /* [out] */ IEnumHNetBridges **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBridge( 
            /* [out] */ IHNetBridge **ppHNetBridge,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllBridges( 
            /* [out] */ ULONG *pcBridges,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgeSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridgeSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridgeSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridgeSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBridges )( 
            IHNetBridgeSettings * This,
            /* [out] */ IEnumHNetBridges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBridge )( 
            IHNetBridgeSettings * This,
            /* [out] */ IHNetBridge **ppHNetBridge,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllBridges )( 
            IHNetBridgeSettings * This,
            /* [out] */ ULONG *pcBridges,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgeSettingsVtbl;

    interface IHNetBridgeSettings
    {
        CONST_VTBL struct IHNetBridgeSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridgeSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridgeSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridgeSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridgeSettings_EnumBridges(This,ppEnum)	\
    (This)->lpVtbl -> EnumBridges(This,ppEnum)

#define IHNetBridgeSettings_CreateBridge(This,ppHNetBridge,pnetcfgExisting)	\
    (This)->lpVtbl -> CreateBridge(This,ppHNetBridge,pnetcfgExisting)

#define IHNetBridgeSettings_DestroyAllBridges(This,pcBridges,pnetcfgExisting)	\
    (This)->lpVtbl -> DestroyAllBridges(This,pcBridges,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_EnumBridges_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ IEnumHNetBridges **ppEnum);


void __RPC_STUB IHNetBridgeSettings_EnumBridges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_CreateBridge_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ IHNetBridge **ppHNetBridge,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgeSettings_CreateBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgeSettings_DestroyAllBridges_Proxy( 
    IHNetBridgeSettings * This,
    /* [out] */ ULONG *pcBridges,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgeSettings_DestroyAllBridges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridgeSettings_INTERFACE_DEFINED__ */


#ifndef __IHNetFirewallSettings_INTERFACE_DEFINED__
#define __IHNetFirewallSettings_INTERFACE_DEFINED__

/* interface IHNetFirewallSettings */
/* [unique][uuid][object][local] */ 

typedef struct tagHNET_FW_LOGGING_SETTINGS
    {
    /* [string] */ LPWSTR pszwPath;
    ULONG ulMaxFileSize;
    BOOLEAN fLogDroppedPackets;
    BOOLEAN fLogConnections;
    } 	HNET_FW_LOGGING_SETTINGS;


EXTERN_C const IID IID_IHNetFirewallSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6E-3032-11D4-9348-00C04F8EEB71")
    IHNetFirewallSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFirewalledConnections( 
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirewallLoggingSettings( 
            /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFirewallLoggingSettings( 
            /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAllFirewalling( 
            /* [out] */ ULONG *pcFirewalledConnections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetFirewallSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetFirewallSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetFirewallSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetFirewallSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFirewalledConnections )( 
            IHNetFirewallSettings * This,
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirewallLoggingSettings )( 
            IHNetFirewallSettings * This,
            /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *SetFirewallLoggingSettings )( 
            IHNetFirewallSettings * This,
            /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings);
        
        HRESULT ( STDMETHODCALLTYPE *DisableAllFirewalling )( 
            IHNetFirewallSettings * This,
            /* [out] */ ULONG *pcFirewalledConnections);
        
        END_INTERFACE
    } IHNetFirewallSettingsVtbl;

    interface IHNetFirewallSettings
    {
        CONST_VTBL struct IHNetFirewallSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetFirewallSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetFirewallSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetFirewallSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetFirewallSettings_EnumFirewalledConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumFirewalledConnections(This,ppEnum)

#define IHNetFirewallSettings_GetFirewallLoggingSettings(This,ppSettings)	\
    (This)->lpVtbl -> GetFirewallLoggingSettings(This,ppSettings)

#define IHNetFirewallSettings_SetFirewallLoggingSettings(This,pSettings)	\
    (This)->lpVtbl -> SetFirewallLoggingSettings(This,pSettings)

#define IHNetFirewallSettings_DisableAllFirewalling(This,pcFirewalledConnections)	\
    (This)->lpVtbl -> DisableAllFirewalling(This,pcFirewalledConnections)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_EnumFirewalledConnections_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ IEnumHNetFirewalledConnections **ppEnum);


void __RPC_STUB IHNetFirewallSettings_EnumFirewalledConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_GetFirewallLoggingSettings_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ HNET_FW_LOGGING_SETTINGS **ppSettings);


void __RPC_STUB IHNetFirewallSettings_GetFirewallLoggingSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_SetFirewallLoggingSettings_Proxy( 
    IHNetFirewallSettings * This,
    /* [in] */ HNET_FW_LOGGING_SETTINGS *pSettings);


void __RPC_STUB IHNetFirewallSettings_SetFirewallLoggingSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetFirewallSettings_DisableAllFirewalling_Proxy( 
    IHNetFirewallSettings * This,
    /* [out] */ ULONG *pcFirewalledConnections);


void __RPC_STUB IHNetFirewallSettings_DisableAllFirewalling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetFirewallSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0163 */
/* [local] */ 

VOID
HNetFreeFirewallLoggingSettings(
    HNET_FW_LOGGING_SETTINGS *pSettings
    );


extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0163_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0163_v0_0_s_ifspec;

#ifndef __IHNetIcsSettings_INTERFACE_DEFINED__
#define __IHNetIcsSettings_INTERFACE_DEFINED__

/* interface IHNetIcsSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B6F-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumIcsPublicConnections( 
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumIcsPrivateConnections( 
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIcs( 
            /* [out] */ ULONG *pcIcsPublicConnections,
            /* [out] */ ULONG *pcIcsPrivateConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPossiblePrivateConnections( 
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ ULONG *pcPrivateConnections,
            /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
            /* [out] */ LONG *pxCurrentPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutodialSettings( 
            /* [out] */ BOOLEAN *pfAutodialEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAutodialSettings( 
            /* [in] */ BOOLEAN fEnableAutodial) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDhcpEnabled( 
            /* [out] */ BOOLEAN *pfDhcpEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDhcpEnabled( 
            /* [in] */ BOOLEAN fEnableDhcp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDhcpScopeSettings( 
            /* [out] */ DWORD *pdwScopeAddress,
            /* [out] */ DWORD *pdwScopeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDhcpScopeSettings( 
            /* [in] */ DWORD dwScopeAddress,
            /* [in] */ DWORD dwScopeMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDhcpReservedAddresses( 
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDnsEnabled( 
            /* [out] */ BOOLEAN *pfDnsEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDnsEnabled( 
            /* [in] */ BOOLEAN fEnableDns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshTargetComputerAddress( 
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ ULONG ulAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumIcsPublicConnections )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumIcsPrivateConnections )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIcs )( 
            IHNetIcsSettings * This,
            /* [out] */ ULONG *pcIcsPublicConnections,
            /* [out] */ ULONG *pcIcsPrivateConnections);
        
        HRESULT ( STDMETHODCALLTYPE *GetPossiblePrivateConnections )( 
            IHNetIcsSettings * This,
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ ULONG *pcPrivateConnections,
            /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
            /* [out] */ LONG *pxCurrentPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAutodialSettings )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfAutodialEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetAutodialSettings )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableAutodial);
        
        HRESULT ( STDMETHODCALLTYPE *GetDhcpEnabled )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfDhcpEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetDhcpEnabled )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableDhcp);
        
        HRESULT ( STDMETHODCALLTYPE *GetDhcpScopeSettings )( 
            IHNetIcsSettings * This,
            /* [out] */ DWORD *pdwScopeAddress,
            /* [out] */ DWORD *pdwScopeMask);
        
        HRESULT ( STDMETHODCALLTYPE *SetDhcpScopeSettings )( 
            IHNetIcsSettings * This,
            /* [in] */ DWORD dwScopeAddress,
            /* [in] */ DWORD dwScopeMask);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDhcpReservedAddresses )( 
            IHNetIcsSettings * This,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDnsEnabled )( 
            IHNetIcsSettings * This,
            /* [out] */ BOOLEAN *pfDnsEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetDnsEnabled )( 
            IHNetIcsSettings * This,
            /* [in] */ BOOLEAN fEnableDns);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshTargetComputerAddress )( 
            IHNetIcsSettings * This,
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ ULONG ulAddress);
        
        END_INTERFACE
    } IHNetIcsSettingsVtbl;

    interface IHNetIcsSettings
    {
        CONST_VTBL struct IHNetIcsSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsSettings_EnumIcsPublicConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumIcsPublicConnections(This,ppEnum)

#define IHNetIcsSettings_EnumIcsPrivateConnections(This,ppEnum)	\
    (This)->lpVtbl -> EnumIcsPrivateConnections(This,ppEnum)

#define IHNetIcsSettings_DisableIcs(This,pcIcsPublicConnections,pcIcsPrivateConnections)	\
    (This)->lpVtbl -> DisableIcs(This,pcIcsPublicConnections,pcIcsPrivateConnections)

#define IHNetIcsSettings_GetPossiblePrivateConnections(This,pConn,pcPrivateConnections,pprgPrivateConnections,pxCurrentPrivate)	\
    (This)->lpVtbl -> GetPossiblePrivateConnections(This,pConn,pcPrivateConnections,pprgPrivateConnections,pxCurrentPrivate)

#define IHNetIcsSettings_GetAutodialSettings(This,pfAutodialEnabled)	\
    (This)->lpVtbl -> GetAutodialSettings(This,pfAutodialEnabled)

#define IHNetIcsSettings_SetAutodialSettings(This,fEnableAutodial)	\
    (This)->lpVtbl -> SetAutodialSettings(This,fEnableAutodial)

#define IHNetIcsSettings_GetDhcpEnabled(This,pfDhcpEnabled)	\
    (This)->lpVtbl -> GetDhcpEnabled(This,pfDhcpEnabled)

#define IHNetIcsSettings_SetDhcpEnabled(This,fEnableDhcp)	\
    (This)->lpVtbl -> SetDhcpEnabled(This,fEnableDhcp)

#define IHNetIcsSettings_GetDhcpScopeSettings(This,pdwScopeAddress,pdwScopeMask)	\
    (This)->lpVtbl -> GetDhcpScopeSettings(This,pdwScopeAddress,pdwScopeMask)

#define IHNetIcsSettings_SetDhcpScopeSettings(This,dwScopeAddress,dwScopeMask)	\
    (This)->lpVtbl -> SetDhcpScopeSettings(This,dwScopeAddress,dwScopeMask)

#define IHNetIcsSettings_EnumDhcpReservedAddresses(This,ppEnum)	\
    (This)->lpVtbl -> EnumDhcpReservedAddresses(This,ppEnum)

#define IHNetIcsSettings_GetDnsEnabled(This,pfDnsEnabled)	\
    (This)->lpVtbl -> GetDnsEnabled(This,pfDnsEnabled)

#define IHNetIcsSettings_SetDnsEnabled(This,fEnableDns)	\
    (This)->lpVtbl -> SetDnsEnabled(This,fEnableDns)

#define IHNetIcsSettings_RefreshTargetComputerAddress(This,pszwName,ulAddress)	\
    (This)->lpVtbl -> RefreshTargetComputerAddress(This,pszwName,ulAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumIcsPublicConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumIcsPublicConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumIcsPrivateConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumIcsPrivateConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_DisableIcs_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ ULONG *pcIcsPublicConnections,
    /* [out] */ ULONG *pcIcsPrivateConnections);


void __RPC_STUB IHNetIcsSettings_DisableIcs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetPossiblePrivateConnections_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ IHNetConnection *pConn,
    /* [out] */ ULONG *pcPrivateConnections,
    /* [length_is][out] */ IHNetConnection **pprgPrivateConnections[  ],
    /* [out] */ LONG *pxCurrentPrivate);


void __RPC_STUB IHNetIcsSettings_GetPossiblePrivateConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetAutodialSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfAutodialEnabled);


void __RPC_STUB IHNetIcsSettings_GetAutodialSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetAutodialSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableAutodial);


void __RPC_STUB IHNetIcsSettings_SetAutodialSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDhcpEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfDhcpEnabled);


void __RPC_STUB IHNetIcsSettings_GetDhcpEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDhcpEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableDhcp);


void __RPC_STUB IHNetIcsSettings_SetDhcpEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDhcpScopeSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ DWORD *pdwScopeAddress,
    /* [out] */ DWORD *pdwScopeMask);


void __RPC_STUB IHNetIcsSettings_GetDhcpScopeSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDhcpScopeSettings_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ DWORD dwScopeAddress,
    /* [in] */ DWORD dwScopeMask);


void __RPC_STUB IHNetIcsSettings_SetDhcpScopeSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_EnumDhcpReservedAddresses_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IHNetIcsSettings_EnumDhcpReservedAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_GetDnsEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [out] */ BOOLEAN *pfDnsEnabled);


void __RPC_STUB IHNetIcsSettings_GetDnsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_SetDnsEnabled_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ BOOLEAN fEnableDns);


void __RPC_STUB IHNetIcsSettings_SetDnsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetIcsSettings_RefreshTargetComputerAddress_Proxy( 
    IHNetIcsSettings * This,
    /* [in] */ OLECHAR *pszwName,
    /* [in] */ ULONG ulAddress);


void __RPC_STUB IHNetIcsSettings_RefreshTargetComputerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsSettings_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0164 */
/* [local] */ 

typedef struct tagHNET_RESPONSE_RANGE
    {
    UCHAR ucIPProtocol;
    USHORT usStartPort;
    USHORT usEndPort;
    } 	HNET_RESPONSE_RANGE;

typedef struct tagHNET_PORT_MAPPING_BINDING
    {
    OLECHAR *pszwTargetMachineName;
    ULONG ulTargetMachineAddress;
    } 	HNET_PORT_MAPPING_BINDING;



extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0164_v0_0_s_ifspec;

#ifndef __IHNetProtocolSettings_INTERFACE_DEFINED__
#define __IHNetProtocolSettings_INTERFACE_DEFINED__

/* interface IHNetProtocolSettings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetProtocolSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B70-3032-11D4-9348-00C04F8EEB71")
    IHNetProtocolSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumApplicationProtocols( 
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationProtocol( 
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucOutgoingIPProtocol,
            /* [in] */ USHORT usOutgoingPort,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
            /* [out] */ IHNetApplicationProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortMappingProtocols( 
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePortMappingProtocol( 
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usPort,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindPortMappingProtocol( 
            /* [in] */ GUID *pGuid,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetProtocolSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetProtocolSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetProtocolSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetProtocolSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumApplicationProtocols )( 
            IHNetProtocolSettings * This,
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateApplicationProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucOutgoingIPProtocol,
            /* [in] */ USHORT usOutgoingPort,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
            /* [out] */ IHNetApplicationProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortMappingProtocols )( 
            IHNetProtocolSettings * This,
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePortMappingProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ OLECHAR *pszwName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usPort,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *FindPortMappingProtocol )( 
            IHNetProtocolSettings * This,
            /* [in] */ GUID *pGuid,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        END_INTERFACE
    } IHNetProtocolSettingsVtbl;

    interface IHNetProtocolSettings
    {
        CONST_VTBL struct IHNetProtocolSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetProtocolSettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetProtocolSettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetProtocolSettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetProtocolSettings_EnumApplicationProtocols(This,fEnabledOnly,ppEnum)	\
    (This)->lpVtbl -> EnumApplicationProtocols(This,fEnabledOnly,ppEnum)

#define IHNetProtocolSettings_CreateApplicationProtocol(This,pszwName,ucOutgoingIPProtocol,usOutgoingPort,uscResponses,rgResponses,ppProtocol)	\
    (This)->lpVtbl -> CreateApplicationProtocol(This,pszwName,ucOutgoingIPProtocol,usOutgoingPort,uscResponses,rgResponses,ppProtocol)

#define IHNetProtocolSettings_EnumPortMappingProtocols(This,ppEnum)	\
    (This)->lpVtbl -> EnumPortMappingProtocols(This,ppEnum)

#define IHNetProtocolSettings_CreatePortMappingProtocol(This,pszwName,ucIPProtocol,usPort,ppProtocol)	\
    (This)->lpVtbl -> CreatePortMappingProtocol(This,pszwName,ucIPProtocol,usPort,ppProtocol)

#define IHNetProtocolSettings_FindPortMappingProtocol(This,pGuid,ppProtocol)	\
    (This)->lpVtbl -> FindPortMappingProtocol(This,pGuid,ppProtocol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_EnumApplicationProtocols_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ BOOLEAN fEnabledOnly,
    /* [out] */ IEnumHNetApplicationProtocols **ppEnum);


void __RPC_STUB IHNetProtocolSettings_EnumApplicationProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_CreateApplicationProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ OLECHAR *pszwName,
    /* [in] */ UCHAR ucOutgoingIPProtocol,
    /* [in] */ USHORT usOutgoingPort,
    /* [in] */ USHORT uscResponses,
    /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponses[  ],
    /* [out] */ IHNetApplicationProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_CreateApplicationProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_EnumPortMappingProtocols_Proxy( 
    IHNetProtocolSettings * This,
    /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);


void __RPC_STUB IHNetProtocolSettings_EnumPortMappingProtocols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_CreatePortMappingProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ OLECHAR *pszwName,
    /* [in] */ UCHAR ucIPProtocol,
    /* [in] */ USHORT usPort,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_CreatePortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetProtocolSettings_FindPortMappingProtocol_Proxy( 
    IHNetProtocolSettings * This,
    /* [in] */ GUID *pGuid,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetProtocolSettings_FindPortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetProtocolSettings_INTERFACE_DEFINED__ */


#ifndef __IHNetConnection_INTERFACE_DEFINED__
#define __IHNetConnection_INTERFACE_DEFINED__

/* interface IHNetConnection */
/* [unique][uuid][object][local] */ 

typedef struct tagHNET_CONN_PROPERTIES
    {
    BOOLEAN fLanConnection;
    BOOLEAN fFirewalled;
    BOOLEAN fIcsPublic;
    BOOLEAN fIcsPrivate;
    BOOLEAN fBridge;
    BOOLEAN fPartOfBridge;
    BOOLEAN fCanBeBridged;
    BOOLEAN fCanBeFirewalled;
    BOOLEAN fCanBeIcsPublic;
    BOOLEAN fCanBeIcsPrivate;
    } 	HNET_CONN_PROPERTIES;

typedef struct tagHNET_FW_ICMP_SETTINGS
    {
    BOOLEAN fAllowOutboundDestinationUnreachable;
    BOOLEAN fAllowOutboundSourceQuench;
    BOOLEAN fAllowRedirect;
    BOOLEAN fAllowInboundEchoRequest;
    BOOLEAN fAllowInboundRouterRequest;
    BOOLEAN fAllowOutboundTimeExceeded;
    BOOLEAN fAllowOutboundParameterProblem;
    BOOLEAN fAllowInboundTimestampRequest;
    BOOLEAN fAllowInboundMaskRequest;
    } 	HNET_FW_ICMP_SETTINGS;


EXTERN_C const IID IID_IHNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B71-3032-11D4-9348-00C04F8EEB71")
    IHNetConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetINetConnection( 
            /* [out] */ INetConnection **ppNetConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRasPhonebookPath( 
            /* [string][out] */ OLECHAR **ppszwPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ HNET_CONN_PROPERTIES **ppProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlInterface( 
            REFIID iid,
            /* [iid_is] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Firewall( 
            /* [out] */ IHNetFirewalledConnection **ppFirewalledConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePublic( 
            /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SharePrivate( 
            /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortMappings( 
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindingForPortMappingProtocol( 
            /* [in] */ IHNetPortMappingProtocol *pProtocol,
            /* [out] */ IHNetPortMappingBinding **ppBinding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcmpSettings( 
            /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcmpSettings( 
            /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowAutoconfigBalloon( 
            /* [out] */ BOOLEAN *pfShowBalloon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRasConnectionEntry( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetINetConnection )( 
            IHNetConnection * This,
            /* [out] */ INetConnection **ppNetConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuid )( 
            IHNetConnection * This,
            /* [out] */ GUID **ppGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetConnection * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasPhonebookPath )( 
            IHNetConnection * This,
            /* [string][out] */ OLECHAR **ppszwPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IHNetConnection * This,
            /* [out] */ HNET_CONN_PROPERTIES **ppProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlInterface )( 
            IHNetConnection * This,
            REFIID iid,
            /* [iid_is] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *Firewall )( 
            IHNetConnection * This,
            /* [out] */ IHNetFirewalledConnection **ppFirewalledConn);
        
        HRESULT ( STDMETHODCALLTYPE *SharePublic )( 
            IHNetConnection * This,
            /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn);
        
        HRESULT ( STDMETHODCALLTYPE *SharePrivate )( 
            IHNetConnection * This,
            /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortMappings )( 
            IHNetConnection * This,
            /* [in] */ BOOLEAN fEnabledOnly,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindingForPortMappingProtocol )( 
            IHNetConnection * This,
            /* [in] */ IHNetPortMappingProtocol *pProtocol,
            /* [out] */ IHNetPortMappingBinding **ppBinding);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcmpSettings )( 
            IHNetConnection * This,
            /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcmpSettings )( 
            IHNetConnection * This,
            /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings);
        
        HRESULT ( STDMETHODCALLTYPE *ShowAutoconfigBalloon )( 
            IHNetConnection * This,
            /* [out] */ BOOLEAN *pfShowBalloon);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRasConnectionEntry )( 
            IHNetConnection * This);
        
        END_INTERFACE
    } IHNetConnectionVtbl;

    interface IHNetConnection
    {
        CONST_VTBL struct IHNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetConnection_GetINetConnection(This,ppNetConnection)	\
    (This)->lpVtbl -> GetINetConnection(This,ppNetConnection)

#define IHNetConnection_GetGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetGuid(This,ppGuid)

#define IHNetConnection_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetConnection_GetRasPhonebookPath(This,ppszwPath)	\
    (This)->lpVtbl -> GetRasPhonebookPath(This,ppszwPath)

#define IHNetConnection_GetProperties(This,ppProperties)	\
    (This)->lpVtbl -> GetProperties(This,ppProperties)

#define IHNetConnection_GetControlInterface(This,iid,ppv)	\
    (This)->lpVtbl -> GetControlInterface(This,iid,ppv)

#define IHNetConnection_Firewall(This,ppFirewalledConn)	\
    (This)->lpVtbl -> Firewall(This,ppFirewalledConn)

#define IHNetConnection_SharePublic(This,ppIcsPublicConn)	\
    (This)->lpVtbl -> SharePublic(This,ppIcsPublicConn)

#define IHNetConnection_SharePrivate(This,ppIcsPrivateConn)	\
    (This)->lpVtbl -> SharePrivate(This,ppIcsPrivateConn)

#define IHNetConnection_EnumPortMappings(This,fEnabledOnly,ppEnum)	\
    (This)->lpVtbl -> EnumPortMappings(This,fEnabledOnly,ppEnum)

#define IHNetConnection_GetBindingForPortMappingProtocol(This,pProtocol,ppBinding)	\
    (This)->lpVtbl -> GetBindingForPortMappingProtocol(This,pProtocol,ppBinding)

#define IHNetConnection_GetIcmpSettings(This,ppSettings)	\
    (This)->lpVtbl -> GetIcmpSettings(This,ppSettings)

#define IHNetConnection_SetIcmpSettings(This,pSettings)	\
    (This)->lpVtbl -> SetIcmpSettings(This,pSettings)

#define IHNetConnection_ShowAutoconfigBalloon(This,pfShowBalloon)	\
    (This)->lpVtbl -> ShowAutoconfigBalloon(This,pfShowBalloon)

#define IHNetConnection_DeleteRasConnectionEntry(This)	\
    (This)->lpVtbl -> DeleteRasConnectionEntry(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetConnection_GetINetConnection_Proxy( 
    IHNetConnection * This,
    /* [out] */ INetConnection **ppNetConnection);


void __RPC_STUB IHNetConnection_GetINetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetGuid_Proxy( 
    IHNetConnection * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IHNetConnection_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetName_Proxy( 
    IHNetConnection * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetConnection_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetRasPhonebookPath_Proxy( 
    IHNetConnection * This,
    /* [string][out] */ OLECHAR **ppszwPath);


void __RPC_STUB IHNetConnection_GetRasPhonebookPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetProperties_Proxy( 
    IHNetConnection * This,
    /* [out] */ HNET_CONN_PROPERTIES **ppProperties);


void __RPC_STUB IHNetConnection_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetControlInterface_Proxy( 
    IHNetConnection * This,
    REFIID iid,
    /* [iid_is] */ void **ppv);


void __RPC_STUB IHNetConnection_GetControlInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_Firewall_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetFirewalledConnection **ppFirewalledConn);


void __RPC_STUB IHNetConnection_Firewall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SharePublic_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetIcsPublicConnection **ppIcsPublicConn);


void __RPC_STUB IHNetConnection_SharePublic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SharePrivate_Proxy( 
    IHNetConnection * This,
    /* [out] */ IHNetIcsPrivateConnection **ppIcsPrivateConn);


void __RPC_STUB IHNetConnection_SharePrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_EnumPortMappings_Proxy( 
    IHNetConnection * This,
    /* [in] */ BOOLEAN fEnabledOnly,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IHNetConnection_EnumPortMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetBindingForPortMappingProtocol_Proxy( 
    IHNetConnection * This,
    /* [in] */ IHNetPortMappingProtocol *pProtocol,
    /* [out] */ IHNetPortMappingBinding **ppBinding);


void __RPC_STUB IHNetConnection_GetBindingForPortMappingProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_GetIcmpSettings_Proxy( 
    IHNetConnection * This,
    /* [out] */ HNET_FW_ICMP_SETTINGS **ppSettings);


void __RPC_STUB IHNetConnection_GetIcmpSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_SetIcmpSettings_Proxy( 
    IHNetConnection * This,
    /* [in] */ HNET_FW_ICMP_SETTINGS *pSettings);


void __RPC_STUB IHNetConnection_SetIcmpSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_ShowAutoconfigBalloon_Proxy( 
    IHNetConnection * This,
    /* [out] */ BOOLEAN *pfShowBalloon);


void __RPC_STUB IHNetConnection_ShowAutoconfigBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetConnection_DeleteRasConnectionEntry_Proxy( 
    IHNetConnection * This);


void __RPC_STUB IHNetConnection_DeleteRasConnectionEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetFirewalledConnection_INTERFACE_DEFINED__
#define __IHNetFirewalledConnection_INTERFACE_DEFINED__

/* interface IHNetFirewalledConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetFirewalledConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B72-3032-11D4-9348-00C04F8EEB71")
    IHNetFirewalledConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unfirewall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetFirewalledConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetFirewalledConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetFirewalledConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetFirewalledConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unfirewall )( 
            IHNetFirewalledConnection * This);
        
        END_INTERFACE
    } IHNetFirewalledConnectionVtbl;

    interface IHNetFirewalledConnection
    {
        CONST_VTBL struct IHNetFirewalledConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetFirewalledConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetFirewalledConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetFirewalledConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetFirewalledConnection_Unfirewall(This)	\
    (This)->lpVtbl -> Unfirewall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetFirewalledConnection_Unfirewall_Proxy( 
    IHNetFirewalledConnection * This);


void __RPC_STUB IHNetFirewalledConnection_Unfirewall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetFirewalledConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetIcsPublicConnection_INTERFACE_DEFINED__
#define __IHNetIcsPublicConnection_INTERFACE_DEFINED__

/* interface IHNetIcsPublicConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsPublicConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B73-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsPublicConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unshare( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsPublicConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsPublicConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsPublicConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsPublicConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unshare )( 
            IHNetIcsPublicConnection * This);
        
        END_INTERFACE
    } IHNetIcsPublicConnectionVtbl;

    interface IHNetIcsPublicConnection
    {
        CONST_VTBL struct IHNetIcsPublicConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsPublicConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsPublicConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsPublicConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsPublicConnection_Unshare(This)	\
    (This)->lpVtbl -> Unshare(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsPublicConnection_Unshare_Proxy( 
    IHNetIcsPublicConnection * This);


void __RPC_STUB IHNetIcsPublicConnection_Unshare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsPublicConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetIcsPrivateConnection_INTERFACE_DEFINED__
#define __IHNetIcsPrivateConnection_INTERFACE_DEFINED__

/* interface IHNetIcsPrivateConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetIcsPrivateConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B74-3032-11D4-9348-00C04F8EEB71")
    IHNetIcsPrivateConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemoveFromIcs( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetIcsPrivateConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetIcsPrivateConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetIcsPrivateConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetIcsPrivateConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromIcs )( 
            IHNetIcsPrivateConnection * This);
        
        END_INTERFACE
    } IHNetIcsPrivateConnectionVtbl;

    interface IHNetIcsPrivateConnection
    {
        CONST_VTBL struct IHNetIcsPrivateConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetIcsPrivateConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetIcsPrivateConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetIcsPrivateConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetIcsPrivateConnection_RemoveFromIcs(This)	\
    (This)->lpVtbl -> RemoveFromIcs(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetIcsPrivateConnection_RemoveFromIcs_Proxy( 
    IHNetIcsPrivateConnection * This);


void __RPC_STUB IHNetIcsPrivateConnection_RemoveFromIcs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetIcsPrivateConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetBridge_INTERFACE_DEFINED__
#define __IHNetBridge_INTERFACE_DEFINED__

/* interface IHNetBridge */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B75-3032-11D4-9348-00C04F8EEB71")
    IHNetBridge : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [out] */ IEnumHNetBridgedConnections **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMember( 
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ IHNetBridgedConnection **ppBridgedConn,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridge * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMembers )( 
            IHNetBridge * This,
            /* [out] */ IEnumHNetBridgedConnections **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *AddMember )( 
            IHNetBridge * This,
            /* [in] */ IHNetConnection *pConn,
            /* [out] */ IHNetBridgedConnection **ppBridgedConn,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IHNetBridge * This,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgeVtbl;

    interface IHNetBridge
    {
        CONST_VTBL struct IHNetBridgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridge_EnumMembers(This,ppEnum)	\
    (This)->lpVtbl -> EnumMembers(This,ppEnum)

#define IHNetBridge_AddMember(This,pConn,ppBridgedConn,pnetcfgExisting)	\
    (This)->lpVtbl -> AddMember(This,pConn,ppBridgedConn,pnetcfgExisting)

#define IHNetBridge_Destroy(This,pnetcfgExisting)	\
    (This)->lpVtbl -> Destroy(This,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridge_EnumMembers_Proxy( 
    IHNetBridge * This,
    /* [out] */ IEnumHNetBridgedConnections **ppEnum);


void __RPC_STUB IHNetBridge_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridge_AddMember_Proxy( 
    IHNetBridge * This,
    /* [in] */ IHNetConnection *pConn,
    /* [out] */ IHNetBridgedConnection **ppBridgedConn,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridge_AddMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridge_Destroy_Proxy( 
    IHNetBridge * This,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridge_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridge_INTERFACE_DEFINED__ */


#ifndef __IHNetBridgedConnection_INTERFACE_DEFINED__
#define __IHNetBridgedConnection_INTERFACE_DEFINED__

/* interface IHNetBridgedConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetBridgedConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B76-3032-11D4-9348-00C04F8EEB71")
    IHNetBridgedConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBridge( 
            /* [out] */ IHNetBridge **ppBridge) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromBridge( 
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting = 0) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetBridgedConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetBridgedConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetBridgedConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetBridgedConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBridge )( 
            IHNetBridgedConnection * This,
            /* [out] */ IHNetBridge **ppBridge);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromBridge )( 
            IHNetBridgedConnection * This,
            /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);
        
        END_INTERFACE
    } IHNetBridgedConnectionVtbl;

    interface IHNetBridgedConnection
    {
        CONST_VTBL struct IHNetBridgedConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetBridgedConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetBridgedConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetBridgedConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetBridgedConnection_GetBridge(This,ppBridge)	\
    (This)->lpVtbl -> GetBridge(This,ppBridge)

#define IHNetBridgedConnection_RemoveFromBridge(This,pnetcfgExisting)	\
    (This)->lpVtbl -> RemoveFromBridge(This,pnetcfgExisting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetBridgedConnection_GetBridge_Proxy( 
    IHNetBridgedConnection * This,
    /* [out] */ IHNetBridge **ppBridge);


void __RPC_STUB IHNetBridgedConnection_GetBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetBridgedConnection_RemoveFromBridge_Proxy( 
    IHNetBridgedConnection * This,
    /* [defaultvalue][in] */ INetCfg *pnetcfgExisting);


void __RPC_STUB IHNetBridgedConnection_RemoveFromBridge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetBridgedConnection_INTERFACE_DEFINED__ */


#ifndef __IHNetPortMappingProtocol_INTERFACE_DEFINED__
#define __IHNetPortMappingProtocol_INTERFACE_DEFINED__

/* interface IHNetPortMappingProtocol */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetPortMappingProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7E-3032-11D4-9348-00C04F8EEB71")
    IHNetPortMappingProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPProtocol( 
            /* [out] */ UCHAR *pucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPProtocol( 
            /* [in] */ UCHAR ucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ USHORT usPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuiltIn( 
            /* [out] */ BOOLEAN *pfBuiltIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID **ppGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetPortMappingProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetPortMappingProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetPortMappingProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetPortMappingProtocol * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IHNetPortMappingProtocol * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPProtocol )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ UCHAR *pucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPProtocol )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ UCHAR ucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IHNetPortMappingProtocol * This,
            /* [in] */ USHORT usPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuiltIn )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ BOOLEAN *pfBuiltIn);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHNetPortMappingProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuid )( 
            IHNetPortMappingProtocol * This,
            /* [out] */ GUID **ppGuid);
        
        END_INTERFACE
    } IHNetPortMappingProtocolVtbl;

    interface IHNetPortMappingProtocol
    {
        CONST_VTBL struct IHNetPortMappingProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetPortMappingProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetPortMappingProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetPortMappingProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetPortMappingProtocol_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetPortMappingProtocol_SetName(This,pszwName)	\
    (This)->lpVtbl -> SetName(This,pszwName)

#define IHNetPortMappingProtocol_GetIPProtocol(This,pucProtocol)	\
    (This)->lpVtbl -> GetIPProtocol(This,pucProtocol)

#define IHNetPortMappingProtocol_SetIPProtocol(This,ucProtocol)	\
    (This)->lpVtbl -> SetIPProtocol(This,ucProtocol)

#define IHNetPortMappingProtocol_GetPort(This,pusPort)	\
    (This)->lpVtbl -> GetPort(This,pusPort)

#define IHNetPortMappingProtocol_SetPort(This,usPort)	\
    (This)->lpVtbl -> SetPort(This,usPort)

#define IHNetPortMappingProtocol_GetBuiltIn(This,pfBuiltIn)	\
    (This)->lpVtbl -> GetBuiltIn(This,pfBuiltIn)

#define IHNetPortMappingProtocol_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IHNetPortMappingProtocol_GetGuid(This,ppGuid)	\
    (This)->lpVtbl -> GetGuid(This,ppGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetName_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetPortMappingProtocol_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetName_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetPortMappingProtocol_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetIPProtocol_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ UCHAR *pucProtocol);


void __RPC_STUB IHNetPortMappingProtocol_GetIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetIPProtocol_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [in] */ UCHAR ucProtocol);


void __RPC_STUB IHNetPortMappingProtocol_SetIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetPort_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetPortMappingProtocol_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_SetPort_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetPortMappingProtocol_SetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetBuiltIn_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ BOOLEAN *pfBuiltIn);


void __RPC_STUB IHNetPortMappingProtocol_GetBuiltIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_Delete_Proxy( 
    IHNetPortMappingProtocol * This);


void __RPC_STUB IHNetPortMappingProtocol_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingProtocol_GetGuid_Proxy( 
    IHNetPortMappingProtocol * This,
    /* [out] */ GUID **ppGuid);


void __RPC_STUB IHNetPortMappingProtocol_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetPortMappingProtocol_INTERFACE_DEFINED__ */


#ifndef __IHNetPortMappingBinding_INTERFACE_DEFINED__
#define __IHNetPortMappingBinding_INTERFACE_DEFINED__

/* interface IHNetPortMappingBinding */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetPortMappingBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B80-3032-11D4-9348-00C04F8EEB71")
    IHNetPortMappingBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [out] */ IHNetConnection **ppConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocol( 
            /* [out] */ IHNetPortMappingProtocol **ppProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ BOOLEAN *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ BOOLEAN fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentMethod( 
            /* [out] */ BOOLEAN *pfUseName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetComputerName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetComputerName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetComputerAddress( 
            /* [out] */ ULONG *pulAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetComputerAddress( 
            /* [in] */ ULONG ulAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTargetPort( 
            /* [in] */ USHORT usPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetPortMappingBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetPortMappingBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetPortMappingBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetPortMappingBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IHNetPortMappingBinding * This,
            /* [out] */ IHNetConnection **ppConnection);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocol )( 
            IHNetPortMappingBinding * This,
            /* [out] */ IHNetPortMappingProtocol **ppProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IHNetPortMappingBinding * This,
            /* [out] */ BOOLEAN *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IHNetPortMappingBinding * This,
            /* [in] */ BOOLEAN fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentMethod )( 
            IHNetPortMappingBinding * This,
            /* [out] */ BOOLEAN *pfUseName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetComputerName )( 
            IHNetPortMappingBinding * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetComputerName )( 
            IHNetPortMappingBinding * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetComputerAddress )( 
            IHNetPortMappingBinding * This,
            /* [out] */ ULONG *pulAddress);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetComputerAddress )( 
            IHNetPortMappingBinding * This,
            /* [in] */ ULONG ulAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetPort )( 
            IHNetPortMappingBinding * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetTargetPort )( 
            IHNetPortMappingBinding * This,
            /* [in] */ USHORT usPort);
        
        END_INTERFACE
    } IHNetPortMappingBindingVtbl;

    interface IHNetPortMappingBinding
    {
        CONST_VTBL struct IHNetPortMappingBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetPortMappingBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetPortMappingBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetPortMappingBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetPortMappingBinding_GetConnection(This,ppConnection)	\
    (This)->lpVtbl -> GetConnection(This,ppConnection)

#define IHNetPortMappingBinding_GetProtocol(This,ppProtocol)	\
    (This)->lpVtbl -> GetProtocol(This,ppProtocol)

#define IHNetPortMappingBinding_GetEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> GetEnabled(This,pfEnabled)

#define IHNetPortMappingBinding_SetEnabled(This,fEnable)	\
    (This)->lpVtbl -> SetEnabled(This,fEnable)

#define IHNetPortMappingBinding_GetCurrentMethod(This,pfUseName)	\
    (This)->lpVtbl -> GetCurrentMethod(This,pfUseName)

#define IHNetPortMappingBinding_GetTargetComputerName(This,ppszwName)	\
    (This)->lpVtbl -> GetTargetComputerName(This,ppszwName)

#define IHNetPortMappingBinding_SetTargetComputerName(This,pszwName)	\
    (This)->lpVtbl -> SetTargetComputerName(This,pszwName)

#define IHNetPortMappingBinding_GetTargetComputerAddress(This,pulAddress)	\
    (This)->lpVtbl -> GetTargetComputerAddress(This,pulAddress)

#define IHNetPortMappingBinding_SetTargetComputerAddress(This,ulAddress)	\
    (This)->lpVtbl -> SetTargetComputerAddress(This,ulAddress)

#define IHNetPortMappingBinding_GetTargetPort(This,pusPort)	\
    (This)->lpVtbl -> GetTargetPort(This,pusPort)

#define IHNetPortMappingBinding_SetTargetPort(This,usPort)	\
    (This)->lpVtbl -> SetTargetPort(This,usPort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetConnection_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ IHNetConnection **ppConnection);


void __RPC_STUB IHNetPortMappingBinding_GetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetProtocol_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ IHNetPortMappingProtocol **ppProtocol);


void __RPC_STUB IHNetPortMappingBinding_GetProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetEnabled_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ BOOLEAN *pfEnabled);


void __RPC_STUB IHNetPortMappingBinding_GetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetEnabled_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ BOOLEAN fEnable);


void __RPC_STUB IHNetPortMappingBinding_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetCurrentMethod_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ BOOLEAN *pfUseName);


void __RPC_STUB IHNetPortMappingBinding_GetCurrentMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetComputerName_Proxy( 
    IHNetPortMappingBinding * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetPortMappingBinding_GetTargetComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetComputerName_Proxy( 
    IHNetPortMappingBinding * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetPortMappingBinding_SetTargetComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetComputerAddress_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ ULONG *pulAddress);


void __RPC_STUB IHNetPortMappingBinding_GetTargetComputerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetComputerAddress_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ ULONG ulAddress);


void __RPC_STUB IHNetPortMappingBinding_SetTargetComputerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_GetTargetPort_Proxy( 
    IHNetPortMappingBinding * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetPortMappingBinding_GetTargetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetPortMappingBinding_SetTargetPort_Proxy( 
    IHNetPortMappingBinding * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetPortMappingBinding_SetTargetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetPortMappingBinding_INTERFACE_DEFINED__ */


#ifndef __IHNetApplicationProtocol_INTERFACE_DEFINED__
#define __IHNetApplicationProtocol_INTERFACE_DEFINED__

/* interface IHNetApplicationProtocol */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHNetApplicationProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7F-3032-11D4-9348-00C04F8EEB71")
    IHNetApplicationProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ OLECHAR **ppszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ OLECHAR *pszwName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutgoingIPProtocol( 
            /* [out] */ UCHAR *pucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutgoingIPProtocol( 
            /* [in] */ UCHAR ucProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutgoingPort( 
            /* [out] */ USHORT *pusPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutgoingPort( 
            /* [in] */ USHORT usPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResponseRanges( 
            /* [out] */ USHORT *puscResponses,
            /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResponseRanges( 
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuiltIn( 
            /* [out] */ BOOLEAN *pfBuiltIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnabled( 
            /* [out] */ BOOLEAN *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ BOOLEAN fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHNetApplicationProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHNetApplicationProtocol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHNetApplicationProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHNetApplicationProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IHNetApplicationProtocol * This,
            /* [string][out] */ OLECHAR **ppszwName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IHNetApplicationProtocol * This,
            /* [string][in] */ OLECHAR *pszwName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutgoingIPProtocol )( 
            IHNetApplicationProtocol * This,
            /* [out] */ UCHAR *pucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutgoingIPProtocol )( 
            IHNetApplicationProtocol * This,
            /* [in] */ UCHAR ucProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutgoingPort )( 
            IHNetApplicationProtocol * This,
            /* [out] */ USHORT *pusPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutgoingPort )( 
            IHNetApplicationProtocol * This,
            /* [in] */ USHORT usPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetResponseRanges )( 
            IHNetApplicationProtocol * This,
            /* [out] */ USHORT *puscResponses,
            /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetResponseRanges )( 
            IHNetApplicationProtocol * This,
            /* [in] */ USHORT uscResponses,
            /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuiltIn )( 
            IHNetApplicationProtocol * This,
            /* [out] */ BOOLEAN *pfBuiltIn);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnabled )( 
            IHNetApplicationProtocol * This,
            /* [out] */ BOOLEAN *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IHNetApplicationProtocol * This,
            /* [in] */ BOOLEAN fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHNetApplicationProtocol * This);
        
        END_INTERFACE
    } IHNetApplicationProtocolVtbl;

    interface IHNetApplicationProtocol
    {
        CONST_VTBL struct IHNetApplicationProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHNetApplicationProtocol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHNetApplicationProtocol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHNetApplicationProtocol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHNetApplicationProtocol_GetName(This,ppszwName)	\
    (This)->lpVtbl -> GetName(This,ppszwName)

#define IHNetApplicationProtocol_SetName(This,pszwName)	\
    (This)->lpVtbl -> SetName(This,pszwName)

#define IHNetApplicationProtocol_GetOutgoingIPProtocol(This,pucProtocol)	\
    (This)->lpVtbl -> GetOutgoingIPProtocol(This,pucProtocol)

#define IHNetApplicationProtocol_SetOutgoingIPProtocol(This,ucProtocol)	\
    (This)->lpVtbl -> SetOutgoingIPProtocol(This,ucProtocol)

#define IHNetApplicationProtocol_GetOutgoingPort(This,pusPort)	\
    (This)->lpVtbl -> GetOutgoingPort(This,pusPort)

#define IHNetApplicationProtocol_SetOutgoingPort(This,usPort)	\
    (This)->lpVtbl -> SetOutgoingPort(This,usPort)

#define IHNetApplicationProtocol_GetResponseRanges(This,puscResponses,prgResponseRange)	\
    (This)->lpVtbl -> GetResponseRanges(This,puscResponses,prgResponseRange)

#define IHNetApplicationProtocol_SetResponseRanges(This,uscResponses,rgResponseRange)	\
    (This)->lpVtbl -> SetResponseRanges(This,uscResponses,rgResponseRange)

#define IHNetApplicationProtocol_GetBuiltIn(This,pfBuiltIn)	\
    (This)->lpVtbl -> GetBuiltIn(This,pfBuiltIn)

#define IHNetApplicationProtocol_GetEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> GetEnabled(This,pfEnabled)

#define IHNetApplicationProtocol_SetEnabled(This,fEnable)	\
    (This)->lpVtbl -> SetEnabled(This,fEnable)

#define IHNetApplicationProtocol_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetName_Proxy( 
    IHNetApplicationProtocol * This,
    /* [string][out] */ OLECHAR **ppszwName);


void __RPC_STUB IHNetApplicationProtocol_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetName_Proxy( 
    IHNetApplicationProtocol * This,
    /* [string][in] */ OLECHAR *pszwName);


void __RPC_STUB IHNetApplicationProtocol_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetOutgoingIPProtocol_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ UCHAR *pucProtocol);


void __RPC_STUB IHNetApplicationProtocol_GetOutgoingIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetOutgoingIPProtocol_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ UCHAR ucProtocol);


void __RPC_STUB IHNetApplicationProtocol_SetOutgoingIPProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetOutgoingPort_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ USHORT *pusPort);


void __RPC_STUB IHNetApplicationProtocol_GetOutgoingPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetOutgoingPort_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ USHORT usPort);


void __RPC_STUB IHNetApplicationProtocol_SetOutgoingPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetResponseRanges_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ USHORT *puscResponses,
    /* [length_is][out] */ HNET_RESPONSE_RANGE *prgResponseRange[  ]);


void __RPC_STUB IHNetApplicationProtocol_GetResponseRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetResponseRanges_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ USHORT uscResponses,
    /* [size_is][in] */ HNET_RESPONSE_RANGE rgResponseRange[  ]);


void __RPC_STUB IHNetApplicationProtocol_SetResponseRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetBuiltIn_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ BOOLEAN *pfBuiltIn);


void __RPC_STUB IHNetApplicationProtocol_GetBuiltIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_GetEnabled_Proxy( 
    IHNetApplicationProtocol * This,
    /* [out] */ BOOLEAN *pfEnabled);


void __RPC_STUB IHNetApplicationProtocol_GetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_SetEnabled_Proxy( 
    IHNetApplicationProtocol * This,
    /* [in] */ BOOLEAN fEnable);


void __RPC_STUB IHNetApplicationProtocol_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHNetApplicationProtocol_Delete_Proxy( 
    IHNetApplicationProtocol * This);


void __RPC_STUB IHNetApplicationProtocol_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHNetApplicationProtocol_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetBridges_INTERFACE_DEFINED__
#define __IEnumHNetBridges_INTERFACE_DEFINED__

/* interface IEnumHNetBridges */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetBridges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B77-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetBridges : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridge **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetBridges **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetBridgesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetBridges * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetBridges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetBridges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetBridges * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridge **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetBridges * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetBridges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetBridges * This,
            /* [out] */ IEnumHNetBridges **ppEnum);
        
        END_INTERFACE
    } IEnumHNetBridgesVtbl;

    interface IEnumHNetBridges
    {
        CONST_VTBL struct IEnumHNetBridgesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetBridges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetBridges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetBridges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetBridges_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetBridges_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetBridges_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetBridges_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Next_Proxy( 
    IEnumHNetBridges * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetBridge **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetBridges_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Skip_Proxy( 
    IEnumHNetBridges * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetBridges_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Reset_Proxy( 
    IEnumHNetBridges * This);


void __RPC_STUB IEnumHNetBridges_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridges_Clone_Proxy( 
    IEnumHNetBridges * This,
    /* [out] */ IEnumHNetBridges **ppEnum);


void __RPC_STUB IEnumHNetBridges_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetBridges_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__
#define __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__

/* interface IEnumHNetFirewalledConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetFirewalledConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B78-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetFirewalledConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetFirewalledConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetFirewalledConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetFirewalledConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetFirewalledConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetFirewalledConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetFirewalledConnections * This,
            /* [out] */ IEnumHNetFirewalledConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetFirewalledConnectionsVtbl;

    interface IEnumHNetFirewalledConnections
    {
        CONST_VTBL struct IEnumHNetFirewalledConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetFirewalledConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetFirewalledConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetFirewalledConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetFirewalledConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetFirewalledConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetFirewalledConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetFirewalledConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Next_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetFirewalledConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetFirewalledConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Skip_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetFirewalledConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Reset_Proxy( 
    IEnumHNetFirewalledConnections * This);


void __RPC_STUB IEnumHNetFirewalledConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetFirewalledConnections_Clone_Proxy( 
    IEnumHNetFirewalledConnections * This,
    /* [out] */ IEnumHNetFirewalledConnections **ppEnum);


void __RPC_STUB IEnumHNetFirewalledConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetFirewalledConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__
#define __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__

/* interface IEnumHNetIcsPublicConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetIcsPublicConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B79-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetIcsPublicConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetIcsPublicConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetIcsPublicConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetIcsPublicConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetIcsPublicConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetIcsPublicConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetIcsPublicConnections * This,
            /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetIcsPublicConnectionsVtbl;

    interface IEnumHNetIcsPublicConnections
    {
        CONST_VTBL struct IEnumHNetIcsPublicConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetIcsPublicConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetIcsPublicConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetIcsPublicConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetIcsPublicConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetIcsPublicConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetIcsPublicConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetIcsPublicConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Next_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetIcsPublicConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetIcsPublicConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Skip_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetIcsPublicConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Reset_Proxy( 
    IEnumHNetIcsPublicConnections * This);


void __RPC_STUB IEnumHNetIcsPublicConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPublicConnections_Clone_Proxy( 
    IEnumHNetIcsPublicConnections * This,
    /* [out] */ IEnumHNetIcsPublicConnections **ppEnum);


void __RPC_STUB IEnumHNetIcsPublicConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetIcsPublicConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__
#define __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__

/* interface IEnumHNetIcsPrivateConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetIcsPrivateConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7A-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetIcsPrivateConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetIcsPrivateConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetIcsPrivateConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetIcsPrivateConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetIcsPrivateConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetIcsPrivateConnections * This,
            /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetIcsPrivateConnectionsVtbl;

    interface IEnumHNetIcsPrivateConnections
    {
        CONST_VTBL struct IEnumHNetIcsPrivateConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetIcsPrivateConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetIcsPrivateConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetIcsPrivateConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetIcsPrivateConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetIcsPrivateConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetIcsPrivateConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetIcsPrivateConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Next_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetIcsPrivateConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Skip_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Reset_Proxy( 
    IEnumHNetIcsPrivateConnections * This);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetIcsPrivateConnections_Clone_Proxy( 
    IEnumHNetIcsPrivateConnections * This,
    /* [out] */ IEnumHNetIcsPrivateConnections **ppEnum);


void __RPC_STUB IEnumHNetIcsPrivateConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetIcsPrivateConnections_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__
#define __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__

/* interface IEnumHNetApplicationProtocols */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetApplicationProtocols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7B-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetApplicationProtocols : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetApplicationProtocolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetApplicationProtocols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetApplicationProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetApplicationProtocols * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetApplicationProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetApplicationProtocols * This,
            /* [out] */ IEnumHNetApplicationProtocols **ppEnum);
        
        END_INTERFACE
    } IEnumHNetApplicationProtocolsVtbl;

    interface IEnumHNetApplicationProtocols
    {
        CONST_VTBL struct IEnumHNetApplicationProtocolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetApplicationProtocols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetApplicationProtocols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetApplicationProtocols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetApplicationProtocols_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetApplicationProtocols_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetApplicationProtocols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetApplicationProtocols_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Next_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetApplicationProtocol **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetApplicationProtocols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Skip_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetApplicationProtocols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Reset_Proxy( 
    IEnumHNetApplicationProtocols * This);


void __RPC_STUB IEnumHNetApplicationProtocols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetApplicationProtocols_Clone_Proxy( 
    IEnumHNetApplicationProtocols * This,
    /* [out] */ IEnumHNetApplicationProtocols **ppEnum);


void __RPC_STUB IEnumHNetApplicationProtocols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetApplicationProtocols_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__
#define __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__

/* interface IEnumHNetPortMappingProtocols */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetPortMappingProtocols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7C-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetPortMappingProtocols : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetPortMappingProtocolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetPortMappingProtocols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetPortMappingProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetPortMappingProtocols * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetPortMappingProtocols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetPortMappingProtocols * This,
            /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);
        
        END_INTERFACE
    } IEnumHNetPortMappingProtocolsVtbl;

    interface IEnumHNetPortMappingProtocols
    {
        CONST_VTBL struct IEnumHNetPortMappingProtocolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetPortMappingProtocols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetPortMappingProtocols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetPortMappingProtocols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetPortMappingProtocols_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetPortMappingProtocols_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetPortMappingProtocols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetPortMappingProtocols_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Next_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetPortMappingProtocol **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetPortMappingProtocols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Skip_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetPortMappingProtocols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Reset_Proxy( 
    IEnumHNetPortMappingProtocols * This);


void __RPC_STUB IEnumHNetPortMappingProtocols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingProtocols_Clone_Proxy( 
    IEnumHNetPortMappingProtocols * This,
    /* [out] */ IEnumHNetPortMappingProtocols **ppEnum);


void __RPC_STUB IEnumHNetPortMappingProtocols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetPortMappingProtocols_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__
#define __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__

/* interface IEnumHNetPortMappingBindings */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetPortMappingBindings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B81-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetPortMappingBindings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetPortMappingBindingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetPortMappingBindings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetPortMappingBindings * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetPortMappingBindings * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetPortMappingBindings * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetPortMappingBindings * This,
            /* [out] */ IEnumHNetPortMappingBindings **ppEnum);
        
        END_INTERFACE
    } IEnumHNetPortMappingBindingsVtbl;

    interface IEnumHNetPortMappingBindings
    {
        CONST_VTBL struct IEnumHNetPortMappingBindingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetPortMappingBindings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetPortMappingBindings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetPortMappingBindings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetPortMappingBindings_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetPortMappingBindings_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetPortMappingBindings_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetPortMappingBindings_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Next_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetPortMappingBinding **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetPortMappingBindings_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Skip_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetPortMappingBindings_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Reset_Proxy( 
    IEnumHNetPortMappingBindings * This);


void __RPC_STUB IEnumHNetPortMappingBindings_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetPortMappingBindings_Clone_Proxy( 
    IEnumHNetPortMappingBindings * This,
    /* [out] */ IEnumHNetPortMappingBindings **ppEnum);


void __RPC_STUB IEnumHNetPortMappingBindings_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetPortMappingBindings_INTERFACE_DEFINED__ */


#ifndef __IEnumHNetBridgedConnections_INTERFACE_DEFINED__
#define __IEnumHNetBridgedConnections_INTERFACE_DEFINED__

/* interface IEnumHNetBridgedConnections */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumHNetBridgedConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85D18B7D-3032-11D4-9348-00C04F8EEB71")
    IEnumHNetBridgedConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumHNetBridgedConnections **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumHNetBridgedConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumHNetBridgedConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumHNetBridgedConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumHNetBridgedConnections * This,
            /* [in] */ ULONG cElt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumHNetBridgedConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumHNetBridgedConnections * This,
            /* [out] */ IEnumHNetBridgedConnections **ppEnum);
        
        END_INTERFACE
    } IEnumHNetBridgedConnectionsVtbl;

    interface IEnumHNetBridgedConnections
    {
        CONST_VTBL struct IEnumHNetBridgedConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumHNetBridgedConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumHNetBridgedConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumHNetBridgedConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumHNetBridgedConnections_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumHNetBridgedConnections_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumHNetBridgedConnections_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumHNetBridgedConnections_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Next_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IHNetBridgedConnection **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumHNetBridgedConnections_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Skip_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumHNetBridgedConnections_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Reset_Proxy( 
    IEnumHNetBridgedConnections * This);


void __RPC_STUB IEnumHNetBridgedConnections_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumHNetBridgedConnections_Clone_Proxy( 
    IEnumHNetBridgedConnections * This,
    /* [out] */ IEnumHNetBridgedConnections **ppEnum);


void __RPC_STUB IEnumHNetBridgedConnections_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumHNetBridgedConnections_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_hnetcfg_0182 */
/* [local] */ 

#ifndef NOTIFYFORMATBUFFERSIZE
#define NOTIFYFORMATBUFFERSIZE 1024
#endif
#ifndef HNWCALLBACKBUFFERSIZE
#define HNWCALLBACKBUFFERSIZE 1024
#endif
typedef VOID (STDMETHODCALLTYPE HNWCALLBACK)(LPCWSTR pszLogEntry, LPARAM lParam);
typedef HNWCALLBACK *LPHNWCALLBACK;
HRESULT APIENTRY
HNetGetShareAndBridgeSettings(
    OUT INetConnection  **ppNetPublicConnection,
    OUT INetConnection ***ppNetPrivateConnection,
    OUT BOOLEAN          *pbSharePublicConnection,
    OUT BOOLEAN          *pbFirewallPublicConnection
    );
HRESULT APIENTRY
HNetSetShareAndBridgeSettings(
    IN  INetConnection  *pNetPublicConnection,
    IN  INetConnection  *pNetPrivateConnection[],
    IN  BOOLEAN          bSharePublicConnection,
    IN  BOOLEAN          bFirewallPublicConnection,
    IN  LPHNWCALLBACK    lpHnwCallback,
    IN  LPARAM           lpContext,
    OUT INetConnection **pNetPrivateInterface
    );
typedef HRESULT (APIENTRY *LPFNHNETSETSHAREANDBRIDGESETTINGS)(
    INetConnection  *pNetPublicConnection,
    INetConnection  *pNetPrivateConnection[],
    BOOLEAN          bSharePublicConnection,
    BOOLEAN          bFirewallPublicConnection,
    LPHNWCALLBACK    lpHnwCallback,
    LPARAM           lpContext,
    INetConnection **pNetPrivateInterface );
HRESULT APIENTRY
ObtainIcsErrorConditions(
    IN  LPHNWCALLBACK lpHnwCallback,
    IN  LPARAM        lpContext );
BOOL APIENTRY
HNetSharedAccessSettingsDlg(
    IN  BOOL fSharedAccessMode,
    IN  HWND hwndOwner );
BOOL APIENTRY
HNetSharingAndFirewallSettingsDlg(
    IN HWND             hwndOwner,
    IN IHNetCfgMgr      *pHNetCfgMgr,
    IN BOOL             fShowFwOnlySettings,
    IN OPTIONAL IHNetConnection  *pHNetConn);


extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0182_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_hnetcfg_0182_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\gpcifc.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/

#ifndef __GPCIFC
#define __GPCIFC

//***   gpcifc.h - GPC interface definitions
//
//  This file containes all the GPC interface definitions.


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

//
// Protocol Template Id's
//
#define GPC_PROTOCOL_TEMPLATE_IP                  0
#define GPC_PROTOCOL_TEMPLATE_IPX                 1

#define GPC_PROTOCOL_TEMPLATE_MAX                 2

#define GPC_PROTOCOL_TEMPLATE_NOT_SPECIFIED       (-1)

#define DD_GPC_DEVICE_NAME      L"\\Device\\Gpc"

#define GpcMajorVersion 2

//
// GPC max supported priorities
//
#define GPC_PRIORITY_MAX    16

//
// Classification Family IDs
//
#define GPC_CF_QOS			0
#define GPC_CF_IPSEC_OUT	1
#define GPC_CF_IPSEC_IN		2
#define GPC_CF_FILTER		3
#define GPC_CF_CLASS_MAP	4

#define GPC_CF_MAX			5

//
// IPSEC specific
//
#define GPC_PRIORITY_IPSEC	2
#define GPC_CF_IPSEC	    GPC_CF_IPSEC_OUT
#define GPC_CF_IPSEC_MAX    GPC_CF_IPSEC_IN
#define GPC_CF_IPSEC_MIN    GPC_CF_IPSEC_OUT

//
// GPC flags defined
//
#define GPC_FLAGS_FRAGMENT          			0x00000001
#define GPC_FLAGS_USERMODE_CLIENT_EX 		0x00000002

#define MAX_STRING_LENGTH	256

//
// handle definitions and error codes
//
#define GPC_INVALID_HANDLE	    (-1)

#define GPC_STATUS_SUCCESS				STATUS_SUCCESS
#define GPC_STATUS_PENDING				STATUS_PENDING
#define GPC_STATUS_FAILURE				STATUS_UNSUCCESSFUL
#define GPC_STATUS_RESOURCES			STATUS_INSUFFICIENT_RESOURCES
#define GPC_STATUS_NOTREADY				STATUS_DEVICE_NOT_READY 
#define GPC_STATUS_NOT_FOUND			STATUS_NOT_FOUND
#define GPC_STATUS_CONFLICT				STATUS_DUPLICATE_NAME
#define GPC_STATUS_INVALID_HANDLE		STATUS_INVALID_HANDLE
#define GPC_STATUS_INVALID_PARAMETER	STATUS_INVALID_PARAMETER
#define GPC_STATUS_NOT_SUPPORTED    	STATUS_NOT_SUPPORTED
#define GPC_STATUS_NOT_EMPTY            STATUS_DIRECTORY_NOT_EMPTY
#define GPC_STATUS_TOO_MANY_HANDLES     STATUS_TOO_MANY_OPENED_FILES
#define GPC_STATUS_NOT_IMPLEMENTED      STATUS_NOT_IMPLEMENTED
#define GPC_STATUS_INSUFFICIENT_BUFFER	STATUS_BUFFER_TOO_SMALL
#define GPC_STATUS_NO_MEMORY			STATUS_NO_MEMORY
#define GPC_STATUS_IGNORED				1L


/*
/////////////////////////////////////////////////////////////////
//
//   typedef
//
/////////////////////////////////////////////////////////////////
*/

//
// Gpc status
//
typedef NTSTATUS  GPC_STATUS;

//
// handles
//

typedef HANDLE  GPC_HANDLE, *PGPC_HANDLE;
typedef HANDLE  GPC_CLIENT_HANDLE, *PGPC_CLIENT_HANDLE;

//
// A classification handle is used as a reference to a classification 
// block by the clients
//

typedef ULONG	CLASSIFICATION_HANDLE, *PCLASSIFICATION_HANDLE;

//
// A pointer to the CfInfo blob data that is stored in the GPC.
// The client will use this definition in all references to a CfInfo blob.
//

typedef UCHAR	GPC_CFINFO, *PGPC_CFINFO;

typedef VOID    GPC_PATTERN, *PGPC_PATTERN;

typedef struct _TC_INTERFACE_ID {

    ULONG	InterfaceId;
    ULONG	LinkId;

} TC_INTERFACE_ID, *PTC_INTERFACE_ID;

//
// Clients on the IP stack use the IP template.
// The usage of the union is defined by the value of the ProtocolId,
// which can be IP, TCP, UDP, ICMP or IPSEC.
//
typedef struct _GPC_IP_PATTERN {

    TC_INTERFACE_ID	InterfaceId;
    ULONG			SrcAddr;
    ULONG			DstAddr;
	
    union {
        struct { USHORT s_srcport,s_dstport; } S_un_ports;	      // UDP, TCP
        struct { UCHAR s_type,s_code; USHORT filler; } S_un_icmp; // ICMP
        ULONG	S_Spi;							                  // IPSEC
    } S_un;

    UCHAR	    	ProtocolId;

    UCHAR       	Reserved[3];
    
#define gpcSrcPort	S_un.S_un_ports.s_srcport
#define gpcDstPort	S_un.S_un_ports.s_dstport
#define gpcIcmpType	S_un.S_un_icmp.s_type
#define gpcIcmpCode	S_un.S_un_icmp.s_code
#define gpcSpi		S_un.S_Spi

} GPC_IP_PATTERN, *PGPC_IP_PATTERN;

//
// Clients of the IPX stack will use the IPX pattern
//
typedef struct _GPC_IPX_PATTERN {

    struct {
        ULONG 	NetworkAddress;
        UCHAR 	NodeAddress[6];
        USHORT 	Socket;
    } Src, Dest;

} GPC_IPX_PATTERN, *PGPC_IPX_PATTERN;


typedef struct _GPC_GEN_PATTERN {

    ULONG	ProtocolId;
	ULONG	PatternSize;
	ULONG  	PatternOffset;
	ULONG  	MaskOffset;
    //
    // the pattern and mask bits will follow here...
    //

} GPC_GEN_PATTERN, *PGPC_GEN_PATTERN;


typedef struct _GPC_ENUM_CFINFO_BUFFER {

    ULONG				Length;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    ULONG				CfInfoSize;
    ULONG				CfInfoOffset;	// from the beginning of this buffer
    GPC_CLIENT_HANDLE	OwnerClientCtx;
    ULONG				PatternCount;
    ULONG				PatternMaskLen;
    GPC_GEN_PATTERN		GenericPattern[1];

} GPC_ENUM_CFINFO_BUFFER, *PGPC_ENUM_CFINFO_BUFFER;

/*
/////////////////////////////////////////////////////////////////
//
//   Client handler prototypes
//
/////////////////////////////////////////////////////////////////
*/


typedef
GPC_STATUS
(*GPC_CL_ADD_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_HANDLE				GpcCfInfoHandle,
       IN PTC_INTERFACE_ID InterfaceInfo,
    IN  ULONG                   CfInfoSize,
    IN  PVOID					pCfInfo,
	OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

  
typedef
VOID
(*GPC_CL_ADD_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
VOID
(*GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS	        	Status
    );


typedef
GPC_STATUS
(*GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	PVOID                   pNewCfInfo
    );


typedef
VOID
(*GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
GPC_STATUS
(*GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_CL_GET_CFINFO_NAME)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    OUT	PUNICODE_STRING			CfInfoName
    );


//
// A function list used to pass function pointers for client registration.
//
typedef struct _GPC_CLIENT_FUNC_LIST {

    ULONG 									GpcVersion;
    GPC_CL_ADD_CFINFO_COMPLETE_HANDLER		ClAddCfInfoCompleteHandler;
    GPC_CL_ADD_CFINFO_NOTIFY_HANDLER		ClAddCfInfoNotifyHandler;
    GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER	ClModifyCfInfoCompleteHandler;
    GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER		ClModifyCfInfoNotifyHandler;
    GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER	ClRemoveCfInfoCompleteHandler;
    GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER		ClRemoveCfInfoNotifyHandler;
    GPC_CL_GET_CFINFO_NAME					ClGetCfInfoName;
    
} GPC_CLIENT_FUNC_LIST, *PGPC_CLIENT_FUNC_LIST;


/*
/////////////////////////////////////////////////////////////////
//
//   GPC API prototypes
//
/////////////////////////////////////////////////////////////////
*/


//
// Calls to GPC
//

typedef
GPC_STATUS
(*GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

typedef
GPC_CLIENT_HANDLE
(*GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    );

typedef
GPC_STATUS
(*GPC_GET_ULONG_FROM_CFINFO_HANDLER)(
    IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue
    );

typedef
GPC_STATUS
(*GPC_REGISTER_CLIENT_HANDLER)(
    IN	ULONG					CfId,
	IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
	IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
	IN	GPC_CLIENT_HANDLE		ClientContext,
	OUT	PGPC_HANDLE				pClientHandle
    );

typedef
GPC_STATUS
(*GPC_DEREGISTER_CLIENT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_CFINFO_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN  ULONG					CfInfoSize,
	IN	PVOID					pClientCfInfo,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	OUT	PGPC_HANDLE	    		pGpcCfInfoHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_PATTERN_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					Pattern,
	IN	PVOID					Mask,
	IN	ULONG					Priority,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	OUT	PGPC_HANDLE				pGpcPatternHandle,
	OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

typedef
VOID
(*GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_MODIFY_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
	IN  PVOID	    			pClientCfInfo
    );

typedef
VOID
(*GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle
    );

typedef
VOID
(*GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcPatternHandle
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID			        pPattern,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue,
    IN	BOOLEAN					bNoCache
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PACKET_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					pNdisPacket,   // PNDIS_PACKET type
	IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		pInterfaceId,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    );

typedef struct _GPC_EXPORTED_CALLS {

    ULONG										    GpcVersion;
    HANDLE										    Reserved;
    GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER		    GpcGetCfInfoClientContextHandler;
    GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER	GpcGetCfInfoClientContextWithRefHandler;
    GPC_GET_ULONG_FROM_CFINFO_HANDLER			    GpcGetUlongFromCfInfoHandler;
    GPC_REGISTER_CLIENT_HANDLER					    GpcRegisterClientHandler;
    GPC_DEREGISTER_CLIENT_HANDLER				    GpcDeregisterClientHandler;
    GPC_ADD_CFINFO_HANDLER						    GpcAddCfInfoHandler;
    GPC_ADD_PATTERN_HANDLER						    GpcAddPatternHandler;
    GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER		    GpcAddCfInfoNotifyCompleteHandler;
    GPC_MODIFY_CFINFO_HANDLER					    GpcModifyCfInfoHandler;
    GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcModifyCfInfoNotifyCompleteHandler;
    GPC_REMOVE_CFINFO_HANDLER					    GpcRemoveCfInfoHandler;
    GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcRemoveCfInfoNotifyCompleteHandler;
    GPC_REMOVE_PATTERN_HANDLER					    GpcRemovePatternHandler;
    GPC_CLASSIFY_PATTERN_HANDLER				    GpcClassifyPatternHandler;
    GPC_CLASSIFY_PACKET_HANDLER					    GpcClassifyPacketHandler;

} GPC_EXPORTED_CALLS, *PGPC_EXPORTED_CALLS;


NTSTATUS
GpcInitialize(
	OUT	PGPC_EXPORTED_CALLS		pGpcEntries
    );


NTSTATUS
GpcDeinitialize(
	IN	PGPC_EXPORTED_CALLS		pGpcEntries
    );

#if 0
NTSTATUS
GetInterfaceIdFromIp(
	IN	ULONG   DestAddress,
	IN	PULONG  pBestIfIndex
    );
#endif

#endif // __GPCIFC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\gpcstruc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    gpcstruc.h

Abstract:

    This module contains type definitions for the interface between the traffic dll and
    kernel mode components.

Author:

    Jim Stewart ( jstew )    August 22, 1996

Revision History:

    Yoram Bernet (yoramb)       May 1, 1997

    Ofer Bar (oferbar)          Oct 1, 1997 - Revision 2 changes


--*/

#ifndef __GPCSTRUC_H
#define __GPCSTRUC_H


#define GPC_NOTIFY_CFINFO_CLOSED	1

//
// NtDeviceIoControlFile IoControlCode values for the GPC.
//
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)


#define IOCTL_GPC_REGISTER_CLIENT       CTRL_CODE( 20, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_DEREGISTER_CLIENT     CTRL_CODE( 21, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_CF_INFO           CTRL_CODE( 22, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_PATTERN           CTRL_CODE( 23, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_MODIFY_CF_INFO        CTRL_CODE( 24, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_CF_INFO        CTRL_CODE( 25, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_PATTERN        CTRL_CODE( 26, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ENUM_CFINFO           CTRL_CODE( 27, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_NOTIFY_REQUEST        CTRL_CODE( 28, METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define IOCTL_GPC_ADD_CF_INFO_EX        CTRL_CODE( 30, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GPC_ADD_PATTERN_EX		CTRL_CODE( 31, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GPC_REMOVE_CF_INFO_EX        CTRL_CODE( 32, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GPC_REMOVE_PATTERN_EX        CTRL_CODE( 33, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GPC_REGISTER_CLIENT_EX       CTRL_CODE( 34, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GPC_DEREGISTER_CLIENT_EX     CTRL_CODE( 35, METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_GPC_GET_ENTRIES           CTRL_CODE( 50, METHOD_BUFFERED,FILE_ANY_ACCESS)


/*
/////////////////////////////////////////////////////////////////
//
//   Ioctl buffer formats - user level clients send buffers to the
//   GPC instead of calling entry points. Parameters are returned 
//   in other buffers. Buffers are defined below:
//
/////////////////////////////////////////////////////////////////
*/


//
// Register client
//
typedef struct _GPC_REGISTER_CLIENT_REQ {

    ULONG               CfId;
    ULONG               Flags;
    ULONG               MaxPriorities;
    GPC_CLIENT_HANDLE   ClientContext;

} GPC_REGISTER_CLIENT_REQ, *PGPC_REGISTER_CLIENT_REQ;

typedef struct _GPC_REGISTER_CLIENT_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          ClientHandle;

} GPC_REGISTER_CLIENT_RES, *PGPC_REGISTER_CLIENT_RES;


//
// Deregister client
//
typedef struct _GPC_DEREGISTER_CLIENT_REQ {

    GPC_HANDLE          ClientHandle;

} GPC_DEREGISTER_CLIENT_REQ, *PGPC_DEREGISTER_CLIENT_REQ;

typedef struct _GPC_DEREGISTER_CLIENT_RES {

    GPC_STATUS          Status;

} GPC_DEREGISTER_CLIENT_RES, *PGPC_DEREGISTER_CLIENT_RES;


//
// Add CfInfo
//
typedef struct _GPC_ADD_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_CLIENT_HANDLE   ClientCfInfoContext;    // client specific context
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];  // Varies from CF to CF

} GPC_ADD_CF_INFO_REQ, *PGPC_ADD_CF_INFO_REQ;


//
// Add CfInfo EX
//
typedef struct _GPC_ADD_CF_INFO_EX_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_CLIENT_HANDLE   ClientCfInfoContext;    // client specific context

    //
    // New Fields for QOS only usage
    //
    HANDLE      FileHandle;
    ULONG       RemoteAddress;
    USHORT     RemotePort;

    
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];  // Varies from CF to CF

} GPC_ADD_CF_INFO_EX_REQ, *PGPC_ADD_CF_INFO_EX_REQ;

typedef struct _GPC_ADD_CF_INFO_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          GpcCfInfoHandle;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    
} GPC_ADD_CF_INFO_RES, *PGPC_ADD_CF_INFO_RES;


//
// Add pattern
//
typedef struct _GPC_ADD_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    GPC_CLIENT_HANDLE   ClientPatternContext;
    ULONG               Priority;
    ULONG				ProtocolTemplate;
    ULONG               PatternSize;
    CHAR                PatternAndMask[1];

} GPC_ADD_PATTERN_REQ, *PGPC_ADD_PATTERN_REQ;

typedef struct _GPC_ADD_PATTERN_RES {

    GPC_STATUS              Status;
    GPC_HANDLE              GpcPatternHandle;
    CLASSIFICATION_HANDLE   ClassificationHandle;

} GPC_ADD_PATTERN_RES, *PGPC_ADD_PATTERN_RES;


//
// Modify CfInfo
//
typedef struct _GPC_MODIFY_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];

} GPC_MODIFY_CF_INFO_REQ, *PGPC_MODIFY_CF_INFO_REQ;

typedef struct _GPC_MODIFY_CF_INFO_RES {
    
    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_MODIFY_CF_INFO_RES, *PGPC_MODIFY_CF_INFO_RES;


//
// Remove CfInfo
//
typedef struct _GPC_REMOVE_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;

} GPC_REMOVE_CF_INFO_REQ, *PGPC_REMOVE_CF_INFO_REQ;

typedef struct _GPC_REMOVE_CF_INFO_RES {

    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_REMOVE_CF_INFO_RES, *PGPC_REMOVE_CF_INFO_RES;


//
// Remove pattern
//
typedef struct _GPC_REMOVE_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcPatternHandle;

} GPC_REMOVE_PATTERN_REQ, *PGPC_REMOVE_PATTERN_REQ;

typedef struct _GPC_REMOVE_PATTERN_RES {

    GPC_STATUS          Status;

} GPC_REMOVE_PATTERN_RES, *PGPC_REMOVE_PATTERN_RES;


//
// Enumerate CfInfo
//
typedef struct _GPC_ENUM_CFINFO_REQ {

    GPC_HANDLE          ClientHandle;
    HANDLE				EnumHandle;
    ULONG				CfInfoCount;     // # requested

} GPC_ENUM_CFINFO_REQ, *PGPC_ENUM_CFINFO_REQ;

typedef struct _GPC_ENUM_CFINFO_RES {

    GPC_STATUS          	Status;
    HANDLE					EnumHandle;
    ULONG					TotalCfInfo;     // total installed
    GPC_ENUM_CFINFO_BUFFER	EnumBuffer[1];

} GPC_ENUM_CFINFO_RES, *PGPC_ENUM_CFINFO_RES;


//
// Notify request
//
typedef struct _GPC_NOTIFY_REQUEST_REQ {

    HANDLE       	ClientHandle;

} GPC_NOTIFY_REQUEST_REQ, *PGPC_NOTIFY_REQUEST_REQ;

typedef struct _GPC_NOTIFY_REQUEST_RES {

    HANDLE			ClientCtx;
    ULONG			SubCode;			// notification type
    ULONG			Reason;				// reason
    ULONG_PTR	    NotificationCtx;	// i.e. flow context
    ULONG			Param1;				// optional param
    IO_STATUS_BLOCK	IoStatBlock;		// reserved for the IOCTL

} GPC_NOTIFY_REQUEST_RES, *PGPC_NOTIFY_REQUEST_RES;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\icanon.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    icanon.h

Abstract:

    Function prototypes and definitions for the internal APIs which
    canonicalize, validate, and compare pathnames, LANMAN object
    names, and lists.

Author:

    Danny Glasser (dannygl) 15 June 1989

Notes:

    The references to the old set of canonicalization routines,
    which live in NETLIB, are being kept around for now.  When
    these routines are expunged the references in here should also
    be removed.

Revision History:

    06-May-1991 rfirth
        32-bit version
    11-Jun-1991 rfirth
        Added WI_Net prototypes
    22-Jan-1992 rfirth
        Changed names to be in line with NT naming convention (I_Net => Netp)
        Removed WI_Net prototypes
        Added mapping for old names. Names should be changed in all sources
    24-Feb-1992 rfirth
        Added LM2X_COMPATIBLE support
    10-May-1993 JohnRo
        RAID 6987: allow spaces in computer names (use comma for API lists).
        Also corrected copyright dates and re-ordered this history.
        Allow multiple includes of this file to be harmless.

--*/


#ifndef _ICANON_
#define _ICANON_


#ifdef __cplusplus
extern "C" {
#endif

//
// keep old names for now
//

#define NetpPathType            I_NetPathType
#define NetpPathCanonicalize    I_NetPathCanonicalize
#define NetpPathCompare         I_NetPathCompare
#define NetpNameValidate        I_NetNameValidate
#define NetpNameCanonicalize    I_NetNameCanonicalize
#define NetpNameCompare         I_NetNameCompare
#define NetpListCanonicalize    I_NetListCanonicalize
#define NetpListTraverse        I_NetListTraverse


//
// canonicalization routine prototypes
//

NET_API_STATUS
NetpIsRemote(
    IN  LPWSTR  ComputerName OPTIONAL,
    OUT LPDWORD LocalOrRemote,
    OUT LPWSTR  CanonicalizedName OPTIONAL,
    IN  DWORD   cchCanonName,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpPathType(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpPathCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName,
    IN  LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPWSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NET_API_FUNCTION
NetpPathCompare(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  PathName1,
    IN  LPWSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpNameCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NET_API_FUNCTION
NetpNameCompare(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name1,
    IN  LPWSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NET_API_FUNCTION
NetpListCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  List,
    IN  LPWSTR  Delimiters OPTIONAL,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    );

LPWSTR
NET_API_FUNCTION
NetpListTraverse(
    IN  LPWSTR  Reserved OPTIONAL,
    IN  LPWSTR* pList,
    IN  DWORD   Flags
    );

//
// ** Manifest constants for use with the above functions **
//

//
// Global flags (across all canonicalization functions)
//

#define LM2X_COMPATIBLE                 0x80000000L

#define GLOBAL_CANON_FLAGS              (LM2X_COMPATIBLE)

//
// These are the values which can be returned from NetpIsRemote in LocalOrRemote
//

#define ISREMOTE    (-1)
#define ISLOCAL     0

//
// Flags for NetpIsRemote
//
#define NIRFLAG_MAPLOCAL    0x00000001L
#define NIRFLAG_RESERVED    (~(GLOBAL_CANON_FLAGS|NIRFLAG_MAP_LOCAL))

//
// Flags for I_NetPathType
//
#define INPT_FLAGS_OLDPATHS             0x00000001
#define INPT_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INPT_FLAGS_OLDPATHS))

//
// Flags for I_NetPathCanonicalize
//
#define INPCA_FLAGS_OLDPATHS            0x00000001
#define INPCA_FLAGS_RESERVED            (~(GLOBAL_CANON_FLAGS|INPCA_FLAGS_OLDPATHS))

//
// Flags for I_NetPathCompare
//
#define INPC_FLAGS_PATHS_CANONICALIZED  0x00000001
#define INPC_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INPC_FLAGS_PATHS_CANONICALIZED))

//
// Flags for I_NetNameCanonicalize
//
#define INNCA_FLAGS_FULL_BUFLEN         0x00000001
#define INNCA_FLAGS_RESERVED            (~(GLOBAL_CANON_FLAGS|INNCA_FLAGS_FULL_BUFLEN))

//
// Flags for I_NetNameCompare
//
#define INNC_FLAGS_NAMES_CANONICALIZED  0x00000001
#define INNC_FLAGS_RESERVED             (~(GLOBAL_CANON_FLAGS|INNC_FLAGS_NAMES_CANONICALIZED))

//
// Flags for I_NetNameValidate
//
#define INNV_FLAGS_RESERVED             (~GLOBAL_CANON_FLAGS)

//
// Name types for I_NetName* and I_NetListCanonicalize
//
#define NAMETYPE_USER           1
#define NAMETYPE_PASSWORD       2
#define NAMETYPE_GROUP          3
#define NAMETYPE_COMPUTER       4
#define NAMETYPE_EVENT          5
#define NAMETYPE_DOMAIN         6
#define NAMETYPE_SERVICE        7
#define NAMETYPE_NET            8
#define NAMETYPE_SHARE          9
#define NAMETYPE_MESSAGE        10
#define NAMETYPE_MESSAGEDEST    11
#define NAMETYPE_SHAREPASSWORD  12
#define NAMETYPE_WORKGROUP      13


//
// Special name types for I_NetListCanonicalize
//
#define NAMETYPE_COPYONLY       0
#define NAMETYPE_PATH           INLC_FLAGS_MASK_NAMETYPE

//
// Flags for I_NetListCanonicalize
//
#define INLC_FLAGS_MASK_NAMETYPE        0x000000FF
#define INLC_FLAGS_MASK_OUTLIST_TYPE    0x00000300
#define OUTLIST_TYPE_NULL_NULL          0x00000100
#define OUTLIST_TYPE_API                0x00000200
#define OUTLIST_TYPE_SEARCHPATH         0x00000300
#define INLC_FLAGS_CANONICALIZE         0x00000400
#define INLC_FLAGS_MULTIPLE_DELIMITERS  0x00000800
#define INLC_FLAGS_MASK_RESERVED        (~(GLOBAL_CANON_FLAGS| \
                                        INLC_FLAGS_MASK_NAMETYPE |   \
                                        INLC_FLAGS_MASK_OUTLIST_TYPE |  \
                                        INLC_FLAGS_CANONICALIZE |       \
                                        INLC_FLAGS_MULTIPLE_DELIMITERS))

//
// Delimiter strings for the three types of input lists accepted by
// I_NetListCanonicalize.
//
#define LIST_DELIMITER_STR_UI               TEXT(" \t;,")
#define LIST_DELIMITER_STR_API              TEXT(",")
#define LIST_DELIMITER_STR_NULL_NULL        TEXT("")

//
// The API list delimiter character
//
#define LIST_DELIMITER_CHAR_API             TEXT(',')

//
// The Search-path list delimiter character
//
#define LIST_DELIMITER_CHAR_SEARCHPATH      ';'

//
// The list quote character
//
#define LIST_QUOTE_CHAR                     '\"'


/*NOINC*/
/*
 * MAX_API_LIST_SIZE(maxelts, maxsize)
 * MAX_SEARCHPATH_LIST_SIZE(maxelts, maxsize)
 * MAX_NULL_NULL_LIST_SIZE(maxelts, maxsize)
 *
 * These macros specify the maximum size (in bytes) of API, search-path,
 * and null-null  lists, respectively, given the maximum number of elements
 * and the maximum size (in bytes, not including the terminating null) of
 * an element.  They are intended to be used in allocating arrays large
 * enough to hold the output of I_NetListCanonicalize.
 *
 * The size of an API or search-path list entry is three more than the size
 * of the element.  This includes two bytes for leading and trailing quote
 * characters and one byte for a trailing delimiter (or null, for the last
 * element).
 *
 * The size of a null-null list is one more than the size the elements
 * concantenated (allowing for a terminating null after each element).  The
 * extra byte is for the second null which follows the last element.
 */
#define MAX_API_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 3))

#define MAX_SEARCHPATH_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 3))

#define MAX_NULL_NULL_LIST_SIZE(maxelts, maxsize)     \
        ((maxelts) * ((maxsize) + 1) + 1)

/*INC*/

/***
 *      Constants for type return value.
 *      --> THESE ARE ONLY BUILDING BLOCKS, THEY ARE NOT RETURNED <---
 */

#define ITYPE_WILD              0x1
#define ITYPE_NOWILD            0

#define ITYPE_ABSOLUTE          0x2
#define ITYPE_RELATIVE          0

#define ITYPE_DPATH             0x4
#define ITYPE_NDPATH            0

#define ITYPE_DISK              0
#define ITYPE_LPT               0x10
#define ITYPE_COM               0x20
#define ITYPE_COMPNAME          0x30
#define ITYPE_CON               0x40
#define ITYPE_NUL               0x50

/*
 *      Meta-system names are used in the permission database.  A meta
 *      system name applies to a whole class of objects.  For example,
 *      \MAILSLOT applies to all mailslots.  These are NOT valid
 *      system object names themselves.
 */

#define ITYPE_SYS               0x00000800
#define ITYPE_META              0x00008000          /* See above */
#define ITYPE_SYS_MSLOT         (ITYPE_SYS|0)
#define ITYPE_SYS_SEM           (ITYPE_SYS|0x100)
#define ITYPE_SYS_SHMEM         (ITYPE_SYS|0x200)
#define ITYPE_SYS_PIPE          (ITYPE_SYS|0x300)
#define ITYPE_SYS_COMM          (ITYPE_SYS|0x400)
#define ITYPE_SYS_PRINT         (ITYPE_SYS|0x500)
#define ITYPE_SYS_QUEUE         (ITYPE_SYS|0x600)

#define ITYPE_UNC               0x1000  /* unc paths */
#define ITYPE_PATH              0x2000  /* 'local' non-unc paths */
#define ITYPE_DEVICE            0x4000

#define   ITYPE_PATH_SYS        (ITYPE_PATH_ABSND|ITYPE_SYS)
#define   ITYPE_UNC_SYS         (ITYPE_UNC|ITYPE_SYS)

/* End of building blocks. */


/***
 *      The real things...
 *      WHAT GETS RETURNED
 */

/*        ITYPE_UNC:  \\foo\bar and \\foo\bar\x\y */
#define   ITYPE_UNC_COMPNAME    (ITYPE_UNC|ITYPE_COMPNAME)
#define   ITYPE_UNC_WC          (ITYPE_UNC|ITYPE_COMPNAME|ITYPE_WILD)
#define   ITYPE_UNC_SYS_SEM     (ITYPE_UNC_SYS|ITYPE_SYS_SEM)
#define   ITYPE_UNC_SYS_SHMEM   (ITYPE_UNC_SYS|ITYPE_SYS_SHMEM)
#define   ITYPE_UNC_SYS_MSLOT   (ITYPE_UNC_SYS|ITYPE_SYS_MSLOT)
#define   ITYPE_UNC_SYS_PIPE    (ITYPE_UNC_SYS|ITYPE_SYS_PIPE)
#define   ITYPE_UNC_SYS_QUEUE   (ITYPE_UNC_SYS|ITYPE_SYS_QUEUE)

#define   ITYPE_PATH_ABSND      (ITYPE_PATH|ITYPE_ABSOLUTE|ITYPE_NDPATH)
#define   ITYPE_PATH_ABSD       (ITYPE_PATH|ITYPE_ABSOLUTE|ITYPE_DPATH)
#define   ITYPE_PATH_RELND      (ITYPE_PATH|ITYPE_RELATIVE|ITYPE_NDPATH)
#define   ITYPE_PATH_RELD       (ITYPE_PATH|ITYPE_RELATIVE|ITYPE_DPATH)
#define   ITYPE_PATH_ABSND_WC   (ITYPE_PATH_ABSND|ITYPE_WILD)
#define   ITYPE_PATH_ABSD_WC    (ITYPE_PATH_ABSD|ITYPE_WILD)
#define   ITYPE_PATH_RELND_WC   (ITYPE_PATH_RELND|ITYPE_WILD)
#define   ITYPE_PATH_RELD_WC    (ITYPE_PATH_RELD|ITYPE_WILD)

#define   ITYPE_PATH_SYS_SEM    (ITYPE_PATH_SYS|ITYPE_SYS_SEM)
#define   ITYPE_PATH_SYS_SHMEM  (ITYPE_PATH_SYS|ITYPE_SYS_SHMEM)
#define   ITYPE_PATH_SYS_MSLOT  (ITYPE_PATH_SYS|ITYPE_SYS_MSLOT)
#define   ITYPE_PATH_SYS_PIPE   (ITYPE_PATH_SYS|ITYPE_SYS_PIPE)
#define   ITYPE_PATH_SYS_COMM   (ITYPE_PATH_SYS|ITYPE_SYS_COMM)
#define   ITYPE_PATH_SYS_PRINT  (ITYPE_PATH_SYS|ITYPE_SYS_PRINT)
#define   ITYPE_PATH_SYS_QUEUE  (ITYPE_PATH_SYS|ITYPE_SYS_QUEUE)

#define   ITYPE_PATH_SYS_SEM_M  (ITYPE_PATH_SYS|ITYPE_SYS_SEM|ITYPE_META)
#define   ITYPE_PATH_SYS_SHMEM_M (ITYPE_PATH_SYS|ITYPE_SYS_SHMEM|ITYPE_META)
#define   ITYPE_PATH_SYS_MSLOT_M (ITYPE_PATH_SYS|ITYPE_SYS_MSLOT|ITYPE_META)
#define   ITYPE_PATH_SYS_PIPE_M (ITYPE_PATH_SYS|ITYPE_SYS_PIPE|ITYPE_META)
#define   ITYPE_PATH_SYS_COMM_M (ITYPE_PATH_SYS|ITYPE_SYS_COMM|ITYPE_META)
#define   ITYPE_PATH_SYS_PRINT_M (ITYPE_PATH_SYS|ITYPE_SYS_PRINT|ITYPE_META)
#define   ITYPE_PATH_SYS_QUEUE_M (ITYPE_PATH_SYS|ITYPE_SYS_QUEUE|ITYPE_META)

#define   ITYPE_DEVICE_DISK     (ITYPE_DEVICE|ITYPE_DISK)
#define   ITYPE_DEVICE_LPT      (ITYPE_DEVICE|ITYPE_LPT)
#define   ITYPE_DEVICE_COM      (ITYPE_DEVICE|ITYPE_COM)
#define   ITYPE_DEVICE_CON      (ITYPE_DEVICE|ITYPE_CON)
#define   ITYPE_DEVICE_NUL      (ITYPE_DEVICE|ITYPE_NUL)


#ifdef __cplusplus
}
#endif

#endif // ndef _ICANON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ipfltdrv.h ===
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ipfltdrv.h

Abstract:

    Contains the IOCTLs and related data structures needed to interact with the IP
    Filter Driver

Author:

    Amritansh Raghav

Revision History:

    amritanr         30th Nov 1995     Created

--*/

#ifndef __IPFLTDRV_H__
#define __IPFLTDRV_H__

#if _MSC_VER > 1000
#pragma once
#endif


#define IPHDRLEN 0xf                  // header length mask in iph_verlen
#define IPHDRSFT 2                    // scaling value for the length


//
// Typedefs used in this file
//

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED  1

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED
#include <pfhook.h>

//
// if you don't want these definitions, define the manifest in your sources file
//

#include <packon.h>

//
// Structure of an ICMP header.
//
#ifndef IP_H_INCLUDED
//* IP Header format.
struct IPHeader {
    uchar       iph_verlen;             // Version and length.
    uchar       iph_tos;                // Type of service.
    ushort      iph_length;             // Total length of datagram.
    ushort      iph_id;                 // Identification.
    ushort      iph_offset;             // Flags and fragment offset.
    uchar       iph_ttl;                // Time to live.
    uchar       iph_protocol;           // Protocol.
    ushort      iph_xsum;               // Header checksum.
    IPAddr      iph_src;                // Source address.
    IPAddr      iph_dest;               // Destination address.
}; /* IPHeader */
typedef struct IPHeader IPHeader;
#endif

#ifndef ICMPHEADER_INCLUDED
typedef struct ICMPHeader {
    UCHAR       ich_type;           // Type of ICMP packet.
    UCHAR       ich_code;           // Subcode of type.
    USHORT      ich_xsum;           // Checksum of packet.
    ULONG       ich_param;          // Type-specific parameter field.
} ICMPHeader , *PICMPHeader;
#endif
#include <packoff.h>

#include <rtinfo.h>
#include <ipinfoid.h>
#include <ipfltinf.h>

#define IP_FILTER_DRIVER_VERSION_1    1
#define IP_FILTER_DRIVER_VERSION_2    1
#define IP_FILTER_DRIVER_VERSION    IP_FILTER_DRIVER_VERSION_2

#define MAX_ADDRWORDS            1

//
// common flags
//

#define PF_GLOBAL_FLAGS_LOGON    0x80000000
#define PF_GLOBAL_FLAGS_ABSORB   0x40000000

//
// Log ID
//
typedef UINT_PTR PFLOGGER ;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Service name - this is what the service is called                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IPFLTRDRVR_SERVICE_NAME "IPFilterDriver"

//
// The following definitions come from <pfhook.h> now.
//

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Device Name - this string is the name of the device.  It is the name     //
// that should be passed to NtOpenFile when accessing the device.           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//#define DD_IPFLTRDRVR_DEVICE_NAME   L"\\Device\\IPFILTERDRIVER"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IOCTL code definitions and related structures                            //
// All the IOCTLs are synchronous and need administrator privilege          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//#define FSCTL_IPFLTRDRVR_BASE     FILE_DEVICE_NETWORK

//#define _IPFLTRDRVR_CTL_CODE(function, method, access) \
//                 CTL_CODE(FSCTL_IPFLTRDRVR_BASE, function, method, access)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to to create an interface in the filter driver. It    //
// takes in an index and an opaque context. It creates an interface,        //
// associates the index and context with it and returns a context for this  //
// created interface. All future IOCTLS require this context that is passed //
// out                                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_CREATE_INTERFACE \
            _IPFLTRDRVR_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _FILTER_DRIVER_CREATE_INTERFACE
{
    IN    DWORD   dwIfIndex;
    IN    DWORD   dwAdapterId;
    IN    PVOID   pvRtrMgrContext;
    OUT   PVOID   pvDriverContext;
}FILTER_DRIVER_CREATE_INTERFACE, *PFILTER_DRIVER_CREATE_INTERFACE;

#define INVALID_FILTER_DRIVER_CONTEXT  NULL

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to set filters for an interface.                      //
// The context used to identify the interface is the one that is passed out //
// by the CREATE_INTERFACE IOCTL                                            //
// There can be two TOC entries, one for IP_FILTER_DRIVER_IN_FILTER_INFO    //
// and the other for IP_FILTER_DRIVER_OUT_FILTER_INFO.                      //
// If a (in or out) TOC entry doesnt exist, no change is made to the        //
// (in or out) filters.                                                     //
// If a (in or out) TOC exists and its size is 0, the (in or out) filters   //
// are deleted and the default (in or out) action set to FORWARD.           //
// If a TOC exists and its size is not 0 but the number of filters in the   //
// FILTER_DESCRIPTOR is 0, the old filters are deleted and the default      //
// action set to the one specified in the descriptor.                       //
// The last case is when the Toc exists, its size is not 0, and the         //
// number of filters is also not 0. In this case, the old filters are       //
// deleted, the default action set to the one specified in the descriptor   //
// and the new filters are added.                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_SET_INTERFACE_FILTERS \
            _IPFLTRDRVR_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// NOTE: These two IDs are reused but since they are used in different      //
// namespaces, we can do that safely                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IP_FILTER_DRIVER_IN_FILTER_INFO         IP_GENERAL_INFO_BASE + 1
#define IP_FILTER_DRIVER_OUT_FILTER_INFO        IP_GENERAL_INFO_BASE + 2

typedef struct _FILTER_DRIVER_SET_FILTERS
{
    IN   PVOID                  pvDriverContext;
    IN   RTR_INFO_BLOCK_HEADER  ribhInfoBlock;
}FILTER_DRIVER_SET_FILTERS, *PFILTER_DRIVER_SET_FILTERS;

//
//Definitions for logging and for filter defs.
//


typedef enum _pfEtype
{
    PFE_FILTER = 1,
    PFE_SYNORFRAG,
    PFE_SPOOF,
    PFE_UNUSEDPORT,
    PFE_ALLOWCTL,
    PFE_FULLDENY,
    PFE_NOFRAG,
    PFE_STRONGHOST,
    PFE_FRAGCACHE
} PFETYPE, *PPFETYPE;

typedef struct _FILTER_INFO
{
    DWORD   dwSrcAddr;
    DWORD   dwSrcMask;
    DWORD   dwDstAddr;
    DWORD   dwDstMask;
    DWORD   dwProtocol;
    DWORD   fLateBound;
    WORD    wSrcPort;
    WORD    wDstPort;
}FILTER_INFO, *PFILTER_INFO;

typedef enum _AddrType
{
   IPV4,
   IPV6
}ADDRTYPE, *PADDRTYPE;

typedef struct _FILTER_INFO2
{
    ADDRTYPE addrType;
    DWORD   dwaSrcAddr[MAX_ADDRWORDS];
    DWORD   dwaSrcMask[MAX_ADDRWORDS];
    DWORD   dwaDstAddr[MAX_ADDRWORDS];
    DWORD   dwaDstMask[MAX_ADDRWORDS];
    DWORD   dwProtocol;
    DWORD   fLateBound;
    WORD    wSrcPort;
    WORD    wDstPort;
    WORD    wSrcPortHigh;
    WORD    wDstPortHigh;
}FILTER_INFO2, *PFILTER_INFO2;

typedef struct _FILTER_DESCRIPTOR
{
    DWORD           dwVersion;
    DWORD           dwNumFilters;
    FORWARD_ACTION  faDefaultAction;
    FILTER_INFO     fiFilter[1];
}FILTER_DESCRIPTOR, *PFILTER_DESCRIPTOR;

//
// new filter definition
//

typedef struct _pfFilterInfoEx
{
    PFETYPE  type;
    DWORD dwFlags;
    DWORD  dwFilterRule;
    PVOID   pvFilterHandle;
    FILTER_INFO2 info;
} FILTER_INFOEX, *PFILTER_INFOEX;

#define FLAGS_INFOEX_NOSYN   0x1        // not implemented.
#define FLAGS_INFOEX_LOGALL  0x2
#define FLAGS_INFOEX_ALLOWDUPS 0x4
#define FLAGS_INFOEX_ALLFLAGS 0x7
#define FLAGS_INFOEX_ALLOWANYREMOTEADDRESS 0x8
#define FLAGS_INFOEX_ALLOWANYLOCALADDRESS 0x10

typedef struct _FILTER_DESCRIPTOR2
{
    DWORD           dwVersion;         // must be 2
    DWORD           dwNumFilters;
    FILTER_INFOEX   fiFilter[1];
} FILTER_DESCRIPTOR2, *PFILTER_DESCRIPTOR2;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The constants that should be used to set up the FILTER_INFO_STRUCTURE    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)

#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
//#define FILTER_PROTO_TCP_ESTAB  FILTER_PROTO(0x86)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// For WAN interfaces, the address is unknown at the time the filters are   //
// set. Use these two constants two specify "Local Address". The address    //
// and mask are set with IOCTL_INTERFACE_BOUND                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SRC_ADDR_USE_LOCAL_FLAG     0x00000001
#define SRC_ADDR_USE_REMOTE_FLAG    0x00000002
#define DST_ADDR_USE_LOCAL_FLAG     0x00000004
#define DST_ADDR_USE_REMOTE_FLAG    0x00000008
#define SRC_MASK_LATE_FLAG          0x00000010
#define DST_MASK_LATE_FLAG          0x00000020

#define SetSrcAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_LOCAL_FLAG)

#define SetSrcAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= SRC_ADDR_USE_REMOTE_FLAG)

#define SetDstAddrToLocalAddr(pFilter)      \
    ((pFilter)->fLateBound |= DST_ADDR_USE_LOCAL_FLAG)

#define SetDstAddrToRemoteAddr(pFilter)     \
    ((pFilter)->fLateBound |= DST_ADDR_USE_REMOTE_FLAG)

#define SetSrcMaskLateFlag(pFilter) ((pFilter)->fLateBound |= SRC_MASK_LATE_FLAG)
#define SetDstMaskLateFlag(pFilter) ((pFilter)->fLateBound |= DST_MASK_LATE_FLAG)

#define AreAllFieldsUnchanged(pFilter)      \
    ((pFilter)->fLateBound == 0x00000000)

#define DoesSrcAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & SRC_ADDR_USE_LOCAL_FLAG)

#define DoesSrcAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & SRC_ADDR_USE_REMOTE_FLAG)

#define DoesDstAddrUseLocalAddr(pFilter)    \
    ((pFilter)->fLateBound & DST_ADDR_USE_LOCAL_FLAG)

#define DoesDstAddrUseRemoteAddr(pFilter)   \
    ((pFilter)->fLateBound & DST_ADDR_USE_REMOTE_FLAG)

#define IsSrcMaskLateBound(pFilter) ((pFilter)->fLateBound & SRC_MASK_LATE_FLAG)
#define IsDstMaskLateBound(pFilter) ((pFilter)->fLateBound & DST_MASK_LATE_FLAG)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is used to specify address and mask information for WAN       //
// interfaces at the time they bind. The driver goes through all the        //
// filters for the interface specified by pvDriverContext and if the        //
// fLateBind flag was sepecified for the filter, it changes the             //
// any FILTER_ADDRESS_UNKNOWN fields in the source with dwSrcAddr and       //
// those in the dest with dwDstAddr                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_SET_LATE_BOUND_FILTERS \
            _IPFLTRDRVR_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


typedef struct _FILTER_DRIVER_BINDING_INFO
{
    IN  PVOID   pvDriverContext;
    IN  DWORD   dwLocalAddr;
    IN  DWORD   dwRemoteAddr;
    IN  DWORD   dwMask;
}FILTER_DRIVER_BINDING_INFO, *PFILTER_DRIVER_BINDING_INFO;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL deletes an interface. Once this is called, one may not use    //
// the context of this interface for either any of the IOCTLs or the        //
// MatchFilter() function                                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_DELETE_INTERFACE \
            _IPFLTRDRVR_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DELETE_INTERFACEEX \
            _IPFLTRDRVR_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _FILTER_DRIVER_DELETE_INTERFACE
{
    IN   PVOID   pvDriverContext;
}FILTER_DRIVER_DELETE_INTERFACE, *PFILTER_DRIVER_DELETE_INTERFACE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL is exposed so that a user mode test utility can test the      //
// correctness of implementation of the driver                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_TEST_PACKET \
            _IPFLTRDRVR_CTL_CODE(4, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_DRIVER_TEST_PACKET
{
    IN   PVOID            pvInInterfaceContext;
    IN   PVOID            pvOutInterfaceContext;
    OUT  FORWARD_ACTION   eaResult;
    IN   BYTE             bIpPacket[1];
}FILTER_DRIVER_TEST_PACKET, *PFILTER_DRIVER_TEST_PACKET;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL get the information associated with an interface. This        //
// includes the filters set for the interface and statistics related to the //
// filters themselves. If the size of buffer passed to it is less than      //
// sizeof(FILTER_DRIVER_GET_FILTERS), it returns STATUS_INSUFFICIENT_BUFFER.//
// If the size is >= sizeof(FILTER_DRIVER_GET_FILTERS) but less than what is//
// needed to fill in all the FILTER_STATS, then only the number of in and   //
// out filters is written out (so that the user can figure out how much     //
// memory is needed) and it return STATUS_SUCCESS. If the buffer passed is  //
// large enough all the information is written out                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_GET_FILTER_INFO \
            _IPFLTRDRVR_CTL_CODE(5, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_STATS_EX
{
    DWORD       dwNumPacketsFiltered;
    FILTER_INFOEX info;
}FILTER_STATS_EX, *PFILTER_STATS_EX;

typedef struct _FILTER_STATS
{
    DWORD       dwNumPacketsFiltered;
    FILTER_INFO info;
}FILTER_STATS, *PFILTER_STATS;

typedef struct _FILTER_IF
{
    FORWARD_ACTION   eaInAction;
    FORWARD_ACTION   eaOutAction;
    DWORD            dwNumInFilters;
    DWORD            dwNumOutFilters;
    FILTER_STATS     filters[1];
}FILTER_IF, *PFILTER_IF;

typedef struct _FILTER_DRIVER_GET_FILTERS
{
    IN   PVOID     pvDriverContext;
    OUT  DWORD     dwDefaultHitsIn;
    OUT  DWORD     dwDefaultHitsOut;
    OUT  FILTER_IF interfaces;
}FILTER_DRIVER_GET_FILTERS, *PFILTER_DRIVER_GET_FILTERS;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This IOCTL gets the performance information associated with the filter   //
// driver. This information is only collected if the driver is built with   //
// the DRIVER_PERF flag                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_GET_FILTER_TIMES \
            _IPFLTRDRVR_CTL_CODE(6, METHOD_BUFFERED, FILE_READ_ACCESS)

typedef struct _FILTER_DRIVER_GET_TIMES
{
    OUT DWORD           dwFragments;
    OUT DWORD           dwNumPackets;
    OUT DWORD           dwCache1;
    OUT DWORD           dwCache2;
    OUT DWORD           dwWalk1;
    OUT DWORD           dwWalk2;
    OUT DWORD           dwForw;
    OUT DWORD           dwWalkCache;
    OUT LARGE_INTEGER   liTotalTime;
}FILTER_DRIVER_GET_TIMES, *PFILTER_DRIVER_GET_TIMES;



typedef struct _MIB_IFFILTERTABLE
{
    DWORD       dwIfIndex;
    DWORD       dwDefaultHitsIn;
    DWORD       dwDefaultHitsOut;
    FILTER_IF   table;
}MIB_IFFILTERTABLE, *PMIB_IFFILTERTABLE;


#define SIZEOF_IFFILTERTABLE(X)     \
    (MAX_MIB_OFFSET + sizeof(MIB_IFFILTERTABLE) - sizeof(FILTER_STATS) + ((X) * sizeof(FILTER_STATS)) + ALIGN_SIZE)

typedef struct _FILTER_DRIVER_GET_TIMES MIB_IFFILTERTIMES, *PMIB_IFFILTERTIMES;


//
// New IOCTLs and definitions for creating interfaces and filters and
// retrieving information
//

#define IOCTL_PF_CREATE_AND_SET_INTERFACE_PARAMETERS \
            _IPFLTRDRVR_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_PF_GET_INTERFACE_PARAMETERS \
            _IPFLTRDRVR_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)


typedef enum _PfBindingType
{
    PF_BIND_NONE = 0,
    PF_BIND_IPV4ADDRESS,
    PF_BIND_IPV6ADDRESS,
    PF_BIND_NAME,
    PF_BIND_INTERFACEINDEX
} PFBINDINGTYPE, *PPFBINDINGTYPE;

typedef struct _pfSetInterfaceParameters
{
    PFBINDINGTYPE pfbType;
    DWORD  dwBindingData;
    FORWARD_ACTION eaIn;
    FORWARD_ACTION eaOut;
    FILTER_DRIVER_CREATE_INTERFACE fdInterface;
    DWORD dwInterfaceFlags;
    PFLOGGER pfLogId;
} PFINTERFACEPARAMETERS, *PPFINTERFACEPARAMETERS;

//
// flags for dwInterfaceFlags
//

#define PFSET_FLAGS_UNIQUE          0x1

//
// Structure used to fetch the interface parameters
//

typedef struct _pfGetInterfaceParameters
{
    DWORD   dwReserved;
    PVOID   pvDriverContext;
    DWORD   dwFlags;
    DWORD   dwInDrops;
    DWORD   dwOutDrops;
    FORWARD_ACTION   eaInAction;
    FORWARD_ACTION   eaOutAction;
    DWORD   dwNumInFilters;
    DWORD   dwNumOutFilters;
    DWORD   dwSynOrFrag;
    DWORD   dwSpoof;
    DWORD   dwUnused;
    DWORD   dwTcpCtl;
    LARGE_INTEGER   liSYN;
    LARGE_INTEGER   liTotalLogged;
    DWORD   dwLostLogEntries;
    FILTER_STATS_EX  FilterInfo[1];
} PFGETINTERFACEPARAMETERS, *PPFGETINTERFACEPARAMETERS;

//
// flags for above
//

#define GET_FLAGS_RESET           0x1        // reset all fetched counters
#define GET_FLAGS_FILTERS         0x2        // fetch filters as well
#define GET_BY_INDEX              0x4        // pvDriverContext is an
                                             //  interface index not
                                             //  an interface handle

//
// These IOCTL definitions are used to create, modify and delete
// log interfaces
//

#define IOCTL_PF_CREATE_LOG \
            _IPFLTRDRVR_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_PF_DELETE_LOG \
            _IPFLTRDRVR_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// A logged frame.
//
typedef struct _pfLoggedFrame
{
    LARGE_INTEGER  Timestamp;
    PFETYPE     pfeTypeOfFrame;
    DWORD       dwTotalSizeUsed;
    DWORD       dwFilterRule;
    WORD        wSizeOfAdditionalData;
    WORD        wSizeOfIpHeader;
    DWORD       dwRtrMgrIndex;
    DWORD       dwIPIndex;
    IPHeader    IpHeader;
    BYTE        bData[1];
} PFLOGGEDFRAME, *PPFLOGGEDFRAME;

typedef struct _PfLog
{
    PFLOGGER pfLogId;
    HANDLE hEvent;
    DWORD dwFlags;        // see LOG_ flags below
} PFLOG, *PPFLOG;

typedef struct _PfDeleteLog
{
    PFLOGGER pfLogId;
} PFDELETELOG, *PPFDELETELOG;

//
// set a new log buffer. Note dwSize is an in/out
//
typedef struct _PfSetBuffer
{
    IN      PFLOGGER pfLogId;
    IN OUT  DWORD dwSize;
    OUT     DWORD dwLostEntries;
    OUT     DWORD dwLoggedEntries;
    OUT     PBYTE pbPreviousAddress;
    IN      DWORD dwSizeThreshold;
    IN      DWORD dwEntriesThreshold;
    IN      DWORD dwFlags;
    IN      PBYTE pbBaseOfLog;
} PFSETBUFFER, *PPFSETBUFFER;

typedef struct _InterfaceBinding
{
    PVOID   pvDriverContext;
    PFBINDINGTYPE pfType;
    DWORD   dwAdd;
    DWORD   dwEpoch;
} INTERFACEBINDING, *PINTERFACEBINDING;

typedef struct _InterfaceBinding2
{
    PVOID   pvDriverContext;
    PFBINDINGTYPE pfType;
    DWORD   dwAdd;
    DWORD   dwEpoch;
    DWORD   dwLinkAdd;
} INTERFACEBINDING2, *PINTERFACEBINDING2;


//
// flags for above
//

#define LOG_LOG_ABSORB    0x1        // log is used to absorb frames

typedef struct _FIlterDriverGetSyncCount
{
    LARGE_INTEGER liCount;
} FILTER_DRIVER_GET_SYN_COUNT, *PFILTER_DRIVER_GET_SYN_COUNT;

//
// IOCTL_PF_DELETE_BY_HANDLE input structure
//

typedef struct _PfDeleteByHandle
{
    PVOID   pvDriverContext;
    PVOID   pvHandles[1];
} PFDELETEBYHANDLE, *PPFDELETEBYHANDLE;

//
// IOCTL to do incremental filter setting and deleting. This IOCTL requires
// using the new filter info definitions. No mix and match matey.
//
#define IOCTL_SET_INTERFACE_FILTERS_EX \
            _IPFLTRDRVR_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_DELETE_INTERFACE_FILTERS_EX \
            _IPFLTRDRVR_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_LOG_BUFFER \
            _IPFLTRDRVR_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_INTERFACE_BINDING \
            _IPFLTRDRVR_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLEAR_INTERFACE_BINDING \
            _IPFLTRDRVR_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_LATE_BOUND_FILTERSEX \
            _IPFLTRDRVR_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_GET_SYN_COUNTS \
            _IPFLTRDRVR_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_PF_DELETE_BY_HANDLE \
            _IPFLTRDRVR_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_PF_IP_ADDRESS_LOOKUP \
            _IPFLTRDRVR_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SET_INTERFACE_BINDING2 \
            _IPFLTRDRVR_CTL_CODE(21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif //__IPFLTDRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ipnathlp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    ipnathlp.h

Abstract:

    This module contains declarations for user-mode home-networking components.
    These include the DNS proxy, the DHCP allocator, and the DirectPlay
    transparent proxy.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   24-May-1999

    Added declarations for the DirectPlay transparent proxy.

--*/

#ifndef _IPNATHLP_H_
#define _IPNATHLP_H_

#ifdef __cplusplus
extern "C" {
#endif
#pragma warning(push)
#pragma warning(disable:4200)

//
// COMMON DECLARATIONS
//

#define IPNATHLP_LOGGING_NONE               0
#define IPNATHLP_LOGGING_ERROR              1
#define IPNATHLP_LOGGING_WARN               2
#define IPNATHLP_LOGGING_INFO               3

#define IPNATHLP_INTERFACE_FLAG_DISABLED    0x00000001

#define IPNATHLP_CONTROL_UPDATE_SETTINGS    128
#define IPNATHLP_CONTROL_UPDATE_CONNECTION  129
#define IPNATHLP_CONTROL_UPDATE_AUTODIAL    130
#define IPNATHLP_CONTROL_UPDATE_FWLOGGER    131
#define IPNATHLP_CONTROL_UPDATE_DNS_DISABLE 132
#define IPNATHLP_CONTROL_UPDATE_DNS_ENABLE  133
#define IPNATHLP_CONTROL_UPDATE_POLICY      134


//
// NAT MIB-ACCESS DECLARATIONS (alphabetically)
//

//
// Structure:   IP_NAT_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve NAT information.
//

typedef struct _IP_NAT_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_NAT_MIB_QUERY, *PIP_NAT_MIB_QUERY;

#define IP_NAT_INTERFACE_STATISTICS_OID     0
#define IP_NAT_INTERFACE_MAPPING_TABLE_OID  1
#define IP_NAT_MAPPING_TABLE_OID            2


//
// DHCP ALLOCATOR DECLARATIONS (alphabetically)
//

//
// Structure:   IP_AUTO_DHCP_GLOBAL_INFO
//
// This structure holds global configuration for the DHCP allocator.
// The configuration consists of
//  (a) the network and mask from which addresses are to be allocated
//  (b) an optional list of addresses to be excluded from allocation.
//

typedef struct _IP_AUTO_DHCP_GLOBAL_INFO {
    ULONG LoggingLevel;
    ULONG Flags;
    ULONG LeaseTime;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    ULONG ExclusionCount;
    ULONG ExclusionArray[0];
} IP_AUTO_DHCP_GLOBAL_INFO, *PIP_AUTO_DHCP_GLOBAL_INFO;

//
// Structure:   IP_AUTO_DHCP_INTERFACE_INFO
//
// This structure holds per-interface configuration for the DHCP allocator.
// The configuration currently only allows the allocator to be disabled
// on the given interface. Since the allocator runs in promiscuous-interface
// mode, it is enabled by default on all interfaces. Thus, the only interfaces
// which require any configuration are those on which the allocator is to be
// disabled.
//

typedef struct _IP_AUTO_DHCP_INTERFACE_INFO {
    ULONG Flags;
} IP_AUTO_DHCP_INTERFACE_INFO, *PIP_AUTO_DHCP_INTERFACE_INFO;

#define IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED \
    IPNATHLP_INTERFACE_FLAG_DISABLED

//
// Structure:   IP_AUTO_DHCP_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve DHCP allocator information.
//

typedef struct _IP_AUTO_DHCP_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_AUTO_DHCP_MIB_QUERY, *PIP_AUTO_DHCP_MIB_QUERY;

//
// Structure : IP_AUTO_DHCP_STATISTICS
//
// This structure defines the statistics kept by the DHCP allocator,
// and accessible via 'MibGet'.
//

typedef struct _IP_AUTO_DHCP_STATISTICS {
    ULONG MessagesIgnored;
    ULONG BootpOffersSent;
    ULONG DiscoversReceived;
    ULONG InformsReceived;
    ULONG OffersSent;
    ULONG RequestsReceived;
    ULONG AcksSent;
    ULONG NaksSent;
    ULONG DeclinesReceived;
    ULONG ReleasesReceived;
} IP_AUTO_DHCP_STATISTICS, *PIP_AUTO_DHCP_STATISTICS;

#define IP_AUTO_DHCP_STATISTICS_OID             0


//
// DNS PROXY DECLARATIONS (alphabetically)
//

//
// Structure:   IP_DNS_PROXY_GLOBAL_INFO
//
// This structure holds global configuration for the DNS proxy.
//

typedef struct _IP_DNS_PROXY_GLOBAL_INFO {
    ULONG LoggingLevel;
    ULONG Flags;
    ULONG TimeoutSeconds;
} IP_DNS_PROXY_GLOBAL_INFO, *PIP_DNS_PROXY_GLOBAL_INFO;

#define IP_DNS_PROXY_FLAG_ENABLE_DNS            0x00000001
#define IP_DNS_PROXY_FLAG_ENABLE_WINS           0x00000002

//
// Structure:   IP_DNS_PROXY_INTERFACE_INFO
//
// This structure holds per-interface configuration for the DNS proxy.
// The configuration currently only allows the proxy to be disabled
// on a given interface. The proxy runs in promiscuous-interface mode
// so that all interfaces are added to it and it is enabled on all of them
// by default. Hence, the configuration need only be present for those
// interfaces on which the proxy is not to be run.
//

typedef struct _IP_DNS_PROXY_INTERFACE_INFO {
    ULONG Flags;
} IP_DNS_PROXY_INTERFACE_INFO, *PIP_DNS_PROXY_INTERFACE_INFO;

#define IP_DNS_PROXY_INTERFACE_FLAG_DISABLED \
    IPNATHLP_INTERFACE_FLAG_DISABLED
#define IP_DNS_PROXY_INTERFACE_FLAG_DEFAULT     0x00000002

//
// Structure:   IP_DNS_PROXY_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve DNS proxy information.
//

typedef struct _IP_DNS_PROXY_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_DNS_PROXY_MIB_QUERY, *PIP_DNS_PROXY_MIB_QUERY;

//
// Structure:   IP_DNS_PROXY_STATISTICS
//

typedef struct _IP_DNS_PROXY_STATISTICS {
    ULONG MessagesIgnored;
    ULONG QueriesReceived;
    ULONG ResponsesReceived;
    ULONG QueriesSent;
    ULONG ResponsesSent;
} IP_DNS_PROXY_STATISTICS, *PIP_DNS_PROXY_STATISTICS;

#define IP_DNS_PROXY_STATISTICS_OID             0


//
// Structure:   IP_FTP_GLOBAL_INFO
//
// This structure holds global configuration for the DirectPlay transparent
// proxy.
//

typedef struct IP_FTP_GLOBAL_INFO {
    ULONG LoggingLevel;
    ULONG Flags;
} IP_FTP_GLOBAL_INFO, *PIP_FTP_GLOBAL_INFO;

//
// Structure:   IP_FTP_INTERFACE_INFO
//
// This structure holds per-interface configuration for the transparent proxy.
// The configuration currently only allows the proxy to be disabled
// on a given interface. The proxy runs in promiscuous-interface mode
// so that all interfaces are added to it and it is enabled on all of them
// by default. Hence, the configuration need only be present for those
// interfaces on which the proxy is not to be run.
//

typedef struct _IP_FTP_INTERFACE_INFO {
    ULONG Flags;
} IP_FTP_INTERFACE_INFO, *PIP_FTP_INTERFACE_INFO;

#define IP_FTP_INTERFACE_FLAG_DISABLED IPNATHLP_INTERFACE_FLAG_DISABLED

//
// Structure:   IP_FTP_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve transparent proxy
// information.
//

typedef struct _IP_FTP_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_FTP_MIB_QUERY, *PIP_FTP_MIB_QUERY;

//
// Structure:   IP_FTP_STATISTICS
//

typedef struct _IP_FTP_STATISTICS {
    ULONG ConnectionsAccepted;
    ULONG ConnectionsDropped;
    ULONG ConnectionsActive;
    ULONG PlayersActive;
} IP_FTP_STATISTICS, *PIP_FTP_STATISTICS;

#define IP_FTP_STATISTICS_OID             0


//
// DIRECTPLAY TRANSPARENT PROXY DECLARATIONS (alphabetically)
//

//
// Structure:   IP_H323_GLOBAL_INFO
//
// This structure holds global configuration for the H.323 transparent
// proxy.
//

typedef struct IP_H323_GLOBAL_INFO {
    ULONG LoggingLevel;
    ULONG Flags;
} IP_H323_GLOBAL_INFO, *PIP_H323_GLOBAL_INFO;

//
// Structure:   IP_H323_INTERFACE_INFO
//
// This structure holds per-interface configuration for the transparent proxy.
// The configuration currently only allows the proxy to be disabled
// on a given interface. The proxy runs in promiscuous-interface mode
// so that all interfaces are added to it and it is enabled on all of them
// by default. Hence, the configuration need only be present for those
// interfaces on which the proxy is not to be run.
//

typedef struct _IP_H323_INTERFACE_INFO {
    ULONG Flags;
} IP_H323_INTERFACE_INFO, *PIP_H323_INTERFACE_INFO;

#define IP_H323_INTERFACE_FLAG_DISABLED IPNATHLP_INTERFACE_FLAG_DISABLED

//
// Structure:   IP_H323_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve transparent proxy
// information.
//

typedef struct _IP_H323_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_H323_MIB_QUERY, *PIP_H323_MIB_QUERY;




//
// Application Level Gateway 
//


//
// Structure:   IP_ALG_GLOBAL_INFO
//
// This structure holds global configuration for the ALG transparent proxy.
//

typedef struct IP_ALG_GLOBAL_INFO {
    ULONG LoggingLevel;
    ULONG Flags;
} IP_ALG_GLOBAL_INFO, *PIP_ALG_GLOBAL_INFO;

//
// Structure:   IP_ALG_INTERFACE_INFO
//
// This structure holds per-interface configuration for the transparent proxy.
// The configuration currently only allows the proxy to be disabled
// on a given interface. The proxy runs in promiscuous-interface mode
// so that all interfaces are added to it and it is enabled on all of them
// by default. Hence, the configuration need only be present for those
// interfaces on which the proxy is not to be run.
//

typedef struct _IP_ALG_INTERFACE_INFO {
    ULONG Flags;
} IP_ALG_INTERFACE_INFO, *PIP_ALG_INTERFACE_INFO;

#define IP_ALG_INTERFACE_FLAG_DISABLED IPNATHLP_INTERFACE_FLAG_DISABLED

//
// Structure:   IP_ALG_MIB_QUERY
//
// This structure is passed to 'MibGet' to retrieve transparent proxy
// information.
//

typedef struct _IP_ALG_MIB_QUERY {
    ULONG Oid;
    union {
        ULONG Index[0];
        UCHAR Data[0];
    };
} IP_ALG_MIB_QUERY, *PIP_ALG_MIB_QUERY;

//
// Structure:   IP_ALG_STATISTICS
//

typedef struct _IP_ALG_STATISTICS {
    ULONG ConnectionsAccepted;
    ULONG ConnectionsDropped;
    ULONG ConnectionsActive;
    ULONG PlayersActive;
} IP_ALG_STATISTICS, *PIP_ALG_STATISTICS;

#define IP_ALG_STATISTICS_OID             0


#pragma warning(pop)

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _IPNATHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\httpp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    HttpP.h

Abstract:

    Private APIs and structs for HTTP.SYS

Author:

--*/


#ifndef __HTTPP_H__
#define __HTTPP_H__

#include <http.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Used by HttpInitialize & HttpTerminate
//
// HTTP_INITIALIZE_CLIENT - Initializes the HTTP API layer and driver for 
//                          client applications.
//
#define HTTP_INITIALIZE_CLIENT          0x00000004

// HTTP_SEND_REPONSE_RAW_HEADER - Specifies that a caller of
// HttpSendResponseEntityBody() is intentionally omitting a call to
// HttpSendHttpResponse() in order to bypass normal header processing. The
// actual HTTP headers will be generated by the application and sent
// as the initial part of the entity body. This flag should be passed
// on the first call to HttpSendResponseEntityBody(), and not after.
//
#define HTTP_SEND_RESPONSE_FLAG_RAW_HEADER          0x00000004

//
// Flags for HttpSendHttpRequest() & HttpSendRequestEntityBody()
//
#define HTTP_SEND_REQUEST_FLAG_MORE_DATA            0x00000001
#define HTTP_SEND_REQUEST_FLAG_VALID                0x00000001

//
// HTTP_REQUEST_FLAG_DONT_PIPELINE - Requests that do not take entity bodies 
// (e.g., GETs, HEAD, etc) are pipelined when sent to a HTTP 1.1 server. This
// flag allows the user to disable this feature.
//
#define HTTP_REQUEST_FLAG_DONT_PIPELINE             0x00000002

//
// Values for HTTP_RESPONSE::Flags. Zero or more of these may be ORed together.
//
// HTTP_RESPONSE_FLAG_AUTH_BASIC     - The response contains a Basic 
//                                     authentication challenge.
//
// HTTP_RESPONSE_FLAG_AUTH_DIGEST    - The response contains a Digest 
//                                     authentication challenge.
//
// HTTP_RESPONSE_FLAG_AUTH_NTLM      - The response contains an NTLM
//                                     authentication challenge.
//
// HTTP_RESPONSE_FLAG_AUTH_NEGOTIATE - The response contains a Negotiate 
//                                     authentication challenge.
//
// HTTP_RESPONSE_FLAG_AUTH_KERBEROS  - The response contains a Kerberos 
//                                     authentication challenge.
//
// HTTP_RESPONSE_FLAG_MORE_DATA      - There is more HTTP_RESPONSE to be read.
//
// HTTP_RESPONSE_FLAG_HEADER         - The response contains at least 1 header
//                                     (known or unknown.)
//
// HTTP_RESPONSE_FLAG_ENTITY         - The response contains at least one
//                                     entity chunk.
//
// HTTP_RESPONSE_FLAG_DRIVER         - The response should be treated as if 
//                                     it had been generated by the driver
//
#define HTTP_RESPONSE_FLAG_AUTH_BASIC               0x00000001
#define HTTP_RESPONSE_FLAG_AUTH_DIGEST              0x00000002
#define HTTP_RESPONSE_FLAG_AUTH_NTLM                0x00000004
#define HTTP_RESPONSE_FLAG_AUTH_NEGOTIATE           0x00000008
#define HTTP_RESPONSE_FLAG_AUTH_KERBEROS            0x00000010
#define HTTP_RESPONSE_FLAG_MORE_DATA                0x00000020
#define HTTP_RESPONSE_FLAG_HEADER                   0x00000040
#define HTTP_RESPONSE_FLAG_ENTITY                   0x00000080
#define HTTP_RESPONSE_FLAG_DRIVER                   0x00000100


//
// Generic option flags. These apply to application pools.
// These are passed to HttpCreateHttpHandle.
//
// HTTP_OPTION_CONTROLLER - Opens the object that doesn't read data.
//

#define HTTP_OPTION_CONTROLLER          0x00000001
#define HTTP_OPTION_VALID               0x00000001

typedef HTTP_OPAQUE_ID HTTP_CONFIG_GROUP_ID,   *PHTTP_CONFIG_GROUP_ID;

//
// Filters and SSL.
//

//
// Server Information/Parameters (HTTP client-side only)
//

typedef struct _HTTP_CLIENT_SSL_CONTEXT
{
    ULONG SslProtocolVersion;
    PVOID pClientCertContext;
    ULONG ServerCertValidation;
    ULONG ServerNameLength;
    WCHAR ServerName[ANYSIZE_ARRAY];

} HTTP_CLIENT_SSL_CONTEXT, *PHTTP_CLIENT_SSL_CONTEXT;

//
// Data associated with raw transport connections.
//

typedef struct _HTTP_RAW_CONNECTION_INFO
{
    //
    // Connection ID.
    //

    HTTP_RAW_CONNECTION_ID ConnectionId;

    //
    // Transport address info.
    //

    HTTP_TRANSPORT_ADDRESS Address;

    //
    // Only used by the client-side.
    //

    USHORT                   ClientSSLContextLength;
    PHTTP_CLIENT_SSL_CONTEXT pClientSSLContext;

    //
    // Initial data.
    //

    ULONG InitialDataSize;      // size of initial data
    PVOID pInitialData;         // pointer to initial data

} HTTP_RAW_CONNECTION_INFO, *PHTTP_RAW_CONNECTION_INFO;


//
// Flags for HttpReceiveClientCertificate().
//
// HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP - Maps the client certificate to a token.
//

#define HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP           0x00000001
#define HTTP_RECEIVE_CLIENT_CERT_FLAG_VALID         0x00000001

//
// Names of the filters.
//

#define HTTP_SSL_SERVER_FILTER_CHANNEL_NAME L"SSLFilterChannel"
#define HTTP_SSL_SERVER_FILTER_CHANNEL_NAME_LENGTH        \
        (sizeof(HTTP_SSL_SERVER_FILTER_CHANNEL_NAME)-sizeof(WCHAR))

#define HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME L"SSLClientFilterChannel"
#define HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME_LENGTH  \
        (sizeof(HTTP_SSL_CLIENT_FILTER_CHANNEL_NAME)-sizeof(WCHAR))

//
// Network QoS stuff.
//

typedef ULONG HTTP_BANDWIDTH_LIMIT,  *PHTTP_BANDWIDTH_LIMIT;
typedef ULONG HTTP_CONNECTION_LIMIT, *PHTTP_CONNECTION_LIMIT;

//
// Bandwidth throttling limit can not be set lower than the following
// limit. The value is in bytes/sec.
//

#define HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE (1024)

//
// Distinguished value for bandwidth and connection limits indicating
// "no limit".
//

#define HTTP_LIMIT_INFINITE   ((ULONG)-1L)


//
// Enabled states. Used for configuration groups and the control channel.
//

typedef enum _HTTP_ENABLED_STATE
{
    HttpEnabledStateActive,
    HttpEnabledStateInactive,

    HttpEnabledStateMaximum

} HTTP_ENABLED_STATE, *PHTTP_ENABLED_STATE;

//
// AppPool Enabled states.
//

typedef enum _HTTP_APP_POOL_ENABLED_STATE
{
    HttpAppPoolEnabled,
    HttpAppPoolDisabled_RapidFailProtection,
    HttpAppPoolDisabled_AppPoolQueueFull,
    HttpAppPoolDisabled_ByAdministrator,
    HttpAppPoolDisabled_JobObjectFired,

    HttpAppPoolEnabledMaximum

} HTTP_APP_POOL_ENABLED_STATE, *PHTTP_APP_POOL_ENABLED_STATE;

//
// Load Balancer states.
//

typedef enum _HTTP_LOAD_BALANCER_CAPABILITIES
{
    HttpLoadBalancerBasicCapability = 1,
    HttpLoadBalancerSophisticatedCapability = 2,    // default

    HttpLoadBalancerMaximum

} HTTP_LOAD_BALANCER_CAPABILITIES, *PHTTP_LOAD_BALANCER_CAPABILITIES;

//
// UTF8 Logging
//

typedef BOOLEAN HTTP_CONTROL_CHANNEL_UTF8_LOGGING, *PHTTP_CONTROL_CHANNEL_UTF8_LOGGING;

//
// Control channel query/set information classes used for the
// HttpQueryControlChannelInformation() and HttpSetControlChannelInformation()
// APIs.
//

typedef enum _HTTP_CONTROL_CHANNEL_INFORMATION_CLASS
{
    //
    // Query/set the master state.
    //
    // pControlChannelInformation points to a HTTP_ENABLED_STATE enum.
    //

    HttpControlChannelStateInformation,

    //
    // Query/set the default network bandwidth limit.
    //
    // pControlChannelInformation points to a HTTP_BANDWIDTH_LIMIT value.
    //

    HttpControlChannelBandwidthInformation,

    //
    // Query the default network connections limit.
    //
    // pControlChannelInformation points to a HTTP_CONNECTION_LIMIT value.
    //

    HttpControlChannelConnectionInformation,

    //
    // Set the handle used to communicate with the Filter/SSL process.
    //
    // Note this cannot be queried.
    //

    HttpControlChannelFilterInformation,

    //
    // Set the global Connection Timeout information
    //
    // pControlChannelInformation points to a
    // HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT structure.
    //

    HttpControlChannelTimeoutInformation,

    //
    // Set the UTF8 Logging property for all sites
    //
    // pControlChannelInformation points to a HTTP_CONTROL_CHANNEL_UTF8_LOGGING structure.
    //
    
    HttpControlChannelUTF8Logging,

    //
    // Set the Binary Logging property for all cgroups belongs to this
    // control channel. This will effectively disables the conventional
    // logging. The pControlChannelInformation should point the binary
    // logging settings: HTTP_CONTROL_CHANNEL_BINARY_LOGGING. Please
    // note that when this is set, utf8 logging no longer applies since
    // http.sys doesn't do any string formatting.
    //

    HttpControlChannelBinaryLogging,

    //
    // Set the limit for number processes, below which we will still 
    // complete Demand Start Irps.  If the number of total active processes
    // across all AppPools associated with this control channel exceeds
    // this threshold, new requests that are queued to AppPools with a 
    // pending Demand Start Irp will (1) not complete the Irp and 
    // (2) will fail the request, returning 503 (Unavailable).
    //
    // pControlChannelInformation points to a 
    // HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD structure.
    //
    
    HttpControlChannelDemandStartThreshold,

    HttpControlChannelMaximumInformation

} HTTP_CONTROL_CHANNEL_INFORMATION_CLASS, *PHTTP_CONTROL_CHANNEL_INFORMATION_CLASS;

//
// Default control channel property values.
//

#define HTTP_CONTROL_CHANNEL_STATE_DEFAULT              HttpEnabledStateInactive
#define HTTP_CONTROL_CHANNEL_MAX_BANDWIDTH_DEFAULT      HTTP_LIMIT_INFINITE


//
// Application pool query/set information classes used for the
// HttpQueryAppPoolInformation() and HttpSetAppPoolInformation()
// APIs.
//

typedef enum _HTTP_APP_POOL_INFORMATION_CLASS
{
    //
    // Query/set the maximum number of queued new requests on
    // the application pool.
    //
    // pAppPoolInformation points to a LONG containing the maximum
    // number of queued requests.
    //

    HttpAppPoolQueueLengthInformation,

    //
    // Query/set the enabled state of the application pool.
    //
    // pAppPoolInformation points to a HTTP_APP_POOL_ENABLED_STATE enum.
    //

    HttpAppPoolStateInformation,

    //
    // Query/set the load balancer capabilities of the application pool.
    //
    // pAppPoolInformation points to a HTTP_LOAD_BALANCER_CAPABILITIES enum.
    //

    HttpAppPoolLoadBalancerInformation,

    //
    // Set the control channel associated with this application pool.
    //
    // pAppPoolInformation points to a HTTP_APP_POOL_CONTROL_CHANNEL structure
    //

    HttpAppPoolControlChannelInformation,

    HttpAppPoolMaximumInformation

} HTTP_APP_POOL_INFORMATION_CLASS, *PHTTP_APP_POOL_INFORMATION_CLASS;


//
// Configuration group query/set information classes used for the
// HttpQueryConfigGroupInformation() and HttpSetConfigGroupInformation() APIs.
// Config Group inherit from control channel when cgroup is created.
//

typedef enum _HTTP_CONFIG_GROUP_INFORMATION_CLASS
{
    //
    // Query/set the current state of the configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_STATE structure
    // that receives the current state.
    //

    HttpConfigGroupStateInformation,

    //
    // Query/set the maximum network bandwidth allowed for the configuration
    // group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_MAX_BANDWIDTH
    // structure specifying the maximum bytes per second allowed for the
    // container.
    //

    HttpConfigGroupBandwidthInformation,

    //
    // Query/set the maximum network connections allowed for the
    // configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_MAX_CONNECTIONS
    // structure containing the maximum number of network connections
    // allowed for the container.
    //

    HttpConfigGroupConnectionInformation,

    //
    // Set the application pool associated with the configuration group.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_APP_POOL
    // structure containing the HANDLE of the application pool to
    // associate.
    //

    HttpConfigGroupAppPoolInformation,

    //
    // Set the logging related config settings.
    // This allows WAS to supply logging config as a config group setting.
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_LOGGING structure.
    //
    // Note: this cannot be queried.
    //

    HttpConfigGroupLogInformation,

    //
    // Set this information only on the root config object for the site.  
    //
    // pConfigGroupInformation points to a HTTP_CONFIG_GROUP_SITE structure.
    //

    HttpConfigGroupSiteInformation,

    //
    // Set this information only on the root config object for the site.
    //
    // pConfigGroupInformation points to a DWORD that contains 
    // the ConnectionTimeout value (in seconds)
    //

    HttpConfigGroupConnectionTimeoutInformation,

    HttpConfigGroupMaximumInformation

} HTTP_CONFIG_GROUP_INFORMATION_CLASS, *PHTTP_CONFIG_GROUP_INFORMATION_CLASS;


//
// Generic configuration group property flags. Each structure defining a
// property value must contain an element of this type.
//

typedef struct _HTTP_PROPERTY_FLAGS
{
    ULONG_PTR Present:1;    // ULONG_PTR for alignment

} HTTP_PROPERTY_FLAGS, *PHTTP_PROPERTY_FLAGS;


//
// Individual property values.
//

// HttpControlChannelTimeoutInformation
typedef struct _HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT 
{
    HTTP_PROPERTY_FLAGS     Flags;
    ULONG                   ConnectionTimeout;  // Seconds
    ULONG                   HeaderWaitTimeout;  // Seconds
    ULONG                   MinFileKbSec;       // Bytes/Second
} HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT, *PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT;

// HttpControlChannelDemandStartThreshold
typedef struct _HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD
{
    HTTP_PROPERTY_FLAGS     Flags;
    ULONG                   DemandStartThreshold; // App Pool Processes
} HTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD, 
*PHTTP_CONTROL_CHANNEL_DEMAND_START_THRESHOLD;

// HttpAppPoolControlChannelInformation
typedef struct _HTTP_APP_POOL_CONTROL_CHANNEL 
{
    HTTP_PROPERTY_FLAGS     Flags;
    HANDLE                  ControlChannel;
} HTTP_APP_POOL_CONTROL_CHANNEL, *PHTTP_APP_POOL_CONTROL_CHANNEL;

typedef struct _HTTP_CONFIG_GROUP_STATE
{
    HTTP_PROPERTY_FLAGS Flags;
    HTTP_ENABLED_STATE  State;

} HTTP_CONFIG_GROUP_STATE, *PHTTP_CONFIG_GROUP_STATE;


typedef struct _HTTP_CONFIG_GROUP_MAX_BANDWIDTH
{
    HTTP_PROPERTY_FLAGS  Flags;
    HTTP_BANDWIDTH_LIMIT MaxBandwidth;

} HTTP_CONFIG_GROUP_MAX_BANDWIDTH, *PHTTP_CONFIG_GROUP_MAX_BANDWIDTH;


typedef struct _HTTP_CONFIG_GROUP_MAX_CONNECTIONS
{
    HTTP_PROPERTY_FLAGS   Flags;
    HTTP_CONNECTION_LIMIT MaxConnections;

} HTTP_CONFIG_GROUP_MAX_CONNECTIONS, *PHTTP_CONFIG_GROUP_MAX_CONNECTIONS;


typedef struct _HTTP_CONTROL_CHANNEL_FILTER
{
    HTTP_PROPERTY_FLAGS Flags;
    HANDLE              FilterHandle;
    BOOLEAN             FilterOnlySsl;

} HTTP_CONTROL_CHANNEL_FILTER, *PHTTP_CONTROL_CHANNEL_FILTER;


typedef struct _HTTP_CONFIG_GROUP_APP_POOL
{
    HTTP_PROPERTY_FLAGS Flags;
    HANDLE              AppPoolHandle;

} HTTP_CONFIG_GROUP_APP_POOL, *PHTTP_CONFIG_GROUP_APP_POOL;


typedef struct _HTTP_CONFIG_GROUP_SECURITY
{
    HTTP_PROPERTY_FLAGS  Flags;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

} HTTP_CONFIG_GROUP_SECURITY, *PHTTP_CONFIG_GROUP_SECURITY;

//
// Log file truncation size can not be set lower than the following
// limit. The value is in bytes.
//

#define HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE (1 * 1024 * 1024)


typedef enum _HTTP_LOGGING_TYPE
{
    HttpLoggingTypeW3C,
    HttpLoggingTypeIIS,
    HttpLoggingTypeNCSA,
    HttpLoggingTypeRaw,

    HttpLoggingTypeMaximum

} HTTP_LOGGING_TYPE, *PHTTP_LOGGING_TYPE;

typedef enum _HTTP_LOGGING_PERIOD
{
    HttpLoggingPeriodMaxSize = 0,
    HttpLoggingPeriodDaily   = 1,
    HttpLoggingPeriodWeekly  = 2,
    HttpLoggingPeriodMonthly = 3,
    HttpLoggingPeriodHourly  = 4,

    HttpLoggingPeriodMaximum

} HTTP_LOGGING_PERIOD, *PHTTP_LOGGING_PERIOD;

typedef enum _HTTP_SELECTIVE_LOGGING_TYPE
{    
    HttpLogAllRequests,
    HttpLogSuccessfulRequests,
    HttpLogErrorRequests,
    
    HttpSelectiveLoggingMaximum
        
} HTTP_SELECTIVE_LOGGING_TYPE, *PHTTP_SELECTIVE_LOGGING_TYPE; 

typedef struct _HTTP_CONFIG_GROUP_LOGGING
{
    //
    // To indicate if this property exists or not in the config group
    //

    HTTP_PROPERTY_FLAGS Flags;

    //
    // This is field's counterpart in the metabase is LogType
    //

    BOOLEAN LoggingEnabled;

    //
    // Indicates the Logging Format
    //

    HTTP_LOGGING_TYPE LogFormat;

    //
    // Indicates the exact directory where the log file
    // will be written to for a site.
    //

    UNICODE_STRING LogFileDir;

    //
    // Log Period in terms of HTTP_LOGGING_PERIOD
    // 0 = MAX SIZE, 1 = DAILY, 2 = WEEKLY,
    // 3 = MONTHLY,  4 = HOURLY
    //

    ULONG LogPeriod;

    //
    // Indicates the max size,in bytes,after which the
    // log file should be rotated. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates unlimited size.
    //

    ULONG LogFileTruncateSize;

    //
    // A bitmask indicating which fields to log when
    // LogFormat is set to W3C Extended
    //

    ULONG LogExtFileFlags;

    //
    // If this has been set then we recycle log files
    // based on the local time for this site. Default
    // should be FALSE.
    //
    
    BOOLEAN LocaltimeRollover;

    //
    // Selective logging type. If HttpLogAllRequests
    // is picked all types of requests are logged.
    //

    HTTP_SELECTIVE_LOGGING_TYPE SelectiveLogging;
    

} HTTP_CONFIG_GROUP_LOGGING, *PHTTP_CONFIG_GROUP_LOGGING;

//
// When LogFormat is Raw (Binary) and logging settings are 
// configured through control channel for all sites, following
// binary logging settings structure should be used.
//

typedef struct _HTTP_CONTROL_CHANNEL_BINARY_LOGGING
{
    //
    // To indicate if this property exist or not
    // in the config group
    //

    HTTP_PROPERTY_FLAGS Flags;

    //
    // This is field's counterpart in the metabase is
    // LogType
    //

    BOOLEAN LoggingEnabled;

    //
    // If this has been set then we recycle log files
    // based on the local time for this site. Default
    // should be FALSE.
    //
    
    BOOLEAN LocaltimeRollover;

    //
    // Indicates the exact directory where the log file
    // will be written to for a site.
    //

    UNICODE_STRING LogFileDir;

    //
    // Log Period in terms of HTTP_LOGGING_PERIOD
    // 0 = MAX SIZE, 1 = DAILY, 2 = WEEKLY,
    // 3 = MONTHLY,  4 = HOURLY
    //

    ULONG LogPeriod;

    //
    // Indicates the max size,in bytes,after which the
    // log file should be rotated. A value of -1
    // (HTTP_LIMIT_INFINITE) indicates unlimited size.
    //

    ULONG LogFileTruncateSize;

}   HTTP_CONTROL_CHANNEL_BINARY_LOGGING, 
 * PHTTP_CONTROL_CHANNEL_BINARY_LOGGING;

// 
// HTTP_CONFIG_GROUP_SITE
// 

typedef struct _HTTP_CONFIG_GROUP_SITE
{
    ULONG   SiteId;

} HTTP_CONFIG_GROUP_SITE, *PHTTP_CONFIG_GROUP_SITE;

//
// This structure holds all the necessary logging info.
// Server App may pass this with last SendResponse or
// SendEntityBody APIs.Unicode field lengths are in bytes.
//

typedef struct _HTTP_LOG_FIELDS_DATA
{
    USHORT UserNameLength;
    USHORT UriStemLength;
    USHORT ClientIpLength;
    USHORT ServerNameLength;
    USHORT ServiceNameLength;
    USHORT ServerIpLength;
    USHORT MethodLength;
    USHORT UriQueryLength;
    USHORT HostLength;
    USHORT UserAgentLength;
    USHORT CookieLength;
    USHORT ReferrerLength;

    PCWSTR UserName;
    PCWSTR UriStem;
    PCSTR  ClientIp;
    PCSTR  ServerName;
    PCSTR  ServiceName;
    PCSTR  ServerIp;
    PCSTR  Method;
    PCSTR  UriQuery;
    PCSTR  Host;
    PCSTR  UserAgent;
    PCSTR  Cookie;
    PCSTR  Referrer;

    USHORT ServerPort;
    USHORT ProtocolStatus;
    
    ULONG  Win32Status;

    HTTP_VERB MethodNum;

    USHORT SubStatus;

} HTTP_LOG_FIELDS_DATA, *PHTTP_LOG_FIELDS_DATA;


//
// For transfers between filters and upper levels.
//

typedef enum _HTTP_FILTER_BUFFER_TYPE
{
    HttpFilterBufferHttpStream,             // both directions
    HttpFilterBufferSslInitInfo,            // filter -> app
    HttpFilterBufferSslServerCert,          // filter -> app (HTTP client only)
    HttpFilterBufferSslClientCert,          // filter -> app
    HttpFilterBufferSslClientCertAndMap,    // filter -> app
    HttpFilterBufferSslRenegotiate,         // app -> filter
    HttpFilterBufferSslRenegotiateAndMap,   // app -> filter
    HttpFilterBufferCloseConnection,        // app -> filter
    HttpFilterBufferNotifyDisconnect,       // filter -> app

    HttpFilterBufferMaximum

} HTTP_FILTER_BUFFER_TYPE, *PHTTP_FILTER_BUFFER_TYPE;


//
// The buffer transferred between filters and upper levels.
//

typedef struct _HTTP_FILTER_BUFFER
{
    HTTP_FILTER_BUFFER_TYPE BufferType;

    ULONG  BufferSize;
    PUCHAR pBuffer;

    ULONGLONG Reserved;

} HTTP_FILTER_BUFFER, *PHTTP_FILTER_BUFFER;


// 
// Appends write buffer info to the filter buffer struct.  This is used for
// posting both a read and a write in a single IOCTL call.
//

typedef struct _HTTP_FILTER_BUFFER_PLUS
{
    HTTP_FILTER_BUFFER_TYPE BufferType;

    ULONG  BufferSize;
    PUCHAR pBuffer;

    ULONGLONG Reserved;

    ULONG  WriteBufferSize;
    PUCHAR pWriteBuffer;

} HTTP_FILTER_BUFFER_PLUS, *PHTTP_FILTER_BUFFER_PLUS;


//
// Counter Group.
//

//
// Counter property description.
//

typedef struct _HTTP_PROP_DESC
{
    ULONG Size;
    ULONG Offset;
    BOOLEAN WPZeros;

} HTTP_PROP_DESC, *PHTTP_PROP_DESC;


//
// This enum defines the available counter groups.
//

typedef enum _HTTP_COUNTER_GROUP
{
    HttpCounterGroupSite,
    HttpCounterGroupGlobal,

    HttpCounterGroupMaximum

} HTTP_COUNTER_GROUP, *PHTTP_COUNTER_GROUP;


//
// This enum defines the type of global couters.
//

typedef enum _HTTP_GLOBAL_COUNTER_ID
{
    HttpGlobalCounterCurrentUrisCached,
    HttpGlobalCounterTotalUrisCached,
    HttpGlobalCounterUriCacheHits,
    HttpGlobalCounterUriCacheMisses,
    HttpGlobalCounterUriCacheFlushes,
    HttpGlobalCounterTotalFlushedUris,

    HttpGlobalCounterMaximum

} HTTP_GLOBAL_COUNTER_ID, *PHTTP_GLOBAL_COUNTER_ID;


//
// Global couters.
//

typedef struct _HTTP_GLOBAL_COUNTERS
{
    ULONG CurrentUrisCached;
    ULONG TotalUrisCached;
    ULONG UriCacheHits;
    ULONG UriCacheMisses;
    ULONG UriCacheFlushes;
    ULONG TotalFlushedUris;

} HTTP_GLOBAL_COUNTERS, *PHTTP_GLOBAL_COUNTERS;


//
// This enum defines the type of site counters.
// NB: HTTP_SITE_COUNTER_ID and HTTP_SITE_COUNTERS 
//     must be in the same order
//

typedef enum _HTTP_SITE_COUNTER_ID
{
    HttpSiteCounterBytesSent,
    HttpSiteCounterBytesReceived,
    HttpSiteCounterBytesTransfered,
    HttpSiteCounterCurrentConns,
    HttpSiteCounterMaxConnections,
    HttpSiteCounterConnAttempts,
    HttpSiteCounterGetReqs,
    HttpSiteCounterHeadReqs,
    HttpSiteCounterAllReqs,
    HttpSiteCounterMeasuredIoBandwidthUsage,
    HttpSiteCounterCurrentBlockedBandwidthBytes,
    HttpSiteCounterTotalBlockedBandwidthBytes,

    HttpSiteCounterMaximum

} HTTP_SITE_COUNTER_ID, *PHTTP_SITE_COUNTER_ID;


//
// Site counters.
//

typedef struct _HTTP_SITE_COUNTERS
{
    ULONG SiteId;
    ULONGLONG BytesSent;
    ULONGLONG BytesReceived;
    ULONGLONG BytesTransfered;
    ULONG CurrentConns;
    ULONG MaxConnections;
    ULONG ConnAttempts;
    ULONG GetReqs;
    ULONG HeadReqs;
    ULONG AllReqs;
    ULONG MeasuredIoBandwidthUsage;
    ULONG CurrentBlockedBandwidthBytes;
    ULONG TotalBlockedBandwidthBytes;

} HTTP_SITE_COUNTERS, *PHTTP_SITE_COUNTERS;

// ***************************************************************************
//
//                  Data structures for Client APIs (Begin)
//
// ***************************************************************************

//
// These are used for setting per-request config options.
//

typedef enum _HTTP_REQUEST_CONFIG_ID
{
    HttpRequestConfigAuthentication,
    HttpRequestConfigProxyAuthentication,
    HttpRequestConfigConnectionIndex,

    HttpRequestConfigMaxConfigId

} HTTP_REQUEST_CONFIG_ID, *PHTTP_REQUEST_CONFIG_ID;


typedef struct _HTTP_REQUEST_CONFIG
{
    HTTP_REQUEST_CONFIG_ID ObjectType;
    PVOID                  pValue;
    ULONG                  ValueLength;

} HTTP_REQUEST_CONFIG, *PHTTP_REQUEST_CONFIG;


typedef enum _HTTP_AUTH_TYPE
{
    HttpAuthTypeAutoSelect = 0,
    HttpAuthTypeBasic,
    HttpAuthTypeDigest,
    HttpAuthTypeNTLM,
    HttpAuthTypeNegotiate,
    HttpAuthTypeKerberos,
    HttpAuthTypesCount
} HTTP_AUTH_TYPE, *PHTTP_AUTH_TYPE;


#define HTTP_AUTH_FLAGS_DEFAULT_CREDENTIALS 0x00000001
#define HTTP_AUTH_FLAGS_VALID               0x00000001

//
// The config object for HttpRequestConfigAuthentication,
// HttpRequestConfigProxyAuthentication types.
//

typedef struct _HTTP_AUTH_CREDENTIALS
{
    HTTP_AUTH_TYPE AuthType;

    ULONG  AuthFlags;

    USHORT UserNameLength;  // In bytes, not including NUL
    USHORT PasswordLength;  // In bytes, not including NUL
    USHORT DomainLength;    // In bytes, not including NUL
    PCWSTR pUserName;
    PCWSTR pPassword;
    PCWSTR pDomain;

    USHORT HeaderValueLength;
    PCSTR  pHeaderValue;    // The value of WWW-Authenticate header
                            // or Proxy-Authenticate header as returned
                            // by the server.

} HTTP_AUTH_CREDENTIALS, *PHTTP_AUTH_CREDENTIALS;


//
// This is for setting configuration on a ServerContext -
// Via HttpSetServerContextInformation & HttpQueryServerContextInformation.
//

typedef enum _HTTP_SERVER_CONFIG_ID
{
    HttpServerConfigConnectionCount,           // set & query
    HttpServerConfigProxyPreAuthState,         // set & query
    HttpServerConfigProxyPreAuthFlushCache,    // only set
    HttpServerConfigPreAuthState,              // set & query
    HttpServerConfigPreAuthFlushURICache,      // only set
    HttpServerConfigIgnoreContinueState,       // set & query
    HttpServerConfigConnectionTimeout,         // set & query
    HttpServerConfigServerCert,                // only query
    HttpServerConfigServerCertValidation,      // set & query
    HttpServerConfigServerCertAccept,          // only set
    HttpServerConfigSslProtocolVersion,        // set & query
    HttpServerConfigClientCert,                // set & query
    HttpServerConfigClientCertIssuerList,      // only query

    HttpServerConfigMaxInformation

} HTTP_SERVER_CONFIG_ID, *PHTTP_SERVER_CONFIG_ID;

//
// Validate server certificate types 
//

typedef enum _HTTP_SSL_SERVER_CERT_VALIDATION
{
    HttpSslServerCertValidationIgnore,
    HttpSslServerCertValidationManual,
    HttpSslServerCertValidationManualOnce,
    HttpSslServerCertValidationAutomatic,

    HttpSslServerCertValidationMax

} HTTP_SSL_SERVER_CERT_VALIDATION, *PHTTP_SSL_SERVER_CERT_VALIDATION;

//
// Server certificate information
//

typedef struct _HTTP_SSL_CERT_ISSUER_INFO
{
    ULONG IssuerCount;
    ULONG IssuerListLength;
    PVOID pIssuerList;
} HTTP_SSL_CERT_ISSUER_INFO, *PHTTP_SSL_CERT_ISSUER_INFO;


typedef struct _HTTP_SSL_SERIALIZED_CERT
{
    ULONG           Flags;

#define HTTP_SSL_CERT_HASH_LENGTH 32

    ULONG           CertHashLength:8;
    UCHAR           CertHash[HTTP_SSL_CERT_HASH_LENGTH];

    PUCHAR          pSerializedCert;
    ULONG           SerializedCertLength;

    PUCHAR          pSerializedCertStore;
    ULONG           SerializedCertStoreLength;

} HTTP_SSL_SERIALIZED_CERT, *PHTTP_SSL_SERIALIZED_CERT;


typedef struct _HTTP_SSL_SERVER_CERT_INFO
{
    ULONG                     Status;

    HTTP_SSL_CERT_ISSUER_INFO IssuerInfo;

    HTTP_SSL_SERIALIZED_CERT  Cert;

} HTTP_SSL_SERVER_CERT_INFO, *PHTTP_SSL_SERVER_CERT_INFO;



// ***************************************************************************
//
//                  Data structures for Client APIs (End)
//
// ***************************************************************************

//
// Define our API linkage.
//

#if !defined(HTTPAPI_LINKAGE)
#define HTTPAPI_LINKAGE DECLSPEC_IMPORT
#endif  // !HTTPAPI_LINKAGE


//
// Control channel APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenControlChannel(
    OUT PHANDLE pControlChannelHandle,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    OUT PVOID pControlChannelInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    );


//
// Configuration Group APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateConfigGroup(
    IN HANDLE ControlChannelHandle,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpDeleteConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpAddUrlToConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN HTTP_URL_CONTEXT UrlContext
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveUrlFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpRemoveAllUrlsFromConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    OUT PVOID pConfigGroupInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN HTTP_CONFIG_GROUP_ID ConfigGroupId,
    IN HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    );


//
// Application Pool manipulation APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpShutdownAppPool(
    IN HANDLE AppPoolHandle
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    OUT PVOID pAppPoolInformation,
    IN ULONG Length,
    OUT PULONG pReturnLength OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetAppPoolInformation(
    IN HANDLE AppPoolHandle,
    IN HTTP_APP_POOL_INFORMATION_CLASS InformationClass,
    IN PVOID pAppPoolInformation,
    IN ULONG Length
    );


//
// Demand start notifications.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpWaitForDemandStart(
    IN HANDLE AppPoolHandle,
    IN OUT PVOID pBuffer OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


//
// API calls for SSL/Filter helper process.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCreateFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpOpenFilter(
    OUT PHANDLE pFilterHandle,
    IN PCWSTR pFilterName,
    IN ULONG Options
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpShutdownFilter(
    IN HANDLE FilterHandle
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAccept(
    IN HANDLE FilterHandle,
    OUT PHTTP_RAW_CONNECTION_INFO pRawConnectionInfo,
    IN ULONG RawConnectionInfoSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterClose(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterRawWriteAndAppRead(
    IN HANDLE FilterHandle,
    IN OUT PHTTP_FILTER_BUFFER_PLUS pHttpBufferPlus,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAppWriteAndRawRead(
    IN HANDLE FilterHandle,
    IN OUT PHTTP_FILTER_BUFFER_PLUS pHttpBufferPlus,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterRawRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    OUT PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );
     
HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterRawWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN PVOID pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );


HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAppRead(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpFilterAppWrite(
    IN HANDLE FilterHandle,
    IN HTTP_RAW_CONNECTION_ID ConnectionId,
    IN OUT PHTTP_FILTER_BUFFER pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pBytesReceived OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

//
// Counter Group APIs.
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpGetCounters(
    IN HANDLE ControlChannelHandle,
    IN HTTP_COUNTER_GROUP CounterGroup,
    IN OUT PULONG pCounterBlockSize,
    IN OUT PVOID pCounterBlocks,
    OUT PULONG pNumInstances OPTIONAL
    );


//
// HTTP client APIs
//

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpInitializeServerContext(
    IN  USHORT                 ServerNameLength,
    IN  PWSTR                  pServerName,
    IN  USHORT                 ProxyLength            OPTIONAL,
    IN  PWSTR                  pProxy                 OPTIONAL,
    IN  ULONG                  ServerFlags            OPTIONAL,
    IN  PVOID                  pReserved,
    OUT PHANDLE                pServerHandle
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendHttpRequest(
    IN  HANDLE               ServerHandle,
    IN  PHTTP_REQUEST        pHttpRequest,
    IN  ULONG                HttpRequestFlags,
    IN  USHORT               RequestConfigCount      OPTIONAL,
    IN  PHTTP_REQUEST_CONFIG pRequestConfig          OPTIONAL,
    IN  LPOVERLAPPED         pOverlapped             OPTIONAL,
    IN  ULONG                ResponseBufferLength    OPTIONAL,
    OUT PHTTP_RESPONSE       pResponseBuffer         OPTIONAL,
    IN  ULONG                Reserved,               // must be 0
    OUT PVOID                pReserved,              // must be NULL
    OUT PULONG               pBytesReceived          OPTIONAL,
    OUT PHTTP_REQUEST_ID     pRequestID
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSendRequestEntityBody(
    IN  HANDLE              ServerHandle,
    IN  HTTP_REQUEST_ID     RequestID,
    IN  ULONG               Flags,
    IN  USHORT              EntityBodyCount,
    IN  PHTTP_DATA_CHUNK    pHttpEntityBody,
    IN  LPOVERLAPPED        pOverlapped            OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpReceiveHttpResponse(
    IN  HANDLE              ServerHandle,
    IN  HTTP_REQUEST_ID     RequestID,
    IN  ULONG               Flags,
    IN  ULONG               ResponseBufferLength,
    OUT PHTTP_RESPONSE      pResponseBuffer,
    IN  ULONG               Reserved,              // must be 0
    OUT PVOID               pReserved,             // must be NULL
    OUT PULONG              pBytesReceived         OPTIONAL,
    IN  LPOVERLAPPED        pOverlapped            OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpSetServerContextInformation(
    IN  HANDLE                ServerHandle,
    IN  HTTP_SERVER_CONFIG_ID ConfigId,
    IN  PVOID                 pInputBuffer,
    IN  ULONG                 InputBufferLength,
    IN  LPOVERLAPPED          pOverlapped          OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpQueryServerContextInformation(
    IN  HANDLE                 ServerHandle,
    IN  HTTP_SERVER_CONFIG_ID  ConfigId,
    IN  PVOID                  pReserved1,
    IN  ULONG                  Reserved2,
    OUT PVOID                  pOutputBuffer,
    IN  ULONG                  OutputBufferLength,
    OUT PULONG                 pReturnLength,
    IN  LPOVERLAPPED           pOverlapped         OPTIONAL
    );

HTTPAPI_LINKAGE
ULONG
WINAPI
HttpCancelHttpRequest(
    IN  HANDLE            ServerHandle,
    IN  HTTP_REQUEST_ID   RequestID,
    IN  ULONG             Flags,
    IN  LPOVERLAPPED      pOverlapped              OPTIONAL
    );



#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif // __HTTPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ipfltinf.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    private\inc\ipfltinf.h

Abstract:
    Stuff needed for filtering/firewall/demand dial support in user mode
    Kernel mode only stuff is in ntos\inc\ipfilter.h

Revision History:

--*/

#ifndef __IPFLTINF_H__
#define __IPFLTINF_H__

#if _MSC_VER > 1000
#pragma once
#endif

typedef void *INTERFACE_CONTEXT;    // Context in an inteface

//
// Enum for values that may be returned from filter routine.
//

typedef enum _FORWARD_ACTION
{
    FORWARD = 0,
    DROP = 1,
    ICMP_ON_DROP = 2
} FORWARD_ACTION;


typedef enum _ACTION_E
{
    ICMP_DEST_UNREACHABLE_ON_DROP = 0x1
} ACTION_E, *PACTION_E;

//
// Actions that are returned to IP from IPSEC for a packet.
//

typedef enum  _IPSEC_ACTION
{
    eFORWARD = 0,
    eDROP,
    eABSORB,
    eBACKFILL_NOT_SUPPORTED
} IPSEC_ACTION, *PIPSEC_ACTION;


//
// Structure passed to the IPSetInterfaceContext call.
//

typedef struct _IP_SET_IF_CONTEXT_INFO
{
    unsigned int        Index;      // Inteface index for i/f to be set.
    INTERFACE_CONTEXT   *Context;   // Context for inteface.
    IPAddr              NextHop;
} IP_SET_IF_CONTEXT_INFO, *PIP_SET_IF_CONTEXT_INFO;

#endif //__IPFLTINF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\iphlpstk.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    iphlpstk.h

Abstract:

Revision History:

    Amritansh Raghav

--*/

#ifndef _IPHLPSTK_
#define _IPHLPSTK_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <iprtrmib.h>
#include <ntddip.h>
#include <tcpinfo.h>

DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );

DWORD
GetIfTableFromStack(
    OUT PMIB_IFTABLE pIfTable,
    IN  DWORD        dwSize,
    IN  BOOL         bOrder,
    IN  BOOL         bForceUpdate
    );

DWORD
NhpGetInterfaceIndexFromStack(
    IN  PWCHAR      pwszIfName,
    OUT PDWORD      pdwIfIndex
    );

DWORD
GetIfEntryFromStack(
    OUT PMIB_IFROW  pIfEntry,
    IN  DWORD       dwAdapterIndex,
    IN  BOOL        bForceUpdate
    );

DWORD
SetIfEntryToStack(
    IN MIB_IFROW  *pIfEntry,
    IN BOOL       bForceUpdate
    );

DWORD
AllocateAndGetIpAddrTableFromStack(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    );

DWORD
GetIpAddrTableFromStack(
    OUT PMIB_IPADDRTABLE  pIpAddrTable,
    IN  DWORD             dwSize,
    IN  BOOL              bOrder
    );

DWORD
AllocateAndGetTcpTableFromStack(
    OUT MIB_TCPTABLE  **ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    );

DWORD
AllocateAndGetTcpExTableFromStack(
    OUT PVOID         *ppTcpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
GetTcpTableFromStack(
    OUT PMIB_TCPTABLE   pTcpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    );

DWORD
SetTcpEntryToStack(
    IN PMIB_TCPROW pTcpRow
    );

DWORD
AllocateAndGetUdpTableFromStack(
    OUT MIB_UDPTABLE  **ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags
    );
    
DWORD
AllocateAndGetUdpExTableFromStack(
    OUT PVOID         *ppUdpTable,
    IN  BOOL          bOrder,
    IN  HANDLE        hHeap,
    IN  DWORD         dwFlags,
    IN  DWORD         dwFamily
    );

DWORD
GetUdpTableFromStack(
    OUT PMIB_UDPTABLE   pUdpTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder
    );

DWORD
AllocateAndGetIpForwardTableFromStack(
    OUT MIB_IPFORWARDTABLE  **ppForwardTable,
    IN  BOOL                bOrder,
    IN  HANDLE              hHeap,
    IN  DWORD               dwFlags
    );

DWORD
GetIpForwardTableFromStack(
    OUT PMIB_IPFORWARDTABLE pForwardTable,
    IN  DWORD               dwSize,
    IN  BOOL                bOrder
    );

DWORD
GetIpStatsFromStack(
    OUT PMIB_IPSTATS pIpStats
    );

DWORD
GetIpStatsFromStackEx(
    OUT PMIB_IPSTATS pIpStats,
    IN  DWORD        dwFamily
    );

DWORD
SetIpStatsToStack(
    IN PMIB_IPSTATS pIpStats
    );

DWORD
GetIcmpStatsFromStack(
    OUT PMIB_ICMP pIcmpStats
    );

DWORD
GetIcmpStatsFromStackEx(
    OUT PVOID         pIcmpStats,
    IN  DWORD         dwFamily
    );

DWORD
GetUdpStatsFromStack(
    OUT PMIB_UDPSTATS pUdpStats
    );

DWORD
GetUdpStatsFromStackEx(
    OUT PMIB_UDPSTATS pUdpStats,
    IN  DWORD         dwFamily
    );

DWORD
GetTcpStatsFromStack(
    OUT PMIB_TCPSTATS pTcpStats
    );

DWORD
GetTcpStatsFromStackEx(
    OUT PMIB_TCPSTATS pTcpStats,
    IN  DWORD         dwFamily
    );

DWORD
AllocateAndGetIpNetTableFromStack(
    OUT MIB_IPNETTABLE **ppNetTable,
    IN  BOOL           bOrder,
    IN  HANDLE         hHeap,
    IN  DWORD          dwFlags,
    IN  BOOL           bForceUpdate
    );

DWORD
GetIpNetTableFromStack(
    OUT PMIB_IPNETTABLE pNetTable,
    IN  DWORD           dwSize,
    IN  BOOL            bOrder,
    IN  BOOL            bForceUpdate
    );

DWORD
SetIpNetEntryToStack(
    IN MIB_IPNETROW *pNetRow,
    IN BOOL         bForceUpdate
    );

DWORD
FlushIpNetTableFromStack(
    IN DWORD    dwIfIndex
    );

DWORD
SetProxyArpEntryToStack(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwAdapterIndex,
    IN  BOOL    bAddEntry,
    IN  BOOL    bForceUpdate
    );

DWORD
AllocateAndGetArpEntTableFromStack(
    OUT PDWORD    *ppdwArpEntTable,
    OUT PDWORD    pdwNumEntries,
    IN  HANDLE    hHeap,
    IN  DWORD     dwAllocFlags,
    IN  DWORD     dwReAllocFlags
    );

DWORD
SetIpForwardEntryToStack(
    IN PMIB_IPFORWARDROW pForwardRow
    );

DWORD
SetIpRouteEntryToStack(
    IN IPRouteEntry *pRoute
    );

DWORD
SetIpMultihopRouteEntryToStack(
    IN IPMultihopRouteEntry *pRoute
    );    

DWORD
GetBestInterfaceFromStack(
    DWORD   dwDestAddress,
    PDWORD  pdwBestIfIndex
    );

DWORD
GetBestRouteFromStack(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSrcAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );

#ifndef NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED
#define NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED

DWORD
NhpAllocateAndGetInterfaceInfoFromStack(
    OUT IP_INTERFACE_NAME_INFO **ppTable,
    OUT PDWORD                 pdwCount,
    IN  BOOL                   bOrder,
    IN  HANDLE                 hHeap,
    IN  DWORD                  dwFlags
    );

#endif

#ifdef __cplusplus
}
#endif

#endif // _IPHLPSTK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ipsec.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ipsec.h

Abstract:

    Generic include file used by components to access the IPSEC driver.
    Contains the SAAPI IOCTLs and the structures relevant to them.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997

Environment:

    Kernel mode

Revision History:

--*/
#ifndef  _IPSEC_H
#define  _IPSEC_H

#include <windef.h>
#include <winipsec.h>

//
// NOTE: all addresses are expected in Network byte order
//
typedef unsigned long IPAddr;
typedef unsigned long IPMask;

//
// This should go into a global header
//

#define DD_IPSEC_DEVICE_NAME    L"\\Device\\IPSEC"
#define DD_IPSEC_SYM_NAME       L"\\DosDevices\\IPSECDev"
#define DD_IPSEC_DOS_NAME       L"\\\\.\\IPSECDev"

//
// This is the name of the event that will be signaled after any policy changes have been applied.
//
#define IPSEC_POLICY_CHANGE_NOTIFY  L"IPSEC_POLICY_CHANGE_NOTIFY"

//                                                                           //
// IOCTL code definitions and related structures                             //
// All the IOCTLs are synchronous and need administrator privilege           //
//                                                                           //
#define FSCTL_IPSEC_BASE     FILE_DEVICE_NETWORK

#define _IPSEC_CTL_CODE(function, method, access) \
                 CTL_CODE(FSCTL_IPSEC_BASE, function, method, access)

//
// Security Association/Policy APIs implemented as Ioctls
//
#define IOCTL_IPSEC_ADD_FILTER  \
            _IPSEC_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_DELETE_FILTER \
            _IPSEC_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_POST_FOR_ACQUIRE_SA \
            _IPSEC_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_GET_SPI \
            _IPSEC_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_UPDATE_SA \
            _IPSEC_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_ADD_SA \
            _IPSEC_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_DELETE_SA \
            _IPSEC_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_EXPIRE_SA \
            _IPSEC_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_ENUM_SAS \
            _IPSEC_CTL_CODE(8, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_IPSEC_ENUM_FILTERS \
            _IPSEC_CTL_CODE(9, METHOD_OUT_DIRECT, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_QUERY_EXPORT \
            _IPSEC_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IPSEC_QUERY_STATS \
            _IPSEC_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IPSEC_QUERY_SPI \
            _IPSEC_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IPSEC_SET_OPERATION_MODE \
            _IPSEC_CTL_CODE(13, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_SET_TCPIP_STATUS \
            _IPSEC_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_REGISTER_PROTOCOL \
            _IPSEC_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPSEC_GET_OPERATION_MODE \
            _IPSEC_CTL_CODE(16, METHOD_BUFFERED, FILE_WRITE_ACCESS)               

#define IOCTL_IPSEC_SET_DIAGNOSTIC_MODE \
            _IPSEC_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Structures to go with the ioctls above
//
#define FILTER_FLAGS_PASS_THRU  0x0001
#define FILTER_FLAGS_DROP       0x0002
#define FILTER_FLAGS_INBOUND    0x0004
#define FILTER_FLAGS_OUTBOUND   0x0008
#define FILTER_FLAGS_MANUAL     0x0010

// Flags for DestType in acquire
#define IPSEC_BCAST 0x1
#define IPSEC_MCAST 0x2


//
// Special constants for ExType member of _IPSEC_FILTER
//

#define EXT_NORMAL          0x00
#define EXT_DNS_SERVER      0X01
#define EXT_WINS_SERVER     0X02
#define EXT_DHCP_SERVER     0X03
#define EXT_DEFAULT_GATEWAY 0X04

// The following flag is OR-ed with the above to specify that the
// destination address is the special address. If not OR-ed, it this
// means the source address is the special address.

#define EXT_DEST            0x80

//
// for IOCTL_IPSEC_ADD_FILTER
//
typedef struct _IPSEC_FILTER {
    IPAddr          SrcAddr;
    IPMask          SrcMask;
    IPAddr          DestAddr;
    IPMask          DestMask;
    IPAddr          TunnelAddr;
    DWORD           Protocol;
    WORD            SrcPort;
    WORD            DestPort;
    BOOLEAN         TunnelFilter;
    UCHAR           ExType;
    WORD            Flags;
} IPSEC_FILTER, *PIPSEC_FILTER;

typedef struct _IPSEC_FILTER_INFO {
    GUID            FilterId;   // unique identifier to identify a filter
    GUID            PolicyId;   // unique identifier to identify a policy entry
    ULONG           Index;      // hint on where this entry fits in the ordered list of filters
    IPSEC_FILTER    AssociatedFilter;
} IPSEC_FILTER_INFO, *PIPSEC_FILTER_INFO;

typedef struct _IPSEC_ADD_FILTER {
    DWORD               NumEntries;
    IPSEC_FILTER_INFO   pInfo[1];        
} IPSEC_ADD_FILTER, *PIPSEC_ADD_FILTER;

//
// for IOCTL_IPSEC_DELETE_FILTER
//
typedef IPSEC_ADD_FILTER    IPSEC_DELETE_FILTER, *PIPSEC_DELETE_FILTER;

//
// for IOCTL_IPSEC_ENUM_FILTERS
//
typedef struct _IPSEC_ENUM_FILTERS {
    DWORD               NumEntries;         // num entries for which there is space
    DWORD               NumEntriesPresent;  // num entries actually present in the driver
    IPSEC_FILTER_INFO   pInfo[1];        
} IPSEC_ENUM_FILTERS, *PIPSEC_ENUM_FILTERS;

//
// for IOCTL_IPSEC_QUERY_STATS
//
typedef IPSEC_STATISTICS    IPSEC_QUERY_STATS, *PIPSEC_QUERY_STATS;

//
// for IOCTL_IPSEC_SET_OPERATION_MODE
// &   IOCTL_IPSEC_GET_OPERATION_MODE
//
typedef enum _OPERATION_MODE {
    IPSEC_BYPASS_MODE = 0,
    IPSEC_BLOCK_MODE,
    IPSEC_SECURE_MODE,
    IPSEC_BOOTTIME_STATEFUL_MODE,
    IPSEC_OPERATION_MODE_MAX
} OPERATION_MODE;

//defines the forwarding behavior to apply in 
//boot and boottime stateful mode
typedef enum _IPSEC_FORWARDING_BEHAVIOR{
    IPSEC_FORWARD_BYPASS =0,
    IPSEC_FORWARD_BLOCK,
    IPSEC_FORWARD_MAX
} IPSEC_FORWARDING_BEHAVIOR;

// Following defines and structs 
// for boot time security
#define EXEMPT_DIRECTION_INBOUND 0x1
#define EXEMPT_DIRECTION_OUTBOUND 0x2
#define EXEMPT_TYPE_PDP 0x1


typedef struct _IPSEC_EXEMPT_ENTRY {
   ULONG Type;
   ULONG Size;
   BYTE Protocol;
   BYTE Direction;
   USHORT SrcPort;
   USHORT DestPort;
   USHORT Reserved;
} IPSEC_EXEMPT_ENTRY, *PIPSEC_EXEMPT_ENTRY;

typedef struct _IPSEC_SET_OPERATION_MODE {
    OPERATION_MODE  OperationMode;
} IPSEC_SET_OPERATION_MODE, *PIPSEC_SET_OPERATION_MODE;


typedef struct _IPSEC_GET_OPERATION_MODE {
	OPERATION_MODE OperationMode;
} IPSEC_GET_OPERATION_MODE, * PIPSEC_GET_OPERATION_MODE;



// For IOCTL_IPSEC_SET_DIAGNOSTIC_MODE
#define IPSEC_DIAGNOSTIC_DISABLE_LOG        0x00000000
#define IPSEC_DIAGNOSTIC_ENABLE_LOG         0x00000001
#define IPSEC_DIAGNOSTIC_INBOUND            0x00000002
#define IPSEC_DIAGNOSTIC_OUTBOUND           0x00000004
#define IPSEC_DIAGNOSTIC_MAX                0x00000007

typedef struct _IPSEC_SET_DIAGNOSTIC_MODE{
	DWORD Mode;
        DWORD LogInterval;
} IPSEC_SET_DIAGNOSTIC_MODE, * PIPSEC_SET_DIAGNOSTIC_MODE;


// For IOCTL_IPSEC_REGISTER_PROTOCOL.
//

typedef enum _REGISTER_IPSEC_PROTOCOL {
    IPSEC_REGISTER_PROTOCOLS = 0,
    IPSEC_DEREGISTER_PROTOCOLS,
    REGISTER_IPSEC_PROTOCOL_MAX
} REGISTER_IPSEC_PROTOCOL, * PREGISTER_IPSEC_PROTOCOL;


typedef struct _IPSEC_REGISTER_PROTOCOL {
    REGISTER_IPSEC_PROTOCOL RegisterProtocol;
} IPSEC_REGISTER_PROTOCOL, * PIPSEC_REGISTER_PROTOCOL;


//
// for IOCTL_IPSEC_SET_TCPIP_STATUS
//
typedef struct _IPSEC_SET_TCPIP_STATUS {
    BOOLEAN TcpipStatus;
    PVOID   TcpipFreeBuff;
    PVOID   TcpipAllocBuff;
    PVOID   TcpipGetInfo;
    PVOID   TcpipNdisRequest;
    PVOID   TcpipSetIPSecStatus;
    PVOID   TcpipSetIPSecPtr;
    PVOID   TcpipUnSetIPSecPtr;
    PVOID   TcpipUnSetIPSecSendPtr;
    PVOID   TcpipTCPXsum;
    PVOID   TcpipSendICMPErr;
} IPSEC_SET_TCPIP_STATUS, *PIPSEC_SET_TCPIP_STATUS;

//
// The base Security Association structure for IOCTL_IPSEC_*_SA
//
typedef ULONG   SPI_TYPE;

typedef enum _Operation {
    None = 0,
    Auth,       // AH
    Encrypt,    // ESP
    Compress
} OPERATION_E;

//
// IPSEC DOI ESP algorithms
//
typedef enum _ESP_ALGO {
    IPSEC_ESP_NONE = 0,
    IPSEC_ESP_DES,
    IPSEC_ESP_DES_40,
    IPSEC_ESP_3_DES,
    IPSEC_ESP_MAX
} ESP_ALGO;

//
// IPSEC DOI AH algorithms
//
typedef enum _AH_ALGO {
    IPSEC_AH_NONE = 0,
    IPSEC_AH_MD5,
    IPSEC_AH_SHA,
    IPSEC_AH_MAX
} AH_ALGO;

//
// Lifetime structure - 0 => not significant
//
typedef struct _LIFETIME {
    ULONG   KeyExpirationTime;   // lifetime of key - in seconds
    ULONG   KeyExpirationBytes;  // max # of KBytes xformed till re-key
} LIFETIME, *PLIFETIME;

//
// describes generic algorithm properties
//    
typedef struct _ALGO_INFO {
    ULONG   algoIdentifier;     // ESP_ALGO or AH_ALGO
    ULONG   algoKeylen;         // len in bytes
    ULONG   algoRounds;         // # of algo rounds
} ALGO_INFO, *PALGO_INFO;

//
// Security Association
//

//
// Flags - not mutually exclusive
//
typedef ULONG   SA_FLAGS;

#define IPSEC_SA_INTERNAL_IOCTL_DELETE   0x10000000

#define MAX_SAS 3   // COMP, ESP, AH
#define MAX_OPS MAX_SAS

typedef struct _SECURITY_ASSOCIATION   {
    OPERATION_E Operation;      // ordered set of operations
    SPI_TYPE    SPI;            // SPI in order of operations in OperationArray
    ALGO_INFO   IntegrityAlgo;  // AH
    ALGO_INFO   ConfAlgo;       // ESP
    PVOID       CompAlgo;       // compression algo info
} SECURITY_ASSOCIATION, *PSECURITY_ASSOCIATION;

typedef struct _SA_STRUCT {
    HANDLE                  Context; // context of the original ACQUIRE request
    ULONG                   NumSAs;  // number of SAs following
    SA_FLAGS                Flags;
    IPAddr                  TunnelAddr;         // Tunnel end IP Addr
    IPAddr                  SrcTunnelAddr;      // Tunnel src IP Addr
    LIFETIME                Lifetime;
    IPSEC_FILTER            InstantiatedFilter; // the actual addresses for which this SA was setup
    SECURITY_ASSOCIATION    SecAssoc[MAX_SAS];
    DWORD                   dwQMPFSGroup;  
    IKE_COOKIE_PAIR         CookiePair;
    IPSEC_SA_UDP_ENCAP_TYPE EncapType;
    WORD                    SrcEncapPort;       //Src, Dst encapsulation ports for NAT
    WORD                    DestEncapPort; 
    IPAddr                  PeerPrivateAddr;
    ULONG                   KeyLen;             // key len in # of chars
    UCHAR                   KeyMat[1];
} SA_STRUCT, *PSA_STRUCT;

typedef struct _IPSEC_ADD_UPDATE_SA {
    SA_STRUCT   SAInfo;
} IPSEC_ADD_UPDATE_SA, *PIPSEC_ADD_UPDATE_SA;

//
// Outbound SAs are typically deleted
//
typedef struct  _IPSEC_DELETE_SA {
    IPSEC_QM_SA SATemplate;     // template used for SA match
} IPSEC_DELETE_SA, *PIPSEC_DELETE_SA;

//
// Inbound SAs are typically expired
//
typedef struct _IPSEC_DELETE_INFO {
    IPAddr      DestAddr;
    IPAddr      SrcAddr;
    SPI_TYPE    SPI;
} IPSEC_DELETE_INFO, *PIPSEC_DELETE_INFO;

typedef struct  _IPSEC_EXPIRE_SA {
    IPSEC_DELETE_INFO   DelInfo;
} IPSEC_EXPIRE_SA, *PIPSEC_EXPIRE_SA;

typedef struct _IPSEC_GET_SPI {
    HANDLE          Context;    // context to represent this SA negotiation
    IPSEC_FILTER    InstantiatedFilter; // the actual addresses for which this SA was setup
    SPI_TYPE        SPI;        // filled out on return
} IPSEC_GET_SPI, *PIPSEC_GET_SPI;

typedef IPSEC_GET_SPI IPSEC_SET_SPI, *PIPSEC_SET_SPI;

typedef struct _IPSEC_SA_ALGO_INFO {
    ALGO_INFO   IntegrityAlgo;
    ALGO_INFO   ConfAlgo;
    ALGO_INFO   CompAlgo;
} IPSEC_SA_ALGO_INFO, *PIPSEC_SA_ALGO_INFO;

typedef ULONG   SA_ENUM_FLAGS;

#define SA_ENUM_FLAGS_INITIATOR         0x00000001
#define SA_ENUM_FLAGS_MTU_BUMPED        0x00000002
#define SA_ENUM_FLAGS_OFFLOADED         0x00000004
#define SA_ENUM_FLAGS_OFFLOAD_FAILED    0x00000008
#define SA_ENUM_FLAGS_OFFLOADABLE       0x00000010
#define SA_ENUM_FLAGS_IN_REKEY          0x00000020

typedef struct  _IPSEC_SA_STATS {
    ULARGE_INTEGER  ConfidentialBytesSent;
    ULARGE_INTEGER  ConfidentialBytesReceived;
    ULARGE_INTEGER  AuthenticatedBytesSent;
    ULARGE_INTEGER  AuthenticatedBytesReceived;
    ULARGE_INTEGER  TotalBytesSent;
    ULARGE_INTEGER  TotalBytesReceived;
    ULARGE_INTEGER  OffloadedBytesSent;
    ULARGE_INTEGER  OffloadedBytesReceived;
} IPSEC_SA_STATS, *PIPSEC_SA_STATS;

typedef struct _IPSEC_SA_INFO {
    GUID                PolicyId;    // unique identifier to identify a policy entry
    GUID                FilterId;
    LIFETIME            Lifetime;
    IPAddr              InboundTunnelAddr;
    ULONG               NumOps;
    SPI_TYPE            InboundSPI[MAX_OPS];
    SPI_TYPE            OutboundSPI[MAX_OPS];
    OPERATION_E         Operation[MAX_OPS];
    IPSEC_SA_ALGO_INFO  AlgoInfo[MAX_OPS];
    IPSEC_FILTER        AssociatedFilter;
    DWORD               dwQMPFSGroup;  
    IKE_COOKIE_PAIR     CookiePair;
    SA_ENUM_FLAGS       EnumFlags;
    IPSEC_SA_STATS      Stats;
    UDP_ENCAP_INFO      EncapInfo;
} IPSEC_SA_INFO, *PIPSEC_SA_INFO;

typedef struct _SECURITY_ASSOCIATION_OUT   {
    DWORD       Operation;          // ordered set of operations
    SPI_TYPE    SPI;                // SPI in order of operations in OperationArray
    ALGO_INFO   IntegrityAlgo;      // AH
    ALGO_INFO   ConfAlgo;           // ESP
    ALGO_INFO   CompAlgo;           // compression algo info
} SECURITY_ASSOCIATION_OUT, *PSECURITY_ASSOCIATION_OUT;

typedef struct _IPSEC_SA_QUERY_INFO {
    GUID                        PolicyId;   // unique identifier to identify a policy entry
    LIFETIME                    Lifetime;
    ULONG                       NumSAs;
    SECURITY_ASSOCIATION_OUT    SecAssoc[MAX_SAS];
    IPSEC_FILTER                AssociatedFilter;
    DWORD                       Flags;
    IKE_COOKIE_PAIR             AssociatedMainMode;
} IPSEC_SA_QUERY_INFO, *PIPSEC_SA_QUERY_INFO;

typedef struct _IPSEC_ENUM_SAS {
    DWORD           NumEntries;         // num entries for which there is space
    DWORD           NumEntriesPresent;  // num entries actually present in the driver
    DWORD           Index;              // num entries to skip
    IPSEC_QM_SA     SATemplate;         // template used for SA match
    IPSEC_SA_INFO   pInfo[1];
} IPSEC_ENUM_SAS, *PIPSEC_ENUM_SAS;

typedef struct _IPSEC_POST_FOR_ACQUIRE_SA {
    HANDLE      IdentityInfo;   // identity of Principal
    HANDLE      Context;        // context to represent this SA negotiation
    GUID        PolicyId;       // GUID for QM policy
    IPAddr      SrcAddr;
    IPMask      SrcMask;
    IPAddr      DestAddr;
    IPMask      DestMask;
    IPAddr      TunnelAddr;
    IPAddr      InboundTunnelAddr;
    DWORD       Protocol;
    IKE_COOKIE_PAIR CookiePair; // only used for notify
    WORD        SrcPort;
    WORD        DestPort;
    BOOLEAN     TunnelFilter;   // TRUE => this is a tunnel filter
    UCHAR       DestType;
    WORD        SrcEncapPort;
    WORD        DestEncapPort;
    BYTE        Pad1[4]; 
    UCHAR       Pad2[2];
} IPSEC_POST_FOR_ACQUIRE_SA, *PIPSEC_POST_FOR_ACQUIRE_SA;

//NB.  This must be <= size as the IPSEC_POST_FOR_ACQUIRE_SA
typedef struct _IPSEC_POST_EXPIRE_NOTIFY {
    HANDLE      IdentityInfo;    // identity of Principal
    HANDLE      Context;        // context to represent this SA negotiation
    SPI_TYPE    InboundSpi;
    SPI_TYPE    OutboundSpi;
    DWORD       Flags;
    IPAddr      SrcAddr;
    IPMask      SrcMask;
    IPAddr      DestAddr;
    IPMask      DestMask;
    IPAddr      TunnelAddr;
    IPAddr      InboundTunnelAddr;
    DWORD       Protocol;
    IKE_COOKIE_PAIR CookiePair;
    WORD        SrcPort;
    WORD        DestPort;
    BOOLEAN     TunnelFilter;   // TRUE => this is a tunnel filter
    WORD        SrcEncapPort;
    WORD        DestEncapPort;    
    IPAddr      PeerPrivateAddr;
    UCHAR       Pad[3];
} IPSEC_POST_EXPIRE_NOTIFY, *PIPSEC_POST_EXPIRE_NOTIFY;

typedef struct _IPSEC_QUERY_EXPORT {
    BOOLEAN     Export;
} IPSEC_QUERY_EXPORT, *PIPSEC_QUERY_EXPORT;

typedef struct _IPSEC_FILTER_SPI {
    IPSEC_FILTER    Filter;
    SPI_TYPE        Spi;
    DWORD           Operation;
    DWORD           Flags;
    struct _IPSEC_FILTER_SPI *Next;
} IPSEC_FILTER_SPI, *PIPSEC_FILTER_SPI;

typedef struct _QOS_FILTER_SPI {
    IPAddr  SrcAddr;
    IPAddr  DestAddr;
    DWORD   Protocol;
    WORD    SrcPort;
    WORD    DestPort;
    DWORD   Operation;
    DWORD   Flags;
    SPI_TYPE Spi;
} QOS_FILTER_SPI, *PQOS_FILTER_SPI;

typedef struct  _IPSEC_QUERY_SPI {
    IPSEC_FILTER Filter;
    SPI_TYPE Spi;                      // inbound spi
    SPI_TYPE OtherSpi;                 // outbound spi
    DWORD Operation;
} IPSEC_QUERY_SPI, *PIPSEC_QUERY_SPI;

#define IPSEC_NOTIFY_EXPIRE_CONTEXT 0x00000000
#define IPSEC_RPC_CONTEXT           0x00000001

#endif  _IPSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
    ulong       ipsi_forwarding;
    ulong       ipsi_defaultttl;
    ulong       ipsi_inreceives;
    ulong       ipsi_inhdrerrors;
    ulong       ipsi_inaddrerrors;
    ulong       ipsi_forwdatagrams;
    ulong       ipsi_inunknownprotos;
    ulong       ipsi_indiscards;
    ulong       ipsi_indelivers;
    ulong       ipsi_outrequests;
    ulong       ipsi_routingdiscards;
    ulong       ipsi_outdiscards;
    ulong       ipsi_outnoroutes;
    ulong       ipsi_reasmtimeout;
    ulong       ipsi_reasmreqds;
    ulong       ipsi_reasmoks;
    ulong       ipsi_reasmfails;
    ulong       ipsi_fragoks;
    ulong       ipsi_fragfails;
    ulong       ipsi_fragcreates;
    ulong       ipsi_numif;
    ulong       ipsi_numaddr;
    ulong       ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_destunreachs;
    ulong       icmps_timeexcds;
    ulong       icmps_parmprobs;
    ulong       icmps_srcquenchs;
    ulong       icmps_redirects;
    ulong       icmps_echos;
    ulong       icmps_echoreps;
    ulong       icmps_timestamps;
    ulong       icmps_timestampreps;
    ulong       icmps_addrmasks;
    ulong       icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
    ICMPStats   icsi_instats;
    ICMPStats   icsi_outstats;
} ICMPSNMPInfo;

typedef struct ICMPv6Stats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_typecount[256];
} ICMPv6Stats;

typedef struct ICMPv6SNMPInfo {
    ICMPv6Stats   icsi_instats;
    ICMPv6Stats   icsi_outstats;
} ICMPv6SNMPInfo;

#define IP_FORWARDING       1
#define IP_NOT_FORWARDING   2

typedef struct IPAddrEntry {
    ulong       iae_addr;
    ulong       iae_index;
    ulong       iae_mask;
    ulong       iae_bcastaddr;
    ulong       iae_reasmsize;
    ushort      iae_context;
    ushort      iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
#ifdef NT
    ulong       ire_context;
#endif
} IPRouteEntry;

typedef struct IPRouteBlock {
    ulong       numofroutes;
    IPRouteEntry route[1];
} IPRouteBlock;

//
// Route with multiple nexthops and associated defns
//

typedef struct IPRouteNextHopEntry {
    ulong       ine_iretype;
    ulong       ine_nexthop;
    ulong       ine_ifindex;
#ifdef NT
    ulong       ine_context;
#endif
} IPRouteNextHopEntry;


typedef struct IPMultihopRouteEntry {
    ulong               imre_numnexthops;
    ulong               imre_flags;
    IPRouteEntry        imre_routeinfo;
    IPRouteNextHopEntry imre_morenexthops[1];
} IPMultihopRouteEntry;

#define IMRE_FLAG_DELETE_DEST   0x00000001

//
// Input context to pass when querying a route
//

typedef enum {
    IPNotifyNotification = 0,
    IPNotifySynchronization,
    IPNotifyMaximumVersion
} IPNotifyVersion;

typedef struct IPNotifyData {
    ulong       Version;   // See IPNotifyVersion above.
    ulong       Add;
    char        Info[1];
} IPNotifyData, *PIPNotifyData;

typedef struct IPNotifyOutput {
    ulong       ino_addr;
    ulong       ino_mask;
    ulong       ino_info[6];
} IPNotifyOutput, *PIPNotifyOutput;

typedef union IPRouteNotifyOutput {
    IPNotifyOutput irno_info;
    struct {
        ulong   irno_dest;
        ulong   irno_mask;
        ulong   irno_nexthop;
        ulong   irno_proto;
        ulong   irno_ifindex;
        ulong   irno_metric;
        ulong   irno_flags;
    };
} IPRouteNotifyOutput, *PIPRouteNotifyOutput;

#define IRNO_FLAG_ADD       0x00000001
#define IRNO_FLAG_DELETE    0x00000002

//
// Input context to pass when querying a route
//
typedef struct IPRouteLookupData {
    ulong       Version;   //version of this structure
    ulong       DestAdd;
    ulong       SrcAdd;
    char        Info[1];
} IPRouteLookupData, *PIPRouteLookupData;

typedef struct AddrXlatInfo {
    ulong       axi_count;
    ulong       axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                 1
#define IP_MIB_RTCHANGE_NOTIFY_ID       2
#define ICMP_MIB_STATS_ID               1

#define AT_MIB_ADDRXLAT_INFO_ID         1
#define AT_MIB_ADDRXLAT_ENTRY_ID        0x101

#define IP_MIB_RTTABLE_ENTRY_ID         0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID       0x102
#define IP_MIB_RTTABLE_ENTRY_ID_EX      0x103

#define IP_INTFC_FLAG_P2P                 1
#define IP_INTFC_FLAG_P2MP                2
#define IP_INTFC_FLAG_UNIDIRECTIONAL      4


typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103
#define IP_MIB_SINGLE_RT_ENTRY_ID       0x104
#define IP_GET_BEST_SOURCE              0x105

#ifndef s6_addr

struct in6_addr {
    union {
        unsigned char Byte[16];
        unsigned short Word[8];
    } u;
};

#define in_addr6 in6_addr

/*
** Defines to match RFC 2553.
*/
#define _S6_un     u
#define _S6_u8     Byte
#define s6_addr    _S6_un._S6_u8

/*
** Defines for our implementation.
*/
#define s6_bytes   u.Byte
#define s6_words   u.Word

#endif

typedef struct IP6RouteEntry {
    ulong           ire_Length;
    struct in6_addr ire_Source;
    ulong           ire_ScopeId;
    ulong           ire_IfIndex;
} IP6RouteEntry;

#define IP6_MIB_STATS_ID       IP_MIB_STATS_ID
#define IP6_GET_BEST_ROUTE_ID  3
#define ICMP6_MIB_STATS_ID     4

#pragma warning(pop)

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\isnkrnl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    isnkrnl.h

Abstract:

    This header file contains interface definitions for NT clients
    of the ISN IPX/SPX/Netbios stack.

Author:

    Adam Barr (adamba) 10 November 1993

Revision History:

--*/



#include <packon.h>

//
// Defines a local target. The NicId is assigned by IPX
// for each adapter or WAN line it is bound to. The MacAddress
// is generally the address of the remote machine or the
// router that is used to get to the remote machine.
//
//

//
// [SanjayAn] Changed LocalTarget to include a NicHandle
//

#ifdef	_PNP_POWER

typedef	struct _NIC_HANDLE {
	USHORT	NicId;

#ifdef  _PNP_LATER
	ULONG	Version;
	CSHORT	Signature;
#endif  _PNP_LATER

} NIC_HANDLE, *PNIC_HANDLE;


typedef struct _IPX_LOCAL_TARGET {
    union {
        USHORT      NicId;
    	NIC_HANDLE	NicHandle;
    };
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#else

typedef USHORT  NIC_HANDLE;
typedef PUSHORT PNIC_HANDLE;

typedef struct _IPX_LOCAL_TARGET {
    USHORT NicId;
    UCHAR MacAddress[6];
} IPX_LOCAL_TARGET, *PIPX_LOCAL_TARGET;

#endif	_PNP_POWER

//
// Definition of the options on a TDI datagram. These
// can be passed in as the Options field of a send
// datagram. It is indicated as the Options on a receive
// datagram, and will be copied into the Options field
// of a posted receive datagram if there is room.
//
// The complete structure does not need to be passed.
// Only the packet type can be passed, or nothing.
//

typedef struct _IPX_DATAGRAM_OPTIONS {
    UCHAR PacketType;
    UCHAR Reserved;
    IPX_LOCAL_TARGET LocalTarget;
} IPX_DATAGRAM_OPTIONS, *PIPX_DATAGRAM_OPTIONS;


//
// The extended address that some addresses want. If
// the proper ioctl is set (MIPX_SENDADDROPT) then
// this structure is passed as the remote address on
// send datagrams...
//

typedef struct _IPX_ADDRESS_EXTENDED {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
} IPX_ADDRESS_EXTENDED, *PIPX_ADDRESS_EXTENDED;

//
// ...and this structure is passed on receive indications.
// The values for Flags are defined right after it.
// By using the MIPX_SETRCVFLAGS ioctl you can also
// enable this format for receive addresses without
// changing what is passed on sends.
//

typedef struct _IPX_ADDRESS_EXTENDED_FLAGS {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
} IPX_ADDRESS_EXTENDED_FLAGS, *PIPX_ADDRESS_EXTENDED_FLAGS;

//
// Just appends Nic to the above structure.
//
typedef struct _IPX_ADDRESS_EXTENDED_FLAGS2 {
    TA_IPX_ADDRESS IpxAddress;
    UCHAR PacketType;
    UCHAR Flags;
    ULONG Nic;
} IPX_ADDRESS_EXTENDED_FLAGS2, *PIPX_ADDRESS_EXTENDED_FLAGS2;

#define IPX_EXTENDED_FLAG_BROADCAST   0x01   // the frame was sent as a broadcast
#define IPX_EXTENDED_FLAG_LOCAL       0x02   // the frame was sent from this machine



//
// The various states of the NICs (LAN/WAN)
//
#define NIC_CREATED         1
#define NIC_DELETED         2
#define NIC_CONNECTED       3
#define NIC_DISCONNECTED    4
#define NIC_LINE_DOWN       5
#define NIC_LINE_UP         6
#define NIC_CONFIGURED      7

//
// The mother of all hacks - tell the forwarder if it should shrink or
// expand all the NICIds...
//
#define NIC_OPCODE_DECREMENT_NICIDS 0x10
#define NIC_OPCODE_INCREMENT_NICIDS 0x20

//
// Move the isnipx.h definitions over here
//
// Frame types.  For now these mirror those in isnipx.h.
//
#define MISN_FRAME_TYPE_ETHERNET_II  0
#define MISN_FRAME_TYPE_802_3        1
#define MISN_FRAME_TYPE_802_2        2
#define MISN_FRAME_TYPE_SNAP         3
#define MISN_FRAME_TYPE_ARCNET       4    // we ignore this
#define MISN_FRAME_TYPE_MAX          4    // of the four standard ones

#define ISN_FRAME_TYPE_AUTO         0xff

#include <packoff.h>

//***NIC  Info ***


//
// For now, we assume that there will not be more than 256 bindings.
// This is a big enough number for most cases that we will encounter now
// or the foreseeable future.  We allocate an array of ULONGS of the above
// dimension. This array stores in its first n elements pointers to the
// bindings created for the various LAN and WAN adapters.
//
#define IPX_MAXIMUM_BINDINGS               256


//
// This is the interface that the Router process in address space uses
// to open an address end point.  Only one point can currently be opened.
// The ea buffer should have the end point information in exactly the same
// format as is used for TdiTransportAddress endpoint.
//
#define ROUTER_INTERFACE  "RouterInterface"
#define ROUTER_INTERFACE_LENGTH  (sizeof("RouterInterface") - 1)

//
// Max. no. of ports that the Router can open
//
#define IPX_RT_MAX_ADDRESSES         16


// Structure for MIPX_CONFIG Ioctl parameters
typedef struct _ISN_ACTION_GET_DETAILS {
    USHORT NicId;          // passed by caller
    BOOLEAN BindingSet;    // returns TRUE if in set
    UCHAR Type;            // 1 = lan, 2 = up wan, 3 = down wan
    ULONG FrameType;       // returns 0 through 3
    ULONG NetworkNumber;   // returns virtual net if NicId is 0
    UCHAR Node[6];         // adapter's MAC address.
    WCHAR AdapterName[64]; // terminated with Unicode NULL
} ISN_ACTION_GET_DETAILS, *PISN_ACTION_GET_DETAILS;


//
// IPX_NIC_INFO.  One or more such structures can be retrieved by a user
//                app through the MIPX_GETNEWNICS ioctl.
//
typedef struct _IPX_NIC_INFO {

    ULONG   InterfaceIndex; // relevant only for demand dial WAN interfaces
    UCHAR   RemoteNodeAddress[6];        //remote nic address (only for WAN)
    ULONG   LinkSpeed;            //speed of link
    ULONG   PacketType;           //packet type 802.3 or whatever
    ULONG   MaxPacketSize;        //Max. pkt size allowed on the link
    ULONG   NdisMediumType;       //Medium type
    ULONG   NdisMediumSubtype;    //
    BOOLEAN Status;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
    ISN_ACTION_GET_DETAILS Details;
    } IPX_NIC_INFO, *PIPX_NIC_INFO;

//
// structure to be passed in the input buffer for the MIPX_GETNEWNICS IOCTL
//
typedef struct _IPX_NICS {
       ULONG NoOfNics;
       ULONG TotalNoOfNics;
       ULONG fAllNicsDesired;   //indicates that the client wants
                                  //ipx to start afresh
       UCHAR Data[1];              //memory holding an array of IPX_NIC_INFO
                                   //structures starts here
       } IPX_NICS, *PIPX_NICS;

//
// Enhanced OPTIONS structure for use with the MIPX_GETNEWNICS ioctl
//
typedef struct _IPX_DATAGRAM_OPTIONS2 {
    IPX_DATAGRAM_OPTIONS DgrmOptions;
    TDI_ADDRESS_IPX  RemoteAddress;
    ULONG            LengthOfExtraOpInfo;  //set it to the size of the extra
                                           //option info.
    char             Data[1];          //for future extensibility
} IPX_DATAGRAM_OPTIONS2, *PIPX_DATAGRAM_OPTIONS2;

//
// Invalid NicId passed down only once so IPX can map the ConnectionId
// to a NicId, which is used later.
//
#define INVALID_NICID   0xffffffff

//
// Structure to be passed with the MIPX_QUERY_WAN_INACTIVITY IOCTL
//
typedef struct _IPX_QUERY_WAN_INACTIVITY {
    ULONG   ConnectionId;
    USHORT  NicId;                  // if equals INVALID_NICID, AdapterIndex is filled in
                                    // adapter index; should change to NicHandle [ZZ]
    ULONG   WanInactivityCounter;   // filled in on return
} IPX_QUERY_WAN_INACTIVITY, *PIPX_QUERY_WAN_INACTIVITY;

//
// Structure to be passed with the MIPX_IPXWAN_CONFIG_DONE IOCTL
//
typedef struct _IPXWAN_CONFIG_DONE {
    USHORT  NicId;           // adapter index; should change to NicHandle [ZZ]
    ULONG   Network;
    UCHAR   LocalNode[6];
    UCHAR   RemoteNode[6];
} IPXWAN_CONFIG_DONE, *PIPXWAN_CONFIG_DONE;

//
// Definitions for TDI_ACTION calls supported by ISN.
// In general the structure defined is passed in the
// OutputBuffer (which becomes the MDL chain when
// the transport receives it) and is used for input
// and output as specified.
//

//
// This is the TransportId to use in the action header
// (it is the string "MISN").
//

#define ISN_ACTION_TRANSPORT_ID   (('N' << 24) | ('S' << 16) | ('I' << 8) | ('M'))


//
// Get local target is used to force a re-RIP and also
// obtain the local target information if desired. The
// IpxAddress is passed on input and the LocalTarget
// is returned on output. The structure defined here
// goes in the Data section of an NWLINK_ACTION
// structure with the Option set to MIPX_LOCALTARGET.
//

typedef struct _ISN_ACTION_GET_LOCAL_TARGET {
    TDI_ADDRESS_IPX IpxAddress;
    IPX_LOCAL_TARGET LocalTarget;
} ISN_ACTION_GET_LOCAL_TARGET, *PISN_ACTION_GET_LOCAL_TARGET;


//
// Get network information is used to return information
// about the path to a network. The information may not
// be accurate since it only reflects what IPX knows
// about the first hop to the remote. Network is an
// input and LinkSpeed (in bytes per second) and
// MaximumPacketSize (not including the IPX header)
// are returned. The structure defined here goes
// in the Data section of an NWLINK_ACTION structure
// with the Options set to MIPX_NETWORKINFO.
//

typedef struct _ISN_ACTION_GET_NETWORK_INFO {
    ULONG Network;
    ULONG LinkSpeed;
    ULONG MaximumPacketSize;
} ISN_ACTION_GET_NETWORK_INFO, *PISN_ACTION_GET_NETWORK_INFO;



//
// This is the structure that the streams IPX transport used
// for its action requests. Because of the way in which nwlink
// was implemented, when passing this structure in a TDI_ACTION
// it should be specified as the InputBuffer, not the output
// buffer.
//
// In the action header, the TransportId is "MIPX" and the
// ActionCode is 0. DatagramOption is TRUE for IPX ioctls
// and FALSE for SPX. The BufferLength includes the length
// of everything after it, which is sizeof(ULONG) for Option
// plus whatever Data is present. Option is one of the
// ioctl codes defined after the structure; in most cases
// Data is not needed.
//

typedef struct _NWLINK_ACTION {
    TDI_ACTION_HEADER Header;
    UCHAR OptionType;
    ULONG BufferLength;
    ULONG Option;
    CHAR Data[1];
} NWLINK_ACTION, *PNWLINK_ACTION;

//
// Defines the values for OptionType (note that for
// NWLINK this is a BOOLEAN DatagramOption, so we
// define these to match, adding the control channel
// one for ISN only).
//

#define NWLINK_OPTION_CONNECTION    0   // action is on a connection
#define NWLINK_OPTION_ADDRESS       1   // action is on an address
#define NWLINK_OPTION_CONTROL       2   // action is on the control channel,
                                        // may also be submitted on an
                                        // open connection or address object



//
// The following IOCTLs are taken from nwlink; the only
// ones added for ISN are the ones in the 200 range.
//


/** Ioctls for IPX - (X) = User callable **/

/**
    ioctls will values 100 - 150 were added for the NT port.
**/

#define I_MIPX          (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SETNODEADDR   (I_MIPX | 0)   /* Set the node address */
#define MIPX_SETNETNUM     (I_MIPX | 1)   /* Set the network number */
#define MIPX_SETPTYPE      (I_MIPX | 2)   /* (X) Set the packet type */
#define MIPX_SENTTYPE      (I_MIPX | 3)   /* (X) Set the xport type */
#define MIPX_SETPKTSIZE    (I_MIPX | 4)   /* Set the packet size */
#define MIPX_SETSAP        (I_MIPX | 5)   /* Set the sap/type field */
#define MIPX_SENDOPTS      (I_MIPX | 6)   /* (X) Send options on recv */
#define MIPX_NOSENDOPTS    (I_MIPX | 7)   /* (X) Don't send options on recv */
#define MIPX_SENDSRC       (I_MIPX | 8)   /* (X) Send source address up */
#define MIPX_NOSENDSRC     (I_MIPX | 9)   /* (X) Don't Send source address up */
#define MIPX_CONVBCAST     (I_MIPX | 10)  /* Convert TKR bcast to func addr */
#define MIPX_NOCONVBCAST   (I_MIPX | 11)  /* Don't cnvrt TKR bcast to funcaddr */
#define MIPX_SETCARDTYPE   (I_MIPX | 12)  /* Set 802.3 or ETH type */
#define MIPX_STARGROUP     (I_MIPX | 13)  /* This is stargroup */
#define MIPX_SWAPLENGTH    (I_MIPX | 14)  /* Set flag for swapping 802.3 length */
#define MIPX_SENDDEST      (I_MIPX | 15)  /* (X) Send dest. address up */
#define MIPX_NOSENDDEST    (I_MIPX | 16)  /* (X) Don't send dest. address up */
#define MIPX_SENDFDEST     (I_MIPX | 17)  /* (X) Send final dest. address up */
#define MIPX_NOSENDFDEST   (I_MIPX | 18)  /* (X) Don't send final dest. up */

/** Added for NT port **/

#define MIPX_SETVERSION    (I_MIPX | 100) /* Set card version */
#define MIPX_GETSTATUS     (I_MIPX | 101)
#define MIPX_SENDADDROPT   (I_MIPX | 102) /* (X) Send ptype w/addr on recv */
#define MIPX_NOSENDADDROPT (I_MIPX | 103) /* (X) Stop sending ptype on recv */
#define MIPX_CHECKSUM      (I_MIPX | 104) /* Enable/Disable checksum      */
#define MIPX_GETPKTSIZE    (I_MIPX | 105) /* Get max packet size          */
#define MIPX_SENDHEADER    (I_MIPX | 106) /* Send header with data        */
#define MIPX_NOSENDHEADER  (I_MIPX | 107) /* Don't send header with data  */
#define MIPX_SETCURCARD    (I_MIPX | 108) /* Set current card for IOCTLs  */
#define MIPX_SETMACTYPE    (I_MIPX | 109) /* Set the Cards MAC type       */
#define MIPX_DOSROUTE      (I_MIPX | 110) /* Do source routing on this card*/
#define MIPX_NOSROUTE      (I_MIPX | 111) /* Don't source routine the card*/
#define MIPX_SETRIPRETRY   (I_MIPX | 112) /* Set RIP retry count          */
#define MIPX_SETRIPTO      (I_MIPX | 113) /* Set RIP timeout              */
#define MIPX_SETTKRSAP     (I_MIPX | 114) /* Set the token ring SAP       */
#define MIPX_SETUSELLC     (I_MIPX | 115) /* Put LLC hdr on packets       */
#define MIPX_SETUSESNAP    (I_MIPX | 116) /* Put SNAP hdr on packets      */
#define MIPX_8023LEN       (I_MIPX | 117) /* 1=make even, 0=dont make even*/
#define MIPX_SENDPTYPE     (I_MIPX | 118) /* Send ptype in options on recv*/
#define MIPX_NOSENDPTYPE   (I_MIPX | 119) /* Don't send ptype in options  */
#define MIPX_FILTERPTYPE   (I_MIPX | 120) /* Filter on recv ptype         */
#define MIPX_NOFILTERPTYPE (I_MIPX | 121) /* Don't Filter on recv ptype   */
#define MIPX_SETSENDPTYPE  (I_MIPX | 122) /* Set pkt type to send with    */
#define MIPX_GETCARDINFO   (I_MIPX | 123) /* Get info on a card           */
#define MIPX_SENDCARDNUM   (I_MIPX | 124) /* Send card num up in options  */
#define MIPX_NOSENDCARDNUM (I_MIPX | 125) /* Dont send card num in options*/
#define MIPX_SETROUTER     (I_MIPX | 126) /* Set router enabled flag      */
#define MIPX_SETRIPAGE     (I_MIPX | 127) /* Set RIP age timeout          */
#define MIPX_SETRIPUSAGE   (I_MIPX | 128) /* Set RIP usage timeout        */
#define MIPX_SETSROUTEUSAGE (I_MIPX| 129) /* Set the SROUTE usage timeout */
#define MIPX_SETINTNET     (I_MIPX | 130) /* Set internal network number  */
#define MIPX_NOVIRTADDR    (I_MIPX | 131) /* Turn off virtual net num     */
#define MIPX_VIRTADDR      (I_MIPX | 132) /* Turn on  virtual net num     */
#define MIPX_GETNETINFO    (I_MIPX | 135) /* Get info on a network num    */
#define MIPX_SETDELAYTIME  (I_MIPX | 136) /* Set cards delay time         */
#define MIPX_SETROUTEADV   (I_MIPX | 137) /* Route advertise timeout      */
#define MIPX_SETSOCKETS    (I_MIPX | 138) /* Set default sockets          */
#define MIPX_SETLINKSPEED  (I_MIPX | 139) /* Set the link speed for a card*/
#define MIPX_SETWANFLAG    (I_MIPX | 140)
#define MIPX_GETCARDCHANGES (I_MIPX | 141) /* Wait for card changes	*/
#define MIPX_GETMAXADAPTERS (I_MIPX | 142)
#define MIPX_REUSEADDRESS   (I_MIPX | 143)
#define MIPX_RERIPNETNUM    (I_MIPX | 144) /* ReRip a network         */
#define MIPX_GETNETINFO_NR  (I_MIPX | 145) /* Get info on a net num - NO RIP */

#define MIPX_SETNIC         (I_MIPX | 146)
#define MIPX_NOSETNIC       (I_MIPX | 147)

/** For Source Routing Support **/

#define MIPX_SRCLEAR       (I_MIPX | 200) /* Clear the source routing table*/
#define MIPX_SRDEF         (I_MIPX | 201) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRBCAST       (I_MIPX | 202) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRMULTI       (I_MIPX | 203) /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRREMOVE      (I_MIPX | 204) /* Remove a node from the table */
#define MIPX_SRLIST        (I_MIPX | 205) /* Get the source routing table */
#define MIPX_SRGETPARMS    (I_MIPX | 206) /* Get source routing parms     */

#define MIPX_SETSHOULDPUT  (I_MIPX | 210) /* Turn on should put call      */
#define MIPX_DELSHOULDPUT  (I_MIPX | 211) /* Turn off should put call     */
#define MIPX_GETSHOULDPUT  (I_MIPX | 212) /* Get ptr to mipx_shouldput    */

/** Added for ISN **/

#define MIPX_RCVBCAST      (I_MIPX | 300) /* (X) Enable broadcast reception */
#define MIPX_NORCVBCAST    (I_MIPX | 301) /* (X) Disable broadcast reception */
#define MIPX_ADAPTERNUM    (I_MIPX | 302) /* Get maximum adapter number */
#define MIPX_NOTIFYCARDINFO (I_MIPX | 303) /* Pend until card info changes */
#define MIPX_LOCALTARGET   (I_MIPX | 304) /* Get local target for address */
#define MIPX_NETWORKINFO   (I_MIPX | 305) /* Return info about remote net */
#define MIPX_ZEROSOCKET    (I_MIPX | 306) /* Use 0 as source socket on sends */
#define MIPX_SETRCVFLAGS   (I_MIPX | 307) /* Turn on flags in receive addr   */
#define MIPX_NORCVFLAGS    (I_MIPX | 308) /* Turn off flags in receive addr  */
#define MIPX_CONFIG        (I_MIPX | 309) /* used by IPXROUTE for config info */
#define MIPX_LINECHANGE    (I_MIPX | 310) /* queued until WAN line goes up/down */
#define MIPX_GETCARDINFO2  (I_MIPX | 311) /* Get info, return real send size for token-ring */
#define MIPX_ADAPTERNUM2   (I_MIPX | 312) /* Max. number including duplicates */


//
// Used by a user mode process to get nic info defined by the IPX_NIC_INFO
// structure.
//
// NOTE NOTE NOTE
//
// This is supposed to be used only by the FWRDR process and nobody else.
// If some other app. uses it, the FWRDR will be affected
//
//
#define MIPX_GETNEWNICINFO  (I_MIPX | 313) /*Get any new NIC info that might
                                            *be there*/

//
// IOCTL to be used if the interface is  ROUTER_INTERFACE
//
#define MIPX_SEND_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 314), METHOD_IN_DIRECT) // send dgram
#define MIPX_RCV_DATAGRAM     _TDI_CONTROL_CODE((I_MIPX | 315), METHOD_OUT_DIRECT) // send dgram

#define MIPX_RT_CREATE      (I_MIPX | 316)
#define MIPX_IPXWAN_CONFIG_DONE   (I_MIPX | 317)
#define MIPX_QUERY_WAN_INACTIVITY (I_MIPX | 318)

/** Ioctls for SPX **/

#define I_MSPX          (('S' << 24) | ('P' << 16) | ('P' << 8))
#define MSPX_SETADDR       (I_MSPX | 0)   /* Set the network address      */
#define MSPX_SETPKTSIZE    (I_MSPX | 1)   /* Set the packet size per card */
#define MSPX_SETDATASTREAM (I_MSPX | 2)   /* Set datastream type          */

/** Added for NT port **/

#define MSPX_SETASLISTEN   (I_MSPX | 100) /* Set as a listen socket       */
#define MSPX_GETSTATUS     (I_MSPX | 101) /* Get running status           */
#define MSPX_GETQUEUEPTR   (I_MSPX | 102) /* Get ptr to the streams queue */
#define MSPX_SETDATAACK    (I_MSPX | 103) /* Set DATA ACK option          */
#define MSPX_NODATAACK     (I_MSPX | 104) /* Turn off DATA ACK option     */
#define MSPX_SETMAXPKTSOCK (I_MSPX | 105) /* Set the packet size per socket */
#define MSPX_SETWINDOWCARD (I_MSPX | 106) /* Set window size for card     */
#define MSPX_SETWINDOWSOCK (I_MSPX | 107) /* Set window size for 1 socket */
#define MSPX_SENDHEADER    (I_MSPX | 108) /* Send header with data        */
#define MSPX_NOSENDHEADER  (I_MSPX | 109) /* Don't send header with data  */
#define MSPX_GETPKTSIZE    (I_MSPX | 110) /* Get the packet size per card */
#define MSPX_SETCONNCNT    (I_MSPX | 111) /* Set the conn req count       */
#define MSPX_SETCONNTO     (I_MSPX | 112) /* Set the conn req timeout     */
#define MSPX_SETALIVECNT   (I_MSPX | 113) /* Set the keepalive count      */
#define MSPX_SETALIVETO    (I_MSPX | 114) /* Set the keepalive timeout    */
#define MSPX_SETALWAYSEOM  (I_MSPX | 115) /* Turn on always EOM flag      */
#define MSPX_NOALWAYSEOM   (I_MSPX | 116) /* Turn off always EOM flag     */
#define MSPX_GETSTATS      (I_MSPX | 119) /* Get connection stats         */
#define MSPX_NOACKWAIT     (I_MSPX | 120) /* Disable piggyback wait       */
#define MSPX_ACKWAIT       (I_MSPX | 121) /* Enable pback wait (default)  */

//
// Taken out of isn\inc\bind.h
//
typedef struct _IPXCP_CONFIGURATION {
    USHORT Version;
    USHORT Length;
    UCHAR Network[4];
    UCHAR LocalNode[6];
    UCHAR RemoteNode[6];
    ULONG ConnectionClient;  // 0 - Server, 1 - Client
    ULONG InterfaceIndex;
    ULONG ConnectionId; 	 // used to match TimeSinceLastActivity IOCtls
    ULONG IpxwanConfigRequired;	 // 1 - IPXWAN Required
} IPXCP_CONFIGURATION, *PIPXCP_CONFIGURATION;

#define IPXWAN_SOCKET   (USHORT)0x490



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef LLINFO_INCLUDED
#define LLINFO_INCLUDED

#include <ipifcons.h>

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define IF_MIB_STATS_ID             1
#define IF_FRIENDLY_NAME_ID         2
#define IF_QUERY_SET_OFFLOAD_ID     3

#define MAX_PHYSADDR_SIZE   8

typedef struct IPNetToMediaEntry {
    ulong           inme_index;
    ulong           inme_physaddrlen;
    uchar           inme_physaddr[MAX_PHYSADDR_SIZE];
    ulong           inme_addr;
    ulong           inme_type;
} IPNetToMediaEntry;

#define INME_TYPE_OTHER         1
#define INME_TYPE_INVALID       2
#define INME_TYPE_DYNAMIC       3
#define INME_TYPE_STATIC        4

#define MAX_IFDESCR_LEN         256

#define IFE_FIXED_SIZE  offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
    ulong           if_index;
    ulong           if_type;
    ulong           if_mtu;
    ulong           if_speed;
    ulong           if_physaddrlen;
    uchar           if_physaddr[MAX_PHYSADDR_SIZE];
    ulong           if_adminstatus;
    ulong           if_operstatus;
    ulong           if_lastchange;
    ulong           if_inoctets;
    ulong           if_inucastpkts;
    ulong           if_innucastpkts;
    ulong           if_indiscards;
    ulong           if_inerrors;
    ulong           if_inunknownprotos;
    ulong           if_outoctets;
    ulong           if_outucastpkts;
    ulong           if_outnucastpkts;
    ulong           if_outdiscards;
    ulong           if_outerrors;
    ulong           if_outqlen;
    ulong           if_descrlen;
    uchar           if_descr[1];
} IFEntry;

// MIB-II interface status values.  The latest definition of these values 
// is in RFC 2863.  ifOperStatus can use all values.  ifAdminStatus only
// uses the first three values.

typedef enum {
    IF_STATUS_UP               = 1,
    IF_STATUS_DOWN             = 2,
    IF_STATUS_TESTING          = 3,
    IF_STATUS_UNKNOWN          = 4,
    IF_STATUS_DORMANT          = 5,
    IF_STATUS_NOT_PRESENT      = 6,
    IF_STATUS_LOWER_LAYER_DOWN = 7
} IF_STATUS_ENUM;


typedef struct IFOffloadCapability {
    ulong           ifoc_OffloadFlags;
    ulong           ifoc_IPSecOffloadFlags;
} IFOffloadCapability;

#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\httpioctl.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    HttpIoctl.h

Abstract:

    Contains structures and declarations shared between
    HTTP.SYS and HTTPAPI.DLL. Users of the HTTP API should include
    HttpP.h and not this file.

--*/


#ifndef __HTTP_IOCTL_H__
#define __HTTP_IOCTL_H__

#include <httpp.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Names of the object directory, devices, driver, and service.
//

#define HTTP_DIRECTORY_NAME         L"\\Device\\Http"
#define HTTP_CONTROL_DEVICE_NAME    L"\\Device\\Http\\Control"
#define HTTP_APP_POOL_DEVICE_NAME   L"\\Device\\Http\\AppPool"
#define HTTP_FILTER_DEVICE_NAME     L"\\Device\\Http\\Filter"
#define HTTP_SERVER_DEVICE_NAME     L"\\Device\\Http\\Server"



//
#define HTTP_DRIVER_NAME            L"HTTP.SYS"
#define HTTP_SERVICE_NAME           L"HTTP"
#define HTTP_FILTER_SERVICE_NAME    L"HTTPFilter"


//
// The current interface version number. This version number must be
// updated after any significant changes to the interface (especially
// structure changes).
//

#define HTTP_INTERFACE_VERSION_MAJOR  0x0001
#define HTTP_INTERFACE_VERSION_MINOR  0x0001


//
// The name of the EA (Extended Attribute) passed to NtCreateFile(). This
// allows us to pass version information at the time the driver is opened,
// allowing HTTP.SYS to immediately fail open requests with invalid version
// numbers.
//
// N.B. The EA name (including the terminator) must be a multiple of eight
// to ensure natural alignment of the HTTP_OPEN_PACKET structure used as
// the EA value.
//

//                                       7654321076543210
#define HTTP_OPEN_PACKET_NAME           "UlOpenPacket000"
#define HTTP_OPEN_PACKET_NAME_LENGTH    (sizeof(HTTP_OPEN_PACKET_NAME) - 1)
C_ASSERT( ((HTTP_OPEN_PACKET_NAME_LENGTH + 1) & 7) == 0 );


//
// The following structure is used as the value for the EA named above.
//

typedef struct HTTP_OPEN_PACKET
{
    USHORT             MajorVersion;
    USHORT             MinorVersion;
    USHORT             ServerNameLength;
    PWCHAR             pServerName;
    USHORT             ProxyNameLength;
    PWCHAR             pProxyName;
    USHORT             TransportAddressLength;
    PTRANSPORT_ADDRESS pTransportAddress;

} HTTP_OPEN_PACKET, *PHTTP_OPEN_PACKET;

//
// Structures for IOCTL_HTTP_QUERY_CONTROL_CHANNEL and
// IOCTL_HTTP_SET_CONTROL_CHANNEL.
//

typedef struct _HTTP_CONTROL_CHANNEL_INFO
{
    HTTP_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass;

} HTTP_CONTROL_CHANNEL_INFO, *PHTTP_CONTROL_CHANNEL_INFO;


//
// Structures for IOCTL_HTTP_CREATE_CONFIG_GROUP,
// IOCTL_HTTP_DELETE_CONFIG_GROUP, IOCTL_HTTP_QUERY_CONFIG_GROUP,
// and IOCTL_HTTP_SET_CONFIG_GROUP.
//

typedef struct _HTTP_CONFIG_GROUP_INFO
{
    HTTP_CONFIG_GROUP_ID ConfigGroupId;
    HTTP_CONFIG_GROUP_INFORMATION_CLASS InformationClass;

} HTTP_CONFIG_GROUP_INFO, *PHTTP_CONFIG_GROUP_INFO;


//
// Structures for IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP and
// IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP.
//

typedef enum _HTTP_URL_OPERATOR_TYPE
{
    HttpUrlOperatorTypeReservation,
    HttpUrlOperatorTypeRegistration,
    HttpUrlOperatorTypeMax

} HTTP_URL_OPERATOR_TYPE, *PHTTP_URL_OPERATOR_TYPE;

typedef struct _HTTP_CONFIG_GROUP_URL_INFO
{
    HTTP_URL_OPERATOR_TYPE   UrlType;
    HTTP_CONFIG_GROUP_ID     ConfigGroupId;
    HTTP_URL_CONTEXT         UrlContext;
    PSECURITY_DESCRIPTOR     pSecurityDescriptor;
    ULONG                    SecurityDescriptorLength;
    UNICODE_STRING           FullyQualifiedUrl;

} HTTP_CONFIG_GROUP_URL_INFO, *PHTTP_CONFIG_GROUP_URL_INFO;


//
// Structures for IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP.
//

typedef struct _HTTP_REMOVE_ALL_URLS_INFO
{
    HTTP_CONFIG_GROUP_ID ConfigGroupId;

} HTTP_REMOVE_ALL_URLS_INFO, *PHTTP_REMOVE_ALL_URLS_INFO;


//
// Structures for IOCTL_HTTP_CREATE_APP_POOL.
//

typedef struct _HTTP_CREATE_APP_POOL_INFO
{
    UNICODE_STRING AppPoolName;

} HTTP_CREATE_APP_POOL_INFO, *PHTTP_CREATE_APP_POOL_INFO;


//
// Structures for IOCTL_HTTP_QUERY_APP_POOL_INFORMATION and
// IOCTL_HTTP_SET_APP_POOL_INFORMATION.
//

typedef struct _HTTP_APP_POOL_INFO
{
    HTTP_APP_POOL_INFORMATION_CLASS InformationClass;

} HTTP_APP_POOL_INFO, *PHTTP_APP_POOL_INFO;


//
// Structures for IOCTL_HTTP_RECEIVE_HTTP_REQUEST and
// IOCTL_HTTP_RECEIVE_ENTITY_BODY.
//

typedef struct _HTTP_RECEIVE_REQUEST_INFO
{
    HTTP_REQUEST_ID RequestId;
    ULONG Flags;

} HTTP_RECEIVE_REQUEST_INFO, *PHTTP_RECEIVE_REQUEST_INFO;


//
// Structures for IOCTL_HTTP_SEND_HTTP_RESPONSE.
//

typedef struct _HTTP_SEND_HTTP_RESPONSE_INFO
{
    PHTTP_RESPONSE        pHttpResponse;
    USHORT                EntityChunkCount;
    PHTTP_DATA_CHUNK      pEntityChunks;
    HTTP_CACHE_POLICY     CachePolicy;
    HTTP_REQUEST_ID       RequestId;
    ULONG                 Flags;
    PHTTP_LOG_FIELDS_DATA pLogData;

} HTTP_SEND_HTTP_RESPONSE_INFO, *PHTTP_SEND_HTTP_RESPONSE_INFO;


//
// Structures for IOCTL_HTTP_FLUSH_RESPONSE_CACHE.
//

typedef struct _HTTP_FLUSH_RESPONSE_CACHE_INFO
{
    UNICODE_STRING FullyQualifiedUrl;
    ULONG          Flags;

} HTTP_FLUSH_RESPONSE_CACHE_INFO, *PHTTP_FLUSH_RESPONSE_CACHE_INFO;


//
// Structures for IOCTL_HTTP_WAIT_FOR_DISCONNECT.
//

typedef struct _HTTP_WAIT_FOR_DISCONNECT_INFO
{
    HTTP_CONNECTION_ID ConnectionId;

} HTTP_WAIT_FOR_DISCONNECT_INFO, *PHTTP_WAIT_FOR_DISCONNECT_INFO;


//
// Structures for IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT
//

typedef struct _HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO
{
    HTTP_CONNECTION_ID  ConnectionId;
    ULONG               Flags;

} HTTP_FILTER_RECEIVE_CLIENT_CERT_INFO, *PHTTP_FILTER_RECEIVE_CLIENT_CERT_INFO;


//
// Structure for IOCTL_HTTP_SEND_REQUEST (Input).
//

typedef struct  _HTTP_SEND_REQUEST_INPUT_INFO
{
    PHTTP_REQUEST_ID     pHttpRequestId;
    PHTTP_REQUEST        pHttpRequest;
    PULONG               pBytesTaken;
    ULONG                HttpRequestFlags;
    USHORT               RequestConfigCount;
    PHTTP_REQUEST_CONFIG pRequestConfig;

} HTTP_SEND_REQUEST_INPUT_INFO, *PHTTP_SEND_REQUEST_INPUT_INFO;


//
// Structure for IOCTL_HTTP_SEND_REQUEST_ENTITY_BODY_INFO.
//

typedef struct _HTTP_SEND_REQUEST_ENTITY_BODY_INFO
{
    HTTP_REQUEST_ID     RequestID;
    ULONG               Flags;
    USHORT              EntityChunkCount;
    PHTTP_DATA_CHUNK    pHttpEntityChunk;

} HTTP_SEND_REQUEST_ENTITY_BODY_INFO, *PHTTP_SEND_REQUEST_ENTITY_BODY_INFO;


//
// Structure for IOCTL_HTTP_RECEIVE_RESPONSE (Input). 
//

typedef struct _HTTP_RECEIVE_RESPONSE_INFO
{
    HTTP_REQUEST_ID RequestID;
    PULONG          pBytesTaken;
    ULONG           Flags;

} HTTP_RECEIVE_RESPONSE_INFO, *PHTTP_RECEIVE_RESPONSE_INFO;


//
// structure for IOCTL_HTTP_SET_SERVER_CONTEXT_INFORMATION & 
// IOCTL_HTTP_QUERY_SERVER_CONTEXT_INFORMATION.
//

typedef struct _HTTP_SERVER_CONTEXT_INFORMATION
{
    HTTP_SERVER_CONFIG_ID   ConfigID;
    PULONG                  pBytesTaken;
    PVOID                   pInputBuffer;
    ULONG                   InputBufferLength;

} HTTP_SERVER_CONTEXT_INFORMATION, *PHTTP_SERVER_CONTEXT_INFORMATION;


//
// Structures for IOCTL_HTTP_ADD_FRAGMENT_TO_CACHE.
//

typedef struct _HTTP_ADD_FRAGMENT_INFO
{
    UNICODE_STRING      FragmentName;
    HTTP_DATA_CHUNK     DataChunk;
    HTTP_CACHE_POLICY   CachePolicy;

} HTTP_ADD_FRAGMENT_INFO, *PHTTP_ADD_FRAGMENT_INFO;


//
// Structures for IOCTL_HTTP_READ_FRAGMENT_FROM_CACHE.
//

typedef struct _HTTP_READ_FRAGMENT_INFO
{
    UNICODE_STRING  FragmentName;
    HTTP_BYTE_RANGE ByteRange;

} HTTP_READ_FRAGMENT_INFO, *PHTTP_READ_FRAGMENT_INFO;


//
// HTTP IOCTL code definitions.
//
// N.B. To ensure the efficiency of the code generated by HTTP.SYS's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in devctrl.c.
//

#define _HTTP_CTL_CODE(request, method, access)             \
    CTL_CODE( FILE_DEVICE_NETWORK, request, method, access )

#define _HTTP_REQUEST(ioctl)                                \
   ((((ULONG)(ioctl)) >> 2) & 0x03FF)


//
// Server-side IOCTLs.
//

#define HTTP_QUERY_CONTROL_CHANNEL                          0
#define HTTP_SET_CONTROL_CHANNEL                            1
#define HTTP_CREATE_CONFIG_GROUP                            2
#define HTTP_DELETE_CONFIG_GROUP                            3
#define HTTP_QUERY_CONFIG_GROUP                             4
#define HTTP_SET_CONFIG_GROUP                               5
#define HTTP_ADD_URL_TO_CONFIG_GROUP                        6
#define HTTP_REMOVE_URL_FROM_CONFIG_GROUP                   7
#define HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP              8
#define HTTP_QUERY_APP_POOL_INFORMATION                     9
#define HTTP_SET_APP_POOL_INFORMATION                       10
#define HTTP_SHUTDOWN_APP_POOL                              11
#define HTTP_RECEIVE_HTTP_REQUEST                           12
#define HTTP_RECEIVE_ENTITY_BODY                            13
#define HTTP_SEND_HTTP_RESPONSE                             14
#define HTTP_SEND_ENTITY_BODY                               15
#define HTTP_FLUSH_RESPONSE_CACHE                           16
#define HTTP_WAIT_FOR_DEMAND_START                          17
#define HTTP_WAIT_FOR_DISCONNECT                            18
#define HTTP_FILTER_ACCEPT                                  19
#define HTTP_FILTER_CLOSE                                   20
#define HTTP_FILTER_RAW_READ                                21
#define HTTP_FILTER_RAW_WRITE                               22
#define HTTP_FILTER_APP_READ                                23
#define HTTP_FILTER_APP_WRITE                               24
#define HTTP_FILTER_RECEIVE_CLIENT_CERT                     25
#define HTTP_SHUTDOWN_FILTER_CHANNEL                        26
#define HTTP_GET_COUNTERS                                   27
#define HTTP_ADD_FRAGMENT_TO_CACHE                          28
#define HTTP_READ_FRAGMENT_FROM_CACHE                       29

//
// Client-side IOCTLs.
//

#define HTTP_SEND_REQUEST                                   30
#define HTTP_SEND_REQUEST_ENTITY_BODY                       31
#define HTTP_RECEIVE_RESPONSE                               32
#define HTTP_QUERY_SERVER_CONTEXT_INFORMATION               33 
#define HTTP_SET_SERVER_CONTEXT_INFORMATION                 34
#define HTTP_CANCEL_REQUEST                                 35

#define HTTP_NUM_IOCTLS                                     36


#define IOCTL_HTTP_QUERY_CONTROL_CHANNEL                    \
    _HTTP_CTL_CODE( HTTP_QUERY_CONTROL_CHANNEL,             \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_CONTROL_CHANNEL                      \
    _HTTP_CTL_CODE( HTTP_SET_CONTROL_CHANNEL,               \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_CREATE_CONFIG_GROUP                      \
    _HTTP_CTL_CODE( HTTP_CREATE_CONFIG_GROUP,               \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_DELETE_CONFIG_GROUP                      \
    _HTTP_CTL_CODE( HTTP_DELETE_CONFIG_GROUP,               \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_QUERY_CONFIG_GROUP                       \
    _HTTP_CTL_CODE( HTTP_QUERY_CONFIG_GROUP,                \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_CONFIG_GROUP                         \
    _HTTP_CTL_CODE( HTTP_SET_CONFIG_GROUP,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_ADD_URL_TO_CONFIG_GROUP                  \
    _HTTP_CTL_CODE( HTTP_ADD_URL_TO_CONFIG_GROUP,           \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_REMOVE_URL_FROM_CONFIG_GROUP             \
    _HTTP_CTL_CODE( HTTP_REMOVE_URL_FROM_CONFIG_GROUP,      \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP        \
    _HTTP_CTL_CODE( HTTP_REMOVE_ALL_URLS_FROM_CONFIG_GROUP, \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_QUERY_APP_POOL_INFORMATION               \
    _HTTP_CTL_CODE( HTTP_QUERY_APP_POOL_INFORMATION,        \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SET_APP_POOL_INFORMATION                 \
    _HTTP_CTL_CODE( HTTP_SET_APP_POOL_INFORMATION,          \
                    METHOD_IN_DIRECT,                       \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_SHUTDOWN_APP_POOL                        \
    _HTTP_CTL_CODE( HTTP_SHUTDOWN_APP_POOL,                 \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_RECEIVE_HTTP_REQUEST                     \
    _HTTP_CTL_CODE( HTTP_RECEIVE_HTTP_REQUEST,              \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_RECEIVE_ENTITY_BODY                      \
    _HTTP_CTL_CODE( HTTP_RECEIVE_ENTITY_BODY,               \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_HTTP_RESPONSE                       \
    _HTTP_CTL_CODE( HTTP_SEND_HTTP_RESPONSE,                \
                    METHOD_NEITHER,                         \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_ENTITY_BODY                         \
    _HTTP_CTL_CODE( HTTP_SEND_ENTITY_BODY,                  \
                    METHOD_NEITHER,                         \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FLUSH_RESPONSE_CACHE                     \
    _HTTP_CTL_CODE( HTTP_FLUSH_RESPONSE_CACHE,              \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_WAIT_FOR_DEMAND_START                    \
    _HTTP_CTL_CODE( HTTP_WAIT_FOR_DEMAND_START,             \
                    METHOD_BUFFERED,                        \
                    FILE_WRITE_ACCESS )

#define IOCTL_HTTP_WAIT_FOR_DISCONNECT                      \
    _HTTP_CTL_CODE( HTTP_WAIT_FOR_DISCONNECT,               \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_ACCEPT                            \
    _HTTP_CTL_CODE( HTTP_FILTER_ACCEPT,                     \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_CLOSE                             \
    _HTTP_CTL_CODE( HTTP_FILTER_CLOSE,                      \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RAW_READ                          \
    _HTTP_CTL_CODE( HTTP_FILTER_RAW_READ,                   \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RAW_WRITE                         \
    _HTTP_CTL_CODE( HTTP_FILTER_RAW_WRITE,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_APP_READ                          \
    _HTTP_CTL_CODE( HTTP_FILTER_APP_READ,                   \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_APP_WRITE                         \
    _HTTP_CTL_CODE( HTTP_FILTER_APP_WRITE,                  \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_FILTER_RECEIVE_CLIENT_CERT               \
    _HTTP_CTL_CODE( HTTP_FILTER_RECEIVE_CLIENT_CERT,        \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SHUTDOWN_FILTER_CHANNEL                  \
    _HTTP_CTL_CODE( HTTP_SHUTDOWN_FILTER_CHANNEL,           \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_GET_COUNTERS                             \
    _HTTP_CTL_CODE( HTTP_GET_COUNTERS,                      \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_ADD_FRAGMENT_TO_CACHE                    \
    _HTTP_CTL_CODE( HTTP_ADD_FRAGMENT_TO_CACHE,             \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_READ_FRAGMENT_FROM_CACHE                 \
    _HTTP_CTL_CODE( HTTP_READ_FRAGMENT_FROM_CACHE,          \
                    METHOD_NEITHER,                         \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_REQUEST                             \
    _HTTP_CTL_CODE( HTTP_SEND_REQUEST,                      \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_SEND_REQUEST_ENTITY_BODY                 \
    _HTTP_CTL_CODE( HTTP_SEND_REQUEST_ENTITY_BODY,          \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_RECEIVE_RESPONSE                         \
    _HTTP_CTL_CODE( HTTP_RECEIVE_RESPONSE,                  \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS )

#define IOCTL_HTTP_QUERY_SERVER_CONTEXT_INFORMATION         \
    _HTTP_CTL_CODE( HTTP_QUERY_SERVER_CONTEXT_INFORMATION,  \
                    METHOD_OUT_DIRECT,                      \
                    FILE_READ_ACCESS | FILE_WRITE_ACCESS )

#define IOCTL_HTTP_SET_SERVER_CONTEXT_INFORMATION           \
    _HTTP_CTL_CODE( HTTP_SET_SERVER_CONTEXT_INFORMATION,    \
                    METHOD_IN_DIRECT,                       \
                    FILE_READ_ACCESS | FILE_WRITE_ACCESS )

#define IOCTL_HTTP_CANCEL_REQUEST                           \
    _HTTP_CTL_CODE( HTTP_CANCEL_REQUEST,                    \
                    METHOD_BUFFERED,                        \
                    FILE_READ_ACCESS | FILE_WRITE_ACCESS )


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif // __HTTP_IOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\logonp.h ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    logonp.h

Abstract:

    Private Netlogon service routines useful by both the Netlogon service
    and others that pass mailslot messages to/from the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 7-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef _LOGONP_H_
#define _LOGONP_H_
#include <dsgetdc.h>    // PDS_DOMAIN_TRUSTSW

//
// Message versions returned from NetpLogonGetMessageVersion
//

#define LMUNKNOWN_MESSAGE   0  // No version tokens on end of message
#define LM20_MESSAGE        1  // Just LM 2.0 token on end of message
#define LMNT_MESSAGE        2  // LM 2.0 and LM NT token on end of message
#define LMUNKNOWNNT_MESSAGE 3  // LM 2.0 and LM NT token on end of
                                    // message, but the version is not
                                    // supported.
#define LMWFW_MESSAGE       4  // LM WFW token on end of message

//
// Define the token placed in the last two bytes of a LanMan 2.0 message
//

#define LM20_TOKENBYTE    0xFF

//
// Define the token placed in the last four bytes of a NT LanMan message
//  Notice that such a message is by definition a LanMan 2.0 message
//

#define LMNT_TOKENBYTE    0xFF

//
// Define the token placed in the next to last byte of the PRIMARY_QUERY
// message from newer (8/8/94) WFW and Chicago clients.  This byte (followed
// by a LM20_TOKENBYTE) indicates the client is WAN-aware and sends the
// PRIMARY_QUERY to the DOMAIN<1B> name.  As such, BDC on the same subnet need
// not respond to this query.
//

#define LMWFW_TOKENBYTE   0xFE

//
//  Put the LANMAN NT token onto the end of a message.
//
//  The token is always followed by a LM 2.0 token so LM 2.0 systems will
//  think this message is from a LM 2.0 system.
//
//  Also append a version flag before the NT TOKEN so that the future
//  versions of software can handle the newer messages effectively.
//
//Arguments:
//
//  Where - Indirectly points to the current location in the buffer.  The
//      'String' is copied to the current location.  This current location is
//      updated to point to the byte following the token.
//
//  NtVersion - Additional version information to be or'ed into the NtVersion
//      field of the message.

#define NetpLogonPutNtToken( _Where, _NtVersion ) \
{ \
    SmbPutUlong( (*_Where), NETLOGON_NT_VERSION_1 | (_NtVersion) ); \
    (*_Where) += sizeof(ULONG); \
    *((PUCHAR)((*_Where)++)) = LMNT_TOKENBYTE; \
    *((PUCHAR)((*_Where)++)) = LMNT_TOKENBYTE; \
    NetpLogonPutLM20Token( _Where ); \
}

//
//  Put the LANMAN 2.0 token onto the end of a message.
//
//Arguments:
//
//  Where - Indirectly points to the current location in the buffer.  The
//      'String' is copied to the current location.  This current location is
//      updated to point to the byte following the token.

#define NetpLogonPutLM20Token( _Where ) \
{ \
    *((PUCHAR)((*_Where)++)) = LM20_TOKENBYTE; \
    *((PUCHAR)((*_Where)++)) = LM20_TOKENBYTE; \
}

#define NetpLogonPutGuid( _Guid, _Where ) \
            NetpLogonPutBytes( (_Guid), sizeof(GUID), _Where )

#define NetpLogonGetGuid( _Message, _MessageSize, _Where, _Guid ) \
            NetpLogonGetBytes( \
                (_Message),    \
                (_MessageSize),\
                (_Where),      \
                sizeof(GUID),  \
                (_Guid) )



//
// Name of binary Forest Trust List file
//
#define NL_FOREST_BINARY_LOG_FILE L"\\system32\\config\\netlogon.ftl"
#define NL_FOREST_BINARY_LOG_FILE_JOIN L"\\system32\\config\\netlogon.ftj"

//
// Header for binary Forest Trust List file.
//

typedef struct _DS_DISK_TRUSTED_DOMAIN_HEADER {

    ULONG Version;

} DS_DISK_TRUSTED_DOMAIN_HEADER, *PDS_DISK_TRUSTED_DOMAIN_HEADER;

#define DS_DISK_TRUSTED_DOMAIN_VERSION   1

//
// Entry for binary Forest Trust List file.
//
typedef struct _PDS_DISK_TRUSTED_DOMAIN {

    //
    // Size of entire entry
    //

    ULONG EntrySize;

    //
    // Name of the trusted domain.
    //
    ULONG NetbiosDomainNameSize;
    ULONG DnsDomainNameSize;


    //
    // Flags defining attributes of the trust.
    //
    ULONG Flags;

    //
    // Index to the domain that is the parent of this domain.
    //  Only defined if NETLOGON_DOMAIN_IN_FOREST is set and
    //      NETLOGON_DOMAIN_TREE_ROOT is not set.
    //
    ULONG ParentIndex;

    //
    // The trust type and attributes of this trust.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  these value are infered.
    //
    ULONG TrustType;
    ULONG TrustAttributes;

    //
    // The SID of the trusted domain.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  this value will be NULL.
    //
    ULONG DomainSidSize;

    //
    // The GUID of the trusted domain.
    //

    GUID DomainGuid;

} DS_DISK_TRUSTED_DOMAINS, *PDS_DISK_TRUSTED_DOMAINS;

//
// Procedure forwards from logonp.c
//

VOID
NetpLogonPutOemString(
    IN LPSTR String,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    );

VOID
NetpLogonPutUnicodeString(
    IN LPWSTR String,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    );

VOID
NetpLogonPutBytes(
    IN LPVOID Data,
    IN DWORD Size,
    IN OUT PCHAR * Where
    );

DWORD
NetpLogonGetMessageVersion(
    IN PVOID Message,
    IN PDWORD MessageSize,
    OUT PULONG Version
    );

BOOL
NetpLogonGetOemString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringLength,
    OUT LPSTR *String
    );

BOOL
NetpLogonGetUnicodeString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringSize,
    OUT LPWSTR *String
    );

BOOL
NetpLogonGetBytes(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD DataSize,
    OUT LPVOID Data
    );

BOOL
NetpLogonGetDBInfo(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    OUT PDB_CHANGE_INFO Data
);

LPWSTR
NetpLogonOemToUnicode(
    IN LPSTR Ansi
    );

LPSTR
NetpLogonUnicodeToOem(
    IN LPWSTR Unicode
    );

NET_API_STATUS
NetpLogonWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );

//
// Define the largest message returned by a mailslot created by
// NetpLogonCreateRandomMailslot().  The 64 byte value allows expansion
// of the messages in the future.
//
#define MAX_RANDOM_MAILSLOT_RESPONSE (max(sizeof(NETLOGON_LOGON_RESPONSE), sizeof(NETLOGON_PRIMARY)) + 64 )

NET_API_STATUS
NetpLogonCreateRandomMailslot(
    IN LPSTR path,
    OUT PHANDLE MsHandle
    );

VOID
NetpLogonPutDomainSID(
    IN PCHAR Sid,
    IN DWORD SidLength,
    IN OUT PCHAR * Where
    );

BOOL
NetpLogonGetDomainSID(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD SIDSize,
    OUT PCHAR *Sid
    );

BOOLEAN
NetpLogonTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN DWORD Timeout
    );

NET_API_STATUS
NlWriteBinaryLog(
    IN LPWSTR FileSuffix,
    IN LPBYTE Buffer,
    IN ULONG BufferSize
    );

NET_API_STATUS
NlWriteFileForestTrustList (
    IN LPWSTR FileSuffix,
    IN PDS_DOMAIN_TRUSTSW ForestTrustList,
    IN ULONG ForestTrustListCount
    );

#endif // _LOGONP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\mpr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mpr.h

Abstract:

    Standard MPR Header File for NT-WIN32

Author:

    John Ludeman (Johnl)    10-Dec-1991

Environment:

    User Mode -Win32

Notes:

    This is a private header file specific to the multiple provider and
    the windows shell.

Revision History:

    10-Dec-1991     Johnl
    Created

    13-Jan-1992     Johnl
    Moved return codes specific to WNetRestoreConnection from winnet32.h
        to here.

    24-Jan-1992     Johnl
    Added additional APIs for support of Filemanager's toolbar

    19-Mar-1992     JohnL
    Added WNetNukeConnections

    12-May-1992     Johnl
    Removed "I_" from I_WNetConnect/DisconnectDialog,
    Added WNNC_DLG_Disconnect and WNNC_DLG_Connect manifests

    05-Aug-1992     AlbertT
        Added extra BOOL bFlushCache to WNetGetDirectoryType{A,W}

    26-Aug-1992     Johnl
    Renamed WNetNukeConnections to WNetClearConnections

    Nov-5-1992      CongpaY
        Add structures _CONNECT_INFO, PARAMETERS, ERRORDLGPARAMETERS
        and functions DoPassordDialog, DoProfileErrorDialog
        and ShowReconnectDialog. They are used by restoring connection.

    07-Nov-1992     ChuckC
        Added WNetDisconnectDialog2 and WNetConnectionDialog2 for help
        support.

    12-Nov-1992     Yi-HsinS
        Added WNetBrowsePrinterDialog, WNetBrowseDialog

    20-Dec-1992     Yi-HsinS
        Added WNetGetFormatNameProc

    29-Dec-1992     Johnl
        Added WNetGetConnection2

    07-Jan-1993     Danl
        Added Credential Management API

    29-Jun-1994     JonN
        Added parameter to DoProfileErrorDialog

    23-Mar-1995     AnirudhS
        Added WNFMT_* manifests

    12-Jul-1995     Anirudhs
        Removed things defined in winnetwk.h and winnetp.h

    21-Feb-1997     AnirudhS
        Added I_MprSaveConn for use by setup (Win95->NT upgrade)

--*/
#include <lmcons.h>
#include <wincred.h>
#ifndef _MPR_H_INCLUDED
#define _MPR_H_INCLUDED

//For restoring connection stuff. Add by congpay.
// const used by connect.c
#define SHOW_CONNECTION     (WM_USER+200)
#define DO_PASSWORD_DIALOG  (WM_USER + 201)
#define DO_ERROR_DIALOG     (WM_USER + 202)

// Used by I_MprSaveConn
#define DEFER_EXPLICIT_PASSWORD         0x00000001
#define DEFER_UNKNOWN                   0x00000002
#define DEFER_DEFAULT_CRED              0x00000004

// Errors that can be repaired by popping up a
// username/password dialog

#define IS_USERNAME_PASSWORD_ERROR(x)     \
        CREDUI_IS_AUTHENTICATION_ERROR(x)

// types used by connect.c

typedef struct _CONNECTION_INFO *LPCONNECTION_INFO;

// The following two structures are used by two threads in mpr.dll and
// mprui.dll to share data.

typedef struct _PARAMETERS
{
    HWND       hDlg;
    HANDLE     hDlgCreated;                // Initialized in WNetRestoreConnection
    HANDLE     hDlgFailed;                 // Initialized in WNetRestoreConnection
    HANDLE     hDonePassword;              // Initialized in WNetRestoreConnection
    TCHAR *    pchResource;                // ShowReconnectDialog, DoRestoreConnection
    TCHAR *    pchUserName;                // For DoPasswordDialog
    TCHAR      passwordBuffer[UNLEN+1];    // Used by WNetRestoreThisConnection
    BOOL       fSuccess;                   // For the DoPasswordDialog
    BOOL       fDidCancel;                 // For the DoPasswordDialog
    DWORD      dwError;                    // Error from the connection attempt
    LONG       fDoCleanup;                 // TRUE if the current thread should clean up
    HINSTANCE  hDll;                       // Handle to mpr.dll to prevent unload
    DWORD      status;                     // return value from DoRestoreConnection
    DWORD      numSubKeys;                 // Initialized in WNetRestoreConnection
    DWORD      RegMaxWait;
    LPCONNECTION_INFO ConnectArray;        // Initialized in WNetRestoreConnection
    DWORD      dwRestoreFlags;             // WNRC_ flags - modify the behavior of WNetRestoreConnection
    BOOL       fReconnectFailed;           // set to TRUE if any reconnect fails
}
PARAMETERS;

#ifdef __cplusplus
extern "C" {
#endif

//function load from mprui.dll.

DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    DWORD         cbPasswordReturnBuffer, // bytes!
    BOOL *        pfDidCancel,
    DWORD         dwError
    );

DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel, // ask whether to stop reconnecting devices
                                //  this time?
    BOOL *        pfDidCancel,  // stop reconnecting devices this time?
                                //  active iff fAllowCancel
    BOOL *        pfDisconnect, // do not reconnect this device in future?
    BOOL *        pfHideErrors  // stop displaying error dialogs this time?
                                //  active iff fAllowCancel
    );

DWORD
MPRUI_ShowReconnectDialog(
    HWND          hwndParent,
    PARAMETERS *  Params
    );

//
// Return codes from WNetRestoreConnection
//
#define WN_CONTINUE     0x00000BB9

DWORD APIENTRY
RestoreConnectionA0(
    HWND    hWnd,
    LPSTR  lpDevice
    );

DWORD APIENTRY
MPRUI_WNetClearConnections(
     HWND    hWnd
     );

DWORD
MPRUI_WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD
MPRUI_WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );

DWORD
MPRUI_WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD
MPRUI_WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpDiscDlgStruct
    );

DWORD
MPRUI_WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpDiscDlgStruct
    );


//
// Authentication Provider (Credential Management) Functions
//

DWORD APIENTRY
WNetLogonNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    );

typedef DWORD
(APIENTRY *PF_WNetLogonNotify) (
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    );

DWORD APIENTRY
WNetPasswordChangeNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    );

//
// Directory functions
//
DWORD
WNetGetDirectoryTypeA (
    LPSTR   lpName,
    LPINT   lpType,
    BOOL    bFlushCache
    );

DWORD
WNetGetDirectoryTypeW (
    LPTSTR  lpName,
    LPINT   lpType,
    BOOL    bFlushCache
    );

#ifdef UNICODE
#define WNetGetDirectoryType   WNetGetDirectoryTypeW
#else
#define WNetGetDirectoryType   WNetGetDirectoryTypeA
#endif  // UNICODE


DWORD
WNetDirectoryNotifyA (
    HWND    hwnd,
    LPSTR   lpDir,
    DWORD   dwOper
    );

DWORD
WNetDirectoryNotifyW (
    HWND    hwnd,
    LPTSTR  lpDir,
    DWORD   dwOper
    );

#ifdef UNICODE
#define WNetDirectoryNotify   WNetDirectoryNotifyW
#else
#define WNetDirectoryNotify   WNetDirectoryNotifyA
#endif  // UNICODE


DWORD
WNetPropertyDialogA (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    DWORD nType
    );

DWORD
WNetPropertyDialogW (
    HWND  hwndParent,
    DWORD iButton,
    DWORD nPropSel,
    LPTSTR lpszName,
    DWORD nType
    );

#ifdef UNICODE
#define WNetPropertyDialog    WNetPropertyDialogW
#else
#define WNetPropertyDialog    WNetPropertyDialogA
#endif  // UNICODE


DWORD
WNetGetPropertyTextA (
    DWORD iButton,
    DWORD nPropSel,
    LPSTR lpszName,
    LPSTR lpszButtonName,
    DWORD nButtonNameLength,
    DWORD nType
    );

DWORD
WNetGetPropertyTextW (
    DWORD  iButton,
    DWORD  nPropSel,
    LPTSTR lpszName,
    LPTSTR lpszButtonName,
    DWORD  nButtonNameLength,
    DWORD  nType
    );

#ifdef UNICODE
#define WNetGetPropertyText   WNetGetPropertyTextW
#else
#define WNetGetPropertyText   WNetGetPropertyTextA
#endif  // UNICODE

typedef struct _WNET_CONNECTINFOA
{
    LPSTR lpRemoteName ;
    LPSTR lpProvider ;
} WNET_CONNECTIONINFOA, *LPWNET_CONNECTIONINFOA ;

typedef struct _WNET_CONNECTINFOW
{
    LPWSTR lpRemoteName ;
    LPWSTR lpProvider ;
} WNET_CONNECTIONINFOW, *LPWNET_CONNECTIONINFOW ;

#ifdef UNICODE
#define WNET_CONNECTIONINFO   WNET_CONNECTIONINFOW
#define LPWNET_CONNECTIONINFO LPWNET_CONNECTIONINFOW
#else
#define WNET_CONNECTIONINFO WNET_CONNECTIONINFOA
#define LPWNET_CONNECTIONINFO LPWNET_CONNECTIONINFOA
#endif  // UNICODE

//
//  Used in conjunction with WNET_CONNECTIONINFO, gets the net provider name
//  in addition to the remote name for this connection.
//
DWORD
WNetGetConnection2A(
    LPSTR   lpLocalName,
    LPVOID  lpBuffer,       // Contains WNET_CONNECTIONINFOA struct
    LPDWORD lpBufferSize    // In bytes!
    ) ;

DWORD
WNetGetConnection2W(
    LPWSTR  lpLocalName,
    LPVOID  lpBuffer,       // Contains WNET_CONNECTIONINFOW struct
    LPDWORD lpBufferSize    // In bytes!
    ) ;

#ifdef UNICODE
#define WNetGetConnection2 WNetGetConnection2W
#else
#define WNetGetConnection2 WNetGetConnection2A
#endif  // UNICODE

//
// Used by winlogon to close all net connections at logoff
//
DWORD APIENTRY WNetClearConnections(HWND hWnd);

//
// This entry point is used by setup when converting a Win9x user hive to NT
//
DWORD
I_MprSaveConn(
    IN HKEY             HiveRoot,
    IN LPCWSTR          ProviderName,
    IN DWORD            ProviderType,
    IN LPCWSTR          UserName,
    IN LPCWSTR          LocalName,
    IN LPCWSTR          RemoteName,
    IN DWORD            ConnectionType,
    IN BYTE             ProviderFlags,
    IN DWORD            DeferFlags
    );


//
// Browse dialog
//

// Type of the callback routine used by the browse dialog to validate
// the path input by the user
typedef BOOL (*PFUNC_VALIDATION_CALLBACK)( LPWSTR pszName );

//  WNetBrowseDialog and WNetBrowsePrinterDialog
//  NOTE: WNetBrowsePrintDialog =
//        WNetBrowseDialog with dwType RESOURCETYPE_PRINT
//
/*******************************************************************

    NAME:       WNetBrowseDialog, WNetBrowsePrinterDialog

    SYNOPSIS:   Presents a dialog to the user from which the user can
                browse the network for disk or print shares.

    ENTRY:      hwndParent  -  Parent window handle
                dwType      -  ( Only in WNetBrowseDialog )
                   RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpszName    -  The path name typed by the user. It will be
                               undefined if the user hits the CANCEL button.
                cchBufSize  -  The buffer size of the lpszName in characters
                lpszHelpFile-  The helpfile to use when the user hits F1.
                nHelpContext-  The helpcontext to use for the helpfile above
                pfuncValidation - Callback method to validate the path typed
                   by the user. If NULL, no validation will
                               be done.

    RETURNS:    WN_CANCEL when the user cancels the dialog. NO_ERROR
                on success, standard ERROR_* error code otherwise

    NOTES:      This is a UNICODE only API.

    HISTORY:
        Yi-HsinS    22-Nov-1992    Created

********************************************************************/

DWORD WNetBrowseDialog(
    HWND    hwndParent,
    DWORD   dwType,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation );

DWORD WNetBrowsePrinterDialog(
    HWND    hwndParent,
    WCHAR  *lpszName,
    DWORD   cchBufSize,
    WCHAR  *lpszHelpFile,
    DWORD   nHelpContext,
    PFUNC_VALIDATION_CALLBACK pfuncValidation );

//
// stuff in user, not driver, for shell apps
//
DWORD APIENTRY WNetErrorText(DWORD,LPTSTR,DWORD);

//
// used by MPRUI.DLL to determine if a provider supports
// NpSearchDialog() and obtain to a pointer to it.
//
FARPROC WNetGetSearchDialog(LPWSTR lpProvider) ;

//
// used by MPRUI.DLL to determine if a provider supports
// NPFormatNetworkName() and obtain a pointer to it.
//
FARPROC WNetGetFormatNameProc(LPWSTR lpProvider) ;

//
// used by MPRUI.DLL to determine if a provider supports
// WNNC_ENUM_GLOBAL
//
BOOL WNetSupportGlobalEnum(LPWSTR lpProvider) ;

//
// used by ACLEDIT.DLL to get provider-specific permission editor
//

DWORD WNetFMXGetPermCaps( LPWSTR lpDriveName ) ;
DWORD WNetFMXEditPerm( LPWSTR lpDriveName, HWND hwndFMX, DWORD nDialogType );
DWORD WNetFMXGetPermHelp( LPWSTR  lpDriveName,
                          DWORD   nDialogType,
                          BOOL    fDirectory,
                          LPVOID  lpFileNameBuffer,
                          LPDWORD lpBufferSize,
                          LPDWORD lpnHelpContext );

//
// sections and keys used for persistent connections
//

#define WNNC_DLG_DISCONNECT     0x0008
#define WNNC_DLG_CONNECT        0x0004

#ifdef UNICODE

#define MPR_MRU_FILE_SECTION        L"NET_Files"
#define MPR_MRU_PRINT_SECTION       L"NET_Printers"
#define MPR_MRU_ORDER_KEY       L"Order"

#define MPR_NETWORK_SECTION     L"Network"
#define MPR_SAVECONNECTION_KEY      L"SaveConnections"
#define MPR_RESTORECONNECTION_KEY   L"RestoreConnections"
#define MPR_EXPANDLOGONDOMAIN_KEY       L"ExpandLogonDomain"

#define MPR_YES_VALUE           L"yes"
#define MPR_NO_VALUE            L"no"

#else

#define MPR_MRU_FILE_SECTION        "NET_Files"
#define MPR_MRU_PRINT_SECTION       "NET_Printers"
#define MPR_MRU_ORDER_KEY       "Order"

#define MPR_NETWORK_SECTION     "Network"
#define MPR_SAVECONNECTION_KEY      "SaveConnections"
#define MPR_RESTORECONNECTION_KEY   "RestoreConnections"
#define MPR_EXPANDLOGONDOMAIN_KEY       "ExpandLogonDomain"

#define MPR_YES_VALUE           "yes"
#define MPR_NO_VALUE            "no"

#endif  // UNICODE


//
// Internal NP interface used to help the NTLM provider remember
// whether a persistent connection is a DFS connection or not
//

DWORD APIENTRY
NPGetReconnectFlags (
       IN  LPWSTR   lpLocalName,
       OUT LPBYTE   lpPersistFlags
    );
typedef DWORD (*PF_NPGetReconnectFlags) (
       LPWSTR   lpLocalName,
       LPBYTE   lpPersistFlags
    );

// This macro operates on the dwFlags parameter of NPAddConnection3
#define CONNECT_PROVIDER_FLAGS(dwFlags)   ((BYTE) (((dwFlags) & 0xFF000000) >> 24))

#ifdef __cplusplus
}
#endif

#endif // _MPR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\msgtext.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    apperr.h

Abstract:

    This file contains the number and text of miscellaneous error
    messages.

Author:

    Cliff Van Dyke (CliffV) 4-Nov-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

--*/


#define MTXT_BASE 3300


/**INTERNAL_ONLY**/

/*** WARNING *** WARNING *** WARNING ****
 *                                      *
 * The redirector has hardcoded in its  *
 * makefile some message numbers used   *
 * at startup.  If you change MTXT_BASE *
 * or any of the redirs message numbers *
 * you must also fix the redir makefile *
 * where it generates netwksta.pro      *
 *                                      *
 ****************************************/

/************* WARNING ***************
 * See the comment in netcons.h for  *
 * info on the allocation of errors  *
 *************************************/

/**END_INTERNAL**/

/*  Share remarks, must be <= MAXCOMMENTSZ bytes.
 */

#define MTXT_IPC_SHARE_REMARK       MTXT_BASE+1   /* @I Remote IPC %0 */
#define MTXT_ADMIN_SHARE_REMARK     MTXT_BASE+2   /* @I Remote Admin %0 */
#define MTXT_LOGON_SRV_SHARE_REMARK MTXT_BASE+3   /* @I Logon server share %0 */


#define MTXT_WKSTA_ERR_POPUP_HDR MTXT_BASE+4    /* @I A network error occurred. %0 */

/* NetWksta installation messages.
 */

#define MTXT_MemAllocMsg        (MTXT_BASE+100) /* There is not enough memory to start the Workstation service. */
#define MTXT_IniFilRdErr        (MTXT_BASE+101) /* An error occurred when reading the NETWORKS entry in the LANMAN.INI file. */
#define MTXT_BadArgMsg          (MTXT_BASE+102) /* This is an invalid argument: %1. */
#define MTXT_BadNetEntHdr    (MTXT_BASE+103) /* @W The %1 NETWORKS entry in the LANMAN.INI file has a
     * syntax error and will be ignored.
     */
#define MTXT_MultNetsMsg        (MTXT_BASE+104) /* There are too many NETWORKS entries in the LANMAN.INI file. */
/* UNUSED            (MTXT_BASE+105) */
#define MTXT_BadBiosMsg        (MTXT_BASE+106) /* @W An error occurred when opening network
     * device driver %1 = %2.
     */
#define MTXT_BadLinkMsg         (MTXT_BASE+107) /* @W Device driver %1 sent a bad BiosLinkage response.*/
#define MTXT_BadVerMsg          (MTXT_BASE+108) /* The program cannot be used with this operating system. */
#define MTXT_RdrInstMsg         (MTXT_BASE+109) /* The redirector is already installed. */
#define MTXT_Version        (MTXT_BASE+110) /* @I Installing NETWKSTA.SYS Version %1.%2.%3  (%4)
     *
     */
#define MTXT_RdrInstlErr    (MTXT_BASE+111) /* There was an error installing NETWKSTA.SYS.
     *
     * Press ENTER to continue.
     */
#define MTXT_BadResolver    (MTXT_BASE+112) /* Resolver linkage problem. */

/*
 *    Forced Logoff error messages
 */

#define MTXT_Expiration_Warning (MTXT_BASE + 113) /* @I
     * Your logon time at %1 ends at %2.
     * Please clean up and log off.
     */

#define MTXT_Logoff_Warning (MTXT_BASE + 114) /* @I
     *
     * You will be automatically disconnected at %1.
     */

#define MTXT_Expiration_Message (MTXT_BASE + 115) /* @I
     * Your logon time at %1 has ended.
     */

#define MTXT_Past_Expiration_Message (MTXT_BASE + 116) /* @I
     * Your logon time at %1 ended at %2.
     */

#define MTXT_Immediate_Kickoff_Warning (MTXT_BASE + 117) /* @I
     * WARNING: You have until %1 to logoff. If you
     * have not logged off at this time, your session will be
     * disconnected, and any open files or devices you
     * have open may lose data.
     */

#define MTXT_Kickoff_Warning (MTXT_BASE + 118) /* @I
     * WARNING: You must log off at %1 now.  You have
     * two minutes to log off, or you will be disconnected.
     */

#define MTXT_Kickoff_File_Warning (MTXT_BASE + 119) /* @I
     *
     * You have open files or devices, and a forced
     * disconnection may cause you to lose data.
     */

/*  Servers default share remark */

#define MTXT_Svr_Default_Share_Remark (MTXT_BASE + 120) /* @I
     *Default Share for Internal Use %0*/

/* Messenger Service Message Box Title */
#define MTXT_MsgsvcTitle (MTXT_BASE + 121) /* @I
     *Messenger Service %0*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\mdhcsapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mdhcpapi.h

Abstract:

    This file contains the MDHCP APIs proto-type and description. Also
    contains the data structures used by the MDHCP APIs.

Author:

    Munil Shah  (munils)  01-Oct-1997

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _MDHCSAPI_H_
#define _MDHCSAPI_H_

#if defined(MIDL_PASS)
#define LPWSTR [string] wchar_t *
#endif

typedef struct _DHCP_MSCOPE_INFO {
    LPWSTR MScopeName;
    LPWSTR MScopeComment;
    DWORD  MScopeId;
    DWORD  MScopeAddressPolicy;
    DHCP_HOST_INFO PrimaryHost;
    DHCP_SUBNET_STATE MScopeState;
    DWORD  MScopeFlags;
    DATE_TIME   ExpiryTime;
    LPWSTR  LangTag;
    BYTE    TTL;
} DHCP_MSCOPE_INFO, *LPDHCP_MSCOPE_INFO;

typedef struct _DHCP_MSCOPE_TABLE {
    DWORD NumElements;
#if defined( MIDL_PASS )
    [ size_is( NumElements ) ]
#endif;
    LPWSTR *pMScopeNames;         // scope name
} DHCP_MSCOPE_TABLE, *LPDHCP_MSCOPE_TABLE;

typedef struct _DHCP_MCLIENT_INFO {
    DHCP_IP_ADDRESS ClientIpAddress;    // currently assigned IP address.
    DWORD   MScopeId;
    DHCP_CLIENT_UID ClientId;
    LPWSTR ClientName;                  // optional.
    DATE_TIME ClientLeaseStarts;       // UTC time in FILE_TIME format.
    DATE_TIME ClientLeaseEnds;       // UTC time in FILE_TIME format.
    DHCP_HOST_INFO OwnerHost;           // host that distributed this IP address.
    DWORD   AddressFlags;
    BYTE    AddressState;
} DHCP_MCLIENT_INFO, *LPDHCP_MCLIENT_INFO;

typedef struct _DHCP_MCLIENT_INFO_ARRAY {
    DWORD NumElements;
#if defined(MIDL_PASS)
    [size_is(NumElements)]
#endif // MIDL_PASS
        LPDHCP_MCLIENT_INFO *Clients; // array of pointers
} DHCP_MCLIENT_INFO_ARRAY, *LPDHCP_MCLIENT_INFO_ARRAY;

typedef struct _MSCOPE_MIB_INFO {
    DWORD MScopeId;
    LPWSTR MScopeName;
    DWORD NumAddressesInuse;
    DWORD NumAddressesFree;
    DWORD NumPendingOffers;
} MSCOPE_MIB_INFO, *LPMSCOPE_MIB_INFO;

typedef struct _DHCP_MCAST_MIB_INFO {
    DWORD Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Renews;
    DWORD Acks;
    DWORD Naks;
    DWORD Releases;
    DWORD Informs;
    DATE_TIME ServerStartTime;
    DWORD Scopes;
#if defined(MIDL_PASS)
    [size_is(Scopes)]
#endif // MIDL_PASS
    LPMSCOPE_MIB_INFO ScopeInfo; // array.
} DHCP_MCAST_MIB_INFO, *LPDHCP_MCAST_MIB_INFO;

// The APIs

#ifndef     DHCPAPI_NO_PROTOTYPES
DWORD DHCP_API_FUNCTION
DhcpSetMScopeInfo(
    DHCP_CONST WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_MSCOPE_INFO MScopeInfo,
    BOOL NewScope
    );

DWORD DHCP_API_FUNCTION
DhcpGetMScopeInfo(
    DHCP_CONST WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_MSCOPE_INFO *MScopeInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopes(
    DHCP_CONST WCHAR *ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpAddMScopeElement(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopeElements(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpRemoveMScopeElement(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteMScope(
    WCHAR * ServerIpAddress,
    WCHAR *  MScopeName,
    DHCP_FORCE_FLAG ForceFlag
    );

DWORD DHCP_API_FUNCTION
DhcpGetMClientInfo(
    WCHAR * ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_MCLIENT_INFO *ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpDeleteMClientInfo(
    WCHAR * ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    );

DWORD DHCP_API_FUNCTION
DhcpEnumMScopeClients(
    WCHAR * ServerIpAddress,
    WCHAR * MScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    );

DWORD DHCP_API_FUNCTION
DhcpScanMDatabase(
    DHCP_CONST WCHAR *ServerIpAddress,
    WCHAR * MScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    );

DWORD DHCP_API_FUNCTION
DhcpGetMCastMibInfo(
    DHCP_CONST WCHAR *ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MibInfo
    );

#endif DHCPAPI_NO_PROTOTYPES
#endif _MDHCSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\msgrutil.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgrutil.h

Abstract:

    Header file for the following helper routines found in the msgrutil.c
    module of netlib.

        NetpNetBiosAddName
        NetpNetBiosDelName
        NetpNetBiosGetAdapterNumbers
        NetpNetBiosCall
        NetpNetBiosHangup
        NetpNetBiosReceive
        NetpNetBiosSend
        NetpStringToNetBiosName
        NetpNetBiosStatusToApiStatus

Authors:

    Rita Wong (ritaw) 26-July-1991

Revision History:

--*/

#define MESSAGE_ALIAS_TYPE             0x03
#define WKSTA_TO_MESSAGE_ALIAS_TYPE    0x01

typedef struct _NB30_ADAPTER_STATUS {
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER Names[16];
} NB30_ADAPTER_STATUS, *PNB30_ADAPTER_STATUS;

NET_API_STATUS
NetpNetBiosReset(
    IN  UCHAR LanAdapterNumber
    );

NET_API_STATUS
NetpNetBiosAddName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber,
    OUT PUCHAR NetBiosNameNumber OPTIONAL
    );

NET_API_STATUS
NetpNetBiosDelName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber
    );

NET_API_STATUS
NetpNetBiosGetAdapterNumbers(
    OUT PLANA_ENUM LanAdapterBuffer,
    IN  WORD LanAdapterBufferSize
    );

NET_API_STATUS
NetpNetBiosCall(
    IN  UCHAR LanAdapterNumber,
    IN  LPTSTR NameToCall,
    IN  LPTSTR Sender,
    OUT UCHAR *SessionNumber
    );

NET_API_STATUS
NetpNetBiosHangup(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber
    );

NET_API_STATUS
NetpNetBiosSend(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  PCHAR SendBuffer,
    IN  WORD SendBufferSize
    );

NET_API_STATUS
NetpNetBiosReceive(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    OUT PUCHAR ReceiveBuffer,
    IN  WORD ReceiveBufferSize,
    IN  HANDLE EventHandle,
    OUT WORD *NumberOfBytesReceived
    );

NET_API_STATUS
NetpStringToNetBiosName(
    OUT PCHAR NetBiosName,
    IN  LPTSTR String,
    IN  DWORD CanonicalizeType,
    IN  WORD Type
    );

NET_API_STATUS
NetpNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    );

int
NetpSmbCheck(
    IN LPBYTE  buffer,     // Buffer containing SMB
    IN USHORT  size,       // size of SMB buffer (in bytes)
    IN UCHAR   func,       // Function code
    IN int     parms,      // Parameter count
    IN LPSTR   fields      // Buffer fields dope vector
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\netbios.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netbios.h

Abstract:

    This is the include file for the component of netbios that allows
    the netbios initialization routine to be called during dll
    initialization and destruction.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

BOOLEAN
NetbiosInitialize(
    HMODULE hModule
    );

VOID
NetbiosDelete(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\nameser.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *	 /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *	@(#)nameser.h	5.3
 *
 *	Last delta created	14:06:04 3/4/91
 *	This file extracted	11:19:28 3/8/91
 *
 *	Modifications:
 *
 *		GSS	20 Jul 90	New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)nameser.h	5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ	512		/* maximum packet size */
#define MAXDNAME	256		/* maximum domain name */
#define MAXCDNAME	255		/* maximum compressed domain name */
#define MAXLABEL	63		/* maximum length of domain label */
	/* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ	4
	/* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ	10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT	53

/*
 * Currently defined opcodes
 */
#define QUERY		0x0		/* standard query */
#define IQUERY		0x1		/* inverse query */
#define STATUS		0x2		/* nameserver status query */
/*#define xxx		0x3		/* 0x3 reserved */
	/* non standard */
#define UPDATEA		0x9		/* add resource record */
#define UPDATED		0xa		/* delete a specific resource record */
#define UPDATEDA	0xb		/* delete all nemed resource record */
#define UPDATEM		0xc		/* modify a specific resource record */
#define UPDATEMA	0xd		/* modify all named resource record */

#define ZONEINIT	0xe		/* initial zone transfer */
#define ZONEREF		0xf		/* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR		0		/* no error */
#endif
#define FORMERR		1		/* format error */
#define SERVFAIL	2		/* server failure */
#define NXDOMAIN	3		/* non existent domain */
#define NOTIMP		4		/* not implemented */
#define REFUSED		5		/* query refused */
	/* non standard */
#define NOCHANGE	0xf		/* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A	        1		/* host address */
#define T_NS		2		/* authoritative server */
#define T_MD		3		/* mail destination */
#define T_MF		4		/* mail forwarder */
#define T_CNAME		5		/* connonical name */
#define T_SOA		6		/* start of authority zone */
#define T_MB		7		/* mailbox domain name */
#define T_MG		8		/* mail group member */
#define T_MR		9		/* mail rename name */
#define T_NULL		10		/* null resource record */
#define T_WKS		11		/* well known service */
#define T_PTR		12		/* domain name pointer */
#define T_HINFO		13		/* host information */
#define T_MINFO		14		/* mailbox information */
#define T_MX		15		/* mail routing information */
#define T_TXT		16		/* text strings */
#define T_AFSDB		18		/* AFS database servers */
#define T_ATMA 		34		/* ATM endpoint address */
	/* non standard */
#define T_UINFO		100		/* user (finger) information */
#define T_UID		101		/* user ID */
#define T_GID		102		/* group ID */
#define T_UNSPEC	103		/* Unspecified format (binary data) */
	/* Query type values which do not appear in resource records */
#define T_AXFR		252		/* transfer zone of authority */
#define T_MAILB		253		/* transfer mailbox records */
#define T_MAILA		254		/* transfer mail agent records */
#define T_ANY		255		/* wildcard match */

/*
 * Values for class field
 */

#define C_IN		1		/* the arpa internet */
#define C_CHAOS		3		/* for chaos net at MIT */
#define C_HS		4		/* for Hesiod name server at MIT */
	/* Query class values which do not appear in resource records */
#define C_ANY		255		/* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax) */
#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER	LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#ifndef BYTE_ORDER		/* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_AMD64_) || defined(_IA64_)
#define BYTE_ORDER	LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
	/* you must determine what the correct bit order is for your compiler */
	UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
	unsigned short	id;		/* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
			/* fields in third byte */
	unsigned char	qr:1;		/* response flag */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	rd:1;		/* recursion desired */
			/* fields in fourth byte */
	unsigned char	ra:1;		/* recursion available */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	rcode:4;	/* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
			/* fields in third byte */
	unsigned char	rd:1;		/* recursion desired */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	qr:1;		/* response flag */
			/* fields in fourth byte */
	unsigned char	rcode:4;	/* response code */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	ra:1;		/* recursion available */
#endif
			/* remaining bytes */
	unsigned short	qdcount;	/* number of question entries */
	unsigned short	ancount;	/* number of answer entries */
	unsigned short	nscount;	/* number of authority entries */
	unsigned short	arcount;	/* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK	0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
	short	        r_zone;			/* zone number */
	short	        r_class;		/* class number */
	short	        r_type;			/* type number */
	unsigned long	r_ttl;			/* time to live */
	int	        r_size;			/* size of data area */
	char	       *r_data;		        /* pointer to data */
};

extern	unsigned short	_getshort();
extern	unsigned long	_getlong();

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
	(s) = *(cp)++ << 8; \
	(s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
	(l) = *(cp)++ << 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
	*(cp)++ = (s) >> 8; \
	*(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
	(cp)[3] = l; \
	(cp)[2] = (l >>= 8); \
	(cp)[1] = (l >>= 8); \
	(cp)[0] = l >> 8; \
	(cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\nb30p.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nb30p.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 09-Dec-1991

Revision History:

--*/


#ifndef _NB30P_
#define _NB30P_

#define NB_DEVICE_NAME      L"\\Device\\Netbios" // name of our driver.
#define	NB_REGISTRY_STRING	L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Netbios"
//
//  private IOCTLs used by the Netbios routine in the dll to communicate with
//  \Device\Netbios
//

#define IOCTL_NB_BASE FILE_DEVICE_TRANSPORT

#define _NB_CONTROL_CODE(request, method) \
    CTL_CODE(IOCTL_NB_BASE, request, method, FILE_ANY_ACCESS)

#define IOCTL_NB_NCB            _NB_CONTROL_CODE(20, METHOD_NEITHER)
#define IOCTL_NB_REGISTER_STOP  _NB_CONTROL_CODE(21, METHOD_NEITHER)
#define IOCTL_NB_STOP           _NB_CONTROL_CODE(22, METHOD_NEITHER)
#define IOCTL_NB_REGISTER_RESET _NB_CONTROL_CODE(23, METHOD_BUFFERED)

//
// MessageId: STATUS_HANGUP_REQUIRED
//
// MessageText:
//
//  Warning error for the Netbios driver to the Netbios dll. When receiving this
//  status on an NCB completion, the dll will hangup the connection causing the
//  connection block to be deleted. This status will never be returned to a user
//  application.
//
#define STATUS_HANGUP_REQUIRED           ((NTSTATUS)0x80010001L)

//
//  Private extension for XNS to support vtp.exe
//

#define NCALLNIU            0x74    /* UB special */

//
//  Private extension to support AsyBEUI
//

#define NCBQUICKADDNAME     0x75
#define NCBQUICKADDGRNAME   0x76

//  Values for transport_id in ACTION_HEADER

#define MS_ABF          "MABF"
#define MS_XNS          "MXNS"

#endif // _NB30P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\nbtioctl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nbtioctl.h

Abstract:

    This header file defines constants for issuing IOCTLS to Netbt


Author:

    JSTEW     November 16, 1993

Revision History:

--*/

#include <tdi.h>

#ifndef _NBTIOCTL_
#define _NBTIOCTL_

#define NETBIOS_NAMESIZE 16
#define MAX_IPADDRS_PER_HOST 26

//
// The following definitions are from Dns.c
//
#define DNS_NAME_BUFFER_LENGTH      (256)
#define DNS_MAX_NAME_LENGTH         (255)

//
// Netbt supports this number of adapters
//
#if defined(VXD) || defined(CHICAGO_PRODUCT)
#define NBT_MAXIMUM_BINDINGS    32  // we allow up to 32 net cards in CHICAGO
#else
#define NBT_MAXIMUM_BINDINGS    64  // we allow up to 64 net cards in NT
#endif  // VXD || CHICAGO_PRODUCT

//
// This structure is passed down to netbt on a IOCTL_NETBT_ADAPTER_STATUS
// call.  If the Ipaddress is set to anything other than zero netbt will
// assume it is an ip address and use it rather than try a name resolution
// on the netbios name passed in.
//
typedef struct
{
    ULONG                IpAddress;
    TA_NETBIOS_ADDRESS   NetbiosAddress;

} tIPANDNAMEINFO;

//
// Adapter Status response buffer format for a query of the remote hash
// table.  It is the same as the adapter status format except it includes
// the ip address of each name too. This is used in NBtQueryAdapterStatus
// when responding to nbtstat queries.
//
typedef struct
{
    UCHAR   name[NETBIOS_NAMESIZE];
    UCHAR   name_num;
    UCHAR   name_flags;
    UCHAR   padding;
#ifndef CHICAGO_PRODUCT
    ULONG   IpAddress;      // ip address of remote host
    ULONG   Ttl;            // remaining time in cache
#else
    UCHAR   IpAddress[4];
    UCHAR   Ttl[4];
#endif  // !CHICAGO_PRODUCT
} tREMOTE_CACHE;

// We log the how names are registered and queried
//
#define NAME_QUERY_SUCCESS         0
#define NAME_REGISTRATION_SUCCESS  1
#define NAME_QUERY_FAILURE         2
#define SIZE_RESOLVD_BY_BCAST_CACHE 8

typedef struct
{
    UCHAR   Name[NETBIOS_NAMESIZE];
} tNAME;
typedef struct
{
    ULONG   Stats[4];
    ULONG   Index;
    tNAME   NamesReslvdByBcast[SIZE_RESOLVD_BY_BCAST_CACHE];

} tNAMESTATS_INFO;


typedef struct
{
    USHORT  LanaNumber;
    ULONG   IpAddress;
    ULONG   NameServerAddress;     // primary WINS server
    ULONG   BackupServer;          // backup WINS server
    ULONG   lDnsServerAddress;     // primary DNS server
    ULONG   lDnsBackupServer;      // backup DNS server
} tIPCONFIG_PER_LANA;

//
// structure returned when ipconfig queries vnbt for parameters being used
//
typedef struct
{
    USHORT              NumLanas;
    tIPCONFIG_PER_LANA  LanaInfo[8];
    USHORT              NodeType;
    USHORT              ScopeLength;
    CHAR                szScope[1];
} tIPCONFIG_INFO;

//
// These two structures are used to return the connection list to
// NbtStat
//
typedef struct
{
#ifdef  CHICAGO_PRODUCT
    UCHAR           State[4];
    UCHAR           SrcIpAddr[4];
    CHAR            LocalName[NETBIOS_NAMESIZE];
    CHAR            RemoteName[NETBIOS_NAMESIZE];
    UCHAR           BytesRcvd[4];
    UCHAR           BytesSent[4];
#else
    ULONG           State;
    ULONG           SrcIpAddr;
    CHAR            LocalName[NETBIOS_NAMESIZE];
    CHAR            RemoteName[NETBIOS_NAMESIZE];
    LARGE_INTEGER   BytesRcvd;
    LARGE_INTEGER   BytesSent;
#endif  // CHICAGO_PRODUCT
    UCHAR           Originator; // True if originated on this node
} tCONNECTIONS;

typedef struct
{
    ULONG           ConnectionCount;
    tCONNECTIONS    ConnList[1];
} tCONNECTION_LIST;


typedef struct
{
    ULONG   IpAddress;
    ULONG   Resolved;
    UCHAR   Name[16];

} tIPADDR_BUFFER;

// this is the format of the buffer passed to Netbt when it either posts
// a buffer for subsequent DNS name resolutions, or it replies to a name
// resolution request. For a posted buffer, Name starts with a null, otherwise
// name is the name that was resolved. Resolved is set to true if the name
// resolved.
//
typedef struct
{
    union {
        WCHAR   pwName[DNS_NAME_BUFFER_LENGTH];     // Support for UNICODE
        CHAR    pName[DNS_NAME_BUFFER_LENGTH];     // Support for UNICODE
    };
    ULONG   NameLen;                            // how big is the name
    ULONG   bUnicode;
    ULONG   Resolved;
    ULONG   IpAddrsList[MAX_IPADDRS_PER_HOST+1];
} tIPADDR_BUFFER_DNS;

//
// this is the format of the buffer passed to Nbt by DHCP when DHCP
// changes the Ip Address
//
typedef struct
{
    ULONG   IpAddress;
    ULONG   SubnetMask;

} tNEW_IP_ADDRESS;

//
// this is the format of the buffer passed to Nbt by the RDR when
// it wants to know the Wins IP addresses for a given network adapter
// card.
//
typedef struct
{
    ULONG   PrimaryWinsServer;
    ULONG   BackupWinsServer;
} tWINS_ADDRESSES;

typedef ULONG   tIPADDRESS;
#define MAX_NUM_OTHER_NAME_SERVERS   10 // # of Backup Name Server entries to keep in cache

typedef struct
{
    union
    {
        tIPADDRESS      AllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  NameServerAddress;
            tIPADDRESS  BackupServer;
            tIPADDRESS  Others[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };
    USHORT  NumOtherServers;
    USHORT  LastResponsive;
    ULONG   NodeType;
    BOOLEAN NetbiosEnabled;
}tWINS_NODE_INFO;


//
// This structure is returned by Nbt when a TdiQueryInformation()
// call asks for TDI_QUERY_ADDRESS_INFO on a connection.  This is
// the same as a TRANSPORT_ADDRESS struct from "tdi.h" containing
// two address, a NetBIOS address followed by an IP address.
//

typedef struct _NBT_ADDRESS_PAIR {
    LONG TAAddressCount;                   // this will always == 2

    struct {
        USHORT AddressLength;              // length in bytes of this address == 18
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_NETBIOS
        TDI_ADDRESS_NETBIOS Address;
    } AddressNetBIOS;

    struct {
        USHORT AddressLength;              // length in bytes of this address == 14
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_IP
        union {
            TDI_ADDRESS_IP Address;
            TDI_ADDRESS_IP6 AddressIp6;
        };
    } AddressIP;

} NBT_ADDRESS_PAIR, *PNBT_ADDRESS_PAIR;

typedef struct _NBT_ADDRESS_PAIR_INFO {
    ULONG ActivityCount;                   // outstanding open file objects/this address.
    NBT_ADDRESS_PAIR AddressPair;          // the actual address & its components.
} NBT_ADDRESS_PAIR_INFO, *PNBT_ADDRESS_PAIR_INFO;


#define WINS_INTERFACE_NAME "WinsInterface"
//
// This is the format of the remote address structure on the front of
// datagram rcvs passed up to WINS
//
typedef struct
{
    SHORT       Family;
    USHORT      Port;
    ULONG       IpAddress;
    ULONG       LengthOfBuffer;

} tREM_ADDRESS;


#define     MAX_NAME    650        // arbitrary!

typedef struct _NETBT_ADAPTER_INDEX_MAP
{
    ULONG   Index;
#if defined(VXD) || defined(CHICAGO_PRODUCT)
    ULONG   LanaNumber;
#else
    WCHAR   Name[MAX_NAME];
#endif
}NETBT_ADAPTER_INDEX_MAP, *PNETBT_ADAPTER_INDEX_MAP;

typedef struct _NETBT_INTERFACE_INFO
{
     LONG                       NumAdapters;
     NETBT_ADAPTER_INDEX_MAP    Adapter[1];
} NETBT_INTERFACE_INFO,*PNETBT_INTERFACE_INFO;


//
// Bind request type as requested by Rdr/Srv
//
enum eNbtBindRequestor
{
    SMB_SERVER,
    SMB_CLIENT
};

#if !defined(VXD) && !defined(CHICAGO_PRODUCT)
typedef struct _NETBT_SMB_BIND_REQUEST
{
    ULONG           RequestType;            // Set as SMB_SERVER_BINDING_.... from above
    ULONG           PnPOpCode;
    PUNICODE_STRING pDeviceName;
    PWSTR           MultiSZBindList;
}NETBT_SMB_BIND_REQUEST, *PNETBT_SMB_BIND_REQUEST;
#endif  // !VXD && !CHICAGO_PRODUCT


//
// Wins and Netbt share the transaction id space, where WINS uses the lower
// half
//
#define WINS_MAXIMUM_TRANSACTION_ID 0x7FFF

// this is equivalent to AF_INET - WINS depends on this to determine kind of
// address the source node has.
//
#define NBT_UNIX    1
#define NBT_INET    2
#define WINS_EXPORT       TEXT("Export")
#define NETBT_LINKAGE_KEY TEXT("system\\currentcontrolset\\services\\netbt\\linkage")

typedef struct _tWINS_SET_INFO
{
    ULONG           IpAddress;
}tWINS_SET_INFO;

// defines for CHICAGO_PRODUCT
#if defined(VXD) || defined(CHICAGO_PRODUCT)

#define NBT_VERIFY_VXD_IOCTL    0x33333333
typedef struct {
    ULONG   Signature;
    ULONG   LanaNumber;

    CHAR    UserData[1];
} tNBT_IOCTL_HEADER;


#define IOCTL_NETBT_PURGE_CACHE                 101
#define IOCTL_NETBT_GET_BCAST_NAMES             102
#define IOCTL_NETBT_GET_CONNECTIONS             103
#define IOCTL_NETBT_GET_LOCAL_NAMES             104
#define IOCTL_NETBT_GET_REMOTE_NAMES            105
#define IOCTL_NETBT_REREAD_REGISTRY             106
#define IOCTL_NETBT_NEW_IPADDRESS               107
#define IOCTL_NETBT_DNS_NAME_RESOLVE            108
#define IOCTL_NETBT_FIND_NAME                   109
#define IOCTL_NETBT_GET_WINS_ADDR               110
#define IOCTL_NETBT_WINS_SEND                   111
#define IOCTL_NETBT_WINS_RCV                    112
#define IOCTL_NETBT_GET_IP_ADDRS                113
#define IOCTL_NETBT_GET_IP_SUBNET               114
#define IOCTL_NETBT_ADAPTER_STATUS              115
#define IOCTL_NETBT_IPCONFIG_INFO               116
#define IOCTL_NETBT_NAME_RELEASE_REFRESH        117
#define IOCTL_NETBT_ADD_TO_REMOTE_TABLE         118
#define IOCTL_NETBT_GET_INTERFACE_INFO          119
#define IOCTL_NETBT_SET_TCP_CONNECTION_INFO     120
#define IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE    121
#define IOCTL_NETBT_LAST_IOCTL                  200

#else

// defines for NT

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
#define _NETBT_CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_TRANSPORT, function, method, access)


#define IOCTL_NETBT_PURGE_CACHE     _NETBT_CTRL_CODE( 30, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_BCAST_NAMES _NETBT_CTRL_CODE( 31, METHOD_OUT_DIRECT,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_CONNECTIONS _NETBT_CTRL_CODE( 32, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_REMOTE_NAMES _NETBT_CTRL_CODE( 33, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_REREAD_REGISTRY  _NETBT_CTRL_CODE( 34, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_NEW_IPADDRESS    _NETBT_CTRL_CODE( 35, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_DNS_NAME_RESOLVE _NETBT_CTRL_CODE( 36, METHOD_OUT_DIRECT,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_FIND_NAME        _NETBT_CTRL_CODE( 37, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_WINS_ADDR    _NETBT_CTRL_CODE( 38, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_WINS_SEND        _NETBT_CTRL_CODE( 39, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_WINS_RCV         _NETBT_CTRL_CODE( 40, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_GET_IP_ADDRS     _NETBT_CTRL_CODE( 41, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_IP_SUBNET     _NETBT_CTRL_CODE( 42, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_ADAPTER_STATUS    _NETBT_CTRL_CODE( 43, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_CHECK_IP_ADDR    _NETBT_CTRL_CODE( 44, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_ADD_INTERFACE   _NETBT_CTRL_CODE( 45, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_DELETE_INTERFACE _NETBT_CTRL_CODE( 46, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_QUERY_INTERFACE_INSTANCE _NETBT_CTRL_CODE( 47, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_SET_WINS_ADDRESS _NETBT_CTRL_CODE( 48, METHOD_BUFFERED,\
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_ENABLE_EXTENDED_ADDR _NETBT_CTRL_CODE( 49, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_DISABLE_EXTENDED_ADDR _NETBT_CTRL_CODE( 50, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_NAME_RELEASE_REFRESH _NETBT_CTRL_CODE( 51, METHOD_BUFFERED,\
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_ADD_TO_REMOTE_TABLE _NETBT_CTRL_CODE( 52, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_GET_INTERFACE_INFO _NETBT_CTRL_CODE( 53, METHOD_OUT_DIRECT, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_SET_TCP_CONNECTION_INFO _NETBT_CTRL_CODE( 54, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO _NETBT_CTRL_CODE( 55, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE _NETBT_CTRL_CODE( 56, METHOD_BUFFERED, \
                                                        FILE_ANY_ACCESS)
#define IOCTL_NETBT_WINS_SET_INFO _NETBT_CTRL_CODE( 57, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_NETBT_ENABLE_DISABLE_NETBIOS_SMB _NETBT_CTRL_CODE( 58, METHOD_BUFFERED, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// This ioctl should be last since Driver.c uses this to decide the range of
// ioctls to pass to DispatchIoctls
//
#define IOCTL_NETBT_LAST_IOCTL       _NETBT_CTRL_CODE( 59, METHOD_OUT_DIRECT, \
                                                        FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define NETBT_DISABLE_NETBIOS_SMB       0
#define NETBT_ENABLE_NETBIOS_SMB        1
#define NETBT_RESTORE_NETBIOS_SMB       2

//
// Used in IOCTL_NETBT_ADD_INTERFACE and IOCTL_NETBT_DELETE_INTERFACE
//
typedef struct  _netbt_add_del_if {
    NTSTATUS   Status;
    ULONG   InstanceNumber; // instance number of this device
    ULONG   Length; // length of the buffer
    WCHAR   IfName[1]; // actual data
} NETBT_ADD_DEL_IF, *PNETBT_ADD_DEL_IF;

//
// Used in IOCTL_NETBT_SET_WINS_ADDRESS
//
typedef struct  _netbt_set_wins_addr {
    ULONG   PrimaryWinsAddr;
    ULONG   SecondaryWinsAddr;
    NTSTATUS   Status;
} NETBT_SET_WINS_ADDR, *PNETBT_SET_WINS_ADDR;

#endif  // VXD || CHICAGO_PRODUCT

#endif  // ifndef _NBTIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ndispnp.h ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  Module Name:
 *      ndispnp.h
 *
 *  Abstract:
 *      Include file for PnP message apis to NDIS.
 *
 *  Environment:
 *      These routines are statically linked in the caller's executable and are callable in user mode.
 */

#ifndef _NDISPNP_
#define _NDISPNP_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(push)
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4514)
#endif
#if (_MSC_VER >= 1020)
#pragma once
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Definitions for Layer
//
#define NDIS            0x01
#define TDI             0x02

//
// Definitions for Operation
//
#define BIND                0x01
#define UNBIND              0x02
#define RECONFIGURE         0x03
#define UNBIND_FORCE        0x04
#define UNLOAD              0x05
#define REMOVE_DEVICE       0x06    // This is a notification that a device is about to be removed.
#define ADD_IGNORE_BINDING  0x07
#define DEL_IGNORE_BINDING  0x08
#define BIND_LIST           0x09    // this is a notification that a protocol's bind list has changed

//
// Return code from this api is to be treated as a BOOL. Link with ndispnp.lib for this.
//
extern
UINT
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent,
    IN  PUNICODE_STRING UpperComponent,
    IN  PUNICODE_STRING BindList,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    );

#define MEDIA_STATE_CONNECTED       1
#define MEDIA_STATE_DISCONNECTED    0
#define MEDIA_STATE_UNKNOWN         -1

#define DEVICE_STATE_CONNECTED      1
#define DEVICE_STATE_DISCONNECTED   0

typedef struct
{
    ULONG               Size;               // Of this structure
    ULONG               DeviceState;        // DEVICE_STATE_XXX above
    ULONG               MediaType;          // NdisMediumXXX
    ULONG               MediaState;      // MEDIA_STATE_XXX above
    ULONG               PhysicalMediaType;
    ULONG               LinkSpeed;          // In 100bits/s. 10Mb/s = 100000
    ULONGLONG           PacketsSent;
    ULONGLONG           PacketsReceived;
    ULONG               InitTime;           // In milliseconds
    ULONG               ConnectTime;        // In seconds
    ULONGLONG           BytesSent;          // 0 - Unknown (or not supported)
    ULONGLONG           BytesReceived;      // 0 - Unknown (or not supported)
    ULONGLONG           DirectedBytesReceived;
    ULONGLONG           DirectedPacketsReceived;
    ULONG               PacketsReceiveErrors;
    ULONG               PacketsSendErrors;
    ULONG               ResetCount;
    ULONG               MediaSenseConnectCount;
    ULONG               MediaSenseDisconnectCount;

} NIC_STATISTICS, *PNIC_STATISTICS;

extern
UINT
NdisQueryHwAddress(
    IN  PUNICODE_STRING DeviceGUID,         // Device name of the form "\Device\{GUID}
    OUT PUCHAR          CurrentAddress,     // Has space for HW address
    OUT PUCHAR          PermanentAddress,   // Has space for HW address
    OUT PUCHAR          VendorId            // Has space for Vendor Id
    );

extern
UINT
NdisQueryStatistics(
    IN  PUNICODE_STRING   DeviceGUID,      // Device name of the form "\Device\{GUID}
    OUT PNIC_STATISTICS   Statistics
    );

typedef struct _NDIS_INTERFACE
{
    UNICODE_STRING      DeviceName;
    UNICODE_STRING      DeviceDescription;
} NDIS_INTERFACE, *PNDIS_INTERFACE;

typedef struct _NDIS_ENUM_INTF
{
    UINT                TotalInterfaces;        // in Interface array below
    UINT                AvailableInterfaces;    // >= TotalInterfaces
    UINT                BytesNeeded;            // for all available interfaces
    UINT                Reserved;
    NDIS_INTERFACE      Interface[1];
} NDIS_ENUM_INTF, *PNDIS_ENUM_INTF;

extern
UINT
NdisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF Interfaces,
    IN  UINT            Size
    );

typedef enum
{
    BundlePrimary,
    BundleSecondary
} BUNDLE_TYPE;

typedef struct _DEVICE_BUNDLE_ENRTY
{
    UNICODE_STRING Name;
    BUNDLE_TYPE    Type;
} DEVICE_BUNDLE_ENRTY, *PDEVICE_BUNDLE_ENRTY;

typedef struct _DEVICE_BUNDLE
{
    UINT                TotalEntries;
    UINT                AvailableEntries;
    DEVICE_BUNDLE_ENRTY Entries[1];
} DEVICE_BUNDLE, *PDEVICE_BUNDLE;

extern
UINT
NdisQueryDeviceBundle(
    IN  PUNICODE_STRING DeviceGUID,      // Device name of the form "\Device\{GUID}
    OUT PDEVICE_BUNDLE  BundleBuffer,
    IN  UINT            BufferSize
    );

#define POINTER_TO_OFFSET(val, start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) - (ULONG_PTR)(start) )

#define OFFSET_TO_POINTER(val, start)               \
    (val) = ((val) == NULL) ? NULL : (PVOID)( (PCHAR)(val) + (ULONG_PTR)(start) )

#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#pragma warning(pop)
#endif

#endif  // _NDISPNP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\netcfgp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for netcfgp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcfgp_h__
#define __netcfgp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IIpxAdapterInfo_FWD_DEFINED__
#define __IIpxAdapterInfo_FWD_DEFINED__
typedef interface IIpxAdapterInfo IIpxAdapterInfo;
#endif 	/* __IIpxAdapterInfo_FWD_DEFINED__ */


#ifndef __ITcpipProperties_FWD_DEFINED__
#define __ITcpipProperties_FWD_DEFINED__
typedef interface ITcpipProperties ITcpipProperties;
#endif 	/* __ITcpipProperties_FWD_DEFINED__ */


#ifndef __INetCfgInternalSetup_FWD_DEFINED__
#define __INetCfgInternalSetup_FWD_DEFINED__
typedef interface INetCfgInternalSetup INetCfgInternalSetup;
#endif 	/* __INetCfgInternalSetup_FWD_DEFINED__ */


#ifndef __INetCfgComponentPrivate_FWD_DEFINED__
#define __INetCfgComponentPrivate_FWD_DEFINED__
typedef interface INetCfgComponentPrivate INetCfgComponentPrivate;
#endif 	/* __INetCfgComponentPrivate_FWD_DEFINED__ */


#ifndef __INetInstallQueue_FWD_DEFINED__
#define __INetInstallQueue_FWD_DEFINED__
typedef interface INetInstallQueue INetInstallQueue;
#endif 	/* __INetInstallQueue_FWD_DEFINED__ */


#ifndef __INetCfgSpecialCase_FWD_DEFINED__
#define __INetCfgSpecialCase_FWD_DEFINED__
typedef interface INetCfgSpecialCase INetCfgSpecialCase;
#endif 	/* __INetCfgSpecialCase_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netcfgp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif
STDAPI
SvchostChangeSvchostGroup (
    LPCWSTR pszService,
    LPCWSTR pszNewGroup
    );








extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_s_ifspec;

#ifndef __IIpxAdapterInfo_INTERFACE_DEFINED__
#define __IIpxAdapterInfo_INTERFACE_DEFINED__

/* interface IIpxAdapterInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIpxAdapterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133270-4B20-11D1-AB01-00805FC1270E")
    IIpxAdapterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameTypesForAdapter( 
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD *anFrameTypes,
            /* [ref][out] */ DWORD *pcFrameTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualNetworkNumber( 
            /* [out] */ DWORD *pdwVNetworkNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualNetworkNumber( 
            /* [in] */ DWORD dwVNetworkNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIpxAdapterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIpxAdapterInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIpxAdapterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIpxAdapterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameTypesForAdapter )( 
            IIpxAdapterInfo * This,
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD *anFrameTypes,
            /* [ref][out] */ DWORD *pcFrameTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualNetworkNumber )( 
            IIpxAdapterInfo * This,
            /* [out] */ DWORD *pdwVNetworkNumber);
        
        HRESULT ( STDMETHODCALLTYPE *SetVirtualNetworkNumber )( 
            IIpxAdapterInfo * This,
            /* [in] */ DWORD dwVNetworkNumber);
        
        END_INTERFACE
    } IIpxAdapterInfoVtbl;

    interface IIpxAdapterInfo
    {
        CONST_VTBL struct IIpxAdapterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIpxAdapterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIpxAdapterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIpxAdapterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIpxAdapterInfo_GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)	\
    (This)->lpVtbl -> GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)

#define IIpxAdapterInfo_GetVirtualNetworkNumber(This,pdwVNetworkNumber)	\
    (This)->lpVtbl -> GetVirtualNetworkNumber(This,pdwVNetworkNumber)

#define IIpxAdapterInfo_SetVirtualNetworkNumber(This,dwVNetworkNumber)	\
    (This)->lpVtbl -> SetVirtualNetworkNumber(This,dwVNetworkNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetFrameTypesForAdapter_Proxy( 
    IIpxAdapterInfo * This,
    /* [string][in] */ LPCWSTR pszwAdapterBindName,
    /* [in] */ DWORD cFrameTypesMax,
    /* [length_is][size_is][out] */ DWORD *anFrameTypes,
    /* [ref][out] */ DWORD *pcFrameTypes);


void __RPC_STUB IIpxAdapterInfo_GetFrameTypesForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo * This,
    /* [out] */ DWORD *pdwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_GetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_SetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo * This,
    /* [in] */ DWORD dwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_SetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIpxAdapterInfo_INTERFACE_DEFINED__ */


#ifndef __ITcpipProperties_INTERFACE_DEFINED__
#define __ITcpipProperties_INTERFACE_DEFINED__

/* interface ITcpipProperties */
/* [unique][uuid][object][local] */ 

typedef struct tagREMOTE_IPINFO
    {
    DWORD dwEnableDhcp;
    WCHAR *pszwIpAddrList;
    WCHAR *pszwSubnetMaskList;
    WCHAR *pszwOptionList;
    } 	REMOTE_IPINFO;


EXTERN_C const IID IID_ITcpipProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133271-4B20-11D1-AB01-00805FC1270E")
    ITcpipProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIpInfoForAdapter( 
            /* [in] */ const GUID *pguidAdapter,
            /* [out] */ REMOTE_IPINFO **ppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIpInfoForAdapter( 
            /* [in] */ const GUID *pguidAdapter,
            /* [in] */ REMOTE_IPINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITcpipPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITcpipProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITcpipProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITcpipProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIpInfoForAdapter )( 
            ITcpipProperties * This,
            /* [in] */ const GUID *pguidAdapter,
            /* [out] */ REMOTE_IPINFO **ppInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetIpInfoForAdapter )( 
            ITcpipProperties * This,
            /* [in] */ const GUID *pguidAdapter,
            /* [in] */ REMOTE_IPINFO *pInfo);
        
        END_INTERFACE
    } ITcpipPropertiesVtbl;

    interface ITcpipProperties
    {
        CONST_VTBL struct ITcpipPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITcpipProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITcpipProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITcpipProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITcpipProperties_GetIpInfoForAdapter(This,pguidAdapter,ppInfo)	\
    (This)->lpVtbl -> GetIpInfoForAdapter(This,pguidAdapter,ppInfo)

#define ITcpipProperties_SetIpInfoForAdapter(This,pguidAdapter,pInfo)	\
    (This)->lpVtbl -> SetIpInfoForAdapter(This,pguidAdapter,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITcpipProperties_GetIpInfoForAdapter_Proxy( 
    ITcpipProperties * This,
    /* [in] */ const GUID *pguidAdapter,
    /* [out] */ REMOTE_IPINFO **ppInfo);


void __RPC_STUB ITcpipProperties_GetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITcpipProperties_SetIpInfoForAdapter_Proxy( 
    ITcpipProperties * This,
    /* [in] */ const GUID *pguidAdapter,
    /* [in] */ REMOTE_IPINFO *pInfo);


void __RPC_STUB ITcpipProperties_SetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITcpipProperties_INTERFACE_DEFINED__ */


#ifndef __INetCfgInternalSetup_INTERFACE_DEFINED__
#define __INetCfgInternalSetup_INTERFACE_DEFINED__

/* interface INetCfgInternalSetup */
/* [unique][uuid][object][local] */ 

typedef 
enum tagCI_FILTER_COMPONENT
    {	FC_LAN	= 0,
	FC_RASSRV	= FC_LAN + 1,
	FC_RASCLI	= FC_RASSRV + 1,
	FC_ATM	= FC_RASCLI + 1
    } 	CI_FILTER_COMPONENT;

typedef struct tagCI_FILTER_INFO
    {
    CI_FILTER_COMPONENT eFilter;
    INetCfgComponent *pIComp;
    void *pvReserved;
    } 	CI_FILTER_INFO;


EXTERN_C const IID IID_INetCfgInternalSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133276-4B20-11D1-AB01-00805FC1270E")
    INetCfgInternalSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectWithFilterAndInstall( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID *pClassGuid,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ const CI_FILTER_INFO *pcfi,
            /* [out] */ INetCfgComponent **ppIComp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentInstalled( 
            /* [in] */ PVOID pComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentUpdated( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateNonEnumeratedComponent( 
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentRemoved( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgInternalSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgInternalSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgInternalSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginBatchOperation )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CommitBatchOperation )( 
            INetCfgInternalSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectWithFilterAndInstall )( 
            INetCfgInternalSetup * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID *pClassGuid,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ const CI_FILTER_INFO *pcfi,
            /* [out] */ INetCfgComponent **ppIComp);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentInstalled )( 
            INetCfgInternalSetup * This,
            /* [in] */ PVOID pComponent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentUpdated )( 
            INetCfgInternalSetup * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateNonEnumeratedComponent )( 
            INetCfgInternalSetup * This,
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratedComponentRemoved )( 
            INetCfgInternalSetup * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        END_INTERFACE
    } INetCfgInternalSetupVtbl;

    interface INetCfgInternalSetup
    {
        CONST_VTBL struct INetCfgInternalSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgInternalSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgInternalSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgInternalSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgInternalSetup_BeginBatchOperation(This)	\
    (This)->lpVtbl -> BeginBatchOperation(This)

#define INetCfgInternalSetup_CommitBatchOperation(This)	\
    (This)->lpVtbl -> CommitBatchOperation(This)

#define INetCfgInternalSetup_SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)	\
    (This)->lpVtbl -> SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)

#define INetCfgInternalSetup_EnumeratedComponentInstalled(This,pComponent)	\
    (This)->lpVtbl -> EnumeratedComponentInstalled(This,pComponent)

#define INetCfgInternalSetup_EnumeratedComponentUpdated(This,pszPnpId)	\
    (This)->lpVtbl -> EnumeratedComponentUpdated(This,pszPnpId)

#define INetCfgInternalSetup_UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)	\
    (This)->lpVtbl -> UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)

#define INetCfgInternalSetup_EnumeratedComponentRemoved(This,pszPnpId)	\
    (This)->lpVtbl -> EnumeratedComponentRemoved(This,pszPnpId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_BeginBatchOperation_Proxy( 
    INetCfgInternalSetup * This);


void __RPC_STUB INetCfgInternalSetup_BeginBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_CommitBatchOperation_Proxy( 
    INetCfgInternalSetup * This);


void __RPC_STUB INetCfgInternalSetup_CommitBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_SelectWithFilterAndInstall_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const GUID *pClassGuid,
    /* [in] */ OBO_TOKEN *pOboToken,
    /* [in] */ const CI_FILTER_INFO *pcfi,
    /* [out] */ INetCfgComponent **ppIComp);


void __RPC_STUB INetCfgInternalSetup_SelectWithFilterAndInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentInstalled_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ PVOID pComponent);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentUpdated_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_UpdateNonEnumeratedComponent_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ INetCfgComponent *pIComp,
    /* [in] */ DWORD dwSetupFlags,
    /* [in] */ DWORD dwUpgradeFromBuildNo);


void __RPC_STUB INetCfgInternalSetup_UpdateNonEnumeratedComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentRemoved_Proxy( 
    INetCfgInternalSetup * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgInternalSetup_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentPrivate_INTERFACE_DEFINED__
#define __INetCfgComponentPrivate_INTERFACE_DEFINED__

/* interface INetCfgComponentPrivate */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133273-4B20-11D1-AB01-00805FC1270E")
    INetCfgComponentPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNotifyObject( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyUpperEdgeConfigChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNotifyObject )( 
            INetCfgComponentPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirty )( 
            INetCfgComponentPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyUpperEdgeConfigChange )( 
            INetCfgComponentPrivate * This);
        
        END_INTERFACE
    } INetCfgComponentPrivateVtbl;

    interface INetCfgComponentPrivate
    {
        CONST_VTBL struct INetCfgComponentPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentPrivate_QueryNotifyObject(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryNotifyObject(This,riid,ppvObject)

#define INetCfgComponentPrivate_SetDirty(This)	\
    (This)->lpVtbl -> SetDirty(This)

#define INetCfgComponentPrivate_NotifyUpperEdgeConfigChange(This)	\
    (This)->lpVtbl -> NotifyUpperEdgeConfigChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_QueryNotifyObject_Proxy( 
    INetCfgComponentPrivate * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB INetCfgComponentPrivate_QueryNotifyObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_SetDirty_Proxy( 
    INetCfgComponentPrivate * This);


void __RPC_STUB INetCfgComponentPrivate_SetDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Proxy( 
    INetCfgComponentPrivate * This);


void __RPC_STUB INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentPrivate_INTERFACE_DEFINED__ */


#ifndef __INetInstallQueue_INTERFACE_DEFINED__
#define __INetInstallQueue_INTERFACE_DEFINED__

/* interface INetInstallQueue */
/* [unique][uuid][object] */ 

typedef 
enum tagNC_INSTALL_TYPE
    {	NCI_INSTALL	= 0,
	NCI_UPDATE	= NCI_INSTALL + 1,
	NCI_REMOVE	= NCI_UPDATE + 1
    } 	NC_INSTALL_TYPE;

typedef struct NIQ_INFO
    {
    NC_INSTALL_TYPE eType;
    GUID ClassGuid;
    GUID InstanceGuid;
    DWORD dwCharacter;
    LPCWSTR pszPnpId;
    LPCWSTR pszInfId;
    DWORD dwDeipFlags;
    } 	NIQ_INFO;


EXTERN_C const IID IID_INetInstallQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133274-4B20-11D1-AB01-00805FC1270E")
    INetInstallQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ const NIQ_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessItems( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetInstallQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetInstallQueue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetInstallQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetInstallQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            INetInstallQueue * This,
            /* [in] */ const NIQ_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessItems )( 
            INetInstallQueue * This);
        
        END_INTERFACE
    } INetInstallQueueVtbl;

    interface INetInstallQueue
    {
        CONST_VTBL struct INetInstallQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetInstallQueue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetInstallQueue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetInstallQueue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetInstallQueue_AddItem(This,pInfo)	\
    (This)->lpVtbl -> AddItem(This,pInfo)

#define INetInstallQueue_ProcessItems(This)	\
    (This)->lpVtbl -> ProcessItems(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetInstallQueue_AddItem_Proxy( 
    INetInstallQueue * This,
    /* [in] */ const NIQ_INFO *pInfo);


void __RPC_STUB INetInstallQueue_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetInstallQueue_ProcessItems_Proxy( 
    INetInstallQueue * This);


void __RPC_STUB INetInstallQueue_ProcessItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetInstallQueue_INTERFACE_DEFINED__ */


#ifndef __INetCfgSpecialCase_INTERFACE_DEFINED__
#define __INetCfgSpecialCase_INTERFACE_DEFINED__

/* interface INetCfgSpecialCase */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgSpecialCase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE95-306E-11D1-AACF-00805FC1270E")
    INetCfgSpecialCase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapterOrder( 
            /* [out] */ DWORD *pcAdapters,
            /* [out] */ INetCfgComponent ***papAdapters,
            /* [out] */ BOOL *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdapterOrder( 
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent **apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWanAdaptersFirst( 
            /* [out] */ BOOL *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWanAdaptersFirst( 
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgSpecialCaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgSpecialCase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgSpecialCase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgSpecialCase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapterOrder )( 
            INetCfgSpecialCase * This,
            /* [out] */ DWORD *pcAdapters,
            /* [out] */ INetCfgComponent ***papAdapters,
            /* [out] */ BOOL *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdapterOrder )( 
            INetCfgSpecialCase * This,
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent **apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *GetWanAdaptersFirst )( 
            INetCfgSpecialCase * This,
            /* [out] */ BOOL *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE *SetWanAdaptersFirst )( 
            INetCfgSpecialCase * This,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        END_INTERFACE
    } INetCfgSpecialCaseVtbl;

    interface INetCfgSpecialCase
    {
        CONST_VTBL struct INetCfgSpecialCaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgSpecialCase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgSpecialCase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgSpecialCase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgSpecialCase_GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)	\
    (This)->lpVtbl -> GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)	\
    (This)->lpVtbl -> SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)

#define INetCfgSpecialCase_GetWanAdaptersFirst(This,pfWanAdaptersFirst)	\
    (This)->lpVtbl -> GetWanAdaptersFirst(This,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetWanAdaptersFirst(This,fWanAdaptersFirst)	\
    (This)->lpVtbl -> SetWanAdaptersFirst(This,fWanAdaptersFirst)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetAdapterOrder_Proxy( 
    INetCfgSpecialCase * This,
    /* [out] */ DWORD *pcAdapters,
    /* [out] */ INetCfgComponent ***papAdapters,
    /* [out] */ BOOL *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetAdapterOrder_Proxy( 
    INetCfgSpecialCase * This,
    /* [in] */ DWORD cAdapters,
    /* [in] */ INetCfgComponent **apAdapters,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase * This,
    /* [out] */ BOOL *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase * This,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgSpecialCase_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\netconp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for netconp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netconp_h__
#define __netconp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetConnectionUiLock_FWD_DEFINED__
#define __INetConnectionUiLock_FWD_DEFINED__
typedef interface INetConnectionUiLock INetConnectionUiLock;
#endif 	/* __INetConnectionUiLock_FWD_DEFINED__ */


#ifndef __INetConnectionWizardUi_FWD_DEFINED__
#define __INetConnectionWizardUi_FWD_DEFINED__
typedef interface INetConnectionWizardUi INetConnectionWizardUi;
#endif 	/* __INetConnectionWizardUi_FWD_DEFINED__ */


#ifndef __INetConnectionWizardUiContext_FWD_DEFINED__
#define __INetConnectionWizardUiContext_FWD_DEFINED__
typedef interface INetConnectionWizardUiContext INetConnectionWizardUiContext;
#endif 	/* __INetConnectionWizardUiContext_FWD_DEFINED__ */


#ifndef __INetInboundConnection_FWD_DEFINED__
#define __INetInboundConnection_FWD_DEFINED__
typedef interface INetInboundConnection INetInboundConnection;
#endif 	/* __INetInboundConnection_FWD_DEFINED__ */


#ifndef __INetLanConnection_FWD_DEFINED__
#define __INetLanConnection_FWD_DEFINED__
typedef interface INetLanConnection INetLanConnection;
#endif 	/* __INetLanConnection_FWD_DEFINED__ */


#ifndef __INetSharedAccessConnection_FWD_DEFINED__
#define __INetSharedAccessConnection_FWD_DEFINED__
typedef interface INetSharedAccessConnection INetSharedAccessConnection;
#endif 	/* __INetSharedAccessConnection_FWD_DEFINED__ */


#ifndef __INetLanConnectionWizardUi_FWD_DEFINED__
#define __INetLanConnectionWizardUi_FWD_DEFINED__
typedef interface INetLanConnectionWizardUi INetLanConnectionWizardUi;
#endif 	/* __INetLanConnectionWizardUi_FWD_DEFINED__ */


#ifndef __INetRasConnection_FWD_DEFINED__
#define __INetRasConnection_FWD_DEFINED__
typedef interface INetRasConnection INetRasConnection;
#endif 	/* __INetRasConnection_FWD_DEFINED__ */


#ifndef __INetDefaultConnection_FWD_DEFINED__
#define __INetDefaultConnection_FWD_DEFINED__
typedef interface INetDefaultConnection INetDefaultConnection;
#endif 	/* __INetDefaultConnection_FWD_DEFINED__ */


#ifndef __INetRasConnectionIpUiInfo_FWD_DEFINED__
#define __INetRasConnectionIpUiInfo_FWD_DEFINED__
typedef interface INetRasConnectionIpUiInfo INetRasConnectionIpUiInfo;
#endif 	/* __INetRasConnectionIpUiInfo_FWD_DEFINED__ */


#ifndef __IPersistNetConnection_FWD_DEFINED__
#define __IPersistNetConnection_FWD_DEFINED__
typedef interface IPersistNetConnection IPersistNetConnection;
#endif 	/* __IPersistNetConnection_FWD_DEFINED__ */


#ifndef __INetConnectionBrandingInfo_FWD_DEFINED__
#define __INetConnectionBrandingInfo_FWD_DEFINED__
typedef interface INetConnectionBrandingInfo INetConnectionBrandingInfo;
#endif 	/* __INetConnectionBrandingInfo_FWD_DEFINED__ */


#ifndef __INetConnectionManager2_FWD_DEFINED__
#define __INetConnectionManager2_FWD_DEFINED__
typedef interface INetConnectionManager2 INetConnectionManager2;
#endif 	/* __INetConnectionManager2_FWD_DEFINED__ */


#ifndef __INetConnection2_FWD_DEFINED__
#define __INetConnection2_FWD_DEFINED__
typedef interface INetConnection2 INetConnection2;
#endif 	/* __INetConnection2_FWD_DEFINED__ */


#ifndef __INetConnectionNotifySink_FWD_DEFINED__
#define __INetConnectionNotifySink_FWD_DEFINED__
typedef interface INetConnectionNotifySink INetConnectionNotifySink;
#endif 	/* __INetConnectionNotifySink_FWD_DEFINED__ */


#ifndef __INetConnectionUiUtilities_FWD_DEFINED__
#define __INetConnectionUiUtilities_FWD_DEFINED__
typedef interface INetConnectionUiUtilities INetConnectionUiUtilities;
#endif 	/* __INetConnectionUiUtilities_FWD_DEFINED__ */


#ifndef __INetConnectionRefresh_FWD_DEFINED__
#define __INetConnectionRefresh_FWD_DEFINED__
typedef interface INetConnectionRefresh INetConnectionRefresh;
#endif 	/* __INetConnectionRefresh_FWD_DEFINED__ */


#ifndef __INetConnectionCMUtil_FWD_DEFINED__
#define __INetConnectionCMUtil_FWD_DEFINED__
typedef interface INetConnectionCMUtil INetConnectionCMUtil;
#endif 	/* __INetConnectionCMUtil_FWD_DEFINED__ */


#ifndef __INetConnectionHNetUtil_FWD_DEFINED__
#define __INetConnectionHNetUtil_FWD_DEFINED__
typedef interface INetConnectionHNetUtil INetConnectionHNetUtil;
#endif 	/* __INetConnectionHNetUtil_FWD_DEFINED__ */


#ifndef __INetConnectionSysTray_FWD_DEFINED__
#define __INetConnectionSysTray_FWD_DEFINED__
typedef interface INetConnectionSysTray INetConnectionSysTray;
#endif 	/* __INetConnectionSysTray_FWD_DEFINED__ */


#ifndef __INetMachinePolicies_FWD_DEFINED__
#define __INetMachinePolicies_FWD_DEFINED__
typedef interface INetMachinePolicies INetMachinePolicies;
#endif 	/* __INetMachinePolicies_FWD_DEFINED__ */


#ifndef __INetConnectionManagerDebug_FWD_DEFINED__
#define __INetConnectionManagerDebug_FWD_DEFINED__
typedef interface INetConnectionManagerDebug INetConnectionManagerDebug;
#endif 	/* __INetConnectionManagerDebug_FWD_DEFINED__ */


#ifndef __ISharedAccessBeacon_FWD_DEFINED__
#define __ISharedAccessBeacon_FWD_DEFINED__
typedef interface ISharedAccessBeacon ISharedAccessBeacon;
#endif 	/* __ISharedAccessBeacon_FWD_DEFINED__ */


#ifndef __ISharedAccessBeaconFinder_FWD_DEFINED__
#define __ISharedAccessBeaconFinder_FWD_DEFINED__
typedef interface ISharedAccessBeaconFinder ISharedAccessBeaconFinder;
#endif 	/* __ISharedAccessBeaconFinder_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "netcon.h"
#include "netcfgx.h"
#include "netcfgp.h"
#include "upnp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netconp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_NetConnectionUiUtilities;
EXTERN_C const CLSID CLSID_NetConnectionHNetUtil;
EXTERN_C const CLSID GUID_NETSHELL_PROPS;
EXTERN_C const CLSID CLSID_ConnectionManager2;


























extern RPC_IF_HANDLE __MIDL_itf_netconp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0000_v0_0_s_ifspec;

#ifndef __INetConnectionUiLock_INTERFACE_DEFINED__
#define __INetConnectionUiLock_INTERFACE_DEFINED__

/* interface INetConnectionUiLock */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetConnectionUiLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF50-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionUiLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryLock( 
            /* [string][out] */ LPWSTR *ppszwLockHolder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionUiLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionUiLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionUiLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionUiLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLock )( 
            INetConnectionUiLock * This,
            /* [string][out] */ LPWSTR *ppszwLockHolder);
        
        END_INTERFACE
    } INetConnectionUiLockVtbl;

    interface INetConnectionUiLock
    {
        CONST_VTBL struct INetConnectionUiLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionUiLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionUiLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionUiLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionUiLock_QueryLock(This,ppszwLockHolder)	\
    (This)->lpVtbl -> QueryLock(This,ppszwLockHolder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionUiLock_QueryLock_Proxy( 
    INetConnectionUiLock * This,
    /* [string][out] */ LPWSTR *ppszwLockHolder);


void __RPC_STUB INetConnectionUiLock_QueryLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionUiLock_INTERFACE_DEFINED__ */


#ifndef __INetConnectionWizardUi_INTERFACE_DEFINED__
#define __INetConnectionWizardUi_INTERFACE_DEFINED__

/* interface INetConnectionWizardUi */
/* [unique][uuid][object][local] */ 

typedef 
enum tagNETCON_WIZARD_FLAGS
    {	NCWF_RENAME_DISABLE	= 0x1,
	NCWF_SHORTCUT_ENABLE	= 0x2,
	NCWF_ALLUSER_CONNECTION	= 0x4,
	NCWF_GLOBAL_CREDENTIALS	= 0x8,
	NCWF_FIREWALLED	= 0x10,
	NCWF_DEFAULT	= 0x20,
	NCWF_SHARED	= 0x40,
	NCWF_INCOMINGCONNECTION	= 0x80
    } 	NETCON_WIZARD_FLAGS;


EXTERN_C const IID IID_INetConnectionWizardUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF51-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionWizardUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryMaxPageCount( 
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [out] */ DWORD *pcMaxPages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPages( 
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNewConnectionInfo( 
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ NETCON_MEDIATYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuggestedConnectionName( 
            /* [string][out] */ LPWSTR *pszwSuggestedName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [string][in] */ LPCWSTR pszwConnectionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNewConnection( 
            /* [out] */ INetConnection **ppCon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionWizardUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionWizardUi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionWizardUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionWizardUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryMaxPageCount )( 
            INetConnectionWizardUi * This,
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [out] */ DWORD *pcMaxPages);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            INetConnectionWizardUi * This,
            /* [in] */ INetConnectionWizardUiContext *pContext,
            /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewConnectionInfo )( 
            INetConnectionWizardUi * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ NETCON_MEDIATYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSuggestedConnectionName )( 
            INetConnectionWizardUi * This,
            /* [string][out] */ LPWSTR *pszwSuggestedName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionName )( 
            INetConnectionWizardUi * This,
            /* [string][in] */ LPCWSTR pszwConnectionName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewConnection )( 
            INetConnectionWizardUi * This,
            /* [out] */ INetConnection **ppCon);
        
        END_INTERFACE
    } INetConnectionWizardUiVtbl;

    interface INetConnectionWizardUi
    {
        CONST_VTBL struct INetConnectionWizardUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionWizardUi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionWizardUi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionWizardUi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionWizardUi_QueryMaxPageCount(This,pContext,pcMaxPages)	\
    (This)->lpVtbl -> QueryMaxPageCount(This,pContext,pcMaxPages)

#define INetConnectionWizardUi_AddPages(This,pContext,pfnAddPage,lParam)	\
    (This)->lpVtbl -> AddPages(This,pContext,pfnAddPage,lParam)

#define INetConnectionWizardUi_GetNewConnectionInfo(This,pdwFlags,pMediaType)	\
    (This)->lpVtbl -> GetNewConnectionInfo(This,pdwFlags,pMediaType)

#define INetConnectionWizardUi_GetSuggestedConnectionName(This,pszwSuggestedName)	\
    (This)->lpVtbl -> GetSuggestedConnectionName(This,pszwSuggestedName)

#define INetConnectionWizardUi_SetConnectionName(This,pszwConnectionName)	\
    (This)->lpVtbl -> SetConnectionName(This,pszwConnectionName)

#define INetConnectionWizardUi_GetNewConnection(This,ppCon)	\
    (This)->lpVtbl -> GetNewConnection(This,ppCon)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_QueryMaxPageCount_Proxy( 
    INetConnectionWizardUi * This,
    /* [in] */ INetConnectionWizardUiContext *pContext,
    /* [out] */ DWORD *pcMaxPages);


void __RPC_STUB INetConnectionWizardUi_QueryMaxPageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_AddPages_Proxy( 
    INetConnectionWizardUi * This,
    /* [in] */ INetConnectionWizardUiContext *pContext,
    /* [in] */ LPFNADDPROPSHEETPAGE pfnAddPage,
    /* [in] */ LPARAM lParam);


void __RPC_STUB INetConnectionWizardUi_AddPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetNewConnectionInfo_Proxy( 
    INetConnectionWizardUi * This,
    /* [out] */ DWORD *pdwFlags,
    /* [out] */ NETCON_MEDIATYPE *pMediaType);


void __RPC_STUB INetConnectionWizardUi_GetNewConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetSuggestedConnectionName_Proxy( 
    INetConnectionWizardUi * This,
    /* [string][out] */ LPWSTR *pszwSuggestedName);


void __RPC_STUB INetConnectionWizardUi_GetSuggestedConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_SetConnectionName_Proxy( 
    INetConnectionWizardUi * This,
    /* [string][in] */ LPCWSTR pszwConnectionName);


void __RPC_STUB INetConnectionWizardUi_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUi_GetNewConnection_Proxy( 
    INetConnectionWizardUi * This,
    /* [out] */ INetConnection **ppCon);


void __RPC_STUB INetConnectionWizardUi_GetNewConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionWizardUi_INTERFACE_DEFINED__ */


#ifndef __INetConnectionWizardUiContext_INTERFACE_DEFINED__
#define __INetConnectionWizardUiContext_INTERFACE_DEFINED__

/* interface INetConnectionWizardUiContext */
/* [unique][uuid][object][local] */ 

typedef 
enum tagSETUP_MODE_FLAGS
    {	NCWUC_SETUPMODE_MINIMAL	= 0,
	NCWUC_SETUPMODE_TYPICAL	= 0x1,
	NCWUC_SETUPMODE_LAPTOP	= 0x2,
	NCWUC_SETUPMODE_CUSTOM	= 0x3
    } 	SETUP_MODE_FLAGS;

typedef 
enum tagUNATTENDED_MODE_FLAGS
    {	UM_DEFAULTHIDE	= 0x1,
	UM_GUIATTENDED	= 0x2,
	UM_PROVIDEDEFAULT	= 0x3,
	UM_READONLY	= 0x4,
	UM_FULLUNATTENDED	= 0x5
    } 	UM_MODE;

typedef 
enum tagPRODUCT_TYPE_FLAGS
    {	NCWUC_PRODUCT_WORKSTATION	= 0,
	NCWUC_PRODUCT_SERVER_DC	= 0x1,
	NCWUC_PRODUCT_SERVER_STANDALONE	= 0x2
    } 	PRODUCT_TYPE_FLAGS;

typedef 
enum tagOPERATION_FLAGS
    {	NCWUC_SETUPOPER_UPGRADE	= 0x4,
	NCWUC_SETUPOPER_UNATTENDED	= 0x8,
	NCWUC_SETUPOPER_POSTINSTALL	= 0x10
    } 	OPERATION_FLAGS;


EXTERN_C const IID IID_INetConnectionWizardUiContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF52-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionWizardUiContext : public IUnknown
    {
    public:
        virtual DWORD STDMETHODCALLTYPE GetSetupMode( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetProductType( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetOperationFlags( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetUnattendedModeFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetINetCfg( 
            /* [out] */ INetCfg **ppINetCfg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionWizardUiContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionWizardUiContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionWizardUiContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetSetupMode )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetProductType )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetOperationFlags )( 
            INetConnectionWizardUiContext * This);
        
        DWORD ( STDMETHODCALLTYPE *GetUnattendedModeFlags )( 
            INetConnectionWizardUiContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetINetCfg )( 
            INetConnectionWizardUiContext * This,
            /* [out] */ INetCfg **ppINetCfg);
        
        END_INTERFACE
    } INetConnectionWizardUiContextVtbl;

    interface INetConnectionWizardUiContext
    {
        CONST_VTBL struct INetConnectionWizardUiContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionWizardUiContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionWizardUiContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionWizardUiContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionWizardUiContext_GetSetupMode(This)	\
    (This)->lpVtbl -> GetSetupMode(This)

#define INetConnectionWizardUiContext_GetProductType(This)	\
    (This)->lpVtbl -> GetProductType(This)

#define INetConnectionWizardUiContext_GetOperationFlags(This)	\
    (This)->lpVtbl -> GetOperationFlags(This)

#define INetConnectionWizardUiContext_GetUnattendedModeFlags(This)	\
    (This)->lpVtbl -> GetUnattendedModeFlags(This)

#define INetConnectionWizardUiContext_GetINetCfg(This,ppINetCfg)	\
    (This)->lpVtbl -> GetINetCfg(This,ppINetCfg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetSetupMode_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetSetupMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetProductType_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetProductType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetOperationFlags_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetOperationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE INetConnectionWizardUiContext_GetUnattendedModeFlags_Proxy( 
    INetConnectionWizardUiContext * This);


void __RPC_STUB INetConnectionWizardUiContext_GetUnattendedModeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionWizardUiContext_GetINetCfg_Proxy( 
    INetConnectionWizardUiContext * This,
    /* [out] */ INetCfg **ppINetCfg);


void __RPC_STUB INetConnectionWizardUiContext_GetINetCfg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionWizardUiContext_INTERFACE_DEFINED__ */


#ifndef __INetInboundConnection_INTERFACE_DEFINED__
#define __INetInboundConnection_INTERFACE_DEFINED__

/* interface INetInboundConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetInboundConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF53-31FE-11D1-AAD2-00805FC1270E")
    INetInboundConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServerConnectionHandle( 
            /* [out] */ ULONG_PTR *phRasSrvCon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeAsConfigConnection( 
            /* [in] */ BOOL fStartRemoteAccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetInboundConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetInboundConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetInboundConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetInboundConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetServerConnectionHandle )( 
            INetInboundConnection * This,
            /* [out] */ ULONG_PTR *phRasSrvCon);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeAsConfigConnection )( 
            INetInboundConnection * This,
            /* [in] */ BOOL fStartRemoteAccess);
        
        END_INTERFACE
    } INetInboundConnectionVtbl;

    interface INetInboundConnection
    {
        CONST_VTBL struct INetInboundConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetInboundConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetInboundConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetInboundConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetInboundConnection_GetServerConnectionHandle(This,phRasSrvCon)	\
    (This)->lpVtbl -> GetServerConnectionHandle(This,phRasSrvCon)

#define INetInboundConnection_InitializeAsConfigConnection(This,fStartRemoteAccess)	\
    (This)->lpVtbl -> InitializeAsConfigConnection(This,fStartRemoteAccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetInboundConnection_GetServerConnectionHandle_Proxy( 
    INetInboundConnection * This,
    /* [out] */ ULONG_PTR *phRasSrvCon);


void __RPC_STUB INetInboundConnection_GetServerConnectionHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetInboundConnection_InitializeAsConfigConnection_Proxy( 
    INetInboundConnection * This,
    /* [in] */ BOOL fStartRemoteAccess);


void __RPC_STUB INetInboundConnection_InitializeAsConfigConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetInboundConnection_INTERFACE_DEFINED__ */


#ifndef __INetLanConnection_INTERFACE_DEFINED__
#define __INetLanConnection_INTERFACE_DEFINED__

/* interface INetLanConnection */
/* [unique][uuid][object] */ 

typedef 
enum tagLANCON_INFO_FLAGS
    {	LCIF_NAME	= 0x1,
	LCIF_ICON	= 0x2,
	LCIF_COMP	= 0x8,
	LCIF_ALL	= 0xff
    } 	LANCON_INFO_FLAGS;

typedef struct tagLANCON_INFO
    {
    /* [string] */ LPWSTR szwConnName;
    BOOL fShowIcon;
    GUID guid;
    } 	LANCON_INFO;


EXTERN_C const IID IID_INetLanConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF54-31FE-11D1-AAD2-00805FC1270E")
    INetLanConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ DWORD dwMask,
            /* [out] */ LANCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInfo( 
            /* [in] */ DWORD dwMask,
            /* [in] */ const LANCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceGuid( 
            /* [ref][out] */ GUID *pguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetLanConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetLanConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetLanConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetLanConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            INetLanConnection * This,
            /* [in] */ DWORD dwMask,
            /* [out] */ LANCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            INetLanConnection * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ const LANCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceGuid )( 
            INetLanConnection * This,
            /* [ref][out] */ GUID *pguid);
        
        END_INTERFACE
    } INetLanConnectionVtbl;

    interface INetLanConnection
    {
        CONST_VTBL struct INetLanConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetLanConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetLanConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetLanConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetLanConnection_GetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwMask,pLanConInfo)

#define INetLanConnection_SetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> SetInfo(This,dwMask,pLanConInfo)

#define INetLanConnection_GetDeviceGuid(This,pguid)	\
    (This)->lpVtbl -> GetDeviceGuid(This,pguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetLanConnection_GetInfo_Proxy( 
    INetLanConnection * This,
    /* [in] */ DWORD dwMask,
    /* [out] */ LANCON_INFO *pLanConInfo);


void __RPC_STUB INetLanConnection_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetLanConnection_SetInfo_Proxy( 
    INetLanConnection * This,
    /* [in] */ DWORD dwMask,
    /* [in] */ const LANCON_INFO *pLanConInfo);


void __RPC_STUB INetLanConnection_SetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetLanConnection_GetDeviceGuid_Proxy( 
    INetLanConnection * This,
    /* [ref][out] */ GUID *pguid);


void __RPC_STUB INetLanConnection_GetDeviceGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetLanConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netconp_0329 */
/* [local] */ 


EXTERN_C HRESULT WINAPI HrLanConnectionNameFromGuidOrPath (
  /* [in]    */  const GUID* pguid,
  /* [in]    */  LPCWSTR pszwPath,
  /* [out]   */  LPWSTR  pszwName,
  /* [inout] */  LPDWORD pcchMax);


typedef HRESULT
(WINAPI* PHRLANCONNECTIONNAMEFROMGUIDORPATH)(
    const GUID*,
    LPCWSTR,
    LPWSTR,
    LPDWORD
    );


EXTERN_C HRESULT WINAPI HrPnpInstanceIdFromGuid (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  LPWSTR szwInstance,
  /* [in]    */  UINT cchInstance);


typedef HRESULT
(WINAPI* PHRPNPINSTANCEIDFROMGUID)(
    const GUID*,
    LPWSTR,
    UINT
    );


EXTERN_C HRESULT WINAPI HrGetPnpDeviceStatus (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  NETCON_STATUS *pStatus);


typedef HRESULT
(WINAPI* PHRGETPNPDEVICESTATUS)(
    const GUID*,
    NETCON_STATUS*
    );


EXTERN_C HRESULT WINAPI HrQueryLanMediaState (
  /* [in]    */  const GUID* pguid,
  /* [out]   */  BOOL *pfEnabled);


typedef HRESULT
(WINAPI* PHRQUERYLANMEDIASTATE)(
    const GUID*,
    BOOL*
    );



extern RPC_IF_HANDLE __MIDL_itf_netconp_0329_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0329_v0_0_s_ifspec;

#ifndef __INetSharedAccessConnection_INTERFACE_DEFINED__
#define __INetSharedAccessConnection_INTERFACE_DEFINED__

/* interface INetSharedAccessConnection */
/* [unique][uuid][object] */ 

typedef 
enum tagSHAREDACCESSCON_INFO_FLAGS
    {	SACIF_ICON	= 0x1,
	SACIF_ALL	= 0xff
    } 	SHAREDACCESSCON_INFO_FLAGS;

typedef struct tagSHAREDACCESSCON_INFO
    {
    BOOL fShowIcon;
    } 	SHAREDACCESSCON_INFO;

typedef 
enum tagSAHOST_SERVICES
    {	SAHOST_SERVICE_OSINFO	= 0,
	SAHOST_SERVICE_WANCOMMONINTERFACECONFIG	= SAHOST_SERVICE_OSINFO + 1,
	SAHOST_SERVICE_WANIPCONNECTION	= SAHOST_SERVICE_WANCOMMONINTERFACECONFIG + 1,
	SAHOST_SERVICE_WANPPPCONNECTION	= SAHOST_SERVICE_WANIPCONNECTION + 1,
	SAHOST_SERVICE_NATSTATICPORTMAPPING	= SAHOST_SERVICE_WANPPPCONNECTION + 1,
	SAHOST_SERVICE_MAX	= SAHOST_SERVICE_NATSTATICPORTMAPPING + 1
    } 	SAHOST_SERVICES;


EXTERN_C const IID IID_INetSharedAccessConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF55-31FE-11D1-AAD2-00805FC1270E")
    INetSharedAccessConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ DWORD dwMask,
            /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInfo( 
            /* [in] */ DWORD dwMask,
            /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalAdapterGUID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharedAccessConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetSharedAccessConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetSharedAccessConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetSharedAccessConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            INetSharedAccessConnection * This,
            /* [in] */ DWORD dwMask,
            /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetInfo )( 
            INetSharedAccessConnection * This,
            /* [in] */ DWORD dwMask,
            /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAdapterGUID )( 
            INetSharedAccessConnection * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            INetSharedAccessConnection * This,
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **ppService);
        
        END_INTERFACE
    } INetSharedAccessConnectionVtbl;

    interface INetSharedAccessConnection
    {
        CONST_VTBL struct INetSharedAccessConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharedAccessConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetSharedAccessConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetSharedAccessConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetSharedAccessConnection_GetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwMask,pLanConInfo)

#define INetSharedAccessConnection_SetInfo(This,dwMask,pLanConInfo)	\
    (This)->lpVtbl -> SetInfo(This,dwMask,pLanConInfo)

#define INetSharedAccessConnection_GetLocalAdapterGUID(This,pGuid)	\
    (This)->lpVtbl -> GetLocalAdapterGUID(This,pGuid)

#define INetSharedAccessConnection_GetService(This,ulService,ppService)	\
    (This)->lpVtbl -> GetService(This,ulService,ppService)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetInfo_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ DWORD dwMask,
    /* [out] */ SHAREDACCESSCON_INFO *pLanConInfo);


void __RPC_STUB INetSharedAccessConnection_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_SetInfo_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ DWORD dwMask,
    /* [in] */ const SHAREDACCESSCON_INFO *pLanConInfo);


void __RPC_STUB INetSharedAccessConnection_SetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetLocalAdapterGUID_Proxy( 
    INetSharedAccessConnection * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB INetSharedAccessConnection_GetLocalAdapterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetSharedAccessConnection_GetService_Proxy( 
    INetSharedAccessConnection * This,
    /* [in] */ SAHOST_SERVICES ulService,
    /* [out] */ IUPnPService **ppService);


void __RPC_STUB INetSharedAccessConnection_GetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetSharedAccessConnection_INTERFACE_DEFINED__ */


#ifndef __INetLanConnectionWizardUi_INTERFACE_DEFINED__
#define __INetLanConnectionWizardUi_INTERFACE_DEFINED__

/* interface INetLanConnectionWizardUi */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetLanConnectionWizardUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF56-31FE-11D1-AAD2-00805FC1270E")
    INetLanConnectionWizardUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDeviceComponent( 
            /* [in] */ const GUID *pguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetLanConnectionWizardUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetLanConnectionWizardUi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetLanConnectionWizardUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetLanConnectionWizardUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceComponent )( 
            INetLanConnectionWizardUi * This,
            /* [in] */ const GUID *pguid);
        
        END_INTERFACE
    } INetLanConnectionWizardUiVtbl;

    interface INetLanConnectionWizardUi
    {
        CONST_VTBL struct INetLanConnectionWizardUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetLanConnectionWizardUi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetLanConnectionWizardUi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetLanConnectionWizardUi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetLanConnectionWizardUi_SetDeviceComponent(This,pguid)	\
    (This)->lpVtbl -> SetDeviceComponent(This,pguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetLanConnectionWizardUi_SetDeviceComponent_Proxy( 
    INetLanConnectionWizardUi * This,
    /* [in] */ const GUID *pguid);


void __RPC_STUB INetLanConnectionWizardUi_SetDeviceComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetLanConnectionWizardUi_INTERFACE_DEFINED__ */


#ifndef __INetRasConnection_INTERFACE_DEFINED__
#define __INetRasConnection_INTERFACE_DEFINED__

/* interface INetRasConnection */
/* [unique][uuid][object] */ 

typedef struct tagRASCON_INFO
    {
    /* [string] */ LPWSTR pszwPbkFile;
    /* [string] */ LPWSTR pszwEntryName;
    GUID guidId;
    } 	RASCON_INFO;


EXTERN_C const IID IID_INetRasConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF57-31FE-11D1-AAD2-00805FC1270E")
    INetRasConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRasConnectionInfo( 
            /* [out] */ RASCON_INFO *pRasConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRasConnectionInfo( 
            /* [in] */ const RASCON_INFO *pRasConInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRasConnectionHandle( 
            /* [out] */ ULONG_PTR *phRasConn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetRasConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetRasConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetRasConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetRasConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasConnectionInfo )( 
            INetRasConnection * This,
            /* [out] */ RASCON_INFO *pRasConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetRasConnectionInfo )( 
            INetRasConnection * This,
            /* [in] */ const RASCON_INFO *pRasConInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetRasConnectionHandle )( 
            INetRasConnection * This,
            /* [out] */ ULONG_PTR *phRasConn);
        
        END_INTERFACE
    } INetRasConnectionVtbl;

    interface INetRasConnection
    {
        CONST_VTBL struct INetRasConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetRasConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetRasConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetRasConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetRasConnection_GetRasConnectionInfo(This,pRasConInfo)	\
    (This)->lpVtbl -> GetRasConnectionInfo(This,pRasConInfo)

#define INetRasConnection_SetRasConnectionInfo(This,pRasConInfo)	\
    (This)->lpVtbl -> SetRasConnectionInfo(This,pRasConInfo)

#define INetRasConnection_GetRasConnectionHandle(This,phRasConn)	\
    (This)->lpVtbl -> GetRasConnectionHandle(This,phRasConn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetRasConnection_GetRasConnectionInfo_Proxy( 
    INetRasConnection * This,
    /* [out] */ RASCON_INFO *pRasConInfo);


void __RPC_STUB INetRasConnection_GetRasConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetRasConnection_SetRasConnectionInfo_Proxy( 
    INetRasConnection * This,
    /* [in] */ const RASCON_INFO *pRasConInfo);


void __RPC_STUB INetRasConnection_SetRasConnectionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetRasConnection_GetRasConnectionHandle_Proxy( 
    INetRasConnection * This,
    /* [out] */ ULONG_PTR *phRasConn);


void __RPC_STUB INetRasConnection_GetRasConnectionHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetRasConnection_INTERFACE_DEFINED__ */


#ifndef __INetDefaultConnection_INTERFACE_DEFINED__
#define __INetDefaultConnection_INTERFACE_DEFINED__

/* interface INetDefaultConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetDefaultConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF66-31FE-11D1-AAD2-00805FC1270E")
    INetDefaultConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefault( 
            /* [in] */ BOOL bDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefault( 
            /* [out] */ BOOL *pbDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDefaultConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetDefaultConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetDefaultConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetDefaultConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefault )( 
            INetDefaultConnection * This,
            /* [in] */ BOOL bDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefault )( 
            INetDefaultConnection * This,
            /* [out] */ BOOL *pbDefault);
        
        END_INTERFACE
    } INetDefaultConnectionVtbl;

    interface INetDefaultConnection
    {
        CONST_VTBL struct INetDefaultConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDefaultConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetDefaultConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetDefaultConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetDefaultConnection_SetDefault(This,bDefault)	\
    (This)->lpVtbl -> SetDefault(This,bDefault)

#define INetDefaultConnection_GetDefault(This,pbDefault)	\
    (This)->lpVtbl -> GetDefault(This,pbDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetDefaultConnection_SetDefault_Proxy( 
    INetDefaultConnection * This,
    /* [in] */ BOOL bDefault);


void __RPC_STUB INetDefaultConnection_SetDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetDefaultConnection_GetDefault_Proxy( 
    INetDefaultConnection * This,
    /* [out] */ BOOL *pbDefault);


void __RPC_STUB INetDefaultConnection_GetDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetDefaultConnection_INTERFACE_DEFINED__ */


#ifndef __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__
#define __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__

/* interface INetRasConnectionIpUiInfo */
/* [unique][uuid][object] */ 

typedef 
enum tagRASCON_IPUI_FLAGS
    {	RCUIF_PPP	= 0x1,
	RCUIF_SLIP	= 0x2,
	RCUIF_USE_IP_ADDR	= 0x4,
	RCUIF_USE_NAME_SERVERS	= 0x8,
	RCUIF_USE_REMOTE_GATEWAY	= 0x10,
	RCUIF_USE_HEADER_COMPRESSION	= 0x20,
	RCUIF_VPN	= 0x40,
	RCUIF_DEMAND_DIAL	= 0x80,
	RCUIF_USE_DISABLE_REGISTER_DNS	= 0x100,
	RCUIF_USE_PRIVATE_DNS_SUFFIX	= 0x200,
	RCUIF_NOT_ADMIN	= 0x400,
	RCUIF_ENABLE_NBT	= 0x800
    } 	RASCON_UIINFO_FLAGS;

typedef struct tagRASCON_IPUI
    {
    GUID guidConnection;
    DWORD dwFlags;
    WCHAR pszwIpAddr[ 16 ];
    WCHAR pszwDnsAddr[ 16 ];
    WCHAR pszwDns2Addr[ 16 ];
    WCHAR pszwWinsAddr[ 16 ];
    WCHAR pszwWins2Addr[ 16 ];
    DWORD dwFrameSize;
    WCHAR pszwDnsSuffix[ 256 ];
    } 	RASCON_IPUI;


EXTERN_C const IID IID_INetRasConnectionIpUiInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF58-31FE-11D1-AAD2-00805FC1270E")
    INetRasConnectionIpUiInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUiInfo( 
            /* [out] */ RASCON_IPUI *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetRasConnectionIpUiInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetRasConnectionIpUiInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetRasConnectionIpUiInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetRasConnectionIpUiInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUiInfo )( 
            INetRasConnectionIpUiInfo * This,
            /* [out] */ RASCON_IPUI *pInfo);
        
        END_INTERFACE
    } INetRasConnectionIpUiInfoVtbl;

    interface INetRasConnectionIpUiInfo
    {
        CONST_VTBL struct INetRasConnectionIpUiInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetRasConnectionIpUiInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetRasConnectionIpUiInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetRasConnectionIpUiInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetRasConnectionIpUiInfo_GetUiInfo(This,pInfo)	\
    (This)->lpVtbl -> GetUiInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetRasConnectionIpUiInfo_GetUiInfo_Proxy( 
    INetRasConnectionIpUiInfo * This,
    /* [out] */ RASCON_IPUI *pInfo);


void __RPC_STUB INetRasConnectionIpUiInfo_GetUiInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetRasConnectionIpUiInfo_INTERFACE_DEFINED__ */


#ifndef __IPersistNetConnection_INTERFACE_DEFINED__
#define __IPersistNetConnection_INTERFACE_DEFINED__

/* interface IPersistNetConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF59-31FE-11D1-AAD2-00805FC1270E")
    IPersistNetConnection : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
            /* [out] */ ULONG *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [size_is][in] */ const BYTE *pbBuf,
            /* [in] */ ULONG cbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [size_is][out] */ BYTE *pbBuf,
            /* [in] */ ULONG cbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistNetConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistNetConnection * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
            IPersistNetConnection * This,
            /* [out] */ ULONG *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IPersistNetConnection * This,
            /* [size_is][in] */ const BYTE *pbBuf,
            /* [in] */ ULONG cbSize);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IPersistNetConnection * This,
            /* [size_is][out] */ BYTE *pbBuf,
            /* [in] */ ULONG cbSize);
        
        END_INTERFACE
    } IPersistNetConnectionVtbl;

    interface IPersistNetConnection
    {
        CONST_VTBL struct IPersistNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistNetConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistNetConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistNetConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistNetConnection_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistNetConnection_GetSizeMax(This,pcbSize)	\
    (This)->lpVtbl -> GetSizeMax(This,pcbSize)

#define IPersistNetConnection_Load(This,pbBuf,cbSize)	\
    (This)->lpVtbl -> Load(This,pbBuf,cbSize)

#define IPersistNetConnection_Save(This,pbBuf,cbSize)	\
    (This)->lpVtbl -> Save(This,pbBuf,cbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistNetConnection_GetSizeMax_Proxy( 
    IPersistNetConnection * This,
    /* [out] */ ULONG *pcbSize);


void __RPC_STUB IPersistNetConnection_GetSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistNetConnection_Load_Proxy( 
    IPersistNetConnection * This,
    /* [size_is][in] */ const BYTE *pbBuf,
    /* [in] */ ULONG cbSize);


void __RPC_STUB IPersistNetConnection_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistNetConnection_Save_Proxy( 
    IPersistNetConnection * This,
    /* [size_is][out] */ BYTE *pbBuf,
    /* [in] */ ULONG cbSize);


void __RPC_STUB IPersistNetConnection_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistNetConnection_INTERFACE_DEFINED__ */


#ifndef __INetConnectionBrandingInfo_INTERFACE_DEFINED__
#define __INetConnectionBrandingInfo_INTERFACE_DEFINED__

/* interface INetConnectionBrandingInfo */
/* [unique][uuid][object] */ 

typedef struct tagCON_BRANDING_INFO
    {
    /* [string] */ LPWSTR szwLargeIconPath;
    /* [string] */ LPWSTR szwSmallIconPath;
    /* [string] */ LPWSTR szwTrayIconPath;
    } 	CON_BRANDING_INFO;

typedef struct tagCON_TRAY_MENU_ENTRY
    {
    /* [string] */ LPWSTR szwMenuText;
    /* [string] */ LPWSTR szwMenuCmdLine;
    /* [string] */ LPWSTR szwMenuParams;
    } 	CON_TRAY_MENU_ENTRY;

typedef struct tagCON_TRAY_MENU_DATA
    {
    DWORD dwCount;
    /* [size_is] */ CON_TRAY_MENU_ENTRY *pctme;
    } 	CON_TRAY_MENU_DATA;


EXTERN_C const IID IID_INetConnectionBrandingInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5B-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionBrandingInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBrandingIconPaths( 
            /* [out] */ CON_BRANDING_INFO **ppConBrandInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrayMenuEntries( 
            /* [out] */ CON_TRAY_MENU_DATA **ppMenuData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionBrandingInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionBrandingInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionBrandingInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionBrandingInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrandingIconPaths )( 
            INetConnectionBrandingInfo * This,
            /* [out] */ CON_BRANDING_INFO **ppConBrandInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTrayMenuEntries )( 
            INetConnectionBrandingInfo * This,
            /* [out] */ CON_TRAY_MENU_DATA **ppMenuData);
        
        END_INTERFACE
    } INetConnectionBrandingInfoVtbl;

    interface INetConnectionBrandingInfo
    {
        CONST_VTBL struct INetConnectionBrandingInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionBrandingInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionBrandingInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionBrandingInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionBrandingInfo_GetBrandingIconPaths(This,ppConBrandInfo)	\
    (This)->lpVtbl -> GetBrandingIconPaths(This,ppConBrandInfo)

#define INetConnectionBrandingInfo_GetTrayMenuEntries(This,ppMenuData)	\
    (This)->lpVtbl -> GetTrayMenuEntries(This,ppMenuData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionBrandingInfo_GetBrandingIconPaths_Proxy( 
    INetConnectionBrandingInfo * This,
    /* [out] */ CON_BRANDING_INFO **ppConBrandInfo);


void __RPC_STUB INetConnectionBrandingInfo_GetBrandingIconPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionBrandingInfo_GetTrayMenuEntries_Proxy( 
    INetConnectionBrandingInfo * This,
    /* [out] */ CON_TRAY_MENU_DATA **ppMenuData);


void __RPC_STUB INetConnectionBrandingInfo_GetTrayMenuEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionBrandingInfo_INTERFACE_DEFINED__ */


#ifndef __INetConnectionManager2_INTERFACE_DEFINED__
#define __INetConnectionManager2_INTERFACE_DEFINED__

/* interface INetConnectionManager2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF69-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionManager2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumConnectionProperties( 
            /* [out] */ LPSAFEARRAY *ppsaConnectionProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumConnectionProperties )( 
            INetConnectionManager2 * This,
            /* [out] */ LPSAFEARRAY *ppsaConnectionProperties);
        
        END_INTERFACE
    } INetConnectionManager2Vtbl;

    interface INetConnectionManager2
    {
        CONST_VTBL struct INetConnectionManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionManager2_EnumConnectionProperties(This,ppsaConnectionProperties)	\
    (This)->lpVtbl -> EnumConnectionProperties(This,ppsaConnectionProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionManager2_EnumConnectionProperties_Proxy( 
    INetConnectionManager2 * This,
    /* [out] */ LPSAFEARRAY *ppsaConnectionProperties);


void __RPC_STUB INetConnectionManager2_EnumConnectionProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionManager2_INTERFACE_DEFINED__ */


#ifndef __INetConnection2_INTERFACE_DEFINED__
#define __INetConnection2_INTERFACE_DEFINED__

/* interface INetConnection2 */
/* [unique][uuid][object] */ 

typedef 
enum tagNETCON_SUBMEDIATYPE
    {	NCSM_NONE	= 0,
	NCSM_LAN	= NCSM_NONE + 1,
	NCSM_WIRELESS	= NCSM_LAN + 1,
	NCSM_ATM	= NCSM_WIRELESS + 1,
	NCSM_ELAN	= NCSM_ATM + 1,
	NCSM_1394	= NCSM_ELAN + 1,
	NCSM_DIRECT	= NCSM_1394 + 1,
	NCSM_IRDA	= NCSM_DIRECT + 1,
	NCSM_CM	= NCSM_IRDA + 1
    } 	NETCON_SUBMEDIATYPE;

typedef struct tagNETCON_PROPERTIES_EX
    {
    DWORD dwSize;
    GUID guidId;
    BSTR bstrName;
    BSTR bstrDeviceName;
    NETCON_STATUS ncStatus;
    NETCON_MEDIATYPE ncMediaType;
    NETCON_SUBMEDIATYPE ncSubMediaType;
    DWORD dwCharacter;
    CLSID clsidThisObject;
    CLSID clsidUiObject;
    BSTR bstrPhoneOrHostAddress;
    BSTR bstrPersistData;
    } 	NETCON_PROPERTIES_EX;


EXTERN_C const IID IID_INetConnection2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF6A-31FE-11D1-AAD2-00805FC1270E")
    INetConnection2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertiesEx( 
            /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnection2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnection2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnection2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertiesEx )( 
            INetConnection2 * This,
            /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx);
        
        END_INTERFACE
    } INetConnection2Vtbl;

    interface INetConnection2
    {
        CONST_VTBL struct INetConnection2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnection2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnection2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnection2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnection2_GetPropertiesEx(This,ppConnectionPropertiesEx)	\
    (This)->lpVtbl -> GetPropertiesEx(This,ppConnectionPropertiesEx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnection2_GetPropertiesEx_Proxy( 
    INetConnection2 * This,
    /* [out] */ NETCON_PROPERTIES_EX **ppConnectionPropertiesEx);


void __RPC_STUB INetConnection2_GetPropertiesEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnection2_INTERFACE_DEFINED__ */


#ifndef __INetConnectionNotifySink_INTERFACE_DEFINED__
#define __INetConnectionNotifySink_INTERFACE_DEFINED__

/* interface INetConnectionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5C-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectionAdded( 
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionBandWidthChange( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionDeleted( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionModified( 
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionRenamed( 
            /* [in] */ const GUID *pguidId,
            /* [string][in] */ LPCWSTR pszwNewName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionStatusChange( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ NETCON_STATUS Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionAddressChange( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowBalloon( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableEvents( 
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAdded )( 
            INetConnectionNotifySink * This,
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionBandWidthChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionDeleted )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionModified )( 
            INetConnectionNotifySink * This,
            /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionRenamed )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [string][in] */ LPCWSTR pszwNewName);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionStatusChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ NETCON_STATUS Status);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshAll )( 
            INetConnectionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAddressChange )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ShowBalloon )( 
            INetConnectionNotifySink * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText);
        
        HRESULT ( STDMETHODCALLTYPE *DisableEvents )( 
            INetConnectionNotifySink * This,
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout);
        
        END_INTERFACE
    } INetConnectionNotifySinkVtbl;

    interface INetConnectionNotifySink
    {
        CONST_VTBL struct INetConnectionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionNotifySink_ConnectionAdded(This,pPropsEx)	\
    (This)->lpVtbl -> ConnectionAdded(This,pPropsEx)

#define INetConnectionNotifySink_ConnectionBandWidthChange(This,pguidId)	\
    (This)->lpVtbl -> ConnectionBandWidthChange(This,pguidId)

#define INetConnectionNotifySink_ConnectionDeleted(This,pguidId)	\
    (This)->lpVtbl -> ConnectionDeleted(This,pguidId)

#define INetConnectionNotifySink_ConnectionModified(This,pPropsEx)	\
    (This)->lpVtbl -> ConnectionModified(This,pPropsEx)

#define INetConnectionNotifySink_ConnectionRenamed(This,pguidId,pszwNewName)	\
    (This)->lpVtbl -> ConnectionRenamed(This,pguidId,pszwNewName)

#define INetConnectionNotifySink_ConnectionStatusChange(This,pguidId,Status)	\
    (This)->lpVtbl -> ConnectionStatusChange(This,pguidId,Status)

#define INetConnectionNotifySink_RefreshAll(This)	\
    (This)->lpVtbl -> RefreshAll(This)

#define INetConnectionNotifySink_ConnectionAddressChange(This,pguidId)	\
    (This)->lpVtbl -> ConnectionAddressChange(This,pguidId)

#define INetConnectionNotifySink_ShowBalloon(This,pguidId,szCookie,szBalloonText)	\
    (This)->lpVtbl -> ShowBalloon(This,pguidId,szCookie,szBalloonText)

#define INetConnectionNotifySink_DisableEvents(This,fDisable,ulDisableTimeout)	\
    (This)->lpVtbl -> DisableEvents(This,fDisable,ulDisableTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionAdded_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);


void __RPC_STUB INetConnectionNotifySink_ConnectionAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionBandWidthChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionBandWidthChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionDeleted_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionModified_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const NETCON_PROPERTIES_EX *pPropsEx);


void __RPC_STUB INetConnectionNotifySink_ConnectionModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionRenamed_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [string][in] */ LPCWSTR pszwNewName);


void __RPC_STUB INetConnectionNotifySink_ConnectionRenamed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionStatusChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ NETCON_STATUS Status);


void __RPC_STUB INetConnectionNotifySink_ConnectionStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_RefreshAll_Proxy( 
    INetConnectionNotifySink * This);


void __RPC_STUB INetConnectionNotifySink_RefreshAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ConnectionAddressChange_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionNotifySink_ConnectionAddressChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_ShowBalloon_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const BSTR szCookie,
    /* [in] */ const BSTR szBalloonText);


void __RPC_STUB INetConnectionNotifySink_ShowBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionNotifySink_DisableEvents_Proxy( 
    INetConnectionNotifySink * This,
    /* [in] */ const BOOL fDisable,
    /* [in] */ const ULONG ulDisableTimeout);


void __RPC_STUB INetConnectionNotifySink_DisableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionNotifySink_INTERFACE_DEFINED__ */


#ifndef __INetConnectionUiUtilities_INTERFACE_DEFINED__
#define __INetConnectionUiUtilities_INTERFACE_DEFINED__

/* interface INetConnectionUiUtilities */
/* [unique][uuid][object][local] */ 

typedef 
enum tagQUERY_USER_FOR_REBOOT_FLAGS
    {	QUFR_PROMPT	= 0x1,
	QUFR_REBOOT	= 0x2
    } 	QUERY_USER_FOR_REBOOT_FLAGS;

typedef 
enum tagNCPERM_FLAGS
    {	NCPERM_NewConnectionWizard	= 0,
	NCPERM_Statistics	= 1,
	NCPERM_AddRemoveComponents	= 2,
	NCPERM_RasConnect	= 3,
	NCPERM_LanConnect	= 4,
	NCPERM_DeleteConnection	= 5,
	NCPERM_DeleteAllUserConnection	= 6,
	NCPERM_RenameConnection	= 7,
	NCPERM_RenameMyRasConnection	= 8,
	NCPERM_ChangeBindState	= 9,
	NCPERM_AdvancedSettings	= 10,
	NCPERM_DialupPrefs	= 11,
	NCPERM_LanChangeProperties	= 12,
	NCPERM_RasChangeProperties	= 13,
	NCPERM_LanProperties	= 14,
	NCPERM_RasMyProperties	= 15,
	NCPERM_RasAllUserProperties	= 16,
	NCPERM_ShowSharedAccessUi	= 17,
	NCPERM_AllowAdvancedTCPIPConfig	= 18,
	NCPERM_OpenConnectionsFolder	= 19,
	NCPERM_PersonalFirewallConfig	= 20,
	NCPERM_AllowNetBridge_NLA	= 21,
	NCPERM_ICSClientApp	= 22,
	NCPERM_EnDisComponentsAllUserRas	= 23,
	NCPERM_EnDisComponentsMyRas	= 24,
	NCPERM_ChangeMyRasProperties	= 25,
	NCPERM_ChangeAllUserRasProperties	= 26,
	NCPERM_RenameLanConnection	= 27,
	NCPERM_RenameAllUserRasConnection	= 28,
	NCPERM_IpcfgOperation	= 29,
	NCPERM_Repair	= 30
    } 	NCPERM_FLAGS;


EXTERN_C const IID IID_INetConnectionUiUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5E-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionUiUtilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryUserAndRemoveComponent( 
            HWND hwndParent,
            INetCfg *pnc,
            INetCfgComponent *pncc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryUserForReboot( 
            HWND hwndParent,
            LPCTSTR pszCaption,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayAddComponentDialog( 
            HWND hwndParent,
            INetCfg *pnc,
            CI_FILTER_INFO *pcfi) = 0;
        
        virtual BOOL STDMETHODCALLTYPE UserHasPermission( 
            DWORD dwPerm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionUiUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionUiUtilities * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionUiUtilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionUiUtilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUserAndRemoveComponent )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            INetCfg *pnc,
            INetCfgComponent *pncc);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUserForReboot )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            LPCTSTR pszCaption,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayAddComponentDialog )( 
            INetConnectionUiUtilities * This,
            HWND hwndParent,
            INetCfg *pnc,
            CI_FILTER_INFO *pcfi);
        
        BOOL ( STDMETHODCALLTYPE *UserHasPermission )( 
            INetConnectionUiUtilities * This,
            DWORD dwPerm);
        
        END_INTERFACE
    } INetConnectionUiUtilitiesVtbl;

    interface INetConnectionUiUtilities
    {
        CONST_VTBL struct INetConnectionUiUtilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionUiUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionUiUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionUiUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionUiUtilities_QueryUserAndRemoveComponent(This,hwndParent,pnc,pncc)	\
    (This)->lpVtbl -> QueryUserAndRemoveComponent(This,hwndParent,pnc,pncc)

#define INetConnectionUiUtilities_QueryUserForReboot(This,hwndParent,pszCaption,dwFlags)	\
    (This)->lpVtbl -> QueryUserForReboot(This,hwndParent,pszCaption,dwFlags)

#define INetConnectionUiUtilities_DisplayAddComponentDialog(This,hwndParent,pnc,pcfi)	\
    (This)->lpVtbl -> DisplayAddComponentDialog(This,hwndParent,pnc,pcfi)

#define INetConnectionUiUtilities_UserHasPermission(This,dwPerm)	\
    (This)->lpVtbl -> UserHasPermission(This,dwPerm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_QueryUserAndRemoveComponent_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    INetCfg *pnc,
    INetCfgComponent *pncc);


void __RPC_STUB INetConnectionUiUtilities_QueryUserAndRemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_QueryUserForReboot_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    LPCTSTR pszCaption,
    DWORD dwFlags);


void __RPC_STUB INetConnectionUiUtilities_QueryUserForReboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionUiUtilities_DisplayAddComponentDialog_Proxy( 
    INetConnectionUiUtilities * This,
    HWND hwndParent,
    INetCfg *pnc,
    CI_FILTER_INFO *pcfi);


void __RPC_STUB INetConnectionUiUtilities_DisplayAddComponentDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE INetConnectionUiUtilities_UserHasPermission_Proxy( 
    INetConnectionUiUtilities * This,
    DWORD dwPerm);


void __RPC_STUB INetConnectionUiUtilities_UserHasPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionUiUtilities_INTERFACE_DEFINED__ */


#ifndef __INetConnectionRefresh_INTERFACE_DEFINED__
#define __INetConnectionRefresh_INTERFACE_DEFINED__

/* interface INetConnectionRefresh */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionRefresh;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5F-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionRefresh : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionAdded( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionDeleted( 
            /* [in] */ const GUID *pguidId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionModified( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionRenamed( 
            /* [in] */ INetConnection *pConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectionStatusChanged( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const NETCON_STATUS ncs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowBalloon( 
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableEvents( 
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionRefreshVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionRefresh * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionRefresh * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionRefresh * This);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshAll )( 
            INetConnectionRefresh * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionAdded )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionDeleted )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionModified )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionRenamed )( 
            INetConnectionRefresh * This,
            /* [in] */ INetConnection *pConnection);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectionStatusChanged )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const NETCON_STATUS ncs);
        
        HRESULT ( STDMETHODCALLTYPE *ShowBalloon )( 
            INetConnectionRefresh * This,
            /* [in] */ const GUID *pguidId,
            /* [in] */ const BSTR szCookie,
            /* [in] */ const BSTR szBalloonText);
        
        HRESULT ( STDMETHODCALLTYPE *DisableEvents )( 
            INetConnectionRefresh * This,
            /* [in] */ const BOOL fDisable,
            /* [in] */ const ULONG ulDisableTimeout);
        
        END_INTERFACE
    } INetConnectionRefreshVtbl;

    interface INetConnectionRefresh
    {
        CONST_VTBL struct INetConnectionRefreshVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionRefresh_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionRefresh_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionRefresh_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionRefresh_RefreshAll(This)	\
    (This)->lpVtbl -> RefreshAll(This)

#define INetConnectionRefresh_ConnectionAdded(This,pConnection)	\
    (This)->lpVtbl -> ConnectionAdded(This,pConnection)

#define INetConnectionRefresh_ConnectionDeleted(This,pguidId)	\
    (This)->lpVtbl -> ConnectionDeleted(This,pguidId)

#define INetConnectionRefresh_ConnectionModified(This,pConnection)	\
    (This)->lpVtbl -> ConnectionModified(This,pConnection)

#define INetConnectionRefresh_ConnectionRenamed(This,pConnection)	\
    (This)->lpVtbl -> ConnectionRenamed(This,pConnection)

#define INetConnectionRefresh_ConnectionStatusChanged(This,pguidId,ncs)	\
    (This)->lpVtbl -> ConnectionStatusChanged(This,pguidId,ncs)

#define INetConnectionRefresh_ShowBalloon(This,pguidId,szCookie,szBalloonText)	\
    (This)->lpVtbl -> ShowBalloon(This,pguidId,szCookie,szBalloonText)

#define INetConnectionRefresh_DisableEvents(This,fDisable,ulDisableTimeout)	\
    (This)->lpVtbl -> DisableEvents(This,fDisable,ulDisableTimeout)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionRefresh_RefreshAll_Proxy( 
    INetConnectionRefresh * This);


void __RPC_STUB INetConnectionRefresh_RefreshAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionAdded_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionDeleted_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId);


void __RPC_STUB INetConnectionRefresh_ConnectionDeleted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionModified_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionRenamed_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ INetConnection *pConnection);


void __RPC_STUB INetConnectionRefresh_ConnectionRenamed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ConnectionStatusChanged_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const NETCON_STATUS ncs);


void __RPC_STUB INetConnectionRefresh_ConnectionStatusChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_ShowBalloon_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const GUID *pguidId,
    /* [in] */ const BSTR szCookie,
    /* [in] */ const BSTR szBalloonText);


void __RPC_STUB INetConnectionRefresh_ShowBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionRefresh_DisableEvents_Proxy( 
    INetConnectionRefresh * This,
    /* [in] */ const BOOL fDisable,
    /* [in] */ const ULONG ulDisableTimeout);


void __RPC_STUB INetConnectionRefresh_DisableEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionRefresh_INTERFACE_DEFINED__ */


#ifndef __INetConnectionCMUtil_INTERFACE_DEFINED__
#define __INetConnectionCMUtil_INTERFACE_DEFINED__

/* interface INetConnectionCMUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionCMUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF60-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionCMUtil : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapCMHiddenConnectionToOwner( 
            /* [in] */ REFGUID guidHidden,
            /* [out] */ GUID *pguidOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionCMUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionCMUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionCMUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionCMUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapCMHiddenConnectionToOwner )( 
            INetConnectionCMUtil * This,
            /* [in] */ REFGUID guidHidden,
            /* [out] */ GUID *pguidOwner);
        
        END_INTERFACE
    } INetConnectionCMUtilVtbl;

    interface INetConnectionCMUtil
    {
        CONST_VTBL struct INetConnectionCMUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionCMUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionCMUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionCMUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionCMUtil_MapCMHiddenConnectionToOwner(This,guidHidden,pguidOwner)	\
    (This)->lpVtbl -> MapCMHiddenConnectionToOwner(This,guidHidden,pguidOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionCMUtil_MapCMHiddenConnectionToOwner_Proxy( 
    INetConnectionCMUtil * This,
    /* [in] */ REFGUID guidHidden,
    /* [out] */ GUID *pguidOwner);


void __RPC_STUB INetConnectionCMUtil_MapCMHiddenConnectionToOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionCMUtil_INTERFACE_DEFINED__ */


#ifndef __INetConnectionHNetUtil_INTERFACE_DEFINED__
#define __INetConnectionHNetUtil_INTERFACE_DEFINED__

/* interface INetConnectionHNetUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionHNetUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF64-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionHNetUtil : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyUpdate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionHNetUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionHNetUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionHNetUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionHNetUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyUpdate )( 
            INetConnectionHNetUtil * This);
        
        END_INTERFACE
    } INetConnectionHNetUtilVtbl;

    interface INetConnectionHNetUtil
    {
        CONST_VTBL struct INetConnectionHNetUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionHNetUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionHNetUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionHNetUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionHNetUtil_NotifyUpdate(This)	\
    (This)->lpVtbl -> NotifyUpdate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionHNetUtil_NotifyUpdate_Proxy( 
    INetConnectionHNetUtil * This);


void __RPC_STUB INetConnectionHNetUtil_NotifyUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionHNetUtil_INTERFACE_DEFINED__ */


#ifndef __INetConnectionSysTray_INTERFACE_DEFINED__
#define __INetConnectionSysTray_INTERFACE_DEFINED__

/* interface INetConnectionSysTray */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionSysTray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF65-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionSysTray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowIcon( 
            /* [in] */ const BOOL bShowIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IconStateChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionSysTrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionSysTray * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionSysTray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionSysTray * This);
        
        HRESULT ( STDMETHODCALLTYPE *ShowIcon )( 
            INetConnectionSysTray * This,
            /* [in] */ const BOOL bShowIcon);
        
        HRESULT ( STDMETHODCALLTYPE *IconStateChanged )( 
            INetConnectionSysTray * This);
        
        END_INTERFACE
    } INetConnectionSysTrayVtbl;

    interface INetConnectionSysTray
    {
        CONST_VTBL struct INetConnectionSysTrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionSysTray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionSysTray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionSysTray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionSysTray_ShowIcon(This,bShowIcon)	\
    (This)->lpVtbl -> ShowIcon(This,bShowIcon)

#define INetConnectionSysTray_IconStateChanged(This)	\
    (This)->lpVtbl -> IconStateChanged(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionSysTray_ShowIcon_Proxy( 
    INetConnectionSysTray * This,
    /* [in] */ const BOOL bShowIcon);


void __RPC_STUB INetConnectionSysTray_ShowIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionSysTray_IconStateChanged_Proxy( 
    INetConnectionSysTray * This);


void __RPC_STUB INetConnectionSysTray_IconStateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionSysTray_INTERFACE_DEFINED__ */


#ifndef __INetMachinePolicies_INTERFACE_DEFINED__
#define __INetMachinePolicies_INTERFACE_DEFINED__

/* interface INetMachinePolicies */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetMachinePolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF68-31FE-11D1-AAD2-00805FC1270E")
    INetMachinePolicies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VerifyPermission( 
            /* [in] */ const DWORD ulPerm,
            /* [out] */ BOOL *pPermission) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetMachinePoliciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetMachinePolicies * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetMachinePolicies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetMachinePolicies * This);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyPermission )( 
            INetMachinePolicies * This,
            /* [in] */ const DWORD ulPerm,
            /* [out] */ BOOL *pPermission);
        
        END_INTERFACE
    } INetMachinePoliciesVtbl;

    interface INetMachinePolicies
    {
        CONST_VTBL struct INetMachinePoliciesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetMachinePolicies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetMachinePolicies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetMachinePolicies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetMachinePolicies_VerifyPermission(This,ulPerm,pPermission)	\
    (This)->lpVtbl -> VerifyPermission(This,ulPerm,pPermission)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetMachinePolicies_VerifyPermission_Proxy( 
    INetMachinePolicies * This,
    /* [in] */ const DWORD ulPerm,
    /* [out] */ BOOL *pPermission);


void __RPC_STUB INetMachinePolicies_VerifyPermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetMachinePolicies_INTERFACE_DEFINED__ */


#ifndef __INetConnectionManagerDebug_INTERFACE_DEFINED__
#define __INetConnectionManagerDebug_INTERFACE_DEFINED__

/* interface INetConnectionManagerDebug */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionManagerDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF5D-31FE-11D1-AAD2-00805FC1270E")
    INetConnectionManagerDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyTestStart( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyTestStop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionManagerDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetConnectionManagerDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetConnectionManagerDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetConnectionManagerDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyTestStart )( 
            INetConnectionManagerDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyTestStop )( 
            INetConnectionManagerDebug * This);
        
        END_INTERFACE
    } INetConnectionManagerDebugVtbl;

    interface INetConnectionManagerDebug
    {
        CONST_VTBL struct INetConnectionManagerDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionManagerDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetConnectionManagerDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetConnectionManagerDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetConnectionManagerDebug_NotifyTestStart(This)	\
    (This)->lpVtbl -> NotifyTestStart(This)

#define INetConnectionManagerDebug_NotifyTestStop(This)	\
    (This)->lpVtbl -> NotifyTestStop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetConnectionManagerDebug_NotifyTestStart_Proxy( 
    INetConnectionManagerDebug * This);


void __RPC_STUB INetConnectionManagerDebug_NotifyTestStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetConnectionManagerDebug_NotifyTestStop_Proxy( 
    INetConnectionManagerDebug * This);


void __RPC_STUB INetConnectionManagerDebug_NotifyTestStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetConnectionManagerDebug_INTERFACE_DEFINED__ */


#ifndef __ISharedAccessBeacon_INTERFACE_DEFINED__
#define __ISharedAccessBeacon_INTERFACE_DEFINED__

/* interface ISharedAccessBeacon */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISharedAccessBeacon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF6B-31FE-11D1-AAD2-00805FC1270E")
    ISharedAccessBeacon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ NETCON_MEDIATYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalAdapterGUID( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **__MIDL_0018) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueDeviceName( 
            /* [out] */ BSTR *pUDN) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedAccessBeaconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedAccessBeacon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedAccessBeacon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedAccessBeacon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            ISharedAccessBeacon * This,
            /* [out] */ NETCON_MEDIATYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalAdapterGUID )( 
            ISharedAccessBeacon * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            ISharedAccessBeacon * This,
            /* [in] */ SAHOST_SERVICES ulService,
            /* [out] */ IUPnPService **__MIDL_0018);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueDeviceName )( 
            ISharedAccessBeacon * This,
            /* [out] */ BSTR *pUDN);
        
        END_INTERFACE
    } ISharedAccessBeaconVtbl;

    interface ISharedAccessBeacon
    {
        CONST_VTBL struct ISharedAccessBeaconVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedAccessBeacon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedAccessBeacon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedAccessBeacon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedAccessBeacon_GetMediaType(This,pMediaType)	\
    (This)->lpVtbl -> GetMediaType(This,pMediaType)

#define ISharedAccessBeacon_GetLocalAdapterGUID(This,pGuid)	\
    (This)->lpVtbl -> GetLocalAdapterGUID(This,pGuid)

#define ISharedAccessBeacon_GetService(This,ulService,__MIDL_0018)	\
    (This)->lpVtbl -> GetService(This,ulService,__MIDL_0018)

#define ISharedAccessBeacon_GetUniqueDeviceName(This,pUDN)	\
    (This)->lpVtbl -> GetUniqueDeviceName(This,pUDN)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetMediaType_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ NETCON_MEDIATYPE *pMediaType);


void __RPC_STUB ISharedAccessBeacon_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetLocalAdapterGUID_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB ISharedAccessBeacon_GetLocalAdapterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetService_Proxy( 
    ISharedAccessBeacon * This,
    /* [in] */ SAHOST_SERVICES ulService,
    /* [out] */ IUPnPService **__MIDL_0018);


void __RPC_STUB ISharedAccessBeacon_GetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISharedAccessBeacon_GetUniqueDeviceName_Proxy( 
    ISharedAccessBeacon * This,
    /* [out] */ BSTR *pUDN);


void __RPC_STUB ISharedAccessBeacon_GetUniqueDeviceName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedAccessBeacon_INTERFACE_DEFINED__ */


#ifndef __ISharedAccessBeaconFinder_INTERFACE_DEFINED__
#define __ISharedAccessBeaconFinder_INTERFACE_DEFINED__

/* interface ISharedAccessBeaconFinder */
/* [object][unique][uuid] */ 

typedef struct tagSHAREDACCESS_HOST_INFO
    {
    BSTR WANAccessType;
    IUPnPService *pOSInfo;
    IUPnPService *pWANCommonInterfaceConfig;
    IUPnPService *pWANConnection;
    GUID LocalAdapterGuid;
    } 	SHAREDACCESS_HOST_INFO;


EXTERN_C const IID IID_ISharedAccessBeaconFinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAEDCF67-31FE-11D1-AAD2-00805FC1270E")
    ISharedAccessBeaconFinder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSharedAccessBeacon( 
            /* [in] */ BSTR DeviceId,
            /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedAccessBeaconFinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISharedAccessBeaconFinder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISharedAccessBeaconFinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISharedAccessBeaconFinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharedAccessBeacon )( 
            ISharedAccessBeaconFinder * This,
            /* [in] */ BSTR DeviceId,
            /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon);
        
        END_INTERFACE
    } ISharedAccessBeaconFinderVtbl;

    interface ISharedAccessBeaconFinder
    {
        CONST_VTBL struct ISharedAccessBeaconFinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedAccessBeaconFinder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedAccessBeaconFinder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedAccessBeaconFinder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedAccessBeaconFinder_GetSharedAccessBeacon(This,DeviceId,ppSharedAccessBeacon)	\
    (This)->lpVtbl -> GetSharedAccessBeacon(This,DeviceId,ppSharedAccessBeacon)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISharedAccessBeaconFinder_GetSharedAccessBeacon_Proxy( 
    ISharedAccessBeaconFinder * This,
    /* [in] */ BSTR DeviceId,
    /* [out] */ ISharedAccessBeacon **ppSharedAccessBeacon);


void __RPC_STUB ISharedAccessBeaconFinder_GetSharedAccessBeacon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedAccessBeaconFinder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netconp_0348 */
/* [local] */ 


EXTERN_C HRESULT WINAPI HrGetIconFromMediaType (
  /* [in]    */  DWORD dwIconSize,
  /* [in]    */  NETCON_MEDIATYPE ncm,
  /* [in]    */  NETCON_SUBMEDIATYPE ncsm,
  /* [in]    */  DWORD dwConnectionIcon,
  /* [in]    */  DWORD dwCharacteristics,
  /* [out]   */  HICON *phIcon);



extern RPC_IF_HANDLE __MIDL_itf_netconp_0348_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netconp_0348_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ntddip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddip.h

Abstract:

    This header file defines constants and types for accessing the NT
    IP driver.

Author:

    Mike Massa (mikemas) 13-Aug-1993

Revision History:

--*/

#ifndef _NTDDIP_
#define _NTDDIP_
#pragma once

#include <ipexport.h>

#pragma warning(push)
#pragma warning(disable:4214) // bit field types other than int

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
#define DD_IP_DEVICE_NAME           L"\\Device\\Ip"
#define DD_IP_SYMBOLIC_DEVICE_NAME  L"\\DosDevices\\Ip"

#define IP_ADDRTYPE_TRANSIENT 0x01


//
// Structures used in IOCTLs.
//
typedef struct set_ip_address_request {
    USHORT          Context;        // Context value for the target NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
} IP_SET_ADDRESS_REQUEST, *PIP_SET_ADDRESS_REQUEST;

//
// Structures used in IOCTLs.
//
typedef struct set_ip_address_request_ex {
    USHORT          Context;        // Context value for the target NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    USHORT          Type;           // Type of address being added
} IP_SET_ADDRESS_REQUEST_EX, *PIP_SET_ADDRESS_REQUEST_EX;


typedef struct set_dhcp_interface_request {
    ULONG           Context;        // Context value identifying the NTE
                                    // Valid contexts are 16 bit quantities.
} IP_SET_DHCP_INTERFACE_REQUEST, *PIP_SET_DHCP_INTERFACE_REQUEST;

typedef struct add_ip_nte_request {
    ULONG           InterfaceContext; // Context value for the IP interface
                                    // to which to add the NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    UNICODE_STRING  InterfaceName;  // Interface name when interface context
                                    // is 0xffff
    CHAR            InterfaceNameBuffer[1]; // Buffer to hold interface name
                                    // from above

} IP_ADD_NTE_REQUEST, *PIP_ADD_NTE_REQUEST;

#if defined(_WIN64)

typedef struct add_ip_nte_request32 {
    ULONG           InterfaceContext; // Context value for the IP interface
                                    // to which to add the NTE
    IPAddr          Address;        // IP address to set, or zero to clear
    IPMask          SubnetMask;     // Subnet mask to set
    UNICODE_STRING32 InterfaceName; // Interface name when interface context
                                    // is 0xffff
    CHAR            InterfaceNameBuffer[1]; // Buffer to hold interface name
                                    // from above

} IP_ADD_NTE_REQUEST32, *PIP_ADD_NTE_REQUEST32;

#endif // _WIN64

typedef struct _ip_rtchange_notify {
    IPAddr          Addr;
    IPMask          Mask;
} IP_RTCHANGE_NOTIFY, *PIP_RTCHANGE_NOTIFY;

typedef struct _ip_addchange_notify {
    IPAddr          Addr;
    IPMask          Mask;
    PVOID           pContext;
    USHORT          IPContext;
    ULONG           AddrAdded;
    ULONG           UniAddr;
    UNICODE_STRING  ConfigName;
    CHAR            NameData[1];
} IP_ADDCHANGE_NOTIFY, *PIP_ADDCHANGE_NOTIFY;

typedef struct _ip_ifchange_notify
{
    USHORT          Context;
    UCHAR           Pad[2];
    ULONG           IfAdded;
} IP_IFCHANGE_NOTIFY, *PIP_IFCHANGE_NOTIFY;

typedef struct add_ip_nte_request_old {
    USHORT          InterfaceContext; // Context value for the IP interface
                                // to which to add the NTE
    IPAddr          Address;    // IP address to set, or zero to clear
    IPMask          SubnetMask; // Subnet mask to set
} IP_ADD_NTE_REQUEST_OLD, *PIP_ADD_NTE_REQUEST_OLD;

typedef struct add_ip_nte_response {
    USHORT          Context;    // Context value for the new NTE
    ULONG           Instance;   // Instance ID for the new NTE
} IP_ADD_NTE_RESPONSE, *PIP_ADD_NTE_RESPONSE;

typedef struct delete_ip_nte_request {
    USHORT          Context;    // Context value for the NTE
} IP_DELETE_NTE_REQUEST, *PIP_DELETE_NTE_REQUEST;

typedef struct get_ip_nte_info_request {
    USHORT          Context;    // Context value for the NTE
} IP_GET_NTE_INFO_REQUEST, *PIP_GET_NTE_INFO_REQUEST;

typedef struct get_ip_nte_info_response {
    ULONG           Instance;   // Instance ID for the NTE
    IPAddr          Address;
    IPMask          SubnetMask;
    ULONG           Flags;
} IP_GET_NTE_INFO_RESPONSE, *PIP_GET_NTE_INFO_RESPONSE;

typedef struct  _net_pm_wakeup_pattern_desc {
    struct  _net_pm_wakeup_pattern_desc *Next; // points to the next descriptor
                                // on the list.
    UCHAR           *Ptrn;      // the wakeup pattern
    UCHAR           *Mask;      // bit mask for matching wakeup pattern,
                                // 1 -match, 0 - ignore
    USHORT          PtrnLen;    // length of the Pattern. len of mask
                                // is retrieved via GetWakeupPatternMaskLength
} NET_PM_WAKEUP_PATTERN_DESC, *PNET_PM_WAKEUP_PATTERN_DESC;

typedef struct wakeup_pattern_request {
    ULONG           InterfaceContext; // Context value
    PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc; // higher level protocol pattern
                                // descriptor
    BOOLEAN         AddPattern; // TRUE - Add, FALSE - Delete
} IP_WAKEUP_PATTERN_REQUEST, *PIP_WAKEUP_PATTERN_REQUEST;

typedef struct ip_get_ip_event_response {
    ULONG           SequenceNo; // SequenceNo of the this event
    USHORT          ContextStart; // Context value for the first NTE of the
                                // adapter.
    USHORT          ContextEnd; // Context value for the last NTE of the adapter
    IP_STATUS       MediaStatus; // Status of the media.
    UNICODE_STRING  AdapterName;
} IP_GET_IP_EVENT_RESPONSE, *PIP_GET_IP_EVENT_RESPONSE;

typedef struct ip_get_ip_event_request {
    ULONG           SequenceNo; // SequenceNo of the last event notified.
} IP_GET_IP_EVENT_REQUEST, *PIP_GET_IP_EVENT_REQUEST;

#define IP_PNP_RECONFIG_VERSION 2
typedef struct ip_pnp_reconfig_request {
    USHORT          version;
    USHORT          arpConfigOffset; // If 0, this is an IP layer request;
                                // else this is the offset from the start
                                // of this structure at which the ARP layer
                                // reconfig request is located.
    BOOLEAN         gatewayListUpdate; // is gateway list changed?
    BOOLEAN         IPEnableRouter; // is ip forwarding on?
    UCHAR           PerformRouterDiscovery : 4; // is PerformRouterDiscovery on?
    BOOLEAN         DhcpPerformRouterDiscovery : 4; // has DHCP server specified
                                // IRDP?
    BOOLEAN         EnableSecurityFilter; // Enable/disable security filter
    BOOLEAN         InterfaceMetricUpdate; // re-read interface metric

    UCHAR           Flags;      // mask of valid fields
    USHORT          NextEntryOffset; // the offset from the start of this
                                // structure at which the next
                                // reconfig entry for the IP layer
                                // (if any) is located.

} IP_PNP_RECONFIG_REQUEST, *PIP_PNP_RECONFIG_REQUEST;

#define IP_IRDP_DISABLED            0
#define IP_IRDP_ENABLED             1
#define IP_IRDP_DISABLED_USE_DHCP   2

#define IP_PNP_FLAG_IP_ENABLE_ROUTER                0x01
#define IP_PNP_FLAG_PERFORM_ROUTER_DISCOVERY        0x02
#define IP_PNP_FLAG_ENABLE_SECURITY_FILTER          0x04
#define IP_PNP_FLAG_GATEWAY_LIST_UPDATE             0x08
#define IP_PNP_FLAG_INTERFACE_METRIC_UPDATE         0x10
#define IP_PNP_FLAG_DHCP_PERFORM_ROUTER_DISCOVERY   0x20
#define IP_PNP_FLAG_INTERFACE_TCP_PARAMETER_UPDATE  0x40
#define IP_PNP_FLAG_ALL                             0x6f

typedef enum {
    IPPnPInitCompleteEntryType = 1,
    IPPnPMaximumEntryType
} IP_PNP_RECONFIG_ENTRY_TYPE;

typedef struct ip_pnp_reconfig_header {
    USHORT          NextEntryOffset;
    UCHAR           EntryType;
} IP_PNP_RECONFIG_HEADER, *PIP_PNP_RECONFIG_HEADER;

typedef struct ip_pnp_init_complete {
    IP_PNP_RECONFIG_HEADER Header;
} IP_PNP_INIT_COMPLETE, *PIP_PNP_INIT_COMPLETE;

//
// Enumerated data type for Query procedure in NetBT
//
enum DnsOption {
    WinsOnly =0,
    WinsThenDns,
    DnsOnly
};

typedef struct netbt_pnp_reconfig_request {
    USHORT          version;            // always 1
    enum DnsOption  enumDnsOption;      // Enable Dns box. 3 states: WinsOnly,
                                        // WinsThenDns, DnsOnly
    BOOLEAN         fLmhostsEnabled;    // EnableLmhosts box is checked.
                                        // Checked: TRUE, unchecked: FALSE
    BOOLEAN         fLmhostsFileSet;    // TRUE <==> user has successfully
                                        // chosen a file & filecopy succeeded
    BOOLEAN         fScopeIdUpdated;    // True if the new value for ScopeId
                                        // is different from the old
} NETBT_PNP_RECONFIG_REQUEST, *PNETBT_PNP_RECONFIG_REQUEST;


typedef struct _ip_set_if_promiscuous_info {
    ULONG           Index;  // IP's interface index
    UCHAR           Type;   // PROMISCUOUS_MCAST or PROMISCUOUS_BCAST
    UCHAR           Add;    // 1 to add, 0 to delete
} IP_SET_IF_PROMISCUOUS_INFO, *PIP_SET_IF_PROMISCUOUS_INFO;

#define PROMISCUOUS_MCAST   0
#define PROMISCUOUS_BCAST   1

typedef struct _ip_get_if_index_info {
    ULONG           Index;
    WCHAR           Name[1];
} IP_GET_IF_INDEX_INFO, *PIP_GET_IF_INDEX_INFO;

#ifndef IP_INTERFACE_NAME_INFO_DEFINED
#define IP_INTERFACE_NAME_INFO_DEFINED

typedef struct ip_interface_name_info {
    ULONG           Index;      // Interface Index
    ULONG           MediaType;  // Interface Types - see ipifcons.h
    UCHAR           ConnectionType;
    UCHAR           AccessType;
    GUID            DeviceGuid; // Device GUID is the guid of the device
                                // that IP exposes
    GUID            InterfaceGuid; // Interface GUID, if not GUID_NULL is the
                                // GUID for the interface mapped to the device.
} IP_INTERFACE_NAME_INFO, *PIP_INTERFACE_NAME_INFO;

#endif

typedef struct _ip_get_if_name_info {
    ULONG           Context;    // Set this to 0 to start enumeration
                                // To resume enumeration, copy the value
                                // returned by the last enum
    ULONG           Count;
    IP_INTERFACE_NAME_INFO  Info[1];
} IP_GET_IF_NAME_INFO, *PIP_GET_IF_NAME_INFO;

//
// NTE Flags
//

#define IP_NTE_DYNAMIC  0x00000010

//
// IP IOCTL code definitions
//

#define FSCTL_IP_BASE     FILE_DEVICE_NETWORK

#define _IP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IP_BASE, function, method, access)

//
// This IOCTL is used to send an ICMP Echo request. It is synchronous and
// returns any replies received.
//
#define IOCTL_ICMP_ECHO_REQUEST \
            _IP_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL is used to set the IP address for an interface. It is meant to
// be issued by a DHCP client. Setting the address to 0 deletes the current
// address and disables the interface. It may only be issued by a process
// with Administrator privilege.
//
#define IOCTL_IP_SET_ADDRESS  \
            _IP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL is used to specify on which uninitialized interface a DHCP
// client intends to send its requests. The Interface Context parameter is
// a 16-bit quantity. The IOCTL takes a 32-bit Context as its argument. This
// IOCTL with a Context value of 0xFFFFFFFF must be issued to disable special
// processing in IP when a DHCP client is finished initializing interfaces.
// This IOCTL may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_DHCP_INTERFACE  \
            _IP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_IF_CONTEXT  \
            _IP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_FILTER_POINTER  \
            _IP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_SET_MAP_ROUTE_POINTER  \
            _IP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl may only be issued by a process with Administrator privilege.
//
#define IOCTL_IP_GET_PNP_ARP_POINTERS  \
            _IP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl creates a new, dynamic NTE. It may only be issued by a process
// with Administrator privilege.
//
#define IOCTL_IP_ADD_NTE  \
            _IP_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl deletes a dynamic NTE. It may only be issued by a process with
// Administrator privilege.
//
#define IOCTL_IP_DELETE_NTE  \
            _IP_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl gathers information about an NTE. It requires no special
// privilege.
//
#define IOCTL_IP_GET_NTE_INFO  \
            _IP_CTL_CODE(9, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This ioctl adds or removes wakeup patterns
//
#define IOCTL_IP_WAKEUP_PATTERN  \
            _IP_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl allows DHCP to get media sense notifications.
//
#define IOCTL_IP_GET_IP_EVENT  \
            _IP_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This ioctl may only be issued by a process with Administrator privilege.
//

#define IOCTL_IP_SET_FIREWALL_HOOK  \
            _IP_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST  \
            _IP_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST  \
            _IP_CTL_CODE(14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ARP_SEND_REQUEST  \
            _IP_CTL_CODE(15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_INTERFACE_INFO  \
            _IP_CTL_CODE(16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_BEST_INTERFACE  \
            _IP_CTL_CODE(17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_SET_IF_PROMISCUOUS \
            _IP_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_FLUSH_ARP_TABLE \
            _IP_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_IGMPLIST  \
            _IP_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_SET_BLOCKOFROUTES  \
            _IP_CTL_CODE(23, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_ROUTEWITHREF  \
            _IP_CTL_CODE(24, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_IF_INDEX       \
            _IP_CTL_CODE(26, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_IF_NAME        \
            _IP_CTL_CODE(27, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_BESTINTFC_FUNC_ADDR        \
            _IP_CTL_CODE(28, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_MULTIHOPROUTE  \
            _IP_CTL_CODE(29, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_WOL_CAPABILITY  \
            _IP_CTL_CODE(30, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX  \
            _IP_CTL_CODE(31, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ENABLE_ROUTER_REQUEST \
            _IP_CTL_CODE(32, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_UNENABLE_ROUTER_REQUEST \
            _IP_CTL_CODE(33, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_GET_OFFLOAD_CAPABILITY \
            _IP_CTL_CODE(34, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_IFCHANGE_NOTIFY_REQUEST \
            _IP_CTL_CODE(35, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS \
            _IP_CTL_CODE(36, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_GET_MCAST_COUNTERS \
            _IP_CTL_CODE(37, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IP_ENABLE_MEDIA_SENSE_REQUEST \
            _IP_CTL_CODE(38, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST \
            _IP_CTL_CODE(39, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_SET_ADDRESS_EX  \
            _IP_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IP_CANCEL_CHANGE_NOTIFY \
            _IP_CTL_CODE(41, METHOD_BUFFERED, FILE_ANY_ACCESS)

#pragma warning(pop)
#endif // _NTDDIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ntddtc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddtc.h

Abstract:

    This module contains type definitions for the interface between the 
    traffic dll and kernel mode components.
    Definitions here should not be exposed to the external user.
    'traffic.h' and 'qos.h' should be used as public include files instead.

Author:

    Ofer Bar ( oferbar )    Oct 8, 1997

Revision History:

    Ofer Bar ( oferbar )    Dec 1, 1997

        Add error codes

--*/

//---------------------------------------------------------------------------
// 
//      QoS supported guid
// 
//---------------------------------------------------------------------------

DEFINE_GUID( GUID_QOS_TC_SUPPORTED, 0xe40056dcL, 
             0x40c8, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x59, 0x15);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_UP_INDICATION, 
             0x0ca13af0L, 0x46c4, 0x11d1, 0x78, 0xac, 0x00, 0x80, 0x5f, 0x68, 0x35, 0x1e);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_DOWN_INDICATION, 
             0xaf5315e4L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_CHANGE_INDICATION, 
             0xda76a254L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);

DEFINE_GUID( GUID_QOS_SCHEDULING_PROFILES_SUPPORTED, 0x1ff890f0L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_CURRENT_SCHEDULING_PROFILE, 0x2966ed30L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_DISABLE_DRR, 0x1fa6dc7aL, 0x6120, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD_REACHED, 0x357b74d2L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_BUFFER_SIZE, 0x357b74d3L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD, 0x357b74d0L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_DATA, 0x357b74d1L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_LEVEL,0x9dd7f3ae,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);

DEFINE_GUID( GUID_QOS_LOG_MASK,0x9e696320,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);



#ifndef __NTDDTC_H
#define __NTDDTC_H

//
// Kernel NT private error codes
// these should be only returned to the GPC but not
// to NDIS, since WMI will not map them to winerror
//

#define QOS_STATUS_INVALID_SERVICE_TYPE        0xC0020080L
#define QOS_STATUS_INVALID_TOKEN_RATE          0xC0020081L
#define QOS_STATUS_INVALID_PEAK_RATE           0xC0020082L
#define QOS_STATUS_INVALID_SD_MODE             0xC0020083L
#define QOS_STATUS_INVALID_QOS_PRIORITY        0xC0020084L
#define QOS_STATUS_INVALID_TRAFFIC_CLASS       0xC0020085L
#define QOS_STATUS_TC_OBJECT_LENGTH_INVALID    0xC0020086L
#define QOS_STATUS_INVALID_FLOW_MODE           0xC0020087L
#define QOS_STATUS_INVALID_DIFFSERV_FLOW       0xC0020088L
#define QOS_STATUS_DS_MAPPING_EXISTS           0xC0020089L
#define QOS_STATUS_INVALID_SHAPE_RATE          0xC0020090L
#define QOS_STATUS_INVALID_DS_CLASS            0xC0020091L

//
// These are the public QOS error codes
//

#define QOS_STATUS_INCOMPATABLE_QOS                     NDIS_STATUS_INCOMPATABLE_QOS

// The CF_INFO structure for the QoS classification family.
// Note that this is not interpreted by the GPC, but it is shared by 
// all clients of the GPC which are of the QoS classification family.

#define MAX_INSTANCE_NAME_LENGTH        256


typedef struct _CF_INFO_QOS {

    USHORT                      InstanceNameLength;     // name length
    WCHAR                       InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name

    union {
        struct QosCfTransportInfo {
            ULONG                       ToSValue :8;
            ULONG                       AllowedOffloads :24;
        };
        ULONG                       TransportInformation;
    };
    
    ULONG                       Flags;
    TC_GEN_FLOW                 GenFlow;

} CF_INFO_QOS, *PCF_INFO_QOS;


//
// This is the buffer that the data provider sends up 
// on Interface Up notification
//
typedef struct _TC_INDICATION_BUFFER {

    ULONG                       SubCode;                // reason for notification
    TC_SUPPORTED_INFO_BUFFER    InfoBuffer;

} TC_INDICATION_BUFFER, *PTC_INDICATION_BUFFER;

//
// Definitions for the Class Map (including CBQ)
//

typedef struct _TC_CLASS_MAP_FLOW {

    ULONG             DefaultClass;                   // Default Class Id
    ULONG             ObjectsLength;                  // Length of Objects
    QOS_OBJECT_HDR    Objects;                                // Offset to Objects

} TC_CLASS_MAP_FLOW, *PTC_CLASS_MAP_FLOW;

typedef struct _CF_INFO_CLASS_MAP {

    USHORT                              InstanceNameLength;     // name length
    WCHAR                               InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name
    
    ULONG                               Flags;
    TC_CLASS_MAP_FLOW   ClassMapInfo;
    
} CF_INFO_CLASS_MAP, *PCF_INFO_CLASS_MAP;

//
// Internal QoS Objects start at this offset from the base
//

#define QOS_PRIVATE_GENERAL_ID_BASE 3000

#define QOS_OBJECT_WAN_MEDIA                   (0x00000001 + QOS_PRIVATE_GENERAL_ID_BASE)
        /* QOS_WAN_MEDIA structure passed */
#define QOS_OBJECT_SHAPER_QUEUE_DROP_MODE	   (0x00000002 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueDropMode structure */
#define QOS_OBJECT_SHAPER_QUEUE_LIMIT          (0x00000003 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueLimit structure */
#define QOS_OBJECT_PRIORITY                    (0x00000004 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_PRIORITY structure passed */

//
// This structure defines the media specific information needed by ndiswan to 
// create a flow.
//
typedef struct _QOS_WAN_MEDIA {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           LinkId[6];
    ULONG           ISSLOW;

} QOS_WAN_MEDIA, *LPQOS_WAN_MEDIA;


//
// This structure allows overriding of the default schema used to drop 
// packets when a flow's shaper queue limit is reached.
//
// DropMethod - 
// 	QOS_SHAPER_DROP_FROM_HEAD - Drop packets from
// 		the head of the queue until the new packet can be
// 		accepted into the shaper under the current limit.  This
// 		behavior is the default.
// 	QOS_SHAPER_DROP_INCOMING - Drop the incoming, 
// 		limit-offending packet.
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT_DROP_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            DropMode;

} QOS_SHAPER_QUEUE_LIMIT_DROP_MODE, *LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE;

#define QOS_SHAPER_DROP_INCOMING	0
#define QOS_SHAPER_DROP_FROM_HEAD	1

//
// This structure allows the default per-flow limit on the shaper queue
// size to be overridden.
//
// QueueSizeLimit - Limit, in bytes, of the size of the shaper queue
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            QueueSizeLimit;

} QOS_SHAPER_QUEUE_LIMIT, *LPQOS_SHAPER_QUEUE_LIMIT;


//
// This structure defines the absolute priorty of the flow.  Priorities in the 
// range of 0-7 are currently defined. Receive Priority is not currently used, 
// but may at some point in the future.
//
typedef struct _QOS_PRIORITY {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           SendPriority;     /* this gets mapped to layer 2 priority.*/
    UCHAR           SendFlags;        /* there are none currently defined.*/
    UCHAR           ReceivePriority;  /* this could be used to decide who 
                                       * gets forwarded up the stack first 
                                       * - not used now */
    UCHAR           Unused;

} QOS_PRIORITY, *LPQOS_PRIORITY;


#define PARAM_TYPE_GQOS_INFO        0xABC0DEF0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ntddip6.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This header file defines constants and types for accessing
// the MSR IPv6 driver via ioctls.
//


#ifndef _NTDDIP6_
#define _NTDDIP6_

#include <ipexport.h>

//
// We need a definition of CTL_CODE for use below.
// When compiling kernel components in the DDK environment,
// ntddk.h supplies this definition. Otherwise get it
// from devioctl.h in the SDK environment.
//
#ifndef CTL_CODE
#include <devioctl.h>
#endif

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

//
// We also need a definition of TDI_ADDRESS_IP6.
// In the DDK environment, tdi.h supplies this.
// We provide a definition here for the SDK environment.
//
#ifndef TDI_ADDRESS_LENGTH_IP6
#include <packon.h>
typedef struct _TDI_ADDRESS_IP6 {
    USHORT sin6_port;
    ULONG  sin6_flowinfo;
    USHORT sin6_addr[8];
    ULONG  sin6_scope_id;
} TDI_ADDRESS_IP6, *PTDI_ADDRESS_IP6;
#include <packoff.h>

#define TDI_ADDRESS_LENGTH_IP6 sizeof (TDI_ADDRESS_IP6)
#endif

//
// This is the key name of the TCP/IPv6 protocol stack in the registry.
// The protocol driver and the winsock helper both use it.
//
#define TCPIPV6_NAME L"Tcpip6"

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCPV6_DEVICE_NAME      L"\\Device\\Tcp6"
#define DD_UDPV6_DEVICE_NAME      L"\\Device\\Udp6"
#define DD_RAW_IPV6_DEVICE_NAME   L"\\Device\\RawIp6"
#define DD_IPV6_DEVICE_NAME       L"\\Device\\Ip6"

//
// The Windows-accessible device name.  It is the name that
// (prepended with "\\\\.\\") should be passed to CreateFile.
//
#define WIN_IPV6_BASE_DEVICE_NAME L"Ip6"
#define WIN_IPV6_DEVICE_NAME      L"\\\\.\\" WIN_IPV6_BASE_DEVICE_NAME


//
// When an interface is bound, we are passed a name beginning with
// IPV6_BIND_STRING_PREFIX.  However, we register our interfaces with
// TDI using names beginning with IPV6_EXPORT_STRING_PREFIX.
//
#define IPV6_BIND_STRING_PREFIX   L"\\DEVICE\\"
#define IPV6_EXPORT_STRING_PREFIX L"\\DEVICE\\TCPIP6_"

//
// For buffer sizing convenience, bound the link-layer address size.
//
#define MAX_LINK_LAYER_ADDRESS_LENGTH   64

//
// IPv6 IOCTL code definitions.
//
// The codes that use FILE_ANY_ACCESS are open to all users.
// The codes that use FILE_WRITE_ACCESS require local Administrator privs.
//

#define FSCTL_IPV6_BASE FILE_DEVICE_NETWORK

#define _IPV6_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IPV6_BASE, function, method, access)


//
// This IOCTL is used to send an ICMPv6 Echo request.
// It returns the reply (unless there was a timeout or TTL expired).
//
#define IOCTL_ICMPV6_ECHO_REQUEST \
            _IPV6_CTL_CODE(0, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct icmpv6_echo_request {
    TDI_ADDRESS_IP6 DstAddress; // Destination address.
    TDI_ADDRESS_IP6 SrcAddress; // Source address.
    unsigned int Timeout;       // Request timeout in milliseconds.
    unsigned char TTL;          // TTL or Hop Count.
    unsigned int Flags;
    // Request data follows this structure in memory.
} ICMPV6_ECHO_REQUEST, *PICMPV6_ECHO_REQUEST;

#define ICMPV6_ECHO_REQUEST_FLAG_REVERSE        0x1     // Use routing header.

typedef struct icmpv6_echo_reply {
    TDI_ADDRESS_IP6 Address;    // Replying address.
    IP_STATUS Status;           // Reply IP_STATUS.
    unsigned int RoundTripTime; // RTT in milliseconds.
    // Reply data follows this structure in memory.
} ICMPV6_ECHO_REPLY, *PICMPV6_ECHO_REPLY;


//
// This IOCTL retrieves information about an interface,
// given an interface index or guid.
// It takes as input an IPV6_QUERY_INTERFACE structure
// and returns as output an IPV6_INFO_INTERFACE structure.
// To perform an iteration, start with Index set to -1, in which case
// only an IPV6_QUERY_INTERFACE is returned, for the first interface.
// If there are no more interfaces, then the Index in the returned
// IPV6_QUERY_INTERFACE will be -1.
//
#define IOCTL_IPV6_QUERY_INTERFACE \
            _IPV6_CTL_CODE(1, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_interface {
    unsigned int Index;         // -1 means start/finish iteration,
                                // 0 means use the Guid.
    GUID Guid;
} IPV6_QUERY_INTERFACE;

//
// This IOCTL retrieves persisted information about an interface,
// given a registry index or guid.
// It takes as input an IPV6_PERSISTENT_QUERY_INTERFACE structure
// and returns as output an IPV6_INFO_INTERFACE structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE \
            _IPV6_CTL_CODE(48, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_interface {
    unsigned int RegistryIndex; // -1 means use the Guid.
    GUID Guid;
} IPV6_PERSISTENT_QUERY_INTERFACE;

typedef struct ipv6_info_interface {
    IPV6_QUERY_INTERFACE Next;      // For non-persistent queries only.
    IPV6_QUERY_INTERFACE This;

    //
    // Length of this structure in bytes, not including
    // any link-layer addresses following in memory.
    //
    unsigned int Length;

    //
    // These fields are ignored for updates.
    //
    unsigned int LinkLayerAddressLength;
    unsigned int LocalLinkLayerAddress;  // Offset, zero indicates absence.
    unsigned int RemoteLinkLayerAddress; // Offset, zero indicates absence.

    unsigned int Type;                   // Ignored for updates.
    int RouterDiscovers;                 // Ignored for updates.
    int NeighborDiscovers;               // Ignored for updates.
    int PeriodicMLD;                     // Ignored for updates.
    int Advertises;                      // -1 means no change, else boolean.
    int Forwards;                        // -1 means no change, else boolean.
    unsigned int MediaStatus;            // Ignored for updates.
    int OtherStatefulConfig;             // Ignored for updates.

    unsigned int ZoneIndices[16];        // 0 means no change.

    unsigned int TrueLinkMTU;            // Ignored for updates.
    unsigned int LinkMTU;                // 0 means no change.
    unsigned int CurHopLimit;            // -1 means no change.
    unsigned int BaseReachableTime;      // Milliseconds, 0 means no change.
    unsigned int ReachableTime;          // Milliseconds, ignored for updates.
    unsigned int RetransTimer;           // Milliseconds, 0 means no change.
    unsigned int DupAddrDetectTransmits; // -1 means no change.
    unsigned int Preference;             // -1 means no change.
    int FirewallEnabled;                 // -1 means no change, else boolean.
    unsigned int DefSitePrefixLength;    // -1 means no change, 0 means none.

    // Link-layer addresses may follow.
} IPV6_INFO_INTERFACE;

//
// These values should agree with definitions also
// found in llip6if.h and ip6def.h.
//

#define IPV6_IF_TYPE_LOOPBACK           0
#define IPV6_IF_TYPE_ETHERNET           1
#define IPV6_IF_TYPE_FDDI               2
#define IPV6_IF_TYPE_TUNNEL_AUTO        3
#define IPV6_IF_TYPE_TUNNEL_6OVER4      4
#define IPV6_IF_TYPE_TUNNEL_V6V4        5
#define IPV6_IF_TYPE_TUNNEL_6TO4        6
#define IPV6_IF_TYPE_TUNNEL_TEREDO      7
#define IPV6_IF_TYPE_MIPV6              8

#define IPV6_IF_MEDIA_STATUS_DISCONNECTED       0
#define IPV6_IF_MEDIA_STATUS_RECONNECTED        1
#define IPV6_IF_MEDIA_STATUS_CONNECTED          2

//
// Initialize the fields of the IPV6_INFO_INTERFACE structure
// to values that indicate no change.
//
__inline void
IPV6_INIT_INFO_INTERFACE(IPV6_INFO_INTERFACE *Info)
{
    memset(Info, 0, sizeof *Info);
    Info->Length = sizeof *Info;

    Info->Type = (unsigned int)-1;
    Info->RouterDiscovers = -1;
    Info->NeighborDiscovers = -1;
    Info->PeriodicMLD = -1;
    Info->Advertises = -1;
    Info->Forwards = -1;
    Info->MediaStatus = (unsigned int)-1;

    Info->CurHopLimit = (unsigned int)-1;
    Info->DupAddrDetectTransmits = (unsigned int)-1;
    Info->Preference = (unsigned int)-1;
    Info->FirewallEnabled = -1;
    Info->DefSitePrefixLength = (unsigned int)-1;
}


//
// This IOCTL retrieves information about an address
// on an interface.
//
#define IOCTL_IPV6_QUERY_ADDRESS \
            _IPV6_CTL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_address {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_ADDRESS;

typedef struct ipv6_info_address {
    IPV6_QUERY_ADDRESS Next;
    IPV6_QUERY_ADDRESS This;

    unsigned int Type;
    unsigned int Scope;
    unsigned int ScopeId;

    union {
        struct {  // If it's a unicast address.
            unsigned int DADState;
            unsigned int PrefixConf;
            unsigned int InterfaceIdConf;
            unsigned int ValidLifetime;            // Seconds.
            unsigned int PreferredLifetime;        // Seconds.
        };
        struct {  // If it's a multicast address.
            unsigned int MCastRefCount;
            unsigned int MCastFlags;
            unsigned int MCastTimer;               // Seconds.
        };
    };
} IPV6_INFO_ADDRESS;

//
// Values for address Type.
//
#define ADE_UNICAST   0x00
#define ADE_ANYCAST   0x01
#define ADE_MULTICAST 0x02

//
// Values for address Scope.
//
#define ADE_SMALLEST_SCOPE      0x00
#define ADE_INTERFACE_LOCAL     0x01
#define ADE_LINK_LOCAL          0x02
#define ADE_SUBNET_LOCAL        0x03
#define ADE_ADMIN_LOCAL         0x04
#define ADE_SITE_LOCAL          0x05
#define ADE_ORG_LOCAL           0x08
#define ADE_GLOBAL              0x0e
#define ADE_LARGEST_SCOPE       0x0f

#define ADE_NUM_SCOPES          (ADE_LARGEST_SCOPE - ADE_SMALLEST_SCOPE + 1)

//
// Bit values for MCastFlags.
//
#define MAE_REPORTABLE          0x01
#define MAE_LAST_REPORTER       0x02

//
// Values for PrefixConf.
// These must match the IP_PREFIX_ORIGIN values in iptypes.h.
//
#define PREFIX_CONF_OTHER       0       // None of the ones below.
#define PREFIX_CONF_MANUAL      1       // From a user or administrator.
#define PREFIX_CONF_WELLKNOWN   2       // IANA-assigned.
#define PREFIX_CONF_DHCP        3       // Configured via DHCP.
#define PREFIX_CONF_RA          4       // From a Router Advertisement.

//
// Values for InterfaceIdConf.
// These must match the IP_SUFFIX_ORIGIN values in iptypes.h.
//
#define IID_CONF_OTHER          0       // None of the ones below.
#define IID_CONF_MANUAL         1       // From a user or administrator.
#define IID_CONF_WELLKNOWN      2       // IANA-assigned.
#define IID_CONF_DHCP           3       // Configured via DHCP.
#define IID_CONF_LL_ADDRESS     4       // Derived from the link-layer address.
#define IID_CONF_RANDOM         5       // Random, e.g. temporary address.

//
// Values for DADState.
//
// The low bit set indicates whether the state is valid.
// Among valid states, bigger is better
// for source address selection.
//
#define DAD_STATE_INVALID    0
#define DAD_STATE_TENTATIVE  1
#define DAD_STATE_DUPLICATE  2
#define DAD_STATE_DEPRECATED 3
#define DAD_STATE_PREFERRED  4

//
// We use this infinite lifetime value for prefix lifetimes,
// router lifetimes, address lifetimes, etc.
//
#define INFINITE_LIFETIME 0xffffffff


//
// This IOCTL retrieves information about an address
// that has been assigned persistently to an interface.
// It takes the IPV6_PERSISTENT_QUERY_ADDRESS structure
// and returns the IPV6_UPDATE_ADDRESS structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS \
            _IPV6_CTL_CODE(47, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_address {
    IPV6_PERSISTENT_QUERY_INTERFACE IF;
    unsigned int RegistryIndex; // -1 means use the Address.
    IPv6Addr Address;
} IPV6_PERSISTENT_QUERY_ADDRESS;


//
// This IOCTL retrieves information from the neighbor cache.
//
#define IOCTL_IPV6_QUERY_NEIGHBOR_CACHE \
            _IPV6_CTL_CODE(3, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_neighbor_cache {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_NEIGHBOR_CACHE;

typedef struct ipv6_info_neighbor_cache {
    IPV6_QUERY_NEIGHBOR_CACHE Query;

    unsigned int IsRouter;                // Whether neighbor is a router.
    unsigned int IsUnreachable;           // Whether neighbor is unreachable.
    unsigned int NDState;                 // Current state of entry.
    unsigned int ReachableTimer;          // Reachable time remaining (in ms).

    unsigned int LinkLayerAddressLength;
    // Link-layer address follows.
} IPV6_INFO_NEIGHBOR_CACHE;

#define ND_STATE_INCOMPLETE 0
#define ND_STATE_PROBE      1
#define ND_STATE_DELAY      2
#define ND_STATE_STALE      3
#define ND_STATE_REACHABLE  4
#define ND_STATE_PERMANENT  5

//
// This IOCTL retrieves information from the route cache.
//
#define IOCTL_IPV6_QUERY_ROUTE_CACHE \
            _IPV6_CTL_CODE(4, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_route_cache {
    IPV6_QUERY_INTERFACE IF;  // Fields that identify an interface.
    IPv6Addr Address;
} IPV6_QUERY_ROUTE_CACHE;

typedef struct ipv6_info_route_cache {
    IPV6_QUERY_ROUTE_CACHE Query;

    unsigned int Type;
    unsigned int Flags;
    int Valid;                      // Boolean - FALSE means it is stale.
    IPv6Addr SourceAddress;
    IPv6Addr NextHopAddress;
    unsigned int NextHopInterface;
    unsigned int PathMTU;
    unsigned int PMTUProbeTimer;    // Time until next PMTU probe (in ms).
    unsigned int ICMPLastError;     // Time since last ICMP error sent (in ms).
    unsigned int BindingSeqNumber;
    unsigned int BindingLifetime;   // Seconds.
    IPv6Addr CareOfAddress;
} IPV6_INFO_ROUTE_CACHE;

#define RCE_FLAG_CONSTRAINED_IF         0x1
#define RCE_FLAG_CONSTRAINED_SCOPEID    0x2
#define RCE_FLAG_CONSTRAINED            0x3

#define RCE_TYPE_COMPUTED 1
#define RCE_TYPE_REDIRECT 2


#if 0 // obsolete
//
// This IOCTL retrieves information from the prefix list.
//
#define IOCTL_IPV6_QUERY_PREFIX_LIST \
            _IPV6_CTL_CODE(5, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL retrieves information from the default router list.
//
#define IOCTL_IPV6_QUERY_ROUTER_LIST \
            _IPV6_CTL_CODE(6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL adds a multicast group to the desired interface.
//
#define IOCTL_IPV6_ADD_MEMBERSHIP \
            _IPV6_CTL_CODE(7, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL drops a multicast group.
//
#define IOCTL_IPV6_DROP_MEMBERSHIP \
            _IPV6_CTL_CODE(8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

//
// This IOCTL adds an SP to the SP list.
//
#define IOCTL_IPV6_CREATE_SECURITY_POLICY \
            _IPV6_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_create_security_policy {
    unsigned long SPIndex;                // Index of policy to create.

    unsigned int RemoteAddrField;
    unsigned int RemoteAddrSelector;
    IPv6Addr RemoteAddr;                  // Remote IP Address.
    IPv6Addr RemoteAddrData;

    unsigned int LocalAddrField;          // Single, range, or wildcard.
    unsigned int LocalAddrSelector;       // Packet or policy.
    IPv6Addr LocalAddr;                   // Start of range or single value.
    IPv6Addr LocalAddrData;               // End of range.

    unsigned int TransportProtoSelector;  // Packet or policy.
    unsigned short TransportProto;

    unsigned int RemotePortField;         // Single, range, or wildcard.
    unsigned int RemotePortSelector;      // Packet or policy.
    unsigned short RemotePort;            // Start of range or single value.
    unsigned short RemotePortData;        // End of range.

    unsigned int LocalPortField;          // Single, range, or wildcard.
    unsigned int LocalPortSelector;       // Packet or policy.
    unsigned short LocalPort;             // Start of range or single value.
    unsigned short LocalPortData;         // End of range.

    unsigned int IPSecProtocol;
    unsigned int IPSecMode;
    IPv6Addr RemoteSecurityGWAddr;
    unsigned int Direction;
    unsigned int IPSecAction;
    unsigned long SABundleIndex;
    unsigned int SPInterface;
} IPV6_CREATE_SECURITY_POLICY;


//
// This IOCTL adds an SA to the SA list.
//
#define IOCTL_IPV6_CREATE_SECURITY_ASSOCIATION \
            _IPV6_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_create_security_association {
    unsigned long SAIndex;
    unsigned long SPI;              // Security Parameter Index.
    IPv6Addr SADestAddr;
    IPv6Addr DestAddr;
    IPv6Addr SrcAddr;
    unsigned short TransportProto;
    unsigned short DestPort;
    unsigned short SrcPort;
    unsigned int Direction;
    unsigned long SecPolicyIndex;
    unsigned int AlgorithmId;
    unsigned int RawKeySize;
} IPV6_CREATE_SECURITY_ASSOCIATION;


//
// This IOCTL gets all the SPs from the SP list.
//
#define IOCTL_IPV6_QUERY_SECURITY_POLICY_LIST \
            _IPV6_CTL_CODE(11, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_security_policy_list {
    unsigned int SPInterface;
    unsigned long Index;
} IPV6_QUERY_SECURITY_POLICY_LIST;

typedef struct ipv6_info_security_policy_list {
    IPV6_QUERY_SECURITY_POLICY_LIST Query;
    unsigned long SPIndex;
    unsigned long NextSPIndex;

    unsigned int RemoteAddrField;
    unsigned int RemoteAddrSelector;
    IPv6Addr RemoteAddr;                  // Remote IP Address.
    IPv6Addr RemoteAddrData;

    unsigned int LocalAddrField;          // Single, range, or wildcard.
    unsigned int LocalAddrSelector;       // Packet or policy.
    IPv6Addr LocalAddr;                   // Start of range or single value.
    IPv6Addr LocalAddrData;               // End of range.

    unsigned int TransportProtoSelector;  // Packet or policy.
    unsigned short TransportProto;

    unsigned int RemotePortField;         // Single, range, or wildcard.
    unsigned int RemotePortSelector;      // Packet or policy.
    unsigned short RemotePort;            // Start of range or single value.
    unsigned short RemotePortData;        // End of range.

    unsigned int LocalPortField;          // Single, range, or wildcard.
    unsigned int LocalPortSelector;       // Packet or policy.
    unsigned short LocalPort;             // Start of range or single value.
    unsigned short LocalPortData;         // End of range.

    unsigned int IPSecProtocol;
    unsigned int IPSecMode;
    IPv6Addr RemoteSecurityGWAddr;
    unsigned int Direction;
    unsigned int IPSecAction;
    unsigned long SABundleIndex;
    unsigned int SPInterface;
} IPV6_INFO_SECURITY_POLICY_LIST;


//
// This IOCTL gets all the SAs from the SA list.
//
#define IOCTL_IPV6_QUERY_SECURITY_ASSOCIATION_LIST \
            _IPV6_CTL_CODE(12, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_security_association_list {
    unsigned long Index;
} IPV6_QUERY_SECURITY_ASSOCIATION_LIST;

typedef struct ipv6_info_security_association_list {
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST Query;
    unsigned long SAIndex;
    unsigned long NextSAIndex;
    unsigned long SPI;              // Security Parameter Index.
    IPv6Addr SADestAddr;  
    IPv6Addr DestAddr;
    IPv6Addr SrcAddr;
    unsigned short TransportProto;
    unsigned short DestPort;
    unsigned short SrcPort;    
    unsigned int Direction;   
    unsigned long SecPolicyIndex;
    unsigned int AlgorithmId;
} IPV6_INFO_SECURITY_ASSOCIATION_LIST;


//
// This IOCTL retrieves information from the route table.
// It takes the IPV6_QUERY_ROUTE_TABLE structure
// and returns the IPV6_INFO_ROUTE_TABLE structure.
//
//
#define IOCTL_IPV6_QUERY_ROUTE_TABLE \
            _IPV6_CTL_CODE(13, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_route_table {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
    IPV6_QUERY_NEIGHBOR_CACHE Neighbor;
} IPV6_QUERY_ROUTE_TABLE;

typedef struct ipv6_info_route_table {
    union {
        IPV6_QUERY_ROUTE_TABLE Next;    // Non-persistent query results.
        IPV6_QUERY_ROUTE_TABLE This;    // All other uses.
    };

    unsigned int SitePrefixLength;
    unsigned int ValidLifetime;         // Seconds.
    unsigned int PreferredLifetime;     // Seconds.
    unsigned int Preference;            // Smaller is better. See below.
    unsigned int Type;                  // See values below.
    int Publish;                        // Boolean.
    int Immortal;                       // Boolean.
} IPV6_INFO_ROUTE_TABLE;

//
// The Type field indicates where the route came from.
// These are RFC 2465 ipv6RouteProtocol values.
// Routing protocols are free to define new values.
//
#define RTE_TYPE_SYSTEM         2
#define RTE_TYPE_MANUAL         3
#define RTE_TYPE_AUTOCONF       4
#define RTE_TYPE_RIP            5
#define RTE_TYPE_OSPF           6
#define RTE_TYPE_BGP            7
#define RTE_TYPE_IDRP           8
#define RTE_TYPE_IGRP           9

//
// Standard route preference values.
// The value zero is reserved for administrative configuration.
//
#define ROUTE_PREF_LOW          (16*16*16)
#define ROUTE_PREF_MEDIUM       (16*16)
#define ROUTE_PREF_HIGH         16
#define ROUTE_PREF_ON_LINK      8
#define ROUTE_PREF_LOOPBACK     4
#define ROUTE_PREF_HIGHEST      0


//
// This IOCTL retrieves information about a persistent route.
// It takes the IPV6_PERSISTENT_QUERY_ROUTE_TABLE structure
// and returns the IPV6_INFO_ROUTE_TABLE structure.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE \
            _IPV6_CTL_CODE(46, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_route_table {
    IPV6_PERSISTENT_QUERY_INTERFACE IF;
    unsigned int RegistryIndex; // -1 means use the parameters below.
    IPv6Addr Neighbor;
    IPv6Addr Prefix;
    unsigned int PrefixLength;
} IPV6_PERSISTENT_QUERY_ROUTE_TABLE;


//
// This IOCTL adds/removes a route in the route table.
// It uses the IPV6_INFO_ROUTE_TABLE structure.
//
#define IOCTL_IPV6_UPDATE_ROUTE_TABLE \
            _IPV6_CTL_CODE(14, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_ROUTE_TABLE \
            _IPV6_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL adds/removes an address on an interface.
// It uses the IPV6_UPDATE_ADDRESS structure.
//
#define IOCTL_IPV6_UPDATE_ADDRESS \
            _IPV6_CTL_CODE(15, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_ADDRESS \
            _IPV6_CTL_CODE(38, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_update_address {
    IPV6_QUERY_ADDRESS This;
    unsigned int Type;               // Unicast or anycast.
    unsigned int PrefixConf;
    unsigned int InterfaceIdConf;
    unsigned int PreferredLifetime;  // Seconds.
    unsigned int ValidLifetime;      // Seconds.
} IPV6_UPDATE_ADDRESS;


//
// This IOCTL retrieves information from the binding cache.
//
#define IOCTL_IPV6_QUERY_BINDING_CACHE \
            _IPV6_CTL_CODE(16, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_binding_cache {
    IPv6Addr HomeAddress;
} IPV6_QUERY_BINDING_CACHE;

typedef struct ipv6_info_binding_cache {
    IPV6_QUERY_BINDING_CACHE Query;

    IPv6Addr HomeAddress;
    IPv6Addr CareOfAddress;
    unsigned int BindingSeqNumber;
    unsigned int BindingLifetime;   // Seconds.
} IPV6_INFO_BINDING_CACHE;


//
// This IOCTL controls some attributes of an interface.
// It uses the IPV6_INFO_INTERFACE structure.
//
#define IOCTL_IPV6_UPDATE_INTERFACE \
            _IPV6_CTL_CODE(17, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_INTERFACE \
            _IPV6_CTL_CODE(36, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL flushes entries from the neighbor cache.
// It uses the IPV6_QUERY_NEIGHBOR_CACHE structure.
//
#define IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE \
            _IPV6_CTL_CODE(18, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL flushes entries from the route cache.
// It uses the IPV6_QUERY_ROUTE_CACHE structure.
//
#define IOCTL_IPV6_FLUSH_ROUTE_CACHE \
            _IPV6_CTL_CODE(19, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes SA entries from the SA list.
// It uses the IPV6_QUERY_SECURITY_ASSOCIATION_LIST structure.
//
#define IOCTL_IPV6_DELETE_SECURITY_ASSOCIATION \
             _IPV6_CTL_CODE(20, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes SP entries from the SP list.
// It uses the IPV6_QUERY_SECURITY_POLICY_LIST structure.
//
#define IOCTL_IPV6_DELETE_SECURITY_POLICY \
             _IPV6_CTL_CODE(21, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes an interface.
// It uses the IPV6_QUERY_INTERFACE structure.
//
// The persistent variant, in addition to deleting the runtime interface,
// also keeps the interface from being (re)created persistently.
// However, it does NOT reset or delete any persistent attributes
// of the interface. For example, suppose you have a persisent tunnel
// interface with a persistent attribute, the interface metric.
// If you delete the tunnel interface and reboot, the tunnel interface
// will be recreated with the non-default interface metric.
// If you persistently delete the tunnel interface and reboot,
// the tunnel interface will not be created. But if you then create
// the tunnel interface, it will get the non-default interface metric.
// This is analogous to persistent attributes on removable ethernet interfaces.
//
#define IOCTL_IPV6_DELETE_INTERFACE \
            _IPV6_CTL_CODE(22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_DELETE_INTERFACE \
            _IPV6_CTL_CODE(44, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#if 0 // obsolete
//
// This IOCTL sets the mobility security to either on or off.
// When mobility security is turned on, Binding Cache Updates
// must be protected via IPsec.
//
#define IOCTL_IPV6_SET_MOBILITY_SECURITY \
            _IPV6_CTL_CODE(23, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_set_mobility_security {
    unsigned int MobilitySecurity;  // See MOBILITY_SECURITY values in ipsec.h.
} IPV6_SET_MOBILITY_SECURITY;
#endif


//
// This IOCTL sorts a list of destination addresses.
// The returned list may contain fewer addresses.
// It uses an array of TDI_ADDRESS_IP6 in/out.
//
#define IOCTL_IPV6_SORT_DEST_ADDRS \
            _IPV6_CTL_CODE(24, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// This IOCTL retrieves information from the site prefix table.
//
#define IOCTL_IPV6_QUERY_SITE_PREFIX \
            _IPV6_CTL_CODE(25, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_site_prefix {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
    IPV6_QUERY_INTERFACE IF;
} IPV6_QUERY_SITE_PREFIX;

typedef struct ipv6_info_site_prefix {
    IPV6_QUERY_SITE_PREFIX Query;

    unsigned int ValidLifetime;  // Seconds.
} IPV6_INFO_SITE_PREFIX;


//
// This IOCTL adds/removes a prefix in the site prefix table.
// It uses the IPV6_INFO_SITE_PREFIX structure.
//
// This ioctl is provided for testing purposes.
// Administrative configuration of site prefixes should never
// be required, because site prefixes are configured from
// Router Advertisements on hosts and from the routing table
// on routers. Hence there is no persistent version of this ioctl.
//
#define IOCTL_IPV6_UPDATE_SITE_PREFIX \
            _IPV6_CTL_CODE(26, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL create a new interface.
// It uses the IPV6_INFO_INTERFACE structure,
// with many fields ignored.
//
#define IOCTL_IPV6_CREATE_INTERFACE \
            _IPV6_CTL_CODE(27, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_CREATE_INTERFACE \
            _IPV6_CTL_CODE(43, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL requests a routing change notification.
// It uses the IPV6_RTCHANGE_NOTIFY_REQUEST (input) and
// IPV6_INFO_ROUTE_TABLE (output) structures.
//
// A notification request completes when a route
// that matches is added or deleted.
// A route matches the requested prefix if the route
// prefix and the request prefix intersect.
// So the ::/0 request prefix matches all route updates.
//
#define IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST \
            _IPV6_CTL_CODE(28, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_rtchange_notify_request {
    unsigned int Flags;
    unsigned int PrefixLength;
    unsigned long ScopeId;
    IPv6Addr Prefix;
} IPV6_RTCHANGE_NOTIFY_REQUEST;

#define IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SYNCHRONIZE   0x1
                // Only one wakeup per requestor per change.
#define IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SUPPRESS_MINE 0x2
                // Ignore route changes from this requestor.


#if 0
//
// This IOCTL retrieves an interface index, given a device name.
// It takes a PWSTR for input, and uses the IPV6_QUERY_INTERFACE structure 
// for output.
//
#define IOCTL_IPV6_QUERY_INTERFACE_INDEX \
            _IPV6_CTL_CODE(29, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif


//
// This IOCTL queries global IPv6 parameters.
// It uses the IPV6_GLOBAL_PARAMETERS structure.
//
// Note that changing these parameters typically does not affect
// existing uses of them. For example changing DefaultCurHopLimit
// will not affect the CurHopLimit of existing interfaces,
// but it will affect the CurHopLimit of new interfaces.
//
#define IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(30, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(49, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_global_parameters {
    unsigned int DefaultCurHopLimit;       // -1 means no change.
    unsigned int UseTemporaryAddresses;    // -1 means no change.
    unsigned int MaxTempDADAttempts;       // -1 means no change.
    unsigned int MaxTempValidLifetime;     // -1 means no change.
    unsigned int MaxTempPreferredLifetime; // -1 means no change.
    unsigned int TempRegenerateTime;       // -1 means no change.
    unsigned int MaxTempRandomTime;        // -1 means no change.
    unsigned int TempRandomTime;           // -1 means no change.
    unsigned int NeighborCacheLimit;       // -1 means no change.
    unsigned int RouteCacheLimit;          // -1 means no change.
    unsigned int BindingCacheLimit;        // -1 means no change.
    unsigned int ReassemblyLimit;          // -1 means no change.
    int MobilitySecurity;                  // Boolean, -1 means no change.
    unsigned int MobileIPv6Mode;           // -1 means no change.
} IPV6_GLOBAL_PARAMETERS;

#define USE_TEMP_NO             0       // Don't use temporary addresses.
#define USE_TEMP_YES            1       // Use them.
#define USE_TEMP_ALWAYS         2       // Always generating random numbers.
#define USE_TEMP_COUNTER        3       // Use them with per-interface counter.

//
// Bits in the MobileIPv6Mode field.
//
#define MOBILE_CORRESPONDENT    0x01
#define MOBILE_MOBILE_NODE      0x02
#define MOBILE_HOME_AGENT       0x04

//
// Initialize the fields of the IPV6_GLOBAL_PARAMETERS structure
// to values that indicate no change.
//
__inline void
IPV6_INIT_GLOBAL_PARAMETERS(IPV6_GLOBAL_PARAMETERS *Params)
{
    Params->DefaultCurHopLimit = (unsigned int) -1;
    Params->UseTemporaryAddresses = (unsigned int) -1;
    Params->MaxTempDADAttempts = (unsigned int) -1;
    Params->MaxTempValidLifetime = (unsigned int) -1;
    Params->MaxTempPreferredLifetime = (unsigned int) -1;
    Params->TempRegenerateTime = (unsigned int) -1;
    Params->MaxTempRandomTime = (unsigned int) -1;
    Params->TempRandomTime = (unsigned int) -1;
    Params->NeighborCacheLimit = (unsigned int) -1;
    Params->RouteCacheLimit = (unsigned int) -1;
    Params->BindingCacheLimit = (unsigned int) -1;
    Params->ReassemblyLimit = (unsigned int) -1;
    Params->MobilitySecurity = -1;
    Params->MobileIPv6Mode = (unsigned int) -1;
}


//
// This IOCTL sets global IPv6 parameters.
// It uses the IPV6_GLOBAL_PARAMETERS structure.
//
// Note that changing these parameters typically does not affect
// existing uses of them. For example changing DefaultCurHopLimit
// will not affect the CurHopLimit of existing interfaces,
// but it will affect the CurHopLimit of new interfaces.
//
#define IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(31, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS \
            _IPV6_CTL_CODE(37, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL retrieves information from the prefix policy table.
// It takes as input an IPV6_QUERY_PREFIX_POLICY structure
// and returns as output an IPV6_INFO_PREFIX_POLICY structure.
// To perform an iteration, start with PrefixLength set to -1, in which case
// only an IPV6_QUERY_PREFIX_POLICY is returned, for the first policy.
// If there are no more policies, then the PrefixLength in the returned
// IPV6_QUERY_PREFIX_POLICY will be -1.
//
#define IOCTL_IPV6_QUERY_PREFIX_POLICY \
            _IPV6_CTL_CODE(32, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_query_prefix_policy {
    IPv6Addr Prefix;
    unsigned int PrefixLength;
} IPV6_QUERY_PREFIX_POLICY;

typedef struct ipv6_info_prefix_policy {
    IPV6_QUERY_PREFIX_POLICY Next;      // For non-persistent queries only.
    IPV6_QUERY_PREFIX_POLICY This;

    unsigned int Precedence;
    unsigned int SrcLabel;
    unsigned int DstLabel;
} IPV6_INFO_PREFIX_POLICY;


//
// This IOCTL retrieves information about persisted prefix policies.
// It takes as input an IPV6_PERSISTENT_QUERY_PREFIX_POLICY structure
// and returns as output an IPV6_INFO_PREFIX_POLICY structure.
// (The Next field is not returned.)
// To perform an iteration, start with index 0 and increment
// until getting STATUS_NO_MORE_ENTRIES / ERROR_NO_MORE_ITEMS.
//
// An IOCTL to retrieve persisted prefix policies via prefix
// (like IPV6_QUERY_PREFIX_POLICY) is conceivable but not supported.
//
#define IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY \
            _IPV6_CTL_CODE(50, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct ipv6_persistent_query_prefix_policy {
    unsigned int RegistryIndex;
} IPV6_PERSISTENT_QUERY_PREFIX_POLICY;


//
// This IOCTL adds a prefix to the prefix policy table,
// or updates an existing prefix policy.
// It uses the IPV6_INFO_PREFIX_POLICY structure.
// (The Next field is ignored.)
//
#define IOCTL_IPV6_UPDATE_PREFIX_POLICY \
            _IPV6_CTL_CODE(33, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_UPDATE_PREFIX_POLICY \
            _IPV6_CTL_CODE(41, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL removes a prefix from the prefix policy table.
// It uses the IPV6_QUERY_PREFIX_POLICY structure.
//
#define IOCTL_IPV6_DELETE_PREFIX_POLICY \
            _IPV6_CTL_CODE(34, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_DELETE_PREFIX_POLICY \
            _IPV6_CTL_CODE(42, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL deletes all manual configuration.
//
#define IOCTL_IPV6_RESET \
            _IPV6_CTL_CODE(39, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_IPV6_PERSISTENT_RESET \
            _IPV6_CTL_CODE(45, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// This IOCTL sets the link-layer address of a default router
// on a non-broadcast multi-access (NBMA) link, such as the ISATAP
// link, where Router Solicitations, Router Advertistments, and
// Redirects are desired.
//
// There is no persistent version of this ioctl because
// 6to4svc always configures this information dynamically.
//
#define IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS \
            _IPV6_CTL_CODE(35, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct ipv6_update_router_ll_address {
    IPV6_QUERY_INTERFACE IF;
    // Following this structure in memory are:
    //   Own link-layer address to use for EUI-64 creation.
    //   Link-layer address of router.
} IPV6_UPDATE_ROUTER_LL_ADDRESS;


//
// This IOCTL renews an interface, meaning that all
// auto-configured state is thrown away and regenerated.
// Same behavior as reconnecting the interface to a link.
// It uses the IPV6_QUERY_INTERFACE structure.
//
#define IOCTL_IPV6_RENEW_INTERFACE \
            _IPV6_CTL_CODE(51, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#pragma warning(pop)
#endif  // ifndef _NTDDIP6_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\netcan.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netcan.h

Abstract:

    Prototypes for internal (private) local canonicalization routines (Netpw)
    and client-side RPC functions (Netps)

Author:

    Richard L Firth (rfirth) 22-Jan-1992

Revision History:

--*/

//
// worker (Netpw) functions in NETLIB.LIB
//

NET_API_STATUS
NetpwPathType(
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwPathCanonicalize(
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NetpwPathCompare(
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwNameValidate(
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwNameCanonicalize(
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NetpwNameCompare(
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpwListCanonicalize(
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    );

LPTSTR
NetpwListTraverse(
    IN  LPTSTR  Reserved,
    IN  LPTSTR* pList,
    IN  DWORD   Flags
    );

//
// stub (Netps) functions in SRVSVC.DLL
//

NET_API_STATUS
NetpsPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    );

LONG
NetpsPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

NET_API_STATUS
NetpsNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LONG
NetpsNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\netshp.h ===
#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

// Defines

#define ERROR_CONTEXT_SWITCH            0x55aa
#define ERROR_CONNECT_REMOTE_CONFIG     (ERROR_CONTEXT_SWITCH + 1)


// Flags
enum NS_CMD_FLAGS_PRIV
{
    CMD_FLAG_IMMEDIATE   = 0x04, // not valid from ancestor contexts
};

// Callbacks
typedef
DWORD
    (WINAPI NS_CONTEXT_ENTRY_FN)(
    IN      LPCWSTR     pwszMachine,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID     pvData,
    OUT     LPWSTR      pwcNewContext
    );

typedef NS_CONTEXT_ENTRY_FN *PNS_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_SUBENTRY_FN)(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      LPCVOID                      pvData,
    OUT     LPWSTR                       pwcNewContext
    );

typedef NS_CONTEXT_SUBENTRY_FN *PNS_CONTEXT_SUBENTRY_FN;

typedef
BOOL
(WINAPI *PNS_EVENT_FILTER)(
    IN  EVENTLOGRECORD  *pRecord,
    IN  LPCWSTR         pwszLogName,
    IN  LPCWSTR         pwszComponent,
    IN  LPCWSTR         pwszSubComponent,
    IN  LPCVOID         pvFilterContext
    );

typedef
DWORD
(WINAPI *PNS_GET_EVENT_IDS_FN)(
    IN  LPCWSTR  pwszComponent,
    IN  LPCWSTR  pwszSubComponent,
    OUT PDWORD   pdwEventIds,
    OUT PULONG   pulEventCount
    );

// Macros
#define NUM_VALUES_IN_TABLE(TokenArray) sizeof(TokenArray)/sizeof(VALUE_STRING)

// Structures
typedef struct _NS_PRIV_CONTEXT_ATTRIBUTES
{
    PNS_CONTEXT_ENTRY_FN     pfnEntryFn;
    PNS_CONTEXT_SUBENTRY_FN  pfnSubEntryFn;
    PVOID                    pfnHelpFn;
} NS_PRIV_CONTEXT_ATTRIBUTES, *PNS_PRIV_CONTEXT_ATTRIBUTES;

typedef struct _NS_DLL_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };

        ULONGLONG       _ullAlign;
    };

    PNS_DLL_STOP_FN     pfnStopFn;

} NS_DLL_ATTRIBUTES, *PNS_DLL_ATTRIBUTES;


typedef struct _VALUE_TOKEN
{
    DWORD    dwValue;
    LPCWSTR  pwszToken;
} VALUE_TOKEN, *PVALUE_TOKEN;

typedef struct _VALUE_STRING
{
    DWORD   dwValue;
    DWORD   dwStringId;
} VALUE_STRING, *PVALUE_STRING;


// Exports
VOID WINAPI ConvertGuidToString(
    IN    CONST GUID *pGuid,
    OUT   LPWSTR      pwszBuffer
    );

DWORD WINAPI ConvertStringToGuid(
    IN  LPCWSTR pwszGuid,
    IN  USHORT  usStringLen,
    OUT GUID    *pGuid
    );

DWORD DisplayMessageToConsole(
    IN  HANDLE  hModule,
    IN  HANDLE  hConsole,
    IN  DWORD   dwMsgId,
    ...
    );

DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

VOID WINAPI FreeQuotedString(
    IN  LPWSTR  pwszMadeString
    );

VOID WINAPI FreeString(
    IN  LPWSTR  pwszMadeString
    );

DWORD WINAPI GenericMonitor(
    IN     PCNS_CONTEXT_ATTRIBUTES  pContext,
    IN     LPCWSTR                  pwszMachine,
    IN OUT LPWSTR                  *ppwcArguments,
    IN     DWORD                    dwArgCount,
    IN     DWORD                    dwFlags,
    IN     LPCVOID                  pvData,
    OUT    LPWSTR                   pwcNewContext
    );

LPWSTR WINAPI GetEnumString(
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  DWORD           dwNumVal,
    IN  PTOKEN_VALUE    pEnumTable
    );

BOOL WINAPI InitializeConsole(
    IN    OUT    PDWORD    pdwRR,
    OUT          HANDLE    *phMib,
    OUT          HANDLE    *phConsole
    );

LPWSTR WINAPI MakeQuotedString(
    IN  LPCWSTR  pwszString
    );

LPWSTR WINAPI MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

BOOL WINAPI MatchCmdLine(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD    dwArgCount,
    IN      LPCWSTR  pwszCmdToken,
    OUT     PDWORD   pdwNumMatched
    );

DWORD WINAPI MatchTagsInCmdLine(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN OUT  PTAG_TYPE   pEnumTable,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    );

DWORD WINAPI NsGetFriendlyNameFromIfName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI NsGetIfNameFromFriendlyName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI RefreshConsole(
    IN    HANDLE    hMib,
    IN    HANDLE    hConsole,
    IN    DWORD     dwRR
    );

DWORD WINAPI ProcessCommand(
    IN    LPCWSTR pwszCmdLine,
    OUT   BOOL *pbDone
    );

#define DisplayError     PrintError
#define DisplayMessageT  PrintMessage
#define DisplayMessage   PrintMessageFromModule

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\ntddtcp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas) 13-Aug-1993

Revision History:

--*/

#pragma once
#ifndef _NTDDTCP_
#define _NTDDTCP_

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"

#define DD_TCP_SYMBOLIC_DEVICE_NAME L"\\DosDevices\\Tcp"

//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

typedef struct tcp_blockports_request {
    unsigned long  ReservePorts;   // TRUE if reserve; FALSE otherwise
    union
    {
        unsigned long  NumberofPorts;   // numberofports to reserve
        unsigned long  StartHandle;     // handle to be used to unreserve
    };
} TCP_BLOCKPORTS_REQUEST, *PTCP_BLOCKPORTS_REQUEST;

typedef struct tcp_findtcb_request {
    unsigned long  Src;
    unsigned long  Dest;
    unsigned short DestPort;
    unsigned short SrcPort;
} TCP_FINDTCB_REQUEST, *PTCP_FINDTCB_REQUEST;

typedef struct tcp_findtcb_response {
  ULONG_PTR         tcb_addr;
  unsigned long     tcb_senduna;
  unsigned long     tcb_sendnext;
  unsigned long     tcb_sendmax;
  unsigned long     tcb_sendwin;
  unsigned long     tcb_unacked;
  unsigned long     tcb_maxwin;
  unsigned long     tcb_cwin;
  unsigned short    tcb_mss;
  unsigned long     tcb_rtt;
  unsigned short    tcb_smrtt;
  unsigned short    tcb_rexmitcnt;
  unsigned short    tcb_rexmittimer;
  unsigned short    tcb_rexmit;
  unsigned long     tcb_retrans;
  unsigned short    tcb_state;
  unsigned long     tcb_copied;
} TCP_FINDTCB_RESPONSE, *PTCP_FINDTCB_RESPONSE;


//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_RESERVE_PORT_RANGE  \
            _TCP_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_UNRESERVE_PORT_RANGE  \
            _TCP_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_BLOCK_PORTS  \
            _TCP_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_WSH_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_TCP_FINDTCB \
            _IP_CTL_CODE(21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#pragma warning(pop)
#endif // _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\polstore2.h ===
#ifdef __cplusplus
extern "C" {
#endif

#define POLICY_ACCESS_RIGHTS NSU_ACL_F_AdminFull | NSU_ACL_F_LocalSystemFull

enum STORAGE_LOCATION {
    LOCATION_LOCAL=0,
    LOCATION_REMOTE,
    LOCATION_GLOBAL,
    LOCATION_CACHE,
    LOCATION_FILE,
    LOCATION_WMI
};

#include <ipsec.h>
#include <oakdefs.h>
#include <polstructs.h>

//
//wmi wbenservices
//

#include <wbemidl.h>

HRESULT
WriteDirectoryPolicyToWMI(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    PGPO_INFO pGPOInfo,
    IWbemServices *pWbemServices
    );

HRESULT
IPSecClearWMIStore(
    IWbemServices *pWbemServices
    );

DWORD
IPSecEnumPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
IPSecSetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecCreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecDeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecEnumFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
IPSecSetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
IPSecCreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
IPSecDeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    );

DWORD
IPSecEnumNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
IPSecSetNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
IPSecCreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
IPSecDeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    );

DWORD
IPSecCreateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecSetNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecDeleteNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecEnumNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
IPSecGetFilterData(
    HANDLE hPolicyStore,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
IPSecGetNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
IPSecEnumISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
IPSecSetISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
IPSecCreateISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
IPSecDeleteISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    );

DWORD
IPSecGetISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
IPSecOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
RegOpenPolicyStore(
    LPWSTR pszMachineName,
    IN DWORD dwStore,       // See IPSEC_STORE_* values
    HANDLE * phPolicyStore
    );

////
DWORD
WMIOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );

DWORD
DirOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );

DWORD
FileOpenPolicyStore(
    LPWSTR pszMachineName,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
IPSecClosePolicyStore(
    HANDLE hPolicyStore
    );

DWORD
IPSecAssignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    );

DWORD
IPSecUnassignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    );

DWORD
ComputeDirLocationName(
    LPWSTR pszDirDomainName,
    LPWSTR * ppszDirFQPathName
    );

DWORD
IPSecGetAssignedPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );


DWORD
IPSecExportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );

DWORD
IPSecImportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );

/*
//////////////////////////////
//
// Globals
//
//////////////////////////////

// {6A1F5C6F-72B7-11d2-ACF0-0060B0ECCA17}
static const GUID GUID_POLSTORE_VERSION_INFO =
{ 0x6a1f5c6f, 0x72b7, 0x11d2, { 0xac, 0xf0, 0x0, 0x60, 0xb0, 0xec, 0xca, 0x17 } };


// {72385230-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_POLICY =
{ 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385231-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_ISAKMP =
{ 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385232-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NFA =
{ 0x72385232, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385233-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NEGPOL =
{ 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385236-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_POLICY =
{ 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385237-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_ISAKMP =
{ 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385238-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_POLICY =
{ 0x72385238, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385239-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_ISAKMP =
{ 0x72385239, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523a-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ME_TO_FROM_ANYONE_FILTER=
{ 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385235-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ICMP_FILTER =
{ 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523c-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_POLICY =
{ 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523d-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_ISAKMP =
{ 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523e-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NFA =
{ 0x7238523e, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523f-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NEGPOL =
{ 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

static const GUID GUID_BUILTIN_PERMIT_NEGPOL =
{ 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };





//////////////////////////////
//////////////////////////////
//      Negotiation Policy Types
//////////////////////////////
//////////////////////////////
// {62F49E10-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_STANDARD =
{ 0x62f49e10, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E11-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_BASE =
{ 0x62f49e11, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E12-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_EXTENDED =
{ 0x62f49e12, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E13-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_DEFAULT =
{ 0x62f49e13, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


//////////////////////////////
//////////////////////////////
//      Negotiation Policy Actions
//////////////////////////////
//////////////////////////////

// {3F91A819-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_BLOCK =
{ 0x3f91a819, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {3F91A81A-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU =
{ 0x3f91a81a, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD2-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NO_IPSEC =
{ 0x8a171dd2, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD3-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NORMAL_IPSEC =
{ 0x8a171dd3, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };




//////////////////////////////
//////////////////////////////
//      GUID identifying the default IKE settings to use
//      in case no policy is assigned.
//////////////////////////////
//////////////////////////////
// {72385234-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_DEFAULT_ISAKMP_POLICY=
{ 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

///////////////////////
// GUIDS reserved for future use... These are handy mostly because they
// are easily recognizable because of the trailing zeros.  This helps out in
// debugging and in manual manipulation of policies by GUID -- such as removing
// built-in policies from the DS using adsvw etc.
//////////////////////
*/


#define PAS_INTERFACE_TYPE_NONE          0
#define PAS_INTERFACE_TYPE_DIALUP       -1
#define PAS_INTERFACE_TYPE_LAN          -2
#define PAS_INTERFACE_TYPE_ALL          -3


//
// Negotiation Policy Actions.
//

// {3F91A819-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_BLOCK =
{ 0x3f91a819, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {3F91A81A-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU =
{ 0x3f91a81a, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD2-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NO_IPSEC =
{ 0x8a171dd2, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD3-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NORMAL_IPSEC =
{ 0x8a171dd3, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };


//
// Negotiation Policy Types.
//

// {62F49E10-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_STANDARD =
{ 0x62f49e10, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E13-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_DEFAULT =
{ 0x62f49e13, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


DWORD
IPSecRestoreDefaultPolicies(
    HANDLE hPolicyStore
    );


DWORD
IPSecIsDomainPolicyAssigned(
    PBOOL pbIsDomainPolicyAssigned
    );


//
// Polstore memory management functions.
//


LPVOID
IPSecAllocPolMem(
    DWORD cb
    );

BOOL
IPSecFreePolMem(
    LPVOID pMem
    );

LPWSTR
IPSecAllocPolStr(
    LPCWSTR pStr
    );

BOOL
IPSecFreePolStr(
    LPWSTR pStr
    );

DWORD
IPSecReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    );

BOOL
IPSecReallocatePolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    );

void
IPSecFreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

void
IPSecFreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

void
IPSecFreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

void
IPSecFreeISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

void
IPSecFreeNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecCopyPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
IPSecCopyNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
IPSecCopyFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
IPSecCopyFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    );

DWORD
IPSecCopyISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
IPSecCopyNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
IPSecCopyAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    );

void
IPSecFreeMulPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

void
IPSecFreeMulNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    );

void
IPSecFreeMulFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    );

void
IPSecFreeFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    );

void
IPSecFreeFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    );

void
IPSecFreeMulISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    );

void
IPSecFreeMulNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    );

DWORD
IPSecChooseDriverBootMode(
    HKEY hHKLMKey,
    DWORD dwStore, 
    DWORD dwAction
    );

DWORD
IPSecSetDriverOperationMode(
    HKEY hHKLMKey,
    DWORD dwNewOperationMode
    );

DWORD
IsRegvalueExist(
    HKEY hHKLMKey,
    LPWSTR pszKey,
    LPWSTR pszValue,
    BOOL * pbValueExists
    );

DWORD
IPSecRegDeleteValue(
    HKEY hHKLMKey,
    LPWSTR pszKey,
    LPWSTR pszValue
    );

DWORD
IsAnyPolicyAssigned (
    HKEY hHKLMKey,
    BOOL * pbAnyPolicyAssigned    
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rasuip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       R A S U I P . H
//
//  Contents:   Private RAS APIs used by the NT5 Connections UI.  These
//              APIs are exported by rasdlg.dll.
//
//  Notes:
//
//  Author:     shaunco   10 Nov 1997
//
//----------------------------------------------------------------------------

#ifndef _RASUIP_
#define _RASUIP_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 1200 )
#pragma warning(push)
#endif
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#pragma warning(disable:4514)
#endif
#if (_MSC_VER >= 1020)
#pragma once
#endif
#endif

#include <prsht.h>
#include <ras.h>
#include <hnetcfg.h>


#ifdef __cplusplus
extern "C" {
#endif

//+---------------------------------------------------------------------------
// RASENTRYDLG.reserved2 argument block valid when RASENTRYDLG.dwFlags
// RASEDFLAG_ShellOwned is set.
//

typedef struct
_RASEDSHELLOWNEDR2
{
    // Add page routine to be called by RasEntryDlg before returning.
    // Callback returns context 'lparam'.
    //
    LPFNADDPROPSHEETPAGE    pfnAddPage;
    LPARAM                  lparam;

    // When RASEDFLAG_NewEntry and RASEDFLAG_ShellOwned are set,
    // pvWizardCtx is filled in by RasEntryDlg so that the shell has
    // context information with which to pass to the NccXXX APIs below.
    //
    LPVOID                  pvWizardCtx;
}
RASEDSHELLOWNEDR2;

//For GetCurrentIconEntryType()
//
#define ICON_CONNECTION_FOLDER      0x1000   //The connection folder icon type
#define ICON_NCW_WIZARD             0x1001   // Icon of the New Connection Wizard
#define ICON_HNET_WIZARD            0x1002   //Icon of the Home Networking Wizard


//+---------------------------------------------------------------------------
// RAS Connection wizard APIs
//

// Flags returned from RasWizCreateNewEntry
//
#define NCC_FLAG_ALL_USERS          0x1     // Create connection for all users
#define NCC_FLAG_CREATE_INCOMING    0x2     // Create incoming connection instead
#define NCC_FLAG_SHARED             0x4
#define NCC_FLAG_FIREWALL           0x8     // If turn on Firewall
#define NCC_FLAG_GLOBALCREDS        0x10    // If the credentials is for all users
#define NCC_FLAG_DEFAULT_INTERNET   0x20    // If this is a default internet connection

// Types of connections to be used in calls to RasWizXXX
#define RASWIZ_TYPE_DIALUP    0x1
#define RASWIZ_TYPE_DIRECT    0x2
#define RASWIZ_TYPE_INCOMING  0x3
#define RASWIZ_TYPE_BROADBAND 0x4

DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags);

DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags);

DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName);

DWORD
APIENTRY
RasWizGetSuggestedEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName);

DWORD
APIENTRY
RasWizQueryMaxPageCount(
    IN  DWORD    dwRasWizType);

DWORD
APIENTRY
RasWizSetEntryName(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName);

DWORD
APIENTRY
RasWizIsEntryRenamable(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable);


//+---------------------------------------------------------------------------
// Inbound connection APIs
//

typedef HANDLE HRASSRVCONN;

#define RASSRV_MaxName              256

// Types of ras server connections (RASSRVCONN.dwType values)
//
#define RASSRVUI_MODEM              0
#define RASSRVUI_VPN                1
#define RASSRVUI_DCC                2

// Defines a structure that identifies a client connection
//
typedef struct _RASSRVCONN
{
    DWORD       dwSize;                 // Size of the structure (used for versioning)
    HRASSRVCONN hRasSrvConn;            // Handle of the connection
    DWORD       dwType;
    WCHAR       szEntryName  [RASSRV_MaxName + 1];
    WCHAR       szDeviceName [RASSRV_MaxName + 1];
    GUID        Guid;
} RASSRVCONN, *LPRASSRVCONN;

// Starts the remote access service and marks it as autostart.
// If the remoteaccess service is not installed, this function
// returns an error.
DWORD
APIENTRY
RasSrvInitializeService (
    VOID);

// Stops the remote access service and marks it as disabled.
DWORD
APIENTRY
RasSrvCleanupService (
    VOID);

DWORD
APIENTRY
RasSrvIsServiceRunning (
    OUT BOOL* pfIsRunning);

//
// Returns whether is it ok to display the "Incoming Connections"
// connection.
//
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow);

DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);

DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext);    // context should be passed in as pvData
                                            // subsequent calls to RasWizXXX

// Function behaves anagolously to the WIN32 function RasEnumConnections but
// for client connections instead of dialout connections.
DWORD
APIENTRY
RasSrvEnumConnections (
    IN OUT  LPRASSRVCONN    pRasSrvConn,    // Buffer of array of connections.
    IN      LPDWORD         pcb,            // size in bytes of buffer
    OUT     LPDWORD         pcConnections); // number of connections written to buffer

// Gets the status of a Ras Server Connection
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,            // The connection in question
    OUT BOOL*       pfConnected);           // Buffer to hold the type

// Hang up the given connection
DWORD
APIENTRY
RasSrvHangupConnection (
    IN  HRASSRVCONN hRasSrvConn);           // The connection in question


// Has "show icons in taskbar" been checked?
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon);

// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent);

// Enables or disables having the user manually dial
// his/her remote access server.
DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN BOOL  bEnable );     // whether to enable or not

DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled );   // whether to enable or not

//+---------------------------------------------------------------------------
// Connection sharing API routines
//

// Defines the structure used to store information about the shared connection.
// This structure is stored as binary data in the registry, and any changes
// to it must be made with this in mind.
//
#include <packon.h>
typedef struct _RASSHARECONN
{
    DWORD               dwSize;
    BOOL                fIsLanConnection;
    union {
        GUID            guid;
        RASENTRYNAMEW   name;
    };
} RASSHARECONN, *LPRASSHARECONN;
#include <packoff.h>

// Flag set by 'RasQueryLanConnTable' for private LAN connections
//
#define NCCF_PRIVATE_LAN        0x1000

// Name of secure event object shared with rasauto service.
//
#define RAS_AUTO_DIAL_SHARED_CONNECTION_EVENT \
    "RasAutoDialSharedConnectionEvent"

// VOID
// RasEntryToSharedConnection(
//      IN LPCWSTR          pszPhonebookPath,
//      IN LPCWSTR          pszEntryName,
//      OUT LPRASSHARECONN  pConn );
//
// Macro for conversion of phonebook/entry to 'RASSHARECONN'.
//
#define RasEntryToSharedConnection( _pszPhonebookPath, _pszEntryName, _pConn ) \
( \
    ZeroMemory((_pConn), sizeof(RASSHARECONN)), \
    (_pConn)->dwSize = sizeof(RASSHARECONN), \
    (_pConn)->fIsLanConnection = FALSE, \
    (_pConn)->name.dwSize = sizeof((_pConn)->name), \
    (_pConn)->name.dwFlags = REN_AllUsers, \
    lstrcpynW((_pConn)->name.szPhonebookPath, _pszPhonebookPath, MAX_PATH), \
    lstrcpynW((_pConn)->name.szEntryName, _pszEntryName, RAS_MaxEntryName) \
)

// VOID
// RasGuidToSharedConnection(
//      IN REFGUID          guid,
//      OUT LPRASSHARECONN  pConn );
//
// Macro for conversion of LAN GUID to 'RASSHARECONN'
//
#define RasGuidToSharedConnection( _guid, _pConn ) \
( \
    ZeroMemory((_pConn), sizeof(RASSHARECONN)), \
    (_pConn)->dwSize = sizeof(RASSHARECONN), \
    (_pConn)->fIsLanConnection = TRUE, \
    CopyMemory(&(_pConn)->guid, (_guid), sizeof(GUID)) \
)

// VOID
// RasIsEqualSharedConnection(
//      IN LPRASSHARECONN   pConn1,
//      IN LPRASSHARECONN   pConn2 );
//
// Macro for comparison of 'RASSHARECONN' values
//
#define RasIsEqualSharedConnection( _pConn1, _pConn2 ) \
( \
    ((_pConn1)->fIsLanConnection == (_pConn2)->fIsLanConnection) && \
    ((_pConn1)->fIsLanConnection \
        ? !memcmp(&(_pConn1)->guid, &(_pConn2)->guid, sizeof(GUID)) \
        : (!lstrcmpiW( \
                (_pConn1)->name.szPhonebookPath, \
                (_pConn2)->name.szPhonebookPath) && \
           !lstrcmpiW( \
                (_pConn1)->name.szEntryName, \
                (_pConn2)->name.szEntryName))) \
)

DWORD
APIENTRY
RasAutoDialSharedConnection( VOID );

DWORD
APIENTRY
RasIsSharedConnection(
    IN LPRASSHARECONN   pConn,
    OUT PBOOL           pfShared );

DWORD
APIENTRY
RasQuerySharedAutoDial(
    IN PBOOL            pfEnabled );

DWORD
APIENTRY
RasQuerySharedConnection(
    OUT LPRASSHARECONN  pConn );

DWORD
APIENTRY
RasSetSharedAutoDial(
    IN BOOL             fEnable );

//+---------------------------------------------------------------------------
// Internal RAS APIs
//

DWORD
APIENTRY
DwRasUninitialize();

#ifdef __cplusplus
}       // extern "C"
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 1200 )
#pragma warning(pop)
#elif ( _MSC_VER >= 800 )
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
#pragma warning(default:4514)
#endif
#endif

#endif  // _RASUIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rap.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Rap.h

Abstract:

    This header file contains procedure prototypes for Remote Admin Protocol
    (RAP) routines.  These routines are shared between XactSrv and RpcXlate.

Author:

    David Treadwell (davidtr) 08-Jan-1991
    Shanku Niyogi (w-shanku)
    John Rogers (JohnRo)

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Mar-1991 JohnRo
        Extracted Rap routines from XactSrv (Xs) code.
    26-Mar-1991 JohnRo
        Added FORMAT_LPDESC (for debugging).  Include <ctype.h>.
    21-Apr-1991 JohnRo
        Added RapIsValidDescriptorSmb().  Reduced recompiles.
        Make it clear that RapAsciiToDecimal updates the pointer it is given.
        RapConvertSingleEntry's BytesRequired is not OPTIONAL.
        Clarify that OutStructure is OUT, not IN.
    06-May-1991 JohnRo
        Added DESC_CHAR typedef.
    14-May-1991 JohnRo
        Added DESCLEN() and FORMAT_DESC_CHAR macros.
    15-May-1991 JohnRo
        Added conversion mode handling.  Added native vs. RAP handling.
    05-Jun-1991 JohnRo
        Added RapTotalSize().  Make output structure OPTIONAL for convert
        single entry; this will be used by RapTotalSize().
    10-Jul-1991 JohnRo
        Added RapStructureAlignment() for use by RxpConvertDataStructures().
    22-Jul-1991 RFirth
        Added MAX_DESC_SUBSTRING
    19-Aug-1991 JohnRo
        Added DESC_CHAR_IS_DIGIT() macro (to improve UNICODE conversion).
    10-Sep-1991 JohnRo
        Added DESC_DIGIT_TO_NUM(), to support changes suggested by PC-LINT.
    07-Oct-1991 JohnRo
        Correct MAX_DESC_SUBSTRING.
        Use DESC_CHAR_IS_DIGIT() in t-JamesW's new macros.
    07-Feb-1992 JohnRo
        Added RapCharSize() macro.
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for DEC and others.

--*/

#ifndef _RAP_
#define _RAP_


// These must be included first:

#include <windef.h>             // BOOL, CHAR, DWORD, IN, LPBYTE, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <lmremutl.h>   // DESC_CHAR and LPDESC_CHAR typedefs.


#ifndef DESC_CHAR_UNICODE

#include <ctype.h>      // isdigit().
#include <string.h>     // strlen() (only needed for DESCLEN()).

//
// The descriptor strings are really ASCIIZ strings, and are not expected to
// be translated into Unicode.  So, let's define a type for them just to
// make this clearer.  (That'll also make it easier to change to Unicode later
// if I'm wrong.  --JR)
//

//typedef CHAR DESC_CHAR;

//
// Net buffers contain 32-bit pointers.
//

#define NETPTR DWORD

// DESCLEN(desc): return number of characters (not including null) in desc:
#define DESCLEN(desc)                   strlen(desc)

// DESC_CHAR_IS_DIGIT(descchar): return nonzero iff descchar is a digit.
#define DESC_CHAR_IS_DIGIT(descchar)    isdigit(descchar)

// DESC_DIGIT_TO_NUM(descchar): return integer value of descchar.
#define DESC_DIGIT_TO_NUM(descchar) \
    ( (DWORD) ( ((int)(descchar)) - ((int) '0') ) )

//
// Format strings for NetpDbgPrint use (see NetDebug.h).  Note that
// FORMAT_LPDESC_CHAR will go away one of these days.
//
#define FORMAT_DESC_CHAR        "%c"
#define FORMAT_LPDESC           "%s"
#define FORMAT_LPDESC_CHAR      "%c"

#else // DESC_CHAR_UNICODE is defined

//
// The descriptor strings are really ASCIIZ strings, and are not expected to
// be translated into Unicode.  So, let's define a type for them just to
// make this clearer.  (That'll also make it easier to change to Unicode later
// if I'm wrong.  --JR)
//

#include <wchar.h>      // iswdigit(), wcslen().

//typedef WCHAR DESC_CHAR;

// DESCLEN(desc): return number of characters (not including null) in desc:
#define DESCLEN(desc)                   wcslen(desc)

// DESC_CHAR_IS_DIGIT(descchar): return nonzero iff descchar is a digit.
#define DESC_CHAR_IS_DIGIT(descchar)    iswdigit(descchar)

// DESC_DIGIT_TO_NUM(descchar): return integer value of descchar.
#define DESC_DIGIT_TO_NUM(descchar) \
    ( (DWORD) ( ((int)(descchar)) - ((int) L'0') ) )

//
// Format strings for NetpDbgPrint use (see NetDebug.h).  Note that
// FORMAT_LPDESC_CHAR will go away one of these days.
//
#define FORMAT_DESC_CHAR        "%wc"
#define FORMAT_LPDESC           "%ws"
#define FORMAT_LPDESC_CHAR      "%wc"

#endif // DESC_CHAR_UNICODE is defined

//typedef DESC_CHAR * LPDESC;

//
// MAX_DESC_SUBSTRING - the maximum number of consecutive characters in a
// descriptor string which can describe a single field in a structure - for
// example "B21" in "B21BWWWzWB9B".  So far, largest is "B120".
//

#define MAX_DESC_SUBSTRING  4

//
// Some routines need to know whether a given item is part of a request,
// a response, or both:
//

typedef enum _RAP_TRANSMISSION_MODE {
    Request,                    // only part of request (in)
    Response,                   // only part of response (out)
    Both                        // both (in out).
} RAP_TRANSMISSION_MODE, *LPRAP_TRANSMISSION_MODE;

typedef enum _RAP_CONVERSION_MODE {
    NativeToRap,                // native format to RAP
    RapToNative,                // RAP format to native
    NativeToNative,             // native to native
    RapToRap                    // RAP to RAP
} RAP_CONVERSION_MODE, *LPRAP_CONVERSION_MODE;

//
// The value returned by RapLastPointerOffset for a descriptor string
// which indicates that the structure has no pointers. A very high
// value is returned instead of 0, in order to distinguish between
// a structure with no pointers, such as share_info_0, and a structure
// with only one pointer, at offset 0.
//

#define NO_POINTER_IN_STRUCTURE 0xFFFFFFFF

//
// The value returned by RapAuxDataCount when there is no
// auxiliary data. This will be indicated by the lack of an auxiliary
// data count character in the descriptor string.
//

#define NO_AUX_DATA 0xFFFFFFFF

//
// Helper subroutines and macros.
//

DWORD
RapArrayLength(
    IN LPDESC Descriptor,
    IN OUT LPDESC * UpdatedDescriptorPtr,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    );

DWORD
RapAsciiToDecimal (
   IN OUT LPDESC *Number
   );

DWORD
RapAuxDataCountOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapAuxDataCount (
    IN LPBYTE Buffer,
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

// RapCharSize(native): return character size (in bytes) for characters of a
// given format.
// 
// DWORD
// RapCharSize(Native)
//     IN BOOL Native
//     );
//
#define RapCharSize(Native) \
    ( (DWORD) ( (Native) ? sizeof(TCHAR) : sizeof(CHAR) ) )

NET_API_STATUS
RapConvertSingleEntry (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    );

NET_API_STATUS
RapConvertSingleEntryEx (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode,
    IN UINT_PTR Bias
    );

//
//
// RapDescArrayLength(Descriptor) - return the array length if the descriptor
// data has numeric characters, or return default length of 1.
//
// DWORD
// RapDescArrayLength(
//     IN OUT LPDESC Descriptor
//     );
//

#define RapDescArrayLength( Descriptor ) \
   ( ( DESC_CHAR_IS_DIGIT( *(Descriptor) )) ? RapAsciiToDecimal( &(Descriptor) ) : 1 )

//
// RapDescStringLength(Descriptor) - return the array length if the descriptor
// data has numeric characters, or return default length of 0, which indicates
// that there is no limit.
//
// DWORD
// RapDescStringLength(
//     IN OUT LPDESC Descriptor
//     );

#define RapDescStringLength( Descriptor ) \
   ( ( DESC_CHAR_IS_DIGIT( *(Descriptor) )) ? RapAsciiToDecimal( &(Descriptor) ) : 0 )

VOID
RapExamineDescriptor (
    IN LPDESC DescriptorString,
    IN LPDWORD ParmNum OPTIONAL,
    OUT LPDWORD StructureSize OPTIONAL,
    OUT LPDWORD LastPointerOffset OPTIONAL,
    OUT LPDWORD AuxDataCountOffset OPTIONAL,
    OUT LPDESC * ParmNumDescriptor OPTIONAL,
    OUT LPDWORD StructureAlignment OPTIONAL,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapGetFieldSize(
    IN LPDESC TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    );

//
// BOOL
// RapIsPointer(
//     IN CHAR DescChar
//     );
//

#define RapIsPointer(c)         ( ((c) > 'Z') ? TRUE : FALSE )

BOOL
RapIsValidDescriptorSmb (
    IN LPDESC Desc
    );

DWORD
RapLastPointerOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

LPDESC
RapParmNumDescriptor(
    IN LPDESC Descriptor,
    IN DWORD ParmNum,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

// LPVOID
// RapPossiblyAlignCount(
//     IN DWORD Count,
//     IN DWORD Pow2,
//     IN BOOL Native
//     );
#define RapPossiblyAlignCount(count,pow2,native) \
        ( (!(native)) ? (count) : (ROUND_UP_COUNT( (count), (pow2) )) )

// LPVOID
// RapPossiblyAlignPointer(
//     IN LPVOID Ptr,
//     IN DWORD Pow2,
//     IN BOOL Native
//     );
#define RapPossiblyAlignPointer(ptr,pow2,native) \
        ( (!(native)) ? (ptr) : (ROUND_UP_POINTER( (ptr), (pow2) )) )

DWORD
RapStructureAlignment (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapStructureSize (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    );

DWORD
RapTotalSize (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    );

//
// RapValueWouldBeTruncated(n): return TRUE if n would lose bits when we try
// to store it in 16 bits.
//
// BOOL
// RapValueWouldBeTruncated(
//     IN DWORD Value
//     );
//

#define RapValueWouldBeTruncated(n)             \
    ( ( (n) != (DWORD) (WORD) (n)) ? TRUE : FALSE )

#endif // ndef _RAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\oakdefs.h ===
/*++

Copyright (C) 1997 Cisco Systems, Inc.  All Rights Reserved.

Module Name:

    oakrpc.h

Abstract:

    This module contains the definitions requires for the
	ISAKMP/Oakley RPC interface.

Author:

	Derrell Piper (v-dpiper)

Facility:

    ISAKMP/Oakley

Revision History:

--*/
#ifndef __OAKRPC
#define __OAKRPC

typedef unsigned long IPADDR, *PIPADDR;
typedef unsigned long SPI, *PSPI;

/* Oakley hash algorithms */
#define OAK_MD5 1
#define OAK_SHA 2
#define OAK_TIGER 3

/* Oakley pseudo-random functions */
#define OAK_3DES_CBC_MAC 1

/* Oakley authentication methods */
// See oakrpc.idl



#define IPSEC_POLICY_CLEAR 0x00000010
#define IPSEC_POLICY_BLOCK 0x00000020


#define None 0
#define Auth 1
#define Encypt 2


// Status flags

#define STATUS_MM 0x1
#define STATUS_QM 0x2
#define STATUS_ME 0x4
#define STATUS_PEER 0x8

/* Oakley encryption algorithms */
#define OAK_DES_CBC 1
#define OAK_IDEA_CBC 2
#define OAK_BLOWFISH_CBC 3
#define OAK_RC5_R12_B64_CBC 4
#define OAK_3DES_CBC 5
#define OAK_CAST_CBC 6

#define OAK_MM_NO_STATE 0
#define OAK_MM_SA_SETUP 1
#define OAK_MM_KEY_EXCH 2
#define OAK_MM_KEY_AUTH 3
#define OAK_MM_CONTINUE 4

#define OAK_QM_SA_ACCEPT 7
#define OAK_QM_AUTH_AWAIT 8
#define OAK_QM_IDLE 9

typedef DWORD OAKLEY_STATE;

/* Oakley states */

#define OAK_QM_SA_ACCEPT		7
#define OAK_QM_AUTH_AWAIT		8
#define OAK_QM_IDLE				9
#define OAK_QM_CONNECT_WAIT		10

/* generic crypto lifetime */
typedef struct _Lifetime {
	DWORD		KBytes;
    DWORD		Seconds;
} OAKLEY_LIFETIME, *POAKLEY_LIFETIME;

/* generic algorithm descriptor */
typedef struct _Algorithm {
	ULONG	AlgorithmIdentifier;
	ULONG	KeySize;
	ULONG	Rounds;
} OAKLEY_ALGORITHM, *POAKLEY_ALGORITHM;

#define CRYPTO_VERSION_MAJOR 1		/* MajorVersion */
#define CRYPTO_VERSION_MINOR 0		/* MinorVersion */

#define MAX_ALGOS 3              //comp,ah,esp


typedef LARGE_INTEGER COOKIE, *PCOOKIE;


typedef struct _CryptoBundle {
    BYTE		MajorVersion;
    BYTE		MinorVersion;
    OAKLEY_ALGORITHM	EncryptionAlgorithm;
    OAKLEY_ALGORITHM	HashAlgorithm;
    OAKLEY_ALGORITHM    PseudoRandomFunction;  //unused
    BYTE		AuthenticationMethod;
    DWORD		OakleyGroup;
    DWORD		QuickModeLimit;
    OAKLEY_LIFETIME	Lifetime;
    BOOL		PfsIdentityRequired;
} CRYPTO_BUNDLE, *PCRYPTO_BUNDLE;


// LeadingBundleFlags, possible on each byte of the DWORD
#define BYTE_DES_MD5_2048 1
#define BYTE_DES_SHA_2048 2
#define BYTE_3DES_MD5_2048 3
#define BYTE_3DES_SHA_2048 4

typedef struct _IsakmpPolicy {
    GUID		PolicyId;
    BOOL		IdentityProtectionRequired;
    BOOL		PfsIdentityRequired;    
    DWORD               dwFlags;
    BYTE                bLeadingBundleFlags[4];
    DWORD               dwQMLimit;
    DWORD               dwLifetimeSec;
    DWORD               dwUnused[5];
} ISAKMP_POLICY, *PISAKMP_POLICY;

typedef struct _SpiPair {
    SPI			Inbound;
	SPI			Outbound;
} SPI_PAIR, *PSPI_PAIR;

typedef struct _CookiePair {
    COOKIE      Initiator;
    COOKIE      Responder;
} COOKIE_PAIR, *PCOOKIE_PAIR;


typedef struct _IsakmpSa {
    GUID		PolicyId;
    COOKIE_PAIR	Spi;
    IPADDR		Me;
    IPADDR		Peer;
    BOOL IdentityProtectionUsed;
    BOOL PerfectForwardSecrecyUsed;
    CRYPTO_BUNDLE CryptoSelected;
    OAKLEY_STATE CurrentState;
} ISAKMP_SA, *PISAKMP_SA;


typedef struct _IpsecSa {
    GUID		PolicyId;
    SPI_PAIR	Spi;
    IPADDR		Source;
    IPADDR		Destination;
    IPADDR		Tunnel;
    OAKLEY_ALGORITHM	ConfidentialityAlgorithm;
    OAKLEY_ALGORITHM	IntegrityAlgorithm;
    OAKLEY_STATE CurrentState;
} IPSEC_SA, *PIPSEC_SA;

typedef struct  _IPSEC_ALGO_INFO {
    ULONG   algoIdentifier;     // ESP_ALGO or AH_ALGO
    ULONG   secondaryAlgoIdentifier;   // for hmac in ESP case
    ULONG   operation;       // of type OPERATION_E (ipsec.h)	  
    ULONG   algoKeylen;         // len in bytes
    ULONG   algoRounds;         // # of algo rounds
} IPSEC_ALGO_INFO, *PIPSEC_ALGO_INFO;


typedef struct {
    LIFETIME	        Lifetime;
    DWORD		Flags;
    BOOL		PfsQMRequired;
    DWORD               Count;  //Number of Algos
    IPSEC_ALGO_INFO     Algos[MAX_ALGOS];
} IPSEC_ALG_TYPE, *PIPSEC_ALG_TYPE;

typedef enum _AuthenicationEnum {	
	OAK_PRESHARED_KEY	= 1,
	OAK_DSS_SIGNATURE	= 2,
	OAK_RSA_SIGNATURE	= 3,
	OAK_RSA_ENCRYPTION	= 4,
	OAK_SSPI	= 5
}AuthenticationEnum ;

typedef struct _SA_FAIL_INFO {
    GUID        PolicyId;
    IPSEC_FILTER Filter;
    DWORD Status;
    DWORD Flags;
} SA_FAIL_INFO;  


typedef struct _IPSEC_AUTH_INFO
    {
    AuthenticationEnum AuthMethod;
    wchar_t *AuthInfo;
    DWORD AuthInfoSize;
    }	IPSEC_AUTH_INFO, *PIPSEC_AUTH_INFO;


#endif /* __OAKRPC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\remdef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RemDef.h

Abstract:

    Definition of descriptor strings for Net API remote calls.
    Names defined in this file follow the format:

                RemPrefix_RemDescriptor

    where RemPrefix is either REM16, REM32, or REMSmb, indicating whether
          the descriptor is for 16-bit or 32-bit data for conversion,
          or for an actual XACT SMB.

          RemDescriptor follows one of the following formats:

             StructureName_level         -  info structures
             StructureName_level_suffix  -  special info structures
             ApiName_P                   -  parameter descriptors

    This file also contains some field index equates.  These are similar
    to parmnum equates, except that the field index equates are guaranteed
    to reflect the field's position in the descriptor.  (See the
    RapParmNumDescriptor routine for more information on how this is used.)
    If the parmnum value (in the LM*.H header files) is identical to the
    field index value, then no field index equate is given.  Where the numbers
    are different, then for each parmnum of the form:

                ParmNumPrefix_PARMNUM

    this file will have an equate of the form:

                ParmNumPrefix_FIELDINDEX

    where ParmNumPrefix is, for instance, PRJ_PRIORITY (for print job priority).

Notes:

    1. While the above formats should be followed, the equate names
       cannot exceed 32 characters, and abbreviated forms should be used.

    2. The remote API mechanism requires that the return parameter length
       is less than or equal to the send parameter length. This assumption
       is made in order to reduce the overhead in the buffer management
       required for the API call. This restriction is not unreasonable
       as the APIs were designed to return data in the data buffer and just
       use return parameters for data lengths & file handles etc.
       HOWEVER, if it has been spec'ed to return a large parameter field, it
       is possible to pad the size of the send parameter using a REM_FILL_BYTES
       field to meet the above restriction.

    3. Some of the descriptors have different size byte arrays in the 16 and
       32-bit versions.  This allows the 32-bit version to be UNICODE where
       the 16-bit version is an 8-bit (codepage) string.  RapConvertSingleEntry
       automatically makes this conversion if it detects one byte count being
       twice the other's.

Author:

    John Rogers (JohnRo)
    Shanku Niyogi (w-shanku)

Environment:

    Portable to just about anything.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Ported from Lanman 2.0 code.

    17-Jan-1992 rfirth
        Changed REM32_share_info_2 from "zQDzDDDzzQ" to "zQDzDXDzzQ" to allow
        shi2_max_uses field to go from -1 (0xffff) to -1L (0xffffffff), not
        65535L

    17-Aug-1992 JohnRo
        RAID 3607: REPLLOCK.RP$ is being created during tree copy.
        Re-ordered revision history.
    01-Sep-1992 JohnRo
        RAID 5088: NetGetDCName to downlevel doesn't UNICODE translate.
    09-Sep-1992 JohnRo
        RAID 1100: last string in access type truncated in NetAuditRead.
--*/

#ifndef _REMDEF_
#define _REMDEF_

//====================================================================
//
// Conversion descriptors. The 16 and 32 bit versions must have the
// same number of fields. Fields not present in one version can be
// indicated with the REM_IGNORE ('Q') character.
//
// These strings should NOT be passed over the network.
//
//====================================================================

#define REM16_share_info_0              "B13"
#define REM32_share_info_0              "z"
#define REM16_share_info_1              "B13BWz"
#define REM32_share_info_1              "zQDz"
#define REM16_share_info_2              "B13BWzWWWzB9B"
#define REM32_share_info_2              "zQDzDXDzzQ"

#define SHI_REMARK_FIELDINDEX           4
#define SHI_PERMISSIONS_FIELDINDEX      5
#define SHI_MAX_USES_FIELDINDEX         6
#define SHI_PASSWD_FIELDINDEX           9

#define REM16_share_info_90             "B13BWz"
#define REM16_share_info_92             "zzz"
#define REM16_share_info_93             "zzz"

#define REM16_share_info_0_setinfo      "U"
#define REM32_share_info_0_setinfo      "z"
#define REM16_share_info_1_setinfo      "UUUz"
#define REM32_share_info_1_setinfo      "zQDz"
#define REM16_share_info_2_setinfo      "UUUzWWUUB9U"
#define REM32_share_info_2_setinfo      "zQDzQDDzQQ"

#define REM16_share_info_90_setinfo     "B13BWz"
#define REM16_share_info_91_setinfo     "B13BWzWWWOB9BB9BWzWWzWW"

#define REM16_NetShareEnum_P            "WrLeh"
#define REM16_NetShareGetInfo_P         "zWrLh"
#define REM16_NetShareSetInfo_P         "zWsTP"
#define REM16_NetShareAdd_P             "WsT"
#define REM16_NetShareDel_P             "zW"
#define REM16_NetShareCheck_P           "zh"

#define REM16_session_info_0            "z"
#define REM32_session_info_0            "z"
#define REM16_session_info_1            "zzWWWDDD"
#define REM32_session_info_1            "zzQDQDDD"
#define REM16_session_info_2            "zzWWWDDDz"
#define REM32_session_info_2            "zzQDQDDDz"
#define REM16_session_info_10           "zzDD"
#define REM32_session_info_10           "zzDD"

#define REM16_NetSessionEnum_P          "WrLeh"
#define REM16_NetSessionGetInfo_P       "zWrLh"
#define REM16_NetSessionDel_P           "zW"

#define REM16_connection_info_0         "W"
#define REM32_connection_info_0         "D"
#define REM16_connection_info_1         "WWWWDzz"
#define REM32_connection_info_1         "DDDDDzz"

#define REM16_NetConnectionEnum_P       "zWrLeh"

#define REM16_file_info_0               "W"
#define REM32_file_info_0               "D"
#define REM16_file_info_1               "WWWzz"
#define REM32_file_info_1               "DDDzz"
#define REM16_file_info_2               "D"
#define REM32_file_info_2               "D"
#define REM16_file_info_3               "DWWzz"
#define REM32_file_info_3               "DDDzz"
#define REM16_file_info_50              "QB16BBDZ??ZZZ"

#define REM16_NetFileEnum_P             "zWrLeh"
#define REM16_NetFileEnum2_P            "zzWrLehb8g8"
#define REM16_NetFileGetInfo_P          "WWrLh"
#define REM16_NetFileGetInfo2_P         "DWrLh"
#define REM16_NetFileClose_P            "W"
#define REM16_NetFileClose2_P           "D"

#define REM16_server_info_0             "QB16"
#define REM32_server_info_0             "Dz"
#define REM16_server_info_1             "QB16BBDz"
#define REM32_server_info_1             "DzDDDz"
#define REM16_server_info_2             "QB16BBDzJJJWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWz"
#define REM32_server_info_2             "DzDDDzQQQDXQQQQQDDDQDzQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM16_server_info_3             "QB16BBDzJJJWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWzDWz"
#define REM32_server_info_3             "DzDDDzQQQDXQQQQQDDDQDzQQQQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM32_server_info_50            "QB16BBDzWWzzz"

#define REM32_server_info_100           "Dz"
#define REM32_server_info_101           "DzDDDz"
#define REM32_server_info_102           "DzDDDzDDWDDDz"
#define REM32_server_info_402           "DDDzDDDzDDDDDDDDDDDDDDDDDDDDDDz"
#define REM32_server_info_403           "DDDzDDDzDDDDDDDDDDDDDDDDDDDDDDzDDz"

#define REM16_server_info_1_setinfo     "B16BBDz"
#define REM32_server_info_1_setinfo     "zDDDz"
#define REM16_server_info_2_setinfo     "B16BBDzDDDWWzWWWWWWWB21BOWWWWWWWWWWWWWWWWWWWWWWz"
#define REM32_server_info_2_setinfo     "zDDDzQQQDDQQQQQWDDQQOQQQQQQQQQQQQQQQQQQQQQQQ"

#define REM16_server_admin_command      "B"

#define REM16_server_diskenum_0         "B3"
#define REM32_server_diskenum_0         "B3"

#define REM16_authenticator_info_0      "B8D"

#define REM16_server_diskft_100         "B"
#define REM16_server_diskft_101         "BBWWWWDW"
#define REM16_server_diskft_102         "BBWWWWDN"
#define REM16_server_diskfterr_0        "DWWDDW"
#define REM16_ft_info_0                 "WWW"
#define REM16_ft_drivestats_0           "BBWDDDDDDD"
#define REM16_ft_error_info_1           "DWWDDWBBDD"

#define REM16_I_NetServerDiskEnum_P     "WrLeh"
#define REM16_I_NetServerDiskGetInfo_P  "WWrLh"
#define REM16_I_FTVerifyMirror_P        "Wz"
#define REM16_I_FTAbortVerify_P         "W"
#define REM16_I_FTGetInfo_P             "WrLh"
#define REM16_I_FTSetInfo_P             "WsTP"
#define REM16_I_FTLockDisk_P            "WWh"
#define REM16_I_FTFixError_P            "Dzhh2"
#define REM16_I_FTAbortFix_P            "D"
#define REM16_I_FTDiagnoseError_P       "Dhhhh"
#define REM16_I_FTGetDriveStats_P       "WWrLh"
#define REM16_I_FTErrorGetInfo_P        "DWrLh"

#define REM16_NetServerEnum_P           "WrLeh"
#define REM16_I_NetServerEnum_P         "WrLeh"
#define REM16_NetServerEnum2_P          "WrLehDz"
#define REM16_I_NetServerEnum2_P        "WrLehDz"
#define REM16_NetServerGetInfo_P        "WrLh"
#define REM16_NetServerSetInfo_P        "WsTP"
#define REM16_NetServerDiskEnum_P       "WrLeh"
#define REM16_NetServerAdminCommand_P   "zhrLeh"
#define REM16_NetServerReqChalleng_P    "zb8g8"
#define REM16_NetServerAuthenticat_P    "zb8g8"
#define REM16_NetServerPasswordSet_P    "zb12g12b16"

#define REM16_NetAuditOpen_P            "h"
#define REM16_NetAuditClear_P           "zz"
#define REM16_NetAuditRead_P            "zb16g16DhDDrLeh"

#define REM16_audit_entry_fixed         "WWJWW"
#define REM32_audit_entry_fixed         "DDGDD"
#define REM16_audit_entry_srvstatus     "W"
#define REM32_audit_entry_srvstatus     "D"
#define REM16_audit_entry_sesslogon     "WWW"
#define REM32_audit_entry_sesslogon     "DDD"
#define REM16_audit_entry_sesslogoff    "WWW"
#define REM32_audit_entry_sesslogoff    "DDD"
#define REM16_audit_entry_sesspwerr     "WW"
#define REM32_audit_entry_sesspwerr     "DD"
#define REM16_audit_entry_connstart     "WWWW"
#define REM32_audit_entry_connstart     "DDDD"
#define REM16_audit_entry_connstop      "WWWWW"
#define REM32_audit_entry_connstop      "DDDDD"
#define REM16_audit_entry_connrej       "WWWW"
#define REM32_audit_entry_connrej       "DDDD"
#define REM16_audit_entry_resaccess     "WWWWWWW"
#define REM32_audit_entry_resaccess     "DDDDDDD"
#define REM16_audit_entry_resaccess2    "WWWWWWD"
// Note: 16-bit ae_resaccess and ae_resaccess2 both get converted to
// 32-bit ae_resaccess.
#define REM16_audit_entry_resaccessrej  "WWWW"
#define REM32_audit_entry_resaccessrej  "DDDD"
#define REM16_audit_entry_closefile     "WWWWDW"
#define REM32_audit_entry_closefile     "DDDDDD"
#define REM16_audit_entry_servicestat   "WWWWDWW"
#define REM32_audit_entry_servicestat   "DDDDDDD"
#define REM16_audit_entry_aclmod        "WWWWW"
#define REM32_audit_entry_aclmod        "DDDDD"
#define REM16_audit_entry_uasmod        "WWWWWW"
#define REM32_audit_entry_uasmod        "DDDDDD"
#define REM16_audit_entry_netlogon      "WWWW"
#define REM32_audit_entry_netlogon      "DDDD"
#define REM16_audit_entry_netlogoff     "WWWW"
#define REM32_audit_entry_netlogoff     "DDDD"
#define REM16_audit_entry_acclim        "WWWW"
#define REM32_audit_entry_acclim        "DDDD"
#define REM16_audit_entry_lockout       "WWWW"
#define REM32_audit_entry_lockout       "DDDD"

#define REM16_AuditLogReturnBuf         "K"

#define REM16_NetErrorLogOpen_P         "h"
#define REM16_NetErrorLogClear_P        "zz"
#define REM16_NetErrorLogRead_P         "zb16g16DhDDrLeh"

#define REM16_ErrorLogReturnBuf         "K"

#define REM16_chardev_info_0            "B9"
#define REM32_chardev_info_0            "z"
#define REM16_chardev_info_1            "B10WB22D"
#define REM32_chardev_info_1            "zDzD"
#define REM16_chardevQ_info_0           "B13"
#define REM32_chardevQ_info_0           "z"
#define REM16_chardevQ_info_1           "B14WzWW"
#define REM32_chardevQ_info_1           "zDzDD"

#define REM16_chardevQ_info_1_setinfo   "UWzUU"
#define REM32_chardevQ_info_1_setinfo   "QWzQQ"

#define REM16_NetCharDevEnum_P          "WrLeh"
#define REM16_NetCharDevGetInfo_P       "zWrLh"
#define REM16_NetCharDevControl_P       "zW"
#define REM16_NetCharDevQEnum_P         "zWrLeh"
#define REM16_NetCharDevQGetInfo_P      "zzWrLh"
#define REM16_NetCharDevQSetInfo_P      "zWsTP"
#define REM16_NetCharDevQPurge_P        "z"
#define REM16_NetCharDevQPurgeSelf_P    "zz"

#define REM16_msg_info_0                "B16"
#define REM32_msg_info_0                "z"
#define REM16_msg_info_1                "B16BBB16"
#define REM32_msg_info_1                "zQDz"
#define REM16_send_struct               "K"

#define REM16_NetMessageNameEnum_P      "WrLeh"
#define REM16_NetMessageNameGetInfo_P   "zWrLh"
#define REM16_NetMessageNameAdd_P       "zW"
#define REM16_NetMessageNameDel_P       "zW"
#define REM16_NetMessageNameFwd_P       "zzW"
#define REM16_NetMessageNameUnFwd_P     "z"
#define REM16_NetMessageBufferSend_P    "zsT"
#define REM16_NetMessageFileSend_P      "zz"
#define REM16_NetMessageLogFileSet_P    "zW"
#define REM16_NetMessageLogFileGet_P    "rLh"

#define REM16_service_info_0            "B16"
#define REM32_service_info_0            "z"
#define REM16_service_info_1            "B16WDW"
#define REM32_service_info_1            "zDDD"
#define REM16_service_info_2            "B16WDWB64QQ"
#define REM32_service_info_2            "zDDDzDz"
#define REM16_service_cmd_args          "K"

#define REM16_NetServiceEnum_P          "WrLeh"
#define REM16_NetServiceControl_P       "zWWrL"
#define REM16_NetServiceInstall_P       "zF88sg88T"     // See NOTE 2
#define REM16_NetServiceGetInfo_P       "zWrLh"

#define REM16_access_info_0             "z"
#define REM32_access_info_0             "z"
#define REM16_access_info_0_setinfo     "z"
#define REM32_access_info_0_setinfo     "z"
#define REM16_access_info_1             "zWN"
#define REM32_access_info_1             "zDA"
#define REM16_access_info_1_setinfo     "OWN"
#define REM32_access_info_1_setinfo     "ODA"
#define REM16_access_list               "B21BW"
#define REM16_access_list_filler        "QQQ"
#define REM32_access_list               "zQD"

#define ACCESS_ATTR_FIELDINDEX          2

#define REM16_NetAccessEnum_P           "zWWrLeh"
#define REM16_NetAccessGetInfo_P        "zWrLh"
#define REM16_NetAccessSetInfo_P        "zWsTP"
#define REM16_NetAccessAdd_P            "WsT"
#define REM16_NetAccessDel_P            "z"
#define REM16_NetAccessGetUserPerms_P   "zzh"

#define REM16_group_info_0              "B21"
#define REM32_group_info_0              "z"
#define REM16_group_info_1              "B21Bz"
#define REM32_group_info_1              "zQz"
#define REM16_group_users_info_0        "B21"
#define REM32_group_users_info_0        "z"
#define REM16_group_users_info_1        "B21BN"
#define REM16_group_users_info_0_set    "B21BN"
#define REM32_group_users_info_0_set    "zQA"

#define REM16_group_info_1_setinfo      "UUz"
#define REM32_group_info_1_setinfo      "QQz"

#define GRPI_COMMENT_FIELDINDEX         3

#define REM16_NetGroupEnum_P            "WrLeh"
#define REM16_NetGroupAdd_P             "WsT"
#define REM16_NetGroupDel_P             "z"
#define REM16_NetGroupAddUser_P         "zz"
#define REM16_NetGroupDelUser_P         "zz"
#define REM16_NetGroupGetUsers_P        "zWrLeh"
#define REM16_NetGroupSetUsers_P        "zWsTW"
#define REM16_NetGroupGetInfo_P         "zWrLh"
#define REM16_NetGroupSetInfo_P         "zWsTP"

#define REM16_user_info_0               "B21"
#define REM32_user_info_0               "z"
#define REM16_user_info_1               "B21BB16DWzzWz"
#define REM32_user_info_1               "zQb16DDzzDz"
#define REM32_user_info_1_NOCRYPT       "zQzDDzzDz"
#define REM32_user_info_1_OWF           "zQB16DDzzDz"
#define REM16_user_info_2               "B21BB16DWzzWzDzzzzJJJDWb21WWzWW"
#define REM32_user_info_2               "zQb16DDzzDzDzzzzGGGDDb21DDzDD"
#define REM32_user_info_2_NOCRYPT       "zQzDDzzDzDzzzzGGGDDb21DDzDD"
#define REM32_user_info_22              "zQB16DDzzDzDzzzzGGGDDb21DDzDD"
#define REM16_user_info_10              "B21Bzzz"
#define REM32_user_info_10              "zQzzz"
#define REM16_user_info_11              "B21BzzzWDDzzJJWWzWzDWb21W"
#define REM32_user_info_11              "zQzzzDDDzzGGDDzDzDDb21D"

#define REM16_user_info_1_setinfo       "UUB16UWzzWz"
#define REM32_user_info_1_setinfo       "zQB16DDzzDz"
#define REM32_user_info_1_setinfo_NOCRYPT "zQzDDzzDz"
#define REM16_user_info_2_setinfo       "UUB16UWzzWzDzzzzUUJDWB21WWzWW"
#define REM32_user_info_2_setinfo       "QQzQDzzDzDzzzzQQGDDB21DDzDD"
#define REM32_user_info_2_setinfo_NOCRYPT "QQzQDzzDzDzzzzQQGDDB21DDzDD"

#define REM32_user_info_3               "zQb16DDzzDzDzzzzGGGDDb21DDzDDDDzzD"
#define REM32_user_info_3_NOCRYPT       "zQzDDzzDzDzzzzGGGDDb21DDzDDDDzzD"

#define REM32_user_info_3_setinfo         "QQzQDzzDzDzzzzQQGDDB21DDzDDDDzzD"
#define REM32_user_info_3_setinfo_NOCRYPT "QQzQDzzDzDzzzzQQGDDB21DDzDDDDzzD"


#define USER_PASSWD_FIELDINDEX          3
#define USER_PRIV_FIELDINDEX            5
#define USER_DIR_FIELDINDEX             6
#define USER_COMMENT_FIELDINDEX         7
#define USER_USER_FLAGS_FIELDINDEX      8
#define USER_SCRIPT_PATH_FIELDINDEX     9
#define USER_AUTH_FLAGS_FIELDINDEX      10
#define USER_FULL_NAME_FIELDINDEX       11
#define USER_USR_COMMENT_FIELDINDEX     12
#define USER_PARMS_FIELDINDEX           13
#define USER_WORKSTATION_FIELDINDEX     14
#define USER_ACCT_EXPIRES_FIELDINDEX    17
#define USER_MAX_STORAGE_FIELDINDEX     18
#define USER_LOGON_HOURS_FIELDINDEX     20
#define USER_LOGON_SERVER_FIELDINDEX    23
#define USER_COUNTRY_CODE_FIELDINDEX    24
#define USER_CODE_PAGE_FIELDINDEX       25

#define REM16_user_info_100             "DWW"
#define REM16_user_info_101             "B60"
#define REM16_user_modals_info_0        "WDDDWW"
#define REM32_user_modals_info_0        "DDDDDQ"


#define MODAL0_MIN_LEN_FIELDINDEX       1
#define MODAL0_MAX_AGE_FIELDINDEX       2
#define MODAL0_MIN_AGE_FIELDINDEX       3
#define MODAL0_FORCEOFF_FIELDINDEX      4
#define MODAL0_HISTLEN_FIELDINDEX       5

#define REM16_user_modals_info_1        "Wz"
#define REM32_user_modals_info_1        "Dz"

#define REM16_user_modals_info_0_setinfo "WDDDWU"
#define REM32_user_modals_info_0_setinfo "DDDDDQ"
#define REM16_user_modals_info_1_setinfo "Wz"
#define REM32_user_modals_info_1_setinfo "Dz"

#define MODAL1_ROLE_FIELDINDEX          1
#define MODAL1_PRIMARY_FIELDINDEX       2

#define REM16_user_modals_info_100      "B50"
#define REM16_user_modals_info_101      "zDDzDD"
#define REM16_user_logon_info_0         "B21B"
#define REM32_user_logon_info_0         "zQ"
#define REM16_user_logon_info_1         "WB21BWDWWJJJJDJJzzzD"
#define REM32_user_logon_info_1         "QzQDDDDGGGGDGGzzzD"
#define REM16_user_logon_info_2         "B21BzzzJ"
#define REM32_user_logon_info_2         "zQzzzG"
#define REM16_user_logoff_info_1        "WDW"
#define REM32_user_logoff_info_1        "QDW"

#define REM16_NetUserEnum_P             "WrLeh"
#define REM16_NetUserAdd_P              "WsTW"
#define REM16_NetUserAdd2_P             "WsTWW"
#define REM16_NetUserDel_P              "z"
#define REM16_NetUserGetInfo_P          "zWrLh"
#define REM16_NetUserSetInfo_P          "zWsTPW"
#define REM16_NetUserSetInfo2_P         "zWsTPWW"
#define REM16_NetUserPasswordSet_P      "zb16b16W"
#define REM16_NetUserPasswordSet2_P     "zb16b16WW"
#define REM16_NetUserGetGroups_P        "zWrLeh"
#define REM16_NetUserSetGroups_P        "zWsTW"
#define REM16_NetUserModalsGet_P        "WrLh"
#define REM16_NetUserModalsSet_P        "WsTP"
#define REM16_NetUserEnum2_P            "WrLDieh"
#define REM16_NetUserValidate2_P        "Wb62WWrLhWW"

#define REM16_wksta_info_0              "QWDzzzzQBBQQDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REM32_wksta_info_0              "DQQQzQzzDDDzQQQQQQQQQQQQQQQQQQQQQQQQQ"
#define REM16_wksta_info_1              "QWDzzzzQBBQQDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REM16_wksta_info_10             "QzzzQBBzz"
#define REM32_wksta_info_100            "DzzDD"
#define REM32_wksta_info_101            "DzzDDz"
#define REM32_wksta_info_102            "DzzDDzD"
#define REM32_wksta_info_302            "DDDDDDDDDDDDDDDDDzDzD"
#define REM32_wksta_info_402            "DDDDDDDDDDDDDDDDDzDDD"
#define REM32_wksta_info_502            "DDDDDDDDDDDDDDDDDBBBBBBBBBBBBBB"

#define REM16_use_info_0                "B9Bz"
#define REM32_use_info_0                "zQz"
#define REM16_use_info_1                "B9BzzWWWW"
#define REM32_use_info_1                "zQzzDDDD"

#define REM16_printQ_0                  "B13"
#ifndef UNICODE
#define REM32_printQ_0                  REM16_printQ_0
#else
#define REM32_printQ_0                  "B26"
#endif
// Can't do set info of level 0.

#define REM16_printQ_1                  "B13BWWWzzzzzWW"
#ifndef UNICODE
#define REM32_printQ_1                  REM16_printQ_1
#else
#define REM32_printQ_1                  "B26WWWWzzzzzWW"
#endif
#define PRQ_PRIORITY_LVL1_FIELDINDEX         3
#define PRQ_STARTTIME_LVL1_FIELDINDEX         4
#define PRQ_UNTILTIME_LVL1_FIELDINDEX          5
#define PRQ_SEPARATOR_LVL1_FIELDINDEX           6
#define PRQ_PROCESSOR_LVL1_FIELDINDEX            7
#define PRQ_DESTINATIONS_LVL1_FIELDINDEX          8
#define PRQ_PARMS_LVL1_FIELDINDEX                  9
#define PRQ_COMMENT_LVL1_FIELDINDEX                 10

#define REM16_printQ_1_setinfo          "UUWWWzzzzzUU"
#define REM32_printQ_1_setinfo          REM32_printQ_1

#define REM16_printQ_2                  "B13BWWWzzzzzWN"
#ifndef UNICODE
#define REM32_printQ_2                  REM16_printQ_2
#else
#define REM32_printQ_2                  "B26WWWWzzzzzWN"
#endif
// Can't do set info of level 2.

#define REM16_printQ_3                  "zWWWWzzzzWWzzl"
#define REM32_printQ_3                  REM16_printQ_3
#define PRQ_PRIORITY_LVL3_FIELDINDEX      2
#define PRQ_STARTTIME_LVL3_FIELDINDEX      3
#define PRQ_UNTILTIME_LVL3_FIELDINDEX       4
#define PRQ_SEPARATOR_LVL3_FIELDINDEX         6
#define PRQ_PROCESSOR_LVL3_FIELDINDEX          7
#define PRQ_PARMS_LVL3_FIELDINDEX               8
#define PRQ_COMMENT_LVL3_FIELDINDEX              9
#define PRQ_PRINTERS_LVL3_FIELDINDEX                12
#define PRQ_DRIVERNAME_LVL3_FIELDINDEX               13
#define PRQ_DRIVERDATA_LVL3_FIELDINDEX                14

#define REM16_printQ_3_setinfo          "UWWWUzzzzUUzzl"
#define REM32_printQ_3_setinfo          REM32_printQ_3

#define REM16_printQ_4                  "zWWWWzzzzWNzzl"
#define REM32_printQ_4                  REM16_printQ_4
// Can't do set info of level 4.

#define REM16_printQ_5                  "z"
#define REM32_printQ_5                  REM16_printQ_5
// Can't do set info of level 5.

#define REM16_printQ_52                 "WzzzzzzzzWzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
#define REM32_printQ_52                 REM16_printQ_52

#define REM16_DosPrintQEnum_P           "WrLeh"
#define REM16_DosPrintQGetInfo_P        "zWrLh"
#define REM16_DosPrintQSetInfo_P        "zWsTP"
#define REM16_DosPrintQAdd_P            "WsT"
#define REM16_DosPrintQDel_P            "z"
#define REM16_DosPrintQPause_P          "z"
#define REM16_DosPrintQPurge_P          "z"
#define REM16_DosPrintQContinue_P       "z"

#define REM16_print_job_0               "W"
#define REM32_print_job_0               REM16_print_job_0
// print_job_0 cannot be used with setinfo.

#define REM16_print_job_1               "WB21BB16B10zWWzJDz"
#ifndef UNICODE
#define REM32_print_job_1               "WB21BB16B10zWWzGDz"
#else
#define REM32_print_job_1               "WB42WB32B20zWWzGDz"
#endif
#define PRJ_NOTIFYNAME_LVL1_FIELDINDEX        4
#define PRJ_DATATYPE_LVL1_FIELDINDEX             5
#define PRJ_PARMS_LVL1_FIELDINDEX                   6
#define PRJ_POSITION_LVL1_FIELDINDEX                 7
#define PRJ_COMMENT_LVL1_FIELDINDEX                       12

#define REM16_print_job_1_setinfo       "UUUB16B10zWUUUUz"
#define REM32_print_job_1_setinfo       REM32_print_job_1

#define REM16_print_job_2               "WWzWWJDzz"
#define REM32_print_job_2               "WWzWWGDzz"
// print_job_2 cannot be used with setinfo.

#define REM16_print_job_3               "WWzWWJDzzzzzzzzzzlz"
#define REM32_print_job_3               "WWzWWGDzzzzzzzzzzlz"
#define PRJ_PRIORITY_LVL3_FIELDINDEX      2
#define PRJ_POSITION_LVL3_FIELDINDEX        4
#define PRJ_COMMENT_LVL3_FIELDINDEX             8
#define PRJ_DOCUMENT_LVL3_FIELDINDEX             9
#define PRJ_NOTIFYNAME_LVL3_FIELDINDEX            10
#define PRJ_DATATYPE_LVL3_FIELDINDEX               11
#define PRJ_PARMS_LVL3_FIELDINDEX                   12
#define PRJ_PROCPARMS_LVL3_FIELDINDEX                   16
#define PRJ_DRIVERDATA_LVL3_FIELDINDEX                    18

#define REM16_print_job_3_setinfo       "UWUWUUUzzzzzUUUzUlU"
#define REM32_print_job_3_setinfo       REM32_print_job_3

#define REM16_print_job_info_1_setinfo  "WB21BB16B10zWWODDz"
#define REM16_print_job_info_3_setinfo  "WWzWWDDzzzzzOzzzzlO"

#define REM16_DosPrintJobEnum_P         "zWrLeh"
#define REM16_DosPrintJobGetInfo_P      "WWrLh"
#define REM16_DosPrintJobSetInfo_P      "WWsTP"
#define REM16_DosPrintJobAdd_P          "zsTF129g129h"  // See note 2
#define REM16_DosPrintJobSchedule_P     "W"
#define REM16_DosPrintJobDel_P          "W"
#define REM16_DosPrintJobPause_P        "W"
#define REM16_DosPrintJobContinue_P     "W"

#define REM16_print_dest_0              "B9"
#ifndef UNICODE
#define REM32_print_dest_0              REM16_print_dest_0
#else
#define REM32_print_dest_0              "B18"
#endif
// Can't do set info of level 0.

#define REM16_print_dest_1              "B9B21WWzW"
#ifndef UNICODE
#define REM32_print_dest_1              REM16_print_dest_1
#else
#define REM32_print_dest_1              "B18B42WWzW"
#endif
// Can't do set info of level 1.

#define REM16_print_dest_2              "z"
#define REM32_print_dest_2              REM16_print_dest_2
// Can't do set info of level 2.

#define REM16_print_dest_3              "zzzWWzzzWW"
#define REM32_print_dest_3              REM16_print_dest_3
#define REM16_print_dest_info_3_setinfo "zOzWWOzzWW"
// Level 3 parmnums and field indexes are identical, so no equates here.

#define REM16_print_dest_3_setinfo      "UUzUUUzzUU"
#define REM32_print_dest_3_setinfo      REM32_print_dest_3

#define REM16_DosPrintDestEnum_P        "WrLeh"
#define REM16_DosPrintDestGetInfo_P     "zWrLh"
#define REM16_DosPrintDestControl_P     "zW"
#define REM16_DosPrintDestAdd_P         "WsT"
#define REM16_DosPrintDestSetInfo_P     "zWsTP"
#define REM16_DosPrintDestDel_P         "z"

#define REM16_NetProfileSave_P          "zDW"
#define REM16_NetProfileLoad_P          "zDrLD"

#define REM16_profile_load_info         "WDzD"

#define REM16_statistics_info           "B"

#define REM16_statistics2_info_W        "B120"
#define REM16_stat_workstation_0        "JDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REM32_stat_workstation_0        "GDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REM16_statistics2_info_S        "B68"
#define REM16_stat_server_0             "JDDDDDDDDDDDDDDDD"
#define REM32_stat_server_0             "GDDDDDDDDDDDDDDDD"

#define REM16_NetStatisticsGet_P        "rLeh"
#define REM16_NetStatisticsClear_P      ""

#define REM16_NetStatisticsGet2_P       "zDWDrLh"

#define REM16_NetRemoteTOD_P            "rL"

#define REM16_time_of_day_info          "JDBBBBWWBBWB"
#define REM32_time_of_day_info          "GDDDDDXDDDDD"

#define REM16_netbios_info_0            "B17"
#define REM16_netbios_info_1            "B17B9BBWWDWWW"

#define REM16_NetBiosEnum_P             "WrLeh"
#define REM16_NetBiosGetInfo_P          "zWrLh"

#define REM16_Spl_open_data             "zzlzzzzzz"
#define REM16_plain_data                "K"

#define REM16_NetSplQmAbort_P           "Di"
#define REM16_NetSplQmClose_P           "Di"
#define REM16_NetSplQmEndDoc_P          "Dhi"
#define REM16_NetSplQmOpen_P            "zTsWii"
#define REM16_NetSplQmStartDoc_P        "Dzi"
#define REM16_NetSplQmWrite_P           "DTsi"

#define REM16_configgetall_info         "B"
#define REM32_configgetall_info         REM16_configgetall_info
#define REM16_configget_info            "B"
#define REM32_configget_info            REM16_configget_info
#define REM16_configset_info_0          "zz"
#define REM32_configset_info_0          REM16_configset_info_0

#define REM16_NetConfigGetAll_P         "zzrLeh"
#define REM16_NetConfigGet_P            "zzzrLe"
#define REM16_NetConfigSet_P            "zzWWsTD"

#define REM16_NetBuildGetInfo_P         "DWrLh"
#define REM16_build_info_0              "WD"

#define REM16_NetGetDCName_P            "zrL"

#define REM16_dc_name                   "B18"
#ifndef UNICODE
#define REM32_dc_name                   REM16_dc_name
#else
#define REM32_dc_name                   "B36"
#endif

#define REM16_challenge_info_0          "B8"
#define REM16_account_delta_info_0      "K"
#define REM16_account_sync_info_0       "K"

#define REM16_NetAccountDeltas_P        "zb12g12b24WWrLehg24"
#define REM16_NetAccountSync_P          "zb12g12DWrLehig24"

#define REM16_NetLogonEnum_P            "WrLeh"

#define REM16_I_NetPathType_P           "ziD"
#define REM16_I_NetPathCanonicalize_P   "zrLziDD"
#define REM16_I_NetPathCompare_P        "zzDD"
#define REM16_I_NetNameValidate_P       "zWD"
#define REM16_I_NetNameCanonicalize_P   "zrLWD"
#define REM16_I_NetNameCompare_P        "zzWD"

#define REM16_LocalOnlyCall             ""
#define REM32_LocalOnlyCall             ""

//
// The following definitions exist for DOS LANMAN--Windows 3.0
// Normally, there is a const char far * servername
// as the first parameter, but this will be ignored (sort of)
//

#define REM16_DosPrintJobGetId_P        "WrL"
#define REM16_GetPrintId                "WB16B13B"
#define REM16_NetRemoteCopy_P           "zzzzWWrL"
#define REM16_copy_info                 "WB1"
#define REM16_NetRemoteMove_P           "zzzzWWrL"
#define REM16_move_info                 "WB1"
#define REM16_NetHandleGetInfo_P        "WWrLh"
#define REM16_NetHandleSetInfo_P        "WWsTP"
#define REM16_handle_info_1             "DW"
#define REM16_handle_info_2             "z"
#define REM16_WWkstaGetInfo_P           "WrLhOW"

// The following strings are defined for RIPL APIs

#define REM16_RplWksta_info_0           "z"
#define REM16_RplWksta_info_1           "zz"
#define REM16_RplWksta_info_2           "b13b16b15b15zN"
#define REM16_RplWksta_info_3           "b16b49"

#define REM16_RplWkstaEnum_P            "WzWrLehb4g4"
#define REM16_RplWkstaGetInfo_P         "zWrLh"
#define REM16_RplWkstaSetInfo_P         "zWsTPW"
#define REM16_RplWkstaAdd_P             "WsTW"
#define REM16_RplWkstaDel_P             "zW"

#define REM16_RplProfile_info_0         "z"
#define REM16_RplProfile_info_1         "zz"
#define REM16_RplProfile_info_2         "b16b47"
#define REM16_RplProfile_info_3         "b16b47b16"

#define REM16_RplProfileEnum_P          "WzWrLehb4g4"
#define REM16_RplProfileGetInfo_P       "zWrLh"
#define REM16_RplProfileSetInfo_P       "zWsTP"
#define REM16_RplProfileAdd_P           "WzsTW"
#define REM16_RplProfileDel_P           "zW"
#define REM16_RplProfileClone_P         "WzsTW"
#define REM16_RplBaseProfileEnum_P      "WrLehb4g4"


// LAN Manager 3.0 API strings go here

#define REM16_I_GuidGetAgent_P          "g6i"
#define REM16_I_GuidSetAgent_P          "b6D"


// update support

#define REM16_NetAccountUpdate_P        "b12g12WWrLh"
#define REM16_NetAccountConfirmUpd_P    "b12g12D"
#define REM16_update_info_0             "K"

//
// SamrOemChangePasswordUser2 api support
//
#define REM32_SamOEMChgPasswordUser2_P  "zsT"        // Parameters to the call
#define REMSmb_SamOEMChgPasswordUser2   "B516B16"    // data that is passed

//====================================================================
//
// SMB XACT message descriptors. These are the only descriptors that
// can be passed over the network, and must not have any internal-
// use-only characters as defined in RemTypes.h
//
//====================================================================

#define REMSmb_share_info_0              "B13"
#define REMSmb_share_info_1              "B13BWz"
#define REMSmb_share_info_2              "B13BWzWWWzB9B"

#define REMSmb_share_info_90             "B13BWz"
#define REMSmb_share_info_92             "zzz"
#define REMSmb_share_info_93             "zzz"

#define REMSmb_share_info_0_setinfo      "B13"
#define REMSmb_share_info_1_setinfo      "B13BWz"
#define REMSmb_share_info_2_setinfo      "B13BWzWWOB9B"

#define REMSmb_share_info_90_setinfo     "B13BWz"
#define REMSmb_share_info_91_setinfo     "B13BWzWWWOB9BB9BWzWWzWW"

#define REMSmb_NetShareEnum_P            "WrLeh"
#define REMSmb_NetShareGetInfo_P         "zWrLh"
#define REMSmb_NetShareSetInfo_P         "zWsTP"
#define REMSmb_NetShareAdd_P             "WsT"
#define REMSmb_NetShareDel_P             "zW"
#define REMSmb_NetShareCheck_P           "zh"

#define REMSmb_session_info_0            "z"
#define REMSmb_session_info_1            "zzWWWDDD"
#define REMSmb_session_info_2            "zzWWWDDDz"
#define REMSmb_session_info_10           "zzDD"

#define REMSmb_NetSessionEnum_P          "WrLeh"
#define REMSmb_NetSessionGetInfo_P       "zWrLh"
#define REMSmb_NetSessionDel_P           "zW"

#define REMSmb_connection_info_0         "W"
#define REMSmb_connection_info_1         "WWWWDzz"

#define REMSmb_NetConnectionEnum_P       "zWrLeh"

#define REMSmb_file_info_0               "W"
#define REMSmb_file_info_1               "WWWzz"
#define REMSmb_file_info_2               "D"
#define REMSmb_file_info_3               "DWWzz"

#define REMSmb_NetFileEnum_P             "zWrLeh"
#define REMSmb_NetFileEnum2_P            "zzWrLehb8g8"
#define REMSmb_NetFileGetInfo_P          "WWrLh"
#define REMSmb_NetFileGetInfo2_P         "DWrLh"
#define REMSmb_NetFileClose_P            "W"
#define REMSmb_NetFileClose2_P           "D"

#define REMSmb_server_info_0             "B16"
#define REMSmb_server_info_1             "B16BBDz"
#define REMSmb_server_info_2             "B16BBDzDDDWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWz"
#define REMSmb_server_info_3             "B16BBDzDDDWWzWWWWWWWB21BzWWWWWWWWWWWWWWWWWWWWWWzDWz"

#define REMSmb_server_info_1_setinfo     "B16BBDz"
#define REMSmb_server_info_2_setinfo     "B16BBDzDDDWWzWWWWWWWB21BOWWWWWWWWWWWWWWWWWWWWWWz"

#define REMSmb_server_admin_command      "B"

#define REMSmb_server_diskenum_0         "B3"

#define REMSmb_authenticator_info_0      "B8D"

#define REMSmb_server_diskft_100         "B"
#define REMSmb_server_diskft_101         "BBWWWWDW"
#define REMSmb_server_diskft_102         "BBWWWWDN"
#define REMSmb_server_diskfterr_0        "DWWDDW"
#define REMSmb_ft_info_0                 "WWW"
#define REMSmb_ft_drivestats_0           "BBWDDDDDDD"
#define REMSmb_ft_error_info_1           "DWWDDWBBDD"

#define REMSmb_I_NetServerDiskEnum_P     "WrLeh"
#define REMSmb_I_NetServerDiskGetInfo_P  "WWrLh"
#define REMSmb_I_FTVerifyMirror_P        "Wz"
#define REMSmb_I_FTAbortVerify_P         "W"
#define REMSmb_I_FTGetInfo_P             "WrLh"
#define REMSmb_I_FTSetInfo_P             "WsTP"
#define REMSmb_I_FTLockDisk_P            "WWh"
#define REMSmb_I_FTFixError_P            "Dzhh2"
#define REMSmb_I_FTAbortFix_P            "D"
#define REMSmb_I_FTDiagnoseError_P       "Dhhhh"
#define REMSmb_I_FTGetDriveStats_P       "WWrLh"
#define REMSmb_I_FTErrorGetInfo_P        "DWrLh"

#define REMSmb_NetServerEnum_P           "WrLeh"
#define REMSmb_I_NetServerEnum_P         "WrLeh"
#define REMSmb_NetServerEnum2_P          "WrLehDz"
#define REMSmb_I_NetServerEnum2_P        "WrLehDz"
#define REMSmb_NetServerEnum3_P          "WrLehDzz"
#define REMSmb_NetServerGetInfo_P        "WrLh"
#define REMSmb_NetServerSetInfo_P        "WsTP"
#define REMSmb_NetServerDiskEnum_P       "WrLeh"
#define REMSmb_NetServerAdminCommand_P   "zhrLeh"
#define REMSmb_NetServerReqChalleng_P    "zb8g8"
#define REMSmb_NetServerAuthenticat_P    "zb8g8"
#define REMSmb_NetServerPasswordSet_P    "zb12g12b16"

#define REMSmb_NetAuditOpen_P            "h"
#define REMSmb_NetAuditClear_P           "zz"
#define REMSmb_NetAuditRead_P            "zb16g16DhDDrLeh"

#define REMSmb_AuditLogReturnBuf         "K"

#define REMSmb_NetErrorLogOpen_P         "h"
#define REMSmb_NetErrorLogClear_P        "zz"
#define REMSmb_NetErrorLogRead_P         "zb16g16DhDDrLeh"

#define REMSmb_ErrorLogReturnBuf         "K"

#define REMSmb_chardev_info_0            "B9"
#define REMSmb_chardev_info_1            "B10WB22D"
#define REMSmb_chardevQ_info_0           "B13"
#define REMSmb_chardevQ_info_1           "B14WzWW"

#define REMSmb_NetCharDevEnum_P          "WrLeh"
#define REMSmb_NetCharDevGetInfo_P       "zWrLh"
#define REMSmb_NetCharDevControl_P       "zW"
#define REMSmb_NetCharDevQEnum_P         "zWrLeh"
#define REMSmb_NetCharDevQGetInfo_P      "zzWrLh"
#define REMSmb_NetCharDevQSetInfo_P      "zWsTP"
#define REMSmb_NetCharDevQPurge_P        "z"
#define REMSmb_NetCharDevQPurgeSelf_P    "zz"

#define REMSmb_msg_info_0                "B16"
#define REMSmb_msg_info_1                "B16BBB16"
#define REMSmb_send_struct               "K"

#define REMSmb_NetMessageNameEnum_P      "WrLeh"
#define REMSmb_NetMessageNameGetInfo_P   "zWrLh"
#define REMSmb_NetMessageNameAdd_P       "zW"
#define REMSmb_NetMessageNameDel_P       "zW"
#define REMSmb_NetMessageNameFwd_P       "zzW"
#define REMSmb_NetMessageNameUnFwd_P     "z"
#define REMSmb_NetMessageBufferSend_P    "zsT"
#define REMSmb_NetMessageFileSend_P      "zz"
#define REMSmb_NetMessageLogFileSet_P    "zW"
#define REMSmb_NetMessageLogFileGet_P    "rLh"

#define REMSmb_service_info_0            "B16"
#define REMSmb_service_info_1            "B16WDW"
#define REMSmb_service_info_2            "B16WDWB64"
#define REMSmb_service_cmd_args          "K"

#define REMSmb_NetServiceEnum_P          "WrLeh"
#define REMSmb_NetServiceControl_P       "zWWrL"
#define REMSmb_NetServiceInstall_P       "zF88sg88T"     // See NOTE 2
#define REMSmb_NetServiceGetInfo_P       "zWrLh"

#define REMSmb_access_info_0             "z"
#define REMSmb_access_info_0_setinfo     "z"
#define REMSmb_access_info_1             "zWN"
#define REMSmb_access_info_1_setinfo     "OWN"
#define REMSmb_access_list               "B21BW"

#define REMSmb_NetAccessEnum_P           "zWWrLeh"
#define REMSmb_NetAccessGetInfo_P        "zWrLh"
#define REMSmb_NetAccessSetInfo_P        "zWsTP"
#define REMSmb_NetAccessAdd_P            "WsT"
#define REMSmb_NetAccessDel_P            "z"
#define REMSmb_NetAccessGetUserPerms_P   "zzh"

#define REMSmb_group_info_0              "B21"
#define REMSmb_group_info_1              "B21Bz"
#define REMSmb_group_users_info_0        "B21"
#define REMSmb_group_users_info_1        "B21BN"

#define REMSmb_NetGroupEnum_P            "WrLeh"
#define REMSmb_NetGroupAdd_P             "WsT"
#define REMSmb_NetGroupDel_P             "z"
#define REMSmb_NetGroupAddUser_P         "zz"
#define REMSmb_NetGroupDelUser_P         "zz"
#define REMSmb_NetGroupGetUsers_P        "zWrLeh"
#define REMSmb_NetGroupSetUsers_P        "zWsTW"
#define REMSmb_NetGroupGetInfo_P         "zWrLh"
#define REMSmb_NetGroupSetInfo_P         "zWsTP"

#define REMSmb_user_info_0               "B21"
#define REMSmb_user_info_1               "B21BB16DWzzWz"
#define REMSmb_user_info_2               "B21BB16DWzzWzDzzzzDDDDWb21WWzWW"
#define REMSmb_user_info_10              "B21Bzzz"
#define REMSmb_user_info_11              "B21BzzzWDDzzDDWWzWzDWb21W"

#define REMSmb_user_info_100             "DWW"
#define REMSmb_user_info_101             "B60"
#define REMSmb_user_modals_info_0        "WDDDWW"
#define REMSmb_user_modals_info_1        "Wz"
#define REMSmb_user_modals_info_100      "B50"
#define REMSmb_user_modals_info_101      "zDDzDD"
#define REMSmb_user_logon_info_0         "B21B"
#define REMSmb_user_logon_info_1         "WB21BWDWWDDDDDDDzzzD"
#define REMSmb_user_logon_info_2         "B21BzzzD"
#define REMSmb_user_logoff_info_1        "WDW"

#define REMSmb_NetUserEnum_P             "WrLeh"
#define REMSmb_NetUserAdd_P              "WsTW"
#define REMSmb_NetUserAdd2_P             "WsTWW"
#define REMSmb_NetUserDel_P              "z"
#define REMSmb_NetUserGetInfo_P          "zWrLh"
#define REMSmb_NetUserSetInfo_P          "zWsTPW"
#define REMSmb_NetUserSetInfo2_P         "zWsTPWW"
#define REMSmb_NetUserPasswordSet_P      "zb16b16W"
#define REMSmb_NetUserPasswordSet2_P     "zb16b16WW"
#define REMSmb_NetUserGetGroups_P        "zWrLeh"
#define REMSmb_NetUserSetGroups_P        "zWsTW"
#define REMSmb_NetUserModalsGet_P        "WrLh"
#define REMSmb_NetUserModalsSet_P        "WsTP"
#define REMSmb_NetUserEnum2_P            "WrLDieh"
#define REMSmb_NetUserValidate2_P        "Wb62WWrLhWW"

#define REMSmb_wksta_info_0              "WDzzzzBBDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REMSmb_wksta_info_0_setinfo      "WDOOOOBBDWDWWWWWWWWWWWWWWWWWWWzzW"
#define REMSmb_wksta_info_1              "WDzzzzBBDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REMSmb_wksta_info_1_setinfo      "WDOOOOBBDWDWWWWWWWWWWWWWWWWWWWzzWzzW"
#define REMSmb_wksta_info_10             "zzzBBzz"
#define REMSmb_wksta_annc_info           "K"

#define REMSmb_NetWkstaLogon_P           "zzirL"
#define REMSmb_NetWkstaLogoff_P          "zD"
#define REMSmb_NetWkstaSetUID_P          "zzzW"
#define REMSmb_NetWkstaGetInfo_P         "WrLh"
#define REMSmb_NetWkstaSetInfo_P         "WsTP"
#define REMSmb_NetWkstaUserLogon_P       "zzWb54WrLh"
#define REMSmb_NetWkstaUserLogoff_P      "zzWb38WrLh"

#define REMSmb_use_info_0                "B9Bz"
#define REMSmb_use_info_1                "B9BzzWWWW"

#define REMSmb_use_info_2                "B9BzzWWWWWWWzB16"

#define REMSmb_NetUseEnum_P              "WrLeh"
#define REMSmb_NetUseAdd_P               "WsT"
#define REMSmb_NetUseDel_P               "zW"
#define REMSmb_NetUseGetInfo_P           "zWrLh"

#define REMSmb_printQ_0                  "B13"
#define REMSmb_printQ_1                  "B13BWWWzzzzzWW"
#define REMSmb_printQ_2                  "B13BWWWzzzzzWN"
#define REMSmb_printQ_3                  "zWWWWzzzzWWzzl"
#define REMSmb_printQ_4                  "zWWWWzzzzWNzzl"
#define REMSmb_printQ_5                  "z"

#define REMSmb_DosPrintQEnum_P           "WrLeh"
#define REMSmb_DosPrintQGetInfo_P        "zWrLh"
#define REMSmb_DosPrintQSetInfo_P        "zWsTP"
#define REMSmb_DosPrintQAdd_P            "WsT"
#define REMSmb_DosPrintQDel_P            "z"
#define REMSmb_DosPrintQPause_P          "z"
#define REMSmb_DosPrintQPurge_P          "z"
#define REMSmb_DosPrintQContinue_P       "z"

#define REMSmb_print_job_0               "W"
#define REMSmb_print_job_1               "WB21BB16B10zWWzDDz"
#define REMSmb_print_job_2               "WWzWWDDzz"
#define REMSmb_print_job_3               "WWzWWDDzzzzzzzzzzlz"

#define REMSmb_print_job_info_1_setinfo  "WB21BB16B10zWWODDz"
#define REMSmb_print_job_info_3_setinfo  "WWzWWDDzzzzzOzzzzlO"

#define REMSmb_DosPrintJobEnum_P         "zWrLeh"
#define REMSmb_DosPrintJobGetInfo_P      "WWrLh"
#define REMSmb_DosPrintJobSetInfo_P      "WWsTP"
#define REMSmb_DosPrintJobAdd_P          "zsTF129g129h"  // See note 2
#define REMSmb_DosPrintJobSchedule_P     "W"
#define REMSmb_DosPrintJobDel_P          "W"
#define REMSmb_DosPrintJobPause_P        "W"
#define REMSmb_DosPrintJobContinue_P     "W"

#define REMSmb_print_dest_0              "B9"
#define REMSmb_print_dest_1              "B9B21WWzW"
#define REMSmb_print_dest_2              "z"
#define REMSmb_print_dest_3              "zzzWWzzzWW"
#define REMSmb_print_dest_info_3_setinfo "zOzWWOzzWW"

#define REMSmb_DosPrintDestEnum_P        "WrLeh"
#define REMSmb_DosPrintDestGetInfo_P     "zWrLh"
#define REMSmb_DosPrintDestControl_P     "zW"
#define REMSmb_DosPrintDestAdd_P         "WsT"
#define REMSmb_DosPrintDestSetInfo_P     "zWsTP"
#define REMSmb_DosPrintDestDel_P         "z"

#define REMSmb_NetProfileSave_P          "zDW"
#define REMSmb_NetProfileLoad_P          "zDrLD"

#define REMSmb_profile_load_info         "WDzD"

#define REMSmb_statistics_info           "B"

#define REMSmb_statistics2_info_W        "B120"
#define REMSmb_stat_workstation_0        "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
#define REMSmb_statistics2_info_S        "B68"
#define REMSmb_stat_server_0             "DDDDDDDDDDDDDDDDD"

#define REMSmb_NetStatisticsGet_P        "rLeh"
#define REMSmb_NetStatisticsClear_P      ""

#define REMSmb_NetStatisticsGet2_P       "zDWDrLh"

#define REMSmb_NetRemoteTOD_P            "rL"

#define REMSmb_time_of_day_info          "DDBBBBWWBBWB"

#define REMSmb_netbios_info_0            "B17"
#define REMSmb_netbios_info_1            "B17B9BBWWDWWW"

#define REMSmb_NetBiosEnum_P             "WrLeh"
#define REMSmb_NetBiosGetInfo_P          "zWrLh"

#define REMSmb_Spl_open_data             "zzlzzzzzz"
#define REMSmb_plain_data                "K"

#define REMSmb_NetSplQmAbort_P           "Di"
#define REMSmb_NetSplQmClose_P           "Di"
#define REMSmb_NetSplQmEndDoc_P          "Dhi"
#define REMSmb_NetSplQmOpen_P            "zTsWii"
#define REMSmb_NetSplQmStartDoc_P        "Dzi"
#define REMSmb_NetSplQmWrite_P           "DTsi"

#define REMSmb_configgetall_info         "B"
#define REMSmb_configget_info            "B"
#define REMSmb_configset_info_0          "zz"

#define REMSmb_NetConfigGetAll_P         "zzrLeh"
#define REMSmb_NetConfigGet_P            "zzzrLe"
#define REMSmb_NetConfigSet_P            "zzWWsTD"

#define REMSmb_NetBuildGetInfo_P         "DWrLh"
#define REMSmb_build_info_0              "WD"

#define REMSmb_NetGetDCName_P            "zrL"
#define REMSmb_dc_name                   "B18"

#define REMSmb_challenge_info_0          "B8"
#define REMSmb_account_delta_info_0      "K"
#define REMSmb_account_sync_info_0       "K"

#define REMSmb_NetAccountDeltas_P        "zb12g12b24WWrLehg24"
#define REMSmb_NetAccountSync_P          "zb12g12DWrLehig24"

#define REMSmb_NetLogonEnum_P            "WrLeh"

#define REMSmb_I_NetPathType_P           "ziD"
#define REMSmb_I_NetPathCanonicalize_P   "zrLziDD"
#define REMSmb_I_NetPathCompare_P        "zzDD"
#define REMSmb_I_NetNameValidate_P       "zWD"
#define REMSmb_I_NetNameCanonicalize_P   "zrLWD"
#define REMSmb_I_NetNameCompare_P        "zzWD"

#define REMSmb_LocalOnlyCall             ""

//
// The following definitions exist for DOS LANMAN--Windows 3.0
// Normally, there is a const char far * servername
// as the first parameter, but this will be ignored (sort of)
//

#define REMSmb_DosPrintJobGetId_P        "WrL"
#define REMSmb_GetPrintId                "WB16B13B"
#define REMSmb_NetRemoteCopy_P           "zzzzWWrL"
#define REMSmb_copy_info                 "WB1"
#define REMSmb_NetRemoteMove_P           "zzzzWWrL"
#define REMSmb_move_info                 "WB1"
#define REMSmb_NetHandleGetInfo_P        "WWrLh"
#define REMSmb_NetHandleSetInfo_P        "WWsTP"
#define REMSmb_handle_info_1             "DW"
#define REMSmb_handle_info_2             "z"
#define REMSmb_WWkstaGetInfo_P           "WrLhOW"

// The following strings are defined for RIPL APIs

#define REMSmb_RplWksta_info_0           "z"
#define REMSmb_RplWksta_info_1           "zz"
#define REMSmb_RplWksta_info_2           "b13b16b15b15zN"
#define REMSmb_RplWksta_info_3           "b16b49"

#define REMSmb_RplWkstaEnum_P            "WzWrLehb4g4"
#define REMSmb_RplWkstaGetInfo_P         "zWrLh"
#define REMSmb_RplWkstaSetInfo_P         "zWsTPW"
#define REMSmb_RplWkstaAdd_P             "WsTW"
#define REMSmb_RplWkstaDel_P             "zW"

#define REMSmb_RplProfile_info_0         "z"
#define REMSmb_RplProfile_info_1         "zz"
#define REMSmb_RplProfile_info_2         "b16b47"
#define REMSmb_RplProfile_info_3         "b16b47b16"

#define REMSmb_RplProfileEnum_P          "WzWrLehb4g4"
#define REMSmb_RplProfileGetInfo_P       "zWrLh"
#define REMSmb_RplProfileSetInfo_P       "zWsTP"
#define REMSmb_RplProfileAdd_P           "WzsTW"
#define REMSmb_RplProfileDel_P           "zW"
#define REMSmb_RplProfileClone_P         "WzsTW"
#define REMSmb_RplBaseProfileEnum_P      "WrLehb4g4"


// LAN Manager 3.0 API strings go here

#define REMSmb_I_GuidGetAgent_P          "g6i"
#define REMSmb_I_GuidSetAgent_P          "b6D"


// update support

#define REMSmb_NetAccountUpdate_P        "b12g12WWrLh"
#define REMSmb_NetAccountConfirmUpd_P    "b12g12D"
#define REMSmb_update_info_0             "K"

#endif // ndef _REMDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\polstructs.h ===
// Group policy refresh named event signaled by our GPE when gp refreshes
// without GP changes or without a forced refresh.

#define IPSEC_GP_REFRESH_EVENT L"IPSEC_GP_REFRESH_EVENT"

#define REG_IPSEC_DRIVER_STATEFULMODE 3

#define IPSEC_REGISTRY_PROVIDER     0
#define IPSEC_DIRECTORY_PROVIDER    1
#define IPSEC_FILE_PROVIDER         2
#define IPSEC_WMI_PROVIDER          3
#define IPSEC_PERSISTENT_PROVIDER   4

#define POLSTORE_READWRITE 0x00000000 
#define POLSTORE_READONLY  0x00000001
#define POLSTORE_NEW_VER   0x00000002
#define POLSTORE_PARTIAL   0x00000004

#define POL_ACTION_ASSIGN 1
#define POL_ACTION_UNASSIGN 2

//
// Structure for data interchange between Winlogon/Group Policy
// and polstore (see RSOP_PolicySetting in MSDN)
//

typedef struct _GPO_INFO {
  BSTR     bsCreationtime;
  UINT32   uiPrecedence;
  BSTR     bsGPOID; 
  BSTR     bsSOMID;
  UINT32   uiTotalGPOs;
}  GPO_INFO, *PGPO_INFO;


//
//  Extra RSOP information for objects stored in WMI store.
//

typedef struct _RSOP_INFO {
  LPWSTR   pszCreationtime;
  LPWSTR   pszID;
  LPWSTR   pszName;
  UINT32   uiPrecedence;
  LPWSTR   pszGPOID; 
  LPWSTR   pszSOMID;
} RSOP_INFO, * PRSOP_INFO;

typedef struct _IPSEC_AUTH_METHOD {
    DWORD dwAuthType;
    DWORD dwAuthLen;
    LPWSTR pszAuthMethod;
    DWORD dwAltAuthLen;
    PBYTE pAltAuthMethod;
    DWORD dwAuthFlags;
} IPSEC_AUTH_METHOD, *PIPSEC_AUTH_METHOD;

typedef struct _IPSEC_FILTER_SPEC {
    LPWSTR pszSrcDNSName;
    LPWSTR pszDestDNSName;
    LPWSTR pszDescription;
    GUID FilterSpecGUID;
    DWORD dwMirrorFlag;
    IPSEC_FILTER Filter;
} IPSEC_FILTER_SPEC, *PIPSEC_FILTER_SPEC;

typedef struct _IPSEC_FILTER_DATA {
    GUID  FilterIdentifier;
    DWORD dwNumFilterSpecs;
    PIPSEC_FILTER_SPEC * ppFilterSpecs;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
    DWORD dwFlags;    
} IPSEC_FILTER_DATA, *PIPSEC_FILTER_DATA;

typedef IPSEC_ALG_TYPE IPSEC_SECURITY_METHOD, *PIPSEC_SECURITY_METHOD;

// Flags specific to security method

#define FALLBACK_NON_IPSEC_AWARE 0x1
#define FALLBACK_IKE_FAILURE 0x2

typedef struct _IPSEC_NEGPOL_DATA {
    GUID  NegPolIdentifier;
    GUID  NegPolAction;
    GUID  NegPolType;
    DWORD dwSecurityMethodCount;
    IPSEC_SECURITY_METHOD * pIpsecSecurityMethods;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
    DWORD dwFlags;    
} IPSEC_NEGPOL_DATA, *PIPSEC_NEGPOL_DATA;

typedef struct _IPSEC_ISAKMP_DATA {
    GUID  ISAKMPIdentifier;
    ISAKMP_POLICY ISAKMPPolicy;
    DWORD dwNumISAKMPSecurityMethods;
    PCRYPTO_BUNDLE pSecurityMethods;
    DWORD dwWhenChanged;
    DWORD dwFlags;    
} IPSEC_ISAKMP_DATA, *PIPSEC_ISAKMP_DATA;

typedef struct _IPSEC_NFA_DATA {
    LPWSTR pszIpsecName;
    GUID  NFAIdentifier;
    DWORD dwAuthMethodCount;
    PIPSEC_AUTH_METHOD * ppAuthMethods;
    DWORD dwInterfaceType;
    LPWSTR pszInterfaceName;
    DWORD dwTunnelIpAddr;
    DWORD dwTunnelFlags;
    DWORD dwActiveFlag;
    LPWSTR pszEndPointName;
    PIPSEC_FILTER_DATA pIpsecFilterData;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData;
    DWORD dwWhenChanged;
    GUID NegPolIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszDescription;
    DWORD dwFlags;    
} IPSEC_NFA_DATA, *PIPSEC_NFA_DATA;

typedef struct _IPSEC_POLICY_DATA{
    GUID  PolicyIdentifier;
    DWORD dwPollingInterval;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData;
    PIPSEC_NFA_DATA * ppIpsecNFAData;
    DWORD dwNumNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
    GUID ISAKMPIdentifier;
    PRSOP_INFO pRsopInfo;
    DWORD dwFlags;    
} IPSEC_POLICY_DATA, *PIPSEC_POLICY_DATA;


LPVOID
AllocPolMem(
    DWORD cb
    );

BOOL
FreePolMem(
    LPVOID pMem
    );

LPWSTR
AllocPolStr(
    LPCWSTR pStr
    );

BOOL
FreePolStr(
    LPWSTR pStr
    );

DWORD
ReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    );

BOOL
ReallocPolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    );

void
FreeIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

void
FreeIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

void
FreeIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

void
FreeIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

void
FreeIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
CopyIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
CopyIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
CopyIpsecAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    );

DWORD
CopyIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
CopyIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
CopyIpsecFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    );

DWORD
CopyIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );


void
FreeMulIpsecFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    );

void
FreeMulIpsecNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    );

void
FreeMulIpsecPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

void
FreeMulIpsecNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    );

void
FreeIpsecFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    );

void
FreeIpsecFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    );

void
FreeMulIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rmcommon.h ===
/*	
**	RmCommon.h - Driver/Winsock common for PGM Reliable Transport
**
**	This file contains PGM specific information for use by WinSock2 compatible
**  applications that need Reliable Multicast Transport.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**	Created: Mar 12, 2000
**
*/

#ifndef _RMCOMMON_H_
#define _RMCOMMON_H_

#include "wsrm.h"

#define SOCK_PGM    SOCK_RDM

typedef ULONG   tIPADDRESS;

#define PGM_COMMON_SERVICE_FLAGS    XP1_GUARANTEED_ORDER           \
                                  | XP1_GUARANTEED_DELIVERY        \
                                  | XP1_SUPPORT_MULTIPOINT         \
                                  | XP1_GRACEFUL_CLOSE              \
                                  | XP1_IFS_HANDLES


#define PGM_RDM_SERVICE_FLAGS       PGM_COMMON_SERVICE_FLAGS | XP1_MESSAGE_ORIENTED
#define PGM_STREAM_SERVICE_FLAGS    PGM_COMMON_SERVICE_FLAGS | XP1_PSEUDO_STREAM


//
// Argument structure for passing requests from WHSPgm.dll to Pgm.dll
//
//
// Ioctl Definitions:
//

//
// Structure for passing MCast info to Ip
//
typedef struct {
    tIPADDRESS  MCastIpAddr;    // struct in_addr imr_multiaddr -- IP multicast address of group
    tIPADDRESS  MCastInIf;     // struct in_addr imr_interface -- local IP address of incoming interface
} tMCAST_INFO;

//
// Structure to be used for passing down Ioctl info:
//
typedef struct {
    union
    {
        struct
        {
            tMCAST_INFO     MCastInfo;
            USHORT          MCastPort;
        };
        RM_SENDER_STATS     SenderStats;
        RM_RECEIVER_STATS   ReceiverStats;
        ULONG               RcvBufferLength;            // To set the RcvBufferLength in Pgm
        tIPADDRESS          MCastOutIf;                 // local IP address of outgoing interface
        RM_SEND_WINDOW      TransmitWindowInfo;
        ULONG               WindowAdvancePercentage;    // Sender's transmit window advance rate
        ULONG               LateJoinerPercentage;       // Sender's transmit window advance rate
        ULONG               NextMessageBoundary;
        ULONG               MCastTtl;
        ULONG               WindowAdvanceMethod;
        ULONG               HighSpeedIntranetOptimization;
        RM_FEC_INFO         FECInfo;
    };
} tPGM_MCAST_REQUEST;

#define FSCTL_PGM_BASE     FILE_DEVICE_NETWORK

#define _PGM_CTRL_CODE(function, method, access) \
            CTL_CODE(FSCTL_PGM_BASE, function, method, access)

// Ioctls:
#define IOCTL_PGM_WSH_SET_SEND_IF           \
            _PGM_CTRL_CODE( 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_ADD_RECEIVE_IF        \
            _PGM_CTRL_CODE( 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_DEL_RECEIVE_IF        \
            _PGM_CTRL_CODE( 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_JOIN_MCAST_LEAF       \
            _PGM_CTRL_CODE( 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_RCV_BUFF_LEN      \
            _PGM_CTRL_CODE( 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_WINDOW_SIZE_RATE      \
            _PGM_CTRL_CODE( 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_WINDOW_SIZE_RATE      \
            _PGM_CTRL_CODE( 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_ADVANCE_WINDOW_RATE      \
            _PGM_CTRL_CODE( 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_ADVANCE_WINDOW_RATE      \
            _PGM_CTRL_CODE( 8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_LATE_JOINER_PERCENTAGE      \
            _PGM_CTRL_CODE( 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_LATE_JOINER_PERCENTAGE      \
            _PGM_CTRL_CODE( 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_NEXT_MESSAGE_BOUNDARY      \
            _PGM_CTRL_CODE( 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_SENDER_STATS    \
            _PGM_CTRL_CODE( 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_USE_FEC               \
            _PGM_CTRL_CODE( 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_MCAST_TTL      \
            _PGM_CTRL_CODE( 14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_FEC_INFO      \
            _PGM_CTRL_CODE( 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_RECEIVER_STATS      \
            _PGM_CTRL_CODE( 16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_WINDOW_ADVANCE_METHOD      \
            _PGM_CTRL_CODE( 17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_WINDOW_ADVANCE_METHOD      \
            _PGM_CTRL_CODE( 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_SET_HIGH_SPEED_INTRANET_OPT      \
            _PGM_CTRL_CODE( 19, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PGM_WSH_QUERY_HIGH_SPEED_INTRANET_OPT      \
            _PGM_CTRL_CODE( 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif  /* _RMCOMMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\sockreg.h ===
FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    );


NTSTATUS
SockOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    );

NTSTATUS
SockOpenKeyEx(
    PHANDLE HandlePtr,
    PUCHAR  KeyName1,
    PUCHAR  KeyName2,
    PUCHAR  KeyName3
    );

NTSTATUS
SockGetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    PULONG ValueType,
    ULONG  ValueLength
    );

NTSTATUS
SockSetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    ULONG ValueType,
    ULONG  ValueLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\remtypes.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    RemTypes.h

Abstract:

    This header file defines character values used in descriptor strings in
    Remote Admin Protocol.

    NOTES   - All pointer types are lower case, except for buffer pointers,
              and the null pointer.

            - REM_BYTE should not be used for parameters, since data is
              never placed on the stack as individual bytes.

            - REM_NULL_PTR is never specified in the call, but may be
              used to replace a pointer type if the pointer itself is NULL.

            - In some cases as indicated below, a descriptor character
              can indicate an array of data items, if followed by an
              ASCII representation of the number of items. For pointer
              types, this is a count of the data items themselves, not
              the pointers. For example, 'b12' describes a pointer
              to 12 bytes of data, not 12 pointers to byte values.

Author:

    LanMan 2.x people.

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Mar-1991 Shanku Niyogi (w-shanku)
        Ported to NT format, and added special 32-bit descriptor characters.

    21-Aug-1991 Jim Waters (t-jamesw)
        Added REM_ASCIZ_COMMENT.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
--*/

#ifndef _REMTYPES_
#define _REMTYPES_

//
// Data types.
//

#define REM_BYTE                'B'     // Byte (s)
#define REM_WORD                'W'     // Word (s)
#define REM_DWORD               'D'     // DWord (s)
#define REM_DATE_TIME           'C'     // Date time field
#define REM_FILL_BYTES          'F'     // Pad field

//
// Pointer types.
//

//
// For internal use, the count following a REM_ASCIZ may specify the maximum
// string length.  On the network no count may be present.
//
// In RapConvertSingleEntry, attempting to copy a REM_ASCIZ into a buffer too
// small to hold it will result in an error.  Use REM_ASCIZ_TRUNCATABLE
// for strings which can be truncated.
//
#define REM_ASCIZ               'z'     // Far pointer to asciz string

#define REM_BYTE_PTR            'b'     // Far pointer to byte(s)
#define REM_WORD_PTR            'w'     // Far pointer to word(s)
#define REM_DWORD_PTR           'd'     // Far pointer to dword(s)

#define REM_RCV_BYTE_PTR        'g'     // Far pointer to rcv byte(s)
#define REM_RCV_WORD_PTR        'h'     // Far pointer to rcv word(s)
#define REM_RCV_DWORD_PTR       'i'     // Far pointer to rcv dword(s)

#define REM_NULL_PTR            'O'     // NULL pointer

//
// Buffer pointer and length types.
//

#define REM_RCV_BUF_PTR         'r'     // Far pointer to receive data buffer
#define REM_RCV_BUF_LEN         'L'     // Word length of receive buffer

#define REM_SEND_BUF_PTR        's'     // Far pointer to send data buffer
#define REM_SEND_BUF_LEN        'T'     // Word length of send buffer

//
// Other special types.
//

#define REM_AUX_NUM             'N'     // !!! Temporary - for compatibility

#define REM_PARMNUM             'P'     // parameter number word

#define REM_ENTRIES_READ        'e'     // Far pointer to entries read word

#define REM_DATA_BLOCK          'K'     // Unstructured data block

#define REM_SEND_LENBUF         'l'     // Far pointer to send data buffer,
                                        // where first word in buffer is the
                                        // length of the buffer.


//
// Items from here on are "internal use only", and should never actually
// appear on the network.
//

//
// The following is used in the MVDM driver to get various API support
//

#define REM_WORD_LINEAR         'a'     // Far linear pointer to word(s)

//
// The following is used while processing 32-bit APIs and 16-bit APIs with
// different padding requirements or info levels with ignored fields.
//

#define REM_IGNORE              'Q'     // Ignore this field (16->32 or
                                        // 32->16 conversions).

//
// A dword version of the auxiliary structure count (for 32-bit data).
//

#define REM_AUX_NUM_DWORD       'A'     // 32-bit dword count of aux structures

//
// Sign extended dword - for 16->32 bit conversion where the 16-bit
//      quantity may represent signed negative quantities which need
//      to be extended over 32 bits.
//

#define REM_SIGNED_DWORD        'X'     // 32-bit signed dword(s)

#define REM_SIGNED_DWORD_PTR    'x'     // Far pointer to signed dword(s)

//
// Truncatable asciz string - If a count is specified, the field only
//     accepts strings up to the specified length.  In
//     RapConvertSingleEntry, if a REM_ASCIZ_TRUNCATABLE is too long to
//     fit in the destination field, the string will be truncated to fit.
//     Use REM_ASCIZ for fields which cannot accept truncated strings.
//

#define REM_ASCIZ_TRUNCATABLE   'c'     // Far pointer to asciz comment
                                        // Count signifies maximum length.

// Time and date in seconds since 1970 (GMT).  In POSIX, this is usually
// called "seconds since the epoch".

#define REM_EPOCH_TIME_GMT      'G'     // 32-bit unsigned num of seconds.

// Time and date in seconds since 1970 (local time zone).

#define REM_EPOCH_TIME_LOCAL    'J'     // 32-bit unsigned num of seconds.

//
// Unsupported fields - for set info calls. A 'U' indicates that a parameter
//     cannot be changed.
//

#define REM_UNSUPPORTED_FIELD   'U'     // Unsupported field

#endif // ndef _REMTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rpcutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcutil.h

Abstract:

    This file contains prototypes for the bind and unbind functions that
    all net api stub functions will call.  It also includes the allocate
    and free routines used by the MIDL generated RPC stubs.

    Other function prototypes defined here are RPC helper routines to
    start and stop the RPC server, and the RPC status to Net API status
    mapping function.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    23-Oct-1991 Danl
        Added NetpInitRpcServer().

    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)

    20-Jul-1992 JohnRo
        RAID 2252: repl should prevent export on Windows/NT.
        Reordered this change history.
    01-Dec-1992 JohnRo
        Fix MIDL_user_ func signatures.

--*/
#ifndef _RPCUTIL_
#define _RPCUTIL_

#include <lmcons.h>

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>        // __RPC_FAR, etc.

//
// DEFINES
//

//
// The following typedefs are created for use in the net api Enum entry point
// routines.  These structures are meant to mirror the level specific
// info containers that are specified in the .idl file for the Enum API
// function.  Using these structures to set up for the API call allows
// the entry point routine to avoid using any bulky level-specific logic
// to set-up or return from the RPC stub call.
//

typedef struct _GENERIC_INFO_CONTAINER {
    DWORD       EntriesRead;
    LPBYTE      Buffer;
} GENERIC_INFO_CONTAINER, *PGENERIC_INFO_CONTAINER, *LPGENERIC_INFO_CONTAINER ;

typedef struct _GENERIC_ENUM_STRUCT {
    DWORD                   Level;
    PGENERIC_INFO_CONTAINER Container;
} GENERIC_ENUM_STRUCT, *PGENERIC_ENUM_STRUCT, *LPGENERIC_ENUM_STRUCT ;


#define     NT_PIPE_PREFIX      TEXT("\\PIPE\\")

//
// Function Prototypes - routines called by MIDL-generated code:
//

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t NumBytes
    );

void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

//
// Function Prototypes - private network routines.
//

RPC_STATUS
NetpBindRpc(
    IN  LPTSTR              servername,
    IN  LPTSTR              servicename,
    IN  LPTSTR              networkoptions,
    OUT RPC_BINDING_HANDLE  * pBindingHandle
    );

//  We do not need any longer NetpRpcStatusToApiStatus() mapping
//  But for now, rather than eliminating a few references to it in
//  the net tree, we just stub it out.

//  NET_API_STATUS
//  NetpRpcStatusToApiStatus(
//      IN  RPC_STATUS RpcStatus
//      );

#define NetpRpcStatusToApiStatus(RpcStatus)  ((NET_API_STATUS)(RpcStatus))

RPC_STATUS
NetpUnbindRpc(
    IN  RPC_BINDING_HANDLE BindingHandle
    );



#endif // _RPCUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\sock_err.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

  sock_err.h

Abstract:

   This module contains error codes for sockets and STREAMS sources.

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version  (in posix\sys\errno.h)
  9-19-91    mikemas  extracted these codes from posix\sys\errno.h

Notes:

--*/
/*
 *      Copyright (c) 1984 AT&T
 *      Copyright (c) 1987 Fairchild Semiconductor Corporation
 *      Copyright 1987 Lachman Associates, Incorporated (LAI)
 *        All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T,
 *      FAIRCHILD SEMICONDUCTOR CORPORATION,
 *      (AND LACHMAN ASSOCIATES)
 *      AND SPIDER SYSTEMS.
 *
 *      stcp copyright above and this notice must be preserved in all
 *      copies of this source code.  The copyright above does not
 *      evidence any actual or intended publication of this source
 *      code
 */

#ifndef SOCK_ERR_INCLUDED
#define SOCK_ERR_INCLUDED


// in CRT #define ENOTBLK 54      /* Block device required                */
// in CRT #define ETXTBSY 55      /* Text file busy                       */
#define ENOMSG  56      /* No message of desired type           */
#define EIDRM   57      /* Identifier removed                   */
#define ECHRNG  58      /* Channel number out of range          */
#define EL2NSYNC 59     /* Level 2 not synchronized             */
#define EL3HLT  60      /* Level 3 halted                       */
#define EL3RST  61      /* Level 3 reset                        */
#define ELNRNG  62      /* Link number out of range             */
#define EUNATCH 63      /* Protocol driver not attached         */
#define ENOCSI  64      /* No CSI structure available           */
#define EL2HLT  65      /* Level 2 halted                       */

/* Convergent Error Returns */
#define EBADE   66      /* invalid exchange                     */
#define EBADR   67      /* invalid request descriptor           */
#define EXFULL  68      /* exchange full                        */
#define ENOANO  69      /* no anode                             */
#define EBADRQC 70      /* invalid request code                 */
#define EBADSLT 71      /* invalid slot                         */
// in CRT #define EDEADLOCK 72    /* file locking deadlock error          */

#define EBFONT  73      /* bad font file fmt                    */

/* stream problems */
#define ENOSTR  74      /* Device not a stream                  */
#define ENODATA 75      /* no data (for no delay io)            */
#define ETIME   76      /* timer expired                        */
#define ENOSR   77      /* out of streams resources             */

#define ENONET  78      /* Machine is not on the network        */
#define ENOPKG  79      /* Package not installed                */
#define EREMOTE 80      /* The object is remote                 */
#define ENOLINK 81      /* the link has been severed */
#define EADV    82      /* advertise error */
#define ESRMNT  83      /* srmount error */

#define ECOMM   84      /* Communication error on send          */
#define EPROTO  85      /* Protocol error                       */
#define EMULTIHOP 86    /* multihop attempted */
#define ELBIN   87      /* Inode is remote (not really error)*/
#define EDOTDOT 88      /* Cross mount point (not really error)*/
#define EBADMSG 89      /* trying to read unreadable message    */

#define ENOTUNIQ 90     /* given log. name not unique */
#define EREMCHG  91     /* Remote address changed */

/* shared library problems */
#define ELIBACC 92      /* Can't access a needed shared lib.    */
#define ELIBBAD 93      /* Accessing a corrupted shared lib.    */
#define ELIBSCN 94      /* .lib section in a.out corrupted.     */
#define ELIBMAX 95      /* Attempting to link in too many libs. */
#define ELIBEXEC        96      /* Attempting to exec a shared library. */


/*
 * Additional error codes for the socket library
 */

#define EWOULDBLOCK     EAGAIN          /* Operation would block */

#define ENOTSOCK        100             /* Socket operation on non-socket */
#define EADDRNOTAVAIL   101             /* Can't assign requested address */
#define EADDRINUSE      102             /* Address already in use */
#define EAFNOSUPPORT    103
                        /* Address family not supported by protocol family */
#define ESOCKTNOSUPPORT 104             /* Socket type not supported */
#define EPROTONOSUPPORT 105             /* Protocol not supported */
#define ENOBUFS         106             /* No buffer space available */
#define ETIMEDOUT       107             /* Connection timed out */
#define EISCONN         108             /* Socket is already connected */
#define ENOTCONN        109             /* Socket is not connected */
#define ENOPROTOOPT     110             /* Bad protocol option */
#define ECONNRESET      111             /* Connection reset by peer */
#define ECONNABORT      112             /* Software caused connection abort */
#define ENETDOWN        113             /* Network is down */
#define ECONNREFUSED    114             /* Connection refused */
#define EHOSTUNREACH    115             /* Host is unreachable */
#define EPROTOTYPE      116             /* Protocol wrong type for socket */
#define EOPNOTSUPP      117             /* Operation not supported on socket */

#define ETIMEOUT        ETIMEDOUT

/*
 * these originate from the Internet Module
 */
#define ESUBNET         118             /* IP subnet table full */
#define ENETNOLNK       119             /* Subnet module not linked */
#define EBADIOCTL       120             /* Unknown ioctl call */
#define ERESOURCE       121             /* Failure in Streams buffer allocn */

#define EPROTUNR        122             /* ICMP Protocol unreachable    */
#define EPORTUNR        123             /* ICMP Port unreachable        */
#define ENETUNR         124             /* ICMP Network unreachable     */

#define ENETUNREACH     ENETUNR         /* ICMP Network unreachable     */

/*
 * Ethernet Driver Errors
 */

#define EPACKET         150             /* Invalid Ethernet Packet */
#define ETYPEREG        151             /* Type registration error */

/*
 * Socket library call
 */

#define ENOTINIT        152             /* Sockets library not initialized */


#endif  //SOCK_ERR_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\tcpinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** TCPINFO.H - TDI Query/SetInfo and Action definitons.
//
//  This file contains definitions for information returned from TCP/UDP.
//

#pragma once
#ifndef TCP_INFO_INCLUDED
#define TCP_INFO_INCLUDED

#include "ipinfo.h"

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;
#endif // CTE_TYPEDEFS_DEFINED

typedef struct TCPStats {
    ulong       ts_rtoalgorithm;
    ulong       ts_rtomin;
    ulong       ts_rtomax;
    ulong       ts_maxconn;
    ulong       ts_activeopens;
    ulong       ts_passiveopens;
    ulong       ts_attemptfails;
    ulong       ts_estabresets;
    ulong       ts_currestab;
    ulong       ts_insegs;
    ulong       ts_outsegs;
    ulong       ts_retranssegs;
    ulong       ts_inerrs;
    ulong       ts_outrsts;
    ulong       ts_numconns;
} TCPStats;

#define TCP_RTO_OTHER       1
#define TCP_RTO_CONSTANT    2
#define TCP_RTO_RSRE        3
#define TCP_RTO_VANJ        4

#define TCP_MAXCONN_DYNAMIC -1

typedef struct UDPStats {
    ulong       us_indatagrams;
    ulong       us_noports;
    ulong       us_inerrors;
    ulong       us_outdatagrams;
    ulong       us_numaddrs;
} UDPStats;

typedef struct TCPConnTableEntry {
    ulong       tct_state;
    ulong       tct_localaddr;
    ulong       tct_localport;
    ulong       tct_remoteaddr;
    ulong       tct_remoteport;
} TCPConnTableEntry;

typedef struct TCP6ConnTableEntry {
    struct in6_addr tct_localaddr;
    ulong           tct_localscopeid;
    ulong           tct_localport;
    struct in6_addr tct_remoteaddr;
    ulong           tct_remotescopeid;
    ulong           tct_remoteport;
    ulong           tct_state;
    ulong           tct_owningpid;
} TCP6ConnTableEntry, *PTCP6ConnTableEntry;

//* Definitions for the tct_state variable.
#define TCP_CONN_CLOSED     1                   // Closed.
#define TCP_CONN_LISTEN     2                   // Listening.
#define TCP_CONN_SYN_SENT   3                   // SYN Sent.
#define TCP_CONN_SYN_RCVD   4                   // SYN received.
#define TCP_CONN_ESTAB      5                   // Established.
#define TCP_CONN_FIN_WAIT1  6                   // FIN-WAIT-1
#define TCP_CONN_FIN_WAIT2  7                   // FIN-WAIT-2
#define TCP_CONN_CLOSE_WAIT 8                   // Close waiting.
#define TCP_CONN_CLOSING    9                   // Closing state.
#define TCP_CONN_LAST_ACK   10                  // Last ack state.
#define TCP_CONN_TIME_WAIT  11                  // Time wait state.
#define TCP_DELETE_TCB      12                  // Set to delete this TCB.


typedef struct TCPConnTableEntryEx {
    TCPConnTableEntry   tcte_basic;
    ulong               tcte_owningpid;
} TCPConnTableEntryEx;

typedef struct _TCP_EX_TABLE
{
    ulong               dwNumEntries;
    TCPConnTableEntryEx table[1];
} TCP_EX_TABLE;

typedef struct _TCP6_EX_TABLE
{
    ulong              dwNumEntries;
    TCP6ConnTableEntry table[1];
} TCP6_EX_TABLE, *PTCP6_EX_TABLE;


typedef struct UDPEntry {
    ulong       ue_localaddr;
    ulong       ue_localport;
} UDPEntry;

typedef struct UDPEntryEx {
    UDPEntry    uee_basic;
    ulong       uee_owningpid;
} UDPEntryEx;

typedef struct _UDP_EX_TABLE
{
    ulong               dwNumEntries;
    UDPEntryEx          table[1];
} UDP_EX_TABLE;

typedef struct UDP6ListenerEntry {
    struct in6_addr ule_localaddr;
    ulong           ule_localscopeid;
    ulong           ule_localport;
    ulong           ule_owningpid;
} UDP6ListenerEntry, *PUDP6ListenerEntry;

typedef struct _UDP6_LISTENER_TABLE
{
    ulong               dwNumEntries;
    UDP6ListenerEntry   table[1];
} UDP6_LISTENER_TABLE, *PUDP6_LISTENER_TABLE;


#define TCP_MIB_STAT_ID         1
#define UDP_MIB_STAT_ID         1
#define TCP_MIB_TABLE_ID        0x101
#define UDP_MIB_TABLE_ID        0x101
#define TCP_EX_TABLE_ID         0x102
#define UDP_EX_TABLE_ID         0x102

// Sockets based identifiers for connections.

typedef struct TCPSocketOption {
    ulong       tso_value;
} TCPSocketOption;

typedef struct TCPKeepalive {
    ulong   onoff;
    ulong   keepalivetime;
    ulong   keepaliveinterval;
} TCPKeepalive;

//* Structure passed in/returned from the SOCKET_ATMARK call. The tsa_offset
//  field indicate how far back or forward in the data stream urgent data
//  was or will be returned. A negative value means inline urgent data has
//  already been given to the client, -tsa_offset bytes ago. A positive value
//  means that inline urgent data is available tsa_offset bytes down the
//  data stream. The tsa_size field is the size in bytes of the urgent data.
//  This call when always return a 0 size and offset if the connection is not
//  in the urgent inline mode.

typedef struct TCPSocketAMInfo {
    ulong       tsa_size;               // Size of urgent data returned.
    long        tsa_offset;             // Offset of urgent data returned.
} TCPSocketAMInfo;

#define TCP_SOCKET_NODELAY      1
#define TCP_SOCKET_KEEPALIVE    2
#define TCP_SOCKET_OOBINLINE    3
#define TCP_SOCKET_BSDURGENT    4
#define TCP_SOCKET_ATMARK       5
#define TCP_SOCKET_WINDOW       6
#define TCP_SOCKET_KEEPALIVE_VALS 7
#define TCP_SOCKET_TOS          8
#define TCP_SOCKET_SCALE_CWIN   9


//  Address object identifies. All but AO_OPTION_MCASTIF take single boolean
//  character value. That one expects a pointer to an IP address.

#define AO_OPTION_TTL                1
#define AO_OPTION_MCASTTTL           2
#define AO_OPTION_MCASTIF            3
#define AO_OPTION_XSUM               4
#define AO_OPTION_IPOPTIONS          5
#define AO_OPTION_ADD_MCAST          6
#define AO_OPTION_DEL_MCAST          7
#define AO_OPTION_TOS                8
#define AO_OPTION_IP_DONTFRAGMENT    9
#define AO_OPTION_MCASTLOOP         10
#define AO_OPTION_BROADCAST         11
#define AO_OPTION_IP_HDRINCL        12
#define AO_OPTION_RCVALL            13
#define AO_OPTION_RCVALL_MCAST      14
#define AO_OPTION_RCVALL_IGMPMCAST  15
#define AO_OPTION_UNNUMBEREDIF      16
#define AO_OPTION_IP_UCASTIF        17
#define AO_OPTION_ABSORB_RTRALERT   18
#define AO_OPTION_LIMIT_BCASTS      19
#define AO_OPTION_INDEX_BIND        20
#define AO_OPTION_INDEX_MCASTIF     21
#define AO_OPTION_INDEX_ADD_MCAST   22
#define AO_OPTION_INDEX_DEL_MCAST   23
#define AO_OPTION_IFLIST            24
#define AO_OPTION_ADD_IFLIST        25
#define AO_OPTION_DEL_IFLIST        26
#define AO_OPTION_IP_PKTINFO        27
#define AO_OPTION_ADD_MCAST_SRC     28
#define AO_OPTION_DEL_MCAST_SRC     29
#define AO_OPTION_MCAST_FILTER      30
#define AO_OPTION_BLOCK_MCAST_SRC   31
#define AO_OPTION_UNBLOCK_MCAST_SRC 32
#define AO_OPTION_UDP_CKSUM_COVER   33
#define AO_OPTION_WINDOW            34
#define AO_OPTION_SCALE_CWIN        35
#define AO_OPTION_RCV_HOPLIMIT      36
#define AO_OPTION_UNBIND            37
#define AO_OPTION_PROTECT           38

// Values used with AO_OPTION_RCVALL*
// These must match the values defined in mstcpip.h
#define RCVALL_OFF             0
#define RCVALL_ON              1
#define RCVALL_SOCKETLEVELONLY 2

// Values used with AO_OPTION_PROTECT
// These must match the values defined in ws2tcpip.h
#define PROTECTION_LEVEL_UNRESTRICTED  10  // For peer-to-peer apps.
#define PROTECTION_LEVEL_DEFAULT       20  // Default level.
#define PROTECTION_LEVEL_RESTRICTED    30  // For Intranet apps.

//* Information relating to setting/deleting IP multicast addresses.
typedef struct UDPMCastReq {
    ulong       umr_addr;               // MCast address to add/delete.
    ulong       umr_if;                 // I/F on which to join.
} UDPMCastReq;

//* Information relating to setting/deleting IP multicast source/group
//  addresses.  This must match ip_mreq_source.
typedef struct UDPMCastSrcReq {
    ulong       umr_addr;               // MCast address to add/delete.
    ulong       umr_src;                // Source address to add/delete.
    ulong       umr_if;                 // I/F on which to join.
} UDPMCastSrcReq;

//* Information relating to setting/deleting IP multicast source filters.
//  This must match ip_msfilter.
typedef struct UDPMCastFilter {
    ulong       umf_addr;               // MCast address to apply source to.
    ulong       umf_if;                 // I/F on which to join.
    ulong       umf_fmode;              // Filter mode (TRUE=exclude)
    ulong       umf_numsrc;             // Number of sources.
    ulong       umf_srclist[1];           // Source array.
} UDPMCastFilter;

#define UDPMCAST_FILTER_SIZE(numsrc) \
    ((ulong)FIELD_OFFSET (UDPMCastFilter, umf_srclist[numsrc]))

//* Structure defining what is passed in to AO_OPTION_MCASTIF request.
typedef struct UDPMCastIFReq {
    IPAddr      umi_addr;
} UDPMCastIFReq;


//* Structures used in security filter enumeration.
//  All values are in HOST byte order!!!
typedef struct TCPSecurityFilterEntry {
    ulong   tsf_address;        // IP interface address
    ulong   tsf_protocol;       // Transport protocol number
    ulong   tsf_value;          // Transport filter value (e.g. TCP port)
} TCPSecurityFilterEntry;

typedef struct TCPSecurityFilterEnum {
    ULONG tfe_entries_returned;  // The number of TCPSecurityFilterEntry structs
                                 // returned in the subsequent array.

    ULONG tfe_entries_available; // The number of TCPSecurityFilterEntry structs
                                 // currently available from the transport.
} TCPSecurityFilterEnum;

//* Structures used in connection list enumeration.
//  All values are in HOST byte order!!!
typedef struct TCPConnectionListEntry {
    IPAddr  tcf_address;        // IP address
    uint    tcf_ticks;          // Tick Count remaining
} TCPConnectionListEntry;

typedef struct TCPConnectionListEnum {
    ULONG tce_entries_returned;  // The number of TCPConnectionListEntry structs
                                 // returned in the subsequent array.

    ULONG tce_entries_available; // The number of TCPConnectionListEntry structs
                                 // currently available from the transport.
} TCPConnectionListEnum;


//* Connection Callback object for TCP.
#define TCP_CCB_NAME    L"\\Callback\\TcpConnectionCallback"

//* Address information for TCP connections.
typedef struct TCPAddrInfo {
    ulong       tai_daddr;          // Destination IP address.
    ulong       tai_saddr;          // Source IP address.
    ushort      tai_dport;          // Destination port.
    ushort      tai_sport;          // Source port.
} TCPAddrInfo;

//* Connection callback information for TCP connections.
typedef struct TCPCcbInfo {
    ulong          tci_prevstate;   // Previous state.
    ulong          tci_currstate;   // Current state.
    ulong          tci_incomingif;  // Incoming interface id.
    TCPAddrInfo    *tci_connaddr;   // Connection addres pointer.
} TCPCcbInfo;

#endif // TCP_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rxp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    RxP.h

Abstract:

    This is the private header file for the NT version of RpcXlate.

Author:

    John Rogers (JohnRo) 25-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    25-Mar-1991 JohnRo
        Created.
    03-May-1991 JohnRo
        RxpStartBuildingTransaction's data descriptor is SMB version (no Q's
        or U's).  RxpConvertBlock needs 2 versions of data descriptor.
        RcvDataPtrPtr and RcvDataPresent are redundant for RxpConvertArguments
        and RxpConvertBlock.  RxpTransactSmb now gets UNC server name.
        Fixed receive buffer size problem.  Use LPTSTR.
        Added stuff to allow runtime debug on/off changes.
        Clarify that RxpStartBuildingTransaction uses buffer as OUT.
        Reduced recompile hits from header files.
    06-May-1991 JohnRo
        Added RxpComputeRequestBufferSize().
    13-May-1991 JohnRo
        Added print Q and print job APIs support.
    14-May-1991 JohnRo
        Pass 2 aux descriptors to RxpConvertBlock.  Clarify other types of
        aux descriptors.
    18-May-1991 JohnRo
        Handle array of aux structs.
    19-May-1991 JohnRo
        Added DBGSTATIC definition.  Pass ResourceName to RxpSetField().
        Fixed RxpAddAscii().
    20-May-1991 JohnRo
        Make data descriptors OPTIONAL for RxpConvertBlock.
    29-May-1991 JohnRo
        RxpConvertArgs must return SendDataPtr16 and SendDataSize16.
    05-Jun-1991 JohnRo
        Added setfield debug output.
    11-Jun-1991 rfirth
        Added SmbRcvByteLen parameter to RxpConvertBlock
        Changed RetDataSize parameter to RxpTransactSmb to IN OUT LPDWORD
    12-Jun-1991 JohnRo
        Moved DBGSTATIC to <NetDebug.h>.
    13-Jun-1991 JohnRo
        RxpPackSendBuffer and RxpConvertArgs both need DataDesc16.
    15-Jul-1991 JohnRo
        Added FieldIndex parameter to RxpSetField.
        Changed RxpConvertDataStructures to allow ERROR_MORE_DATA, e.g. for
        print APIs.  Added debug flag for the same routine.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    19-Aug-1991 rfirth
        Added Flags parameter to RxpConvert{Args|Block}
    04-Oct-1991 JohnRo
        Handle ERROR_BAD_NET_NAME (e.g. IPC$ not shared) to fix NetShareEnum.
        More work toward UNICODE.  (Added RxpAddTStr().)
    07-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.
    24-Oct-1991 JohnRo
        Added RxpCopyStrArrayToTStrArray for remote config and disk enum.
    29-Oct-1991 JohnRo
        RxpFatalErrorCode() should be paranoid.
    13-Nov-1991 JohnRo
        OK, RxpFatalErrorCode() was too paranoid.  It should allow
        ERROR_MORE_DATA or all the enum APIs break.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.
    26-Jun-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.
    04-May-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.
        Made changes suggested by PC-LINT 5.0
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.

--*/

#ifndef _RXP_
#define _RXP_

// These must be included first:

#include <windef.h>             // IN, LPTSTR, LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <rap.h>                // LPDESC, RapStructureSize(), etc.
// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,rxp.h,smbgtpt.h,stdarg.h,tstr.h,tstring.h) */
/*lint -efile(766,rxp.h,smbgtpt.h,stdarg.h,tstr.h,tstring.h) */
#include <smbgtpt.h>            // SmbPutUshort() (needed by macros below).
#include <stdarg.h>             // va_list, etc.
#include <tstring.h>            // NetpCopyTStrToStr().


// Maximum sizes (in bytes) supported by the transact SMB.
#define MAX_TRANSACT_RET_DATA_SIZE      ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_RET_PARM_SIZE      ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_SEND_DATA_SIZE     ((DWORD) 0x0000FFFF)
#define MAX_TRANSACT_SEND_PARM_SIZE     ((DWORD) 0x0000FFFF)


// Note: IF_DEBUG() and so on are now in Net/Inc/RxpDebug.h.

DWORD
RxpComputeRequestBufferSize(
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    IN DWORD DataSize
    );

NET_API_STATUS
RxpConvertArgs(
    IN LPDESC ParmDescriptorString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD MaximumInputBlockSize,
    IN DWORD MaximumOutputBlockSize,
    IN OUT LPDWORD CurrentInputBlockSizePtr,
    IN OUT LPDWORD CurrentOutputBlockSizePtr,
    IN OUT LPBYTE * CurrentOutputBlockPtrPtr,
    IN va_list * FirstArgumentPtr,      // rest of API's arguments (after
                                        // server name)
    OUT LPDWORD SendDataSizePtr16,
    OUT LPBYTE * SendDataPtrPtr16,
    OUT LPDWORD RcvDataSizePtr,
    OUT LPBYTE * RcvDataPtrPtr,
    IN  DWORD   Flags
    );

NET_API_STATUS
RxpConvertBlock(
    IN  DWORD   ApiNumber,
    IN  LPBYTE  ResponseBlockPtr,
    IN  LPDESC  ParmDescriptorString,
    IN  LPDESC  DataDescriptor16 OPTIONAL,
    IN  LPDESC  DataDescriptor32 OPTIONAL,
    IN  LPDESC  AuxDesc16 OPTIONAL,
    IN  LPDESC  AuxDesc32 OPTIONAL,
    IN  va_list* FirstArgumentPtr,      // rest of API's arguments
    IN  LPBYTE  SmbRcvBuffer OPTIONAL,
    IN  DWORD   SmbRcvByteLen,
    OUT LPBYTE  RcvDataPtr OPTIONAL,
    IN  DWORD   RcvDataSize,
    IN  DWORD   Flags
    );

// DWORD
// RxpEstimateBytesNeeded(
//     IN DWORD BytesNeeded16
//     );
//
// Worst case: BOOL or CHAR might be padded to DWORD.
#define RxpEstimateBytesNeeded(Size16) \
    ( (Size16) * 4 )

//
// Estimate bytes needed for an audit log or error log array.
//
NET_API_STATUS
RxpEstimateLogSize(
    IN DWORD DownlevelFixedEntrySize,
    IN DWORD InputArraySize,
    IN BOOL DoingErrorLog,    // TRUE for error log, FALSE for audit log
    OUT LPDWORD OutputArraySize
    );

// BOOL
// RxpFatalErrorCode(
//     IN NET_API_STATUS Status
//     );
//
#define RxpFatalErrorCode( Status )             \
    ( ( ((Status) != NERR_Success)              \
     && ((Status) != ERROR_MORE_DATA) )         \
    ? TRUE : FALSE )

NET_API_STATUS
RxpPackSendBuffer(
    IN OUT LPVOID * SendBufferPtrPtr,
    IN OUT LPDWORD SendBufferSizePtr,
    OUT LPBOOL AllocFlagPtr,
    IN LPDESC DataDesc16,
    IN LPDESC AuxDesc16,
    IN DWORD FixedSize16,
    IN DWORD AuxOffset,
    IN DWORD AuxSize,
    IN BOOL SetInfo
    );

NET_API_STATUS
RxpReceiveBufferConvert(
    IN OUT LPVOID RcvDataPtr,
    IN DWORD      RcvDataSize,
    IN DWORD      Converter,
    IN DWORD      NumberOfStructures,
    IN LPDESC     DataDescriptorString,
    IN LPDESC     AuxDescriptorString,
    OUT LPDWORD   NumAuxStructs
    );

NET_API_STATUS
RxpSetField (
    IN DWORD ApiNumber,
    IN LPTSTR UncServerName,
    IN LPDESC ObjectDesc OPTIONAL,
    IN LPVOID ObjectToSet OPTIONAL,
    IN LPDESC ParmDesc,
    IN LPDESC DataDesc16,
    IN LPDESC DataDesc32,
    IN LPDESC DataDescSmb,
    IN LPVOID NativeInfoBuffer,
    IN DWORD ParmNumToSend,
    IN DWORD FieldIndex,
    IN DWORD Level
    );

NET_API_STATUS
RxpStartBuildingTransaction(
    OUT LPVOID Buffer,
    IN DWORD BufferSize,
    IN DWORD ApiNumber,
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    OUT LPVOID * RovingOutputPtr,
    OUT LPDWORD SizeSoFarPtr,
    OUT LPVOID * LastStringPtr OPTIONAL,
    OUT LPDESC * ParmDescCopyPtr OPTIONAL
    );

NET_API_STATUS
RxpTransactSmb(
    IN LPTSTR UncServerName,
    IN LPTSTR TransportName,
    IN LPVOID SendParmPtr,
    IN DWORD SendParmSize,
    IN LPVOID SendDataPtr OPTIONAL,
    IN DWORD SendDataSize,
    OUT LPVOID RetParmPtr OPTIONAL,
    IN DWORD RetParmSize,
    OUT LPVOID RetDataPtr OPTIONAL,
    IN OUT LPDWORD RetDataSize,
    IN BOOL NoPermissionRequired
    );

NET_API_STATUS
RxpConvertDataStructures(
    IN  LPDESC  InputDescriptor,
    IN  LPDESC  OutputDescriptor,
    IN  LPDESC  InputAuxDescriptor OPTIONAL,
    IN  LPDESC  OutputAuxDescriptor OPTIONAL,
    IN  LPBYTE  InputBuffer,
    OUT LPBYTE  OutputBuffer,
    IN  DWORD   OutputBufferSize,
    IN  DWORD   PrimaryCount,
    OUT LPDWORD EntriesConverted OPTIONAL,
    IN  RAP_TRANSMISSION_MODE TransmissionMode,
    IN  RAP_CONVERSION_MODE ConversionMode
    );



// VOID
// RxpAddPointer(
//     IN LPVOID Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#if defined(_WIN64)

#define RxpAddPointer(Input,CurPtrPtr,CurSizePtr)                       \
            {                                                           \
                *((PVOID UNALIGNED *)(*(CurPtrPtr))) = (Input);         \
                *(CurPtrPtr) += sizeof(LPBYTE);                         \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(LPBYTE);       \
            }

#else

#define RxpAddPointer(Input,CurPtrPtr,CurSizePtr)                       \
            {                                                           \
                SmbPutUlong( (LPDWORD) *(CurPtrPtr), (DWORD) (Input));  \
                *(CurPtrPtr) += sizeof(LPBYTE);                         \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(LPBYTE);       \
            }

#endif


// RxpAddVariableSize: Add a variable length item to string space at end of
// buffer.  Store pointer to it in buffer; update current buffer pointer and
// Size; update string space pointer.
//
// VOID
// RxpAddVariableSize(
//     IN LPBYTE Input,
//     IN DWORD InputSize,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddVariableSize(Input,InputSize,CurPtrPtr,StrPtrPtr,CurSizePtr) \
            {                                                            \
                *(StrPtrPtr) -= (InputSize);                             \
                RxpAddPointer( *(StrPtrPtr), (CurPtrPtr), (CurSizePtr)); \
                NetpMoveMemory( *((StrPtrPtr)), (Input), (InputSize));   \
            }

// RxpAddAscii: Add an ASCII string to string space at end of buffer;
// store pointer to it in buffer; update current buffer pointer and Size;
// update string space pointer.
//
// VOID
// RxpAddAscii(
//     IN LPTSTR Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddAscii(Input,CurPtrPtr,StrPtrPtr,CurSizePtr)               \
            {                                                           \
                DWORD len = strlen((Input))+1;                          \
                RxpAddVariableSize(                                     \
                    (Input), len,                                       \
                    (CurPtrPtr), (StrPtrPtr), (CurSizePtr));            \
            }

// RxpAddTStr: Add a LPTSTR string to string space at end of buffer;
// store pointer to it in buffer; update current buffer pointer and Size;
// update string space pointer.
//
// VOID
// RxpAddTStr(
//     IN LPTSTR Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPBYTE * StrPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddTStr(Input,CurPtrPtr,StrPtrPtr,CurSizePtr)                 \
            {                                                            \
                DWORD size = STRLEN((Input))+1;                          \
                *(StrPtrPtr) -= size;                                    \
                RxpAddPointer( *(StrPtrPtr), (CurPtrPtr), (CurSizePtr)); \
                NetpCopyWStrToStrDBCS( *((StrPtrPtr)), (Input) );        \
            }

// VOID
// RxpAddWord(
//     IN WORD Input,
//     IN OUT LPBYTE * CurPtrPtr,
//     IN OUT LPDWORD CurSizePtr
//     );
//
#define RxpAddWord(Input,CurPtrPtr,CurSizePtr)                          \
            {                                                           \
                SmbPutUshort( (LPWORD) (*(CurPtrPtr)), (WORD) (Input)); \
                *(CurPtrPtr) += sizeof(WORD);                           \
                *(CurSizePtr) = (*(CurSizePtr)) + sizeof(WORD);         \
            }

//
// MAKE_PARMNUM_PAIR() - packs a parmnum and a field index into a DWORD. We
// have to do this because there are (many) cases where we cannot assume
// correspondence between a parmnum and a field index
//

#define MAKE_PARMNUM_PAIR(parmnum, field_index) ((DWORD)((((DWORD)(field_index)) << 16) | (DWORD)(parmnum)))

//
// FIELD_INDEX_FROM_PARMNUM_PAIR() - retrieve the field index from the pair
// conjoined by MAKE_PARMNUM_PAIR()
//

#define FIELD_INDEX_FROM_PARMNUM_PAIR(pair) ((DWORD)((pair) >> 16))

//
// PARMNUM_FROM_PARMNUM_PAIR() - retrieve the parmnum from the pair conjoined
// by MAKE_PARMNUM_PAIR()
//

#define PARMNUM_FROM_PARMNUM_PAIR(pair) ((DWORD)((pair) & 0x0000ffff))

#endif // ndef _RXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\uiexport.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    uiexport.h

    Prototypes for Net UI exported APIs



    FILE HISTORY:
	Johnl	17-Apr-1992	Created

*/

#ifndef _UIEXPORT_H_
#define _UIEXPORT_H_

#ifdef __cplusplus
extern "C" {
#endif


/* Selections the user can make in the System focus dialog
 */

/* Low word of the selection type
 */
#define FOCUSDLG_DOMAINS_ONLY		(1)
#define FOCUSDLG_SERVERS_ONLY		(2)
#define FOCUSDLG_SERVERS_AND_DOMAINS	(3)

/* High word of the selection type contains a bitmask indicating
 * which domains to display in the dialog.
 * WARNING: This bitmask are shifted up 16 bits from the bitmask in
 *          \nt\private\net\ui\common\h\domenum.h. If you want to
 *          modify the values of the bitmask, you will need to
 *          make corresponding changes to domenum.h.
 *
 */

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

/* Some handy combinations of flags.
*/

/* FOCUSDLG_BROWSE_LM2X_DOMAINS will return only the domains available
   from a LanMan 2.x workstation.  This returns just the logon,
   workstation, and other domains. This is the default value.
*/

#define FOCUSDLG_BROWSE_LM2X_DOMAINS  ( FOCUSDLG_BROWSE_LOGON_DOMAIN       | \
                                        FOCUSDLG_BROWSE_WKSTA_DOMAIN       | \
                                        FOCUSDLG_BROWSE_OTHER_DOMAINS )

/*
   FOCUSDLG_BROWSE_LOCAL_DOMAINS will return only the domains available
   to the local machine.  This returns the logon, workstation,
   and other, plus the domains that trust "us".
*/

#define FOCUSDLG_BROWSE_LOCAL_DOMAINS ( FOCUSDLG_BROWSE_LM2X_DOMAINS       | \
                                        FOCUSDLG_BROWSE_TRUSTING_DOMAINS )

/*
  FOCUSDLG_BROWSE_ALL_DOMAINS is a conglomeration of all potential domain
  sources available to the domain enumerator.
*/

#define FOCUSDLG_BROWSE_ALL_DOMAINS   ( FOCUSDLG_BROWSE_LOCAL_DOMAINS      | \
                                        FOCUSDLG_BROWSE_WORKGROUP_DOMAINS )

/*******************************************************************

    NAME:	I_SystemFocusDialog

    SYNOPSIS:	Presents a dialog to the user from which a server or domain
		maybe selected.

    ENTRY:	hwndOwner -       Parent window handle
		nSelectionType -  The type of selection the user is allowed
			          to make
		pszName -         The server or domain name. It will be
			          undefined if the user hits the CANCEL
                                  button ( pfOK = FALSE )
		cchBufSize -      The buffer size of the lptstrName.
		pfUserQuit -      If the user hits the OKAY button, it will
                                  return TRUE. Otherwise, it will return FALSE.
                pszHelpFile -     The helpfile to use when the user hits F1.
                                  If NULL, the default helpfile is used.
                nHelpContext -    The helpcontext to use for the helpfile above.
 				  If the above is NULL, this must be 0 (& vice
                                  versa).

    EXIT:	if *pfOKPressed is TRUE (and an error didn't occur), then
		lptstrName will be filled with the user selected name.

    RETURNS:	NO_ERROR on success, standard ERROR_* error code otherwise

    NOTES:	This will be a UNICODE only API when the net group goes UNICODE

    HISTORY:
	JohnL	22-Apr-1992	Added selection option, exported to private\inc
	ChuckC	03-Nov-1992	Added helpfile & help context

********************************************************************/

UINT FAR PASCAL I_SystemFocusDialog(
    HWND    hwndOwner,
    UINT    nSelectionType,
    LPWSTR  pszName,
    UINT    cchBufSize,
    BOOL   *pfOKPressed,
    LPWSTR  pszHelpFile,
    DWORD   nHelpContext
    );

typedef UINT (FAR PASCAL *LPFNI_SYSTEMFOCUSDIALOG)(
    HWND    hwndOwner,
    UINT    nSelectionType,
    LPWSTR  pszName,
    UINT    cchBufSize,
    BOOL   *pfOKPressed,
    LPWSTR  pszHelpFile,
    DWORD   nHelpContext
    );

#ifdef __cplusplus
}
#endif

#endif //_UIEXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\rxuser.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rxuser.h

Abstract:

    Prototypes for down-level remoted RxNetUser... routines

Author:

    Richard Firth (rfirth) 28-May-1991

Revision History:

    28-May-1991 RFirth
        Created

--*/

NET_API_STATUS
RxNetUserAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetUserDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName
    );

NET_API_STATUS
RxNetUserEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );

NET_API_STATUS
RxNetUserGetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    );

NET_API_STATUS
RxNetUserGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetUserModalsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    );

NET_API_STATUS
RxNetUserModalsSet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS
RxNetUserPasswordSet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  LPTSTR  OldPassword,
    IN  LPTSTR  NewPassword
    );

NET_API_STATUS
RxNetUserSetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    IN  DWORD   Entries
    );

NET_API_STATUS
RxNetUserSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    );


//NET_API_STATUS
//RxNetUserValidate2
//    /** CANNOT BE REMOTED **/
//{
//
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\uio.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    uio.h

Abstract:

    I/O structure definitions for compatibility with BSD.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  Spider BSD Compatibility
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  UIO.H
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/include/bsd/sys/0/s.uio.h
 *      @(#)uio.h       5.3
 *
 *      Last delta created      14:41:47 3/4/91
 *      This file extracted     11:24:29 3/8/91
 *
 *      Modifications:
 *
 *              GSS     19 Jun 90       New File
 */

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)uio.h       7.1 (Berkeley) 6/4/86
 */

#ifndef _UIO_
#define _UIO_

typedef long                   daddr_t;
typedef char FAR *             caddr_t;

struct iovec {
        caddr_t iov_base;
        int     iov_len;
};

struct uio {
        struct  iovec *uio_iov;
        int     uio_iovcnt;
        int     uio_offset;
        int     uio_segflg;
        int     uio_resid;
};

enum    uio_rw { UIO_READ, UIO_WRITE };

/*
 * Segment flag values (should be enum).
 */
#define UIO_USERSPACE   0               /* from user data space */
#define UIO_SYSSPACE    1               /* from system space */
#define UIO_USERISPACE  2               /* from user I space */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\wlrsop.h ===
//
// For stuff that's passed from Winlogon/Group Policy
// to polstore (see RSOP_PolicySetting in MSDN)
//

#define WIRELESS_RSOP_CLASSNAME L"RSOP_IEEE80211PolicySetting"

typedef struct _GPO_INFO {
  BSTR     bsCreationtime;
  UINT32   uiPrecedence;
  BSTR     bsGPOID;
  BSTR     bsSOMID;
  UINT32   uiTotalGPOs;
}  GPO_INFO, *PGPO_INFO;



HRESULT
WirelessWriteDirectoryPolicyToWMI(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    PGPO_INFO pGPOInfo,
    IWbemServices *pWbemServices
    );

HRESULT
WirelessClearWMIStore(
    IWbemServices *pWbemServices
    );

typedef struct _RSOP_INFO {
  LPWSTR   pszCreationtime;
  LPWSTR   pszID;
  LPWSTR   pszName;
  UINT32   uiPrecedence;
  LPWSTR   pszGPOID;
  LPWSTR   pszSOMID;
} RSOP_INFO, * PRSOP_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\winsintf.h ===
#ifndef WINSINTF_H
#define WINSINTF_H
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	winsintf.h	

Abstract:
	
	This is the header file to be included in a client of the WINS

Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	April-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include <winbase.h>

#if !defined(MIDL_PASS)
#include <rpc.h>
#include <rpcasync.h>
#include <winerror.h>
#endif

#ifdef  WINS_CLIENT_APIS
#define DECLARE_WINS_HANDLE( _hdl ) WINSIF2_HANDLE    _hdl,
#define DECLARE_WINS_HANDLE0( _hdl ) WINSIF2_HANDLE    _hdl
#else
#define DECLARE_WINS_HANDLE( _hdl )
#define DECLARE_WINS_HANDLE0( _hdl )
#endif  WINS_CLIENT_APIS

/*
  defines
*/
#define WINSINTF_MAX_NAME_SIZE			255
//#define WINSINTF_MAX_COMPUTERNAME_LENGTH			(MAX_COMPUTERNAME_LENGTH + 1)


#define WINSINTF_MAX_NO_RPL_PNRS	25
#define WINSINTF_SUCCESS 		ERROR_SUCCESS
#define WINSINTF_FAILURE 		 ERROR_WINS_INTERNAL
#define WINSINTF_CAN_NOT_DEL_LOCAL_WINS ERROR_CAN_NOT_DEL_LOCAL_WINS
#define WINSINTF_STATIC_INIT_FAILED  ERROR_STATIC_INIT
#define WINSINTF_INC_BACKUP_FAILED   ERROR_INC_BACKUP
#define WINSINTF_FULL_BACKUP_FAILED  ERROR_FULL_BACKUP
#define WINSINTF_REC_NOT_FOUND       ERROR_REC_NON_EXISTENT
#define WINSINTF_RPL_NOT_ALLOWED     ERROR_RPL_NOT_ALLOWED

#define WINSINTF_TOO_MANY_STATIC_INITS  ERROR_TOO_MANY_OPEN_FILES
#define WINSINTF_LAST_FAILURE_CODE	WINSINTF_TOO_MANY_STATIC_INITS

#define WINS_BACKUP_DIR_ASCII   "\\wins_bak"
#define WINS_BACKUP_DIR          TEXT(WINS_BACKUP_DIR_ASCII)

//
// Flags that can be set in WINS
//
#define WINSINTF_BS                     0x01
#define WINSINTF_MEMORY_INFO_DUMP       0x02
#define WINSINTF_HEAP_INFO_DUMP         0x04
#define WINSINTF_QUE_ITEMS_DUMP         0x08

#define  WINS_NO_ACCESS	        0x0
#define  WINS_CONTROL_ACCESS	0x0001
#define  WINS_QUERY_ACCESS	    0x0002

#define  WINS_ALL_ACCESS	(STANDARD_RIGHTS_REQUIRED | \
				  WINS_CONTROL_ACCESS |WINS_QUERY_ACCESS)

//
// Type of address families
//
#define WINSINTF_TCP_IP			0x0

//
// Type Of Recs to retrieve (WinsGetDbRecsByName)
//
//  Note: There should be no ovelap of bit patterns
//
#define WINSINTF_STATIC  1
#define WINSINTF_DYNAMIC 2
#define WINSINTF_BOTH    4

//
// Max. members returned for a special group or a multihomed entry
//
#define WINSINTF_MAX_MEM		25	
#define WINSINTF_MAX_ADD		(WINSINTF_MAX_MEM * 2)	

//
//  used as argument of WinsGetDbRecsByName
//
#define  WINSINTF_BEGINNING       0
#define  WINSINTF_END             1

/*
  macros
*/

//
// Pass the value of the field NameLen (WINSINTF_RECORD_ACTION_T) to get
// the actual length of the name
//
#define  WINSINTF_NAME_LEN_M(NameLen)   ((NameLen) - 1)


/*
 externs
*/
struct _WINSINTF_STAT_T;		//forward declaration

#if !defined(MIDL_PASS)
extern  struct _WINSINTF_STAT_T   WinsIntfStat;
extern CRITICAL_SECTION 	WinsIntfCrtSec;
extern CRITICAL_SECTION 	WinsIntfPotentiallyLongCrtSec;
#endif

extern DWORD	WinsIntfNoOfNbtThds;
extern DWORD	WinsIntfNoCncrntStaticInits;
//extern DWORD    WinsIntfNoOfRpcThds;


#ifndef UNICODE
#define WinsBind  WinsABind
#else
#define WinsBind  WinsUBind
#endif

/*
* typedefs
*/
typedef LARGE_INTEGER	WINSINTF_VERS_NO_T;
typedef handle_t        WINSIF2_HANDLE;

//
// NOTE NOTE NOTE
//
// When UNICODE is defined, the client should put a unicode string in
// the pServerAdd and pPipeName fields.
//
typedef struct _WINSINTF_BIND_DATA_T {
		DWORD	fTcpIp;
		LPSTR   pServerAdd; //IP address
		LPSTR	pPipeName;  //unc name
	} WINSINTF_BIND_DATA_T, *PWINSINTF_BIND_DATA_T;


typedef struct _WINSINTF_ADD_T {
		BYTE	Type;
		DWORD	Len;
		DWORD	IPAdd;
	} WINSINTF_ADD_T, *PWINSINTF_ADD_T;
	

	
/*
 enum  definitions.  Have the enum types be of the same value as given
 in nmsdb.h for the various types (otherwise modify winsintf.c code)
*/

//
// Wins Priority Class
//
typedef enum _WINSINTF_PRIORITY_CLASS_E {
		WINSINTF_E_NORMAL = 0,
		WINSINTF_E_HIGH
	} WINSINTF_PRIORITY_CLASS_E, *PWINSINTF_PRIORITY_CLASS_E;

//
// same values as those defined in nmsdb.h
//

//
//NOTE NOTE NOTE
//
// For the enum below,  WINSINTF_E_MULTIHOMED should be the last entry. If
// it is not, you should change WinsRecordAction (under MODIFY) in winsintf.c
//
// Do not disturb the order without changing wins.mib correspondingly
//
typedef enum _WINSINTF_RECTYPE_E {
		WINSINTF_E_UNIQUE 	= 0,
		WINSINTF_E_NORM_GROUP,
		WINSINTF_E_SPEC_GROUP,
		WINSINTF_E_MULTIHOMED
	} WINSINTF_RECTYPE_E, *PWINSINTF_RECTYPE_E;

//
// Same values as those in NMSDB_STATE_E
//

//
//NOTE NOTE NOTE
//
// For the enum below,  WINSINTF_E_DELETED should be the last entry. If
// it is not, you should change WinsRecordAction (under MODIFY) in winsintf.c
//
//  NOTE NOTE NOTE
//
// Do not disturb the order without changing wins.mib correspondingly
//
typedef enum _WINSINTF_STATE_E {
		WINSINTF_E_ACTIVE = 0,
		WINSINTF_E_RELEASED,
		WINSINTF_E_TOMBSTONE,
		WINSINTF_E_DELETED
		} WINSINTF_STATE_E, *PWINSINTF_STATE_E;

typedef enum _WINSINTF_NODE_TYPE_E {
		WINSINTF_E_BNODE = 0,
		WINSINTF_E_PNODE,
		WINSINTF_E_HNODE = 3,
		} WINSINTF_NODE_TYPE_E, *PWINSINTF_NODE_TYPE_E;
//
// Type of action to take on a record.  This is passed as the "command" to
// WinsRecordAction.
//
typedef enum  _WINSINTF_ACT_E {
	WINSINTF_E_INSERT = 0,
	WINSINTF_E_DELETE,
	WINSINTF_E_RELEASE,
	WINSINTF_E_MODIFY,
	WINSINTF_E_QUERY
	} WINSINTF_ACT_E, *PWINSINTF_ACT_E;


//
// Passed as argument to WinsIntfSetTime
//
typedef enum _WINSINTF_TIME_TYPE_E {
	WINSINTF_E_PLANNED_PULL = 0,
	WINSINTF_E_ADDCHG_TRIG_PULL,
	WINSINTF_E_UPDCNT_TRIG_PULL,
	WINSINTF_E_ADMIN_TRIG_PULL,
	WINSINTF_E_NTWRK_TRIG_PULL,
	WINSINTF_E_PLANNED_SCV,
	WINSINTF_E_ADMIN_TRIG_SCV,
	WINSINTF_E_TOMBSTONES_SCV,
	WINSINTF_E_VERIFY_SCV,
	WINSINTF_E_INIT_DB,
	WINSINTF_E_WINS_START,
	WINSINTF_E_COUNTER_RESET
	} WINSINTF_TIME_TYPE_E, *PWINSINTF_TIME_TYPE_E;

//
// Type of trigger to send to a WINS
//
typedef enum _WINSINTF_TRIG_TYPE_E {	
		WINSINTF_E_PULL = 0,
		WINSINTF_E_PUSH,
		WINSINTF_E_PUSH_PROP
	} WINSINTF_TRIG_TYPE_E, *PWINSINTF_TRIG_TYPE_E;


typedef struct _WINSINTF_RECORD_ACTION_T {

	WINSINTF_ACT_E	Cmd_e;
#if defined(MIDL_PASS)
	[size_is(NameLen + 1)] LPBYTE	pName;  //ansi form
#else
        LPBYTE          pName;
#endif

	DWORD		NameLen;
	DWORD		TypOfRec_e;
	DWORD		NoOfAdds;
#if defined(MIDL_PASS)
        [unique, size_is(NoOfAdds)] PWINSINTF_ADD_T pAdd;
#else
        PWINSINTF_ADD_T pAdd;
#endif

	WINSINTF_ADD_T	Add;
	LARGE_INTEGER	VersNo;
	BYTE		NodeTyp;
	DWORD		OwnerId;
	DWORD		State_e;
	DWORD		fStatic;
	DWORD_PTR       TimeStamp;
	} WINSINTF_RECORD_ACTION_T, *PWINSINTF_RECORD_ACTION_T;


typedef struct _WINSINTF_RPL_COUNTERS_T {
		WINSINTF_ADD_T	Add;
		DWORD	NoOfRpls;
		DWORD	NoOfCommFails;
		} WINSINTF_RPL_COUNTERS_T, *PWINSINTF_RPL_COUNTERS_T;
//
// Structure holds the various statistics collected by WINS
//
typedef struct _WINSINTF_STAT_T {
		struct {
		DWORD  NoOfUniqueReg;
		DWORD  NoOfGroupReg;
		DWORD  NoOfQueries;
		DWORD  NoOfSuccQueries;
		DWORD  NoOfFailQueries;
		DWORD  NoOfUniqueRef;
		DWORD  NoOfGroupRef;
		DWORD  NoOfRel;
		DWORD  NoOfSuccRel;
		DWORD  NoOfFailRel;
		DWORD  NoOfUniqueCnf;
		DWORD  NoOfGroupCnf;
		      } Counters;
		struct {
		SYSTEMTIME WinsStartTime;
		SYSTEMTIME LastPScvTime;
		SYSTEMTIME LastATScvTime;	//admin triggered
		SYSTEMTIME LastTombScvTime;	
		SYSTEMTIME LastVerifyScvTime;
		SYSTEMTIME LastPRplTime;
		SYSTEMTIME LastATRplTime;	//admin triggered
		SYSTEMTIME LastNTRplTime;	//network triggered
		SYSTEMTIME LastACTRplTime;	//address change triggered
		SYSTEMTIME LastInitDbTime;	//db initialization
		SYSTEMTIME CounterResetTime;    //counter reset time
		    } TimeStamps;
		DWORD			NoOfPnrs;

#if defined(MIDL_PASS)
		[unique, size_is(NoOfPnrs)] PWINSINTF_RPL_COUNTERS_T   pRplPnrs;
#else
		PWINSINTF_RPL_COUNTERS_T	pRplPnrs;
#endif
		} WINSINTF_STAT_T, *PWINSINTF_STAT_T;

typedef struct _WINSINTF_ADD_VERS_MAP_T {
		WINSINTF_ADD_T	Add;
		LARGE_INTEGER	VersNo;
		} WINSINTF_ADD_VERS_MAP_T, *PWINSINTF_ADD_VERS_MAP_T;
		
typedef struct _WINSINTF_RESULTS_T {
		DWORD			NoOfOwners;
		WINSINTF_ADD_VERS_MAP_T	AddVersMaps[WINSINTF_MAX_NO_RPL_PNRS];
		LARGE_INTEGER		MyMaxVersNo;
		DWORD			RefreshInterval;
		DWORD			TombstoneInterval;
		DWORD			TombstoneTimeout;
		DWORD			VerifyInterval;
		DWORD			WinsPriorityClass;
		DWORD			NoOfWorkerThds;
		WINSINTF_STAT_T		WinsStat;
		} WINSINTF_RESULTS_T, *PWINSINTF_RESULTS_T;	

typedef struct _WINSINTF_RESULTS_NEW_T {
		DWORD			NoOfOwners;
#if defined(MIDL_PASS)
		[unique, size_is(NoOfOwners)] PWINSINTF_ADD_VERS_MAP_T	pAddVersMaps;
#else
		PWINSINTF_ADD_VERS_MAP_T	pAddVersMaps;
#endif
		LARGE_INTEGER		MyMaxVersNo;
		DWORD			RefreshInterval;
		DWORD			TombstoneInterval;
		DWORD			TombstoneTimeout;
		DWORD			VerifyInterval;
		DWORD			WinsPriorityClass;
		DWORD			NoOfWorkerThds;
		WINSINTF_STAT_T		WinsStat;
		} WINSINTF_RESULTS_NEW_T, *PWINSINTF_RESULTS_NEW_T;	

typedef enum _WINSINTF_CMD_E {
		WINSINTF_E_ADDVERSMAP = 0,
		WINSINTF_E_CONFIG,
		WINSINTF_E_STAT,		//get statistics
		WINSINTF_E_CONFIG_ALL_MAPS
		} WINSINTF_CMD_E, *PWINSINTF_CMD_E;


#if 0
typedef struct _WINSINTF_RECS_T {
		PWINSINTF_RECORD_ACTION_T  pRow;
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;

typedef struct _WINSINTF_RECS_T {
		DWORD	BuffSize;
#if defined(MIDL_PASS)
		[unique,size_is(BuffSize)] LPBYTE  pRow;  //will store a pointer to
						   //an array of
						   //WINSINTF_RECORD_ACTION_T
						   //recs
#else
		LPBYTE pRow;
#endif
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;
#endif

typedef struct _WINSINTF_RECS_T {
		DWORD	BuffSize;
#if defined(MIDL_PASS)
		[unique,size_is(NoOfRecs)] PWINSINTF_RECORD_ACTION_T  pRow;  //will store a pointer to
						   //an array of
						   //WINSINTF_RECORD_ACTION_T
						   //recs
#else
		PWINSINTF_RECORD_ACTION_T pRow;
#endif
		DWORD   NoOfRecs;
		DWORD   TotalNoOfRecs;
	} WINSINTF_RECS_T, *PWINSINTF_RECS_T;

//
// Provides information to the Pull thread for pulling the specfied range
// of records from a WINS server.  This structure is passed with the
// QUE_E_CMD_PULL_RANGE cmd.
//
typedef struct _WINSINTF_PULL_RANGE_INFO_T {
	LPVOID			pPnr;          //info of pnr to pull from
	WINSINTF_ADD_T		OwnAdd;
	WINSINTF_VERS_NO_T	MinVersNo;
	WINSINTF_VERS_NO_T	MaxVersNo;
	} WINSINTF_PULL_RANGE_INFO_T, *PWINSINTF_PULL_RANGE_INFO_T;

//
// NOTE NOTE NOTE:
//
// This structure is exactly the same as SERVER_INFO_100_CONTAINER.
// IT SHOULD STAY THE SAME.
//
typedef struct _WINSINTF_BROWSER_INFO_T {
	DWORD	dwNameLen;
#if defined(MIDL_PASS)
	[string] LPBYTE	pName;
#else
	LPBYTE	pName;
#endif
	} WINSINTF_BROWSER_INFO_T, *PWINSINTF_BROWSER_INFO_T;

typedef struct _WINSINTF_BROWSER_NAMES_T {
	DWORD			EntriesRead;		//no use
#if defined(MIDL_PASS)
	[unique, size_is(EntriesRead)]  PWINSINTF_BROWSER_INFO_T pInfo;
#else
	PWINSINTF_BROWSER_INFO_T	pInfo;
#endif
	} WINSINTF_BROWSER_NAMES_T, *PWINSINTF_BROWSER_NAMES_T;

typedef enum _WINSINTF_SCV_OPC_E {
          WINSINTF_E_SCV_GENERAL,
          WINSINTF_E_SCV_VERIFY
  } WINSINTF_SCV_OPC_E, *PWINSINTF_SCV_OPC_E;

//
// To send a scavenge request
//
typedef struct _WINSINTF_SCV_REQ_T {
          WINSINTF_SCV_OPC_E  Opcode_e;
          DWORD               Age;
          DWORD               fForce;
   } WINSINTF_SCV_REQ_T, *PWINSINTF_SCV_REQ_T;
	
typedef enum _DbVersion{
    DbVersionMin,
    DbVersion351 = 1,
    DbVersion4,
    DbVersion5,
    DbVersionMax
} DbVersion;

/*
* function declarations
*/
extern
handle_t
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsBind(
	PWINSINTF_BIND_DATA_T	pBindData
	);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsUnbind(
	PWINSINTF_BIND_DATA_T	pBindData,
	handle_t		BindHdl
	);

extern
DWORD
R_WinsRecordAction(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_RECORD_ACTION_T *ppRecAction
		 );

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsRecordAction(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_RECORD_ACTION_T	*ppRecAction
	);

extern
DWORD
R_WinsStatus(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_T pResults
		 );


extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatus(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	LPVOID              pResults
		 );
extern
DWORD
R_WinsStatusNew(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
		 );
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatusNew(
    DECLARE_WINS_HANDLE( ServerHdl )
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
		 );
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsStatusWHdl(
    PWINSINTF_BIND_DATA_T    pWinsHdl,
	WINSINTF_CMD_E	    Cmd_e,
	PWINSINTF_RESULTS_NEW_T pResults
	);

extern
DWORD
R_WinsTrigger (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTrigger (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_TRIG_TYPE_E	TrigType_e
	);

extern
DWORD
R_WinsDoStaticInit (
    DECLARE_WINS_HANDLE( ServerHdl )
	LPWSTR pDataFilePath,
    DWORD  fDel
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoStaticInit (
    DECLARE_WINS_HANDLE( ServerHdl )
	LPWSTR pDataFilePath,
    DWORD  fDel
	);

extern
DWORD
R_WinsGetDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T	pRecs	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
WinsGetDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo,
	PWINSINTF_RECS_T	pRecs	
	);

extern
DWORD
R_WinsGetDbRecsByName (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
    DWORD               Location,
    LPBYTE              pName,
    DWORD               NameLen,
    DWORD               NoOfRecsDesired,
    DWORD               TypeOfRecs,
	PWINSINTF_RECS_T        pRecs	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetDbRecsByName (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
    DWORD               Location,
    LPBYTE              pName,
    DWORD               NameLen,
    DWORD               NoOfRecsDesired,
    DWORD               TypeOfRecs,
	PWINSINTF_RECS_T    pRecs	
	);

extern
DWORD
R_WinsDoScavenging (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoScavenging (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);
extern
DWORD
R_WinsDoScavengingNew (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_SCV_REQ_T pScvReq
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDoScavengingNew (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_SCV_REQ_T pScvReq
	);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsIntfSetTime(
    DECLARE_WINS_HANDLE( ServerHdl )
	IN OUT PSYSTEMTIME     		pTime,
	IN     WINSINTF_TIME_TYPE_E	TimeType_e
	);
extern
DWORD
R_WinsTerm (
    handle_t ServerHdl,
	IN short		fAbruptTerm
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTerm (
    handle_t ServerHdl,
	IN short	fAbruptTerm
	);
extern
DWORD
R_WinsBackup (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN      LPBYTE			pBackupPath,
	IN	short			fIncremental	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsBackup (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN      LPBYTE			pBackupPath,
	IN	short			fIncremental	
	);
extern
DWORD
R_WinsDelDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDelDbRecs (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
R_WinsPullRange (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	PWINSINTF_ADD_T   	pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsPullRange (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T   	pWinsAdd,
	PWINSINTF_ADD_T   	pOwnAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);

extern
DWORD
R_WinsSetPriorityClass (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN WINSINTF_PRIORITY_CLASS_E 	PrCls_e
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSetPriorityClass (
    DECLARE_WINS_HANDLE( ServerHdl )
	IN WINSINTF_PRIORITY_CLASS_E 	PrCls_e
	);

extern
DWORD
R_WinsResetCounters (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsResetCounters (
    DECLARE_WINS_HANDLE0( ServerHdl )
	);

extern
DWORD
R_WinsWorkerThdUpd (
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD NewNoOfNbtThds
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsWorkerThdUpd (
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD NewNoOfNbtThds
	);
extern
DWORD
WinsRestore (
	LPBYTE BackupPath
	);


extern
DWORD
WinsRestoreEx (
	LPBYTE BackupPath ,
    DbVersion Version
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSyncUp (
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T pWinsAdd,
	PWINSINTF_ADD_T pOwnAdd
	);


extern
DWORD
R_WinsGetNameAndAdd(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetNameAndAdd(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd,
	LPBYTE		pUncName
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetBrowserNames(
    PWINSINTF_BIND_DATA_T       pWinsHdl,
	PWINSINTF_BROWSER_NAMES_T	pNames
	);


extern
VOID
R_WinsGetBrowserNames_notify(
    DECLARE_WINS_HANDLE0( ServerHdl )
);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsGetBrowserNames_Old(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_BROWSER_NAMES_T	pNames
	);

extern
DWORD
R_WinsDeleteWins(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd
	);

extern
DWORD
R_WinsSetFlags(
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD	fFlags
	);

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsSetFlags(
    DECLARE_WINS_HANDLE( ServerHdl )
	DWORD  fFlags	
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsDeleteWins(
    DECLARE_WINS_HANDLE( ServerHdl )
	PWINSINTF_ADD_T	pWinsAdd
	);

extern
void
#if !defined(MIDL_PASS)
__RPC_FAR * __RPC_API
//void  * __RPC_API
//void	*
#endif // MIDL_PASS
midl_user_allocate(size_t cBytes);

extern
//void __RPC_FAR * __RPC_API
void
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS
//void
//midl_user_free(void __RPC_FAR *pMem);
midl_user_free(void *pMem);

extern
VOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsFreeMem(LPVOID pMem);

extern
LPVOID
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsAllocMem(size_t cBytes);

typedef struct _TREE_T  {
#if defined(MIDL_PASS)
		[unique] struct _TREE_T *fPtr;
		[ignore, unique] struct _TREE_T *bPtr;
		[unique, size_is(NameLen)] LPBYTE pName;
#else
		struct _TREE_T *fPtr;
		struct _TREE_T *bPtr;
		LPBYTE pName;
#endif
		unsigned short  NameLen;
		DWORD	x;
	} TREE_T, *PTREE_T;


extern
DWORD
R_WinsTombstoneDbRecs (
    WINSIF2_HANDLE      ServerHdl,
    PWINSINTF_ADD_T	    pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);
extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsTombstoneDbRecs (
    DECLARE_WINS_HANDLE (ServerHdl)
    PWINSINTF_ADD_T	    pWinsAdd,
	WINSINTF_VERS_NO_T	MinVersNo,
	WINSINTF_VERS_NO_T	MaxVersNo
	);

extern
DWORD
R_WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    );

extern
DWORD
#if !defined(MIDL_PASS)
__RPC_API
#endif // MIDL_PASS

WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\winnetp.h ===
#ifndef _WINNETP_
#define _WINNETP_
#ifdef __cplusplus
extern "C" {
#endif
//
// DON'T use 0x00280000 since some people may be
// accidentally trying to use it for RDR2SAMPLE
//
//
// Do NOT add new WNNC_NET_ constants without co-ordinating with PSS
// (HeatherH/ToddC) and jschwart (NT bug #2396)
//
#if(WINVER >= 0x0500)
#define RESOURCE_SHAREABLE      0x00000006
#endif /* WINVER >= 0x0500 */

//
// Structures and infolevels for WNetGetConnection3
//

#define WNGC_INFOLEVEL_DISCONNECTED      1

typedef struct  _WNGC_CONNECTION_STATE {
    DWORD    dwState;
} WNGC_CONNECTION_STATE, *LPWNGC_CONNECTION_STATE;

// Values of the dwState field of WNGC_CONNECTION_STATE
// for info level WNGC_INFOLEVEL_DISCONNECTED
#define WNGC_CONNECTED      0x00000000
#define WNGC_DISCONNECTED   0x00000001


DWORD APIENTRY
WNetGetConnection3A(
     IN LPCSTR lpLocalName,
     IN LPCSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    );
DWORD APIENTRY
WNetGetConnection3W(
     IN LPCWSTR lpLocalName,
     IN LPCWSTR lpProviderName,
     IN DWORD    dwInfoLevel,
     OUT LPVOID   lpBuffer,
     IN OUT LPDWORD  lpcbBuffer
    );
#ifdef UNICODE
#define WNetGetConnection3  WNetGetConnection3W
#else
#define WNetGetConnection3  WNetGetConnection3A
#endif // !UNICODE

//
// WNetRestoreConnectionW is published externally as per the
// consent decree since shlwapi.dll calls it.  The SDK entry
// contains a disclaimer that this API is subject to change.
//


// WNetRestoreConnection2 flags
#define WNRC_NOUI                           0x00000001

DWORD APIENTRY
WNetRestoreConnection2A(
    IN  HWND     hwndParent,
    IN  LPCSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    );
DWORD APIENTRY
WNetRestoreConnection2W(
    IN  HWND     hwndParent,
    IN  LPCWSTR lpDevice,
    IN  DWORD    dwFlags,
    OUT BOOL*    pfReconnectFailed
    );
#ifdef UNICODE
#define WNetRestoreConnection2  WNetRestoreConnection2W
#else
#define WNetRestoreConnection2  WNetRestoreConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetSetConnectionA(
    IN LPCSTR    lpName,
    IN DWORD       dwProperties,
    IN LPVOID      pvValues
    );
DWORD APIENTRY
WNetSetConnectionW(
    IN LPCWSTR    lpName,
    IN DWORD       dwProperties,
    IN LPVOID      pvValues
    );
#ifdef UNICODE
#define WNetSetConnection  WNetSetConnectionW
#else
#define WNetSetConnection  WNetSetConnectionA
#endif // !UNICODE
#if defined(_WIN32_WINDOWS)
DWORD APIENTRY
WNetLogonA(
    IN LPCSTR lpProvider,
    IN HWND hwndOwner
    );
DWORD APIENTRY
WNetLogonW(
    IN LPCWSTR lpProvider,
    IN HWND hwndOwner
    );
#ifdef UNICODE
#define WNetLogon  WNetLogonW
#else
#define WNetLogon  WNetLogonA
#endif // !UNICODE

DWORD APIENTRY
WNetLogoffA(
    IN LPCSTR lpProvider,
    IN HWND hwndOwner
    );
DWORD APIENTRY
WNetLogoffW(
    IN LPCWSTR lpProvider,
    IN HWND hwndOwner
    );
#ifdef UNICODE
#define WNetLogoff  WNetLogoffW
#else
#define WNetLogoff  WNetLogoffA
#endif // !UNICODE

DWORD APIENTRY
WNetVerifyPasswordA(
    IN LPCSTR  lpszPassword,
    OUT BOOL FAR *pfMatch
    );
DWORD APIENTRY
WNetVerifyPasswordW(
    IN LPCWSTR  lpszPassword,
    OUT BOOL FAR *pfMatch
    );
#ifdef UNICODE
#define WNetVerifyPassword  WNetVerifyPasswordW
#else
#define WNetVerifyPassword  WNetVerifyPasswordA
#endif // !UNICODE

#endif  // _WIN32_WINDOWS

DWORD APIENTRY
WNetGetHomeDirectoryA(
    IN LPCSTR  lpProviderName,
    OUT LPSTR   lpDirectory,
    IN OUT LPDWORD   lpBufferSize
    );
DWORD APIENTRY
WNetGetHomeDirectoryW(
    IN LPCWSTR  lpProviderName,
    OUT LPWSTR   lpDirectory,
    IN OUT LPDWORD   lpBufferSize
    );
#ifdef UNICODE
#define WNetGetHomeDirectory  WNetGetHomeDirectoryW
#else
#define WNetGetHomeDirectory  WNetGetHomeDirectoryA
#endif // !UNICODE
DWORD APIENTRY
WNetFormatNetworkNameA(
    IN LPCSTR  lpProvider,
    IN LPCSTR  lpRemoteName,
    OUT LPSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    );
DWORD APIENTRY
WNetFormatNetworkNameW(
    IN LPCWSTR  lpProvider,
    IN LPCWSTR  lpRemoteName,
    OUT LPWSTR   lpFormattedName,
    IN OUT LPDWORD   lpnLength,
    IN DWORD     dwFlags,
    IN DWORD     dwAveCharPerLine
    );
#ifdef UNICODE
#define WNetFormatNetworkName  WNetFormatNetworkNameW
#else
#define WNetFormatNetworkName  WNetFormatNetworkNameA
#endif // !UNICODE

DWORD APIENTRY
WNetGetProviderTypeA(
    IN  LPCSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    );
DWORD APIENTRY
WNetGetProviderTypeW(
    IN  LPCWSTR          lpProvider,
    OUT LPDWORD           lpdwNetType
    );
#ifdef UNICODE
#define WNetGetProviderType  WNetGetProviderTypeW
#else
#define WNetGetProviderType  WNetGetProviderTypeA
#endif // !UNICODE
DWORD APIENTRY
WNetInitialize(
    void
    );


DWORD APIENTRY
MultinetGetErrorTextA(
    OUT LPSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    );
DWORD APIENTRY
MultinetGetErrorTextW(
    OUT LPWSTR lpErrorTextBuf,
    IN OUT LPDWORD lpnErrorBufSize,
    OUT LPWSTR lpProviderNameBuf,
    IN OUT LPDWORD lpnNameBufSize
    );
#ifdef UNICODE
#define MultinetGetErrorText  MultinetGetErrorTextW
#else
#define MultinetGetErrorText  MultinetGetErrorTextA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif
#endif  // _WINNETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\winipsec.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    winipsec.h

Abstract:

    Header file for IPSec WINAPIs.

Author:

    krishnaG    21-September-1999
    abhisheV    21-September-1999    Added all the structures.

Environment:

    User Level: Win32

Revision History:


--*/


#ifndef _WINIPSEC_
#define _WINIPSEC_


#ifdef __cplusplus
extern "C" {
#endif

#ifdef __midl
#define  MIDL_DEFINE_INT(_C, _V) const unsigned short int _C = _V
#else
#define  MIDL_DEFINE_INT(_C, _V)
#endif

#define PERSIST_SPD_OBJECT      (ULONG) 0x00000001
#define IPSEC_STORE_PERSISTENT      0x1
#define IPSEC_STORE_LOCAL           0x2

// Flags sent to ike during shutdown
//

// Service is being shutdown, but not machine
#define SPD_SHUTDOWN_SERVICE 0X1

// Service is being shutdown as well as machine
#define SPD_SHUTDOWN_MACHINE 0X2

// Flag for AddMMFilter, to open if duplicate filter found.
//

#define     OPEN_IF_EXISTS          (ULONG) 0x00000002

//
//  Flags that specify where policy is from.

#define IPSEC_STORE_PERSISTENT      0x1
#define IPSEC_STORE_LOCAL           0x2

// Address specification special values

#define     IP_ADDRESS_ME           (ULONG) 0x00000000
#define     IP_ADDRESS_MASK_NONE    (ULONG) 0xFFFFFFFF
#define     SUBNET_ADDRESS_ANY      (ULONG) 0x00000000
#define     SUBNET_MASK_ANY         (ULONG) 0x00000000


#define     FILTER_NATURE_PASS_THRU         0x00000001
#define     FILTER_NATURE_BLOCKING          0x00000002
#define     FILTER_DIRECTION_INBOUND        0x00000004
#define     FILTER_DIRECTION_OUTBOUND       0x00000008


#define     ENUM_GENERIC_FILTERS            0x00000001
#define     ENUM_SELECT_SPECIFIC_FILTERS    0x00000002
#define     ENUM_SPECIFIC_FILTERS           0x00000004

//
// Policy flags.
//

#define IPSEC_MM_POLICY_ENABLE_DIAGNOSTICS  0x00000001
#define IPSEC_MM_POLICY_DEFAULT_POLICY      0x00000002
#define IPSEC_MM_POLICY_ON_NO_MATCH         0x00000004
#define IPSEC_MM_POLICY_DISABLE_CRL         0x00000008
#define IPSEC_MM_POLICY_DISABLE_NEGOTIATE   0x00000010
#define IPSEC_MM_POLICY_ENABLE_CERT_MAPPING 0x00000020
#define IPSEC_MM_POLICY_STORE_CERT_CHAINS   0x00000040

#define IPSEC_QM_POLICY_TRANSPORT_MODE      0x00000000
#define IPSEC_QM_POLICY_TUNNEL_MODE         0x00000001
#define IPSEC_QM_POLICY_DEFAULT_POLICY      0x00000002
#define IPSEC_QM_POLICY_ALLOW_SOFT          0x00000004
#define IPSEC_QM_POLICY_ON_NO_MATCH         0x00000008
#define IPSEC_QM_POLICY_DISABLE_NEGOTIATE   0x00000010
#define IPSEC_QM_POLICY_DISALLOW_NAT        0x00000020

#define IPSEC_MM_AUTH_DEFAULT_AUTH          0x00000001
#define IPSEC_MM_AUTH_ON_NO_MATCH           0x00000002


#define IPSEC_MM_CERT_AUTH_ENABLE_ACCOUNT_MAP  0x00000001

#define IPSEC_MM_CERT_AUTH_DISABLE_CERT_REQUEST  0x00000002



//
// MatchXXX
//

#define RETURN_DEFAULTS_ON_NO_MATCH         0x00000001
#define RETURN_NON_AH_OFFERS                0x00000002

//
// Delete MM SA flags.
//

#define IPSEC_MM_DELETE_ASSOCIATED_QMS      0x00000001


#define IPSEC_SA_TUNNEL                    0x00000001
#define IPSEC_SA_MULTICAST_MIRROR          0x00000002
#define IPSEC_SA_DISABLE_IDLE_OUT          0x00000004
#define IPSEC_SA_DISABLE_ANTI_REPLAY_CHECK 0x00000008
#define IPSEC_SA_DISABLE_LIFETIME_CHECK    0x00000010
#define IPSEC_SA_ENABLE_NLBS_IDLE_CHECK    0x00000020

typedef enum _IPSEC_SA_DIRECTION {
    SA_DIRECTION_BOTH = 1,
    SA_DIRECTION_INBOUND,
    SA_DIRECTION_OUTBOUND,
    SA_DIRECTION_MAX
} IPSEC_SA_DIRECTION, *PIPSEC_SA_DIRECTION;


typedef enum _IPSEC_SA_UDP_ENCAP_TYPE {
    SA_UDP_ENCAP_TYPE_NONE = 1,
    SA_UDP_ENCAP_TYPE_IKE,
    SA_UDP_ENCAP_TYPE_OTHER,
    SA_UDP_ENCAP_TYPE_MAX
} IPSEC_SA_UDP_ENCAP_TYPE, *PIPSEC_SA_UDP_ENCAP_TYPE;
    


//
// Bounds for number of offers.
//

#define IPSEC_MAX_MM_OFFERS	20
#define IPSEC_MAX_QM_OFFERS	50


typedef enum _IP_PROTOCOL_VERSION {
    IPSEC_PROTOCOL_V4 = 0,
    IPSEC_PROTOCOL_V6,
} IP_PROTOCOL_VERSION, * PIP_PROTOCOL_VERSION;


typedef enum _ADDR_TYPE {
    IP_ADDR_UNIQUE = 1,
    IP_ADDR_SUBNET,
    IP_ADDR_INTERFACE,
    IP_ADDR_DNS_SERVER,
    IP_ADDR_WINS_SERVER,
    IP_ADDR_DHCP_SERVER,
    IP_ADDR_DEFAULT_GATEWAY
} ADDR_TYPE, * PADDR_TYPE;


typedef struct _ADDR {
    ADDR_TYPE AddrType;
#ifdef __midl
    UCHAR ucIpAddr[4];
    UCHAR ucSubNetMask[4];
#else
    ULONG uIpAddr;
    ULONG uSubNetMask;
#endif
    GUID * pgInterfaceID;
} ADDR, * PADDR, IPV4ADDR, * PIPV4ADDR;


typedef struct _IPV6ADDR {
    ADDR_TYPE AddrType;
    UCHAR ucIpAddr[16];
    UCHAR ucSubNetMask;
    GUID * pgInterfaceID;
} IPV6ADDR, * PIPV6ADDR;


typedef enum _PROTOCOL_TYPE {
    PROTOCOL_UNIQUE = 1,
} PROTOCOL_TYPE, * PPROTOCOL_TYPE;


typedef struct _PROTOCOL {
    PROTOCOL_TYPE ProtocolType;
    DWORD dwProtocol;
} PROTOCOL, * PPROTOCOL;


typedef enum _PORT_TYPE {
    PORT_UNIQUE = 1,
} PORT_TYPE, * PPORT_TYPE;


typedef struct _PORT {
    PORT_TYPE PortType;
    WORD wPort;
} PORT, * PPORT;


typedef enum _IF_TYPE {
    INTERFACE_TYPE_ALL = 1,
    INTERFACE_TYPE_LAN,
    INTERFACE_TYPE_DIALUP,
    INTERFACE_TYPE_MAX
} IF_TYPE, * PIF_TYPE;


typedef enum _FILTER_ACTION {
    PASS_THRU = 1,
    BLOCKING,
    NEGOTIATE_SECURITY,
    FILTER_ACTION_MAX
} FILTER_ACTION, * PFILTER_ACTION;


typedef struct _TRANSPORT_FILTER {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR SrcAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR SrcV6Addr;
        [default] ;
    };
#else
    union {
        ADDR SrcAddr;
        IPV6ADDR SrcV6Addr;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR DesAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR DesV6Addr;
        [default] ;
    };
#else
    union {
        ADDR DesAddr;
        IPV6ADDR DesV6Addr;
    };
#endif
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_ACTION InboundFilterAction;
    FILTER_ACTION OutboundFilterAction;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TRANSPORT_FILTER, * PTRANSPORT_FILTER;


//
// Maximum number of transport filters that can be enumerated
// by SPD at a time.
//

#define MAX_TRANSPORTFILTER_ENUM_COUNT 1000
MIDL_DEFINE_INT(MIDL_MAX_TRANSPORTFILTER_COUNT, MAX_TRANSPORTFILTER_ENUM_COUNT);

typedef struct _TUNNEL_FILTER {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR SrcAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR SrcV6Addr;
        [default] ;
    };
#else
    union {
        ADDR SrcAddr;
        IPV6ADDR SrcV6Addr;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR DesAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR DesV6Addr;
        [default] ;
    };
#else
    union {
        ADDR DesAddr;
        IPV6ADDR DesV6Addr;
    };
#endif
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR SrcTunnelAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR SrcV6TunnelAddr;
        [default] ;
    };
#else
    union {
        ADDR SrcTunnelAddr;
        IPV6ADDR SrcV6TunnelAddr;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR DesTunnelAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR DesV6TunnelAddr;
        [default] ;
    };
#else
    union {
        ADDR DesTunnelAddr;
        IPV6ADDR DesV6TunnelAddr;
    };
#endif
    FILTER_ACTION InboundFilterAction;
    FILTER_ACTION OutboundFilterAction;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TUNNEL_FILTER, * PTUNNEL_FILTER;


//
// Maximum number of tunnel filters that can be enumerated
// by SPD at a time.
//

#define MAX_TUNNELFILTER_ENUM_COUNT 1000
MIDL_DEFINE_INT(MIDL_MAX_TUNNELFILTER_COUNT, MAX_TUNNELFILTER_ENUM_COUNT);

typedef struct _MM_FILTER {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR SrcAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR SrcV6Addr;
        [default] ;
    };
#else
    union {
        ADDR SrcAddr;
        IPV6ADDR SrcV6Addr;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR DesAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR DesV6Addr;
        [default] ;
    };
#else
    union {
        ADDR DesAddr;
        IPV6ADDR DesV6Addr;
    };
#endif
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gMMAuthID;
    GUID gPolicyID;
} MM_FILTER, * PMM_FILTER;


//
// Maximum number of main mode filters that can be enumerated
// by SPD at a time.
//

#define MAX_MMFILTER_ENUM_COUNT  1000
MIDL_DEFINE_INT(MIDL_MAX_MMFILTER_COUNT, MAX_MMFILTER_ENUM_COUNT);

//
//  Common Structures for Main Mode and Quick Mode Policies.
//


//
// IPSEC confidentiality algorithms supported by SPD.
//

typedef enum _CONF_ALGO_ENUM {
    CONF_ALGO_NONE = 0,
    CONF_ALGO_DES,
    CONF_ALGO_3_DES = 3,
    CONF_ALGO_MAX
} CONF_ALGO_ENUM, * PCONF_ALGO_ENUM;


//
// IPSEC integrity algorithms supported by SPD.
//

typedef enum _AUTH_ALGO_ENUM {
    AUTH_ALGO_NONE = 0,
    AUTH_ALGO_MD5,
    AUTH_ALGO_SHA1,
    AUTH_ALGO_MAX
} AUTH_ALGO_ENUM, * PAUTH_ALGO_ENUM;


//
// Types of IPSEC Operations supported by SPD.
//

typedef enum _IPSEC_OPERATION {
    NONE = 0,
    AUTHENTICATION,
    ENCRYPTION,
    COMPRESSION,
    SA_DELETE
} IPSEC_OPERATION, * PIPSEC_OPERATION;


//
// HMAC authentication algorithms to use with IPSEC
// Encryption operation.
//

typedef enum _HMAC_AUTH_ALGO_ENUM {
    HMAC_AUTH_ALGO_NONE = 0,
    HMAC_AUTH_ALGO_MD5,
    HMAC_AUTH_ALGO_SHA1,
    HMAC_AUTH_ALGO_MAX
} HMAC_AUTH_ALGO_ENUM, * PHMAC_AUTH_ALGO_ENUM;


//
// Key Lifetime structure.
//

typedef struct  _KEY_LIFETIME {
    ULONG uKeyExpirationTime;
    ULONG uKeyExpirationKBytes;
} KEY_LIFETIME, * PKEY_LIFETIME;


//
// Main mode policy structures.
//


//
// Main mode authentication algorithms supported by SPD.
//

typedef enum _MM_AUTH_ENUM {
    IKE_PRESHARED_KEY = 1,
    IKE_DSS_SIGNATURE,
    IKE_RSA_SIGNATURE,
    IKE_RSA_ENCRYPTION,
    IKE_SSPI
} MM_AUTH_ENUM, * PMM_AUTH_ENUM;


//
// Main mode authentication information structure.
//

typedef struct _CERT_ROOT_CONFIG {
    DWORD dwCertDataSize;
#ifdef __midl
    [size_is(dwCertDataSize)] LPBYTE pCertData;
#else
    LPBYTE pCertData;
#endif
    DWORD dwAuthorizationDataSize;
#ifdef __midl
    [size_is(dwAuthorizationDataSize)] LPBYTE pAuthorizationData;
#else
    LPBYTE pAuthorizationData;
#endif
    DWORD dwFlags;
} CERT_ROOT_CONFIG, * PCERT_ROOT_CONFIG;


typedef struct __MM_CERT_INFO {
    DWORD dwVersion;
    DWORD dwMyCertHashSize;
#ifdef __midl
    [size_is(dwMyCertHashSize)] LPBYTE pMyCertHash;
#else
    LPBYTE pMyCertHash;
#endif
    DWORD dwInboundRootArraySize;
#ifdef __midl
    [size_is(dwInboundRootArraySize)] PCERT_ROOT_CONFIG pInboundRootArray;
#else
    PCERT_ROOT_CONFIG pInboundRootArray;
#endif
    DWORD dwOutboundRootArraySize;
#ifdef __midl
    [size_is(dwOutboundRootArraySize)] PCERT_ROOT_CONFIG pOutboundRootArray;
#else
    PCERT_ROOT_CONFIG pOutboundRootArray;
#endif
} MM_CERT_INFO, * PMM_CERT_INFO;


typedef struct __MM_GENERAL_AUTH_INFO {
    DWORD dwAuthInfoSize;
#ifdef __midl
    [size_is(dwAuthInfoSize)] LPBYTE pAuthInfo;
#else
    LPBYTE pAuthInfo;
#endif
} MM_GENERAL_AUTH_INFO, * PMM_GENERAL_AUTH_INFO;


typedef struct _IPSEC_MM_AUTH_INFO {
    MM_AUTH_ENUM AuthMethod;
#ifdef __midl
    [switch_type(MM_AUTH_ENUM), switch_is(AuthMethod)] union {
        [case(IKE_PRESHARED_KEY,
              IKE_DSS_SIGNATURE,
              IKE_RSA_ENCRYPTION,
              IKE_SSPI)] MM_GENERAL_AUTH_INFO GeneralAuthInfo;
        [case(IKE_RSA_SIGNATURE)] MM_CERT_INFO CertAuthInfo;
        [default] ;
    };
#else
    union {
        MM_GENERAL_AUTH_INFO GeneralAuthInfo;
        MM_CERT_INFO CertAuthInfo;
    };
#endif
} IPSEC_MM_AUTH_INFO, * PIPSEC_MM_AUTH_INFO;


//
// Main mode authentication methods.
//

typedef struct _MM_AUTH_METHODS {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD dwNumAuthInfos;
#ifdef __midl
    [size_is(dwNumAuthInfos)] PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#else
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#endif
} MM_AUTH_METHODS, * PMM_AUTH_METHODS;


//
// Maximum number of main mode auth methods that can be enumerated
// by SPD at a time.
//

#define MAX_MMAUTH_ENUM_COUNT 1000
MIDL_DEFINE_INT(MIDL_MAX_MMAUTH_COUNT, MAX_MMAUTH_ENUM_COUNT);


//
// Main mode algorithm structure.
//

typedef struct _IPSEC_MM_ALGO {
    ULONG uAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uAlgoRounds;
} IPSEC_MM_ALGO, * PIPSEC_MM_ALGO;


//
// Main mode policy offer structure.
//

typedef struct _IPSEC_MM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    DWORD dwQuickModeLimit;
    DWORD dwDHGroup;
    IPSEC_MM_ALGO EncryptionAlgorithm;
    IPSEC_MM_ALGO HashingAlgorithm;
} IPSEC_MM_OFFER, * PIPSEC_MM_OFFER;


//
// Defines for DH groups.
//

#define DH_GROUP_1    0x00000001   // For Diffe Hellman group 1.
#define DH_GROUP_2    0x00000002   // For Diffe Hellman group 2.
#define DH_GROUP_2048 0x10000001


//
// Default Main Mode key expiration time.
//

#define DEFAULT_MM_KEY_EXPIRATION_TIME 480*60 // 8 hours expressed in seconds.


//
// Maximum number of main mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_MMPOLICY_ENUM_COUNT 10
MIDL_DEFINE_INT(MIDL_MAX_MMPOLICY_COUNT, MAX_MMPOLICY_ENUM_COUNT);

//
// Main mode policy structure.
//

typedef struct  _IPSEC_MM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    ULONG uSoftExpirationTime;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_MM_OFFER pOffers;
#else
    PIPSEC_MM_OFFER pOffers;
#endif
} IPSEC_MM_POLICY, * PIPSEC_MM_POLICY;


//
// Quick mode policy structures.
//


typedef DWORD IPSEC_QM_SPI, * PIPSEC_QM_SPI;


//
// Quick mode algorithm structure.
//

typedef struct  _IPSEC_QM_ALGO {
    IPSEC_OPERATION Operation;
    ULONG uAlgoIdentifier;
    HMAC_AUTH_ALGO_ENUM uSecAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uSecAlgoKeyLen;
    ULONG uAlgoRounds;
    ULONG uSecAlgoRounds;
    IPSEC_QM_SPI MySpi;
    IPSEC_QM_SPI PeerSpi;
} IPSEC_QM_ALGO, * PIPSEC_QM_ALGO;


//
// Maximum number of quick mode algorithms in
// a quick mode policy offer.
//

#define QM_MAX_ALGOS    2


//
// Quick mode policy offer structure.
//

typedef struct _IPSEC_QM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    BOOL bPFSRequired;
    DWORD dwPFSGroup;
    DWORD dwNumAlgos;
    IPSEC_QM_ALGO Algos[QM_MAX_ALGOS];
    DWORD dwReserved;
} IPSEC_QM_OFFER, * PIPSEC_QM_OFFER;


//
// Defines for PFS groups.
//

#define PFS_GROUP_NONE 0x00000000   // If PFS is not required.
#define PFS_GROUP_1    DH_GROUP_1   // For Diffe Hellman group 1 PFS.
#define PFS_GROUP_2    DH_GROUP_2   // For Diffe Hellman group 2 PFS.
#define PFS_GROUP_2048 DH_GROUP_2048  
#define PFS_GROUP_MM   0x80000000   // Use group negotiated in MM


//
// Default Quick Mode key expiration time.
//

#define DEFAULT_QM_KEY_EXPIRATION_TIME 60*60 // 1 hour expressed in seconds.


//
// Default Quick Mode key expiration kbytes.
//

#define DEFAULT_QM_KEY_EXPIRATION_KBYTES 100*1000 // 100 MB expressed in KB.


//
// Maximum number of quick mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_QMPOLICY_ENUM_COUNT 100
MIDL_DEFINE_INT(MIDL_MAX_QMPOLICY_COUNT, MAX_QMPOLICY_ENUM_COUNT);


//
// Quick mode policy structure.
//

typedef struct _IPSEC_QM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    DWORD dwReserved;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_QM_OFFER pOffers;
#else
    PIPSEC_QM_OFFER pOffers;
#endif
} IPSEC_QM_POLICY, * PIPSEC_QM_POLICY;


//
// IKE structures.
//

typedef struct _IKE_STATISTICS {
    DWORD dwActiveAcquire;
    DWORD dwActiveReceive;
    DWORD dwAcquireFail;
    DWORD dwReceiveFail;
    DWORD dwSendFail;
    DWORD dwAcquireHeapSize;
    DWORD dwReceiveHeapSize;
    DWORD dwNegotiationFailures;
    DWORD dwAuthenticationFailures;
    DWORD dwInvalidCookiesReceived;
    DWORD dwTotalAcquire;
    DWORD dwTotalGetSpi;
    DWORD dwTotalKeyAdd;
    DWORD dwTotalKeyUpdate;
    DWORD dwGetSpiFail;
    DWORD dwKeyAddFail;
    DWORD dwKeyUpdateFail;
    DWORD dwIsadbListSize;
    DWORD dwConnListSize;
    DWORD dwOakleyMainModes;
    DWORD dwOakleyQuickModes;
    DWORD dwSoftAssociations;
    DWORD dwInvalidPacketsReceived;
} IKE_STATISTICS, * PIKE_STATISTICS;


typedef LARGE_INTEGER IKE_COOKIE, * PIKE_COOKIE;


typedef struct _IKE_COOKIE_PAIR {
    IKE_COOKIE Initiator;
    IKE_COOKIE Responder;
} IKE_COOKIE_PAIR, * PIKE_COOKIE_PAIR;


typedef struct _IPSEC_BYTE_BLOB {
    DWORD dwSize;
#ifdef __midl
    [size_is(dwSize)] LPBYTE pBlob;
#else
    LPBYTE pBlob;
#endif
} IPSEC_BYTE_BLOB, * PIPSEC_BYTE_BLOB;


typedef struct _IPSEC_UDP_ENCAP_CONTEXT {
    WORD wSrcEncapPort;
    WORD wDesEncapPort;
} IPSEC_UDP_ENCAP_CONTEXT, * PIPSEC_UDP_ENCAP_CONTEXT;

//
// Maximum number of main mode SAs that can be enumerated
// by SPD at a time.
//

#define MAX_MMSA_ENUM_COUNT 1000
MIDL_DEFINE_INT(MIDL_MAX_MMSA_COUNT, MAX_MMSA_ENUM_COUNT);


typedef struct _IPSEC_MM_SA {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gMMPolicyID;
    IPSEC_MM_OFFER SelectedMMOffer;
    MM_AUTH_ENUM MMAuthEnum;
    IKE_COOKIE_PAIR MMSpi;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR Me;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR MyV6Addr;
        [default] ;
    };
#else
    union {
        ADDR Me;
        IPV6ADDR MyV6Addr;
    };
#endif
    IPSEC_BYTE_BLOB MyId;
    IPSEC_BYTE_BLOB MyCertificateChain;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR Peer;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR PeerV6Addr;
        [default] ;
    };
#else
    union {
        ADDR Peer;
        IPV6ADDR PeerV6Addr;
    };
#endif
    IPSEC_BYTE_BLOB PeerId;
    IPSEC_BYTE_BLOB PeerCertificateChain;
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext;
    DWORD dwFlags;
} IPSEC_MM_SA, * PIPSEC_MM_SA;


typedef enum _QM_FILTER_TYPE {
      QM_TRANSPORT_FILTER = 1,
      QM_TUNNEL_FILTER
} QM_FILTER_TYPE, * PQM_FILTER_TYPE;


typedef struct _IPSEC_QM_FILTER {
    IP_PROTOCOL_VERSION IpVersion;
    QM_FILTER_TYPE QMFilterType;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR SrcAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR SrcV6Addr;
        [default] ;
    };
#else
    union {
        ADDR SrcAddr;
        IPV6ADDR SrcV6Addr;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR DesAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR DesV6Addr;
        [default] ;
    };
#else
    union {
        ADDR DesAddr;
        IPV6ADDR DesV6Addr;
    };
#endif
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR MyTunnelEndpt;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR MyV6TunnelEndpt;
        [default] ;
    };
#else
    union {
        ADDR MyTunnelEndpt;
        IPV6ADDR MyV6TunnelEndpt;
    };
#endif
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR PeerTunnelEndpt;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR PeerV6TunnelEndpt;
        [default] ;
    };
#else
    union {
        ADDR PeerTunnelEndpt;
        IPV6ADDR PeerV6TunnelEndpt;
    };
#endif
    DWORD dwFlags;
} IPSEC_QM_FILTER, * PIPSEC_QM_FILTER;

//
// Maximum number of quick mode filters allowed in an RPC container
//

MIDL_DEFINE_INT(MIDL_MAX_QMFILTER_COUNT, MAX_TRANSPORTFILTER_ENUM_COUNT);

typedef struct _UDP_ENCAP_INFO {
    IPSEC_SA_UDP_ENCAP_TYPE SAEncapType;
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext;
    IP_PROTOCOL_VERSION PeerAddrVersion;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(PeerAddrVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] ADDR PeerPrivateAddr;
        [case(IPSEC_PROTOCOL_V6)] IPV6ADDR PeerPrivateAddrV6;
        [default] ;
    };
#else
    union {
        ADDR PeerPrivateAddr;
        IPV6ADDR PeerPrivateAddrV6;
    };
#endif
} UDP_ENCAP_INFO, *PUDP_ENCAP_INFO;

typedef struct _IPSEC_QM_SA {
    GUID gQMPolicyID;
    IPSEC_QM_OFFER SelectedQMOffer;
    GUID gQMFilterID;
    IPSEC_QM_FILTER IpsecQMFilter;
    IKE_COOKIE_PAIR MMSpi;
    UDP_ENCAP_INFO EncapInfo;
} IPSEC_QM_SA, * PIPSEC_QM_SA;

#define MAX_QMSA_ENUM_COUNT 500
MIDL_DEFINE_INT(MIDL_MAX_QMSA_COUNT, MAX_QMSA_ENUM_COUNT);


typedef enum _SA_FAIL_MODE {
    MAIN_MODE = 1,
    QUICK_MODE,
} SA_FAIL_MODE, * PSA_FAIL_MODE;


typedef enum _SA_FAIL_POINT {
    FAIL_POINT_ME = 1,
    FAIL_POINT_PEER,
} SA_FAIL_POINT, * PSA_FAIL_POINT;


typedef struct _SA_NEGOTIATION_STATUS_INFO {
    SA_FAIL_MODE FailMode;
    SA_FAIL_POINT FailPoint;
    DWORD dwError;
} SA_NEGOTIATION_STATUS_INFO, * PSA_NEGOTIATION_STATUS_INFO;


//
// IPSec structures.
//

typedef struct _IPSEC_STATISTICS {
    DWORD dwNumActiveAssociations;
    DWORD dwNumOffloadedSAs;
    DWORD dwNumPendingKeyOps;
    DWORD dwNumKeyAdditions;
    DWORD dwNumKeyDeletions;
    DWORD dwNumReKeys;
    DWORD dwNumActiveTunnels;
    DWORD dwNumBadSPIPackets;
    DWORD dwNumPacketsNotDecrypted;
    DWORD dwNumPacketsNotAuthenticated;
    DWORD dwNumPacketsWithReplayDetection;
    ULARGE_INTEGER uConfidentialBytesSent;
    ULARGE_INTEGER uConfidentialBytesReceived;
    ULARGE_INTEGER uAuthenticatedBytesSent;
    ULARGE_INTEGER uAuthenticatedBytesReceived;
    ULARGE_INTEGER uTransportBytesSent;
    ULARGE_INTEGER uTransportBytesReceived;
    ULARGE_INTEGER uBytesSentInTunnels;
    ULARGE_INTEGER uBytesReceivedInTunnels;
    ULARGE_INTEGER uOffloadedBytesSent;
    ULARGE_INTEGER uOffloadedBytesReceived;
} IPSEC_STATISTICS, * PIPSEC_STATISTICS;


typedef struct _IPSEC_INTERFACE_INFO {

    GUID gInterfaceID;
    DWORD dwIndex;
    LPWSTR pszInterfaceName;
    LPWSTR pszDeviceName;
    DWORD dwInterfaceType;
    IP_PROTOCOL_VERSION IpVersion;
#ifdef __midl
    [switch_type(IP_PROTOCOL_VERSION), switch_is(IpVersion)] union {
        [case(IPSEC_PROTOCOL_V4)] UCHAR ucIpAddr[4];
        [case(IPSEC_PROTOCOL_V6)] UCHAR ucIpv6Addr[16];
        [default] ;
    };
#else
    union {
        ULONG uIpAddr;
        UCHAR ucIpv6Addr[16];
    };
#endif
} IPSEC_INTERFACE_INFO, * PIPSEC_INTERFACE_INFO;

// 
// Constants to track the source of policy
//
#define IPSEC_SOURCE_PERSISTENT     0x1
#define IPSEC_SOURCE_LOCAL          0x2
#define IPSEC_SOURCE_DOMAIN         0x3
#define IPSEC_SOURCE_CACHE          0x4
#define IPSEC_SOURCE_WINIPSEC       0x5

typedef enum _SPD_STATE {
    SPD_STATE_INITIAL,
    SPD_STATE_DS_LOAD_SUCCESS,
    SPD_STATE_DS_LOAD_FAIL,
    SPD_STATE_DS_APPLY_SUCCESS,
    SPD_STATE_DS_APPLY_FAIL,
    SPD_STATE_CACHE_LOAD_SUCCESS,
    SPD_STATE_CACHE_LOAD_FAIL,
    SPD_STATE_CACHE_APPLY_SUCCESS,
    SPD_STATE_CACHE_APPLY_FAIL,
    SPD_STATE_LOCAL_LOAD_SUCCESS,
    SPD_STATE_LOCAL_LOAD_FAIL,
    SPD_STATE_LOCAL_APPLY_SUCCESS,
    SPD_STATE_LOCAL_APPLY_FAIL,
    SPD_STATE_PERSISTENT_LOAD_SUCCESS,
    SPD_STATE_PERSISTENT_LOAD_FAIL,
    SPD_STATE_PERSISTENT_APPLY_SUCCESS,
    SPD_STATE_PERSISTENT_APPLY_FAIL,
} SPD_STATE, * PSPD_STATE;

typedef enum _SPD_ACTION {
    SPD_POLICY_APPLY,
    SPD_POLICY_LOAD
} SPD_ACTION, * PSPD_ACTION;

typedef struct _SPD_POLICY_STATE {
    SPD_STATE PolicyLoadState;
    DWORD dwWhenChanged;
} SPD_POLICY_STATE, * PSPD_POLICY_STATE;

#define FLAGS_NLBS_UNBOUND 0x00000000
#define FLAGS_NLBS_BOUND   0x00000001
#define FLAGS_NLBS_MAX     0x00000002

typedef struct _IKE_CONFIG {

    DWORD dwDebug;
    DWORD dwEnableLogging;
    DWORD dwStrongCRLCheck;
    DWORD dwMaxRespOpenMM;
    DWORD dwNLBSFlags;
    DWORD dwFlags;
    DWORD dwEnableDOSProtect;
    DWORD dw2048DHGroupId;
} IKE_CONFIG, * PIKE_CONFIG;


//
// If dwInterfaceType is MIB_IF_TYPE_ETHERNET or MIB_IF_TYPE_FDDI
// or MIB_IF_TYPE_TOKENRING then its a LAN interface.
// If dwInterfaceType is MIB_IF_TYPE_PPP or MIB_IF_TYPE_SLIP
// then its a WAN/DIALUP interface.
//

#define MAX_INTERFACE_ENUM_COUNT 100
MIDL_DEFINE_INT(MIDL_MAX_INTERFACE_COUNT, MAX_INTERFACE_ENUM_COUNT);


//
// IPSEC SPD APIs.
//


DWORD
WINAPI
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    );


VOID
WINAPI
SPDApiBufferFree(
    LPVOID pBuffer
    );


DWORD
WINAPI
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTransportFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTransportFilters,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetTransportFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetTransportFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER * ppTransportFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
DeleteQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumQMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_POLICY pQMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_POLICY * ppQMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
DeleteMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumMMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_POLICY pMMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_POLICY * ppMMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    );


DWORD
WINAPI
DeleteMMFilter(
    HANDLE hMMFilter
    );


DWORD
WINAPI
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER * ppMMFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
MatchMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
MatchTransportFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetQMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gQMPolicyID,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetMMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    );


DWORD
WINAPI
DeleteMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_AUTH_METHODS pMMTemplateAuthMethods,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    LPVOID pvReserved
    );


DWORD
WINAPI
InitiateIKENegotiation(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_FILTER pQMFilter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    LPVOID pvReserved,
    PHANDLE phNegotiation
    );


DWORD
WINAPI
QueryIKENegotiationStatus(
    HANDLE hNegotiation,
    DWORD dwVersion,
    PSA_NEGOTIATION_STATUS_INFO pNegotiationStatus,
    LPVOID pvReserved
    );


DWORD
WINAPI
CloseIKENegotiationHandle(
    HANDLE hNegotiation
    );


DWORD
WINAPI
EnumMMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_SA * ppMMSAs,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
DeleteMMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags,
    LPVOID pvReserved
    );


DWORD
WINAPI
DeleteQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags,
    LPVOID pvReserved
    );


DWORD
WINAPI
QueryIKEStatistics(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIKE_STATISTICS pIKEStatistics,
    LPVOID pvReserved
    );


DWORD
WINAPI
RegisterIKENotifyClient(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    IPSEC_QM_SA QMTemplate,
    DWORD dwFlags,
    LPVOID pvReserved,
    PHANDLE phNotifyHandle
    );


DWORD
WINAPI
QueryIKENotifyData(
    HANDLE hNotifyHandle,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_SA * ppQMSAs,
    PDWORD pdwNumEntries,
    LPVOID pvReserved
    );


DWORD
WINAPI
CloseIKENotifyHandle(
    HANDLE hNotifyHandle
    );


DWORD
WINAPI
QueryIPSecStatistics(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_STATISTICS * ppIpsecStatistics,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pQMSATemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_SA * ppQMSAs,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTunnelFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTunnelFilters,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetTunnelFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
GetTunnelFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER * ppTunnelFilter,
    LPVOID pvReserved
    );


DWORD
WINAPI
MatchTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
OpenMMFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    );


DWORD
WINAPI
CloseMMFilterHandle(
    HANDLE hMMFilter
    );


DWORD
WINAPI
OpenTransportFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved,
    PHANDLE phTxFilter
    );


DWORD
WINAPI
CloseTransportFilterHandle(
    HANDLE hTxFilter
    );


DWORD
WINAPI
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    );


DWORD
WINAPI
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    );


DWORD
WINAPI
EnumIPSecInterfaces(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );


DWORD
WINAPI
AddSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE * phLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE * pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE * pOutboundKeyMat,
    BYTE * pContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    LPVOID pvReserved,
    DWORD dwFlags
    );

DWORD
WINAPI
QuerySpdPolicyState(
    LPWSTR pServerName,
    DWORD dwVersion,
    PSPD_POLICY_STATE * ppSpdPolicyState,
    LPVOID pvReserved
    );


DWORD
WINAPI
SetConfigurationVariables(
    LPWSTR pServerName,
    IKE_CONFIG IKEConfig
    );


DWORD
WINAPI
GetConfigurationVariables(
    LPWSTR pServerName,
    PIKE_CONFIG pIKEConfig
    );


#ifdef __cplusplus
}
#endif


#endif // _WINIPSEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\wzcdlg.h ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzcdlg.h

Abstract:

    Header file for wzcdlg

Author:

    Deonb   21-March-2001

Environment:

    User Level: Win32

Revision History:

--*/

# ifdef     __cplusplus
extern "C" {
# endif

BOOL
WZCDlgMain (
        IN HINSTANCE hInstance,
        IN DWORD    dwReason,
        IN LPVOID   lpReserved OPTIONAL);

HRESULT 
WZCCanShowBalloon ( 
        IN const GUID * pGUIDConn, 
        IN const PCWSTR pszConnectionName,
        IN OUT   BSTR * pszBalloonText, 
        IN OUT   BSTR * pszCookie
        );

HRESULT 
WZCOnBalloonClick ( 
        IN const GUID * pGUIDConn, 
        IN const BSTR pszConnectionName,
        IN const BSTR szCookie
        );

HRESULT 
WZCQueryConnectionStatusText ( 
        IN const GUID *  pGUIDConn, 
        IN const NETCON_STATUS ncs,
        IN OUT BSTR *  pszStatusText
        );

# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\wsahelp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WsaHelp.h

Abstract:

    This header file contains prototypes required for Windows Sockets
    Helper DLLs.  The helper DLLs allow the Windows Sockets DLL to be
    transport independent by suppling the necessary option get/set and
    address conversion routines for an individual transport or transport
    family.

Author:

    David Treadwell (davidtr)    15-Jul-1992

Revision History:

    Keith Moore (keithmo)        08-Jan-1996
        Added WinSock 2 entrypoints.

--*/

#ifndef _WSAHELP_H_
#define _WSAHELP_H_

//
// Notification event definitions.  A helper DLL returns a mask of the
// events for which it wishes to be notified, and the Windows Sockets
// DLL calls the helper DLL in WSHNotify for each requested event.
//

#define WSH_NOTIFY_BIND                 0x01
#define WSH_NOTIFY_LISTEN               0x02
#define WSH_NOTIFY_CONNECT              0x04
#define WSH_NOTIFY_ACCEPT               0x08
#define WSH_NOTIFY_SHUTDOWN_RECEIVE     0x10
#define WSH_NOTIFY_SHUTDOWN_SEND        0x20
#define WSH_NOTIFY_SHUTDOWN_ALL         0x40
#define WSH_NOTIFY_CLOSE                0x80
#define WSH_NOTIFY_CONNECT_ERROR        0x100

//
// Definitions for various internal socket options.  These are used
// by the Windows Sockets DLL to communicate information to the helper
// DLL via get and set socket information calls.
//

#define SOL_INTERNAL 0xFFFE
#define SO_CONTEXT 1

//
// Open, Notify, and Socket Option routine prototypes.
//

typedef
INT
(WINAPI * PWSH_OPEN_SOCKET) (
    IN PINT AddressFamily,
    IN PINT SocketType,
    IN PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

INT
WINAPI
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

typedef
INT
(WINAPI * PWSH_NOTIFY) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    );

INT
WINAPI
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    );

typedef
INT
(WINAPI * PWSH_GET_SOCKET_INFORMATION) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    );

INT
WINAPI
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    );

typedef
INT
(WINAPI * PWSH_SET_SOCKET_INFORMATION) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    );

INT
WINAPI
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    );

//
// Structure and routine for determining the address family/socket
// type/protocol triples supported by an individual Windows Sockets
// Helper DLL.  The Rows field of WINSOCK_MAPPING determines the
// number of entries in the Mapping[] array; the Columns field is
// always 3 for Windows/NT product 1.
//

typedef struct _WINSOCK_MAPPING {
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[1];
} WINSOCK_MAPPING, *PWINSOCK_MAPPING;

typedef
DWORD
(WINAPI * PWSH_GET_WINSOCK_MAPPING) (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

DWORD
WINAPI
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

//
// Address manipulation routine.
//

typedef enum _SOCKADDR_ADDRESS_INFO {
    SockaddrAddressInfoNormal,
    SockaddrAddressInfoWildcard,
    SockaddrAddressInfoBroadcast,
    SockaddrAddressInfoLoopback
} SOCKADDR_ADDRESS_INFO, *PSOCKADDR_ADDRESS_INFO;

typedef enum _SOCKADDR_ENDPOINT_INFO {
    SockaddrEndpointInfoNormal,
    SockaddrEndpointInfoWildcard,
    SockaddrEndpointInfoReserved
} SOCKADDR_ENDPOINT_INFO, *PSOCKADDR_ENDPOINT_INFO;

typedef struct _SOCKADDR_INFO {
    SOCKADDR_ADDRESS_INFO AddressInfo;
    SOCKADDR_ENDPOINT_INFO EndpointInfo;
} SOCKADDR_INFO, *PSOCKADDR_INFO;

typedef
INT
(WINAPI * PWSH_GET_SOCKADDR_TYPE) (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    );

INT
WINAPI
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    );

typedef
INT
(WINAPI * PWSH_GET_WILDCARD_SOCKADDR) (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

INT
WINAPI
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

typedef
INT
(WINAPI * PWSH_ENUM_PROTOCOLS) (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

INT
WINAPI
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

#ifdef _WINSOCK2API_

//
// New WinSock 2 Entrypoints.
//

typedef
INT
(WINAPI * PWSH_OPEN_SOCKET2) (
    IN PINT AddressFamily,
    IN PINT SocketType,
    IN PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

INT
WINAPI
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    );

typedef
INT
(WINAPI * PWSH_JOIN_LEAF) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    );

INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    );

INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    );

typedef
INT
(WINAPI * PWSH_ADDRESS_TO_STRING) (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    );

INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    );

typedef
INT
(WINAPI * PWSH_STRING_TO_ADDRESS) (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    );

typedef
INT
(WINAPI * PWSH_GET_BROADCAST_SOCKADDR) (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    );

typedef
INT
(WINAPI * PWSH_GET_PROVIDER_GUID) (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    );

INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    );

typedef
INT
(WINAPI * PWSH_GET_WSAPROTOCOL_INFO) (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    );

INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    );

typedef
INT
(WINAPI * PWSH_IOCTL) (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    );

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    );

#endif  // _WINSOCK2API_

#endif  // _WSAHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\xsprocs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsProcs.h

Abstract:

    This header file contains procedure prototypes for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSPROCS_
#define _XSPROCS_

//
// API handling routines.
//

NTSTATUS
XsNetShareEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetShareCheck (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetSessionDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConnectionEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileClose (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerDiskEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerAdminCommand (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetAuditOpen (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogOpen (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQPurge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetCharDevQPurgeSelf (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameFwd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageNameUnFwd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageBufferSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageFileSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageLogFileSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetMessageLogFileGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceInstall (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupAddUser (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupDelUser (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupGetUsers (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserPasswordSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserGetGroups (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaSetUID (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUseGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQPause (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQContinue (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobSetInfo_OLD (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobPause (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobContinue (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestControl (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetProfileSave (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetProfileLoad (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetRemoteTOD (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBiosEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBiosGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintQPurge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessGetUserPerms (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGroupSetUsers (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetGroups (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserModalsGet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserModalsSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserAdd2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserSetInfo2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserPasswordSet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConfigGet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetConfigGetAll2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetGetDCName (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetHandleGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetHandleSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetStatisticsGet2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetBuildGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileGetInfo2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetFileClose2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerReqChallenge (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerAuthenticate (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerPasswordSet (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccountDeltas (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccountSync (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserEnum2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaUserLogon (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetWkstaUserLogoff (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetLogonEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetErrorLogRead (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathType (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathCanonicalize (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetPathCompare (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameValidate (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameCanonicalize (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetNameCompare (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditRead (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestAdd (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintDestDel (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetUserValidate2 (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetPrintJobSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_NetServerDiskEnum (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_NetServerDiskGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTVerifyMirror (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTAbortVerify (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTSetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTLockDisk (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTFixError (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTAbortFix (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTDiagnoseError (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTGetDriveStats (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsTI_FTErrorGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAccessCheck (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertRaise (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertStart (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAlertStop (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetAuditWrite (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetIRemoteAPI (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServiceStatus (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerRegister (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetServerDeregister (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetSessionEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetConnectionEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryMake (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryClear (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntrySetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsI_NetFileEntryGetInfo (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsAltSrvMessageBufferSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsAltSrvMessageFileSend (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsSamOEMChangePasswordUser2_P (
    API_HANDLER_PARAMETERS
    );

NTSTATUS
XsNetServerEnum3 (
    API_HANDLER_PARAMETERS
    );

#endif // ndef _XSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\faxuiconstants.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxUIConstants.h                                       //
//                                                                         //
//  DESCRIPTION   : Fax UI Constants.                                      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 28 1999 yossg   create                                         //  
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef _FXS_CONST_H_
#define _FXS_CONST_H_

#include <lmcons.h>

#define FXS_RETRIES_DEFAULT         2
#define FXS_RETRIES_LOWER           0   
#define FXS_RETRIES_UPPER          99    
#define FXS_RETRIES_LENGTH          2 //num of digits of FXS_RETRIES_UPPER

#define FXS_RETRYDELAY_DEFAULT     10
#define FXS_RETRYDELAY_LOWER        0   
#define FXS_RETRYDELAY_UPPER      999    
#define FXS_RETRYDELAY_LENGTH       3 //num of digits of FXS_RETRYDELAY_UPPER

// FXS_DIRTYDAYS_LOWER  
// is actually must have FXS_DIRTYDAYS_ZERO equls zero
// for UI implementation reasons
// Do not change FXS_DIRTYDAYS_LOWER current value!
#define FXS_DIRTYDAYS_ZERO          0   

#define FXS_DIRTYDAYS_DEFAULT      30
#define FXS_DIRTYDAYS_LOWER         1   
#define FXS_DIRTYDAYS_UPPER        99    
#define FXS_DIRTYDAYS_LENGTH        2 //num of digits of FXS_DIRTYDAYS_UPPER

#define FXS_QUOTA_HIGH_DEFAULT     50
#define FXS_QUOTA_HIGH_LOWER        1   
#define FXS_QUOTA_HIGH_UPPER      999    
#define FXS_QUOTA_LENGTH            3 //num of digits of FXS_RINGS_UPPER

#define FXS_QUOTA_LOW_DEFAULT      48
#define FXS_QUOTA_LOW_LOWER         0   
#define FXS_QUOTA_LOW_UPPER       998    

#define FXS_RINGS_DEFAULT           3 
#define FXS_RINGS_LOWER             0   
#define FXS_RINGS_UPPER            99    
#define FXS_RINGS_LENGTH            2 //num of digits of FXS_RINGS_UPPER

#define FXS_DWORD_LEN              10
//Do not change 
#define FXS_MAX_RINGS_LEN          FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_NUM_OF_DEVICES_LEN FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_CODE_LEN           FXS_DWORD_LEN   //to be safe           

#define FXS_MAX_AREACODE_LEN       FXS_DWORD_LEN
#define FXS_MAX_COUNTRYCODE_LEN    FXS_DWORD_LEN

#define FXS_MAX_COUNTRYNAME_LEN   256
#define FXS_MAX_LOG_REPORT_LEVEL    4

//for Node's Display Name
#define FXS_MAX_DISPLAY_NAME_LEN      MAX_FAX_STRING_LEN
//Used in browse dialog, page error msg etc.
#define FXS_MAX_TITLE_LEN             128

#define FXS_MAX_MESSAGE_LEN          1024

#define FXS_MAX_ERROR_MSG_LEN         512
#define FXS_MAX_GENERAL_BUF_LEN       200

#define FXS_THIN_COLUMN_WIDTH          30
#define FXS_NORMAL_COLUMN_WIDTH       120
#define FXS_WIDE_COLUMN_WIDTH         180
#define FXS_LARGE_COLUMN_WIDTH        200

#define FXS_IDS_STATUS_ERROR          999
#define FXS_FIRST_DEVICE_ORDER          1
#define FXS_FIRST_METHOD_PRIORITY       1

#define NUL                             0
#define EQUAL_STRING                    0

#define FXS_ITEMS_NEVER_COUNTED        -1

//constants from lmcons.h (without the final null)
#define FXS_MAX_PASSWORD_LENGTH     PWLEN  //256
#define FXS_MAX_USERNAME_LENGTH     UNLEN  //256
#define FXS_MAX_DOMAIN_LENGTH       DNLEN  //15
//#define FXS_MAX_SERVERNAME_LENGTH   CNLEN  //15  == MAX_COMPUTERNAME_LENGTH

#define FXS_MAX_EMAIL_ADDRESS         128  

#define FXS_MAX_PORT_NUM           0xffff  //MAX_LONG
#define FXS_MIN_PORT_NUM                0
#define FXS_MAX_PORT_NUM_LEN            5

#define FXS_TSID_CSID_MAX_LENGTH       20

#define FXS_GLOBAL_METHOD_DEVICE_ID     0

//temp
#define FXS_ADMIN_HLP_FILE              L"FxsAdmin.hlp"

#define MAX_USERINFO_FULLNAME            128
#define MAX_USERINFO_FAX_NUMBER          64
#define MAX_USERINFO_COMPANY             128
#define MAX_USERINFO_ADDRESS             256
#define MAX_USERINFO_TITLE               64
#define MAX_USERINFO_DEPT                64
#define MAX_USERINFO_OFFICE              64
#define MAX_USERINFO_HOME_PHONE          64
#define MAX_USERINFO_WORK_PHONE          64
#define MAX_USERINFO_BILLING_CODE        64
#define MAX_USERINFO_MAILBOX             64
#define MAX_USERINFO_STREET              256
#define MAX_USERINFO_CITY                256
#define MAX_USERINFO_STATE               64
#define MAX_USERINFO_ZIP_CODE            64
#define MAX_USERINFO_COUNTRY             256

#define MAX_FAX_STRING_LEN               MAX_PATH - 2

//
// FSPI versions
//
typedef enum
{
    FSPI_API_VERSION_1 = 0x00010000    // Used by FSPs    
} FSPI_API_VERSIONS;    // Used in FaxRegisterServiceProviderEx

#endif // _FXS_CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\wsasetup.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wsasetup.h

Abstract:

    This header file contains the type definitions and function prototypes
    for the private interface between NT Setup and WSOCK32.DLL.

Author:

    Keith Moore (keithmo)        27-Oct-1995

Revision History:

--*/


#ifndef _WSASETUP_
#define _WSASETUP_


//
// Setup disposition, used to tell Setup what actions were taken (if any).
//

typedef enum _WSA_SETUP_DISPOSITION {

    WsaSetupNoChangesMade,
    WsaSetupChangesMadeRebootNotNecessary,
    WsaSetupChangesMadeRebootRequired

} WSA_SETUP_DISPOSITION, *LPWSA_SETUP_DISPOSITION;


//
// Opcodes for the migration callback (see below).
//

typedef enum _WSA_SETUP_OPCODE {

    WsaSetupInstallingProvider,
    WsaSetupRemovingProvider,
    WsaSetupValidatingProvider,
    WsaSetupUpdatingProvider

} WSA_SETUP_OPCODE, *LPWSA_SETUP_OPCODE;


//
// Callback function invoked by MigrationWinsockConfiguration() at
// strategic points in the migration process.
//

typedef
BOOL
(CALLBACK LPFN_WSA_SETUP_CALLBACK)(
    WSA_SETUP_OPCODE Opcode,
    LPVOID Parameter,
    DWORD Context
    );


//
// Private function exported by WSOCK32.DLL for use by NT Setup only.  This
// function updates the WinSock 2.0 configuration information to reflect any
// changes made to the WinSock 1.1 configuration.
//

DWORD
WINAPI
MigrateWinsockConfiguration(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    );

typedef
DWORD
(WINAPI * LPFN_MIGRATE_WINSOCK_CONFIGURATION)(
    LPWSA_SETUP_DISPOSITION Disposition,
    LPFN_WSA_SETUP_CALLBACK Callback OPTIONAL,
    DWORD Context OPTIONAL
    );


#endif  // _WSASETUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\wzcsvc.h ===
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wzcsvc.h

Abstract:

    Header file for wzcdlg

Author:

    Deonb   27-March-2001

Environment:

    User Level: Win32

Revision History:

--*/

# ifdef     __cplusplus
extern "C" {
# endif

HRESULT
WZCQueryGUIDNCSState (
    IN      GUID            * pGuidConn,
    OUT     NETCON_STATUS   * pncs
    );

VOID
WZCTrayIconReady (
    IN      const WCHAR    * pszUserName
    );


# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\net\inc\xstypes.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    XsTypes.h

Abstract:

    Structure and type declarations for XACTSRV.

Author:

    David Treadwell (davidtr) 09-Jan-1991

Revision History:

--*/

#ifndef _XSTYPES_
#define _XSTYPES_

//
// This structure is the same as in the server file srvblock.h.  The server
// passes it to XACTSRV via shared memory, and XACTSRV uses it to make the
// necessary API call(s) and receive any response data.  XACTSRV should
// not modify any fields in this structure except the count fields;
// changing other fields could cause an access violation in the server.
//
// WARNING:  When using a srv.sys with SRVDBG2 enabled, you must also
//           use a srvsvc.dll and xactsrv.dll with SRVDBG2 enabled.
//           This is because they share the TRANSACTION structure.
//
// *******************************************************************
// *                                                                 *
// * DO NOT CHANGE THIS STRUCTURE EXCEPT TO MIRROR THE CORRESPONDING *
// * STRUCTURE IN ntos\srv\srvblock.h!                               *
// *                                                                 *
// *******************************************************************
//

typedef struct _TRANSACTION {

    DWORD BlockHeader[2];

#if SRVDBG2
    DWORD ReferenceHistory[4];
#endif

    LPVOID NonpagedHeader;

    LPVOID Connection;
    LPVOID Session;
    LPVOID TreeConnect;

    LIST_ENTRY ConnectionListEntry;

    UNICODE_STRING TransactionName;

    DWORD StartTime;
    DWORD Timeout;
    DWORD cMaxBufferSize;

    LPWORD InSetup;
    LPWORD OutSetup;
    LPBYTE InParameters;
    LPBYTE OutParameters;
    LPBYTE InData;
    LPBYTE OutData;

    DWORD SetupCount;
    DWORD MaxSetupCount;
    DWORD ParameterCount;
    DWORD TotalParameterCount;
    DWORD MaxParameterCount;
    DWORD DataCount;
    DWORD TotalDataCount;
    DWORD MaxDataCount;

    WORD Category;
    WORD Function;

    BOOLEAN InputBufferCopied;
    BOOLEAN OutputBufferCopied;

    WORD Flags;

    WORD Tid;
    WORD Pid;
    WORD Uid;
    WORD OtherInfo;

    HANDLE FileHandle;
    PVOID FileObject;

    DWORD ParameterDisplacement;
    DWORD DataDisplacement;

    BOOLEAN PipeRequest;
    BOOLEAN RemoteApiRequest;

    BOOLEAN Inserted;
    BOOLEAN MultipieceIpxSend;

} TRANSACTION, *PTRANSACTION, *LPTRANSACTION;

//
// The header included in all parameter structures passed to API handlers.
// The actual parameter structure follows.
//

typedef struct _XS_PARAMETER_HEADER {

    WORD Status;
    WORD Converter;
    LPWSTR ClientMachineName;
    LPWSTR ClientTransportName;
    PUCHAR ServerName;              // points to NETBIOS_NAME_LEN array
    PUCHAR EncryptionKey;
    DWORD Flags;
} XS_PARAMETER_HEADER, *PXS_PARAMETER_HEADER, *LPXS_PARAMETER_HEADER;

//
// The input parameters taken by all API handler routines.
//

#define API_HANDLER_PARAMETERS      \
    IN PXS_PARAMETER_HEADER Header, \
    IN PVOID Parameters,            \
    IN LPDESC StructureDesc,         \
    IN LPDESC AuxStructureDesc OPTIONAL
//
// Routine declaration for API processing routines.
//

typedef
NTSTATUS
(*PXACTSRV_API_HANDLER) (
    API_HANDLER_PARAMETERS
    );

typedef
NET_API_STATUS
(*PXACTSRV_ENUM_VERIFY_FUNCTION) (
    NET_API_STATUS ConvertStatus,
    LPBYTE ConvertedEntry,
    LPBYTE BaseAddress
    );

#define API_HANDLER_PARAMETERS_REFERENCE       \
    UNREFERENCED_PARAMETER( Header );          \
    UNREFERENCED_PARAMETER( Parameters );      \
    UNREFERENCED_PARAMETER( StructureDesc );   \
    UNREFERENCED_PARAMETER( AuxStructureDesc )

#endif // ndef _XSTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\annotlib.h ===
#ifndef _ANNOT_H_
#define _ANNOT_H_

#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include <shimgdata.h>
// This file defines classes used to render and edit TIFF 6.0 annotations.
// These annotations are stored in tag #32932. The specification for these annotations
// is defined by Eastman Software, the spec version is 1.00.06.

#define ANNOTATION_IMAGE_TAG 32932

// These structures define the in-file layout of the annotations.
// Note that most of the structs are variable-sized.
// The annotation parser reads the annotations into these structures, wraps them in a descriptor
// and passes the descriptor to the annotation factory object to construct
// CAnnotationMark-derived classes that implement
// the rendering, editing, and saving of the different types of marks.

// MT_* used in ANNOTATIONMARK::uType
#define MT_IMAGEEMBED         1
#define MT_IMAGEREF           2
#define MT_STRAIGHTLINE       3
#define MT_FREEHANDLINE       4
#define MT_HOLLOWRECT         5
#define MT_FILLRECT           6
#define MT_TYPEDTEXT          7
#define MT_FILETEXT           8
#define MT_STAMP              9
#define MT_ATTACHANOTE       10
#define MT_FORM              11
#define MT_OCR               12 // unsupported

// ANNOTATIONMARK is fixed size and exists for every mark in the file
// We only support files with 4 byte integers
// this struct is not declared as UNALIGNED because we never typecast a variable
// as this type.
struct ANNOTATIONMARK
{
    UINT uType;                 /* The type of the mark (or operation).
                                    This will be ignored for sets.*/
    RECT lrBounds;             /* Rect in FULLSIZE units.
                                    This could be a rect or 2 points.*/
    RGBQUAD rgbColor1;          /* This is the main color. (Example: This is the
                                    color of all lines, rects, and stand alone
                                    text.*/
    RGBQUAD rgbColor2;          /* This is the secondary color. (Example: This
                                    is the color of the text of an ATTACH_A_NOTE.)*/
    BOOL bHighlighting;         /* TRUE = The mark will be drawn highlighted.
                                    This attribute is currently only valid
                                    for lines, rectangles, and freehand.*/
    BOOL bTransparent;          /* TRUE = The mark will be drawn transparent.
                                    If the mark is drawn transparent, then white
                                    pixels are not drawn (ie. there is nothing
                                    drawn for this mark where it contains white
                                    pixels. This attribute is currently only
                                    available for images. This attribute being
                                    set to TRUE will cause significant
                                    performance reduction.*/
    UINT uLineSize;             /* The size of the line etc. This is passed
                                    onto Windows and is currently in logical
                                    pixels for lines and rectangles.*/
    UINT uStartingPoint;        /* The shape put on the starting of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    UINT uEndPoint;             /* The shape put on the end of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    LOGFONTA lfFont;             /* The font information for the text. */
    BOOL bMinimizable;          /* TRUE = This mark can be minimized
                                    by the user. This flag is only used for
                                    marks that have a minimizable
                                    characteristic such as ATTACH_A_NOTE.*/
    UINT  Time;                /* The time that the mark was first saved.
                                    in seconds from 00:00:00 1-1-1970 (GMT).*/
    BOOL bVisible;              /* TRUE means that the layer is currently set
                                    to be visible.*/
    DWORD dwPermissions;        /* Reserved. Must be set to 0x0ff83f */
    UINT lReserved[10];         /* Reserved for future expansion.
                                    For this release these must be set to 0.*/
};


// ANNOTATIONHEADER is the first 4 bytes of data in the annotation property.
struct _ANNOTATIONHEADER
{
    BYTE reserved[4];
    UINT IntIs32Bit;
};

typedef UNALIGNED struct _ANNOTATIONHEADER ANNOTATIONHEADER;
//
// for OiAnoDat
//
struct _ANPOINTS
{
    int nMaxPoints;
    int nPoints;
    POINT ptPoint[1];
};

typedef UNALIGNED struct _ANPOINTS ANPOINTS;

struct _ANROTATE
{
    int rotation;
    int scale;
    int nHRes;
    int nVRes;
    int nOrigHRes;
    int nOrigVRes;
    BOOL bReserved1;
    BOOL bReserved2;
    int nReserved[6];
};

typedef UNALIGNED struct _ANROTATE ANROTATE;
// for OiFilNam
struct _ANNAME
{
    char szName[1];
};

typedef UNALIGNED struct _ANNAME ANNAME;
// for OiDIB
struct _ANIMAGE
{
    BYTE dibInfo[1]; // standard memory DIB
};

typedef UNALIGNED struct _ANIMAGE ANIMAGE;
// for OiAnText
struct _ANTEXTPRIVDATA
{
    int nCurrentOrientation;
    UINT uReserved1; // always 1000 when writing, ignore when reading
    UINT uCreationScale; // always 72000 divided by the vertical resolution of the base image when writing.
                         // Used to modify the Attributes.lfFont.lfHeight variable for display
    UINT uAnoTextLength; // 64k byte limit, except 255 byte limit for text stamp
    char szAnoText[1];
};

typedef UNALIGNED struct _ANTEXTPRIVDATA ANTEXTPRIVDATA;

// These structures provide descriptors for the data read from the annotation property blob.
// The extra data includes the size of each annotation structure
// _NAMEDBLOCK is our in-memory representation
struct _NAMEDBLOCK
{
    UINT cbSize;
    char szType[9];
    BYTE data[1];
};

typedef UNALIGNED struct _NAMEDBLOCK NAMEDBLOCK;

// _FILENAMEDBLOCK is what the namedblock looks like in the file
struct _FILENAMEDBLOCK
{
    char szType[8];
    UINT cbSize;
    BYTE data[1];
};

typedef UNALIGNED struct _FILENAMEDBLOCK FILENAMEDBLOCK;

struct ANNOTATIONDESCRIPTOR
{
    UINT cbSize;
    ANNOTATIONMARK mark;
    BYTE blocks[1];
};

// Define a base class for the various annotation types
class CAnnotation
{
public:
    static CAnnotation* CreateAnnotation(UINT type, ULONG uCreationScale);
    static CAnnotation* CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual ~CAnnotation();

    // render to the given rectangle in window client coordinates.
    virtual void Render(HDC hdc) { return; }
    // return the in-file representation of this annotation, as well as its total size
    HRESULT GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex);
    // return our image coordinates
    virtual void GetRect(RECT &rect) {rect = _mark.lrBounds;}
    // return the type of Annotation Mark used to change the selection handles for straight lines
    virtual UINT GetType() { return _mark.uType; }
    // moves the annotation on the page by the specified offset
    virtual void Move(SIZE sizeOffset) { OffsetRect(&_mark.lrBounds, sizeOffset.cx, sizeOffset.cy); }
    // return true if the object can be resized (true for every thing but freehand lines and images)
    virtual BOOL CanResize() { return true; }
    // resizes the annotation on the page to the new rect specified
    virtual void Resize(RECT rectNewSize);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasWidth() { return true; }
    virtual UINT GetWidth() { return _mark.uLineSize; }
    virtual void SetWidth(UINT nWidth) { _mark.uLineSize = nWidth; }

    virtual BOOL HasTransparent() { return true; }
    virtual BOOL GetTransparent() { return _mark.bHighlighting; }
    virtual void SetTransparent(BOOL bTransparent) { _mark.bHighlighting = bTransparent; }

    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

    virtual BOOL HasFont() { return true; }
    virtual void GetFont(LOGFONTA& lfFont) { CopyMemory (&lfFont, &_mark.lfFont, sizeof(lfFont)); }
    virtual void GetFont(LOGFONTW& lfFont);
    virtual void SetFont(LOGFONTA& lfFont) { CopyMemory (&_mark.lfFont, &lfFont, sizeof(lfFont)); }
    virtual void SetFont(LOGFONTW& lfFont);
    virtual LONG GetFontHeight(HDC hdc) { return _mark.lfFont.lfHeight; }

    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

protected:
    CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor);
    NAMEDBLOCK *_FindNamedBlock (LPCSTR szName, ANNOTATIONDESCRIPTOR *pDesc);
    virtual HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer) {return E_NOTIMPL;};
    // define helper functions for writing the different named block types
    SIZE_T _WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len);
    SIZE_T _WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints);
    SIZE_T _WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate);
    SIZE_T _WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen);
    SIZE_T _WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib);

    ANNOTATIONMARK _mark;
    LPSTR          _szGroup;
    FILENAMEDBLOCK *   _pUGroup;
};

class CRectMark : public CAnnotation
{
public:
    CRectMark (ANNOTATIONDESCRIPTOR *pDescriptor);
    void Render (HDC hdc);

    virtual BOOL HasWidth() { return (_mark.uType == MT_HOLLOWRECT); }
    virtual BOOL HasFont() { return false; }
};

class CImageMark : public CAnnotation
{
public:
    CImageMark (ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded);
    ~CImageMark();
    void Render (HDC hdc);
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);
    virtual BOOL CanResize() { return false; };
    virtual void Resize(RECT rectNewSize) { return; };

private:
    HANDLE _hDibSection; // cached image for quicker render
    LPBYTE _pDib;        // the DIB data from the annotation. If NULL, this is a reference mark
    ANROTATE _rotation;  // rotation info
    LPSTR    _szFilename;  // image file name from the annotation
    bool     _bRotate; //REVIEW_SDK: Shouldn't there just be a known blank rotation value? If I rotate something 0 degrees shouldn't just not write the rotation record?
    SIZE_T   _cbDib;
};

class CLineMark : public CAnnotation
{
public:
    CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand);
    ~CLineMark();
    void Render(HDC hdc);
    void GetRect(RECT &rect);
    void SetPoints(POINT* pPoints, int cPoints);
    void GetPointsRect(RECT &rect);
    virtual void Move(SIZE sizeOffset);
    virtual BOOL CanResize() { return (_nPoints == 2); };
    virtual void Resize(RECT rectNewSize);
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasFont() { return false; }

    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

private:
    int    _iMaxPts;
    int    _nPoints;
    POINT *_points; // 2 points for a straight line, more for a freehand line
};

// all text annotations render and initialize the same way so use a common base class
class CTextAnnotation : public CAnnotation
{
public:
    CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxText=65536, bool _bUseColor2=false);
    void Render(HDC hdc);
    virtual ~CTextAnnotation();
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

    virtual BOOL HasWidth() { return false; }
    virtual BOOL HasTransparent() { return false; }
    virtual BOOL HasColor() { return false; }
    virtual LONG GetFontHeight(HDC hdc);
    virtual int GetOrientation() { return _nCurrentOrientation; }

    BSTR GetText();
    void SetText(BSTR bstrText);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

private:
    int _nCurrentOrientation;
    UINT _uCreationScale;
    UINT _uAnoTextLength;
    UINT _nMaxText;
    LPSTR _szText;
    bool _bUseColor2;
};

class CTypedTextMark : public CTextAnnotation
{
public:
    CTypedTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CFileTextMark : public CTextAnnotation
{
public:
    CFileTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CTextStampMark : public CTextAnnotation
{
public:
    CTextStampMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CAttachNoteMark : public CTextAnnotation
{
public:
    CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor2.rgbRed, _mark.rgbColor2.rgbGreen, _mark.rgbColor2.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor2.rgbRed = GetRValue(crColor); _mark.rgbColor2.rgbGreen = GetGValue(crColor); _mark.rgbColor2.rgbBlue = GetBValue(crColor); }
};

class CAnnotationSet
{
public:
    CAnnotationSet ();
    ~CAnnotationSet ();

    // Draw all the marks
    void RenderAllMarks (HDC hdc);
    // construct annotation set from raw data
    HRESULT BuildAllMarksFromData( LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI );
    // Return the annotation at this point in image coordinates
    CAnnotation* GetAnnotation (INT_PTR nIndex);
    // Add a new annotation to the list. Should only be called from a CAnnotation
    BOOL AddAnnotation(CAnnotation *pMark);
    // Remove an annotation from the list. Should only be called from a CAnnotation
    BOOL RemoveAnnotation (CAnnotation *pMark);
    // Save the current set of annotations to the image
    HRESULT CommitAnnotations (IShellImageData *pimg);
    // Forget our old annotations and load new ones
    void SetImageData (IShellImageData *pimg);
    INT_PTR GetCount ()
    {
        if (_dpaMarks)
            return DPA_GetPtrCount(_dpaMarks);
        return 0;
    };

    UINT GetCreationScale();
    void ClearAllMarks();


private:
    HDPA    _dpaMarks;
    LPBYTE  _pDefaultData;
    SIZE_T  _cbDefaultData;
    ULONG   _xDPI;
    ULONG   _yDPI;

    static int CALLBACK _FreeMarks(LPVOID pMark, LPVOID pUnused);
    void   _ClearMarkList ();
    void   _BuildMarkList (IShellImageData *pimg);
    void   _BuildListFromData (LPVOID pData, UINT cbSize);
    INT    _NamedBlockDataSize (UINT uType, LPBYTE pData, LPBYTE pEOD);
    LPBYTE _MakeAnnotationBlob ();
    HRESULT _SaveAnnotationProperty(IShellImageData *pimg, LPBYTE pData, SIZE_T cbBuffer);
    ANNOTATIONDESCRIPTOR *_ReadMark (LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\lmon.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation
All rights reserved

Module Name:

    lmon.h

--*/


typedef struct _PORT_INFO_FFA {
    LPSTR   pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFA, *PPORT_INFO_FFA, *LPPORT_INFO_FFA;

typedef struct _PORT_INFO_FFW {
    LPWSTR  pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFW, *PPORT_INFO_FFW, *LPPORT_INFO_FFW;

#ifdef UNICODE
#define PORT_INFO_FF PORT_INFO_FFW
#define PPORT_INFO_FF PPORT_INFO_FFW
#define LPPORT_INFO_FF LPPORT_INFO_FFW
#else
#define PORT_INFO_FF PORT_INFO_FFA
#define PPORT_INFO_FF PPORT_INFO_FFA
#define LPPORT_INFO_FF LPPORT_INFO_FFA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\prwiziid.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       prwiziid.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        12/15/00
 *
 *  DESCRIPTION: Define clsid/iids for this project
 *
 *****************************************************************************/

#ifndef _PHOTO_PRINT_WIZARD_IIDS_H_
#define _PHOTO_PRINT_WIZARD_IIDS_H_


//CLSID_PrintPhotoshDropTarget  {60fd46de-f830-4894-a628-6fa81bc0190d}
DEFINE_GUID(CLSID_PrintPhotosDropTarget, 0x60fd46de, 0xf830, 0x4894, 0xa6, 0x28, 0x6f, 0xa8, 0x1b, 0xc0, 0x19, 0x0d);


#undef INTERFACE
#define INTERFACE IPrintPhotosWizardSetInfo
//
// IPrintPhotosWizardSetInfo is meant as a way to get information
// to the wizard from outside objects/classes.  Primarily, we use
// this as a way to transfer a dataobject to the wizard that holds
// all of the items we want to print.
//
DECLARE_INTERFACE_(IPrintPhotosWizardSetInfo, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IPrintPhotosWizardSetInfo methods
    STDMETHOD(SetFileListDataObject) (THIS_ IN IDataObject * pdo);
    STDMETHOD(SetFileListArray) (THIS_ IN LPITEMIDLIST *aidl, IN int cItems, IN int iSelectedItem);
    STDMETHOD(RunWizard) (THIS_ VOID);
};

typedef HRESULT (*LPFNPPWPRINTTO)(LPCMINVOKECOMMANDINFO pCMI,IDataObject * pdtobj);
#define PHOTO_PRINT_WIZARD_PRINTTO_ENTRY "UsePPWForPrintTo"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\wiadevdp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADEVDP.H
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/15/1999
 *
 *  DESCRIPTION: Private Device Dialog Declarations
 *
 *******************************************************************************/
#ifndef _WIADEVDP_H_INCLUDED
#define _WIADEVDP_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

//
// Private flags for WIA enumeration
//
//      DEV_MAN_ENUM_TYPE_REMOTE    Will enumerate local AND remote
//      DEV_MAN_ENUM_TYPE_VOL       Will enumerate our volume devices
//      DEV_MAN_ENUM_TYPE_INACTIVE  Will enumerate inactive devices (e.g. USB 
//                                  device thaat is unplugged)
//      DEV_MAN_ENUM_TYPE_STI       Will enumerate STI only devices too
//      DEV_MAN_ENUM_TYPE_ALL       Will enumerate all devices
//
#define DEV_MAN_ENUM_TYPE_REMOTE    0x00000001
#define DEV_MAN_ENUM_TYPE_VOL       0x00000002
#define DEV_MAN_ENUM_TYPE_INACTIVE  0x00000004
#define DEV_MAN_ENUM_TYPE_STI       0x00000008
#define DEV_MAN_ENUM_TYPE_ALL       0x0000000F

DEFINE_GUID( CLSID_WiaDefaultUi, 0xD1621129, 0x45C4, 0x41AD, 0xA1, 0xD1, 0xAF, 0x7E, 0xAF, 0xAB, 0xEE, 0xDC );

//
// {F1ABE2B5-C073-4dba-B6EB-FD7A5111DD8F}
//
DEFINE_GUID( CLSID_WiaAutoPlayDropTarget, 0xf1abe2b5, 0xc073, 0x4dba, 0xb6, 0xeb, 0xfd, 0x7a, 0x51, 0x11, 0xdd, 0x8f );

//
// Private interface used to call system ui
//
#undef  INTERFACE
#define INTERFACE IWiaGetImageDlg
DECLARE_INTERFACE_(IWiaGetImageDlg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaGetImageDlg methods ***
    STDMETHOD(SelectDeviceDlg) (THIS_
        HWND         hwndParent,
        BSTR         bstrInitialDeviceId,
        LONG         lDeviceType,
        LONG         lFlags,
        BSTR        *pbstrDeviceID,
        IWiaItem   **ppWiaItemRoot );

    STDMETHOD(GetImageDlg)( THIS_
        IWiaDevMgr  *pWiaDevMgr,
        HWND         hwndParent,
        LONG         lDeviceType,
        LONG         lFlags,
        LONG         lIntent,
        IWiaItem    *pItemRoot,
        BSTR         bstrFilename,
        GUID        *pguidFormat );
};

DEFINE_GUID( IID_IWiaGetImageDlg, 0x4F67AD3C, 0x19EA, 0x4CE9, 0x80, 0xE2, 0x3A, 0xDE, 0x50, 0xD5, 0x02, 0xA2 );

//
// Hide various controls
//
#define WIA_PROGRESSDLG_NO_PROGRESS              0x00000001
#define WIA_PROGRESSDLG_NO_CANCEL                0x00000002
#define WIA_PROGRESSDLG_NO_ANIM                  0x00000004
#define WIA_PROGRESSDLG_NO_TITLE                 0x00000008

//
// Animation flags
//
#define WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE 0x00010000
#define WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE  0x00020000
#define WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE   0x00040000
#define WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE     0x00080000
#define WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE      0x00100000
#define WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE       0x00200000
#define WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE 0x00400000

#undef  INTERFACE
#define INTERFACE IWiaProgressDialog
DECLARE_INTERFACE_(IWiaProgressDialog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IWiaProgressDialog methods ***
    STDMETHOD(Create)(THIS_ HWND hwndParent, LONG lFlags );
    STDMETHOD(Show)(THIS);
    STDMETHOD(Hide)(THIS);
    STDMETHOD(Cancelled)( THIS_ BOOL *pbCancelled );
    STDMETHOD(SetTitle)( THIS_ LPCWSTR pszMessage );
    STDMETHOD(SetMessage)( THIS_ LPCWSTR pszTitle );
    STDMETHOD(SetPercentComplete)( THIS_ UINT nPercent );
    STDMETHOD(Destroy)(THIS);
};

// {F740718A-E460-4b05-83E8-C5D221C772E5}
DEFINE_GUID( IID_IWiaProgressDialog, 0xF740718A, 0xE460, 0x4B05, 0x83, 0xE8, 0xC5, 0xD2, 0x21, 0xC7, 0x72, 0xE5 );


// {8144B6F5-20A8-444a-B8EE-19DF0BB84BDB}
DEFINE_GUID( CLSID_StiEventHandler, 0x8144b6f5, 0x20a8, 0x444a, 0xb8, 0xee, 0x19, 0xdf, 0xb, 0xb8, 0x4b, 0xdb );


#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVDP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\faxreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This file contains all fax registry strings and general constants.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/


#ifndef _FAXREG_H_
#define _FAXREG_H_

#define FAX_PATH_SEPARATOR_STR  TEXT("\\")
#define FAX_PATH_SEPARATOR_CHR  TEXT('\\')
#define CP_SHORTCUT_EXT     _T(".lnk")

/*****************************************************************************
**                                                                          **
**               Global project definitions and constants                   **
**                                                                          **
*****************************************************************************/

#define FAX_API_MODULE_NAME_A               "FXSAPI.DLL"								// Used by the print monitor and setup
#define FAX_API_MODULE_NAME                 TEXT("FXSAPI.DLL")                          // Used by the print monitor and setup
#define FAX_SERVICE_EXE_NAME                TEXT("FXSSVC.EXE")                          // Used by utility functions
#define FAX_SERVICE_IMAGE_NAME              TEXT("%systemroot%\\system32\\")) FAX_SERVICE_EXE_NAME // Used by the service
#define FAX_WZRD_MODULE_NAME                TEXT("FXSWZRD.DLL")                         // Used by setup
#define FAX_TIFF_MODULE_NAME_A              "FXSTIFF.DLL"
#define FAX_TIFF_MODULE_NAME                TEXT("FXSTIFF.DLL")                         // Used by setup
#define FAX_DRV_MODULE_NAME                 TEXT("FXSDRV.DLL")                          // Used by setup
#define FAX_DRV_WIN9X_32_MODULE_NAME        TEXT("FXSDRV32.DLL")
#define FAX_DRV_WIN9X_16_MODULE_NAME        TEXT("FXSDRV16.DRV")
#define FAX_NT4_DRV_MODULE_NAME             TEXT("FXSDRV4.DLL")
#define FAX_DRV_UNIDRV_MODULE_NAME          TEXT("UNIDRV.DLL")
#define FAX_DRV_UNIDRV_HELP                 TEXT("UNIDRV.HLP")
#define FAX_DRV_DEPEND_FILE                 TEXT("FXSWZRD.DLL")
#define FAX_TIFF_FILE                       TEXT("FXSTIFF.DLL")
#define FAX_RES_FILE                        TEXT("FXSRES.DLL")
#define FAX_DRV_ICONLIB                     TEXT("ICONLIB.DLL")
#define FAX_UI_MODULE_NAME                  TEXT("FXSUI.DLL")                           // Used by setup
#define FAX_MONITOR_FILE                    TEXT("FXSMON.DLL")                          // Used by setup
#define FAX_EVENT_MSG_FILE                  TEXT("%systemroot%\\system32\\fxsevent.dll")// Used by service\regsitry\faxreg.c: CreateFaxEventSource()
#define FAX_MAIL_TRANSPORT_MODULE_NAME      TEXT("FXSXP32.DLL")                         // Used by exchange\xport\faxxp.h
#define FAX_SETUP_DLL                       TEXT("FXSOCM.DLL")                          // Used by setup
#define FAX_SETUP_DLL_PATH                  TEXT("\\setup\\") FAX_SETUP_DLL             // Used by setup                
#define FAX_SEND_IMAGE_NAME                 TEXT("fxssend.exe")                         // Used by the client console
#define FAX_COVER_IMAGE_NAME                TEXT("fxscover.exe")                        // Used by MMC and ClientConsole
#define FAX_COVER_PAGE_EXT_LETTERS          TEXT("cov")                                 // Used by MMC, CoverPage editor, and ClientConsole
#define FAX_COVER_PAGE_FILENAME_EXT         TEXT(".") FAX_COVER_PAGE_EXT_LETTERS        // Used by many
#define FAX_COVER_PAGE_MASK                 TEXT("*") FAX_COVER_PAGE_FILENAME_EXT       // Used by MMC, Outlook ext, and ClientConsole
#define FAX_TIF_FILE_EXT                    TEXT("tif")                                 // Used by the service
#define FAX_TIF_FILE_DOT_EXT                TEXT(".") FAX_TIF_FILE_EXT                  // Used by the service
#define FAX_TIF_FILE_MASK                   TEXT("*") FAX_TIF_FILE_DOT_EXT              // Used by the service
#define FAX_TIFF_FILE_EXT                   TEXT("tiff")                                // Used by print monitor
#define FAX_TIFF_FILE_DOT_EXT               TEXT(".") FAX_TIFF_FILE_EXT                 // Used by print monitor
#define FAX_TIFF_FILE_MASK                  TEXT("*") FAX_TIFF_FILE_DOT_EXT             // Used by print monitor
#define FAX_HTML_HELP_EXT                   TEXT("chm")                                 // Used by the client console
#define FAX_ADMIN_CONSOLE_IMAGE_NAME        TEXT("fxsadmin.msc")                        // Used by configuration wizard and ClientConsole
#define FAX_SERVICE_NAME                    TEXT("Fax")                                 // Used by the service
#define MESSENGER_SERVICE_NAME              TEXT("Messenger")                           // Name of the messenger service.
#define FAX_SERVICE_DISPLAY_NAME            TEXT("Microsoft Fax Server Service")        // Used by the service
#define FAX_SERVICE_DISPLAY_NAME_W          L"Microsoft Fax Server Service"             // Used by the service
#define FAX_PRINTER_NAME                    TEXT("Fax")                                 // Used everywhere
#define FAX_MONITOR_PORT_NAME               TEXT("SHRFAX:")                             // Used by print monitor and setup
#define FAX_PORT_NAME                       FAX_MONITOR_PORT_NAME                       // Used by print monitor and setup
#define FAX_DRIVER_NAME                     TEXT("Microsoft Shared Fax Driver")         // Used by print monitor and setup
#define FAX_DRIVER_NAME_A                   "Microsoft Shared Fax Driver"               // Used by print driver
#define FAX_WIN2K_DRIVER_NAME               TEXT("Windows NT Fax Driver")       // Legacy - for routing extension snap-in
#define FAX_MONITOR_NAME                    TEXT("Microsoft Shared Fax Monitor")        // Used by print monitor and setup
#define FAX_ADDRESS_TYPE_A                  "FAX"                                       // Used by MAPI transport
#define TRANSPORT_DISPLAY_NAME_STRING       "Microsoft Fax Mail Transport"              // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W2K        "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W9X        "AWFAX"                                     // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME            "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_T          TEXT(FAX_MESSAGE_SERVICE_NAME)
#define FAX_MESSAGE_PROVIDER_NAME           "MSFAX XPP"                                 // Used by MAPI transport
#define FAX_MESSAGE_PROVIDER_NAME_T         TEXT(FAX_MESSAGE_PROVIDER_NAME)
#define FAX_MESSAGE_SERVICE_NAME_SBS50      "SHAREDFAX XP"
#define FAX_MESSAGE_SERVICE_NAME_SBS50_T    TEXT(FAX_MESSAGE_SERVICE_NAME_SBS50)
#define FAX_MESSAGE_PROVIDER_NAME_SBS50     "SHAREDFAX XPP"
#define FAX_MESSAGE_PROVIDER_NAME_SBS50_T   TEXT(FAX_MESSAGE_PROVIDER_NAME_SBS50)


#define FAX_ROUTE_MODULE_NAME               TEXT("FXSROUTE")
#define FAX_T30_MODULE_NAME                 TEXT("FXST30")

#define FAX_MESSAGE_SERVICE_PROVIDER_NAME   "Microsoft Fax XPP"                         // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_PROVIDER_NAME_T TEXT(FAX_MESSAGE_SERVICE_PROVIDER_NAME)     // Used by MAPI transport
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME    "FXSXP.DLL"                                 // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T  TEXT(FAX_MESSAGE_TRANSPORT_IMAGE_NAME)      // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_RPC_ENDPOINTW                   L"SHAREDFAX"                                // Used by RPC - Same EndPoint as for BOS
#define FAX_RPC_ENDPOINT                    TEXT("SHAREDFAX")                           // Used by RPC - Same EndPoint as for BOS
#define FAX_CLIENT_CONSOLE_IMAGE_NAME       TEXT("FXSCLNT.exe")                         // Used by MMC
#define FAX_CONSOLE_RESOURCE_DLL            TEXT("FXSCLNTR.dll")                        // Fax Console resource DLL
#define FAX_CONTEXT_HELP_FILE               TEXT("FXSCLNT.hlp")                         // Used by ClientConsole
#define FAX_CLIENT_HELP_FILE                TEXT("FXSCLNT.chm")                         // Used by ClientConsole
#define FAX_COVERPAGE_HELP_FILE             TEXT("FXSCOVER.chm")                        // Used by the cover page editor
#define FAX_ADMIN_HELP_FILE                 TEXT("FXSADMIN.chm")                        // Used by MMC
#define FAX_CLIENTS_SHARE_NAME              TEXT("FxsClients$")                         // Used by FxsUI.dll
#define FAX_COVER_PAGES_SHARE_NAME          TEXT("FxsSrvCp$")                           // Used by send wizard
#define ADAPTIVE_ANSWER_SECTION             TEXT("Adaptive Answer Modems")              // Used by the service
#define REGKEY_CLIENT_EXT                   TEXT("Software\\Microsoft\\Exchange\\Client\\Extensions")   // Used by setup
#define EXCHANGE_CLIENT_EXT_FILE            "%windir%\\system32\\fxsext32.dll"          // Used by setup
#define FAX_FILENAME_FAXPERF_INI            TEXT("\\FXSPERF.INI")                       // Used by setup
#define USE_SERVER_DEVICE                   MAXDWORD                                    // Used by the service - this line id value is reserved for internal use.
#define SHARED_FAX_SERVICE_SETUP_LOG_FILE   TEXT("XPFaxServiceSetupLog.txt")
#define SERVICE_ALWAYS_RUNS                 TEXT("/AlwaysRun")                          // Command line parameter to service to disable idle-activity suicide
#define SERVICE_DELAY_SUICIDE               TEXT("/DelaySuicide")                       // Command line parameter to service to delay idle-activity suicide
                                                                                                                   // This event should be "Global" (see terminal services and named kernel objects)

#define FAX_MODEM_PROVIDER_NAME             TEXT("Windows Telephony Service Provider for Universal Modem Driver")

//
// Install types
//
#define FAX_INSTALL_NETWORK_CLIENT          0x00000001                                  // Used by the coverpage editor
#define FAX_INSTALL_SERVER                  0x00000002                                  // Used by the coverpage editor
#define FAX_INSTALL_WORKSTATION             0x00000004                                  // Used by the coverpage editor
#define FAX_INSTALL_REMOTE_ADMIN            0x00000008                                  // Used by the coverpage editor
//
// Product types
//
#define PRODUCT_TYPE_WINNT                  1                                           // Used by the utility library
#define PRODUCT_TYPE_SERVER                 2                                           // Used by the utility library
//
// Shared memory region name for faxui & faxxp32
//
#define FAX_ENVVAR_PRINT_FILE               TEXT("MS_FAX_PRINTFILE")
#define FAXXP_ATTACH_MUTEX_NAME             TEXT("MS_FAXXP_ATTACHMENT_MUTEX")
#define FAXXP_MEM_NAME                      TEXT("MS_FAXXP_ATTACHMENT_REGION")
#define FAXXP_MEM_MUTEX_NAME                TEXT("MS_FAXXP_ATTACHMENTREGION_MUTEX")
#define FAXXP_ATTACH_END_DOC_EVENT          TEXT("_END_DOC_EVENT")                      // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_ABORT_EVENT            TEXT("_ABORT_EVENT")                        // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_EVENT_NAME_LEN         (MAX_PATH+20)
//
// Fax dirs. These are hardcoded relative paths. We call into the shell to get the base path.
//
#define FAX_SHARE_DIR                       TEXT("Microsoft\\Windows NT\\MSFax")
#define FAX_QUEUE_DIR                       FAX_SHARE_DIR TEXT("\\Queue")               // Used by service

// The following are used by SecureFaxServiceDirectories()
#define FAX_INBOX_DIR                       FAX_SHARE_DIR TEXT("\\Inbox")
#define FAX_SENTITEMS_DIR                   FAX_SHARE_DIR TEXT("\\SentItems")
#define FAX_ACTIVITYLOG_DIR                 FAX_SHARE_DIR TEXT("\\ActivityLog")
#define FAX_COMMONCOVERPAGES_DIR            FAX_SHARE_DIR TEXT("\\Common Coverpages")


#define FAX_PREVIEW_TMP_DIR                 TEXT("\\FxsTmp")  // Created under %windir%\system32 with special permissions.
                                                              // Used for mapping of preview file in W2K and NT4 if
                                                              // Access to %windir%\system32 is denied for guest users.


/*****************************************************************************
**                                                                          **
**                     Registry keys, values, paths etc.                    **
**                                                                          **
*****************************************************************************/

//
// Fax Server Registry Root (relative to LOCAL_MACHINE or CURRENT_USER)
//
#define REGKEY_FAXSERVER_A              "Software\\Microsoft\\Fax"
#define REGKEY_FAXSERVER                TEXT(REGKEY_FAXSERVER_A)

#define REGKEY_CLIENT                   TEXT("Microsoft\\Fax")
#define CLIENT_ARCHIVE_KEY              TEXT("Archive")
#define CLIENT_ARCHIVE_MSGS_PER_CALL    TEXT("MessagesPerCall")
#define CLIENT_INBOX_VIEW               TEXT("InboxView")
#define CLIENT_SENT_ITEMS_VIEW          TEXT("SentItemsView")
#define CLIENT_INCOMING_VIEW            TEXT("IncomingView")
#define CLIENT_OUTBOX_VIEW              TEXT("OutboxView")
#define CLIENT_VIEW_COLUMNS             TEXT("Columns")
#define CLIENT_VIEW_COL_WIDTH           TEXT("Width")
#define CLIENT_VIEW_COL_SHOW            TEXT("Show")
#define CLIENT_VIEW_COL_ORDER           TEXT("Order")
#define CLIENT_VIEW_SORT_ASCENDING      TEXT("SortAscending")
#define CLIENT_VIEW_SORT_COLUMN         TEXT("SortColumn")
#define CLIENT_MAIN_FRAME               TEXT("MainFrame")
#define CLIENT_MAXIMIZED                TEXT("Maximized")
#define CLIENT_NORMAL_POS_TOP           TEXT("NormalPosTop")
#define CLIENT_NORMAL_POS_RIGHT         TEXT("NormalPosRight")
#define CLIENT_NORMAL_POS_BOTTOM        TEXT("NormalPosBottom")
#define CLIENT_NORMAL_POS_LEFT          TEXT("NormalPosLeft")
#define CLIENT_SPLITTER_POS             TEXT("SplitterPos")
#define CLIENT_CONFIRM_SEC              TEXT("Confirm")
#define CLIENT_CONFIRM_ITEM_DEL         TEXT("ItemDeletion")
//
// Registry values stored under HKEY_CURRENT_USER
//
//
// User information is stored under Fax\UserInfo subkey
//
#define   REGVAL_FULLNAME                       TEXT("FullName")
#define   REGVAL_FAX_NUMBER                     TEXT("FaxNumber")
#define   REGVAL_MAILBOX                        TEXT("Mailbox")
#define   REGVAL_COMPANY                        TEXT("Company")
#define   REGVAL_TITLE                          TEXT("Title")
#define   REGVAL_ADDRESS                        TEXT("Address")
#define   REGVAL_CITY                           TEXT("City")
#define   REGVAL_STATE                          TEXT("State")
#define   REGVAL_ZIP                            TEXT("ZIP")
#define   REGVAL_COUNTRY                        TEXT("Country")
#define   REGVAL_DEPT                           TEXT("Department")
#define   REGVAL_OFFICE                         TEXT("Office")
#define   REGVAL_HOME_PHONE                     TEXT("HomePhone")
#define   REGVAL_OFFICE_PHONE                   TEXT("OfficePhone")
#define   REGVAL_BILLING_CODE                   TEXT("BillingCode")

#define   REGVAL_COVERPG                        TEXT("CoverPageFile")
#define   REGVAL_LAST_COUNTRYID                 TEXT("LastCountryID")
#define   REGVAL_LAST_RECNAME                   TEXT("LastRecipientName")
#define   REGVAL_LAST_RECNUMBER                 TEXT("LastRecipientNumber")
#define   REGVAL_USE_DIALING_RULES              TEXT("LastUseDialingRules")
#define   REGVAL_USE_OUTBOUND_ROUTING           TEXT("LastUseOutboundRouting")
#define   REGVAL_STRESS_INDEX                   TEXT("LastStressPrinterIndex")
#define   REGVAL_NEXT_COVERPAGE_TIP             TEXT("NextCoverPageTip")

#define   REGVAL_RECEIPT_NO_RECEIPT             TEXT("ReceiptNoRecipt")
#define   REGVAL_RECEIPT_GRP_PARENT             TEXT("ReceiptGroupParent")
#define   REGVAL_RECEIPT_MSGBOX                 TEXT("ReceiptMessageBox")
#define   REGVAL_RECEIPT_EMAIL                  TEXT("ReceiptEMail")
#define   REGVAL_RECEIPT_ADDRESS                TEXT("ReceiptAddress")
#define   REGVAL_RECEIPT_ATTACH_FAX             TEXT("ReceiptAttachFax")
//
// Status UI configuration values
//
#define   REGVAL_DEVICE_TO_MONITOR              TEXT("DeviceToMonitor") // device ID for monitoring
#define   REGVAL_MONITOR_ON_SEND                TEXT("MonitorOnSend")
#define   REGVAL_MONITOR_ON_RECEIVE             TEXT("MonitorOnReceive")
#define   REGVAL_NOTIFY_PROGRESS                TEXT("NotifyProgress")
#define   REGVAL_NOTIFY_IN_COMPLETE             TEXT("NotifyIncomingCompletion")
#define   REGVAL_NOTIFY_OUT_COMPLETE            TEXT("NotifyOutgoingCompletion")

#define   REGVAL_SOUND_ON_RING                  TEXT("SoundOnRing")
#define   REGVAL_SOUND_ON_RECEIVE               TEXT("SoundOnReceive")
#define   REGVAL_SOUND_ON_SENT                  TEXT("SoundOnSent")
#define   REGVAL_SOUND_ON_ERROR                 TEXT("SoundOnError")

#define   REGVAL_ALWAYS_ON_TOP                  TEXT("AlwaysOnTop")

//
// Fax status monitor and fax notification bar icon contants:
//
#define FAXSTAT_WINCLASS                        TEXT("FaxMonWinClass{3FD224BA-8556-47fb-B260-3E451BAE2793}")    // Window class for fax notification bar messages
#define FAX_SYS_TRAY_DLL                        TEXT("fxsst.dll")   // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                         "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                             // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC               "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();                       // FaxMonitorShutdown type
#define WM_FAXSTAT_CONTROLPANEL                 (WM_USER + 201)     // Fax notification bar configuration has changed
#define WM_FAXSTAT_OPEN_MONITOR                 (WM_USER + 211)     // User explicitly asks for fax status monitor
#define WM_FAXSTAT_INBOX_VIEWED                 (WM_USER + 212)     // Message viewed or deleted in the fax client console's inbox folder
#define WM_FAXSTAT_OUTBOX_VIEWED                (WM_USER + 213)     // Message in error was restarted or deleted in the fax client console's outbox folder
#define WM_FAXSTAT_RECEIVE_NOW                  (WM_USER + 214)     // Start receiving now
#define WM_FAXSTAT_PRINTER_PROPERTY             (WM_USER + 215)     // Open Fax Printer Property Sheet. WPARAM is an initiall page number

//
// Setup information is stored under Fax\Setup subkey
//
#define REGKEY_FAX_SETUP                        REGKEY_FAXSERVER TEXT("\\Setup")
#define REGKEY_FAX_SETUP_SUBKEY                 TEXT("Setup")

#define   REGVAL_CP_LOCATION                    TEXT("CoverPageDir")
#define   REGVAL_FAXINSTALLED                   TEXT("Installed")
#define   REGVAL_PRODUCT_SKU                    TEXT("ProductSKU")
#define   REGVAL_PRODUCT_BUILD                  TEXT("ProductBuild")
#define   REGVAL_SETUP_IN_PROGRESS				TEXT("SetupInProgress")
#define   REGVAL_IS_SHARED_FAX_PRINTER          TEXT("IsFaxPrinterShared")
#define   REGVAL_DONT_UNATTEND_INSTALL          TEXT("DenyUnattendInstall")
#define   REGVAL_FAXINSTALL_TYPE                TEXT("InstallType")
#define   REGVAL_FAXINSTALLED_PLATFORMS         TEXT("InstalledPlatforms")
#define   REGVAL_CFGWZRD_USER_INFO              TEXT("CfgWzdrUserInfo")
#define   REGVAL_CPE_CONVERT                    TEXT("WereCpesConverted")
#define   REGVAL_CFGWZRD_DISABLE_ROUTING        TEXT("DisableRoutingExtensionConfiguration")
#define   REGVAL_IMPORT_INFO                    TEXT("ImportInfoDisplayed")
#define   REGVAL_INSTALLED_COMPONENTS           TEXT("InstalledComponents")
#define   REGVAL_W2K_SENT_ITEMS                 TEXT("W2K_SentItems")
#define   REGVAL_W2K_INBOX                      TEXT("W2K_Inbox")

//
// Client information is stored under Fax\Client subkey
//
#define REGKEY_FAX_CLIENT                        REGKEY_FAXSERVER TEXT("\\Client")
#define REGKEY_FAX_CLIENT_SUBKEY                 TEXT("Client")

#define 	REGVAL_DBGLEVEL                         TEXT("DebugLevel")
#define 	REGVAL_DBGLEVEL_EX                      TEXT("DebugLevelEx")
#define 	REGVAL_DBGFORMAT_EX                     TEXT("DebugFormatEx")
#define 	REGVAL_DBGCONTEXT_EX                    TEXT("DebugContextEx")
#define 	REGVAL_DBG_SKU                          TEXT("DebugSKU")

#define 	REGVAL_SERVER_CP_LOCATION              TEXT("ServerCoverPageDir")
#define 	REGVAL_CFGWZRD_DEVICE                  TEXT("CfgWzdrDevice")
//
// Service startup information is stored under Fax\Client\ServiceStartup subkey
//
#define 	REGKEY_FAX_SERVICESTARTUP               REGKEY_FAX_CLIENT TEXT("\\ServiceStartup")
#define 	REGKEY_FAX_SERVICESTARTUP_SUBKEY        TEXT("ServiceStartup")
#define   		REGVAL_FAX_RPC_READY                  TEXT("RPCReady")




#define DEFAULT_COVERPAGE_EDITOR                FAX_COVER_IMAGE_NAME    // Used by print\faxprint\lib\registry.c
#define DEFAULT_COVERPAGE_DIR                   TEXT("%systemroot%\\Fax\\CoverPg")

#define REGKEY_INSTALLLOCATION                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_DEFAULT_TSID                     TEXT("Fax")
#define REGVAL_DEFAULT_CSID                     TEXT("Fax")

//
// Per-user devmode information is stored under Fax\Devmode subkey
//
#define REGKEY_FAX_DEVMODE                      REGKEY_FAXSERVER TEXT("\\Devmode")
//
// Registry values stored under HKEY_LOCAL_MACHINE
//

//
// Server registry values
// stored under REGKEY_FAXSERVER
//

#define FAX_SVC_EVENT                           TEXT("Microsoft Fax")
#define REGKEY_EVENTLOG                         TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\") FAX_SVC_EVENT

#define   REGVAL_EVENTMSGFILE                   TEXT("EventMessageFile")
#define   REGVAL_CATEGORYMSGFILE                TEXT("CategoryMessageFile")
#define   REGVAL_CATEGORYCOUNT                  TEXT("CategoryCount")
#define   REGVAL_TYPESSUPPORTED                 TEXT("TypesSupported")

#define REGKEY_SOFTWARE                         REGKEY_FAXSERVER

#define   REGVAL_RETRIES                        TEXT("Retries")
#define   REGVAL_RETRYDELAY                     TEXT("Retry Delay")
#define   REGVAL_MANUAL_ANSWER_DEVICE           TEXT("ManualAnswerDevice")
#define   REGVAL_DIRTYDAYS                      TEXT("Dirty Days")
#define   REGVAL_BRANDING                       TEXT("Branding")
#define   REGVAL_USE_DEVICE_TSID                TEXT("UseDeviceTsid")
#define   REGVAL_SERVERCP                       TEXT("ServerCoverPageOnly")
#define   REGVAL_STARTCHEAP                     TEXT("StartCheapTime")
#define   REGVAL_STOPCHEAP                      TEXT("StopCheapTime")
#define   REGVAL_QUEUE_STATE                    TEXT("QueueState")
#define   REGVAL_QUEUE_DIRECTORY                TEXT("QueueDirectory")
#define   REGVAL_JOB_NUMBER                     TEXT("NextJobNumber")
#define   REGVAL_MAX_LINE_CLOSE_TIME            TEXT("MaxLineCloseTime")
#define	  REGVAL_RECIPIENTS_LIMIT		        TEXT("RecipientsLimit")
#define	  REGVAL_ALLOW_REMOTE			        TEXT("AllowRemote")  // Allow remote calls even if printer is not shared.
#define   REGVAL_USE_DEFAULT_FAULT_HANDLING_POLICY  TEXT("UseDefaultFaultHandlingPolicy")
//
// 31 days * 24 hours * 60 minutes * 60 seconds * 1000000 microseconds * 10 (100 ns is one unit)
//
#define   DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME 26784000000000

#define   DEFAULT_REGVAL_RETRIES                3
#define   DEFAULT_REGVAL_RETRYDELAY             10
#define   DEFAULT_REGVAL_DIRTYDAYS              30
#define   DEFAULT_REGVAL_BRANDING               1
#define   DEFAULT_REGVAL_USEDEVICETSID          1
#define   DEFAULT_REGVAL_SERVERCP               0
#define   DEFAULT_REGVAL_STARTCHEAP             MAKELONG(20,0)
#define   DEFAULT_REGVAL_STOPCHEAP              MAKELONG(7,0)
#define   DEFAULT_REGVAL_QUEUE_STATE            0
#define   DEFAULT_REGVAL_JOB_NUMBER             1

#define   REGKEY_DEVICE_PROVIDERS               TEXT("Device Providers")
#define     REGVAL_FRIENDLY_NAME                TEXT("FriendlyName")
#define     REGVAL_IMAGE_NAME                   TEXT("ImageName")
#define     REGVAL_PROVIDER_NAME                TEXT("ProviderName")
#define     REGVAL_PROVIDER_GUID                TEXT("GUID")
#define     REGVAL_PROVIDER_API_VERSION         TEXT("APIVersion")

//
// The following value is the base device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE   DWORD(0x20000)
//
// The following value is the base for our internal unique fax ids
//
#define     DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE        DWORD(0x10000)

//
// How device ids are allocated:
// -----------------------------
// Fax unique devices (allocated by the server), VFSP devices, and EVFSP devices all share
// the same device id space (32-bit = 4GB of ids).
//
// Notice: TAPI permanent line ids (used by FSPs / EFSPs) are not in this space.
//
// Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
//     Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
//     and leave segments allocation to a PM effort here.
//
// Range [DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE ... DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE-1] :
//     Used by the fax server for the unique device ids of TAPI devices discovered by the server.
//
// Range [DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE ... MAXDWORD] : 
// Reserved for future use.
//

// *****************************************************************************
// *****************************************************************************
//                  VFSPs Device ID prefix given so far....
// *****************************************************************************
// 1. DeviceIdPrefix = 0x1. ------> VisionLab    http://VisionLab.com
//
// *****************************************************************************
// *****************************************************************************


#define   REGKEY_RECEIPTS_CONFIG                TEXT("Receipts")    // Key of receipts configuration
#define     REGVAL_RECEIPTS_TYPE                TEXT("Type")        // Receipts supported
#define     REGVAL_RECEIPTS_SERVER              TEXT("Server")      // SMTP Server's name
#define     REGVAL_RECEIPTS_PORT                TEXT("Port")        // SMTP Server's port
#define     REGVAL_RECEIPTS_FROM                TEXT("From")        // SMTP sender address
#define     REGVAL_RECEIPTS_USER                TEXT("User")        // SMTP user name
#define     REGVAL_RECEIPTS_PASSWORD            TEXT("Password")    // SMTP password
#define     REGVAL_RECEIPTS_SMTP_AUTH_TYPE      TEXT("SMTPAuth")    // SMTP authentication type
#define     REGVAL_ISFOR_MSROUTE                TEXT("UseForMsRoute")  // TRUE if to use for MS route through e-mail method

#define     DEFAULT_REGVAL_SMTP_PORT            25                  // Default SMTP port number

#define   REGKEY_ARCHIVE_SENTITEMS_CONFIG       TEXT("SentItems")// Key of SentItems archive configuration
#define   REGKEY_ARCHIVE_INBOX_CONFIG           TEXT("Inbox")    // Key of Inbox archive configuration
#define     REGVAL_ARCHIVE_USE                  TEXT("Use")      // Archive?
#define     REGVAL_ARCHIVE_FOLDER               TEXT("Folder")   // Archive location
#define     REGVAL_ARCHIVE_SIZE_QUOTA_WARNING   TEXT("SizeQuotaWarn") // Warn on size excess?
#define     REGVAL_ARCHIVE_HIGH_WATERMARK       TEXT("HighWatermark") // Warning high watermark
#define     REGVAL_ARCHIVE_LOW_WATERMARK        TEXT("LowWatermark")  // Warning low watermark
#define     REGVAL_ARCHIVE_AGE_LIMIT            TEXT("AgeLimit") // Archive age limit

#define     DEFAULT_REGVAL_ARCHIVE_USE          0        // Don't use archive by default
#define     DEFAULT_REGVAL_ARCHIVE_FOLDER       TEXT("") // Default location of archive
#define     DEFAULT_REGVAL_SIZE_QUOTA_WARNING   1        // Warn on size by default
#define     DEFAULT_REGVAL_HIGH_WATERMARK       100      // High watermark default
#define     DEFAULT_REGVAL_LOW_WATERMARK        95       // Low watermark default
#define     DEFAULT_REGVAL_AGE_LIMIT            60       // Default archive age limit

#define   REGKEY_ACTIVITY_LOG_CONFIG                    TEXT("ActivityLogging")         // Key of Activity Logging configuration
#define     REGVAL_ACTIVITY_LOG_DB                      TEXT("DBFile")                  // Database file
#define     REGVAL_ACTIVITY_LOG_IN                      TEXT("LogIncoming")             // Log incoming faxes?
#define     REGVAL_ACTIVITY_LOG_OUT                     TEXT("LogOutgoing")             // Log outgoing faxes?
#define     REGVAL_ACTIVITY_LOG_LIMIT_CRITERIA          TEXT("LogLimitCriteria")        // The activity log file limitting criteria - Size or Age
#define     REGVAL_ACTIVITY_LOG_SIZE_LIMIT              TEXT("LogSizeLimit")            // The activity log files size limit in MBytes
#define     REGVAL_ACTIVITY_LOG_AGE_LIMIT               TEXT("LogAgeLimit")             // The activity log files age limit in Months
#define     REGVAL_ACTIVITY_LOG_LIMIT_REACHED_ACTION    TEXT("LogLimitReachedAction")   // Delete log file or rename it when file limit reached 

#define   REGKEY_OUTBOUND_ROUTING                   TEXT("Outbound Routing")   // Outbound routing key
#define     REGKEY_OUTBOUND_ROUTING_GROUPS          TEXT("Groups")             // Outbound routing groups key
#define         REGVAL_ROUTING_GROUP_DEVICES        TEXT("Devices")            // List of all group's devices
#define     REGKEY_OUTBOUND_ROUTING_RULES           TEXT("Rules")              // Outbound routing rules key
#define         REGVAL_ROUTING_RULE_COUNTRY_CODE    TEXT("CountryCode")        // Outbound routing rule country code
#define         REGVAL_ROUTING_RULE_AREA_CODE       TEXT("AreaCode")           // Outbound routing rule area code
#define         REGVAL_ROUTING_RULE_GROUP_NAME      TEXT("GroupName")          // Outbound routing rule dest group name
#define         REGVAL_ROUTING_RULE_DEVICE_ID       TEXT("DeviceID")           // Outbound routing rule dest device ID
#define         REGVAL_ROUTING_RULE_USE_GROUP       TEXT("UseGroup")           // Flag inidicating to use group destination

#define   REGKEY_ROUTING_EXTENSIONS             TEXT("Routing Extensions")
#define     REGKEY_ROUTING_METHODS              TEXT("Routing Methods")
#define         REGVAL_FUNCTION_NAME            TEXT("Function Name")
#define         REGVAL_GUID                     TEXT("Guid")
#define         REGVAL_ROUTING_PRIORITY         TEXT("Priority")

#define   REGKEY_UNASSOC_EXTENSION_DATA         TEXT("UnassociatedExtensionData")
#define   REGKEY_DEVICES                        TEXT("Devices")
#define     REGKEY_FAXSVC_DEVICE_GUID           TEXT("{F10A5326-0261-4715-B367-2970427BBD99}")
#define       REGVAL_DEVICE_NAME                TEXT("Device Name")
#define       REGVAL_PROVIDER                   TEXT("Provider Name")
#define       REGVAL_PERMANENT_LINEID           TEXT("Permanent Lineid")
#define       REGVAL_TAPI_PERMANENT_LINEID      TEXT("TAPI Permanent Lineid")

#define       REGVAL_FLAGS                      TEXT("Flags")
#define       REGVAL_RINGS                      TEXT("Rings")
#define       REGVAL_ROUTING_CSID               TEXT("CSID")
#define       REGVAL_ROUTING_TSID               TEXT("TSID")
#define       REGVAL_DEVICE_DESCRIPTION         TEXT("Description")
#define       REGVAL_LAST_DETECTED_TIME         TEXT("LastDetected")
#define       REGVAL_MANUAL_ANSWER              TEXT("ManualAnswer")

#define       REGVAL_LAST_UNIQUE_LINE_ID        TEXT("LastUniqueLineId")

#define   REGKEY_LOGGING                        TEXT("Logging")
#define     REGVAL_CATEGORY_NAME                TEXT("Name")
#define     REGVAL_CATEGORY_LEVEL               TEXT("Level")
#define     REGVAL_CATEGORY_NUMBER              TEXT("Number")

#define   REGKEY_DEVICES_CACHE                  TEXT("Devices Cache")
#define     REGKEY_TAPI_DATA                    TEXT("TAPI Data")

#define REGKEY_TAPIDEVICES_CONFIG               TEXT("TAPIDevices")

#define REGKEY_USERINFO                         TEXT("UserInfo")

#define REGKEY_FAX_LOGGING                      REGKEY_FAXSERVER TEXT("\\") REGKEY_LOGGING
#define REGKEY_FAX_RECEIPTS                     REGKEY_FAXSERVER TEXT("\\") REGKEY_RECEIPTS_CONFIG
#define REGKEY_FAX_INBOX                        REGKEY_FAXSERVER TEXT("\\") REGKEY_ARCHIVE_INBOX_CONFIG
#define REGKEY_FAX_SENTITEMS                    REGKEY_FAXSERVER TEXT("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG
#define REGKEY_FAX_DEVICES                      REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICES
#define REGKEY_FAX_UNASS_DATA					REGKEY_FAX_DEVICES TEXT("\\") REGKEY_UNASSOC_EXTENSION_DATA
#define REGKEY_FAX_DEVICES_CACHE                REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICES_CACHE
#define REGKEY_TAPIDEVICES                      REGKEY_FAXSERVER TEXT("\\") REGKEY_TAPIDEVICES_CONFIG
#define REGKEY_DEVICE_PROVIDER_KEY              REGKEY_FAXSERVER TEXT("\\") REGKEY_DEVICE_PROVIDERS
#define REGKEY_ROUTING_EXTENSION_KEY            REGKEY_FAXSERVER TEXT("\\") REGKEY_ROUTING_EXTENSIONS
#define REGKEY_FAX_USERINFO                     REGKEY_FAXSERVER TEXT("\\") REGKEY_USERINFO
#define REGKEY_FAX_OUTBOUND_ROUTING             REGKEY_FAXSERVER TEXT("\\") REGKEY_OUTBOUND_ROUTING
#define REGKEY_FAX_OUTBOUND_ROUTING_GROUPS      REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\") REGKEY_OUTBOUND_ROUTING_GROUPS
#define REGKEY_FAX_OUTBOUND_ROUTING_RULES       REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\") REGKEY_OUTBOUND_ROUTING_RULES

#define REGKEY_FAX_SETUP_ORIG                   REGKEY_FAX_SETUP TEXT("\\Original Setup Data")
//
// device provider reg values
//
#define REGKEY_MODEM_PROVIDER                   TEXT("Microsoft Modem Device Provider")
#define   REGVAL_T30_PROVIDER_GUID_STRING       TEXT("{2172FD8F-11F6-11d3-90BF-006094EB630B}")
//
// MSFT standard routing methods
//
#define REGKEY_ROUTING_METHOD_EMAIL             TEXT("Email")
#define   REGVAL_RM_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_FOLDER            TEXT("Folder")
#define   REGVAL_RM_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_PRINTING          TEXT("Printing")
#define   REGVAL_RM_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
//
// GUID of routing methods usage flags - used by the Microsoft Fax Routing Extension DLL:
//
#define   REGVAL_RM_FLAGS_GUID                  TEXT("{aacc65ec-0091-40d6-a6f3-a2ed6057e1fa}")
//
// Routing mask bits
//
#define LR_PRINT                                0x00000001
#define LR_STORE                                0x00000002
#define LR_INBOX                                0x00000004
#define LR_EMAIL                                0x00000008
//
// Routing extension reg values
//
#define REGKEY_ROUTING_EXTENSION                TEXT("Microsoft Routing Extension")
//
// Performance key/values
//
#define REGKEY_FAXPERF                          TEXT("SYSTEM\\CurrentControlSet\\Services\\") FAX_SERVICE_NAME TEXT("\\Performance")
#define   REGVAL_OPEN                           TEXT("Open")
#define     REGVAL_OPEN_DATA                    TEXT("OpenFaxPerformanceData")
#define   REGVAL_CLOSE                          TEXT("Close")
#define     REGVAL_CLOSE_DATA                   TEXT("CloseFaxPerformanceData")
#define   REGVAL_COLLECT                        TEXT("Collect")
#define     REGVAL_COLLECT_DATA                 TEXT("CollectFaxPerformanceData")
#define   REGVAL_LIBRARY                        TEXT("Library")
#define     REGVAL_LIBRARY_DATA                 TEXT("%systemroot%\\system32\\fxsperf.dll")
//
// Security descriptors
//
#define REGKEY_SECURITY_CONFIG                  TEXT("Security")
#define REGKEY_FAX_SECURITY                     REGKEY_FAXSERVER TEXT("\\") REGKEY_SECURITY_CONFIG
#define   REGVAL_DESCRIPTOR                     TEXT("Descriptor")

//
// default mail client
//
#define  REGKEY_MAIL_CLIENT     TEXT("SOFTWARE\\Clients\\Mail")
#define  REGVAL_MS_OUTLOOK      TEXT("Microsoft Outlook")

#define  REGKEY_OUTLOOK_CUR_VER TEXT("SOFTWARE\\Classes\\Outlook.Application\\CurVer")

//
// Windows Address Book (WAB) location
//
#define  REGVAL_WABPATH         TEXT("Software\\Microsoft\\WAB\\DLLPath")

//
// Combined translated strings from the wizard to the service
// Format is "{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED<dialable string>{11d0ecca-4072-4c7b-9af1-541d9778375f}<displayable string>"
//
#define COMBINED_PREFIX                         TEXT("{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED")
#define COMBINED_SUFFIX                         TEXT("{11d0ecca-4072-4c7b-9af1-541d9778375f}")
#define COMBINED_TRANSLATED_STRING_FORMAT       COMBINED_PREFIX TEXT("%s") COMBINED_SUFFIX TEXT("%s")
#define COMBINED_TRANSLATED_STRING_EXTRA_LEN    (_tcslen(COMBINED_TRANSLATED_STRING_FORMAT) - 4)

//
// These prefixes are used by all temp preview TIFF files (generated by the client console and the fax send wizard)
//
#define CONSOLE_PREVIEW_TIFF_PREFIX                     TEXT("MSFaxConsoleTempPreview-#")
#define WIZARD_PREVIEW_TIFF_PREFIX                      TEXT("MSFaxWizardTempPreview-#")

#define FAX_ADDERSS_VALID_CHARACTERS                    TEXT("0123456789 -|^!#$*,?@ABCbcdDPTWdptw")

//
// Client console command line parameters.
// All parameters are case insensitive.
//
#define CONSOLE_CMD_FLAG_STR_FOLDER                     TEXT("folder")          // Sets initial startup folder. Usage: "fxsclnt.exe /folder <folder>"
#define CONSOLE_CMD_PRM_STR_OUTBOX                      TEXT("outbox")          // Outbox startup folder. Usage: "fxsclnt.exe /folder outbox"
#define CONSOLE_CMD_PRM_STR_INCOMING                    TEXT("incoming")        // Incoming startup folder. Usage: "fxsclnt.exe /folder incoming"
#define CONSOLE_CMD_PRM_STR_INBOX                       TEXT("inbox")           // Inbox startup folder. Usage: "fxsclnt.exe /folder inbox". This is the default
#define CONSOLE_CMD_PRM_STR_SENT_ITEMS                  TEXT("sent_items")      // sent items startup folder. Usage: "fxsclnt.exe /folder sent_items"

#define CONSOLE_CMD_FLAG_STR_MESSAGE_ID                 TEXT("MessageId")       // Select a message in the startup folder. Usage: "fxsclnt.exe /MessageId 0x0201c0d62f36ec0b"
#define CONSOLE_CMD_FLAG_STR_NEW                        TEXT("New")             // Force a new instance. Usage: "fxsclnt.exe /new"


//
// This is the prefix of optionally non-secure settings.
// For example:
//     In WinXP RTM, extension configuration data was written unencrypted to the registry.
//     In Win .NET Server, the same data is now written encrypted.
//     Since the service code of Win .NET Server is the same as WinXP SP1, the same code
//     should be able to read encrypted AND non-encrypted data.
//
//     If the bOptionallyNonSecure flag is set in the SetRegistrySecureBinary and SetRegistrySecureString
//     functions, the data is encrypted but written to the registry prefixed with FAX_REG_SECURITY_PREFIX.
//
//     If the bOptionallyNonSecure flag is set in the GetRegistrySecureBinary and GetRegistrySecureString
//     functions, the data is read from the registry and checked for a prefix of FAX_REG_SECURITY_PREFIX.
//     If the prefix is not there, the data is considered to be non-encrypted (e.g. WinXP RTM data)
//     and it is returned as-is without decryption. Otherwise, it is properly decrypted.
//
#define FAX_REG_SECURITY_PREFIX TEXT("{5b04adaa-5e01-4160-a61e-02d27d44f9db}")


// This SD is used when setting the security on Fax folders under CSIDL_COMMON_APPDATA:
// 1. When changing locations from the UI
// 2. When upgrading from BOS/SBS2000, and migrating the old archives
// 3. After converting the system partition from FAT to NTFS
//
#define SD_FAX_FOLDERS  TEXT("D:PAI(A;OICI;FA;;;BA)(A;OICI;FA;;;NS)")   // Administrators have full access, Network service have full access

// This SD is used when setting the security on Common Coverpages folder under CSIDL_COMMON_APPDATA:
// 3. After converting the system partition from FAT to NTFS
//
#define SD_COMMON_COVERPAGES  TEXT("D:PAI(A;OICI;FA;;;BA)(A;OICI;0x1200a9;;;WD)")  // Everyone can read, Administrators have full control

#endif  // !_FAXREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\faxsuite.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxSuite.h

Abstract:

    This file provides declaration of the Fax SKU values.

Author:

    Oded Sacher (OdedS)  Dec, 2001

Revision History:

--*/

#ifndef _FAX_SUITE_H
#define _FAX_SUITE_H

typedef enum
{
    PRODUCT_SKU_UNKNOWN             = 0x0000,
    PRODUCT_SKU_PERSONAL            = 0x0001,
    PRODUCT_SKU_PROFESSIONAL        = 0x0002,
    PRODUCT_SKU_SERVER              = 0x0004,
    PRODUCT_SKU_ADVANCED_SERVER     = 0x0008,
    PRODUCT_SKU_DATA_CENTER         = 0x0010,
    PRODUCT_SKU_DESKTOP_EMBEDDED    = 0x0020,
    PRODUCT_SKU_SERVER_EMBEDDED     = 0x0040,
    PRODUCT_SKU_WEB_SERVER          = 0x0080,
    PRODUCT_SERVER_SKUS             = PRODUCT_SKU_SERVER | PRODUCT_SKU_ADVANCED_SERVER | PRODUCT_SKU_DATA_CENTER | PRODUCT_SKU_SERVER_EMBEDDED | PRODUCT_SKU_WEB_SERVER,
    PRODUCT_DESKTOP_SKUS            = PRODUCT_SKU_PERSONAL | PRODUCT_SKU_PROFESSIONAL | PRODUCT_SKU_DESKTOP_EMBEDDED,

    PRODUCT_ALL_SKUS                = 0xFFFF
} PRODUCT_SKU_TYPE;

#endif // _FAX_SUITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds Client Spooler types and prototypes

Author:


Environment:

    User Mode -Win32

Revision History:

    Steve Wilson (NT) (swilson) 1-Jun-95    Ported from spoolss\client\client.h

--*/

#ifndef _SPOOLER_SERVER_CLIENT_H_
#define _SPOOLER_SERVER_CLIENT_H_

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;


typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    DWORD       Status;
    LONG            cThreads;   // InterlockedDecrement/Increment variable for thread synch
    HANDLE      hModule;        // Driver UM DLL Module Handle
    DWORD       (*pfnWrite)();
    HANDLE      (*pfnStartDoc)();
    VOID        (*pfnEndDoc)();
    VOID        (*pfnClose)();
    BOOL        (*pfnStartPage)();
    BOOL        (*pfnEndPage)();
    VOID        (*pfnAbort)();
    HANDLE      hDriver;        // supplied to us by driver UI dll
    DWORD       JobId;
} SPOOL;

//
// Change the RPC buffer size to 64K
//
#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC   0x00000001
#define SPOOL_STATUS_ADDJOB     0x00000002
#define SPOOL_STATUS_ANSI       0x00000004


#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2


DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
);


PNOTIFY
WPCWaitFind(
    HANDLE hFind);

BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    );

VOID
FreeSpool(
    PSPOOL pSpool);

LPVOID
DllAllocSplMem(
    DWORD cb
);


BOOL
DllFreeSplMem(
   LPVOID pMem
);

BOOL
FlushBuffer(
    PSPOOL  pSpool
);

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
);


typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
);

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
);

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        );

LPSTR
StartDocDlgA(
        HANDLE hPrinter,
        DOCINFOA *pDocInfo
        );

#endif // _SPOOLER_SERVER_CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\fxsapip.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, 
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/



#ifndef _FAXAPIP_
#define _FAXAPIP_

#include <FaxUIConstants.h>


#ifndef MIDL_PASS
#include <tapi.h>
#endif

#if !defined(_WINFAX_)
#define WINFAXAPI DECLSPEC_IMPORT
#else
#define WINFAXAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif

//
// FAX ERROR CODES
//

#define FAX_ERR_START                                   7001L   // First fax specific error code

#define FAX_ERR_SRV_OUTOFMEMORY                         7001L
#define FAX_ERR_GROUP_NOT_FOUND                         7002L
#define FAX_ERR_BAD_GROUP_CONFIGURATION                 7003L
#define FAX_ERR_GROUP_IN_USE                            7004L
#define FAX_ERR_RULE_NOT_FOUND                          7005L
#define FAX_ERR_NOT_NTFS                                7006L
#define FAX_ERR_DIRECTORY_IN_USE                        7007L
#define FAX_ERR_FILE_ACCESS_DENIED                      7008L
#define FAX_ERR_MESSAGE_NOT_FOUND                       7009L
#define FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED               7010L
#define FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU               7011L
#define FAX_ERR_VERSION_MISMATCH                        7012L   // Fax client/server versions mismtach
#define	FAX_ERR_RECIPIENTS_LIMIT						7013L	// Recipients limit in a single broadcast

#define FAX_ERR_END                                     7013L   // Last fax specific error code


//
// MessageId: FAX_E_SRV_OUTOFMEMORY
//
// MessageText:
//
//  The fax server failed to allocate memory.
//
#define FAX_E_SRV_OUTOFMEMORY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_SRV_OUTOFMEMORY)

//
// MessageId: FAX_E_GROUP_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing group by name.
//
#define FAX_E_GROUP_NOT_FOUND                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_NOT_FOUND)

//
// MessageId: FAX_E_BAD_GROUP_CONFIGURATION
//
// MessageText:
//
//  The fax server encountered an outbound routing group with bad configuration.
//
#define FAX_E_BAD_GROUP_CONFIGURATION        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_BAD_GROUP_CONFIGURATION)

//
// MessageId: FAX_E_GROUP_IN_USE
//
// MessageText:
//
//  The fax server cannot remove an outbound routing group because it is in use by one or more outbound routing rules.
//
#define FAX_E_GROUP_IN_USE                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_GROUP_IN_USE)

//
// MessageId: FAX_E_RULE_NOT_FOUND
//
// MessageText:
//
//  The fax server failed to locate an outbound routing rule by country code and area code.
//
#define FAX_E_RULE_NOT_FOUND                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_RULE_NOT_FOUND)

//
// MessageId: FAX_E_NOT_NTFS
//
// MessageText:
//
//  The fax server cannot set an archive folder to a non-NTFS partition.
//
#define FAX_E_NOT_NTFS                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_NTFS)

//
// MessageId: FAX_E_DIRECTORY_IN_USE
//
// MessageText:
//
//  The fax server cannot use the same folder for both the inbox and the sent-items archives.
//
#define FAX_E_DIRECTORY_IN_USE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DIRECTORY_IN_USE)

//
// MessageId: FAX_E_FILE_ACCESS_DENIED
//
// MessageText:
//
//  The fax server cannot access the specified file or folder.
//
#define FAX_E_FILE_ACCESS_DENIED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_FILE_ACCESS_DENIED)

//
// MessageId: FAX_E_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  The fax server cannot find the job or message by its ID.
//
#define FAX_E_MESSAGE_NOT_FOUND              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_MESSAGE_NOT_FOUND)

//
// MessageId: FAX_E_DEVICE_NUM_LIMIT_EXCEEDED
//
// MessageText:
//
//  The fax server cannot complete the operation because the number of active fax devices allowed for this version of Windows was exceeded.
//
#define FAX_E_DEVICE_NUM_LIMIT_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED)

//
// MessageId: FAX_E_NOT_SUPPORTED_ON_THIS_SKU
//
// MessageText:
//
//  The fax server cannot complete the operation because it is not supported for this version of Windows.
//
#define FAX_E_NOT_SUPPORTED_ON_THIS_SKU      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU)

//
// MessageId: FAX_E_VERSION_MISMATCH
//
// MessageText:
//
//  The fax server API version does not support the requested operation.
//
#define FAX_E_VERSION_MISMATCH               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_VERSION_MISMATCH)

//
// MessageId: FAX_E_RECIPIENT_LIMIT
//
// MessageText:
//
// The limit on the number of recipients for a single fax broadcast was reached.
//
#define FAX_E_RECIPIENTS_LIMIT               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, FAX_ERR_RECIPIENTS_LIMIT)

typedef enum
{
    FAXLOG_LEVEL_NONE            = 0,
    FAXLOG_LEVEL_MIN,
    FAXLOG_LEVEL_MED,
    FAXLOG_LEVEL_MAX
} FAX_ENUM_LOG_LEVELS;

typedef enum
{
    FAXLOG_CATEGORY_INIT        = 1,        // Initialization / shutdown
    FAXLOG_CATEGORY_OUTBOUND,               // Outbound messages
    FAXLOG_CATEGORY_INBOUND,                // Inbound messages
    FAXLOG_CATEGORY_UNKNOWN                 // Unknown category (all others)
} FAX_ENUM_LOG_CATEGORIES;

typedef struct _FAX_LOG_CATEGORYA
{
    LPCSTR              Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYA, *PFAX_LOG_CATEGORYA;
typedef struct _FAX_LOG_CATEGORYW
{
    LPCWSTR             Name;                       // logging category name
    DWORD               Category;                   // logging category number
    DWORD               Level;                      // logging level for the category
} FAX_LOG_CATEGORYW, *PFAX_LOG_CATEGORYW;
#ifdef UNICODE
typedef FAX_LOG_CATEGORYW FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYW PFAX_LOG_CATEGORY;
#else
typedef FAX_LOG_CATEGORYA FAX_LOG_CATEGORY;
typedef PFAX_LOG_CATEGORYA PFAX_LOG_CATEGORY;
#endif // UNICODE

typedef struct _FAX_TIME
{
    WORD    Hour;
    WORD    Minute;
} FAX_TIME, *PFAX_TIME;

typedef struct _FAX_CONFIGURATIONA
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCSTR              ArchiveDirectory;               // archive directory for outgoing faxes
    LPCSTR              Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONA, *PFAX_CONFIGURATIONA;
typedef struct _FAX_CONFIGURATIONW
{
    DWORD               SizeOfStruct;                   // size of this structure
    DWORD               Retries;                        // number of retries for fax send
    DWORD               RetryDelay;                     // number of minutes between retries
    DWORD               DirtyDays;                      // number of days to keep an unsent job in the queue
    BOOL                Branding;                       // fsp should brand outgoing faxes
    BOOL                UseDeviceTsid;                  // server uses device tsid only
    BOOL                ServerCp;                       // clients must use cover pages on the server
    BOOL                PauseServerQueue;               // is the server queue paused?
    FAX_TIME            StartCheapTime;                 // start of discount rate period
    FAX_TIME            StopCheapTime;                  // end of discount rate period
    BOOL                ArchiveOutgoingFaxes;           // whether outgoing faxes should be archived
    LPCWSTR             ArchiveDirectory;               // archive directory for outgoing faxes
    LPCWSTR             Reserved;                       // Reserved; must be NULL
} FAX_CONFIGURATIONW, *PFAX_CONFIGURATIONW;
#ifdef UNICODE
typedef FAX_CONFIGURATIONW FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONW PFAX_CONFIGURATION;
#else
typedef FAX_CONFIGURATIONA FAX_CONFIGURATION;
typedef PFAX_CONFIGURATIONA PFAX_CONFIGURATION;
#endif // UNICODE


//
// FaxSetJob() command codes
//

typedef enum
{
    JC_UNKNOWN      = 0,
    JC_DELETE,
    JC_PAUSE,
    JC_RESUME
} FAX_ENUM_JOB_COMMANDS;

#define JC_RESTART   JC_RESUME


//
// job type defines
//

//
// NOTICE: JT_* and JS_* are different from the Win2K public constants.
//         If you use WinFax.h and/or the Win2K COM interfaces, you get the Win2K constants.
//         If you use fxsapip.h, you get the Whistler constants.
//
//         NEVER MIX THEM !!!
//
typedef enum
{
    JT_UNKNOWN                  = 0x0001,       // Fax type is not determined yet
    JT_SEND                     = 0x0002,       // Outgoing fax message
    JT_RECEIVE                  = 0x0004,       // Incoming fax message
    JT_ROUTING                  = 0x0008,       // Incoming message - being routed
    JT_FAIL_RECEIVE             = 0x0010,       // Fail receive job (legacy support only)
    JT_BROADCAST                = 0x0020        // Outgoing broadcast message
} FAX_ENUM_JOB_TYPES;

//
// job status defines
//

#define JS_PENDING                  0x00000001
#define JS_INPROGRESS               0x00000002
#define JS_DELETING                 0x00000004
#define JS_FAILED                   0x00000008
#define JS_PAUSED                   0x00000010
#define JS_NOLINE                   0x00000020
#define JS_RETRYING                 0x00000040
#define JS_RETRIES_EXCEEDED         0x00000080


typedef struct _FAX_DEVICE_STATUSA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              CallerId;                   // caller id string
    LPCSTR              Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCSTR              DeviceName;                 // device name
    LPCSTR              DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCSTR              PhoneNumber;                // sending phone number
    LPCSTR              RoutingString;              // routing information
    LPCSTR              SenderName;                 // sender name
    LPCSTR              RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCSTR              StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCSTR              Tsid;                       // transmitting station identifier
    LPCSTR              UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSA, *PFAX_DEVICE_STATUSA;
typedef struct _FAX_DEVICE_STATUSW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             CallerId;                   // caller id string
    LPCWSTR             Csid;                       // station identifier
    DWORD               CurrentPage;                // current page
    DWORD               DeviceId;                   // permanent line id
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             DocumentName;               // document name
    DWORD               JobType;                    // send or receive?
    LPCWSTR             PhoneNumber;                // sending phone number
    LPCWSTR             RoutingString;              // routing information
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             RecipientName;              // recipient name
    DWORD               Size;                       // size in bytes of the document
    FILETIME            StartTime;                  // starting time of the fax send/receive
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    LPCWSTR             StatusString;               // status string if the Status field is zero.  this may be NULL.
    FILETIME            SubmittedTime;              // time the document was submitted
    DWORD               TotalPages;                 // total number of pages in this job
    LPCWSTR             Tsid;                       // transmitting station identifier
    LPCWSTR             UserName;                   // user that submitted the active job
} FAX_DEVICE_STATUSW, *PFAX_DEVICE_STATUSW;
#ifdef UNICODE
typedef FAX_DEVICE_STATUSW FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSW PFAX_DEVICE_STATUS;
#else
typedef FAX_DEVICE_STATUSA FAX_DEVICE_STATUS;
typedef PFAX_DEVICE_STATUSA PFAX_DEVICE_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRYA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCSTR              UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name
} FAX_JOB_ENTRYA, *PFAX_JOB_ENTRYA;
typedef struct _FAX_JOB_ENTRYW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               JobId;                      // fax job id
    LPCWSTR             UserName;                   // user who submitted the job
    DWORD               JobType;                    // job type, see JT defines
    DWORD               QueueStatus;                // job queue status, see JS defines
    DWORD               Status;                     // current status of the device, see FPS_??? masks
    DWORD               Size;                       // size in bytes of the document
    DWORD               PageCount;                  // total page count
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name
} FAX_JOB_ENTRYW, *PFAX_JOB_ENTRYW;
#ifdef UNICODE
typedef FAX_JOB_ENTRYW FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYW PFAX_JOB_ENTRY;
#else
typedef FAX_JOB_ENTRYA FAX_JOB_ENTRY;
typedef PFAX_JOB_ENTRYA PFAX_JOB_ENTRY;
#endif // UNICODE

//
// fax port state masks
//
// if you change these defines the be sure to
// change the resources in the fax service.
//

#define FPS_DIALING              0x20000001
#define FPS_SENDING              0x20000002
#define FPS_RECEIVING            0x20000004
#define FPS_COMPLETED            0x20000008
#define FPS_HANDLED              0x20000010
#define FPS_UNAVAILABLE          0x20000020
#define FPS_BUSY                 0x20000040
#define FPS_NO_ANSWER            0x20000080
#define FPS_BAD_ADDRESS          0x20000100
#define FPS_NO_DIAL_TONE         0x20000200
#define FPS_DISCONNECTED         0x20000400
#define FPS_FATAL_ERROR          0x20000800
#define FPS_NOT_FAX_CALL         0x20001000
#define FPS_CALL_DELAYED         0x20002000
#define FPS_CALL_BLACKLISTED     0x20004000
#define FPS_INITIALIZING         0x20008000
#define FPS_OFFLINE              0x20010000
#define FPS_RINGING              0x20020000

#define FPS_AVAILABLE            0x20100000
#define FPS_ABORTING             0x20200000
#define FPS_ROUTING              0x20400000
#define FPS_ANSWERED             0x20800000

//
// fax port capability mask
//

#define FPF_RECEIVE       0x00000001        // Automatically receive faxes
#define FPF_SEND          0x00000002
#define FPF_VIRTUAL       0x00000004

typedef struct _FAX_PORT_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCSTR              DeviceName;                 // Device name
    LPCSTR              Tsid;                       // Device Tsid
    LPCSTR              Csid;                       // Device Csid
} FAX_PORT_INFOA, *PFAX_PORT_INFOA;
typedef struct _FAX_PORT_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // Device ID
    DWORD               State;                      // State of the device
    DWORD               Flags;                      // Device specific flags
    DWORD               Rings;                      // Number of rings before answer
    DWORD               Priority;                   // Device priority
    LPCWSTR             DeviceName;                 // Device name
    LPCWSTR             Tsid;                       // Device Tsid
    LPCWSTR             Csid;                       // Device Csid
} FAX_PORT_INFOW, *PFAX_PORT_INFOW;
#ifdef UNICODE
typedef FAX_PORT_INFOW FAX_PORT_INFO;
typedef PFAX_PORT_INFOW PFAX_PORT_INFO;
#else
typedef FAX_PORT_INFOA FAX_PORT_INFO;
typedef PFAX_PORT_INFOA PFAX_PORT_INFO;
#endif // UNICODE


typedef struct _FAX_ROUTING_METHODA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCSTR              DeviceName;                 // device name
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODA, *PFAX_ROUTING_METHODA;
typedef struct _FAX_ROUTING_METHODW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               DeviceId;                   // device identifier
    BOOL                Enabled;                    // is this method enabled for this device?
    LPCWSTR             DeviceName;                 // device name
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_ROUTING_METHODW, *PFAX_ROUTING_METHODW;
#ifdef UNICODE
typedef FAX_ROUTING_METHODW FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODW PFAX_ROUTING_METHOD;
#else
typedef FAX_ROUTING_METHODA FAX_ROUTING_METHOD;
typedef PFAX_ROUTING_METHODA PFAX_ROUTING_METHOD;
#endif // UNICODE


typedef struct _FAX_GLOBAL_ROUTING_INFOA
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCSTR              Guid;                       // guid that identifies this routing method
    LPCSTR              FriendlyName;               // friendly name for this method
    LPCSTR              FunctionName;               // exported function name that identifies this method
    LPCSTR              ExtensionImageName;         // module (dll) name that implements this method
    LPCSTR              ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOA, *PFAX_GLOBAL_ROUTING_INFOA;
typedef struct _FAX_GLOBAL_ROUTING_INFOW
{
    DWORD               SizeOfStruct;               // size of this structure
    DWORD               Priority;                   // priority of this device
    LPCWSTR             Guid;                       // guid that identifies this routing method
    LPCWSTR             FriendlyName;               // friendly name for this method
    LPCWSTR             FunctionName;               // exported function name that identifies this method
    LPCWSTR             ExtensionImageName;         // module (dll) name that implements this method
    LPCWSTR             ExtensionFriendlyName;      // displayable string that identifies the extension
} FAX_GLOBAL_ROUTING_INFOW, *PFAX_GLOBAL_ROUTING_INFOW;
#ifdef UNICODE
typedef FAX_GLOBAL_ROUTING_INFOW FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOW PFAX_GLOBAL_ROUTING_INFO;
#else
typedef FAX_GLOBAL_ROUTING_INFOA FAX_GLOBAL_ROUTING_INFO;
typedef PFAX_GLOBAL_ROUTING_INFOA PFAX_GLOBAL_ROUTING_INFO;
#endif // UNICODE


typedef struct _FAX_COVERPAGE_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCSTR              CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCSTR              RecName;                    //
    LPCSTR              RecFaxNumber;               //
    LPCSTR              RecCompany;                 //
    LPCSTR              RecStreetAddress;           //
    LPCSTR              RecCity;                    //
    LPCSTR              RecState;                   //
    LPCSTR              RecZip;                     //
    LPCSTR              RecCountry;                 //
    LPCSTR              RecTitle;                   //
    LPCSTR              RecDepartment;              //
    LPCSTR              RecOfficeLocation;          //
    LPCSTR              RecHomePhone;               //
    LPCSTR              RecOfficePhone;             //
    //
    // Sender information
    //
    LPCSTR              SdrName;                    //
    LPCSTR              SdrFaxNumber;               //
    LPCSTR              SdrCompany;                 //
    LPCSTR              SdrAddress;                 //
    LPCSTR              SdrTitle;                   //
    LPCSTR              SdrDepartment;              //
    LPCSTR              SdrOfficeLocation;          //
    LPCSTR              SdrHomePhone;               //
    LPCSTR              SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCSTR              Note;                       //
    LPCSTR              Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOA, *PFAX_COVERPAGE_INFOA;
typedef struct _FAX_COVERPAGE_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW, *PFAX_COVERPAGE_INFOW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFOW FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOW PFAX_COVERPAGE_INFO;
#else
typedef FAX_COVERPAGE_INFOA FAX_COVERPAGE_INFO;
typedef PFAX_COVERPAGE_INFOA PFAX_COVERPAGE_INFO;
#endif // UNICODE

typedef enum
{
    JSA_NOW                  = 0,   // Send now
    JSA_SPECIFIC_TIME,              // Send at specific time
    JSA_DISCOUNT_PERIOD             // Send at server configured discount period
} FAX_ENUM_JOB_SEND_ATTRIBUTES;
typedef enum
{
    DRT_NONE                = 0x0000,       // Do not send receipt
    DRT_EMAIL               = 0x0001,       // Send receipt by email (SMTP)
    DRT_UNUSED              = 0x0002,       // Reserved
    DRT_MSGBOX              = 0x0004,       // Send receipt by a message box
    DRT_GRP_PARENT          = 0x0008,       // Send a single receipt for a broadcast job
    DRT_ATTACH_FAX          = 0x0010        // Attach the fax tiff file to the receipt
} FAX_ENUM_DELIVERY_REPORT_TYPES;


#define DRT_ALL         (DRT_EMAIL | DRT_MSGBOX)            // All possible delivery report types
#define DRT_MODIFIERS   (DRT_GRP_PARENT | DRT_ATTACH_FAX)   // All state modifiers


//
// the reserved fields are private data used
// by the fax monitor and winfax.
//
//
// Reserved[0] == 0xffffffff
// Reserved[1] == Print job id
//
// Reserved[0] == 0xfffffffe   start of a broadcast job
//

typedef struct _FAX_JOB_PARAMA
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCSTR              RecipientNumber;            // recipient fax number
    LPCSTR              RecipientName;              // recipient name
    LPCSTR              Tsid;                       // transmitter's id
    LPCSTR              SenderName;                 // sender name
    LPCSTR              SenderCompany;              // sender company
    LPCSTR              SenderDept;                 // sender department
    LPCSTR              BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCSTR              DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCSTR              DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMA, *PFAX_JOB_PARAMA;
typedef struct _FAX_JOB_PARAMW
{
    DWORD               SizeOfStruct;               // size of this structure
    LPCWSTR             RecipientNumber;            // recipient fax number
    LPCWSTR             RecipientName;              // recipient name
    LPCWSTR             Tsid;                       // transmitter's id
    LPCWSTR             SenderName;                 // sender name
    LPCWSTR             SenderCompany;              // sender company
    LPCWSTR             SenderDept;                 // sender department
    LPCWSTR             BillingCode;                // billing code
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    SYSTEMTIME          ScheduleTime;               // time to send the fax when JSA_SPECIFIC_TIME is used (must be local time)
    DWORD               DeliveryReportType;         // delivery report type, see DRT defines
    LPCWSTR             DeliveryReportAddress;      // email address for delivery report (ndr or dr) thru MAPI / SMTP
    LPCWSTR             DocumentName;               // document name (optional)
    HCALL               CallHandle;                 // optional call handle
    DWORD_PTR           Reserved[3];                // reserved for ms use only
} FAX_JOB_PARAMW, *PFAX_JOB_PARAMW;
#ifdef UNICODE
typedef FAX_JOB_PARAMW FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMW PFAX_JOB_PARAM;
#else
typedef FAX_JOB_PARAMA FAX_JOB_PARAM;
typedef PFAX_JOB_PARAMA PFAX_JOB_PARAM;
#endif // UNICODE

//
// Event Ids
//
// FEI_NEVENTS is the number of events
//

#define FEI_DIALING                 0x00000001
#define FEI_SENDING                 0x00000002
#define FEI_RECEIVING               0x00000003
#define FEI_COMPLETED               0x00000004
#define FEI_BUSY                    0x00000005
#define FEI_NO_ANSWER               0x00000006
#define FEI_BAD_ADDRESS             0x00000007
#define FEI_NO_DIAL_TONE            0x00000008
#define FEI_DISCONNECTED            0x00000009
#define FEI_FATAL_ERROR             0x0000000a
#define FEI_NOT_FAX_CALL            0x0000000b
#define FEI_CALL_DELAYED            0x0000000c
#define FEI_CALL_BLACKLISTED        0x0000000d
#define FEI_RINGING                 0x0000000e
#define FEI_ABORTING                0x0000000f
#define FEI_ROUTING                 0x00000010
#define FEI_MODEM_POWERED_ON        0x00000011
#define FEI_MODEM_POWERED_OFF       0x00000012
#define FEI_IDLE                    0x00000013
#define FEI_FAXSVC_ENDED            0x00000014
#define FEI_ANSWERED                0x00000015
#define FEI_JOB_QUEUED              0x00000016
#define FEI_DELETED                 0x00000017
#define FEI_INITIALIZING            0x00000018
#define FEI_LINE_UNAVAILABLE        0x00000019
#define FEI_HANDLED                 0x0000001a
#define FEI_FAXSVC_STARTED          0x0000001b

#define FEI_NEVENTS                 FEI_FAXSVC_STARTED

typedef struct _FAX_EVENTA
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTA, *PFAX_EVENTA;
typedef struct _FAX_EVENTW
{
    DWORD               SizeOfStruct;               // Size of this structure
    FILETIME            TimeStamp;                  // Timestamp for when the event was generated
    DWORD               DeviceId;                   // Permanent line id
    DWORD               EventId;                    // Current event id
    DWORD               JobId;                      // Fax Job Id, 0xffffffff indicates inactive job
} FAX_EVENTW, *PFAX_EVENTW;
#ifdef UNICODE
typedef FAX_EVENTW FAX_EVENT;
typedef PFAX_EVENTW PFAX_EVENT;
#else
typedef FAX_EVENTA FAX_EVENT;
typedef PFAX_EVENTA PFAX_EVENT;
#endif // UNICODE


typedef struct _FAX_PRINT_INFOA
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCSTR              DocName;                    // Document name that appears in the spooler
    LPCSTR              RecipientName;              // Recipient name
    LPCSTR              RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCSTR              SenderName;                 // Sender name
    LPCSTR              SenderCompany;              // Sender company (optional)
    LPCSTR              SenderDept;                 // Sender department
    LPCSTR              SenderBillingCode;          // Billing code
    LPCSTR              Reserved;                   // Reserved; must be NULL
    LPCSTR              DrEmailAddress;             // E.Mail address for delivery report
    LPCSTR              OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOA, *PFAX_PRINT_INFOA;
typedef struct _FAX_PRINT_INFOW
{
    DWORD               SizeOfStruct;               // Size of this structure
    LPCWSTR             DocName;                    // Document name that appears in the spooler
    LPCWSTR             RecipientName;              // Recipient name
    LPCWSTR             RecipientNumber;            // Recipient fax number (non-canonical number)
    LPCWSTR             SenderName;                 // Sender name
    LPCWSTR             SenderCompany;              // Sender company (optional)
    LPCWSTR             SenderDept;                 // Sender department
    LPCWSTR             SenderBillingCode;          // Billing code
    LPCWSTR             Reserved;                   // Reserved; must be NULL
    LPCWSTR             DrEmailAddress;             // E.Mail address for delivery report
    LPCWSTR             OutputFileName;             // for print to file, resulting file name
} FAX_PRINT_INFOW, *PFAX_PRINT_INFOW;
#ifdef UNICODE
typedef FAX_PRINT_INFOW FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOW PFAX_PRINT_INFO;
#else
typedef FAX_PRINT_INFOA FAX_PRINT_INFO;
typedef PFAX_PRINT_INFOA PFAX_PRINT_INFO;
#endif // UNICODE


typedef struct _FAX_CONTEXT_INFOA
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    CHAR                ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOA, *PFAX_CONTEXT_INFOA;
typedef struct _FAX_CONTEXT_INFOW
{
    DWORD               SizeOfStruct;                           // Size of this structure
    HDC                 hDC;                                    // Device Context
    WCHAR               ServerName[MAX_COMPUTERNAME_LENGTH+1];  // Server name
} FAX_CONTEXT_INFOW, *PFAX_CONTEXT_INFOW;
#ifdef UNICODE
typedef FAX_CONTEXT_INFOW FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOW PFAX_CONTEXT_INFO;
#else
typedef FAX_CONTEXT_INFOA FAX_CONTEXT_INFO;
typedef PFAX_CONTEXT_INFOA PFAX_CONTEXT_INFO;
#endif // UNICODE


//
// prototypes
//

WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerA(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
WINFAXAPI
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define FaxConnectFaxServer  FaxConnectFaxServerW
#else
#define FaxConnectFaxServer  FaxConnectFaxServerA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERA)(
    IN  LPCSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
typedef BOOL
(WINAPI *PFAXCONNECTFAXSERVERW)(
    IN  LPCWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    );
#ifdef UNICODE
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERW
#else
#define PFAXCONNECTFAXSERVER  PFAXCONNECTFAXSERVERA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXCLOSE)(
    IN HANDLE FaxHandle
    );

typedef enum
{
    PORT_OPEN_QUERY     = 1,
    PORT_OPEN_MODIFY
} FAX_ENUM_PORT_OPEN_TYPE;

WINFAXAPI
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

typedef BOOL
(WINAPI *PFAXOPENPORT)(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    );

WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define FaxCompleteJobParams  FaxCompleteJobParamsW
#else
#define FaxCompleteJobParams  FaxCompleteJobParamsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSA)(
    IN OUT PFAX_JOB_PARAMA *JobParams,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfo
    );
typedef BOOL
(WINAPI *PFAXCOMPLETEJOBPARAMSW)(
    IN OUT PFAX_JOB_PARAMW *JobParams,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfo
    );
#ifdef UNICODE
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSW
#else
#define PFAXCOMPLETEJOBPARAMS  PFAXCOMPLETEJOBPARAMSA
#endif // !UNICODE



WINFAXAPI
BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define FaxSendDocument  FaxSendDocumentW
#else
#define FaxSendDocument  FaxSendDocumentA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTA)(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN PFAX_JOB_PARAMA JobParams,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTW)(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN PFAX_JOB_PARAMW JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo, OPTIONAL
    OUT LPDWORD FaxJobId OPTIONAL
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTW
#else
#define PFAXSENDDOCUMENT  PFAXSENDDOCUMENTA
#endif // !UNICODE

typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKA)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMA JobParams,
    IN OUT PFAX_COVERPAGE_INFOA CoverpageInfo OPTIONAL
    );
typedef BOOL
(CALLBACK *PFAX_RECIPIENT_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN OUT PFAX_JOB_PARAMW JobParams,
    IN OUT PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
    );
#ifdef UNICODE
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKW
#else
#define PFAX_RECIPIENT_CALLBACK  PFAX_RECIPIENT_CALLBACKA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    );
WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    );
#ifdef UNICODE
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastW
#else
#define FaxSendDocumentForBroadcast  FaxSendDocumentForBroadcastA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTA)(
    IN  HANDLE FaxHandle,
    IN  LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN  LPVOID Context
    );
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTFORBROADCASTW)(
    IN  HANDLE FaxHandle,
    IN  LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN  LPVOID Context
    );
#ifdef UNICODE
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTW
#else
#define PFAXSENDDOCUMENTFORBROADCAST  PFAXSENDDOCUMENTFORBROADCASTA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntry
   );
WINFAXAPI
BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   );
#ifdef UNICODE
#define FaxSetJob  FaxSetJobW
#else
#define FaxSetJob  FaxSetJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETJOBA)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYA *JobEntry
    );
typedef BOOL
(WINAPI *PFAXSETJOBW)(
    IN HANDLE FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    );
#ifdef UNICODE
#define PFAXSETJOB  PFAXSETJOBW
#else
#define PFAXSETJOB  PFAXSETJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

typedef BOOL
(WINAPI *PFAXGETPAGEDATA)(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   );

WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
WINFAXAPI
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define FaxGetDeviceStatus  FaxGetDeviceStatusW
#else
#define FaxGetDeviceStatus  FaxGetDeviceStatusA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    );
typedef BOOL
(WINAPI *PFAXGETDEVICESTATUSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    );
#ifdef UNICODE
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSW
#else
#define PFAXGETDEVICESTATUS  PFAXGETDEVICESTATUSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

typedef BOOL
(WINAPI *PFAXABORT)(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    );

WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationA(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxGetConfigurationW(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxGetConfiguration  FaxGetConfigurationW
#else
#define FaxGetConfiguration  FaxGetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXGETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONW
#else
#define PFAXGETCONFIGURATION  PFAXGETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationA(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
WINFAXAPI
BOOL
WINAPI
FaxSetConfigurationW(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define FaxSetConfiguration  FaxSetConfigurationW
#else
#define FaxSetConfiguration  FaxSetConfigurationA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONA *FaxConfig
    );
typedef BOOL
(WINAPI *PFAXSETCONFIGURATIONW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_CONFIGURATIONW *FaxConfig
    );
#ifdef UNICODE
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONW
#else
#define PFAXSETCONFIGURATION  PFAXSETCONFIGURATIONA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesW
#else
#define FaxGetLoggingCategories  FaxGetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXGETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESW
#else
#define PFAXGETLOGGINGCATEGORIES  PFAXGETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
WINFAXAPI
BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesW
#else
#define FaxSetLoggingCategories  FaxSetLoggingCategoriesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESA)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    );
typedef BOOL
(WINAPI *PFAXSETLOGGINGCATEGORIESW)(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    );
#ifdef UNICODE
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESW
#else
#define PFAXSETLOGGINGCATEGORIES  PFAXSETLOGGINGCATEGORIESA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define FaxEnumPorts  FaxEnumPortsW
#else
#define FaxEnumPorts  FaxEnumPortsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMPORTSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfo,
    OUT LPDWORD PortsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMPORTSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfo,
    OUT LPDWORD PortsReturned
    );
#ifdef UNICODE
#define PFAXENUMPORTS  PFAXENUMPORTSW
#else
#define PFAXENUMPORTS  PFAXENUMPORTSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetPortA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxGetPort  FaxGetPortW
#else
#define FaxGetPort  FaxGetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETPORTA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXGETPORTW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXGETPORT  PFAXGETPORTW
#else
#define PFAXGETPORT  PFAXGETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortA(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define FaxSetPort  FaxSetPortW
#else
#define FaxSetPort  FaxSetPortA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETPORTA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOA *PortInfo
    );
typedef BOOL
(WINAPI *PFAXSETPORTW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_PORT_INFOW *PortInfo
    );
#ifdef UNICODE
#define PFAXSETPORT  PFAXSETPORTW
#else
#define PFAXSETPORT  PFAXSETPORTA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsW
#else
#define FaxEnumRoutingMethods  FaxEnumRoutingMethodsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSA)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMROUTINGMETHODSW)(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingMethod,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSW
#else
#define PFAXENUMROUTINGMETHODS  PFAXENUMROUTINGMETHODSA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
WINFAXAPI
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodW
#else
#define FaxEnableRoutingMethod  FaxEnableRoutingMethodA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  BOOL Enabled
    );
typedef BOOL
(WINAPI *PFAXENABLEROUTINGMETHODW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  BOOL Enabled
    );
#ifdef UNICODE
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODW
#else
#define PFAXENABLEROUTINGMETHOD  PFAXENABLEROUTINGMETHODA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoW
#else
#define FaxEnumGlobalRoutingInfo  FaxEnumGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
typedef BOOL
(WINAPI *PFAXENUMGLOBALROUTINGINFOW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo,
    OUT LPDWORD MethodsReturned
    );
#ifdef UNICODE
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOW
#else
#define PFAXENUMGLOBALROUTINGINFO  PFAXENUMGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoW
#else
#define FaxSetGlobalRoutingInfo  FaxSetGlobalRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    );
typedef BOOL
(WINAPI *PFAXSETGLOBALROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    );
#ifdef UNICODE
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOW
#else
#define PFAXSETGLOBALROUTINGINFO  PFAXSETGLOBALROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxGetRoutingInfo  FaxGetRoutingInfoW
#else
#define FaxGetRoutingInfo  FaxGetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXGETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOW
#else
#define PFAXGETROUTINGINFO  PFAXGETROUTINGINFOA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoA(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
WINFAXAPI
BOOL
WINAPI
FaxSetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define FaxSetRoutingInfo  FaxSetRoutingInfoW
#else
#define FaxSetRoutingInfo  FaxSetRoutingInfoA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETROUTINGINFOA)(
    IN  HANDLE FaxPortHandle,
    IN  LPCSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
typedef BOOL
(WINAPI *PFAXSETROUTINGINFOW)(
    IN  HANDLE FaxPortHandle,
    IN  LPCWSTR RoutingGuid,
    IN  const BYTE *RoutingInfoBuffer,
    IN  DWORD RoutingInfoBufferSize
    );
#ifdef UNICODE
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOW
#else
#define PFAXSETROUTINGINFO  PFAXSETROUTINGINFOA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRelease(
    IN HANDLE FaxHandle
    );

typedef BOOL
(WINAPI *PFAXRELEASE)(
    IN HANDLE FaxHandle
    );

BOOL
FXSAPIInitialize(
    VOID
    );

VOID
FXSAPIFree(
    VOID
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2A
(
    IN  LPCSTR                 PrinterName,
    IN  const FAX_PRINT_INFOA    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOA       FaxContextInfo
);
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJob2W
(
    IN  LPCWSTR                 PrinterName,
    IN  const FAX_PRINT_INFOW    *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFOW       FaxContextInfo
);
#ifdef UNICODE
#define FaxStartPrintJob2  FaxStartPrintJob2W
#else
#define FaxStartPrintJob2  FaxStartPrintJob2A
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

typedef BOOL
(WINAPI *PFAXINITIALIZEEVENTQUEUE)(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    );

WINFAXAPI
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    );

typedef VOID
(WINAPI *PFAXFREEBUFFER)(
    LPVOID Buffer
    );

WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define FaxStartPrintJob  FaxStartPrintJobW
#else
#define FaxStartPrintJob  FaxStartPrintJobA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBA)(
    IN  LPCSTR PrinterName,
    IN  const FAX_PRINT_INFOA *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOA FaxContextInfo
    );
typedef BOOL
(WINAPI *PFAXSTARTPRINTJOBW)(
    IN  LPCWSTR PrinterName,
    IN  const FAX_PRINT_INFOW *PrintInfo,
    OUT LPDWORD FaxJobId,
    OUT PFAX_CONTEXT_INFOW FaxContextInfo
    );
#ifdef UNICODE
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBW
#else
#define PFAXSTARTPRINTJOB  PFAXSTARTPRINTJOBA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define FaxPrintCoverPage  FaxPrintCoverPageW
#else
#define FaxPrintCoverPage  FaxPrintCoverPageA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEA)(
    IN const FAX_CONTEXT_INFOA *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    );
typedef BOOL
(WINAPI *PFAXPRINTCOVERPAGEW)(
    IN const FAX_CONTEXT_INFOW *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    );
#ifdef UNICODE
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEW
#else
#define PFAXPRINTCOVERPAGE  PFAXPRINTCOVERPAGEA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define FaxRegisterServiceProvider  FaxRegisterServiceProviderW

typedef BOOL
(WINAPI *PFAXREGISTERSERVICEPROVIDERW)(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    );

#define PFAXREGISTERSERVICEPROVIDER PFAXREGISTERSERVICEPROVIDERW


WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderW(
    IN LPCWSTR DeviceProvider    
    );

#define FaxUnregisterServiceProvider  FaxUnregisterServiceProviderW

typedef BOOL
(WINAPI *PFAXUNREGISTERSERVICEPROVIDERW)(
    IN LPCWSTR DeviceProvider    
    );

#define PFAXUNREGISTERSERVICEPROVIDER PFAXUNREGISTERSERVICEPROVIDERW

typedef BOOL
(CALLBACK *PFAX_ROUTING_INSTALLATION_CALLBACKW)(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );

#define PFAX_ROUTING_INSTALLATION_CALLBACK PFAX_ROUTING_INSTALLATION_CALLBACKW


WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define FaxRegisterRoutingExtension FaxRegisterRoutingExtensionW


typedef BOOL
(WINAPI *PFAXREGISTERROUTINGEXTENSIONW)(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    );

#define PFAXREGISTERROUTINGEXTENSION PFAXREGISTERROUTINGEXTENSIONW

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
);
#ifdef UNICODE
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionW
#else
#define FaxUnregisterRoutingExtension  FaxUnregisterRoutingExtensionA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetInstallType(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );

typedef BOOL
(WINAPI *PFAXGETINSTALLTYPE)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );



WINFAXAPI
BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

typedef BOOL
(WINAPI *PFAXACCESSCHECK)(
    IN HANDLE FaxHandle,
    IN DWORD  AccessMask
    );

//
// Fax Specific Access Rights
//

#define FAX_JOB_SUBMIT          (0x0001)
#define FAX_JOB_QUERY           (0x0002)
#define FAX_CONFIG_QUERY        (0x0004)
#define FAX_CONFIG_SET          (0x0008)
#define FAX_PORT_QUERY          (0x0010)
#define FAX_PORT_SET            (0x0020)
#define FAX_JOB_MANAGE          (0x0040)

#define FAX_READ                (STANDARD_RIGHTS_READ        |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_PORT_QUERY)

#define FAX_WRITE               (STANDARD_RIGHTS_WRITE       |\
                                 FAX_JOB_SUBMIT )

#define FAX_ALL_ACCESS          (STANDARD_RIGHTS_ALL         |\
                                 FAX_JOB_SUBMIT              |\
                                 FAX_JOB_QUERY               |\
                                 FAX_CONFIG_QUERY            |\
                                 FAX_CONFIG_SET              |\
                                 FAX_PORT_QUERY              |\
                                 FAX_PORT_SET                |\
                                 FAX_JOB_MANAGE)


//************************************
//* Extended API Functions
//************************************

#define MAX_DIR_PATH                    248

//
// Outbound routing defines
//
#define ROUTING_RULE_COUNTRY_CODE_ANY   0       // Outbound routing rule - Any country dialing code
#define ROUTING_RULE_AREA_CODE_ANY      0       // Outbound routing rule - Any area dialing code

#define MAX_ROUTING_GROUP_NAME          128
#define ROUTING_GROUP_ALL_DEVICESW      L"<All devices>"
#define ROUTING_GROUP_ALL_DEVICESA      "<All devices>"

#ifdef UNICODE
#define ROUTING_GROUP_ALL_DEVICES       ROUTING_GROUP_ALL_DEVICESW
#else
#define ROUTING_GROUP_ALL_DEVICES       ROUTING_GROUP_ALL_DEVICESA;
#endif // UNICODE


//
// Activity logging defines
//
#define ACTIVITY_LOG_INBOX_FILENAME     TEXT("InboxLOG")
#define ACTIVITY_LOG_OUTBOX_FILENAME    TEXT("OutboxLOG")
#define ACTIVITY_LOG_FILE_EXTENSION     TEXT(".txt")

#define ACTIVITY_LOG_INBOX_FILE       ACTIVITY_LOG_INBOX_FILENAME ACTIVITY_LOG_FILE_EXTENSION 
#define ACTIVITY_LOG_OUTBOX_FILE      ACTIVITY_LOG_OUTBOX_FILENAME ACTIVITY_LOG_FILE_EXTENSION

#define ACTIVITY_LOG_INBOX_FILENAME_TEMPLATE    ACTIVITY_LOG_INBOX_FILENAME TEXT(" %04d-%02d-%02d - %04d-%02d-%02d") ACTIVITY_LOG_FILE_EXTENSION
#define ACTIVITY_LOG_OUTBOX_FILENAME_TEMPLATE   ACTIVITY_LOG_OUTBOX_FILENAME TEXT(" %04d-%02d-%02d - %04d-%02d-%02d") ACTIVITY_LOG_FILE_EXTENSION

#define ACTIVITY_LOG_INBOX  (0x0000)
#define ACTIVITY_LOG_OUTBOX (0x0001)

#define ACTIVITY_LOG_LIMIT_CRITERIA_NONE    (0x0000)
#define ACTIVITY_LOG_LIMIT_CRITERIA_SIZE    (0x0001)
#define ACTIVITY_LOG_LIMIT_CRITERIA_AGE     (0x0002)

#define ACTIVITY_LOG_LIMIT_REACHED_ACTION_COPY      (0x0000)
#define ACTIVITY_LOG_LIMIT_REACHED_ACTION_DELETE    (0x0001)

#define ACTIVITY_LOG_DEFAULT_SIZE_LIMIT     (50)    // 50 Mbyte
#define ACTIVITY_LOG_DEFAULT_AGE_LIMIT      (1)     // 1  Month

//
// Archive defines
//
#define FAX_ARCHIVE_FOLDER_INVALID_SIZE         MAKELONGLONG(0xffffffff, 0xffffffff)
#define MAX_ARCHIVE_FOLDER_PATH                 180

//
// New job status codes
//
#define JS_COMPLETED                0x00000100
#define JS_CANCELED                 0x00000200
#define JS_CANCELING                0x00000400
#define JS_ROUTING                  0x00000800


//
// Extended job status defines
//

#define JS_EX_DISCONNECTED              0x00000001
#define JS_EX_INITIALIZING              0x00000002
#define JS_EX_DIALING                   0x00000003
#define JS_EX_TRANSMITTING              0x00000004
#define JS_EX_ANSWERED                  0x00000005
#define JS_EX_RECEIVING                 0x00000006
#define JS_EX_LINE_UNAVAILABLE          0x00000007
#define JS_EX_BUSY                      0x00000008
#define JS_EX_NO_ANSWER                 0x00000009
#define JS_EX_BAD_ADDRESS               0x0000000A
#define JS_EX_NO_DIAL_TONE              0x0000000B
#define JS_EX_FATAL_ERROR               0x0000000C
#define JS_EX_CALL_DELAYED              0x0000000D
#define JS_EX_CALL_BLACKLISTED          0x0000000E
#define JS_EX_NOT_FAX_CALL              0x0000000F
#define JS_EX_PARTIALLY_RECEIVED        0x00000010
#define JS_EX_HANDLED                   0x00000011

#define FAX_API_VER_0_MAX_JS_EX         JS_EX_HANDLED    // API version 0 was only aware of extended status codes up to JS_EX_HANDLED

#define JS_EX_CALL_COMPLETED            0x00000012
#define JS_EX_CALL_ABORTED              0x00000013

#define FAX_API_VER_1_MAX_JS_EX         JS_EX_CALL_ABORTED    // API version 0 was only aware of extended status codes up to JS_EX_CALL_ABORTED

//
// Available job operations
//
typedef enum
{
    FAX_JOB_OP_VIEW                             = 0x0001,
    FAX_JOB_OP_PAUSE                            = 0x0002,
    FAX_JOB_OP_RESUME                           = 0x0004,
    FAX_JOB_OP_RESTART                          = 0x0008,
    FAX_JOB_OP_DELETE                           = 0x0010,
    FAX_JOB_OP_RECIPIENT_INFO                   = 0x0020,
    FAX_JOB_OP_SENDER_INFO                      = 0x0040
} FAX_ENUM_JOB_OP;

//************************************
//* Getting / Settings the queue state
//************************************

typedef enum
{
    FAX_INCOMING_BLOCKED = 0x0001,
    FAX_OUTBOX_BLOCKED   = 0x0002,
    FAX_OUTBOX_PAUSED    = 0x0004
} FAX_ENUM_QUEUE_STATE;

WINFAXAPI
BOOL
WINAPI
FaxGetQueueStates (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwQueueStates
);

WINFAXAPI
BOOL
WINAPI
FaxSetQueue (
    IN HANDLE       hFaxHandle,
    IN CONST DWORD  dwQueueStates
);

//************************************************
//* Getting / Setting the receipts configuration
//************************************************

typedef enum
{
    FAX_SMTP_AUTH_ANONYMOUS,
    FAX_SMTP_AUTH_BASIC,
    FAX_SMTP_AUTH_NTLM
} FAX_ENUM_SMTP_AUTH_OPTIONS;

typedef struct _FAX_RECEIPTS_CONFIGA
{
    DWORD                           dwSizeOfStruct;         // For version checks
    DWORD                           dwAllowedReceipts;      // Any combination of DRT_EMAIL and DRT_MSGBOX
    FAX_ENUM_SMTP_AUTH_OPTIONS      SMTPAuthOption;         // SMTP server authentication type
    LPSTR                           lptstrReserved;         // Reserved; must be NULL
    LPSTR                           lptstrSMTPServer;       // SMTP server name
    DWORD                           dwSMTPPort;             // SMTP port number
    LPSTR                           lptstrSMTPFrom;         // SMTP sender address
    LPSTR                           lptstrSMTPUserName;     // SMTP user name (for authenticated connections)
    LPSTR                           lptstrSMTPPassword;     // SMTP password (for authenticated connections)
                                                            // This value is always NULL on get and may be NULL
                                                            // on set (won't be written in the server).
    BOOL                            bIsToUseForMSRouteThroughEmailMethod;
} FAX_RECEIPTS_CONFIGA, *PFAX_RECEIPTS_CONFIGA;
typedef struct _FAX_RECEIPTS_CONFIGW
{
    DWORD                           dwSizeOfStruct;         // For version checks
    DWORD                           dwAllowedReceipts;      // Any combination of DRT_EMAIL and DRT_MSGBOX
    FAX_ENUM_SMTP_AUTH_OPTIONS      SMTPAuthOption;         // SMTP server authentication type
    LPWSTR                          lptstrReserved;         // Reserved; must be NULL
    LPWSTR                          lptstrSMTPServer;       // SMTP server name
    DWORD                           dwSMTPPort;             // SMTP port number
    LPWSTR                          lptstrSMTPFrom;         // SMTP sender address
    LPWSTR                          lptstrSMTPUserName;     // SMTP user name (for authenticated connections)
    LPWSTR                          lptstrSMTPPassword;     // SMTP password (for authenticated connections)
                                                            // This value is always NULL on get and may be NULL
                                                            // on set (won't be written in the server).
    BOOL                            bIsToUseForMSRouteThroughEmailMethod;
} FAX_RECEIPTS_CONFIGW, *PFAX_RECEIPTS_CONFIGW;
#ifdef UNICODE
typedef FAX_RECEIPTS_CONFIGW FAX_RECEIPTS_CONFIG;
typedef PFAX_RECEIPTS_CONFIGW PFAX_RECEIPTS_CONFIG;
#else
typedef FAX_RECEIPTS_CONFIGA FAX_RECEIPTS_CONFIG;
typedef PFAX_RECEIPTS_CONFIGA PFAX_RECEIPTS_CONFIG;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationA (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGA  *ppReceipts
);
WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsConfigurationW (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGW  *ppReceipts
);
#ifdef UNICODE
#define FaxGetReceiptsConfiguration  FaxGetReceiptsConfigurationW
#else
#define FaxGetReceiptsConfiguration  FaxGetReceiptsConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGA  pReceipts
);
WINFAXAPI
BOOL
WINAPI
FaxSetReceiptsConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGW  pReceipts
);
#ifdef UNICODE
#define FaxSetReceiptsConfiguration  FaxSetReceiptsConfigurationW
#else
#define FaxSetReceiptsConfiguration  FaxSetReceiptsConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetReceiptsOptions (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwReceiptsOptions  // Combination of DRT_EMAIL and DRT_MSGBOX
);

//********************************************
//*             Server version
//********************************************

typedef struct _FAX_VERSION
{
    DWORD dwSizeOfStruct;       // Size of this structure
    BOOL  bValid;               // Is version valid?
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    WORD  wMajorBuildNumber;
    WORD  wMinorBuildNumber;
    DWORD dwFlags;              // Combination of FAX_VER_FLAG_*
} FAX_VERSION, *PFAX_VERSION;


typedef enum
{
    FAX_VER_FLAG_CHECKED        = 0x00000001,       // File was built in debug mode
    FAX_VER_FLAG_EVALUATION     = 0x00000002        // Evaluation build
} FAX_VERSION_FLAGS;

WINFAXAPI
BOOL
WINAPI
FaxGetVersion (
    IN  HANDLE          hFaxHandle,
    OUT PFAX_VERSION    pVersion
);

#define FAX_API_VERSION_0           0x00000000      // BOS/SBS 2000 Fax Server API (0.0)
#define FAX_API_VERSION_1           0x00010000      // Windows XP Fax Server API   (1.0)
#define FAX_API_VERSION_2           0x00020000      // Windows Server 2003 Fax Server API  (2.0)

//
// NOTICE: Change this value whenever a new API version is introduced.
//
#define CURRENT_FAX_API_VERSION     FAX_API_VERSION_2

WINFAXAPI
BOOL
WINAPI
FaxGetReportedServerAPIVersion (
    IN  HANDLE          hFaxHandle,
    OUT LPDWORD         lpdwReportedServerAPIVersion
);

//********************************************
//*            Activity logging
//********************************************


typedef struct _FAX_ACTIVITY_LOGGING_CONFIGA
{
    DWORD   dwSizeOfStruct;
    BOOL    bLogIncoming;
    BOOL    bLogOutgoing;
    LPSTR   lptstrDBPath;
} FAX_ACTIVITY_LOGGING_CONFIGA, *PFAX_ACTIVITY_LOGGING_CONFIGA;
typedef struct _FAX_ACTIVITY_LOGGING_CONFIGW
{
    DWORD   dwSizeOfStruct;
    BOOL    bLogIncoming;
    BOOL    bLogOutgoing;
    LPWSTR  lptstrDBPath;
} FAX_ACTIVITY_LOGGING_CONFIGW, *PFAX_ACTIVITY_LOGGING_CONFIGW;
#ifdef UNICODE
typedef FAX_ACTIVITY_LOGGING_CONFIGW FAX_ACTIVITY_LOGGING_CONFIG;
typedef PFAX_ACTIVITY_LOGGING_CONFIGW PFAX_ACTIVITY_LOGGING_CONFIG;
#else
typedef FAX_ACTIVITY_LOGGING_CONFIGA FAX_ACTIVITY_LOGGING_CONFIG;
typedef PFAX_ACTIVITY_LOGGING_CONFIGA PFAX_ACTIVITY_LOGGING_CONFIG;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationA (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGA *ppActivLogCfg
);
WINFAXAPI
BOOL
WINAPI
FaxGetActivityLoggingConfigurationW (
    IN  HANDLE                         hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGW *ppActivLogCfg
);
#ifdef UNICODE
#define FaxGetActivityLoggingConfiguration  FaxGetActivityLoggingConfigurationW
#else
#define FaxGetActivityLoggingConfiguration  FaxGetActivityLoggingConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationA (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGA  pActivLogCfg
);
WINFAXAPI
BOOL
WINAPI
FaxSetActivityLoggingConfigurationW (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGW  pActivLogCfg
);
#ifdef UNICODE
#define FaxSetActivityLoggingConfiguration  FaxSetActivityLoggingConfigurationW
#else
#define FaxSetActivityLoggingConfiguration  FaxSetActivityLoggingConfigurationA
#endif // !UNICODE

//********************************************
//*            Outbox configuration
//********************************************

typedef struct _FAX_OUTBOX_CONFIG
{
    DWORD       dwSizeOfStruct;
    BOOL        bAllowPersonalCP;
    BOOL        bUseDeviceTSID;
    DWORD       dwRetries;
    DWORD       dwRetryDelay;
    FAX_TIME    dtDiscountStart;
    FAX_TIME    dtDiscountEnd;
    DWORD       dwAgeLimit;
    BOOL        bBranding;
} FAX_OUTBOX_CONFIG, *PFAX_OUTBOX_CONFIG;

WINFAXAPI
BOOL
WINAPI
FaxGetOutboxConfiguration (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_OUTBOX_CONFIG *ppOutboxCfg
);

WINFAXAPI
BOOL
WINAPI
FaxSetOutboxConfiguration (
    IN HANDLE                    hFaxHandle,
    IN CONST PFAX_OUTBOX_CONFIG  pOutboxCfg
);

WINFAXAPI
BOOL
WINAPI
FaxGetPersonalCoverPagesOption (
    IN  HANDLE  hFaxHandle,
    OUT LPBOOL  lpbPersonalCPAllowed
);

//********************************************
//*            Archive configuration
//********************************************

typedef enum
{
    FAX_MESSAGE_FOLDER_INBOX,
    FAX_MESSAGE_FOLDER_SENTITEMS,
    FAX_MESSAGE_FOLDER_QUEUE
} FAX_ENUM_MESSAGE_FOLDER;

typedef struct _FAX_ARCHIVE_CONFIGA
{
    DWORD   dwSizeOfStruct;
    BOOL    bUseArchive;
    LPSTR   lpcstrFolder;
    BOOL    bSizeQuotaWarning;
    DWORD   dwSizeQuotaHighWatermark;
    DWORD   dwSizeQuotaLowWatermark;
    DWORD   dwAgeLimit;
    DWORDLONG dwlArchiveSize;
} FAX_ARCHIVE_CONFIGA, *PFAX_ARCHIVE_CONFIGA;
typedef struct _FAX_ARCHIVE_CONFIGW
{
    DWORD   dwSizeOfStruct;
    BOOL    bUseArchive;
    LPWSTR  lpcstrFolder;
    BOOL    bSizeQuotaWarning;
    DWORD   dwSizeQuotaHighWatermark;
    DWORD   dwSizeQuotaLowWatermark;
    DWORD   dwAgeLimit;
    DWORDLONG dwlArchiveSize;
} FAX_ARCHIVE_CONFIGW, *PFAX_ARCHIVE_CONFIGW;
#ifdef UNICODE
typedef FAX_ARCHIVE_CONFIGW FAX_ARCHIVE_CONFIG;
typedef PFAX_ARCHIVE_CONFIGW PFAX_ARCHIVE_CONFIG;
#else
typedef FAX_ARCHIVE_CONFIGA FAX_ARCHIVE_CONFIG;
typedef PFAX_ARCHIVE_CONFIGA PFAX_ARCHIVE_CONFIG;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationA (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGA    *ppArchiveCfg
);
WINFAXAPI
BOOL
WINAPI
FaxGetArchiveConfigurationW (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
);
#ifdef UNICODE
#define FaxGetArchiveConfiguration  FaxGetArchiveConfigurationW
#else
#define FaxGetArchiveConfiguration  FaxGetArchiveConfigurationA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGA   pArchiveCfg
);
WINFAXAPI
BOOL
WINAPI
FaxSetArchiveConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
);
#ifdef UNICODE
#define FaxSetArchiveConfiguration  FaxSetArchiveConfigurationW
#else
#define FaxSetArchiveConfiguration  FaxSetArchiveConfigurationA
#endif // !UNICODE

//********************************************
//*         Server activity
//********************************************

typedef struct _FAX_SERVER_ACTIVITY
{
    DWORD   dwSizeOfStruct;
    DWORD   dwIncomingMessages;
    DWORD   dwRoutingMessages;
    DWORD   dwOutgoingMessages;
    DWORD   dwDelegatedOutgoingMessages;
    DWORD   dwQueuedMessages;
    DWORD   dwErrorEvents;
    DWORD   dwWarningEvents;
    DWORD   dwInformationEvents;
} FAX_SERVER_ACTIVITY, *PFAX_SERVER_ACTIVITY;

WINFAXAPI
BOOL
WINAPI
FaxGetServerActivity (
    IN  HANDLE               hFaxHandle,
    OUT PFAX_SERVER_ACTIVITY pServerActivity
);

//********************************************
//*                 Queue jobs
//********************************************

typedef enum
{
    FAX_PRIORITY_TYPE_LOW,
    FAX_PRIORITY_TYPE_NORMAL,
    FAX_PRIORITY_TYPE_HIGH
} FAX_ENUM_PRIORITY_TYPE;

#define FAX_PRIORITY_TYPE_DEFAULT    FAX_PRIORITY_TYPE_LOW

typedef enum
{
    FAX_JOB_FIELD_JOB_ID                    = 0x00000001,
    FAX_JOB_FIELD_TYPE                      = 0x00000002,
    FAX_JOB_FIELD_QUEUE_STATUS              = 0x00000004,
    FAX_JOB_FIELD_STATUS_EX                 = 0x00000008,
    FAX_JOB_FIELD_SIZE                      = 0x00000010,
    FAX_JOB_FIELD_PAGE_COUNT                = 0x00000020,
    FAX_JOB_FIELD_CURRENT_PAGE              = 0x00000040,
    FAX_JOB_FIELD_RECIPIENT_PROFILE         = 0x00000080,
    FAX_JOB_FIELD_SCHEDULE_TIME             = 0x00000100,
    FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME    = 0x00000200,
    FAX_JOB_FIELD_SUBMISSION_TIME           = 0x00000400,
    FAX_JOB_FIELD_TRANSMISSION_START_TIME   = 0x00000800,
    FAX_JOB_FIELD_TRANSMISSION_END_TIME     = 0x00001000,
    FAX_JOB_FIELD_PRIORITY                  = 0x00002000,
    FAX_JOB_FIELD_RETRIES                   = 0x00004000,
    FAX_JOB_FIELD_DELIVERY_REPORT_TYPE      = 0x00008000,
    FAX_JOB_FIELD_SENDER_PROFILE            = 0x00010000,
    FAX_JOB_FIELD_STATUS_SUB_STRUCT         = 0x00020000,
    FAX_JOB_FIELD_DEVICE_ID                 = 0x00040000,
    FAX_JOB_FIELD_MESSAGE_ID                = 0x00080000,
    FAX_JOB_FIELD_BROADCAST_ID              = 0x00010000
} FAX_ENUM_JOB_FIELDS;

typedef struct _FAX_JOB_STATUSA
{
    DWORD           dwSizeOfStruct;
    DWORD           dwValidityMask;
    DWORD           dwJobID;
    DWORD           dwJobType;
    DWORD           dwQueueStatus;
    DWORD           dwExtendedStatus;
    LPCSTR          lpctstrExtendedStatus;
    DWORD           dwSize;
    DWORD           dwPageCount;
    DWORD           dwCurrentPage;
    LPCSTR          lpctstrTsid;
    LPCSTR          lpctstrCsid;
    SYSTEMTIME      tmScheduleTime;
    SYSTEMTIME      tmTransmissionStartTime;
    SYSTEMTIME      tmTransmissionEndTime;
    DWORD           dwDeviceID;
    LPCSTR          lpctstrDeviceName;
    DWORD           dwRetries;
    LPCSTR          lpctstrCallerID;
    LPCSTR          lpctstrRoutingInfo;
    DWORD           dwAvailableJobOperations;
} FAX_JOB_STATUSA, *PFAX_JOB_STATUSA;
typedef struct _FAX_JOB_STATUSW
{
    DWORD           dwSizeOfStruct;
    DWORD           dwValidityMask;
    DWORD           dwJobID;
    DWORD           dwJobType;
    DWORD           dwQueueStatus;
    DWORD           dwExtendedStatus;
    LPCWSTR         lpctstrExtendedStatus;
    DWORD           dwSize;
    DWORD           dwPageCount;
    DWORD           dwCurrentPage;
    LPCWSTR         lpctstrTsid;
    LPCWSTR         lpctstrCsid;
    SYSTEMTIME      tmScheduleTime;
    SYSTEMTIME      tmTransmissionStartTime;
    SYSTEMTIME      tmTransmissionEndTime;
    DWORD           dwDeviceID;
    LPCWSTR         lpctstrDeviceName;
    DWORD           dwRetries;
    LPCWSTR         lpctstrCallerID;
    LPCWSTR         lpctstrRoutingInfo;
    DWORD           dwAvailableJobOperations;
} FAX_JOB_STATUSW, *PFAX_JOB_STATUSW;
#ifdef UNICODE
typedef FAX_JOB_STATUSW FAX_JOB_STATUS;
typedef PFAX_JOB_STATUSW PFAX_JOB_STATUS;
#else
typedef FAX_JOB_STATUSA FAX_JOB_STATUS;
typedef PFAX_JOB_STATUSA PFAX_JOB_STATUS;
#endif // UNICODE

typedef struct _FAX_JOB_ENTRY_EXA
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwValidityMask;
    DWORDLONG               dwlMessageId;
    DWORDLONG               dwlBroadcastId;
    LPCSTR                  lpctstrRecipientNumber;
    LPCSTR                  lpctstrRecipientName;
    LPCSTR                  lpctstrSenderUserName;
    LPCSTR                  lpctstrBillingCode;
    SYSTEMTIME              tmOriginalScheduleTime;
    SYSTEMTIME              tmSubmissionTime;
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwDeliveryReportType;
    LPCSTR                  lpctstrDocumentName;
    LPCSTR                  lpctstrSubject;
    PFAX_JOB_STATUSA        pStatus;
} FAX_JOB_ENTRY_EXA, *PFAX_JOB_ENTRY_EXA;
typedef struct _FAX_JOB_ENTRY_EXW
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwValidityMask;
    DWORDLONG               dwlMessageId;
    DWORDLONG               dwlBroadcastId;
    LPCWSTR                 lpctstrRecipientNumber;
    LPCWSTR                 lpctstrRecipientName;
    LPCWSTR                 lpctstrSenderUserName;
    LPCWSTR                 lpctstrBillingCode;
    SYSTEMTIME              tmOriginalScheduleTime;
    SYSTEMTIME              tmSubmissionTime;
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwDeliveryReportType;
    LPCWSTR                 lpctstrDocumentName;
    LPCWSTR                 lpctstrSubject;
    PFAX_JOB_STATUSW        pStatus;
} FAX_JOB_ENTRY_EXW, *PFAX_JOB_ENTRY_EXW;
#ifdef UNICODE
typedef FAX_JOB_ENTRY_EXW FAX_JOB_ENTRY_EX;
typedef PFAX_JOB_ENTRY_EXW PFAX_JOB_ENTRY_EX;
#else
typedef FAX_JOB_ENTRY_EXA FAX_JOB_ENTRY_EX;
typedef PFAX_JOB_ENTRY_EXA PFAX_JOB_ENTRY_EX;
#endif // UNICODE


typedef struct _FAX_JOB_PARAM_EXA
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwScheduleAction;
        SYSTEMTIME              tmSchedule;
        DWORD                   dwReceiptDeliveryType;
        LPSTR                   lptstrReceiptDeliveryAddress;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        HCALL                   hCall;
        DWORD_PTR               dwReserved[4];
        LPSTR                   lptstrDocumentName;
        DWORD                   dwPageCount;
} FAX_JOB_PARAM_EXA, *PFAX_JOB_PARAM_EXA;
typedef struct _FAX_JOB_PARAM_EXW
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwScheduleAction;
        SYSTEMTIME              tmSchedule;
        DWORD                   dwReceiptDeliveryType;
        LPWSTR                  lptstrReceiptDeliveryAddress;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        HCALL                   hCall;
        DWORD_PTR               dwReserved[4];
        LPWSTR                  lptstrDocumentName;
        DWORD                   dwPageCount;
} FAX_JOB_PARAM_EXW, *PFAX_JOB_PARAM_EXW;
#ifdef UNICODE
typedef FAX_JOB_PARAM_EXW FAX_JOB_PARAM_EX;
typedef PFAX_JOB_PARAM_EXW PFAX_JOB_PARAM_EX;
#else
typedef FAX_JOB_PARAM_EXA FAX_JOB_PARAM_EX;
typedef PFAX_JOB_PARAM_EXA PFAX_JOB_PARAM_EX;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI FaxEnumJobsExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
);
WINFAXAPI
BOOL
WINAPI FaxEnumJobsExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntries,
    OUT LPDWORD             lpdwJobs
);
#ifdef UNICODE
#define FaxEnumJobsEx  FaxEnumJobsExW
#else
#define FaxEnumJobsEx  FaxEnumJobsExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetJobExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
);
WINFAXAPI
BOOL
WINAPI
FaxGetJobExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntry
);
#ifdef UNICODE
#define FaxGetJobEx  FaxGetJobExW
#else
#define FaxGetJobEx  FaxGetJobExA
#endif // !UNICODE


typedef const FAX_JOB_PARAM_EXW * LPCFAX_JOB_PARAM_EXW;
typedef const FAX_JOB_PARAM_EXA * LPCFAX_JOB_PARAM_EXA;

#ifdef UNICODE
        typedef LPCFAX_JOB_PARAM_EXW LPCFAX_JOB_PARAM_EX;
#else
        typedef LPCFAX_JOB_PARAM_EXA LPCFAX_JOB_PARAM_EX;
#endif


typedef enum
{
    FAX_COVERPAGE_FMT_COV = 1,
    FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY
} FAX_ENUM_COVERPAGE_FORMATS;


typedef struct _FAX_COVERPAGE_INFO_EXA
{
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPSTR   lptstrCoverPageFileName;
    BOOL    bServerBased;
    LPSTR   lptstrNote;
    LPSTR   lptstrSubject;
} FAX_COVERPAGE_INFO_EXA, *PFAX_COVERPAGE_INFO_EXA;
typedef struct _FAX_COVERPAGE_INFO_EXW
{
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPWSTR  lptstrCoverPageFileName;
    BOOL    bServerBased;
    LPWSTR  lptstrNote;
    LPWSTR  lptstrSubject;
} FAX_COVERPAGE_INFO_EXW, *PFAX_COVERPAGE_INFO_EXW;
#ifdef UNICODE
typedef FAX_COVERPAGE_INFO_EXW FAX_COVERPAGE_INFO_EX;
typedef PFAX_COVERPAGE_INFO_EXW PFAX_COVERPAGE_INFO_EX;
#else
typedef FAX_COVERPAGE_INFO_EXA FAX_COVERPAGE_INFO_EX;
typedef PFAX_COVERPAGE_INFO_EXA PFAX_COVERPAGE_INFO_EX;
#endif // UNICODE

typedef const FAX_COVERPAGE_INFO_EXW * LPCFAX_COVERPAGE_INFO_EXW;
typedef const FAX_COVERPAGE_INFO_EXA * LPCFAX_COVERPAGE_INFO_EXA;

#ifdef UNICODE
        typedef LPCFAX_COVERPAGE_INFO_EXW LPCFAX_COVERPAGE_INFO_EX;
#else
        typedef LPCFAX_COVERPAGE_INFO_EXA LPCFAX_COVERPAGE_INFO_EX;
#endif


typedef struct _FAX_PERSONAL_PROFILEA
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPSTR      lptstrName;                  // Name of person
    LPSTR      lptstrFaxNumber;             // Fax number
    LPSTR      lptstrCompany;               // Company name
    LPSTR      lptstrStreetAddress;         // Street address
    LPSTR      lptstrCity;                  // City
    LPSTR      lptstrState;                 // State
    LPSTR      lptstrZip;                   // Zip code
    LPSTR      lptstrCountry;               // Country
    LPSTR      lptstrTitle;                 // Title
    LPSTR      lptstrDepartment;            // Department
    LPSTR      lptstrOfficeLocation;        // Office location
    LPSTR      lptstrHomePhone;             // Phone number at home
    LPSTR      lptstrOfficePhone;           // Phone number at office
    LPSTR      lptstrEmail;                 // Personal e-mail address
    LPSTR      lptstrBillingCode;           // Billing code
    LPSTR      lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEA, *PFAX_PERSONAL_PROFILEA;
typedef struct _FAX_PERSONAL_PROFILEW
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPWSTR     lptstrName;                  // Name of person
    LPWSTR     lptstrFaxNumber;             // Fax number
    LPWSTR     lptstrCompany;               // Company name
    LPWSTR     lptstrStreetAddress;         // Street address
    LPWSTR     lptstrCity;                  // City
    LPWSTR     lptstrState;                 // State
    LPWSTR     lptstrZip;                   // Zip code
    LPWSTR     lptstrCountry;               // Country
    LPWSTR     lptstrTitle;                 // Title
    LPWSTR     lptstrDepartment;            // Department
    LPWSTR     lptstrOfficeLocation;        // Office location
    LPWSTR     lptstrHomePhone;             // Phone number at home
    LPWSTR     lptstrOfficePhone;           // Phone number at office
    LPWSTR     lptstrEmail;                 // Personal e-mail address
    LPWSTR     lptstrBillingCode;           // Billing code
    LPWSTR     lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEW, *PFAX_PERSONAL_PROFILEW;
#ifdef UNICODE
typedef FAX_PERSONAL_PROFILEW FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEW PFAX_PERSONAL_PROFILE;
#else
typedef FAX_PERSONAL_PROFILEA FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEA PFAX_PERSONAL_PROFILE;
#endif // UNICODE

typedef const FAX_PERSONAL_PROFILEW * LPCFAX_PERSONAL_PROFILEW;
typedef const FAX_PERSONAL_PROFILEA * LPCFAX_PERSONAL_PROFILEA;

#ifdef UNICODE
        typedef LPCFAX_PERSONAL_PROFILEW LPCFAX_PERSONAL_PROFILE;
#else
        typedef LPCFAX_PERSONAL_PROFILEA LPCFAX_PERSONAL_PROFILE;
#endif


BOOL WINAPI FaxSendDocumentExA
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
BOOL WINAPI FaxSendDocumentExW
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
#ifdef UNICODE
#define FaxSendDocumentEx  FaxSendDocumentExW
#else
#define FaxSendDocumentEx  FaxSendDocumentExA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSENDDOCUMENTEXA)(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpcJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
typedef BOOL
(WINAPI *PFAXSENDDOCUMENTEXW)(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpcJobParams,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
#ifdef UNICODE
#define PFAXSENDDOCUMENTEX  PFAXSENDDOCUMENTEXW
#else
#define PFAXSENDDOCUMENTEX  PFAXSENDDOCUMENTEXA
#endif // !UNICODE


//********************************************
//*               Archive jobs
//********************************************

typedef struct _FAX_MESSAGEA
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwValidityMask;
        DWORDLONG               dwlMessageId;
        DWORDLONG               dwlBroadcastId;
        DWORD                   dwJobType;
        DWORD                   dwQueueStatus;
        DWORD                   dwExtendedStatus;
        LPCSTR                  lpctstrExtendedStatus;
        DWORD                   dwSize;
        DWORD                   dwPageCount;
        LPCSTR                  lpctstrRecipientNumber;
        LPCSTR                  lpctstrRecipientName;
        LPCSTR                  lpctstrSenderNumber;
        LPCSTR                  lpctstrSenderName;
        LPCSTR                  lpctstrTsid;
        LPCSTR                  lpctstrCsid;
        LPCSTR                  lpctstrSenderUserName;
        LPCSTR                  lpctstrBillingCode;
        SYSTEMTIME              tmOriginalScheduleTime;
        SYSTEMTIME              tmSubmissionTime;
        SYSTEMTIME              tmTransmissionStartTime;
        SYSTEMTIME              tmTransmissionEndTime;
        LPCSTR                  lpctstrDeviceName;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        DWORD                   dwRetries;
        LPCSTR                  lpctstrDocumentName;
        LPCSTR                  lpctstrSubject;
        LPCSTR                  lpctstrCallerID;
        LPCSTR                  lpctstrRoutingInfo;
} FAX_MESSAGEA, *PFAX_MESSAGEA;
typedef struct _FAX_MESSAGEW
{
        DWORD                   dwSizeOfStruct;
        DWORD                   dwValidityMask;
        DWORDLONG               dwlMessageId;
        DWORDLONG               dwlBroadcastId;
        DWORD                   dwJobType;
        DWORD                   dwQueueStatus;
        DWORD                   dwExtendedStatus;
        LPCWSTR                 lpctstrExtendedStatus;
        DWORD                   dwSize;
        DWORD                   dwPageCount;
        LPCWSTR                 lpctstrRecipientNumber;
        LPCWSTR                 lpctstrRecipientName;
        LPCWSTR                 lpctstrSenderNumber;
        LPCWSTR                 lpctstrSenderName;
        LPCWSTR                 lpctstrTsid;
        LPCWSTR                 lpctstrCsid;
        LPCWSTR                 lpctstrSenderUserName;
        LPCWSTR                 lpctstrBillingCode;
        SYSTEMTIME              tmOriginalScheduleTime;
        SYSTEMTIME              tmSubmissionTime;
        SYSTEMTIME              tmTransmissionStartTime;
        SYSTEMTIME              tmTransmissionEndTime;
        LPCWSTR                 lpctstrDeviceName;
        FAX_ENUM_PRIORITY_TYPE  Priority;
        DWORD                   dwRetries;
        LPCWSTR                 lpctstrDocumentName;
        LPCWSTR                 lpctstrSubject;
        LPCWSTR                 lpctstrCallerID;
        LPCWSTR                 lpctstrRoutingInfo;
} FAX_MESSAGEW, *PFAX_MESSAGEW;
#ifdef UNICODE
typedef FAX_MESSAGEW FAX_MESSAGE;
typedef PFAX_MESSAGEW PFAX_MESSAGE;
#else
typedef FAX_MESSAGEA FAX_MESSAGE;
typedef PFAX_MESSAGEA PFAX_MESSAGE;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxStartMessagesEnum (
    IN  HANDLE                  hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PHANDLE                 phEnum
);

WINFAXAPI
BOOL
WINAPI
FaxEndMessagesEnum (
    IN  HANDLE  hEnum
);

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesA (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEA  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
);
WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesW (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEW  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
);
#ifdef UNICODE
#define FaxEnumMessages  FaxEnumMessagesW
#else
#define FaxEnumMessages  FaxEnumMessagesA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetMessageA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEA          *ppMsg
);
WINFAXAPI
BOOL
WINAPI
FaxGetMessageW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEW          *ppMsg
);
#ifdef UNICODE
#define FaxGetMessage  FaxGetMessageW
#else
#define FaxGetMessage  FaxGetMessageA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveMessage (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder
);

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCSTR                lpctstrFilePath
);
WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCWSTR                lpctstrFilePath
);
#ifdef UNICODE
#define FaxGetMessageTiff  FaxGetMessageTiffW
#else
#define FaxGetMessageTiff  FaxGetMessageTiffA
#endif // !UNICODE

//************************************
//*     Non-RPC extended interfaces
//************************************

HRESULT WINAPI
FaxFreeSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );

HRESULT WINAPI
FaxSetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );

HRESULT WINAPI
FaxGetSenderInformation(
        PFAX_PERSONAL_PROFILE pfppSender
        );


//********************************************
//*                 Security
//********************************************
//
//  Specific access rights
//
typedef enum
{
    FAX_ACCESS_SUBMIT                   = 0x0001,
    FAX_ACCESS_SUBMIT_NORMAL            = 0x0002,
    FAX_ACCESS_SUBMIT_HIGH              = 0x0004,
    FAX_ACCESS_QUERY_JOBS               = 0x0008,
    FAX_ACCESS_MANAGE_JOBS              = 0x0010,
    FAX_ACCESS_QUERY_CONFIG             = 0x0020,
    FAX_ACCESS_MANAGE_CONFIG            = 0x0040,
    FAX_ACCESS_QUERY_IN_ARCHIVE         = 0x0080,
    FAX_ACCESS_MANAGE_IN_ARCHIVE        = 0x0100,
    FAX_ACCESS_QUERY_OUT_ARCHIVE        = 0x0200,
    FAX_ACCESS_MANAGE_OUT_ARCHIVE       = 0x0400
} FAX_SPECIFIC_ACCESS_RIGHTS;

#define FAX_GENERIC_READ    (FAX_ACCESS_QUERY_JOBS | FAX_ACCESS_QUERY_CONFIG | FAX_ACCESS_QUERY_IN_ARCHIVE | FAX_ACCESS_QUERY_OUT_ARCHIVE)
#define FAX_GENERIC_WRITE   (FAX_ACCESS_MANAGE_JOBS | FAX_ACCESS_MANAGE_CONFIG | FAX_ACCESS_MANAGE_IN_ARCHIVE | FAX_ACCESS_MANAGE_OUT_ARCHIVE)
#define FAX_GENERIC_EXECUTE (FAX_ACCESS_SUBMIT)
#define FAX_GENERIC_ALL     (FAX_ACCESS_SUBMIT                  |       \
                             FAX_ACCESS_SUBMIT_NORMAL           |       \
                             FAX_ACCESS_SUBMIT_HIGH             |       \
                             FAX_ACCESS_QUERY_JOBS              |       \
                             FAX_ACCESS_MANAGE_JOBS             |       \
                             FAX_ACCESS_QUERY_CONFIG            |       \
                             FAX_ACCESS_MANAGE_CONFIG           |       \
                             FAX_ACCESS_QUERY_IN_ARCHIVE        |       \
                             FAX_ACCESS_MANAGE_IN_ARCHIVE       |       \
                             FAX_ACCESS_QUERY_OUT_ARCHIVE       |       \
                             FAX_ACCESS_MANAGE_OUT_ARCHIVE)



//
//  Functions
//


//********************************************
//*              Security
//********************************************
WINFAXAPI
BOOL
WINAPI
FaxGetSecurity (
    IN  HANDLE                  hFaxHandle,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
);

WINFAXAPI
BOOL
WINAPI
FaxGetSecurityEx (
    IN  HANDLE                  hFaxHandle,
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT PSECURITY_DESCRIPTOR    *ppSecDesc
);

WINFAXAPI
BOOL
WINAPI
FaxSetSecurity (
    IN HANDLE                       hFaxHandle,
    IN SECURITY_INFORMATION         SecurityInformation,
    IN CONST PSECURITY_DESCRIPTOR   pSecDesc
);




WINFAXAPI
BOOL
WINAPI
FaxAccessCheckEx (
    IN  HANDLE          FaxHandle,
    IN  DWORD           AccessMask,
    OUT LPDWORD         lpdwRights
    );


//********************************************
//*              Extension data
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataA (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
);
WINFAXAPI
BOOL
WINAPI
FaxGetExtensionDataW (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCWSTR lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
);
#ifdef UNICODE
#define FaxGetExtensionData  FaxGetExtensionDataW
#else
#define FaxGetExtensionData  FaxGetExtensionDataA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataA (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
);
WINFAXAPI
BOOL
WINAPI
FaxSetExtensionDataW (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCWSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
);
#ifdef UNICODE
#define FaxSetExtensionData  FaxSetExtensionDataW
#else
#define FaxSetExtensionData  FaxSetExtensionDataA
#endif // !UNICODE

//********************************************
//*                   FSP
//********************************************

typedef enum
{
    FAX_PROVIDER_STATUS_SUCCESS,     // Provider was successfully loaded
    FAX_PROVIDER_STATUS_SERVER_ERROR,// An error occured on the server while loading provider.
    FAX_PROVIDER_STATUS_BAD_GUID,    // Provider's GUID is invalid
    FAX_PROVIDER_STATUS_BAD_VERSION, // Provider's API version is invalid
    FAX_PROVIDER_STATUS_CANT_LOAD,   // Can't load provider's DLL
    FAX_PROVIDER_STATUS_CANT_LINK,   // Can't find required exported function(s) in provider's DLL
    FAX_PROVIDER_STATUS_CANT_INIT    // Failed while initializing provider
} FAX_ENUM_PROVIDER_STATUS;

typedef struct _FAX_DEVICE_PROVIDER_INFOA
{
    DWORD                           dwSizeOfStruct;
    LPCSTR                          lpctstrFriendlyName;
    LPCSTR                          lpctstrImageName;
    LPCSTR                          lpctstrProviderName;
    LPCSTR                          lpctstrGUID;
    DWORD                           dwCapabilities;
    FAX_VERSION                     Version;
    FAX_ENUM_PROVIDER_STATUS        Status;
    DWORD                           dwLastError;
} FAX_DEVICE_PROVIDER_INFOA, *PFAX_DEVICE_PROVIDER_INFOA;
typedef struct _FAX_DEVICE_PROVIDER_INFOW
{
    DWORD                           dwSizeOfStruct;
    LPCWSTR                         lpctstrFriendlyName;
    LPCWSTR                         lpctstrImageName;
    LPCWSTR                         lpctstrProviderName;
    LPCWSTR                         lpctstrGUID;
    DWORD                           dwCapabilities;
    FAX_VERSION                     Version;
    FAX_ENUM_PROVIDER_STATUS        Status;
    DWORD                           dwLastError;
} FAX_DEVICE_PROVIDER_INFOW, *PFAX_DEVICE_PROVIDER_INFOW;
#ifdef UNICODE
typedef FAX_DEVICE_PROVIDER_INFOW FAX_DEVICE_PROVIDER_INFO;
typedef PFAX_DEVICE_PROVIDER_INFOW PFAX_DEVICE_PROVIDER_INFO;
#else
typedef FAX_DEVICE_PROVIDER_INFOA FAX_DEVICE_PROVIDER_INFO;
typedef PFAX_DEVICE_PROVIDER_INFOA PFAX_DEVICE_PROVIDER_INFO;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersA (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOA *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
);
WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersW (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOW *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
);
#ifdef UNICODE
#define FaxEnumerateProviders  FaxEnumerateProvidersW
#else
#define FaxEnumerateProviders  FaxEnumerateProvidersA
#endif // !UNICODE

//********************************************
//*            Routing extensions
//********************************************

typedef struct _FAX_ROUTING_EXTENSION_INFOA
{
        DWORD                                           dwSizeOfStruct;
        LPCSTR                                          lpctstrFriendlyName;
        LPCSTR                                          lpctstrImageName;
        LPCSTR                                          lpctstrExtensionName;
        FAX_VERSION                                     Version;
        FAX_ENUM_PROVIDER_STATUS        Status;
        DWORD                                           dwLastError;
} FAX_ROUTING_EXTENSION_INFOA, *PFAX_ROUTING_EXTENSION_INFOA;
typedef struct _FAX_ROUTING_EXTENSION_INFOW
{
        DWORD                                           dwSizeOfStruct;
        LPCWSTR                                         lpctstrFriendlyName;
        LPCWSTR                                         lpctstrImageName;
        LPCWSTR                                         lpctstrExtensionName;
        FAX_VERSION                                     Version;
        FAX_ENUM_PROVIDER_STATUS        Status;
        DWORD                                           dwLastError;
} FAX_ROUTING_EXTENSION_INFOW, *PFAX_ROUTING_EXTENSION_INFOW;
#ifdef UNICODE
typedef FAX_ROUTING_EXTENSION_INFOW FAX_ROUTING_EXTENSION_INFO;
typedef PFAX_ROUTING_EXTENSION_INFOW PFAX_ROUTING_EXTENSION_INFO;
#else
typedef FAX_ROUTING_EXTENSION_INFOA FAX_ROUTING_EXTENSION_INFO;
typedef PFAX_ROUTING_EXTENSION_INFOA PFAX_ROUTING_EXTENSION_INFO;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsA (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOA    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
);
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsW (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOW    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
);
#ifdef UNICODE
#define FaxEnumRoutingExtensions  FaxEnumRoutingExtensionsW
#else
#define FaxEnumRoutingExtensions  FaxEnumRoutingExtensionsA
#endif // !UNICODE


//********************************************
//*                     Ports
//********************************************

typedef enum
{
    FAX_DEVICE_STATUS_POWERED_OFF       = 0x0001,
    FAX_DEVICE_STATUS_SENDING           = 0x0002,
    FAX_DEVICE_STATUS_RECEIVING         = 0x0004,
    FAX_DEVICE_STATUS_RINGING           = 0x0008
} FAX_ENUM_DEVICE_STATUS;

typedef enum
{
    FAX_DEVICE_RECEIVE_MODE_OFF         = 0,            // Do not answer to incoming calls
    FAX_DEVICE_RECEIVE_MODE_AUTO        = 1,            // Automatically answer to incoming calls after dwRings rings
    FAX_DEVICE_RECEIVE_MODE_MANUAL      = 2             // Manually answer to incoming calls - only FaxAnswerCall answers the call
} FAX_ENUM_DEVICE_RECEIVE_MODE;

typedef struct _FAX_PORT_INFO_EXA
{
    DWORD                           dwSizeOfStruct;            // For versioning
    DWORD                           dwDeviceID;                // Fax id
    LPCSTR                          lpctstrDeviceName;         // Name of the device
    LPSTR                           lptstrDescription;         // Descriptive string
    LPCSTR                          lpctstrProviderName;       // FSP's name
    LPCSTR                          lpctstrProviderGUID;       // FSP's GUID
    BOOL                            bSend;                     // Is the device send-enabled?
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;               // The device receive mode. See FAX_ENUM_DEVICE_RECEIVE_MODE for details.
    DWORD                           dwStatus;                  // Device status - a combination of values from FAX_ENUM_DEVICE_STATUS
    DWORD                           dwRings;                   // Number of rings before answering an incoming call
    LPSTR                           lptstrCsid;                // Called Station Id
    LPSTR                           lptstrTsid;                // Transmitting Station Id
} FAX_PORT_INFO_EXA, *PFAX_PORT_INFO_EXA;
typedef struct _FAX_PORT_INFO_EXW
{
    DWORD                           dwSizeOfStruct;            // For versioning
    DWORD                           dwDeviceID;                // Fax id
    LPCWSTR                         lpctstrDeviceName;         // Name of the device
    LPWSTR                          lptstrDescription;         // Descriptive string
    LPCWSTR                         lpctstrProviderName;       // FSP's name
    LPCWSTR                         lpctstrProviderGUID;       // FSP's GUID
    BOOL                            bSend;                     // Is the device send-enabled?
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;               // The device receive mode. See FAX_ENUM_DEVICE_RECEIVE_MODE for details.
    DWORD                           dwStatus;                  // Device status - a combination of values from FAX_ENUM_DEVICE_STATUS
    DWORD                           dwRings;                   // Number of rings before answering an incoming call
    LPWSTR                          lptstrCsid;                // Called Station Id
    LPWSTR                          lptstrTsid;                // Transmitting Station Id
} FAX_PORT_INFO_EXW, *PFAX_PORT_INFO_EXW;
#ifdef UNICODE
typedef FAX_PORT_INFO_EXW FAX_PORT_INFO_EX;
typedef PFAX_PORT_INFO_EXW PFAX_PORT_INFO_EX;
#else
typedef FAX_PORT_INFO_EXA FAX_PORT_INFO_EX;
typedef PFAX_PORT_INFO_EXA PFAX_PORT_INFO_EX;
#endif // UNICODE

WINFAXAPI
DWORD
WINAPI
IsDeviceVirtual (
    IN  HANDLE hFaxHandle,
    IN  DWORD  dwDeviceId,
    OUT LPBOOL lpbVirtual
);


WINFAXAPI
BOOL
WINAPI
FaxGetPortExA (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXA  *ppPortInfo
);
WINFAXAPI
BOOL
WINAPI
FaxGetPortExW (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXW  *ppPortInfo
);
#ifdef UNICODE
#define FaxGetPortEx  FaxGetPortExW
#else
#define FaxGetPortEx  FaxGetPortExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXA  pPortInfo
);
WINFAXAPI
BOOL
WINAPI
FaxSetPortExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
);
#ifdef UNICODE
#define FaxSetPortEx  FaxSetPortExW
#else
#define FaxSetPortEx  FaxSetPortExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExA (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXA *ppPorts,
    OUT LPDWORD             lpdwNumPorts
);
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExW (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
);
#ifdef UNICODE
#define FaxEnumPortsEx  FaxEnumPortsExW
#else
#define FaxEnumPortsEx  FaxEnumPortsExA
#endif // !UNICODE


//********************************************
//*    Recipient and sender information
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
);
WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
);
#ifdef UNICODE
#define FaxGetRecipientInfo  FaxGetRecipientInfoW
#else
#define FaxGetRecipientInfo  FaxGetRecipientInfoA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
);
WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
);
#ifdef UNICODE
#define FaxGetSenderInfo  FaxGetSenderInfoW
#else
#define FaxGetSenderInfo  FaxGetSenderInfoA
#endif // !UNICODE

//********************************************
//*    Outbound routing groups
//********************************************

typedef enum
{
    FAX_GROUP_STATUS_ALL_DEV_VALID,
    FAX_GROUP_STATUS_EMPTY,
    FAX_GROUP_STATUS_ALL_DEV_NOT_VALID,
    FAX_GROUP_STATUS_SOME_DEV_NOT_VALID,
} FAX_ENUM_GROUP_STATUS;


typedef struct _FAX_OUTBOUND_ROUTING_GROUPA
{
    DWORD                       dwSizeOfStruct;
    LPCSTR                      lpctstrGroupName;
    DWORD                       dwNumDevices;
    LPDWORD                     lpdwDevices;
    FAX_ENUM_GROUP_STATUS       Status;
} FAX_OUTBOUND_ROUTING_GROUPA, *PFAX_OUTBOUND_ROUTING_GROUPA;
typedef struct _FAX_OUTBOUND_ROUTING_GROUPW
{
    DWORD                       dwSizeOfStruct;
    LPCWSTR                     lpctstrGroupName;
    DWORD                       dwNumDevices;
    LPDWORD                     lpdwDevices;
    FAX_ENUM_GROUP_STATUS       Status;
} FAX_OUTBOUND_ROUTING_GROUPW, *PFAX_OUTBOUND_ROUTING_GROUPW;
#ifdef UNICODE
typedef FAX_OUTBOUND_ROUTING_GROUPW FAX_OUTBOUND_ROUTING_GROUP;
typedef PFAX_OUTBOUND_ROUTING_GROUPW PFAX_OUTBOUND_ROUTING_GROUP;
#else
typedef FAX_OUTBOUND_ROUTING_GROUPA FAX_OUTBOUND_ROUTING_GROUP;
typedef PFAX_OUTBOUND_ROUTING_GROUPA PFAX_OUTBOUND_ROUTING_GROUP;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsA (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPA   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
);
WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsW (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPW   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
);
#ifdef UNICODE
#define FaxEnumOutboundGroups  FaxEnumOutboundGroupsW
#else
#define FaxEnumOutboundGroups  FaxEnumOutboundGroupsA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupA (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPA pGroup
);
WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupW (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPW pGroup
);
#ifdef UNICODE
#define FaxSetOutboundGroup  FaxSetOutboundGroupW
#else
#define FaxSetOutboundGroup  FaxSetOutboundGroupA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
);
WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
);
#ifdef UNICODE
#define FaxAddOutboundGroup  FaxAddOutboundGroupW
#else
#define FaxAddOutboundGroup  FaxAddOutboundGroupA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
);
WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
);
#ifdef UNICODE
#define FaxRemoveOutboundGroup  FaxRemoveOutboundGroupW
#else
#define FaxRemoveOutboundGroup  FaxRemoveOutboundGroupA
#endif // !UNICODE

BOOL
WINAPI
FaxSetDeviceOrderInGroupA (
        IN      HANDLE          hFaxHandle,
        IN      LPCSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
);
BOOL
WINAPI
FaxSetDeviceOrderInGroupW (
        IN      HANDLE          hFaxHandle,
        IN      LPCWSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
);
#ifdef UNICODE
#define FaxSetDeviceOrderInGroup  FaxSetDeviceOrderInGroupW
#else
#define FaxSetDeviceOrderInGroup  FaxSetDeviceOrderInGroupA
#endif // !UNICODE


//********************************************
//*    Outbound routing rules
//********************************************

typedef enum
{
    FAX_RULE_STATUS_VALID,
    FAX_RULE_STATUS_EMPTY_GROUP,                   // The rule's destination group  has no devices
    FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID,       // The rule's destination group  has valid devices
    FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID,      // The rule's destination group  has some invalid devices
    FAX_RULE_STATUS_BAD_DEVICE                     // The rule's destination device is not valid
} FAX_ENUM_RULE_STATUS;


typedef struct _FAX_OUTBOUND_ROUTING_RULEA
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwAreaCode;
    DWORD                   dwCountryCode;
    LPCSTR                  lpctstrCountryName;
    union
    {
        DWORD                   dwDeviceId;
        LPCSTR                  lpcstrGroupName;
    } Destination;
    BOOL                    bUseGroup;
    FAX_ENUM_RULE_STATUS    Status;
} FAX_OUTBOUND_ROUTING_RULEA, *PFAX_OUTBOUND_ROUTING_RULEA;
typedef struct _FAX_OUTBOUND_ROUTING_RULEW
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwAreaCode;
    DWORD                   dwCountryCode;
    LPCWSTR                 lpctstrCountryName;
    union
    {
        DWORD                   dwDeviceId;
        LPCWSTR                 lpcstrGroupName;
    } Destination;
    BOOL                    bUseGroup;
    FAX_ENUM_RULE_STATUS    Status;
} FAX_OUTBOUND_ROUTING_RULEW, *PFAX_OUTBOUND_ROUTING_RULEW;
#ifdef UNICODE
typedef FAX_OUTBOUND_ROUTING_RULEW FAX_OUTBOUND_ROUTING_RULE;
typedef PFAX_OUTBOUND_ROUTING_RULEW PFAX_OUTBOUND_ROUTING_RULE;
#else
typedef FAX_OUTBOUND_ROUTING_RULEA FAX_OUTBOUND_ROUTING_RULE;
typedef PFAX_OUTBOUND_ROUTING_RULEA PFAX_OUTBOUND_ROUTING_RULE;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEA *ppRules,
    OUT LPDWORD                      lpdwNumRules
);
WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEW *ppRules,
    OUT LPDWORD                      lpdwNumRules
);
#ifdef UNICODE
#define FaxEnumOutboundRules  FaxEnumOutboundRulesW
#else
#define FaxEnumOutboundRules  FaxEnumOutboundRulesA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleA (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEA pRule
);
WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleW (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEW pRule
);
#ifdef UNICODE
#define FaxSetOutboundRule  FaxSetOutboundRuleW
#else
#define FaxSetOutboundRule  FaxSetOutboundRuleA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleA (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
);
WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleW (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCWSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
);
#ifdef UNICODE
#define FaxAddOutboundRule  FaxAddOutboundRuleW
#else
#define FaxAddOutboundRule  FaxAddOutboundRuleA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundRule (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode
);

//********************************************
//*         TAPI countries support
//********************************************

typedef struct _FAX_TAPI_LINECOUNTRY_ENTRYA
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    LPCSTR      lpctstrCountryName;
    LPCSTR      lpctstrLongDistanceRule;
} FAX_TAPI_LINECOUNTRY_ENTRYA, *PFAX_TAPI_LINECOUNTRY_ENTRYA;
typedef struct _FAX_TAPI_LINECOUNTRY_ENTRYW
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    LPCWSTR     lpctstrCountryName;
    LPCWSTR     lpctstrLongDistanceRule;
} FAX_TAPI_LINECOUNTRY_ENTRYW, *PFAX_TAPI_LINECOUNTRY_ENTRYW;
#ifdef UNICODE
typedef FAX_TAPI_LINECOUNTRY_ENTRYW FAX_TAPI_LINECOUNTRY_ENTRY;
typedef PFAX_TAPI_LINECOUNTRY_ENTRYW PFAX_TAPI_LINECOUNTRY_ENTRY;
#else
typedef FAX_TAPI_LINECOUNTRY_ENTRYA FAX_TAPI_LINECOUNTRY_ENTRY;
typedef PFAX_TAPI_LINECOUNTRY_ENTRYA PFAX_TAPI_LINECOUNTRY_ENTRY;
#endif // UNICODE

typedef struct _FAX_TAPI_LINECOUNTRY_LISTA
{
    DWORD                        dwNumCountries;
    PFAX_TAPI_LINECOUNTRY_ENTRYA LineCountryEntries;
} FAX_TAPI_LINECOUNTRY_LISTA, *PFAX_TAPI_LINECOUNTRY_LISTA;
typedef struct _FAX_TAPI_LINECOUNTRY_LISTW
{
    DWORD                        dwNumCountries;
    PFAX_TAPI_LINECOUNTRY_ENTRYW LineCountryEntries;
} FAX_TAPI_LINECOUNTRY_LISTW, *PFAX_TAPI_LINECOUNTRY_LISTW;
#ifdef UNICODE
typedef FAX_TAPI_LINECOUNTRY_LISTW FAX_TAPI_LINECOUNTRY_LIST;
typedef PFAX_TAPI_LINECOUNTRY_LISTW PFAX_TAPI_LINECOUNTRY_LIST;
#else
typedef FAX_TAPI_LINECOUNTRY_LISTA FAX_TAPI_LINECOUNTRY_LIST;
typedef PFAX_TAPI_LINECOUNTRY_LISTA PFAX_TAPI_LINECOUNTRY_LIST;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetCountryListA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTA *ppCountryListBuffer
);
WINFAXAPI
BOOL
WINAPI
FaxGetCountryListW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTW *ppCountryListBuffer
);
#ifdef UNICODE
#define FaxGetCountryList  FaxGetCountryListW
#else
#define FaxGetCountryList  FaxGetCountryListA
#endif // !UNICODE

//********************************************
//*            FSP registration
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID,
    IN LPCSTR         lpctstrFriendlyName,
    IN LPCSTR         lpctstrImageName,
    IN LPCSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
);
WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID,
    IN LPCWSTR         lpctstrFriendlyName,
    IN LPCWSTR         lpctstrImageName,
    IN LPCWSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
);
#ifdef UNICODE
#define FaxRegisterServiceProviderEx  FaxRegisterServiceProviderExW
#else
#define FaxRegisterServiceProviderEx  FaxRegisterServiceProviderExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID
);
#ifdef UNICODE
#define FaxUnregisterServiceProviderEx  FaxUnregisterServiceProviderExW
#else
#define FaxUnregisterServiceProviderEx  FaxUnregisterServiceProviderExA
#endif // !UNICODE


//********************************************
//*            Server events
//********************************************

typedef enum
{
        FAX_EVENT_TYPE_LEGACY           = 0x00000000,
        FAX_EVENT_TYPE_IN_QUEUE         = 0x00000001,
        FAX_EVENT_TYPE_OUT_QUEUE        = 0x00000002,
        FAX_EVENT_TYPE_CONFIG           = 0x00000004,
        FAX_EVENT_TYPE_ACTIVITY         = 0x00000008,
        FAX_EVENT_TYPE_QUEUE_STATE      = 0x00000010,
        FAX_EVENT_TYPE_IN_ARCHIVE       = 0x00000020,
        FAX_EVENT_TYPE_OUT_ARCHIVE      = 0x00000040,
        FAX_EVENT_TYPE_FXSSVC_ENDED     = 0x00000080,
        FAX_EVENT_TYPE_DEVICE_STATUS    = 0x00000100,
        FAX_EVENT_TYPE_NEW_CALL         = 0x00000200
} FAX_ENUM_EVENT_TYPE;

typedef enum
{
        FAX_JOB_EVENT_TYPE_ADDED,
        FAX_JOB_EVENT_TYPE_REMOVED,
        FAX_JOB_EVENT_TYPE_STATUS
} FAX_ENUM_JOB_EVENT_TYPE;

typedef enum
{
        FAX_CONFIG_TYPE_RECEIPTS,
        FAX_CONFIG_TYPE_ACTIVITY_LOGGING,
        FAX_CONFIG_TYPE_OUTBOX,
        FAX_CONFIG_TYPE_SENTITEMS,
        FAX_CONFIG_TYPE_INBOX,
        FAX_CONFIG_TYPE_SECURITY,
        FAX_CONFIG_TYPE_EVENTLOGS,
        FAX_CONFIG_TYPE_DEVICES,
        FAX_CONFIG_TYPE_OUT_GROUPS,
        FAX_CONFIG_TYPE_OUT_RULES
} FAX_ENUM_CONFIG_TYPE;


typedef struct _FAX_EVENT_JOBA
{
        DWORDLONG                       dwlMessageId;
        FAX_ENUM_JOB_EVENT_TYPE         Type;
        PFAX_JOB_STATUSA                pJobData;
} FAX_EVENT_JOBA, *PFAX_EVENT_JOBA;
typedef struct _FAX_EVENT_JOBW
{
        DWORDLONG                       dwlMessageId;
        FAX_ENUM_JOB_EVENT_TYPE         Type;
        PFAX_JOB_STATUSW                pJobData;
} FAX_EVENT_JOBW, *PFAX_EVENT_JOBW;
#ifdef UNICODE
typedef FAX_EVENT_JOBW FAX_EVENT_JOB;
typedef PFAX_EVENT_JOBW PFAX_EVENT_JOB;
#else
typedef FAX_EVENT_JOBA FAX_EVENT_JOB;
typedef PFAX_EVENT_JOBA PFAX_EVENT_JOB;
#endif // UNICODE

typedef struct _FAX_EVENT_DEVICE_STATUS
{
    DWORD       dwDeviceId;     // Id of the device whose status has just changed
    DWORD       dwNewStatus;    // The new status - a combination of values from FAX_ENUM_DEVICE_STATUS
} FAX_EVENT_DEVICE_STATUS, *PFAX_EVENT_DEVICE_STATUS;


typedef struct _FAX_EVENT_NEW_CALLA
{
        HCALL                   hCall;
        DWORD                   dwDeviceId;
        LPTSTR                  lptstrCallerId;
} FAX_EVENT_NEW_CALLA, *PFAX_EVENT_NEW_CALLA;
typedef struct _FAX_EVENT_NEW_CALLW
{
        HCALL                   hCall;
        DWORD                   dwDeviceId;
        LPTSTR                  lptstrCallerId;
} FAX_EVENT_NEW_CALLW, *PFAX_EVENT_NEW_CALLW;
#ifdef UNICODE
typedef FAX_EVENT_NEW_CALLW FAX_EVENT_NEW_CALL;
typedef PFAX_EVENT_NEW_CALLW PFAX_EVENT_NEW_CALL;
#else
typedef FAX_EVENT_NEW_CALLA FAX_EVENT_NEW_CALL;
typedef PFAX_EVENT_NEW_CALLA PFAX_EVENT_NEW_CALL;
#endif // UNICODE


typedef struct _FAX_EVENT_EXA
{
        DWORD                   dwSizeOfStruct;
        FILETIME                TimeStamp;
        FAX_ENUM_EVENT_TYPE     EventType;
        union
        {
                FAX_EVENT_JOBA          JobInfo;
                FAX_ENUM_CONFIG_TYPE    ConfigType;
                FAX_SERVER_ACTIVITY     ActivityInfo;
                FAX_EVENT_NEW_CALL      NewCall;
                DWORD                   dwQueueStates;
                FAX_EVENT_DEVICE_STATUS DeviceStatus;
        } EventInfo;
} FAX_EVENT_EXA, *PFAX_EVENT_EXA;
typedef struct _FAX_EVENT_EXW
{
        DWORD                   dwSizeOfStruct;
        FILETIME                TimeStamp;
        FAX_ENUM_EVENT_TYPE     EventType;
        union
        {
                FAX_EVENT_JOBW          JobInfo;
                FAX_ENUM_CONFIG_TYPE    ConfigType;
                FAX_SERVER_ACTIVITY     ActivityInfo;
                FAX_EVENT_NEW_CALL      NewCall;
                DWORD                   dwQueueStates;
                FAX_EVENT_DEVICE_STATUS DeviceStatus;
        } EventInfo;
} FAX_EVENT_EXW, *PFAX_EVENT_EXW;
#ifdef UNICODE
typedef FAX_EVENT_EXW FAX_EVENT_EX;
typedef PFAX_EVENT_EXW PFAX_EVENT_EX;
#else
typedef FAX_EVENT_EXA FAX_EVENT_EX;
typedef PFAX_EVENT_EXA PFAX_EVENT_EX;
#endif // UNICODE



//-------------------------------------------------------------------------------
//      Printers Info
//-------------------------------------------------------------------------------

typedef struct _FAX_PRINTER_INFOA
{
        LPSTR       lptstrPrinterName;
        LPSTR       lptstrServerName;
        LPSTR       lptstrDriverName;
} FAX_PRINTER_INFOA, *PFAX_PRINTER_INFOA;
typedef struct _FAX_PRINTER_INFOW
{
        LPWSTR      lptstrPrinterName;
        LPWSTR      lptstrServerName;
        LPWSTR      lptstrDriverName;
} FAX_PRINTER_INFOW, *PFAX_PRINTER_INFOW;
#ifdef UNICODE
typedef FAX_PRINTER_INFOW FAX_PRINTER_INFO;
typedef PFAX_PRINTER_INFOW PFAX_PRINTER_INFO;
#else
typedef FAX_PRINTER_INFOA FAX_PRINTER_INFO;
typedef PFAX_PRINTER_INFOA PFAX_PRINTER_INFO;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersA(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersW(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
#ifdef UNICODE
#define FaxGetServicePrinters  FaxGetServicePrintersW
#else
#define FaxGetServicePrinters  FaxGetServicePrintersA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETSERVICEPRINTERSA)(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
typedef BOOL
(WINAPI *PFAXGETSERVICEPRINTERSW)(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
#ifdef UNICODE
#define PFAXGETSERVICEPRINTERS  PFAXGETSERVICEPRINTERSW
#else
#define PFAXGETSERVICEPRINTERS  PFAXGETSERVICEPRINTERSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterForServerEvents (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  DWORD_PTR   dwCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        OUT LPHANDLE    lphEvent
);


WINFAXAPI
BOOL
WINAPI
FaxUnregisterForServerEvents (
        IN  HANDLE      hEvent
);


//********************************************
//*   Manual answer support functions
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxAnswerCall(
        IN  HANDLE      hFaxHandle,
        IN  CONST DWORD dwDeviceId
);

//********************************************
//*   Configuration Wizard support functions
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetConfigWizardUsed (
    OUT LPBOOL  lpbConfigWizardUsed
);

WINFAXAPI
BOOL
WINAPI
FaxSetConfigWizardUsed (
    IN  HANDLE  hFaxHandle,
    OUT BOOL    bConfigWizardUsed
);

//********************************************
//*   Ivalidate archive folder
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxRefreshArchive (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
);

WINFAXAPI
BOOL
FaxSetRecipientsLimit(
    IN HANDLE	hFaxHandle,
    IN DWORD	dwRecipientsLimit
);

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientsLimit(
    IN HANDLE	hFaxHandle,
    OUT LPDWORD	lpdwRecipientsLimit
);

#include "FaxSuite.h"

WINFAXAPI
BOOL
FaxGetServerSKU(
    IN HANDLE	hFaxHandle,
    OUT PRODUCT_SKU_TYPE* pServerSKU
);


//
// FaxCheckValidFaxFolder should be used to verify arbitrary folder paths before they are used
// as a parameter for the store-in-folder routing method.
// It should not be used to verify the fax queue folder or the fax archive folders.
//
WINFAXAPI
BOOL
FaxCheckValidFaxFolder(
    IN HANDLE	hFaxHandle,
    IN LPCWSTR  lpcwstrPath
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\splsetup.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation
All rights reserved.

Module Name:

    splsetup.h

Abstract:

    Holds spooler install headers.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#ifndef _SPLSETUP_H
#define _SPLSETUP_H

#ifdef __cplusplus
extern "C"  {
#endif

//
// Type definitions
//
typedef enum {

    PlatformAlpha,
    PlatformX86,
    PlatformMIPS,
    PlatformPPC,
    PlatformWin95,
    PlatformIA64,
    PlatformAlpha64
} PLATFORM;

typedef enum {

    DRIVER_NAME,
    INF_NAME,
    DRV_INFO_4,
    PRINT_PROCESSOR_NAME,
    ICM_FILES,
    DRV_INFO_6
} FIELD_INDEX;

typedef struct _DRIVER_FIELD {

    FIELD_INDEX Index;
    union {

        LPTSTR          pszDriverName;
        LPTSTR          pszInfName;
        LPDRIVER_INFO_4 pDriverInfo4;
        LPTSTR          pszPrintProc;
        LPTSTR          pszzICMFiles;
        LPDRIVER_INFO_6 pDriverInfo6;
    };
} DRIVER_FIELD, *PDRIVER_FIELD;

typedef struct  _PSETUP_LOCAL_DATA  * PPSETUP_LOCAL_DATA;
typedef struct  _SELECTED_DRV_INFO  * PSELECTED_DRV_INFO;

#define     SELECT_DEVICE_HAVEDISK     0x00000001
#define     SELECT_DEVICE_FROMWEB      0x00000002

//

// Function prototypes
//
HDEVINFO
PSetupCreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    );

BOOL
PSetupDestroyPrinterDeviceInfoList(
    IN  HDEVINFO    hPrinterDevInfo
    );

HPROPSHEETPAGE
PSetupCreateDrvSetupPage(
    IN  HDEVINFO    hDevInfo,
    IN  HWND        hwnd
    );

BOOL
PSetupBuildDriversFromPath(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszDriverPath,
    IN  BOOL        bEnumSingleInf
    );

BOOL
PSetupSelectDriver(
    IN  HDEVINFO    hPrinterDevInfo
    );

BOOL
PSetupPreSelectDriver(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszManufacturer,    OPTIONAL
    IN  LPCTSTR     pszModel            OPTIONAL
    );

PPSETUP_LOCAL_DATA
PSetupGetSelectedDriverInfo(
    IN  HDEVINFO    hDevInfo
    );

PPSETUP_LOCAL_DATA
PSetupDriverInfoFromName(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszModel
    );

BOOL
PSetupDestroySelectedDriverInfo(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    );

//
// Driver install flags
//
#define     DRVINST_FLATSHARE               0x00000001
#define     DRVINST_DONOTCOPY_INF           0x00000002
#define     DRVINST_DRIVERFILES_ONLY        0x00000004
#define     DRVINST_PROMPTLESS              0x00000008
#define     DRVINST_PROGRESSLESS            0x00000010
#define     DRVINST_WEBPNP                  0x00000020

/*
DRVINST_WINDOWS_UPDATE - Flag for PrintUI to set to ensure that SPOST_URL gets set.
                         Setting the SPOST_URL is for setup to ignore the inf of this
                         driver during all setup calls except for a Web Point and Print.
                         This flag makes sure that the driver is install with all the
                         spoolers hosted by the local machines (including cluster spoolers)
*/
#define     DRVINST_WINDOWS_UPDATE          0x00000040
/*
DRVINST_PRIVATE_DIRECTORY - Flag to tell that we want to use a private directory for the copying.
                            This is specifically to fix TS where we can get into a AddPrinterDriver
                                                        race condition where the drivers can get deleted before APD is called when
                                                        adding multiple drivers.
                                                        Note - using this flag means that NTPrint must do the file deletion.
*/
#define     DRVINST_PRIVATE_DIRECTORY       0x00000080

//
// Set if we install drivers for a non-native platform
//
#define     DRVINST_ALT_PLATFORM_INSTALL    0x00000100

//
// Set if we want PSetupInstallPrinterDriver not advertise warned or blocked 
// drivers through the UI. Note that if DRVINST_PROMPTLESS is specified, this
// is implied.
// 
#define     DRVINST_NO_WARNING_PROMPT       0x00000200

//
// Set if we want PSetupInstallPrinterDriver to install the printer driver 
// without asking the user if they would rather have an inbox printer driver
// be installed. This is because the print UI can't necessarily take advantage
// of the new driver at all points.
// 
#define     DRVINST_DONT_OFFER_REPLACEMENT  0x00000400

//
// return values for pdwBlockingStatusFlags
// 
#define BSP_PRINTER_DRIVER_OK                 0
#define BSP_PRINTER_DRIVER_BLOCKED   0x00000001
#define BSP_PRINTER_DRIVER_WARNED    0x00000002
#define BSP_BLOCKING_LEVEL_MASK      0x000000ff

#define BSP_INBOX_DRIVER_AVAILABLE   0x00000100

#define BSP_PRINTER_DRIVER_CANCELLED 0x80000000
#define BSP_PRINTER_DRIVER_PROCEEDED 0x40000000
#define BSP_PRINTER_DRIVER_REPLACED  0x20000000
#define BSP_USER_RESPONSE_MASK       0xff000000

DWORD
PSetupInstallPrinterDriver(
    IN HDEVINFO             hDevInfo,
    IN PPSETUP_LOCAL_DATA   pLocalData,
    IN LPCTSTR              pszDriverName,
    IN PLATFORM             platform,
    IN DWORD                dwVersion,
    IN LPCTSTR              pszServerName,
    IN HWND                 hwnd,
    IN LPCTSTR              pszDiskName,
    IN LPCTSTR              pszSource,
    IN DWORD                dwInstallFlags,
    IN DWORD                dwAddDrvFlags,
    OUT LPTSTR             *ppszNewDriverName
    );

BOOL
PSetupIsCompatibleDriver(
    IN     LPCTSTR      pszServer,                OPTIONAL
    IN     LPCTSTR      pszDriverModel,
    IN     LPCTSTR      pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR      pszEnvironment,
    IN     DWORD        dwVersion,
    IN     FILETIME     *pFileTimeDriver,        
       OUT DWORD        *pdwBlockingStatus,                  // returns BSP_DRIVER_OK, BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED
       OUT LPTSTR       *ppszReplacementDriver     OPTIONAL // caller must free it.
    );

//
// returns BSP_PRINTER_DRIVER_CANCELLED, BSP_PRINTER_DRIVER_PROCEEDED or BSP_PRINTER_DRIVER_REPLACED
//
DWORD
PSetupShowBlockedDriverUI(
    HWND        hParentWnd, 
    DWORD       BlockingStatus      // can be BSP_DRIVER_OK, BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED  OR'd with BSP_INBOX_REPLACEMENT_AVAILABLE
);


#define     DRIVER_MODEL_NOT_INSTALLED                  0
#define     DRIVER_MODEL_INSTALLED_AND_IDENTICAL        1
#define     DRIVER_MODEL_INSTALLED_BUT_DIFFERENT       -1

#define     KERNEL_MODE_DRIVER_VERSION                 -1

BOOL
PSetupIsDriverInstalled(
    IN LPCTSTR      pszServerName,
    IN LPCTSTR      pszDriverName,
    IN PLATFORM     platform,
    IN DWORD        dwMajorVersion
    );

INT
PSetupIsTheDriverFoundInInfInstalled(
    IN  LPCTSTR             pszServerName,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwMajorVersion
    );

PLATFORM
PSetupThisPlatform(
    VOID
    );

BOOL
PSetupGetPathToSearch(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszDiskName,
    IN      LPCTSTR     pszFileName,
    IN      BOOL        bPromptForInf,
    IN OUT  TCHAR       szPath[MAX_PATH]
    );

BOOL
PSetupProcessPrinterAdded(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    );

BOOL
PSetupSetSelectDevTitleAndInstructions(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszTitle,
    IN  LPCTSTR     pszSubTitle,
    IN  LPCTSTR     pszInstn
    );

BOOL
PSetupSelectDeviceButtons(
   IN HDEVINFO      hDevInfo,
   IN DWORD         dwFlagsSet,
   IN DWORD         dwFlagsClear
   );

BOOL
PSetupGetLocalDataField(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    );

VOID
PSetupFreeDrvField(
    IN      PDRIVER_FIELD   pDrvField
    );

//
// Internet printing support
//
BOOL
PSetupGetDriverInfForPrinter(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszPrinterName,
    IN OUT  LPTSTR      pszInfName,
    IN OUT  LPDWORD     pcbInfNameSize
    );

DWORD
PSetupInstallPrinterDriverFromTheWeb(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  LPOSVERSIONINFO     pOsVersionInfo,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszSource
    );

//
// Monitor Installation Functions
//
HANDLE
PSetupCreateMonitorInfo(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszServerName
    );

VOID
PSetupDestroyMonitorInfo(
    IN OUT HANDLE  h
    );

BOOL
PSetupEnumMonitor(
    IN     HANDLE   h,
    IN     DWORD    dwIndex,
    OUT    LPTSTR   pMonitorName,
    IN OUT LPDWORD  pdwSize
    );


BOOL
PSetupInstallMonitor(
    IN  HWND        hwnd
    );


//
// Following exported for test team's use
//
LPDRIVER_INFO_3
PSetupGetDriverInfo3(
    IN  PSELECTED_DRV_INFO  pDrvInfo
    );

VOID
PSetupDestroyDriverInfo3(
    IN LPDRIVER_INFO_3 pDriverInfo3
    );

BOOL
PSetupFindMappedDriver(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    );

//
// For Win9x upgrade
//
BOOL
PSetupAssociateICMProfiles(
    IN  LPCTSTR             pszzICMFiles,
    IN  LPCTSTR             pszPrinterName
    );

BOOL
PSetupInstallICMProfiles(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    );

//
// For spooler
//
VOID
PSetupFreeMem(
    PVOID p
    );


//
// Following are the typdefs for calling GetProcAddress()
//
typedef
HDEVINFO
(*pfPSetupCreatePrinterDeviceInfoList)(
    IN      HWND        hwnd
    );

typedef
VOID
(*pfPSetupDestroyPrinterDeviceInfoList)(
    IN      HDEVINFO    h
    );

typedef
BOOL
(*pfPSetupSelectDriver)(
    IN      HDEVINFO    h
    );

typedef
HPROPSHEETPAGE
(*pfPSetupCreateDrvSetupPage)(
    IN      HDEVINFO    h,
    IN      HWND        hwnd
    );

typedef
PPSETUP_LOCAL_DATA
(*pfPSetupGetSelectedDriverInfo)(
    IN      HDEVINFO    h
    );

typedef
VOID
(*pfPSetupDestroySelectedDriverInfo)(
    IN      PPSETUP_LOCAL_DATA  pSelectedDrvInfo
    );

typedef
DWORD
(*pfPSetupInstallPrinterDriver)(
    IN      HDEVINFO            h,
    IN      PPSETUP_LOCAL_DATA  pSelectedDrvInfo,
    IN      LPCTSTR             pszDriverName,
    IN      PLATFORM            platform,
    IN      DWORD               dwVersion,
    IN      LPCTSTR             pszServerName,
    IN      HWND                hwnd,
    IN      LPCTSTR             pszPlatformName,
    IN      LPCTSTR             pszSourcePath,
    IN      DWORD               dwInstallFlags,
    IN      DWORD               dwAddDrvFlags,
    OUT     LPTSTR             *ppszNewDriverName
    );

typedef
BOOL
(*pfPSetupIsDriverInstalled)(
    IN      LPCTSTR     pszServerName,
    IN      LPCTSTR     pszDriverName,
    IN      PLATFORM    platform,
    IN      DWORD       dwMajorVersion
    );

typedef
INT
(*pfPSetupIsTheDriverFoundInInfInstalled)(
    IN      LPCTSTR             pszServerName,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      DWORD               dwMajorVersion
    );

typedef
PLATFORM
(*pfPSetupThisPlatform)(
    VOID
    );

typedef
BOOL
(*pfPSetupGetPathToSearch)(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszTitle,
    IN  LPCTSTR     pszDiskName,
    IN  LPCTSTR     pszFileName,
    IN  BOOL        bPromptForInf,
    OUT TCHAR       szPath[MAX_PATH]
    );

typedef
PPSETUP_LOCAL_DATA
(*pfPSetupDriverInfoFromName)(
    IN      HDEVINFO    h,
    IN      LPCTSTR     pszModel
    );

typedef
BOOL
(*pfPSetupPreSelectDriver)(
    IN      HDEVINFO    h,
    IN      LPCTSTR     pszManufacturer,    OPTIONAL
    IN      LPCTSTR     pszModel            OPTIONAL
    );

typedef
HANDLE
(*pfPSetupCreateMonitorInfo)(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszServerName
    );

typedef
VOID
(*pfPSetupDestroyMonitorInfo)(
    IN      HANDLE      h
    );

typedef
BOOL
(*pfPSetupEnumMonitor)(
    IN      HANDLE      h,
    IN      DWORD       dwIndex,
       OUT  LPTSTR      pMonitorName,
    IN OUT  LPDWORD     pdwSize
    );

typedef
BOOL
(*pfPSetupInstallMonitor)(
    IN      HWND        hwnd
    );


typedef
BOOL
(*pfPSetupProcessPrinterAdded)(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      LPCTSTR             pszPrinterName,
    IN      HWND                hwnd
    );

typedef
BOOL
(*pfPSetupBuildDriversFromPath)(
    IN      HANDLE      h,
    IN      LPCTSTR     pszDriverPath,
    IN      BOOL        bEnumSingleInf
    );

typedef
BOOL
(*pfPSetupSetSelectDevTitleAndInstructions)(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszSubTitle,
    IN      LPCTSTR     pszInstn
    );

typedef
BOOL
(*pfPSetupSelectDeviceButtons)(
   IN HDEVINFO      hDevInfo,
   IN DWORD         dwFlagsSet,
   IN DWORD         dwFlagsClear
   );

typedef
DWORD
(*pfPSetupInstallPrinterDriverFromTheWeb)(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      LPOSVERSIONINFO     pOsVersionInfo,
    IN      HWND                hwnd,
    IN      LPCTSTR             pszSource
    );

typedef
BOOL
(*pfPSetupGetLocalDataField)(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    );

typedef
VOID
(*pfPSetupFreeDrvField)(
    IN      PDRIVER_FIELD   pDrvField
    );

typedef
BOOL
(*pfPSetupAssociateICMProfiles)(
    IN  LPCTSTR             pszzICMFiles,
    IN  LPCTSTR             pszPrinterName
    );

typedef
BOOL
(*pfPSetupInstallICMProfiles)(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    );

typedef
BOOL
(*pfPSetupIsCompatibleDriver)(
    IN     LPCTSTR      pszServer,                OPTIONAL
    IN     LPCTSTR      pszDriverModel,
    IN     LPCTSTR      pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR      pszEnvironment,
    IN     DWORD        dwVersion,
    IN     FILETIME     *pFileTimeDriver,        
       OUT DWORD        *pdwBlockingStatus,
       OUT LPTSTR       *ppszReplacementDriver     OPTIONAL // caller must free it.
    );

typedef 
DWORD
(*pfPSetupShowBlockedDriverUI)(
    HWND        hParentWnd, 
    DWORD       BlockingStatus      // can be BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED, OR'd with BSP_INBOX_REPLACEMENT_AVAILABLE
);

typedef
BOOL
(*pfPSetupFindMappedDriver)(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    );

typedef
DWORD
(*pfPSetupInstallInboxDriverSilently)(
    IN      LPCTSTR     pszDriverName
    );

typedef
VOID
(*pfPSetupFreeMem)(
    PVOID p
    );



#ifdef __cplusplus

}
#endif

#endif  // #ifndef _SPLSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\splapip.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    SplApiP.h

Abstract:

    Header file for Private Print APIs
    For use in stress

Author:

    Matthew Felton (MattFe) 4-Mar-1994

Revision History:

--*/
#ifndef SPLAPIP_H_
#define SPLAPIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "lmon.h"

// Internal Used to report Stress test results

#define STRESSINFOLEVEL 0

//  W A R N I N G
//
//  Do not alter the size of this structure it will break NT interop with older releases if you do.

typedef struct _PRINTER_INFO_STRESSA {
    LPSTR   pPrinterName;           // Printer Name locally "Printername" remotely "\\servername\printername"
    LPSTR   pServerName;            // Server Name
    DWORD   cJobs;                  // Number of Jobs currently in Print Queue
    DWORD   cTotalJobs;             // Total Number of Jobs spooled
    DWORD   cTotalBytes;            // Total Bytes Printed (LOW DWORD)
    SYSTEMTIME stUpTime;            // Time printed data structure crated UTC
    DWORD   MaxcRef;                // Maximum number of cRef
    DWORD   cTotalPagesPrinted;     // Total number of pages printed
    DWORD   dwGetVersion;           // OS version
    DWORD   fFreeBuild;             // TRUE for free build
    DWORD   cSpooling;              // Number of jobs actively spooling
    DWORD   cMaxSpooling;           // Maximum number of cSpooling
    DWORD   cRef;                   // Printer object reference count (opened)
    DWORD   cErrorOutOfPaper;       // Total Number of Out Of Paper Errors
    DWORD   cErrorNotReady;         // Total Number of Error Not Ready
    DWORD   cJobError;              // Total number of Job Errors
    DWORD   dwNumberOfProcessors;   // Number of Processors on computer
    DWORD   dwProcessorType;        // Processor Type of computer
    DWORD   dwHighPartTotalBytes;   // Total Bytes Printed (HIGH DWORD)
    DWORD   cChangeID;              // Count of Changes to Printer Config
    DWORD   dwLastError;            // Last Error
    DWORD   Status;                 // Current Printer Status
    DWORD   cEnumerateNetworkPrinters; // Count How Many Times Browse List Requested
    DWORD   cAddNetPrinters;        // Count of NetPrinters Added ( Browser )
    WORD    wProcessorArchitecture; // Processor Architecture of computer
    WORD    wProcessorLevel;        // Processor Level of computer
    DWORD   cRefIC;                 // Count of open IC handles
    DWORD   dwReserved2;            // Reserved for Future Use
    DWORD   dwReserved3;

} PRINTER_INFO_STRESSA, *PPRINTER_INFO_STRESSA, *LPPRINTER_INFO_STRESSA;

typedef struct _PRINTER_INFO_STRESSW {
    LPWSTR  pPrinterName;           // Printer Name locally "Printername" remotely "\\servername\printername"
    LPWSTR  pServerName;            // Server Name
    DWORD   cJobs;                  // Number of Jobs currently in Print Queue
    DWORD   cTotalJobs;             // Total Number of Jobs spooled
    DWORD   cTotalBytes;            // Total Bytes Printed (LOW DWORD)
    SYSTEMTIME stUpTime;            // Time printed data structure crated UTC
    DWORD   MaxcRef;                // Maximum number of cRef
    DWORD   cTotalPagesPrinted;     // Total number of pages printed
    DWORD   dwGetVersion;           // OS version
    DWORD   fFreeBuild;             // TRUE for free build
    DWORD   cSpooling;              // Number of jobs actively spooling
    DWORD   cMaxSpooling;           // Maximum number of cSpooling
    DWORD   cRef;                   // Printer object reference count (opened)
    DWORD   cErrorOutOfPaper;       // Total Number of Out Of Paper Errors
    DWORD   cErrorNotReady;         // Total Number of Error Not Ready
    DWORD   cJobError;              // Total number of Job Errors
    DWORD   dwNumberOfProcessors;   // Number of Processors on computer
    DWORD   dwProcessorType;        // Processor Type of computer
    DWORD   dwHighPartTotalBytes;   // Total Bytes Printed (HIGH DWORD)
    DWORD   cChangeID;              // Count of Changes to Printer Config
    DWORD   dwLastError;            // Last Error
    DWORD   Status;                 // Current Printer Status
    DWORD   cEnumerateNetworkPrinters; // Count How Many Times Browse List Requested
    DWORD   cAddNetPrinters;        // Count of NetPrinters Added ( Browser )
    WORD    wProcessorArchitecture; // Processor Architecture of computer
    WORD    wProcessorLevel;        // Processor Level of computer
    DWORD   cRefIC;                 // Count of open IC handles
    DWORD   dwReserved2;            // Reserved for Future Use
    DWORD   dwReserved3;

} PRINTER_INFO_STRESSW, *PPRINTER_INFO_STRESSW, *LPPRINTER_INFO_STRESSW;


typedef struct _DRIVER_UPGRADE_INFO_1W {
    LPWSTR   pPrinterName;           // Printer Name being upgraded
    LPWSTR   pOldDriverDirectory;    // fully qualified path to old printer driver

} DRIVER_UPGRADE_INFO_1W, *PDRIVER_UPGRADE_INFO_1W, *LPDRIVER_UPGRADE_INFO_1W;


#ifdef UNICODE
#define PRINTER_INFO_STRESS PRINTER_INFO_STRESSW
#define PPRINTER_INFO_STRESS PPRINTER_INFO_STRESSW
#define LPPRINTER_INFO_STRESS LPPRINTER_INFO_STRESSW
#else
#define PRINTER_INFO_STRESS PRINTER_INFO_STRESSA
#define PPRINTER_INFO_STRESS PPRINTER_INFO_STRESSA
#define LPPRINTER_INFO_STRESS LPPRINTER_INFO_STRESSA
#endif // UNICODE


BOOL
AddPortExW(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
);

BOOL
AddPortExA(
    LPSTR pName,
    DWORD Level,
    LPBYTE lpBuffer,
    LPSTR  lpMonitorName
);

BOOL
SetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
);


#ifdef UNICODE
#define AddPortEx AddPortExW
#else
#define AddPortEx AddPortExA
#endif // !UNICODE

//
//  Interfaces to Spooler APIs
//

HANDLE
SplAddPrinter(
    LPWSTR      pName,
    DWORD       Level,
    LPBYTE      pPrinter,
    HANDLE      pIniSpooler,
    LPBYTE      pExtraData,
    LPBYTE      pSplClientInfo,
    DWORD       dwLevel
);

BOOL
SplDeletePrinter(
    HANDLE  hPrinter
);

BOOL
SplEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

DWORD
SplOpenPrinter(
   LPWSTR               pPrinterName,
   LPHANDLE             phPrinter,
   LPPRINTER_DEFAULTS   pDefault,
   HANDLE               pIniSpooler,
   LPBYTE               pSplClientInfo,
   DWORD                dwLevel
);


BOOL
SplDeletePrinterDriver(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    HANDLE   pIniSpooler
);

BOOL
SplDeletePrinterDriverEx(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pDriverName,
    HANDLE   pIniSpooler,
    DWORD    dwDeleteFlag,
    DWORD    dwVersionNum
);

BOOL
SplGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    HANDLE   pIniSpooler
);


BOOL
SplGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    HANDLE   pIniSpooler
);

BOOL
SplAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPVOID   pBuffer,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    HANDLE  pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

BOOL
SplAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    HANDLE  pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
);

BOOL
SplAddDriverCatalog(
    HANDLE hPrinter,
    DWORD  dwLevel,
    VOID   *pvDriverInfCatInfo,
    DWORD  dwCatalogCopyFlags
);

BOOL
SplDeleteMonitor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName,
    HANDLE   pIniSpooler
);

BOOL
SplDeletePrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName,
    HANDLE   pIniSpooler
);

BOOL
SplAddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName,
    HANDLE   pIniSpooler
);


BOOL
SplAddMonitor(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo,
    HANDLE   pIniSpooler
);

BOOL
SplMonitorIsInstalled(
    LPWSTR  pMonitorName
);

BOOL
SplDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName,
    HANDLE   pIniSpooler
);

BOOL
SplEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

BOOL
SplConfigurePort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pPortName,
    HANDLE   pIniSpooler
);


BOOL
SplXcvData(
    HANDLE      hXcv,
    LPCWSTR     pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    HANDLE      pIniSpooler
);


BOOL
SplEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


BOOL
SplEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


BOOL
SplEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);

BOOL
SplEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    HANDLE   pIniSpooler
);


VOID
SplBroadcastChange(
    HANDLE  hPrinter,
    DWORD   Message,
    WPARAM  wParam,
    LPARAM  lParam
);


typedef struct _SPOOLER_INFO_1 {
    LPWSTR pDir;
    LPWSTR pDefaultSpoolDir;
    LPWSTR pszRegistryRoot;
    LPWSTR pszRegistryPrinters;
    LPWSTR pszRegistryMonitors;
    LPWSTR pszRegistryEnvironments;
    LPWSTR pszRegistryEventLog;
    LPWSTR pszRegistryProviders;
    LPWSTR pszEventLogMsgFile;
    LPWSTR pszDriversShare;
    LPWSTR pszRegistryForms;
    DWORD   SpoolerFlags;
    FARPROC pfnReadRegistryExtra;
    FARPROC pfnWriteRegistryExtra;
    FARPROC pfnFreePrinterExtra;
} SPOOLER_INFO_1, *PSPOOLER_INFO_1, *LPSPOOLER_INFO_1;

typedef struct _SPOOLER_INFO_2 {
    LPWSTR pDir;
    LPWSTR pDefaultSpoolDir;
    LPWSTR pszRegistryRoot;
    LPWSTR pszRegistryPrinters;
    LPWSTR pszRegistryMonitors;
    LPWSTR pszRegistryEnvironments;
    LPWSTR pszRegistryEventLog;
    LPWSTR pszRegistryProviders;
    LPWSTR pszEventLogMsgFile;
    LPWSTR pszDriversShare;
    LPWSTR pszRegistryForms;
    DWORD   SpoolerFlags;
    FARPROC pfnReadRegistryExtra;
    FARPROC pfnWriteRegistryExtra;
    FARPROC pfnFreePrinterExtra;
    LPWSTR pszResource;
    LPWSTR pszName;
    LPWSTR pszAddress;
    LPWSTR pszClusResID;
    LPWSTR pszClusResDriveLetter;
} SPOOLER_INFO_2, *PSPOOLER_INFO_2, *LPSPOOLER_INFO_2;

#define SPL_UPDATE_WININI_DEVICES                   0x00000001
#define SPL_PRINTER_CHANGES                         0x00000002
#define SPL_LOG_EVENTS                              0x00000004
#define SPL_FORMS_CHANGE                            0x00000008
#define SPL_BROADCAST_CHANGE                        0x00000010
#define SPL_SECURITY_CHECK                          0x00000020
#define SPL_OPEN_CREATE_PORTS                       0x00000040
#define SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION     0x00000080
#define SPL_REMOTE_HANDLE_CHECK                     0x00000100
#define SPL_PRINTER_DRIVER_EVENT                    0x00000200

#define SPL_ALWAYS_CREATE_DRIVER_SHARE              0x00000400
#define SPL_NO_UPDATE_PRINTERINI                    0x00000800
#define SPL_NO_UPDATE_JOBSHD                        0x00001000
#define SPL_CLUSTER_REG                             0x00002000
#define SPL_OFFLINE                                 0x00004000
#define SPL_PENDING_DELETION                        0x00008000
#define SPL_SERVER_THREAD                           0x00010000
#define SPL_PRINT                                   0x00020000
#define SPL_NON_RAW_TO_MASQ_PRINTERS                0x00040000
#define SPL_OPEN_EXISTING_ONLY                      0x00080000

#define SPL_TYPE                                    0xff000000
#define SPL_TYPE_LOCAL                              0x01000000
#define SPL_TYPE_CLUSTER                            0x02000000
#define SPL_TYPE_CACHE                              0x04000000


HANDLE
SplCreateSpooler(
    LPWSTR  pMachineName,
    DWORD   Level,
    PBYTE   pSpooler,
    LPBYTE  pReserved
);

BOOL
SplDeleteSpooler(
    HANDLE  hSpooler
);

BOOL
SplCloseSpooler(
    HANDLE  hSpooler
);


BOOL
SplEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
SplAddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);

BOOL
SplDeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
);

BOOL
SplGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplSetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);

BOOL
SplClosePrinter(
    HANDLE hPrinter
);

DWORD
SplGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

DWORD
SplGetPrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);


DWORD
SplEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
);

DWORD
SplEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
SplEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey       // address for size of value buffer
);


DWORD
SplDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
);


DWORD
SplDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
);

DWORD
SplDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
);


DWORD
SplSetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

DWORD
SplSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
SplGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplGetPrinterDriverEx(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
);


BOOL
SplResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);


BOOL
SplGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
SplSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    DWORD   Command
);

BOOL
SplSetPrinterExtra(
    HANDLE  hPrinter,
    LPBYTE  pExtraData
);

BOOL
SplGetPrinterExtra(
    HANDLE  hPrinter,
    PBYTE   *ppExtraData
);

BOOL
SplSetPrinterExtraEx(
    HANDLE  hPrinter,
    DWORD   dwPrivateFlag
);

BOOL
SplGetPrinterExtraEx(
    HANDLE  hPrinter,
    LPDWORD pdwPrivateFlag
);

BOOL
SplDriverEvent(
    LPWSTR  pName,
    INT     PrinterEvent,
    LPARAM  lParam,
    DWORD   *pdwReturnedError
);

BOOL
SplCopyNumberOfFiles(
    LPWSTR  pszPrinterName,
    LPWSTR  *ppszSourceFileNames,
    DWORD   dwCount,
    LPWSTR  pszTargetDir,
    LPBOOL  pbFilesAddedOrUpdated
    );

BOOL
SplGetDriverDir(
    HANDLE  hIniSpooler,
    LPWSTR  pszDir,
    LPDWORD pcchDir
    );

HMODULE
SplLoadLibraryTheCopyFileModule(
    HANDLE  hPrinter,
    LPWSTR  pszModule
    );

BOOL
SplCopyFileEvent(
    HANDLE  hPrinter,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    );

VOID
SplDriverUnloadComplete(
    LPWSTR   pDriverFile
    );

BOOL
SplGetSpoolFileInfo(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL
SplCommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL
SplCloseSpoolFileHandle(
    HANDLE  hPrinter
    );

BOOL
bGetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE *ppDevMode
    );

BOOL
bSetDevModePerUser(
    HKEY hKeyUser,
    LPCWSTR pszPrinter,
    PDEVMODE pDevMode
    );

DWORD 
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCWSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:

    Adina Trufinescu (adinatru) 12-Dec-1999
    Define LPDEVMODEW and PSECURITY_DESCRIPTOR as pointers in order to
    let RPC do the conversion from a 32bit to a 64bit quantity. Make sure 
    these pointers are set on NULL all over the place where use PRINTER_CONTAINER,
    otherwise RPC will get confused when try to marshall.
--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   ULONG_PTR
#define PSECURITY_DESCRIPTOR ULONG_PTR
#define HANDLE      ULONG_PTR
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>
#include <..\..\..\..\public\internal\printscan\inc\splapip.h>
#include <..\..\..\..\public\internal\windows\inc\winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\kmspool.h ===
BOOL KMOpenPrinterW(LPWSTR   pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTS pDefault);

BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);


BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);
DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
);

BOOL
KMStartPagePrinter(
    HANDLE hPrinter
);

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
KMClosePrinter(
    HANDLE  hPrinter);

BOOL
KMAbortPrinter(
    HANDLE  hPrinter);

VOID
FreeSpool(
    PSPOOL pSpool);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winprtp.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation
All rights reserved.

Module Name:

    WinPrtP.h

Abstract:

    Private PrintUI library public header.

Author:

    Albert Ting (AlbertT)  27-Jun-95

Revision History:

--*/

DEFINE_GUID(CLSID_PrintUIShellExtension, 0x77597368, 0x7b15, 0x11d0, 0xa0, 0xc2, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03 );
DEFINE_GUID(IID_IFindPrinter, 0xb4cd8efc, 0xd70b, 0x11d1, 0x99, 0xb1, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPrinterFolder,  0xef99abd4, 0x5b8d, 0x11d1, 0xa9, 0xc8, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IFolderNotify,  0xff22d71, 0x5172, 0x11d1, 0xa9, 0xc6, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IDsPrinterProperties,0x8a58bc16, 0x410e, 0x11d1, 0xa9, 0xc2, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPhysicalLocation, 0xdfe8c7eb, 0x651b, 0x11d2, 0x92, 0xce, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03);
DEFINE_GUID(IID_IPrnStream, 0xa24c1d62, 0x75f5, 0x11d2, 0xb8, 0x99, 0x0, 0xc0, 0x4f, 0x86, 0xae, 0x55);

// {2E4599E1-BE2C-436a-B0AD-3D0E347F34B3}
DEFINE_GUID(IID_IPrintUIServices, 0x2e4599e1, 0xbe2c, 0x436a, 0xb0, 0xad, 0x3d, 0xe, 0x34, 0x7f, 0x34, 0xb3);


#ifndef _PRTLIB_H
#define _PRTLIB_H

#ifdef __cplusplus
extern "C" {
#endif

/********************************************************************

    Prototypes

********************************************************************/

//
// Initialize the library.
//
BOOL
bPrintLibInit(
    VOID
    );

//
// Create a new print queue.
//
VOID
vQueueCreate(
    HWND    hwndOwner,
    LPCTSTR pszPrinter,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Display document defaults for a print queue.
//
VOID
vDocumentDefaults(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

#define PRINTER_SHARING_PAGE 1

//
// Display properties for a print queue.
//
VOID
vPrinterPropPages(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

VOID
vServerPropPages(
    HWND    hwndOwner,
    LPCTSTR pszServerName,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Run printer and drivers setup.
//
BOOL
bPrinterSetup(
    HWND    hwnd,
    UINT    uAction,
    UINT    cchPrinterName,
    LPTSTR  pszPrinterName,
    UINT*   pcchPrinterName,
    LPCTSTR pszServerName
    );

/********************************************************************

    Print folder interfaces.

********************************************************************/

/********************************************************************

    Printers Folder Extenstion Interface.  This interface extends
    the printers IShellFolder implementation.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrinterFolder

DECLARE_INTERFACE_(IPrinterFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPrintersFolder methods ***
    STDMETHOD_(BOOL, IsPrinter)( THIS_ LPCITEMIDLIST pidl ) PURE;
};

/********************************************************************

    Folder Notification interface.

********************************************************************/

//
// Folder notify type
//

typedef enum IFolderNotifyType
{
    kFolderNone,                            // No item changed do not generate notification
    kFolderUpdate,                          // Item changed
    kFolderAttributes,                      // Item attribute changed
    kFolderCreate,                          // Item created
    kFolderDelete,                          // Item deleted
    kFolderRename,                          // Item renamed
    kFolderUpdateAll,                       // Update all items == 'F5'
} FOLDER_NOTIFY_TYPE, *PFOLDER_NOTIFY_TYPE;

//
// Folder notification callback interface definition.
//

#undef  INTERFACE
#define INTERFACE   IFolderNotify

DECLARE_INTERFACE_(IFolderNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IFolderNotify methods ***
    STDMETHOD_(BOOL, ProcessNotify)( THIS_ FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName ) PURE;
};

typedef struct _FOLDER_PRINTER_DATA {
    LPCTSTR pName;
    LPCTSTR pComment;
    DWORD   Status;
    DWORD   Attributes;
    DWORD   cJobs;
    DWORD   cbSize;
    LPCTSTR pLocation;
    LPCTSTR pDriverName;
    LPCTSTR pStatus;            // Connection status i.e. <opening...>
    LPCTSTR pPortName;
} FOLDER_PRINTER_DATA, *PFOLDER_PRINTER_DATA;

//
// Register folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder,
    OUT  PBOOL                   pbAdministrator OPTIONAL
    );

//
// Unregister folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    );

BOOL
bFolderEnumPrinters(
    IN   HANDLE                  hFolder,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded,
    OUT  PDWORD                  pcbReturned
    );

BOOL
bFolderRefresh(
    IN   HANDLE                  hFolder,
    OUT  PBOOL                   pbAdministrator
    );

BOOL
bFolderGetPrinter(
    IN   HANDLE                  hFolder,
    IN   LPCTSTR                 pszPrinter,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded
    );

/********************************************************************

    PrintUI error support (exposed to shell)

********************************************************************/

HRESULT
ShowErrorMessageSC(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  DWORD                dwCode
    );

HRESULT
ShowErrorMessageHR(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  HRESULT              hr
    );

/********************************************************************

    IPhysicalLocation

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPhysicalLocation

DECLARE_INTERFACE_(IPhysicalLocation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPhysicalLocation methods
    STDMETHOD(DiscoverPhysicalLocation)(THIS) PURE;
    STDMETHOD(GetExactPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSearchPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;

    // IPhysicalLocation methods for fetching individual physical locations
    STDMETHOD(GetUserPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetMachinePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSubnetPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSitePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(BrowseForLocation)(THIS_ HWND hParent, BSTR bsDefault, BSTR *pbsLocation) PURE;
    STDMETHOD(ShowPhysicalLocationUI)(THIS) PURE;
};

/********************************************************************

    IDsPrinterProperties

    This is a private interface used to launch printer properties
    from the DS MMC snapin.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IDsPrinterProperties

DECLARE_INTERFACE_(IDsPrinterProperties, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IDsFolder methods
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, LPCWSTR pszObjectPath, PBOOL pbDisplayed) PURE;
};

/********************************************************************

    Find Printer Interface.  This inferface allows a user to find
    a printer either on the network or in the DS if one is
    available.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IFindPrinter

DECLARE_INTERFACE_(IFindPrinter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindPrinter methods
    STDMETHOD(FindPrinter)(THIS_ HWND hwnd, LPWSTR pszBuffer, UINT *puSize) PURE;
};

/********************************************************************

    IPageSwitch - Interface used as a connection point for
    the connect to printer dialog when integrated in a wizard.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPageSwitch

DECLARE_INTERFACE(IPageSwitch)
{
    // *** INotifyReflect methods ***

    //
    // This functions provide opportunity to the client to change
    // the next/prev page ID and/or allow/deny advancing to the
    // next/prev page.
    //
    // S_OK:        means you can advance to the next/prev page
    // S_FALSE:     means you cant advance to the next/prev page
    //
    STDMETHOD(GetPrevPageID)( THIS_ UINT *puPageID ) PURE;
    STDMETHOD(GetNextPageID)( THIS_ UINT *puPageID ) PURE;

    //
    // The property page calls this method when the printer connection is
    // successfully created and we are about to advance to the
    // next/prev page
    //
    STDMETHOD(SetPrinterInfo)( THIS_ LPCWSTR pszPrinterName, LPCWSTR pszComment, LPCWSTR pszLocation, LPCWSTR pszShareName ) PURE;

    //
    // This method provide notification to the client that
    // the user clicked "Cancel" button on the wizard - which
    // normaly leads to closing the wizard.
    //
    // S_OK     - Prevent cancel operation
    // S_FALSE  - Allow cancel operation
    //
    STDMETHOD(QueryCancel)( THIS ) PURE;
};

//
// The API function for creating the ConnectToPrinterDlg style
// property page
//
HRESULT
ConnectToPrinterPropertyPage(
    OUT HPROPSHEETPAGE   *phPsp,
    OUT UINT             *puPageID,
    IN  IPageSwitch      *pPageSwitchController
    );

/********************************************************************

    IPrnStream flags

********************************************************************/

typedef enum _PrinterPersistentFlags
{
    PRST_PRINTER_DATA       = 1<<0,
    PRST_PRINTER_INFO_2     = 1<<1,
    PRST_PRINTER_INFO_7     = 1<<2,
    PRST_PRINTER_SEC        = 1<<3,
    PRST_USER_DEVMODE       = 1<<4,
    PRST_PRINTER_DEVMODE    = 1<<5,
    PRST_COLOR_PROF         = 1<<6,
    PRST_FORCE_NAME         = 1<<7,
    PRST_RESOLVE_NAME       = 1<<8,
    PRST_RESOLVE_PORT       = 1<<9,
    PRST_RESOLVE_SHARE      = 1<<10,
    PRST_DONT_GENERATE_SHARE = 1<<11,
    PRST_DONT_CHANGE_DRIVER = 1 <<12,
    PRST_MINIMUM_SETTINGS   = PRST_PRINTER_DATA | PRST_PRINTER_INFO_2 | PRST_PRINTER_DEVMODE,
    PRST_ALL_SETTINGS       = PRST_MINIMUM_SETTINGS | 
                              PRST_PRINTER_INFO_7   | 
                              PRST_PRINTER_SEC      | 
                              PRST_USER_DEVMODE     | 
                              PRST_COLOR_PROF,
} PrinterPersistentFlags;

/********************************************************************

    IPrnStream query flags.

********************************************************************/

typedef enum _PrinterPersistentQueryFlag
{
    kPrinterPersistentPrinterInfo2,
    kPrinterPersistentPrinterInfo7,
    kPrinterPersistentUserDevMode,
    kPrinterPersistentPrinterDevMode,
    kPrinterPersistentSecurity,
    kPrinterPersistentColorProfile,
} PrinterPersistentQueryFlag;

typedef union _PersistentInfo
{
    PRINTER_INFO_2      *pi2;
    PRINTER_INFO_7      *pi7;
    DEVMODE             *pDevMode;
    SECURITY_DESCRIPTOR *pszSecurity;
    LPWSTR              pMultiSzColor;
} PersistentInfo;

/********************************************************************

    IPrnStream interface definition

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrnStream

DECLARE_INTERFACE_(IPrnStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPrnStream methods
    STDMETHOD(BindPrinterAndFile)(THIS_ LPCWSTR pszPrinter, LPCWSTR pszFile) PURE;
    STDMETHOD(StorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(RestorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(QueryPrinterInfo)(THIS_ PrinterPersistentQueryFlag Flag, PersistentInfo *pPrstInfo) PURE;
};

/********************************************************************

    Error codes returned by IPrnStream methods

********************************************************************/

typedef enum _PrnPrstError
{
    //
    //  When storing/ restoring opereations called and
    //  BindPrinterAndFile wasn't called or failed
    //
    PRN_PERSIST_ERROR_INVALID_OBJ       = 0x1,
    //
    //  Failed to write Printer data because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRNDATA     = 0x2,
    //
    //  Failed to restore Printer data because SetPrinterData failed
    //
    PRN_PERSIST_ERROR_RESTORE_PRNDATA   = 0x3,
    //
    //  Failed to restore Printer data because because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRNDATA      = 0x4,
    //
    //  Failed to store Printer Info 2 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI2         = 0x5,
    //
    //  Failed to store Printer Info 2 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI2           = 0x6,
    //
    //  Failed to restore Printer Info 2 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI2          = 0x7,
    //
    //  Failed to restore Printer Info 2 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI2       = 0x8,
    //
    //  Failed to store Printer Info 7 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI7         = 0x9,
    //
    //  Failed to store Printer Info 7 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI7           = 0xa,
    //
    //  Failed to restore Printer Info 7 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI7          = 0xb,
    //
    //  Failed to restore Printer Info 7 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI7       = 0xc,
    //
    //  Failed to store Printer Security Descriptor because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_SEC         = 0xd,
    //
    //  Failed to store Printer Security Descriptor because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_SEC           = 0xe,
    //
    //  Failed to restore Printer Security Descriptor because reading failure
    //
    PRN_PERSIST_ERROR_READ_SEC          = 0xf,
    //
    //  Failed to restore Printer Security Descriptor because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_SEC       = 0x10,
    //
    //  Failed to store Printer Color Profiles because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_COLOR_PRF   = 0x11,
    //
    //  Failed to store Printer Color Profiles because EnumcolorProfiles failure
    //
    PRN_PERSIST_ERROR_GET_COLOR_PRF     = 0x12,
    //
    //  Failed to restore Printer Color Profiles because reading failure
    //
    PRN_PERSIST_ERROR_READ_COLOR_PRF    = 0x13,
    //
    //  Failed to restore Printer Color Profiles because AddColorProfile failure
    //
    PRN_PERSIST_ERROR_RESTORE_COLOR_PRF = 0x14,
    //
    //  Failed to store User DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_USR_DEVMODE = 0x15,
    //
    //  Failed to store User DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_USR_DEVMODE   = 0x16,
    //
    //  Failed to restore User DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_USR_DEVMODE  = 0x17,
    //
    //  Failed to restore User DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_USR_DEVMODE   = 0x18,
    //
    //  Failed to store Printer DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRN_DEVMODE     = 0x19,
    //
    //  Failed to store Printer DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PRN_DEVMODE       = 0x1a,
    //
    //  Failed to restore Printer DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRN_DEVMODE      = 0x1b,
    //
    //  Failed to restore Printer DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PRN_DEVMODE   = 0x1c,
    //
    //  Failed because of unresolved printer name conflict
    //
    PRN_PERSIST_ERROR_PRN_NAME_CONFLICT     = 0x1d,
    //
    //  Failed because of printer name conflict
    //
    PRN_PERSIST_ERROR_UNBOUND               = 0x1e,
    //
    //  Restoring failure because failure at building backup info
    //
    PRN_PERSIST_ERROR_BACKUP                = 0x1f,
    //
    //  Restoring failure and Backup Failure too ; printer settings in undefined status
    //
    PRN_PERSIST_ERROR_FATAL                 = 0xffff
} PrnPrstError;

/********************************************************************

    IID_IPrintUIServices interface definition

********************************************************************/

#undef  INTERFACE
#define INTERFACE  IPrintUIServices

DECLARE_INTERFACE_(IPrintUIServices, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IID_IPrintUIServices methods ***
    STDMETHOD(GenerateShareName)(THIS_ LPCTSTR lpszServer, LPCTSTR lpszBaseName, LPTSTR lpszOut, int cchMaxChars) PURE;
};

#ifdef __cplusplus
}
#endif
#endif // ndef _PRTLIB_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\printui.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    printui.h

Abstract:

    Plug and Play interface printui.dll and ntprint.dll.

Author:

    Steve Kiraly (SteveKi) 30-Oct-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRINTUI_H
#define _PRINTUI_H

typedef enum {
    kAdvInf_ColorPrinter  = 1 << 0,   // The PnpInterface installed a color printer
} EAdvInfReturnFlags;

typedef enum {
    kPnPInterface_WebPointAndPrint      = 1 << 0,   // Web point and print install
    kPnPInterface_PromptForCD           = 1 << 1,   // Prompt for cd
    kPnPInterface_Quiet                 = 1 << 2,   // No error messages
    kPnPInterface_NoShare               = 1 << 3,   // Do not share printer
    kPnpInterface_UseExisting           = 1 << 4,   // Use driver if installed (Hydra)
    kPnpInterface_PromptIfUnknownDriver = 1 << 5,   // Prompt user if the printer driver is not known
    kPnPInterface_PromptIfFileNeeded    = 1 << 6,   // Prompt if files are needed
    kPnpInterface_HydraSpecific         = 1 << 7,   // Hydra specific flag
    kPnPInterface_Share                 = 1 << 8,   // Caller wants the printer shared
    kPnPInterface_WindowsUpdate         = 1 << 9,   // Windows Update case
    kPnPInterface_DontAutoGenerateName  = 1 << 10,  // Don't auto generate mangled printer name
    kPnPInterface_UseNonLocalizedStrings= 1 << 11,  // Use non localized Environment and Version
    kPnPInterface_SupressSetupUI        = 1 << 12,  // Supress setup warnings UI (super quiet mode)
    kPnPInterface_InstallColorProfiles  = 1 << 13   // Install ICM for color printer drivers
} EPnPInterfaceFlags;

typedef enum {
    kPrinterInstall,                        // Do printer quite install
    kInstallWizard,                         // Do install wizard
    kDestroyWizardData,                     // Do destroy wizard data
    kInfInstall,                            // Do inf installation
    kInfDriverInstall,                      // Do inf driver installation
    kDriverRemoval,                         // Do driver removal
    kAdvInfInstall                          // Do Inf Install with extras.
} EPnPFunctionCode;

typedef struct _TPrinterInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszDriverName;              // Pointer to printer driver name.
    LPCTSTR     pszPortName;                // Name of port to install
    LPTSTR      pszPrinterNameBuffer;       // Buffer where to return fully qualified printer name.
    UINT        cchPrinterName;             // Size of printer name buffer in characters
    LPCTSTR     pszPrintProcessor;          // Name of print processor
} TPrinterInstall;

typedef struct _TInstallWizard {
    UINT                    cbSize;         // Size of this structure for validation
    LPCTSTR                 pszServerName;  // Machine name NULL equals local machine
    PSP_INSTALLWIZARD_DATA  pData;          // Pointer to install wizard data
    PVOID                   pReferenceData; // Class installer instance data
} TInstallWizard;

typedef struct _TDestroyWizard {
    UINT                    cbSize;         // Size of this structure for validation purposes
    LPCTSTR                 pszServerName;  // Machine name NULL equals local machine
    PSP_INSTALLWIZARD_DATA  pData;          // Pointer to install wizard data
    PVOID                   pReferenceData; // Class installer instance data
} TDestroyWizard;

typedef struct _TInfInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszPortName;                // Port name where to install printer
    LPTSTR      pszPrinterNameBuffer;       // Base printer name, Note if a printer exists
                                            // with this name a unique name will be
                                            // generated ie. "printer (Copy 1)".  This parameter
                                            // may contain the null string in which case the printer
                                            // name will be auto generated using the model name
                                            // as the base name.  This parameter can be null,
                                            // and the new name will not be copied back
    UINT        cchPrinterName;             // Size of printer name buffer in characters
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    DWORD       dwFlags;                    // Install flags
} TInfInstall;

typedef struct _TAdvInfInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszPortName;                // Port name where to install printer
    LPTSTR      pszPrinterNameBuffer;       // Base printer name, Note if a printer exists
                                            // with this name a unique name will be
                                            // generated ie. "printer (Copy 1)".  This parameter
                                            // may contain the null string in which case the printer
                                            // name will be auto generated using the model name
                                            // as the base name.  This parameter can be null,
                                            // and the new name will not be copied back
    UINT        cchPrinterName;             // Size of printer name buffer in characters
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    DWORD       dwFlags;                    // Install flags
    DWORD       dwAttributes;               // Printer install attributes
    PSECURITY_DESCRIPTOR pSecurityDescriptor; // Security Descriptor to set.
    DWORD       dwOutFlags;                 // A set of flags to be returned back to our caller.
} TAdvInfInstall;


typedef struct _TInfDriverInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    LPCTSTR     pszArchitecture;            // Architecture string
    LPCTSTR     pszVersion;                 // Driver version string
    DWORD       dwFlags;                    // Install flags
} TInfDriverInstall;

typedef struct _TDriverRemoval {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszArchitecture;            // Architecture string
    LPCTSTR     pszVersion;                 // Driver version string
    DWORD       dwFlags;                    // Removal flags
} TDriverRemoval;

typedef union _TParameterBlock {
    TPrinterInstall     *pPrinterInstall;   // Pointer to printer install wizard
    TInstallWizard      *pInstallWizard;    // Pointer to install wizard data
    TDestroyWizard      *pDestroyWizard;    // Pointer to destroy wizard data
    TInfInstall         *pInfInstall;       // Pointer to inf install data
    TAdvInfInstall      *pAdvInfInstall;    // Pointer to advanced inf install data
    TInfDriverInstall   *pInfDriverInstall; // Pointer to inf driver install data
    TDriverRemoval      *pDriverRemoval;    // Pointer to driver removal data
} TParameterBlock;

DWORD
PnPInterface(
    IN EPnPFunctionCode    Function,        // Function code
    IN TParameterBlock    *pParameterBlock  // Pointer to parameter block
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\wiaview.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for wiaview.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wiaview_h__
#define __wiaview_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVideoPreview_FWD_DEFINED__
#define __IVideoPreview_FWD_DEFINED__
typedef interface IVideoPreview IVideoPreview;
#endif 	/* __IVideoPreview_FWD_DEFINED__ */


#ifndef __VideoPreview_FWD_DEFINED__
#define __VideoPreview_FWD_DEFINED__

#ifdef __cplusplus
typedef class VideoPreview VideoPreview;
#else
typedef struct VideoPreview VideoPreview;
#endif /* __cplusplus */

#endif 	/* __VideoPreview_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IVideoPreview_INTERFACE_DEFINED__
#define __IVideoPreview_INTERFACE_DEFINED__

/* interface IVideoPreview */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVideoPreview;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d82237ec-5be9-4760-b950-b7afa51b0ba9")
    IVideoPreview : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Device( 
            /* [in] */ IUnknown *pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoPreviewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoPreview * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoPreview * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoPreview * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoPreview * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoPreview * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoPreview * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoPreview * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Device )( 
            IVideoPreview * This,
            /* [in] */ IUnknown *pDevice);
        
        END_INTERFACE
    } IVideoPreviewVtbl;

    interface IVideoPreview
    {
        CONST_VTBL struct IVideoPreviewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoPreview_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoPreview_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoPreview_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoPreview_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVideoPreview_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVideoPreview_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVideoPreview_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVideoPreview_Device(This,pDevice)	\
    (This)->lpVtbl -> Device(This,pDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVideoPreview_Device_Proxy( 
    IVideoPreview * This,
    /* [in] */ IUnknown *pDevice);


void __RPC_STUB IVideoPreview_Device_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVideoPreview_INTERFACE_DEFINED__ */



#ifndef __WIAVIEWLib_LIBRARY_DEFINED__
#define __WIAVIEWLib_LIBRARY_DEFINED__

/* library WIAVIEWLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WIAVIEWLib;

EXTERN_C const CLSID CLSID_VideoPreview;

#ifdef __cplusplus

class DECLSPEC_UUID("457A23DF-6F2A-4684-91D0-317FB768D87C")
VideoPreview;
#endif
#endif /* __WIAVIEWLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\kdbg1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ntkd1394.h

Abstract:

    Header file for 1394 Debugging

Author:

    George Chrysanthakopoulos (georgioc) 31-October-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

// {66f250d6-7801-4a64-b139-eea80a450b24}
DEFINE_GUID(GUID_1394DBG, 0x66f250d6, 0x7801, 0x4a64, 0xb1, 0x39, 0xee, 0xa8, 0x0a, 0x45, 0x0b, 0x24);

#define DEBUG_1394_MAJOR_VERSION            0x1
#define DEBUG_1394_MINOR_VERSION            0x0

#define DEBUG_1394_CONFIG_TAG               0xBABABABA

#define INSTANCE_DEVICE_SYMLINK_NAME        L"\\DosDevices\\DBG1394_INSTANCE"
#define INSTANCE_DEVICE_NAME                L"\\Device\\Dbg1394_Instance"

#define DEBUG_BUS1394_MAX_PACKET_SIZE       4000

typedef struct _DEBUG_1394_SEND_PACKET {

    ULONG               TransferStatus;
    ULONG               PacketHeader[4];
    ULONG               Length;
    UCHAR               Packet[DEBUG_BUS1394_MAX_PACKET_SIZE];

} DEBUG_1394_SEND_PACKET, *PDEBUG_1394_SEND_PACKET;

typedef struct _DEBUG_1394_RECEIVE_PACKET {

    ULONG               TransferStatus;
    ULONG               Length;
    UCHAR               Packet[DEBUG_BUS1394_MAX_PACKET_SIZE];

} DEBUG_1394_RECEIVE_PACKET, *PDEBUG_1394_RECEIVE_PACKET;

// exists on target. client uses to match for id.
typedef struct _DEBUG_1394_CONFIG {

    ULONG               Tag;
    USHORT              MajorVersion;
    USHORT              MinorVersion;
    ULONG               Id;
    ULONG               BusPresent;    
    PHYSICAL_ADDRESS    SendPacket;
    PHYSICAL_ADDRESS    ReceivePacket;

} DEBUG_1394_CONFIG, *PDEBUG_1394_CONFIG;

//
// Various definitions
//
#define IOCTL_V1394DBG_API_REQUEST          CTL_CODE( FILE_DEVICE_UNKNOWN, \
                                                      0x200,               \
                                                      METHOD_BUFFERED,     \
                                                      FILE_ANY_ACCESS)


//
// Debug 1394 Request Packets
//
typedef struct _VDBG1394_API_CONFIGURATION {

    ULONG           OperationMode;
    ULONG           fulFlags;
    ULARGE_INTEGER  HostControllerInstanceId;
    ULONG           PhySpeed;

} VDBG1394_API_CONFIGURATION, *PVDBG1394_API_CONFIGURATION;

typedef struct _VDBG1394_API_IO_PARAMETERS {

    ULONG               fulFlags;
    PHYSICAL_ADDRESS    StartingMemoryOffset;

} VDBG1394_API_IO_PARAMETERS, *PVDBG1394_IO_PARAMETERS;

#ifndef _1394_H_

//
// 1394 Node Address format
//
typedef struct _NODE_ADDRESS {
    USHORT              NA_Node_Number:6;       // Bits 10-15
    USHORT              NA_Bus_Number:10;       // Bits 0-9
} NODE_ADDRESS, *PNODE_ADDRESS;

//
// 1394 Address Offset format (48 bit addressing)
//
typedef struct _ADDRESS_OFFSET {
    USHORT              Off_High;
    ULONG               Off_Low;
} ADDRESS_OFFSET, *PADDRESS_OFFSET;

//
// 1394 I/O Address format
//
typedef struct _IO_ADDRESS {
    NODE_ADDRESS        IA_Destination_ID;
    ADDRESS_OFFSET      IA_Destination_Offset;
} IO_ADDRESS, *PIO_ADDRESS;

#endif

typedef struct _V1394DBG_API_ASYNC_READ {

    IO_ADDRESS      DestinationAddress;
    ULONG           DataLength;
    UCHAR           Data[1];

} VDBG1394_API_ASYNC_READ, *PVDBG1394_API_ASYNC_READ;

typedef struct _V1394DBG_API_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that device drivers are asking the sbp2 port driver to carry out.
    //

    ULONG RequestNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //

    ULONG Flags;

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        VDBG1394_API_CONFIGURATION SetConfiguration;
        VDBG1394_API_CONFIGURATION GetConfiguration;
        VDBG1394_API_IO_PARAMETERS SetIoParameters;
        VDBG1394_API_IO_PARAMETERS GetIoParameters;

        VDBG1394_API_ASYNC_READ    AsyncRead;
    } u;

} V1394DBG_API_REQUEST, *PV1394DBG_API_REQUEST;

//
// Request Number
//
#define V1394DBG_API_SET_CONFIGURATION                      0x00000001
#define V1394DBG_API_GET_CONFIGURATION                      0x00000002
#define V1394DBG_API_SET_IO_PARAMETERS                      0x00000003
#define V1394DBG_API_GET_IO_PARAMETERS                      0x00000004
#define V1394DBG_API_SET_DEBUG_MODE                         0x00000005
#define V1394DBG_API_ASYNC_READ                             0x00000006

#define V1394DBG_API_CONFIGURATION_MODE_DEBUG               0x00000000
#define V1394DBG_API_CONFIGURATION_MODE_RAW_MEMORY_ACCESS   0x00000001

#define V1394DBG_API_FLAG_WRITE_IO                          0x00000001
#define V1394DBG_API_FLAG_READ_IO                           0x00000002

// 3 different debug modes flags
#define V1394DBG_API_MODE_KD_CLIENT                         0x00000001
#define V1394DBG_API_MODE_USER_CLIENT                       0x00000002
#define V1394DBG_API_MODE_USER_SERVER                       0x00000003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\mtype.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mtype.h

Abstract:

    Marshalling code needs this information about each field in _INFO_ structures. 
    Data.h define arrays of FieldInfo structures for each _INFO_ structure
    
Author:

    AdinaTru 18 Jan 2000

Revision History:


--*/

#ifndef _MTYPE
#define _MTYPE

typedef enum _EFIELDTYPE 
{
    DATA_TYPE = 0,
    PTR_TYPE  = 1,

} EFIELDTYPE;


typedef enum Call_Route
{
    NATIVE_CALL  = 0,   // either KM call or Spooler in-proc call
    RPC_CALL     = 1,   // RPC call
   
} CALL_ROUTE;

//
// Holds information about a field in public spooler structures _INFO_
//
typedef struct _FieldInfo 
{
    DWORD32 Offset;           // Field's offset inside structure
    ULONG_PTR Size;           // Field's size in bytes
    ULONG_PTR Alignment;      // Field's alignment; Not always the same as the size!!!
    EFIELDTYPE  Type;         // Field's type;  PTR_TYPE if pointer, DATA_TYPE otherwise

} FieldInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\offsets.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    offsets.h

Abstract:

    Global structure declarations used by marshalling and string packing code.

Author:

Environment:

    User Mode - Spoolss

Revision History:

Notes: 

--*/

#ifndef _OFFSETS_H
#define _OFFSETS_H

#include "mType.h"

extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD PrinterInfo6Offsets[];
extern DWORD PrinterInfo6Strings[];
extern DWORD PrinterInfo7Offsets[];
extern DWORD PrinterInfo7Strings[];
extern DWORD PrinterInfo8Offsets[];
extern DWORD PrinterInfo8Strings[];
extern DWORD PrinterInfo9Offsets[];
extern DWORD PrinterInfo9Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD DriverInfo4Offsets[];
extern DWORD DriverInfo4Strings[];
extern DWORD DriverInfo5Offsets[];
extern DWORD DriverInfo5Strings[];
extern DWORD DriverInfo6Offsets[];
extern DWORD DriverInfoVersionStrings[];


extern DWORD DriverInfo6Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJob2Offsets[];
extern DWORD AddJobStrings[];
extern DWORD AddJob2Strings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD ProvidorInfo2Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
extern DWORD PrinterEnumValuesOffsets[];


extern FieldInfo PrinterInfoStressFields[];
extern FieldInfo PrinterInfo4Fields[];
extern FieldInfo PrinterInfo1Fields[];
extern FieldInfo PrinterInfo2Fields[];
extern FieldInfo PrinterInfo3Fields[];
extern FieldInfo PrinterInfo5Fields[];
extern FieldInfo PrinterInfo6Fields[];
extern FieldInfo PrinterInfo7Fields[];
extern FieldInfo PrinterInfo8Fields[];
extern FieldInfo PrinterInfo9Fields[];
extern FieldInfo JobInfo1Fields[];
extern FieldInfo JobInfo2Fields[];
extern FieldInfo JobInfo3Fields[];
extern FieldInfo DriverInfo1Fields[];
extern FieldInfo DriverInfo2Fields[];
extern FieldInfo DriverInfo3Fields[];
extern FieldInfo DriverInfo4Fields[];
extern FieldInfo DriverInfo5Fields[];
extern FieldInfo DriverInfo6Fields[];
extern FieldInfo DriverInfoVersionFields[];

extern FieldInfo AddJobFields[];
extern FieldInfo AddJob2Fields[];
extern FieldInfo FormInfo1Fields[];
extern FieldInfo PortInfo1Fields[];
extern FieldInfo PortInfo2Fields[];
extern FieldInfo PortInfo3Fields[];
extern FieldInfo PrintProcessorInfo1Fields[];
extern FieldInfo MonitorInfo1Fields[];
extern FieldInfo MonitorInfo2Fields[];
extern FieldInfo DocInfo1Fields[];
extern FieldInfo DatatypeInfo1Fields[];
extern FieldInfo PrinterEnumValuesFields[];


extern FieldInfo PrinterInfoStressFields32[];
extern FieldInfo PrinterInfo4Fields32[];
extern FieldInfo PrinterInfo1Fields32[];
extern FieldInfo PrinterInfo2Fields32[];
extern FieldInfo PrinterInfo3Fields32[];
extern FieldInfo PrinterInfo5Fields32[];
extern FieldInfo PrinterInfo6Fields32[];
extern FieldInfo PrinterInfo7Fields32[];
extern FieldInfo PrinterInfo8Fields32[];
extern FieldInfo PrinterInfo9Fields32[];
extern FieldInfo JobInfo1Fields32[];
extern FieldInfo JobInfo2Fields32[];
extern FieldInfo JobInfo3Fields32[];
extern FieldInfo DriverInfo1Fields32[];
extern FieldInfo DriverInfo2Fields32[];
extern FieldInfo DriverInfo3Fields32[];
extern FieldInfo DriverInfo4Fields32[];
extern FieldInfo DriverInfo5Fields32[];
extern FieldInfo DriverInfo6Fields32[];
extern FieldInfo AddJobFields32[];
extern FieldInfo FormInfo1Fields32[];
extern FieldInfo PortInfo1Fields32[];
extern FieldInfo PortInfo2Fields32[];
extern FieldInfo PortInfo3Fields32[];
extern FieldInfo PrintProcessorInfo1Fields32[];
extern FieldInfo MonitorInfo1Fields32[];
extern FieldInfo MonitorInfo2Fields32[];
extern FieldInfo DocInfo1Fields32[];
extern FieldInfo DatatypeInfo1Fields32[];
extern FieldInfo PrinterEnumValuesFields32[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

Notes: 

    FOR ADDING OR UPDATING Offset structures.

All the offsets should appear in ascending order in the struct. This is critical
for converting 32 bit structures into the corresponding 64 bit structures. Custom 
marshalling will break if this is not adhered to.

See spllib\marshall.cxx for additional information

--*/

#ifndef _DATA_H
#define _DATA_H

#include <offsets.h>
#include <winsprlp.h>

#ifdef PRINTER_OFFSETS
DWORD PrinterInfoStressOffsets[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pDevMode),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             offsetof(PRINTER_INFO_2A, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Offsets[]={0xFFFFFFFF};

DWORD PrinterInfo7Offsets[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Offsets[]={offsetof(PRINTER_INFO_8A, pDevMode),
                             0xFFFFFFFF};

DWORD PrinterInfo9Offsets[]={offsetof(PRINTER_INFO_9A, pDevMode),
                             0xFFFFFFFF};
#endif

#ifdef PRINTER_STRINGS
DWORD PrinterInfoStressStrings[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Strings[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Strings[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3Strings[]={0xFFFFFFFF};

DWORD PrinterInfo4Strings[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Strings[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Strings[]={0xFFFFFFFF};

DWORD PrinterInfo7Strings[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Strings[]={0xFFFFFFFF};

DWORD PrinterInfo9Strings[]={0xFFFFFFFF};

#endif


#ifdef JOB_OFFSETS
DWORD JobInfo1Offsets[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Offsets[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pDevMode),
                         offsetof(JOB_INFO_2, pStatus),
                         offsetof(JOB_INFO_2, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3Offsets[]={0xFFFFFFFF};
#endif

#ifdef JOB_STRINGS
DWORD JobInfo1Strings[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Strings[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3Strings[]={0xFFFFFFFF};
#endif


#ifdef DRIVER_OFFSETS
DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pDependentFiles),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Offsets[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pDependentFiles),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            offsetof(DRIVER_INFO_4A, pszzPreviousNames),
                            0xFFFFFFFF};

DWORD DriverInfo5Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Offsets[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pDependentFiles),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszzPreviousNames),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};


#endif

#ifdef DRIVER_STRINGS
DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Strings[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo5Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Strings[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};

DWORD DriverInfoVersionStrings[]={offsetof(DRIVER_INFO_VERSION, pName),
                                  offsetof(DRIVER_INFO_VERSION, pEnvironment),
                                  offsetof(DRIVER_INFO_VERSION, pMonitorName),
                                  offsetof(DRIVER_INFO_VERSION, pDefaultDataType),
                                  offsetof(DRIVER_INFO_VERSION, pszMfgName),
                                  offsetof(DRIVER_INFO_VERSION, pszOEMUrl),
                                  offsetof(DRIVER_INFO_VERSION, pszHardwareID),
                                  offsetof(DRIVER_INFO_VERSION, pszProvider),
                                  0xFFFFFFFF};



#endif


#ifdef ADDJOB_OFFSETS
DWORD AddJobOffsets[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Offsets[]={offsetof(ADDJOB_INFO_2W, pData),
                       0xFFFFFFFF};
#endif

#ifdef ADDJOB_STRINGS
DWORD AddJobStrings[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Strings[]={offsetof(ADDJOB_INFO_2W, pData),
                        0xFFFFFFFF};

#endif


#ifdef FORM_OFFSETS
DWORD FormInfo1Offsets[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif

#ifdef FORM_STRINGS
DWORD FormInfo1Strings[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif


#ifdef PORT_OFFSETS
DWORD PortInfo1Offsets[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Offsets[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
DWORD PortInfo3Offsets[]={offsetof(PORT_INFO_3A, pszStatus),
                          0xFFFFFFFF};
#endif

#ifdef PORT_STRINGS
DWORD PortInfo1Strings[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Strings[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
#endif


#ifdef PRINTPROCESSOR_OFFSETS
DWORD PrintProcessorInfo1Offsets[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif

#ifdef PRINTPROCESSOR_STRINGS
DWORD PrintProcessorInfo1Strings[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif


#ifdef MONITOR_OFFSETS
DWORD MonitorInfo1Offsets[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};
DWORD MonitorInfo2Offsets[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif

#ifdef MONITOR_STRINGS
DWORD MonitorInfo1Strings[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};

DWORD MonitorInfo2Strings[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif


#ifdef DOCINFO_OFFSETS
DWORD DocInfo1Offsets[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif

#ifdef DOCINFO_STRINGS
DWORD DocInfo1Strings[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif


#ifdef DATATYPE_OFFSETS
DWORD DatatypeInfo1Offsets[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif

#ifdef DATATYPE_STRINGS

DWORD DatatypeInfo1Strings[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif


#ifdef PRINTER_ENUM_VALUES_OFFSETS

DWORD PrinterEnumValuesOffsets[] = {offsetof(PRINTER_ENUM_VALUESA, pValueName),
                                    offsetof(PRINTER_ENUM_VALUESA, pData),
                                    0xFFFFFFFF};
#endif

#ifdef PROVIDOR_STRINGS
DWORD ProvidorInfo1Strings[]={offsetof(PROVIDOR_INFO_1A, pName),
                              offsetof(PROVIDOR_INFO_1A, pEnvironment),
                              offsetof(PROVIDOR_INFO_1A, pDLLName),
                              0xFFFFFFFF};

DWORD ProvidorInfo2Strings[]={0xFFFFFFFF};
#endif



#ifdef PRINTER_OFFSETS
FieldInfo PrinterInfoStressFields[]={
                             {offsetof(PRINTER_INFO_STRESSA, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },                                 
                             {offsetof(PRINTER_INFO_STRESSA, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, stUpTime), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, MaxcRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalPagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwGetVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, fFreeBuild), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cMaxSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorOutOfPaper), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorNotReady), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwNumberOfProcessors), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwProcessorType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwHighPartTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cChangeID), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwLastError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cEnumerateNetworkPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cAddNetPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorArchitecture), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorLevel), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRefIC), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved2), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved3), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
                             

FieldInfo PrinterInfo1Fields[]={
                                {offsetof(PRINTER_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_1A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo3Fields[]={
                                {offsetof(PRINTER_INFO_3, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo4Fields[]={
                                {offsetof(PRINTER_INFO_4A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo5Fields[]={
                                {offsetof(PRINTER_INFO_5A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo6Fields[]={
                                {offsetof(PRINTER_INFO_6, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7A, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7A, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo8Fields[]={
                                {offsetof(PRINTER_INFO_8A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo9Fields[]={
                                {offsetof(PRINTER_INFO_9A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif


#ifdef JOB_OFFSETS

FieldInfo JobInfo1Fields[]= {
                             {offsetof(JOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };


FieldInfo JobInfo2Fields[]= {
                             {offsetof(JOB_INFO_2A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pNotifyName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Size), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Time), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };

FieldInfo JobInfo3Fields[]= {
                            {offsetof(JOB_INFO_3, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, NextJobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {0xFFFFFFFF, 0, 0, DATA_TYPE}
                            };
#endif


#ifdef DRIVER_OFFSETS

FieldInfo DriverInfo1Fields[]= {
                                {offsetof(DRIVER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo2Fields[]= {
                                {offsetof(DRIVER_INFO_2A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo3Fields[]= {
                                {offsetof(DRIVER_INFO_3A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_3A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_3A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo4Fields[]= {
                                {offsetof(DRIVER_INFO_4A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_4A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_4A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo5Fields[]= {
                                {offsetof(DRIVER_INFO_5A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_5A, dwDriverAttributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwConfigVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwDriverVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfo6Fields[]= {
                                {offsetof(DRIVER_INFO_6A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_6A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfoVersionFields[]= {
                                {offsetof(DRIVER_INFO_VERSION, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pFileInfo), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, dwFileCount), sizeof(DWORD),sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif

#ifdef ADDJOB_OFFSETS
FieldInfo AddJobFields[]= {
                           {offsetof(ADDJOB_INFO_1A, Path), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };
FieldInfo AddJob2Fields[]= {
                           {offsetof(ADDJOB_INFO_2W, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_2W, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };

#endif


#ifdef FORM_OFFSETS
FieldInfo FormInfo1Fields[]= {
                              {offsetof(FORM_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(FORM_INFO_1A, Size), sizeof(SIZEL), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, ImageableArea), sizeof(RECTL), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif

#ifdef PORT_OFFSETS
FieldInfo PortInfo1Fields[]= {
                              {offsetof(PORT_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };

FieldInfo PortInfo2Fields[]= {
                              {offsetof(PORT_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pMonitorName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, fPortType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_2A, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
                              
FieldInfo PortInfo3Fields[]= {
                              {offsetof(PORT_INFO_3A, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_3A, pszStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_3A, dwSeverity), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif


#ifdef PRINTPROCESSOR_OFFSETS
FieldInfo PrintProcessorInfo1Fields[]= {
                                        {offsetof(PRINTPROCESSOR_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                        {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                        };
                              
#endif


#ifdef MONITOR_OFFSETS
FieldInfo MonitorInfo1Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
FieldInfo MonitorInfo2Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pEnvironment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pDLLName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif


#ifdef DOCINFO_OFFSETS
FieldInfo DocInfo1Fields[]= {
                             {offsetof(DOC_INFO_1A, pDocName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pOutputFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
#endif


#ifdef DATATYPE_OFFSETS
FieldInfo DatatypeInfo1Fields[]={
                                 {offsetof(DATATYPES_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif

#ifdef PRINTER_ENUM_VALUES_OFFSETS
FieldInfo PrinterEnumValuesFields[]= {
                                      {offsetof(PRINTER_ENUM_VALUESA, pValueName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbValueName), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, dwType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbData), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                      };

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\cmdhelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cmdhelp.h

Abstract:

    Command line helper library

Environment:

    User mode only

Revision History:
    
    04/04/2001 - created

--*/

#ifndef __CMDHELP_H__
#define __CMDHELP_H__

#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include <windows.h>  // sdk

/*++

Routine Description:

    Validates a string contains only valid octal characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringOctal(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string contains only valid decimal characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringDecimal(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string contains only valid hex characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringHex(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string is formatted properly for use in
    SptUtilScanQuotedHexString().  The required format is as follows:
    
        x <= { 0..9, A..F, a..f }
        "(xx )*(xx)"
        
    i.e. the following strings are valid:
        "00 01 02 03"
        "00"
        "ff Fa Bc Ed 08 8f"
        
    i.e. the following strings are invalid:
        ""              // zero-length string
        " 00 01 02 03"  // space at beginning
        "00 01 02 03 "  // space at end

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringHexQuoted(
    IN PCHAR String
    );

/*++

Routine Description:

    Scans in a quoted hex string of the form "xx xx xx" into
    a pre-allocated buffer.
    Also can be used to determine the required buffer size.
    
Arguments:

Return Value:

    TRUE && *DataSize != 0 if everything was successful.
    (*DataSize contains the size of the data scanned)
    
    FALSE && *DataSize == 0 if failed to validate string
    
    FALSE && *DataSize != 0 if buffer too small

--*/
BOOLEAN
CmdHelpScanQuotedHexString(
    IN  PUCHAR QuotedHexString,
    OUT PUCHAR Data,
    OUT PDWORD DataSize
    );

/*++

Routine Description:

    Prints out the buffer specified in HEX format.
    Simplistic, but very useful, esp. for debugging.
    
Arguments:

    Buffer - the data to print
    Size - how many bytes are to be printed

Return Value:

--*/
VOID
CmdHelpPrintBuffer(
    IN PUCHAR Buffer,
    IN SIZE_T Size
    );


#pragma warning(pop)
#endif // __CMDHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\printscan\inc\winsrv\winspl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* Compiler settings for winspl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __winspl_h__
#define __winspl_h__

/* Forward Declarations */ 

/* header files for imported files */
#include "import.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __winspool_INTERFACE_DEFINED__
#define __winspool_INTERFACE_DEFINED__

/* interface winspool */
/* [implicit_handle][unique][endpoint][ms_union][version][uuid] */ 

typedef WORD TABLE;

typedef struct _NOTIFY_ATTRIB_TABLE
    {
    WORD Attrib;
    TABLE Table;
    }	NOTIFY_ATTRIB_TABLE;

typedef struct _NOTIFY_ATTRIB_TABLE __RPC_FAR *PNOTIFY_ATTRIB_TABLE;

typedef /* [context_handle] */ void __RPC_FAR *PRINTER_HANDLE;

typedef /* [context_handle] */ void __RPC_FAR *GDI_HANDLE;

typedef /* [handle] */ wchar_t __RPC_FAR *STRING_HANDLE;

typedef /* [string] */ wchar_t __RPC_FAR *SPL_STRING;

typedef struct _PORT_VAR_CONTAINER
    {
    DWORD cbMonitorData;
    /* [unique][size_is] */ LPBYTE pMonitorData;
    }	PORT_VAR_CONTAINER;

typedef struct _PORT_VAR_CONTAINER __RPC_FAR *PPORT_VAR_CONTAINER;

typedef struct _PORT_VAR_CONTAINER __RPC_FAR *LPPORT_VAR_CONTAINER;

typedef struct _PORT_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPORT_INFO_1W pPortInfo1;
        /* [case()] */ LPPORT_INFO_2W pPortInfo2;
        /* [case()] */ LPPORT_INFO_3W pPortInfo3;
        /* [case()] */ LPPORT_INFO_FFW pPortInfoFF;
        }	PortInfo;
    }	PORT_CONTAINER;

typedef struct _PORT_CONTAINER __RPC_FAR *PPORT_CONTAINER;

typedef struct _PORT_CONTAINER __RPC_FAR *LPPORT_CONTAINER;

typedef struct _DEVMODE_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPBYTE pDevMode;
    }	DEVMODE_CONTAINER;

typedef struct _DEVMODE_CONTAINER __RPC_FAR *PDEVMODE_CONTAINER;

typedef struct _DEVMODE_CONTAINER __RPC_FAR *LPDEVMODE_CONTAINER;

typedef struct _SECURITY_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPBYTE pSecurity;
    }	SECURITY_CONTAINER;

typedef struct _SECURITY_CONTAINER __RPC_FAR *PSECURITY_CONTAINER;

typedef struct _SECURITY_CONTAINER __RPC_FAR *LPSECURITY_CONTAINER;

typedef struct _PRINTER_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPRINTER_INFO_STRESSW pPrinterInfoStress;
        /* [case()] */ LPPRINTER_INFO_1W pPrinterInfo1;
        /* [case()] */ LPPRINTER_INFO_2W pPrinterInfo2;
        /* [case()] */ LPPRINTER_INFO_3 pPrinterInfo3;
        /* [case()] */ LPPRINTER_INFO_4W pPrinterInfo0;
        /* [case()] */ LPPRINTER_INFO_5W pPrinterInfo5;
        /* [case()] */ LPPRINTER_INFO_6 pPrinterInfo6;
        /* [case()] */ LPPRINTER_INFO_7W pPrinterInfo7;
        /* [case()] */ LPPRINTER_INFO_8W pPrinterInfo8;
        /* [case()] */ LPPRINTER_INFO_9W pPrinterInfo9;
        }	PrinterInfo;
    }	PRINTER_CONTAINER;

typedef struct _PRINTER_CONTAINER __RPC_FAR *PPRINTER_CONTAINER;

typedef struct _PRINTER_CONTAINER __RPC_FAR *LPPRINTER_CONTAINER;

typedef struct _JOB_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ JOB_INFO_1W __RPC_FAR *Level1;
        /* [case()] */ JOB_INFO_2W __RPC_FAR *Level2;
        /* [case()] */ JOB_INFO_3 __RPC_FAR *Level3;
        }	JobInfo;
    }	JOB_CONTAINER;

typedef struct _JOB_CONTAINER __RPC_FAR *PJOB_CONTAINER;

typedef struct _JOB_CONTAINER __RPC_FAR *LPJOB_CONTAINER;

typedef struct _RPC_DRIVER_INFO_3W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    }	RPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_3W __RPC_FAR *PRPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_3W __RPC_FAR *LPRPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_4W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    DWORD cchPreviousNames;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pszzPreviousNames;
    }	RPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_4W __RPC_FAR *PRPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_4W __RPC_FAR *LPRPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_6W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    DWORD cchPreviousNames;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pszzPreviousNames;
    FILETIME ftDriverDate;
    DWORDLONG dwlDriverVersion;
    SPL_STRING pMfgName;
    SPL_STRING pOEMUrl;
    SPL_STRING pHardwareID;
    SPL_STRING pProvider;
    }	RPC_DRIVER_INFO_6W;

typedef struct _RPC_DRIVER_INFO_6W __RPC_FAR *PRPC_DRIVER_INFO_6W;

typedef struct _RPC_DRIVER_INFO_6W __RPC_FAR *LPRPC_DRIVER_INFO_6W;

typedef struct _DRIVER_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDRIVER_INFO_1W Level1;
        /* [case()] */ LPDRIVER_INFO_2W Level2;
        /* [case()] */ LPRPC_DRIVER_INFO_3W Level3;
        /* [case()] */ LPRPC_DRIVER_INFO_4W Level4;
        /* [case()] */ LPRPC_DRIVER_INFO_6W Level6;
        }	DriverInfo;
    }	DRIVER_CONTAINER;

typedef struct _DRIVER_CONTAINER __RPC_FAR *PDRIVER_CONTAINER;

typedef struct _DRIVER_CONTAINER __RPC_FAR *LPDRIVER_CONTAINER;

typedef struct _DOC_INFO_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDOC_INFO_1W pDocInfo1;
        }	DocInfo;
    }	DOC_INFO_CONTAINER;

typedef struct _DOC_INFO_CONTAINER __RPC_FAR *PDOC_INFO_CONTAINER;

typedef struct _DOC_INFO_CONTAINER __RPC_FAR *LPDOC_INFO_CONTAINER;

typedef struct _FORM_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPFORM_INFO_1W pFormInfo1;
        }	FormInfo;
    }	FORM_CONTAINER;

typedef struct _FORM_CONTAINER __RPC_FAR *PFORM_CONTAINER;

typedef struct _FORM_CONTAINER __RPC_FAR *LPFORM_CONTAINER;

typedef struct _MONITOR_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPMONITOR_INFO_1W pMonitorInfo1;
        /* [case()] */ LPMONITOR_INFO_2W pMonitorInfo2;
        }	MonitorInfo;
    }	MONITOR_CONTAINER;

typedef struct _MONITOR_CONTAINER __RPC_FAR *PMONITOR_CONTAINER;

typedef struct _MONITOR_CONTAINER __RPC_FAR *LPMONITOR_CONTAINER;

typedef struct _RPC_PROVIDOR_INFO_2W
    {
    DWORD cchOrder;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pOrder;
    }	RPC_PROVIDOR_INFO_2W;

typedef struct _RPC_PROVIDOR_INFO_2W __RPC_FAR *PRPC_PROVIDOR_INFO_2W;

typedef struct _RPC_PROVIDOR_INFO_2W __RPC_FAR *LPRPC_PROVIDOR_INFO_2W;

typedef struct _PROVIDOR_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPROVIDOR_INFO_1W pProvidorInfo1;
        /* [case()] */ LPRPC_PROVIDOR_INFO_2W pRpcProvidorInfo2;
        }	ProvidorInfo;
    }	PROVIDOR_CONTAINER;

typedef struct _PROVIDOR_CONTAINER __RPC_FAR *PPROVIDOR_CONTAINER;

typedef struct _PROVIDOR_CONTAINER __RPC_FAR *LPPROVIDOR_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPSPLCLIENT_INFO_1 pClientInfo1;
        /* [case()] */ LPSPLCLIENT_INFO_2 pClientInfo2;
        }	ClientInfo;
    }	SPLCLIENT_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER __RPC_FAR *PSPLCLIENT_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER __RPC_FAR *LPSPLCLIENT_CONTAINER;

typedef struct _STRING_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPWSTR pszString;
    }	STRING_CONTAINER;

typedef struct _STRING_CONTAINER __RPC_FAR *PSTRING_CONTAINER;

typedef struct _SYSTEMTIME_CONTAINER
    {
    DWORD cbBuf;
    PSYSTEMTIME pSystemTime;
    }	SYSTEMTIME_CONTAINER;

typedef struct _SYSTEMTIME_CONTAINER __RPC_FAR *PSYSTEMTIME_CONTAINER;

typedef struct _RPC_V2_NOTIFY_OPTIONS_TYPE
    {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    /* [unique][size_is] */ PWORD pFields;
    }	RPC_V2_NOTIFY_OPTIONS_TYPE;

typedef struct _RPC_V2_NOTIFY_OPTIONS_TYPE __RPC_FAR *PRPC_V2_NOTIFY_OPTIONS_TYPE;

typedef struct _RPC_V2_NOTIFY_OPTIONS
    {
    DWORD Version;
    DWORD Reserved;
    DWORD Count;
    /* [unique][size_is] */ PRPC_V2_NOTIFY_OPTIONS_TYPE pTypes;
    }	RPC_V2_NOTIFY_OPTIONS;

typedef struct _RPC_V2_NOTIFY_OPTIONS __RPC_FAR *PRPC_V2_NOTIFY_OPTIONS;

typedef /* [switch_type] */ union _RPC_V2_NOTIFY_INFO_DATA_DATA
    {
    /* [case()] */ STRING_CONTAINER String;
    /* [case()] */ DWORD dwData[ 2 ];
    /* [case()] */ SYSTEMTIME_CONTAINER SystemTime;
    /* [case()] */ DEVMODE_CONTAINER DevMode;
    /* [case()] */ SECURITY_CONTAINER SecurityDescriptor;
    }	RPC_V2_NOTIFY_INFO_DATA_DATA;

typedef /* [switch_type] */ union _RPC_V2_NOTIFY_INFO_DATA_DATA __RPC_FAR *PRPC_V2_NOTIFY_INFO_DATA_DATA;

typedef struct _RPC_V2_NOTIFY_INFO_DATA
    {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    /* [switch_is] */ RPC_V2_NOTIFY_INFO_DATA_DATA Data;
    }	RPC_V2_NOTIFY_INFO_DATA;

typedef struct _RPC_V2_NOTIFY_INFO_DATA __RPC_FAR *PRPC_V2_NOTIFY_INFO_DATA;

typedef struct _RPC_V2_NOTIFY_INFO
    {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    /* [unique][size_is] */ RPC_V2_NOTIFY_INFO_DATA aData[ 1 ];
    }	RPC_V2_NOTIFY_INFO;

typedef struct _RPC_V2_NOTIFY_INFO __RPC_FAR *PRPC_V2_NOTIFY_INFO;

typedef /* [switch_type] */ union _RPC_V2_UREPLY_PRINTER
    {
    /* [case()] */ PRPC_V2_NOTIFY_INFO pInfo;
    }	RPC_V2_UREPLY_PRINTER;

typedef /* [switch_type] */ union _RPC_V2_UREPLY_PRINTER __RPC_FAR *PRPC_V2_UREPLY_PRINTER;

DWORD RpcEnumPrinters( 
    /* [in] */ DWORD Flags,
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrinterEnum,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcOpenPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired);

DWORD RpcSetJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId,
    /* [unique][in] */ LPJOB_CONTAINER pJobContainer,
    /* [in] */ DWORD Command);

DWORD RpcGetJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcEnumJobs( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD FirstJob,
    /* [in] */ DWORD NoJobs,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcAddPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle);

DWORD RpcDeletePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcSetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [in] */ DWORD Command);

DWORD RpcGetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrinter,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcAddPrinterDriver( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PDRIVER_CONTAINER pDriverContainer);

DWORD RpcEnumPrinterDrivers( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDrivers,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcGetPrinterDriver( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriver,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcGetPrinterDriverDirectory( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriverDirectory,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcDeletePrinterDriver( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pDriverName);

DWORD RpcAddPrintProcessor( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPathName,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProcessorName);

DWORD RpcEnumPrintProcessors( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrintProcessorInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcGetPrintProcessorDirectory( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrintProcessorDirectory,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcStartDocPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PDOC_INFO_CONTAINER pDocInfoContainer,
    /* [out] */ LPDWORD pJobId);

DWORD RpcStartPagePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcWritePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][in] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcWritten);

DWORD RpcEndPagePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcAbortPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcReadPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][out] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcNoBytesRead);

DWORD RpcEndDocPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcAddJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pAddJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcScheduleJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId);

DWORD RpcGetPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD nSize,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcSetPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD Type,
    /* [size_is][in] */ LPBYTE pData,
    /* [in] */ DWORD cbData);

DWORD RpcWaitForPrinterChange( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Flags,
    /* [out] */ LPDWORD pFlags);

DWORD RpcClosePrinter( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phPrinter);

DWORD RpcAddForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PFORM_CONTAINER pFormInfoContainer);

DWORD RpcDeleteForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName);

DWORD RpcGetForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pForm,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcSetForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName,
    /* [in] */ PFORM_CONTAINER pFormInfoContainer);

DWORD RpcEnumForms( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pForm,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcEnumPorts( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPort,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcEnumMonitors( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pMonitor,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcAddPort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcConfigurePort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pPortName);

DWORD RpcDeletePort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pPortName);

DWORD RpcCreatePrinterIC( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [out] */ GDI_HANDLE __RPC_FAR *pHandle,
    /* [in] */ LPDEVMODE_CONTAINER pDevModeContainer);

DWORD RpcPlayGdiScriptOnPrinterIC( 
    /* [in] */ GDI_HANDLE hPrinterIC,
    /* [size_is][in] */ LPBYTE pIn,
    /* [in] */ DWORD cIn,
    /* [size_is][out] */ LPBYTE pOut,
    /* [in] */ DWORD cOut,
    /* [in] */ DWORD ul);

DWORD RpcDeletePrinterIC( 
    /* [out][in] */ GDI_HANDLE __RPC_FAR *phPrinterIC);

DWORD RpcAddPrinterConnection( 
    /* [string][in] */ STRING_HANDLE pName);

DWORD RpcDeletePrinterConnection( 
    /* [string][in] */ STRING_HANDLE pName);

DWORD RpcPrinterMessageBox( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Error,
    /* [in] */ DWORD hWnd,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pText,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pCaption,
    /* [in] */ DWORD dwType);

DWORD RpcAddMonitor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ PMONITOR_CONTAINER pMonitorContainer);

DWORD RpcDeleteMonitor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcDeletePrintProcessor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProcessorName);

DWORD RpcAddPrintProvidor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ PPROVIDOR_CONTAINER pProvidorContainer);

DWORD RpcDeletePrintProvidor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProvidorName);

DWORD RpcEnumPrintProcessorDatatypes( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pPrintProcessorName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDatatypes,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcResetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode);

DWORD RpcGetPrinterDriver2( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriver,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [in] */ DWORD dwClientMajorVersion,
    /* [in] */ DWORD dwClientMinorVersion,
    /* [out] */ LPDWORD pdwServerMaxVersion,
    /* [out] */ LPDWORD pdwServerMinVersion);

DWORD RpcClientFindFirstPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [in] */ DWORD dwPID,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ LPDWORD pdwEvent);

DWORD RpcFindNextPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [out] */ LPDWORD pdwChange,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ PRPC_V2_NOTIFY_INFO __RPC_FAR *ppInfo);

DWORD RpcFindClosePrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcRouterFindFirstPrinterChangeNotificationOld( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal);

DWORD RpcReplyOpenPrinter( 
    /* [string][in] */ STRING_HANDLE pMachine,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *phPrinterNotify,
    /* [in] */ DWORD dwPrinterRemote,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][in] */ LPBYTE pBuffer);

DWORD RpcRouterReplyPrinter( 
    /* [in] */ PRINTER_HANDLE hNotify,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][in] */ LPBYTE pBuffer);

DWORD RpcReplyClosePrinter( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phNotify);

DWORD RpcAddPortEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ LPPORT_CONTAINER pPortContainer,
    /* [in] */ LPPORT_VAR_CONTAINER pPortVarContainer,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcRemoteFindFirstPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][out][in] */ LPBYTE pBuffer);

DWORD RpcSpoolerInit( 
    /* [in] */ STRING_HANDLE pName);

DWORD RpcResetPrinterEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD dwFlags);

DWORD RpcRemoteFindFirstPrinterChangeNotificationEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions);

DWORD RpcRouterReplyPrinterEx( 
    /* [in] */ PRINTER_HANDLE hNotify,
    /* [in] */ DWORD dwColor,
    /* [in] */ DWORD fdwFlags,
    /* [out] */ PDWORD pdwResult,
    /* [in] */ DWORD dwReplyType,
    /* [switch_is][in] */ RPC_V2_UREPLY_PRINTER Reply);

DWORD RpcRouterRefreshPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwColor,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ PRPC_V2_NOTIFY_INFO __RPC_FAR *ppInfo);

DWORD RpcSetAllocFailCount( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwFailCount,
    /* [out] */ LPDWORD lpdwAllocCount,
    /* [out] */ LPDWORD lpdwFreeCount,
    /* [out] */ LPDWORD lpdwFailCountHit);

DWORD RpcOpenPrinterEx( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired,
    /* [in] */ PSPLCLIENT_CONTAINER pClientInfo);

DWORD RpcAddPrinterEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [in] */ PSPLCLIENT_CONTAINER pClientInfo,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle);

DWORD RpcSetPort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pPortName,
    /* [in] */ LPPORT_CONTAINER pPortContainer);

DWORD RpcEnumPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwIndex,
    /* [size_is][out] */ wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD cbValueName,
    /* [out] */ LPDWORD pcbValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD cbData,
    /* [out] */ LPDWORD pcbData);

DWORD RpcDeletePrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName);

DWORD RpcClusterSplOpen( 
    /* [unique][string][in] */ STRING_HANDLE pServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pResource,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pAddress);

DWORD RpcClusterSplClose( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phPrinter);

DWORD RpcClusterSplIsAlive( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcSetPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD Type,
    /* [size_is][in] */ LPBYTE pData,
    /* [in] */ DWORD cbData);

DWORD RpcGetPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD nSize,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcEnumPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [size_is][out] */ LPBYTE pEnumValues,
    /* [in] */ DWORD cbEnumValues,
    /* [out] */ LPDWORD pcbEnumValues,
    /* [out] */ LPDWORD pnEnumValues);

DWORD RpcEnumPrinterKey( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [size_is][out] */ wchar_t __RPC_FAR *pSubkey,
    /* [in] */ DWORD cbSubkey,
    /* [out] */ LPDWORD pcbSubkey);

DWORD RpcDeletePrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName);

DWORD RpcDeletePrinterKey( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName);

DWORD RpcSeekPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ LARGE_INTEGER liDistanceToMove,
    /* [out] */ PLARGE_INTEGER pliNewPointer,
    /* [in] */ DWORD dwMoveMethod,
    /* [in] */ BOOL bWrite);

DWORD RpcDeletePrinterDriverEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pDriverName,
    /* [in] */ DWORD dwDeleteFlag,
    /* [in] */ DWORD dwVersionNum);

DWORD RpcAddPerMachineConnection( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrinterName,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrintServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pProvider);

DWORD RpcDeletePerMachineConnection( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrinterName);

DWORD RpcEnumPerMachineConnections( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [size_is][unique][out][in] */ LPBYTE pPrinterEnum,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcXcvData( 
    /* [in] */ PRINTER_HANDLE hXcv,
    /* [string][in] */ const wchar_t __RPC_FAR *pszDataName,
    /* [size_is][in] */ PBYTE pInputData,
    /* [in] */ DWORD cbInputData,
    /* [size_is][out] */ PBYTE pOutputData,
    /* [in] */ DWORD cbOutputData,
    /* [out] */ PDWORD pcbOutputNeeded,
    /* [out][in] */ PDWORD pdwStatus);

DWORD RpcAddPrinterDriverEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PDRIVER_CONTAINER pDriverContainer,
    /* [in] */ DWORD dwFileCopyFlags);

DWORD RpcSplOpenPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired,
    /* [out][in] */ PSPLCLIENT_CONTAINER pSplClientContainer);

DWORD RpcGetSpoolFileInfo( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwAppProcessId,
    /* [in] */ DWORD dwLevel,
    /* [size_is][out] */ LPBYTE pSpoolFileInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcCommitSpoolData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwAppProcessId,
    /* [in] */ DWORD cbCommit,
    /* [in] */ DWORD dwLevel,
    /* [size_is][out] */ LPBYTE pSpoolFileInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcCloseSpoolFileHandle( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcFlushPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][in] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcWritten,
    /* [in] */ DWORD cSleep);


extern handle_t winspool_bhandle;


extern RPC_IF_HANDLE winspool_ClientIfHandle;
extern RPC_IF_HANDLE winspool_ServerIfHandle;
#endif /* __winspool_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER STRING_HANDLE_bind  ( STRING_HANDLE );
void     __RPC_USER STRING_HANDLE_unbind( STRING_HANDLE, handle_t );

void __RPC_USER PRINTER_HANDLE_rundown( PRINTER_HANDLE );
void __RPC_USER GDI_HANDLE_rundown( GDI_HANDLE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

typedef void (*PMFN)(void);


//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

typedef struct TypeDescriptor
{
#if _RTTI
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#define CT_PTD(ct)			((ct).pType)
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
	CatchableType	*arrayOfCatchableTypes[];
	} CatchableTypeArray;
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler

	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
} ThrowInfo;

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index

#define EH_EMPTY_STATE	-1


//
// HandlerType - description of a single 'catch'
//

typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
										//		of current stack frame.
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
} HandlerType;

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#define HT_PTD(ht)				((ht).pType)
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA) && !defined(_M_IA64)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
	HandlerType *pHandlerArray;		// List of handlers for this try
} TryBlockMapEntry;

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#if  !defined(_M_IA64)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#endif // !defined(_M_IA64)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
	void			(*action)(void);	// Funclet to call to effect state change
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#define UWE_ACTION(uwe)		((uwe).action)

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
	ULONG		Ip;
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

typedef const struct _s_FuncInfo
{
	unsigned int		magicNumber;		// Identifies version of compiler
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
} FuncInfo;

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#elif defined(_M_IA64)

#if !defined(_NTSUBSET_)

struct _CONTEXT;
struct _EXCEPTION_RECORD;
typedef __int64 ULONGLONG;

typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

typedef struct _UNWIND_INFO {
    USHORT Version;                            // Version Number
    USHORT Flags;                              // Flags
    ULONG DataLength;                          // Length of Descriptor Data
    PVOID Descriptors;                         // Unwind Descriptors
} UNWIND_INFO, *PUNWIND_INFO;

typedef union _FRAME_POINTERS {
    struct {
        ULONG MemoryStackFp;
        ULONG BackingStoreFp;
    };
    ULONGLONG FramePointers;           // used to force 8-byte alignment
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    PEXCEPTION_ROUTINE ExceptionHandler;
    PVOID HandlerData;
    PUNWIND_INFO UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#endif

//
// On IA64 we don't have a registration node, just a pointer to the stack
// frame base and backing store base.
//
typedef FRAME_POINTERS EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    ULONG ControlPc;
    struct _RUNTIME_FUNCTION *FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext, *pDispatcherContext;

typedef struct _EHContext {
    PVOID Psp;
    LONG  State;
} EHContext;

#define EH_STATE_OFFSET -12

#define EH_STATE(pRN) \
    (*(int*)(pRN->MemoryStackFp + EH_STATE_OFFSET))

#else
#error "Machine not supported"
#endif


/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//

typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
		} params;
} EHExceptionRecord;

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))



/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\ntdbg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntdbg.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT Dbg subsystem.

Revision History:

--*/

#ifndef _NTDBG_
#define _NTDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif



//
// The following are explicitly sized versions of common system
// structures which appear in the kernel debugger API.
//
// All of the debugger structures which are exposed to both
// sides of the KD API are declared below in explicitly sized
// versions as well, with inline converter functions.
//

//
// Macro for sign extending 32 bit addresses into 64 bits
//

#define COPYSE(p64,p32,f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

__inline
void
ExceptionRecord32To64(
    IN PEXCEPTION_RECORD32 Ex32,
    OUT PEXCEPTION_RECORD64 Ex64
    )
{
    ULONG i;
    Ex64->ExceptionCode = Ex32->ExceptionCode;
    Ex64->ExceptionFlags = Ex32->ExceptionFlags;
    Ex64->ExceptionRecord = Ex32->ExceptionRecord;
    COPYSE(Ex64,Ex32,ExceptionAddress);
    Ex64->NumberParameters = Ex32->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++) {
        COPYSE(Ex64,Ex32,ExceptionInformation[i]);
    }
}

__inline
void
ExceptionRecord64To32(
    IN PEXCEPTION_RECORD64 Ex64,
    OUT PEXCEPTION_RECORD32 Ex32
    )
{
    ULONG i;
    Ex32->ExceptionCode = Ex64->ExceptionCode;
    Ex32->ExceptionFlags = Ex64->ExceptionFlags;
    Ex32->ExceptionRecord = (ULONG) Ex64->ExceptionRecord;
    Ex32->ExceptionAddress = (ULONG) Ex64->ExceptionAddress;
    Ex32->NumberParameters = Ex64->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++) {
        Ex32->ExceptionInformation[i] = (ULONG) Ex64->ExceptionInformation[i];
    }
}


//
// DbgKm Apis are from the kernel component (Dbgk) through a process
// debug port.
//

#define DBGKM_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGKM_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGKM_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGKM_APIMSG) << 16) | (DBGKM_MSG_OVERHEAD + (TypeSize)))

#define DBGKM_FORMAT_API_MSG(m,Number,TypeSize)             \
    (m).h.u1.Length = DBGKM_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = LPC_DEBUG_EVENT;                    \
    (m).ApiNumber = (Number)

typedef enum _DBGKM_APINUMBER {
    DbgKmExceptionApi,
    DbgKmCreateThreadApi,
    DbgKmCreateProcessApi,
    DbgKmExitThreadApi,
    DbgKmExitProcessApi,
    DbgKmLoadDllApi,
    DbgKmUnloadDllApi,
    DbgKmMaxApiNumber
} DBGKM_APINUMBER;


#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_EXCEPTION {
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;
#endif

typedef struct _DBGKM_EXCEPTION32 {
    EXCEPTION_RECORD32 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION32, *PDBGKM_EXCEPTION32;

typedef struct _DBGKM_EXCEPTION64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION64, *PDBGKM_EXCEPTION64;

__inline
void
DbgkmException32To64(
    IN PDBGKM_EXCEPTION32 E32,
    OUT PDBGKM_EXCEPTION64 E64
    )
{
    ExceptionRecord32To64(&E32->ExceptionRecord, &E64->ExceptionRecord);
    E64->FirstChance = E32->FirstChance;
}

__inline
void
DbgkmException64To32(
    IN PDBGKM_EXCEPTION64 E64,
    OUT PDBGKM_EXCEPTION32 E32
    )
{
    ExceptionRecord64To32(&E64->ExceptionRecord, &E32->ExceptionRecord);
    E32->FirstChance = E64->FirstChance;
}


//
// The DbgSS, DbgKm and DbgSs stuff is not needed in the portable debugger,
// and some of the following types and prototypes use portable types, so just
// turn them all off when building the debugger.
//

#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_CREATE_THREAD {
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS {
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL {
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL {
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef struct _DBGKM_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGKM_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGKM_APIMSG, *PDBGKM_APIMSG;

//
// DbgSrv Messages are from Dbg subsystem to emulation subsystem.
// The only defined message at this time is continue
//

#define DBGSRV_MSG_OVERHEAD \
    (sizeof(DBGSRV_APIMSG) - sizeof(PORT_MESSAGE))

#define DBGSRV_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSRV_APIMSG) << 16) | (DBGSRV_MSG_OVERHEAD))

#define DBGSRV_FORMAT_API_MSG(m,Number,TypeSize,CKey)     \
    (m).h.u1.Length = DBGSRV_API_MSG_LENGTH((TypeSize));  \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSRV_APINUMBER {
    DbgSrvContinueApi,
    DbgSrvMaxApiNumber
} DBGSRV_APINUMBER;

typedef struct _DBGSRV_APIMSG {
    PORT_MESSAGE h;
    DBGSRV_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    PVOID ContinueKey;
} DBGSRV_APIMSG, *PDBGSRV_APIMSG;

//
//
// DbgSs Apis are from the system service emulation subsystems to the Dbg
// subsystem
//

typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

#define DBGSS_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGSS_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGSS_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSS_APIMSG) << 16) | (DBGSS_MSG_OVERHEAD + (TypeSize)))

#define DBGSS_FORMAT_API_MSG(m,Number,TypeSize,pApp,CKey)  \
    (m).h.u1.Length = DBGSS_API_MSG_LENGTH((TypeSize));   \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).AppClientId = *(pApp);                            \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSS_APINUMBER {
    DbgSsExceptionApi,
    DbgSsCreateThreadApi,
    DbgSsCreateProcessApi,
    DbgSsExitThreadApi,
    DbgSsExitProcessApi,
    DbgSsLoadDllApi,
    DbgSsUnloadDllApi,
    DbgSsMaxApiNumber
} DBGSS_APINUMBER;

typedef struct _DBGSS_CREATE_PROCESS {
    CLIENT_ID DebugUiClientId;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGSS_CREATE_PROCESS, *PDBGSS_CREATE_PROCESS;

typedef struct _DBGSS_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    CLIENT_ID AppClientId;
    PVOID ContinueKey;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGSS_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGSS_APIMSG, *PDBGSS_APIMSG;

#define DBGUI_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGUI_APIMSG, u.Continue) - sizeof(PORT_MESSAGE))

#define DBGUI_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGUI_APIMSG) << 16) | (DBGUI_MSG_OVERHEAD + (TypeSize)))

#define DBGUI_FORMAT_API_MSG(m,Number,TypeSize)            \
    (m).h.u1.Length = DBGUI_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number)

typedef enum _DBGUI_APINUMBER {
    DbgUiWaitStateChangeApi,
    DbgUiContinueApi,
    DbgUiStopDebugApi,
    DbgUiMaxApiNumber
} DBGUI_APINUMBER;

typedef struct _DBGUI_CREATE_THREAD {
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE {
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

typedef struct _DBGUI_CONTINUE {
    CLIENT_ID AppClientId;
    NTSTATUS ContinueStatus;
} DBGUI_CONTINUE, *PDBGUI_CONTINUE;

typedef struct _DBGUI_STOPDEBUG {
    ULONG ProcessId;
} DBGUI_STOPDEBUG, *PDBGUI_STOPDEBUG;

typedef struct _DBGUI_APIMSG {
    PORT_MESSAGE h;
    union {
        HANDLE DbgStateChangeSemaphore;
        struct {
            DBGKM_APINUMBER ApiNumber;
            NTSTATUS ReturnedStatus;
            union {
                DBGUI_CONTINUE Continue;
                DBGUI_WAIT_STATE_CHANGE WaitStateChange;
                DBGUI_STOPDEBUG StopDebug;
            } u;
        };
    };
} DBGUI_APIMSG, *PDBGUI_APIMSG;

typedef
NTSTATUS
(*PDBGSS_UI_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PCLIENT_ID DebugUiClientId
    );

typedef
NTSTATUS
(*PDBGSS_DBGKM_APIMSG_FILTER) (
    IN OUT PDBGKM_APIMSG ApiMsg
    );

typedef
NTSTATUS
(*PDBGSS_SUBSYSTEMKEY_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PULONG SubsystemKey,
    IN BOOLEAN ProcessKey
    );
//
// DbgSs APIs
//

NTSTATUS
NTAPI
DbgSsInitialize(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

VOID
NTAPI
DbgSsHandleKmApiMsg(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

typedef
NTSTATUS
(*PDBGSS_INITIALIZE_ROUTINE)(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

typedef
VOID
(*PDBGSS_HANDLE_MSG_ROUTINE)(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

//
// DbgUi APIs
//

NTSTATUS
NTAPI
DbgUiConnectToDbg( VOID );

HANDLE
NTAPI
DbgUiGetThreadDebugObject (
    );

VOID
NTAPI
DbgUiSetThreadDebugObject (
    IN HANDLE DebugObject
    );

NTSTATUS
NTAPI
DbgUiWaitStateChange (
    OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
NTAPI
DbgUiContinue (
    IN PCLIENT_ID AppClientId,
    IN NTSTATUS ContinueStatus
    );

NTSTATUS
NTAPI
DbgUiStopDebugging (
    IN HANDLE Process
    );

NTSTATUS
DbgUiDebugActiveProcess (
     IN HANDLE Process
     );

VOID
DbgUiRemoteBreakin (
    IN PVOID Context
    );

NTSTATUS
DbgUiIssueRemoteBreakin (
    IN HANDLE Process
    );

struct _DEBUG_EVENT;

NTSTATUS
DbgUiConvertStateChangeStructure (
    IN PDBGUI_WAIT_STATE_CHANGE StateChange,
    OUT struct _DEBUG_EVENT *DebugEvent);

#endif // DBG_NO_PORTABLE_TYPES





typedef struct _KAPC_STATE32 {
    LIST_ENTRY32 ApcListHead[2];
    ULONG Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE32;

typedef struct _KAPC_STATE64 {
    LIST_ENTRY64 ApcListHead[2];
    ULONG64 Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE64;

typedef struct _DISPATCHER_HEADER32 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY32 WaitListHead;
} DISPATCHER_HEADER32;

typedef struct _DISPATCHER_HEADER64 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY64 WaitListHead;
} DISPATCHER_HEADER64;

typedef struct _KSPIN_LOCK_QUEUE32 {
    ULONG Next;
    ULONG Lock;
} KSPIN_LOCK_QUEUE32, *PKSPIN_LOCK_QUEUE32;

typedef struct _KSPIN_LOCK_QUEUE64 {
    ULONG64 Next;
    ULONG64 Lock;
} KSPIN_LOCK_QUEUE64, *PKSPIN_LOCK_QUEUE64;

typedef struct _PP_LOOKASIDE_LIST32 {
    ULONG P;
    ULONG L;
} PP_LOOKASIDE_LIST32, *PPP_LOOKASIDE_LIST32;

typedef struct _PP_LOOKASIDE_LIST64 {
    ULONG P;
    ULONG L;
} PP_LOOKASIDE_LIST64, *PPP_LOOKASIDE_LIST64;

#define NT51_POOL_SMALL_LISTS 32


//
// X86 KSWITCHFRAME
//
typedef struct _X86_KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} X86_KSWITCHFRAME, *PX86_KSWITCHFRAME;


//
// Special Registers for i386
//

typedef struct _X86_DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} X86_DESCRIPTOR, *PX86_DESCRIPTOR;

typedef struct _X86_KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    X86_DESCRIPTOR Gdtr;
    X86_DESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} X86_KSPECIAL_REGISTERS, *PX86_KSPECIAL_REGISTERS;


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define X86_SIZE_OF_80387_REGISTERS      80

typedef struct _X86_FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[X86_SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} X86_FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _X86_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} X86_CONTEXT, *PX86_CONTEXT;

#define MAXIMUM_SUPPORTED_EXTENSION     512

//
// Define the size of FP registers in the FXSAVE format
//
#define X86_SIZE_OF_FX_REGISTERS        128

typedef struct _X86_FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[X86_SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[X86_SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
} X86_FXSAVE_FORMAT, *PX86_FXSAVE_FORMAT;

typedef struct _X86_NT5_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;
    union {
        UCHAR   ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
        X86_FXSAVE_FORMAT FxSave;
    };

} X86_NT5_CONTEXT, *PX86_NT5_CONTEXT;

typedef struct _ALPHA_CONTEXT {

    ULONG FltF0;
    ULONG FltF1;
    ULONG FltF2;
    ULONG FltF3;
    ULONG FltF4;
    ULONG FltF5;
    ULONG FltF6;
    ULONG FltF7;
    ULONG FltF8;
    ULONG FltF9;
    ULONG FltF10;
    ULONG FltF11;
    ULONG FltF12;
    ULONG FltF13;
    ULONG FltF14;
    ULONG FltF15;
    ULONG FltF16;
    ULONG FltF17;
    ULONG FltF18;
    ULONG FltF19;
    ULONG FltF20;
    ULONG FltF21;
    ULONG FltF22;
    ULONG FltF23;
    ULONG FltF24;
    ULONG FltF25;
    ULONG FltF26;
    ULONG FltF27;
    ULONG FltF28;
    ULONG FltF29;
    ULONG FltF30;
    ULONG FltF31;

    ULONG IntV0;        //  $0: return value register, v0
    ULONG IntT0;        //  $1: temporary registers, t0 - t7
    ULONG IntT1;        //  $2:
    ULONG IntT2;        //  $3:
    ULONG IntT3;        //  $4:
    ULONG IntT4;        //  $5:
    ULONG IntT5;        //  $6:
    ULONG IntT6;        //  $7:
    ULONG IntT7;        //  $8:
    ULONG IntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG IntS1;        // $10:
    ULONG IntS2;        // $11:
    ULONG IntS3;        // $12:
    ULONG IntS4;        // $13:
    ULONG IntS5;        // $14:
    ULONG IntFp;        // $15: frame pointer register, fp/s6
    ULONG IntA0;        // $16: argument registers, a0 - a5
    ULONG IntA1;        // $17:
    ULONG IntA2;        // $18:
    ULONG IntA3;        // $19:
    ULONG IntA4;        // $20:
    ULONG IntA5;        // $21:
    ULONG IntT8;        // $22: temporary registers, t8 - t11
    ULONG IntT9;        // $23:
    ULONG IntT10;       // $24:
    ULONG IntT11;       // $25:
    ULONG IntRa;        // $26: return address register, ra
    ULONG IntT12;       // $27: temporary register, t12
    ULONG IntAt;        // $28: assembler temp register, at
    ULONG IntGp;        // $29: global pointer register, gp
    ULONG IntSp;        // $30: stack pointer register, sp
    ULONG IntZero;      // $31: zero register, zero

    ULONG Fpcr;         // floating point control register
    ULONG SoftFpcr;     // software extension to FPCR

    ULONG Fir;          // (fault instruction) continuation address

    ULONG Psr;          // processor status
    ULONG ContextFlags;

    //
    // Beginning of the "second half".
    // The name "High" parallels the HighPart of a LargeInteger.
    //

    ULONG HighFltF0;
    ULONG HighFltF1;
    ULONG HighFltF2;
    ULONG HighFltF3;
    ULONG HighFltF4;
    ULONG HighFltF5;
    ULONG HighFltF6;
    ULONG HighFltF7;
    ULONG HighFltF8;
    ULONG HighFltF9;
    ULONG HighFltF10;
    ULONG HighFltF11;
    ULONG HighFltF12;
    ULONG HighFltF13;
    ULONG HighFltF14;
    ULONG HighFltF15;
    ULONG HighFltF16;
    ULONG HighFltF17;
    ULONG HighFltF18;
    ULONG HighFltF19;
    ULONG HighFltF20;
    ULONG HighFltF21;
    ULONG HighFltF22;
    ULONG HighFltF23;
    ULONG HighFltF24;
    ULONG HighFltF25;
    ULONG HighFltF26;
    ULONG HighFltF27;
    ULONG HighFltF28;
    ULONG HighFltF29;
    ULONG HighFltF30;
    ULONG HighFltF31;

    ULONG HighIntV0;        //  $0: return value register, v0
    ULONG HighIntT0;        //  $1: temporary registers, t0 - t7
    ULONG HighIntT1;        //  $2:
    ULONG HighIntT2;        //  $3:
    ULONG HighIntT3;        //  $4:
    ULONG HighIntT4;        //  $5:
    ULONG HighIntT5;        //  $6:
    ULONG HighIntT6;        //  $7:
    ULONG HighIntT7;        //  $8:
    ULONG HighIntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG HighIntS1;        // $10:
    ULONG HighIntS2;        // $11:
    ULONG HighIntS3;        // $12:
    ULONG HighIntS4;        // $13:
    ULONG HighIntS5;        // $14:
    ULONG HighIntFp;        // $15: frame pointer register, fp/s6
    ULONG HighIntA0;        // $16: argument registers, a0 - a5
    ULONG HighIntA1;        // $17:
    ULONG HighIntA2;        // $18:
    ULONG HighIntA3;        // $19:
    ULONG HighIntA4;        // $20:
    ULONG HighIntA5;        // $21:
    ULONG HighIntT8;        // $22: temporary registers, t8 - t11
    ULONG HighIntT9;        // $23:
    ULONG HighIntT10;       // $24:
    ULONG HighIntT11;       // $25:
    ULONG HighIntRa;        // $26: return address register, ra
    ULONG HighIntT12;       // $27: temporary register, t12
    ULONG HighIntAt;        // $28: assembler temp register, at
    ULONG HighIntGp;        // $29: global pointer register, gp
    ULONG HighIntSp;        // $30: stack pointer register, sp
    ULONG HighIntZero;      // $31: zero register, zero

    ULONG HighFpcr;         // floating point control register
    ULONG HighSoftFpcr;     // software extension to FPCR
    ULONG HighFir;          // processor status

    double DoNotUseThisField; // to force quadword structure alignment
    ULONG HighFill[2];      // padding for 16-byte stack frame alignment


} ALPHA_CONTEXT, *PALPHA_CONTEXT;


typedef struct _ALPHA_NT5_CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG FltF0;
    ULONGLONG FltF1;
    ULONGLONG FltF2;
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;
    ULONGLONG FltF10;
    ULONGLONG FltF11;
    ULONGLONG FltF12;
    ULONGLONG FltF13;
    ULONGLONG FltF14;
    ULONGLONG FltF15;
    ULONGLONG FltF16;
    ULONGLONG FltF17;
    ULONGLONG FltF18;
    ULONGLONG FltF19;
    ULONGLONG FltF20;
    ULONGLONG FltF21;
    ULONGLONG FltF22;
    ULONGLONG FltF23;
    ULONGLONG FltF24;
    ULONGLONG FltF25;
    ULONGLONG FltF26;
    ULONGLONG FltF27;
    ULONGLONG FltF28;
    ULONGLONG FltF29;
    ULONGLONG FltF30;
    ULONGLONG FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:
    ULONGLONG IntS0;    //  $9: nonvolatile registers, s0 - s5
    ULONGLONG IntS1;    // $10:
    ULONGLONG IntS2;    // $11:
    ULONGLONG IntS3;    // $12:
    ULONGLONG IntS4;    // $13:
    ULONGLONG IntS5;    // $14:
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6
    ULONGLONG IntA0;    // $16: argument registers, a0 - a5
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:
    ULONGLONG IntA4;    // $20:
    ULONGLONG IntA5;    // $21:
    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:
    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temp register, at
    ULONGLONG IntGp;    // $29: global pointer register, gp
    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG IntZero;  // $31: zero register, zero

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG SoftFpcr; // software extension to FPCR

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill[4];      // padding for 16-byte stack frame alignment

} ALPHA_NT5_CONTEXT, *PALPHA_NT5_CONTEXT;


typedef struct _IA64_KSPECIAL_REGISTERS {  // Intel-IA64-Filler

    // Kernel debug breakpoint registers       // Intel-IA64-Filler

    ULONGLONG KernelDbI0;         // Instruction debug registers       // Intel-IA64-Filler
    ULONGLONG KernelDbI1;       // Intel-IA64-Filler
    ULONGLONG KernelDbI2;       // Intel-IA64-Filler
    ULONGLONG KernelDbI3;       // Intel-IA64-Filler
    ULONGLONG KernelDbI4;       // Intel-IA64-Filler
    ULONGLONG KernelDbI5;       // Intel-IA64-Filler
    ULONGLONG KernelDbI6;       // Intel-IA64-Filler
    ULONGLONG KernelDbI7;       // Intel-IA64-Filler

    ULONGLONG KernelDbD0;         // Data debug registers       // Intel-IA64-Filler
    ULONGLONG KernelDbD1;       // Intel-IA64-Filler
    ULONGLONG KernelDbD2;       // Intel-IA64-Filler
    ULONGLONG KernelDbD3;       // Intel-IA64-Filler
    ULONGLONG KernelDbD4;       // Intel-IA64-Filler
    ULONGLONG KernelDbD5;       // Intel-IA64-Filler
    ULONGLONG KernelDbD6;       // Intel-IA64-Filler
    ULONGLONG KernelDbD7;       // Intel-IA64-Filler

    // Kernel performance monitor registers       // Intel-IA64-Filler

    ULONGLONG KernelPfC0;         // Performance configuration registers       // Intel-IA64-Filler
    ULONGLONG KernelPfC1;       // Intel-IA64-Filler
    ULONGLONG KernelPfC2;       // Intel-IA64-Filler
    ULONGLONG KernelPfC3;       // Intel-IA64-Filler
    ULONGLONG KernelPfC4;       // Intel-IA64-Filler
    ULONGLONG KernelPfC5;       // Intel-IA64-Filler
    ULONGLONG KernelPfC6;       // Intel-IA64-Filler
    ULONGLONG KernelPfC7;       // Intel-IA64-Filler

    ULONGLONG KernelPfD0;         // Performance data registers       // Intel-IA64-Filler
    ULONGLONG KernelPfD1;       // Intel-IA64-Filler
    ULONGLONG KernelPfD2;       // Intel-IA64-Filler
    ULONGLONG KernelPfD3;       // Intel-IA64-Filler
    ULONGLONG KernelPfD4;       // Intel-IA64-Filler
    ULONGLONG KernelPfD5;       // Intel-IA64-Filler
    ULONGLONG KernelPfD6;       // Intel-IA64-Filler
    ULONGLONG KernelPfD7;       // Intel-IA64-Filler

    // kernel bank shadow (hidden) registers       // Intel-IA64-Filler

    ULONGLONG IntH16;       // Intel-IA64-Filler
    ULONGLONG IntH17;       // Intel-IA64-Filler
    ULONGLONG IntH18;       // Intel-IA64-Filler
    ULONGLONG IntH19;       // Intel-IA64-Filler
    ULONGLONG IntH20;       // Intel-IA64-Filler
    ULONGLONG IntH21;       // Intel-IA64-Filler
    ULONGLONG IntH22;       // Intel-IA64-Filler
    ULONGLONG IntH23;       // Intel-IA64-Filler
    ULONGLONG IntH24;       // Intel-IA64-Filler
    ULONGLONG IntH25;       // Intel-IA64-Filler
    ULONGLONG IntH26;       // Intel-IA64-Filler
    ULONGLONG IntH27;       // Intel-IA64-Filler
    ULONGLONG IntH28;       // Intel-IA64-Filler
    ULONGLONG IntH29;       // Intel-IA64-Filler
    ULONGLONG IntH30;       // Intel-IA64-Filler
    ULONGLONG IntH31;       // Intel-IA64-Filler

    // Application Registers       // Intel-IA64-Filler

    //       - CPUID Registers - AR       // Intel-IA64-Filler
    ULONGLONG ApCPUID0; // Cpuid Register 0       // Intel-IA64-Filler
    ULONGLONG ApCPUID1; // Cpuid Register 1       // Intel-IA64-Filler
    ULONGLONG ApCPUID2; // Cpuid Register 2       // Intel-IA64-Filler
    ULONGLONG ApCPUID3; // Cpuid Register 3       // Intel-IA64-Filler
    ULONGLONG ApCPUID4; // Cpuid Register 4       // Intel-IA64-Filler
    ULONGLONG ApCPUID5; // Cpuid Register 5       // Intel-IA64-Filler
    ULONGLONG ApCPUID6; // Cpuid Register 6       // Intel-IA64-Filler
    ULONGLONG ApCPUID7; // Cpuid Register 7       // Intel-IA64-Filler

    //       - Kernel Registers - AR       // Intel-IA64-Filler
    ULONGLONG ApKR0;    // Kernel Register 0 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR1;    // Kernel Register 1 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR2;    // Kernel Register 2 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR3;    // Kernel Register 3 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR4;    // Kernel Register 4       // Intel-IA64-Filler
    ULONGLONG ApKR5;    // Kernel Register 5       // Intel-IA64-Filler
    ULONGLONG ApKR6;    // Kernel Register 6       // Intel-IA64-Filler
    ULONGLONG ApKR7;    // Kernel Register 7       // Intel-IA64-Filler

    ULONGLONG ApITC;    // Interval Timer Counter       // Intel-IA64-Filler

    // Global control registers       // Intel-IA64-Filler

    ULONGLONG ApITM;    // Interval Timer Match register       // Intel-IA64-Filler
    ULONGLONG ApIVA;    // Interrupt Vector Address       // Intel-IA64-Filler
    ULONGLONG ApPTA;    // Page Table Address       // Intel-IA64-Filler
    ULONGLONG ApGPTA;   // ia32 Page Table Address       // Intel-IA64-Filler

    ULONGLONG StISR;    // Interrupt status       // Intel-IA64-Filler
    ULONGLONG StIFA;    // Interruption Faulting Address       // Intel-IA64-Filler
    ULONGLONG StITIR;   // Interruption TLB Insertion Register       // Intel-IA64-Filler
    ULONGLONG StIIPA;   // Interruption Instruction Previous Address (RO)       // Intel-IA64-Filler
    ULONGLONG StIIM;    // Interruption Immediate register (RO)       // Intel-IA64-Filler
    ULONGLONG StIHA;    // Interruption Hash Address (RO)       // Intel-IA64-Filler

    //       - External Interrupt control registers (SAPIC)       // Intel-IA64-Filler
    ULONGLONG SaLID;    // Local SAPIC ID       // Intel-IA64-Filler
    ULONGLONG SaIVR;    // Interrupt Vector Register (RO)       // Intel-IA64-Filler
    ULONGLONG SaTPR;    // Task Priority Register       // Intel-IA64-Filler
    ULONGLONG SaEOI;    // End Of Interrupt       // Intel-IA64-Filler
    ULONGLONG SaIRR0;   // Interrupt Request Register 0 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR1;   // Interrupt Request Register 1 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR2;   // Interrupt Request Register 2 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR3;   // Interrupt Request Register 3 (RO)       // Intel-IA64-Filler
    ULONGLONG SaITV;    // Interrupt Timer Vector       // Intel-IA64-Filler
    ULONGLONG SaPMV;    // Performance Monitor Vector       // Intel-IA64-Filler
    ULONGLONG SaCMCV;   // Corrected Machine Check Vector       // Intel-IA64-Filler
    ULONGLONG SaLRR0;   // Local Interrupt Redirection Vector 0       // Intel-IA64-Filler
    ULONGLONG SaLRR1;   // Local Interrupt Redirection Vector 1       // Intel-IA64-Filler

    // System Registers       // Intel-IA64-Filler
    //       - Region registers       // Intel-IA64-Filler
    ULONGLONG Rr0;  // Region register 0       // Intel-IA64-Filler
    ULONGLONG Rr1;  // Region register 1       // Intel-IA64-Filler
    ULONGLONG Rr2;  // Region register 2       // Intel-IA64-Filler
    ULONGLONG Rr3;  // Region register 3       // Intel-IA64-Filler
    ULONGLONG Rr4;  // Region register 4       // Intel-IA64-Filler
    ULONGLONG Rr5;  // Region register 5       // Intel-IA64-Filler
    ULONGLONG Rr6;  // Region register 6       // Intel-IA64-Filler
    ULONGLONG Rr7;  // Region register 7       // Intel-IA64-Filler

    //      - Protection Key registers  // Intel-IA64-Filler
    ULONGLONG Pkr0;     // Protection Key register 0  // Intel-IA64-Filler
    ULONGLONG Pkr1;     // Protection Key register 1  // Intel-IA64-Filler
    ULONGLONG Pkr2;     // Protection Key register 2  // Intel-IA64-Filler
    ULONGLONG Pkr3;     // Protection Key register 3  // Intel-IA64-Filler
    ULONGLONG Pkr4;     // Protection Key register 4  // Intel-IA64-Filler
    ULONGLONG Pkr5;     // Protection Key register 5  // Intel-IA64-Filler
    ULONGLONG Pkr6;     // Protection Key register 6  // Intel-IA64-Filler
    ULONGLONG Pkr7;     // Protection Key register 7  // Intel-IA64-Filler
    ULONGLONG Pkr8;     // Protection Key register 8  // Intel-IA64-Filler
    ULONGLONG Pkr9;     // Protection Key register 9  // Intel-IA64-Filler
    ULONGLONG Pkr10;    // Protection Key register 10  // Intel-IA64-Filler
    ULONGLONG Pkr11;    // Protection Key register 11  // Intel-IA64-Filler
    ULONGLONG Pkr12;    // Protection Key register 12  // Intel-IA64-Filler
    ULONGLONG Pkr13;    // Protection Key register 13  // Intel-IA64-Filler
    ULONGLONG Pkr14;    // Protection Key register 14  // Intel-IA64-Filler
    ULONGLONG Pkr15;    // Protection Key register 15  // Intel-IA64-Filler

    //      -  Translation Lookaside buffers  // Intel-IA64-Filler
    ULONGLONG TrI0;     // Instruction Translation Register 0  // Intel-IA64-Filler
    ULONGLONG TrI1;     // Instruction Translation Register 1  // Intel-IA64-Filler
    ULONGLONG TrI2;     // Instruction Translation Register 2  // Intel-IA64-Filler
    ULONGLONG TrI3;     // Instruction Translation Register 3  // Intel-IA64-Filler
    ULONGLONG TrI4;     // Instruction Translation Register 4  // Intel-IA64-Filler
    ULONGLONG TrI5;     // Instruction Translation Register 5  // Intel-IA64-Filler
    ULONGLONG TrI6;     // Instruction Translation Register 6  // Intel-IA64-Filler
    ULONGLONG TrI7;     // Instruction Translation Register 7  // Intel-IA64-Filler

    ULONGLONG TrD0;     // Data Translation Register 0  // Intel-IA64-Filler
    ULONGLONG TrD1;     // Data Translation Register 1  // Intel-IA64-Filler
    ULONGLONG TrD2;     // Data Translation Register 2  // Intel-IA64-Filler
    ULONGLONG TrD3;     // Data Translation Register 3  // Intel-IA64-Filler
    ULONGLONG TrD4;     // Data Translation Register 4  // Intel-IA64-Filler
    ULONGLONG TrD5;     // Data Translation Register 5  // Intel-IA64-Filler
    ULONGLONG TrD6;     // Data Translation Register 6  // Intel-IA64-Filler
    ULONGLONG TrD7;     // Data Translation Register 7  // Intel-IA64-Filler

    //      -  Machine Specific Registers  // Intel-IA64-Filler
    ULONGLONG SrMSR0;   // Machine Specific Register 0  // Intel-IA64-Filler
    ULONGLONG SrMSR1;   // Machine Specific Register 1  // Intel-IA64-Filler
    ULONGLONG SrMSR2;   // Machine Specific Register 2  // Intel-IA64-Filler
    ULONGLONG SrMSR3;   // Machine Specific Register 3  // Intel-IA64-Filler
    ULONGLONG SrMSR4;   // Machine Specific Register 4  // Intel-IA64-Filler
    ULONGLONG SrMSR5;   // Machine Specific Register 5  // Intel-IA64-Filler
    ULONGLONG SrMSR6;   // Machine Specific Register 6  // Intel-IA64-Filler
    ULONGLONG SrMSR7;   // Machine Specific Register 7  // Intel-IA64-Filler

} IA64_KSPECIAL_REGISTERS, *PIA64_KSPECIAL_REGISTERS;  // Intel-IA64-Filler


typedef struct _IA64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

    ULONGLONG DbI0;         // Intel-IA64-Filler
    ULONGLONG DbI1;         // Intel-IA64-Filler
    ULONGLONG DbI2;         // Intel-IA64-Filler
    ULONGLONG DbI3;         // Intel-IA64-Filler
    ULONGLONG DbI4;         // Intel-IA64-Filler
    ULONGLONG DbI5;         // Intel-IA64-Filler
    ULONGLONG DbI6;         // Intel-IA64-Filler
    ULONGLONG DbI7;         // Intel-IA64-Filler

    ULONGLONG DbD0;         // Intel-IA64-Filler
    ULONGLONG DbD1;         // Intel-IA64-Filler
    ULONGLONG DbD2;         // Intel-IA64-Filler
    ULONGLONG DbD3;         // Intel-IA64-Filler
    ULONGLONG DbD4;         // Intel-IA64-Filler
    ULONGLONG DbD5;         // Intel-IA64-Filler
    ULONGLONG DbD6;         // Intel-IA64-Filler
    ULONGLONG DbD7;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //

    FLOAT128 FltS0;         // Intel-IA64-Filler
    FLOAT128 FltS1;         // Intel-IA64-Filler
    FLOAT128 FltS2;         // Intel-IA64-Filler
    FLOAT128 FltS3;         // Intel-IA64-Filler
    FLOAT128 FltT0;         // Intel-IA64-Filler
    FLOAT128 FltT1;         // Intel-IA64-Filler
    FLOAT128 FltT2;         // Intel-IA64-Filler
    FLOAT128 FltT3;         // Intel-IA64-Filler
    FLOAT128 FltT4;         // Intel-IA64-Filler
    FLOAT128 FltT5;         // Intel-IA64-Filler
    FLOAT128 FltT6;         // Intel-IA64-Filler
    FLOAT128 FltT7;         // Intel-IA64-Filler
    FLOAT128 FltT8;         // Intel-IA64-Filler
    FLOAT128 FltT9;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //

    FLOAT128 FltS4;         // Intel-IA64-Filler
    FLOAT128 FltS5;         // Intel-IA64-Filler
    FLOAT128 FltS6;         // Intel-IA64-Filler
    FLOAT128 FltS7;         // Intel-IA64-Filler
    FLOAT128 FltS8;         // Intel-IA64-Filler
    FLOAT128 FltS9;         // Intel-IA64-Filler
    FLOAT128 FltS10;        // Intel-IA64-Filler
    FLOAT128 FltS11;        // Intel-IA64-Filler
    FLOAT128 FltS12;        // Intel-IA64-Filler
    FLOAT128 FltS13;        // Intel-IA64-Filler
    FLOAT128 FltS14;        // Intel-IA64-Filler
    FLOAT128 FltS15;        // Intel-IA64-Filler
    FLOAT128 FltS16;        // Intel-IA64-Filler
    FLOAT128 FltS17;        // Intel-IA64-Filler
    FLOAT128 FltS18;        // Intel-IA64-Filler
    FLOAT128 FltS19;        // Intel-IA64-Filler

    FLOAT128 FltF32;        // Intel-IA64-Filler
    FLOAT128 FltF33;        // Intel-IA64-Filler
    FLOAT128 FltF34;        // Intel-IA64-Filler
    FLOAT128 FltF35;        // Intel-IA64-Filler
    FLOAT128 FltF36;        // Intel-IA64-Filler
    FLOAT128 FltF37;        // Intel-IA64-Filler
    FLOAT128 FltF38;        // Intel-IA64-Filler
    FLOAT128 FltF39;        // Intel-IA64-Filler

    FLOAT128 FltF40;        // Intel-IA64-Filler
    FLOAT128 FltF41;        // Intel-IA64-Filler
    FLOAT128 FltF42;        // Intel-IA64-Filler
    FLOAT128 FltF43;        // Intel-IA64-Filler
    FLOAT128 FltF44;        // Intel-IA64-Filler
    FLOAT128 FltF45;        // Intel-IA64-Filler
    FLOAT128 FltF46;        // Intel-IA64-Filler
    FLOAT128 FltF47;        // Intel-IA64-Filler
    FLOAT128 FltF48;        // Intel-IA64-Filler
    FLOAT128 FltF49;        // Intel-IA64-Filler

    FLOAT128 FltF50;        // Intel-IA64-Filler
    FLOAT128 FltF51;        // Intel-IA64-Filler
    FLOAT128 FltF52;        // Intel-IA64-Filler
    FLOAT128 FltF53;        // Intel-IA64-Filler
    FLOAT128 FltF54;        // Intel-IA64-Filler
    FLOAT128 FltF55;        // Intel-IA64-Filler
    FLOAT128 FltF56;        // Intel-IA64-Filler
    FLOAT128 FltF57;        // Intel-IA64-Filler
    FLOAT128 FltF58;        // Intel-IA64-Filler
    FLOAT128 FltF59;        // Intel-IA64-Filler

    FLOAT128 FltF60;        // Intel-IA64-Filler
    FLOAT128 FltF61;        // Intel-IA64-Filler
    FLOAT128 FltF62;        // Intel-IA64-Filler
    FLOAT128 FltF63;        // Intel-IA64-Filler
    FLOAT128 FltF64;        // Intel-IA64-Filler
    FLOAT128 FltF65;        // Intel-IA64-Filler
    FLOAT128 FltF66;        // Intel-IA64-Filler
    FLOAT128 FltF67;        // Intel-IA64-Filler
    FLOAT128 FltF68;        // Intel-IA64-Filler
    FLOAT128 FltF69;        // Intel-IA64-Filler

    FLOAT128 FltF70;        // Intel-IA64-Filler
    FLOAT128 FltF71;        // Intel-IA64-Filler
    FLOAT128 FltF72;        // Intel-IA64-Filler
    FLOAT128 FltF73;        // Intel-IA64-Filler
    FLOAT128 FltF74;        // Intel-IA64-Filler
    FLOAT128 FltF75;        // Intel-IA64-Filler
    FLOAT128 FltF76;        // Intel-IA64-Filler
    FLOAT128 FltF77;        // Intel-IA64-Filler
    FLOAT128 FltF78;        // Intel-IA64-Filler
    FLOAT128 FltF79;        // Intel-IA64-Filler

    FLOAT128 FltF80;        // Intel-IA64-Filler
    FLOAT128 FltF81;        // Intel-IA64-Filler
    FLOAT128 FltF82;        // Intel-IA64-Filler
    FLOAT128 FltF83;        // Intel-IA64-Filler
    FLOAT128 FltF84;        // Intel-IA64-Filler
    FLOAT128 FltF85;        // Intel-IA64-Filler
    FLOAT128 FltF86;        // Intel-IA64-Filler
    FLOAT128 FltF87;        // Intel-IA64-Filler
    FLOAT128 FltF88;        // Intel-IA64-Filler
    FLOAT128 FltF89;        // Intel-IA64-Filler

    FLOAT128 FltF90;        // Intel-IA64-Filler
    FLOAT128 FltF91;        // Intel-IA64-Filler
    FLOAT128 FltF92;        // Intel-IA64-Filler
    FLOAT128 FltF93;        // Intel-IA64-Filler
    FLOAT128 FltF94;        // Intel-IA64-Filler
    FLOAT128 FltF95;        // Intel-IA64-Filler
    FLOAT128 FltF96;        // Intel-IA64-Filler
    FLOAT128 FltF97;        // Intel-IA64-Filler
    FLOAT128 FltF98;        // Intel-IA64-Filler
    FLOAT128 FltF99;        // Intel-IA64-Filler

    FLOAT128 FltF100;       // Intel-IA64-Filler
    FLOAT128 FltF101;       // Intel-IA64-Filler
    FLOAT128 FltF102;       // Intel-IA64-Filler
    FLOAT128 FltF103;       // Intel-IA64-Filler
    FLOAT128 FltF104;       // Intel-IA64-Filler
    FLOAT128 FltF105;       // Intel-IA64-Filler
    FLOAT128 FltF106;       // Intel-IA64-Filler
    FLOAT128 FltF107;       // Intel-IA64-Filler
    FLOAT128 FltF108;       // Intel-IA64-Filler
    FLOAT128 FltF109;       // Intel-IA64-Filler

    FLOAT128 FltF110;       // Intel-IA64-Filler
    FLOAT128 FltF111;       // Intel-IA64-Filler
    FLOAT128 FltF112;       // Intel-IA64-Filler
    FLOAT128 FltF113;       // Intel-IA64-Filler
    FLOAT128 FltF114;       // Intel-IA64-Filler
    FLOAT128 FltF115;       // Intel-IA64-Filler
    FLOAT128 FltF116;       // Intel-IA64-Filler
    FLOAT128 FltF117;       // Intel-IA64-Filler
    FLOAT128 FltF118;       // Intel-IA64-Filler
    FLOAT128 FltF119;       // Intel-IA64-Filler

    FLOAT128 FltF120;       // Intel-IA64-Filler
    FLOAT128 FltF121;       // Intel-IA64-Filler
    FLOAT128 FltF122;       // Intel-IA64-Filler
    FLOAT128 FltF123;       // Intel-IA64-Filler
    FLOAT128 FltF124;       // Intel-IA64-Filler
    FLOAT128 FltF125;       // Intel-IA64-Filler
    FLOAT128 FltF126;       // Intel-IA64-Filler
    FLOAT128 FltF127;       // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //

    ULONGLONG StFPSR;       // Intel-IA64-Filler ; FP status

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //

    ULONGLONG IntGp;        // Intel-IA64-Filler ; r1, volatile
    ULONGLONG IntT0;        // Intel-IA64-Filler ; r2-r3, volatile
    ULONGLONG IntT1;        // Intel-IA64-Filler ;
    ULONGLONG IntS0;        // Intel-IA64-Filler ; r4-r7, preserved
    ULONGLONG IntS1;        // Intel-IA64-Filler
    ULONGLONG IntS2;        // Intel-IA64-Filler
    ULONGLONG IntS3;        // Intel-IA64-Filler
    ULONGLONG IntV0;        // Intel-IA64-Filler ; r8, volatile
    ULONGLONG IntT2;        // Intel-IA64-Filler ; r9-r11, volatile
    ULONGLONG IntT3;        // Intel-IA64-Filler
    ULONGLONG IntT4;        // Intel-IA64-Filler
    ULONGLONG IntSp;        // Intel-IA64-Filler ; stack pointer (r12), special
    ULONGLONG IntTeb;       // Intel-IA64-Filler ; teb (r13), special
    ULONGLONG IntT5;        // Intel-IA64-Filler ; r14-r31, volatile
    ULONGLONG IntT6;        // Intel-IA64-Filler
    ULONGLONG IntT7;        // Intel-IA64-Filler
    ULONGLONG IntT8;        // Intel-IA64-Filler
    ULONGLONG IntT9;        // Intel-IA64-Filler
    ULONGLONG IntT10;       // Intel-IA64-Filler
    ULONGLONG IntT11;       // Intel-IA64-Filler
    ULONGLONG IntT12;       // Intel-IA64-Filler
    ULONGLONG IntT13;       // Intel-IA64-Filler
    ULONGLONG IntT14;       // Intel-IA64-Filler
    ULONGLONG IntT15;       // Intel-IA64-Filler
    ULONGLONG IntT16;       // Intel-IA64-Filler
    ULONGLONG IntT17;       // Intel-IA64-Filler
    ULONGLONG IntT18;       // Intel-IA64-Filler
    ULONGLONG IntT19;       // Intel-IA64-Filler
    ULONGLONG IntT20;       // Intel-IA64-Filler
    ULONGLONG IntT21;       // Intel-IA64-Filler
    ULONGLONG IntT22;       // Intel-IA64-Filler

    ULONGLONG IntNats;      // Intel-IA64-Filler ; Nat bits for r1-r31
                            // Intel-IA64-Filler ; r1-r31 in bits 1 thru 31.
    ULONGLONG Preds;        // Intel-IA64-Filler ; predicates, preserved

    ULONGLONG BrRp;         // Intel-IA64-Filler ; return pointer, b0, preserved
    ULONGLONG BrS0;         // Intel-IA64-Filler ; b1-b5, preserved
    ULONGLONG BrS1;         // Intel-IA64-Filler
    ULONGLONG BrS2;         // Intel-IA64-Filler
    ULONGLONG BrS3;         // Intel-IA64-Filler
    ULONGLONG BrS4;         // Intel-IA64-Filler
    ULONGLONG BrT0;         // Intel-IA64-Filler ; b6-b7, volatile
    ULONGLONG BrT1;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers
    ULONGLONG ApUNAT;       // Intel-IA64-Filler ; User Nat collection register, preserved
    ULONGLONG ApLC;         // Intel-IA64-Filler ; Loop counter register, preserved
    ULONGLONG ApEC;         // Intel-IA64-Filler ; Epilog counter register, preserved
    ULONGLONG ApCCV;        // Intel-IA64-Filler ; CMPXCHG value register, volatile
    ULONGLONG ApDCR;        // Intel-IA64-Filler ; Default control register (TBD)

    // Register stack info
    ULONGLONG RsPFS;        // Intel-IA64-Filler ; Previous function state, preserved
    ULONGLONG RsBSP;        // Intel-IA64-Filler ; Backing store pointer, preserved
    ULONGLONG RsBSPSTORE;   // Intel-IA64-Filler
    ULONGLONG RsRSC;        // Intel-IA64-Filler ; RSE configuration, volatile
    ULONGLONG RsRNAT;       // Intel-IA64-Filler ; RSE Nat collection register, preserved

    // Trap Status Information
    ULONGLONG StIPSR;       // Intel-IA64-Filler ; Interruption Processor Status
    ULONGLONG StIIP;        // Intel-IA64-Filler ; Interruption IP
    ULONGLONG StIFS;        // Intel-IA64-Filler ; Interruption Function State

    // iA32 related control registers
    ULONGLONG StFCR;        // Intel-IA64-Filler ; copy of Ar21
    ULONGLONG Eflag;        // Intel-IA64-Filler ; Eflag copy of Ar24
    ULONGLONG SegCSD;       // Intel-IA64-Filler ; iA32 CSDescriptor (Ar25)
    ULONGLONG SegSSD;       // Intel-IA64-Filler ; iA32 SSDescriptor (Ar26)
    ULONGLONG Cflag;        // Intel-IA64-Filler ; Cr0+Cr4 copy of Ar27
    ULONGLONG StFSR;        // Intel-IA64-Filler ; x86 FP status (copy of AR28)
    ULONGLONG StFIR;        // Intel-IA64-Filler ; x86 FP status (copy of AR29)
    ULONGLONG StFDR;        // Intel-IA64-Filler ; x86 FP status (copy of AR30)

      ULONGLONG UNUSEDPACK;   // Intel-IA64-Filler ; added to pack StFDR to 16-bytes

} IA64_CONTEXT, *PIA64_CONTEXT;

//
// Special Registers for AMD64.
//

typedef struct _AMD64_DESCRIPTOR {
    USHORT  Pad[3];
    USHORT  Limit;
    ULONG64 Base;
} AMD64_DESCRIPTOR, *PAMD64_DESCRIPTOR;

typedef struct _AMD64_KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    AMD64_DESCRIPTOR Gdtr;
    AMD64_DESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Cr8;
    ULONG64 MsrGsBase;
    ULONG64 MsrGsSwap;
    ULONG64 MsrStar;
    ULONG64 MsrLStar;
    ULONG64 MsrCStar;
    ULONG64 MsrSyscallMask;
} AMD64_KSPECIAL_REGISTERS, *PAMD64_KSPECIAL_REGISTERS;

typedef struct _AMD64_KSWITCH_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5Home;
    ULONG MxCsr;
    KIRQL ApcBypass;
    UCHAR Fill1[3];
    ULONG64 Rbp;
    ULONG64 Return;
} AMD64_KSWITCH_FRAME, *PAMD64_KSWITCH_FRAME;

//
// Format of data for fnsave/frstor instructions.
//
// This structure is used to store the legacy floating point state.
//

typedef struct _AMD64_LEGACY_SAVE_AREA {
    USHORT ControlWord;
    USHORT Reserved0;
    USHORT StatusWord;
    USHORT Reserved1;
    USHORT TagWord;
    USHORT Reserved2;
    ULONG ErrorOffset;
    USHORT ErrorSelector;
    USHORT ErrorOpcode;
    ULONG DataOffset;
    USHORT DataSelector;
    USHORT Reserved3;
    UCHAR FloatRegisters[8 * 10];
} AMD64_LEGACY_SAVE_AREA, *PAMD64_LEGACY_SAVE_AREA;

typedef struct _AMD64_M128 {
    ULONGLONG Low;
    LONGLONG High;
} AMD64_M128, *PAMD64_M128;

// Must be 16-byte aligned.
typedef struct _AMD64_CONTEXT {

    //
    // Register parameter home addresses.
    //

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5Home;
    ULONG64 P6Home;

    //
    // Control flags.
    //

    ULONG ContextFlags;
    ULONG MxCsr;

    //
    // Segment Registers and processor flags.
    //

    USHORT SegCs;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;
    USHORT SegSs;
    ULONG EFlags;

    //
    // Debug registers
    //

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

    //
    // Integer registers.
    //

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 Rbx;
    ULONG64 Rsp;
    ULONG64 Rbp;
    ULONG64 Rsi;
    ULONG64 Rdi;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

    //
    // Program counter.
    //

    ULONG64 Rip;

    //
    // MMX/floating point state.
    //

    AMD64_M128 Xmm0;
    AMD64_M128 Xmm1;
    AMD64_M128 Xmm2;
    AMD64_M128 Xmm3;
    AMD64_M128 Xmm4;
    AMD64_M128 Xmm5;
    AMD64_M128 Xmm6;
    AMD64_M128 Xmm7;
    AMD64_M128 Xmm8;
    AMD64_M128 Xmm9;
    AMD64_M128 Xmm10;
    AMD64_M128 Xmm11;
    AMD64_M128 Xmm12;
    AMD64_M128 Xmm13;
    AMD64_M128 Xmm14;
    AMD64_M128 Xmm15;

    //
    // Legacy floating point state.
    //

    AMD64_LEGACY_SAVE_AREA FltSave;
    ULONG Fill;

    //
    // Special debug control registers.
    //

    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Fill1;
} AMD64_CONTEXT, *PAMD64_CONTEXT;

typedef struct _ARM_CONTEXT {
    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    ULONG R0;
    ULONG R1;
    ULONG R2;
    ULONG R3;
    ULONG R4;
    ULONG R5;
    ULONG R6;
    ULONG R7;
    ULONG R8;
    ULONG R9;
    ULONG R10;
    ULONG R11;
    ULONG R12;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    ULONG Sp;
    ULONG Lr;
    ULONG Pc;
    ULONG Psr;
} ARM_CONTEXT, *PARM_CONTEXT;


typedef struct _CROSS_PLATFORM_CONTEXT {

    union {
        X86_CONTEXT       X86Context;
        X86_NT5_CONTEXT   X86Nt5Context;
        ALPHA_CONTEXT     AlphaContext;
        ALPHA_NT5_CONTEXT AlphaNt5Context;
        IA64_CONTEXT      IA64Context;
        AMD64_CONTEXT     Amd64Context;
        ARM_CONTEXT       ArmContext;
    };

} CROSS_PLATFORM_CONTEXT, *PCROSS_PLATFORM_CONTEXT;


typedef struct _CROSS_PLATFORM_KSPECIAL_REGISTERS {

    union {
        X86_KSPECIAL_REGISTERS   X86Special;
        IA64_KSPECIAL_REGISTERS  IA64Special;
        AMD64_KSPECIAL_REGISTERS Amd64Special;
    };

} CROSS_PLATFORM_KSPECIAL_REGISTERS, *PCROSS_PLATFORM_KSPECIAL_REGISTERS;


typedef struct _X86_KPROCESSOR_STATE {
    struct _X86_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_KPROCESSOR_STATE, *PX86_KPROCESSOR_STATE;

typedef struct _X86_NT5_KPROCESSOR_STATE {
    struct _X86_NT5_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_NT5_KPROCESSOR_STATE, *PX86_NT5_KPROCESSOR_STATE;

typedef struct _ALPHA_NT5_KPROCESSOR_STATE {
    struct _ALPHA_NT5_CONTEXT ContextFrame;
} ALPHA_NT5_KPROCESSOR_STATE, *PALPHA_NT5_KPROCESSOR_STATE;

typedef struct _IA64_KPROCESSOR_STATE {
    struct _IA64_CONTEXT ContextFrame;
    struct _IA64_KSPECIAL_REGISTERS SpecialRegisters;
} IA64_KPROCESSOR_STATE, *PIA64_KPROCESSOR_STATE;

typedef struct _AMD64_KPROCESSOR_STATE {
    struct _AMD64_KSPECIAL_REGISTERS SpecialRegisters;
    ULONG64 Fill;
    struct _AMD64_CONTEXT ContextFrame;
} AMD64_KPROCESSOR_STATE, *PAMD64_KPROCESSOR_STATE;


typedef struct _X86_FIBER {

    ULONG FiberData;

    //
    // Matches first three DWORDs of TEB
    //

    ULONG ExceptionList;
    ULONG StackBase;
    ULONG StackLimit;

    //
    // Used by base to free a thread's stack
    //

    ULONG DeallocationStack;

    X86_NT5_CONTEXT FiberContext;

    ULONG Wx86Tib;

} X86_FIBER, *PX86_FIBER;

typedef struct _IA64_FIBER {

    ULONG64 FiberData;

    //
    // Matches first three DWORDs of TEB
    //

    ULONG64 ExceptionList;
    ULONG64 StackBase;
    ULONG64 StackLimit;

    //
    // Used by base to free a thread's stack
    //

    ULONG64 DeallocationStack;

    IA64_CONTEXT FiberContext;

    ULONG64 Wx86Tib;

    ULONG64 DeallocationBStore;
    ULONG64 BStoreLimit;

} IA64_FIBER, *PIA64_FIBER;

typedef struct _AMD64_FIBER {

    ULONG64 FiberData;

    //
    // Matches first three DWORDs of TEB
    //

    ULONG64 ExceptionList;
    ULONG64 StackBase;
    ULONG64 StackLimit;

    //
    // Used by base to free a thread's stack
    //

    ULONG64 DeallocationStack;

    AMD64_CONTEXT FiberContext;

    ULONG64 Wx86Tib;

} AMD64_FIBER, *PAMD64_FIBER;

typedef struct _CROSS_PLATFORM_FIBER {

    union {
        X86_FIBER   X86Fiber;
        IA64_FIBER  IA64Fiber;
        AMD64_FIBER Amd64Fiber;
    };

} CROSS_PLATFORM_FIBER, *PCROSS_PLATFORM_FIBER;


#define DBGKD_MAXSTREAM 16

typedef struct _X86_DBGKD_CONTROL_REPORT {
    ULONG   Dr6;
    ULONG   Dr7;
    USHORT  InstructionCount;
    USHORT  ReportFlags;
    UCHAR   InstructionStream[DBGKD_MAXSTREAM];
    USHORT  SegCs;
    USHORT  SegDs;
    USHORT  SegEs;
    USHORT  SegFs;
    ULONG   EFlags;
} X86_DBGKD_CONTROL_REPORT, *PX86_DBGKD_CONTROL_REPORT;

#define X86_REPORT_INCLUDES_SEGS    0x0001
// Indicates the current CS is a standard 32-bit flat segment.
// This allows the debugger to avoid retrieving the
// CS descriptor to see if it's 16-bit code or not.
// Note that the V86 flag in EFlags must also be checked
// when determining the code type.
#define X86_REPORT_STANDARD_CS      0x0002

typedef struct _ALPHA_DBGKD_CONTROL_REPORT {
    ULONG InstructionCount;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
} ALPHA_DBGKD_CONTROL_REPORT, *PALPHA_DBGKD_CONTROL_REPORT;

typedef struct _IA64_DBGKD_CONTROL_REPORT {
    ULONG InstructionCount;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
} IA64_DBGKD_CONTROL_REPORT, *PIA64_DBGKD_CONTROL_REPORT;

typedef struct _AMD64_DBGKD_CONTROL_REPORT {
    ULONG64 Dr6;
    ULONG64 Dr7;
    ULONG EFlags;
    USHORT InstructionCount;
    USHORT ReportFlags;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
    USHORT SegCs;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
} AMD64_DBGKD_CONTROL_REPORT, *PAMD64_DBGKD_CONTROL_REPORT;

#define AMD64_REPORT_INCLUDES_SEGS    0x0001
// Indicates the current CS is a standard 64-bit flat segment.
// This allows the debugger to avoid retrieving the
// CS descriptor to see if it's 16- or 32-bit code or not.
// Note that the V86 flag in EFlags must also be checked
// when determining the code type.
#define AMD64_REPORT_STANDARD_CS      0x0002

typedef struct _DBGKD_ANY_CONTROL_REPORT
{
    union
    {
        X86_DBGKD_CONTROL_REPORT X86ControlReport;
        ALPHA_DBGKD_CONTROL_REPORT AlphaControlReport;
        IA64_DBGKD_CONTROL_REPORT IA64ControlReport;
        AMD64_DBGKD_CONTROL_REPORT Amd64ControlReport;
    };
} DBGKD_ANY_CONTROL_REPORT, *PDBGKD_ANY_CONTROL_REPORT;

// DBGKD_ANY_CONTROL_SET is 32-bit packed with an NTSTATUS in
// DBGKD_CONTINUE2 so start with a 32-bit value to get the 64-bit
// values aligned.

#include <pshpack4.h>

typedef struct _X86_DBGKD_CONTROL_SET {
    ULONG   TraceFlag;
    ULONG   Dr7;
    ULONG   CurrentSymbolStart;
    ULONG   CurrentSymbolEnd;
} X86_DBGKD_CONTROL_SET, *PX86_DBGKD_CONTROL_SET;

typedef ULONG ALPHA_DBGKD_CONTROL_SET, *PALPHA_DBGKD_CONTROL_SET;

#define IA64_DBGKD_CONTROL_SET_CONTINUE_NONE                0x0000
#define IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_INSTRUCTION   0x0001
#define IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_TAKEN_BRANCH  0x0002

typedef struct _IA64_DBGKD_CONTROL_SET {
    ULONG   Continue;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} IA64_DBGKD_CONTROL_SET, *PIA64_DBGKD_CONTROL_SET;

typedef struct _AMD64_DBGKD_CONTROL_SET {
    ULONG   TraceFlag;
    ULONG64 Dr7;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} AMD64_DBGKD_CONTROL_SET, *PAMD64_DBGKD_CONTROL_SET;

typedef struct _DBGKD_ANY_CONTROL_SET
{
    union
    {
        X86_DBGKD_CONTROL_SET X86ControlSet;
        ALPHA_DBGKD_CONTROL_SET AlphaControlSet;
        IA64_DBGKD_CONTROL_SET IA64ControlSet;
        AMD64_DBGKD_CONTROL_SET Amd64ControlSet;
    };
} DBGKD_ANY_CONTROL_SET, *PDBGKD_ANY_CONTROL_SET;

#include <poppack.h>

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC32 {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY32 DpcListEntry;
    ULONG DeferredRoutine;
    ULONG DeferredContext;
    ULONG SystemArgument1;
    ULONG SystemArgument2;
    ULONG Lock;
} KDPC32;

typedef struct _KDPC64 {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY64 DpcListEntry;
    ULONG64 DeferredRoutine;
    ULONG64 DeferredContext;
    ULONG64 SystemArgument1;
    ULONG64 SystemArgument2;
    ULONG64 Lock;
} KDPC64;

#define X86_MAX_RING 3

typedef struct _X86_KTSS {
    // Intel's TSS format
    ULONG   Previous;
    struct
    {
        ULONG   Esp;
        ULONG   Ss;
    } Ring[X86_MAX_RING];
    ULONG   Cr3;
    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;
    ULONG   Es;
    ULONG   Cs;
    ULONG   Ss;
    ULONG   Ds;
    ULONG   Fs;
    ULONG   Gs;
    ULONG   Ldt;
    USHORT  T;
    USHORT  IoMapBase;
} X86_KTSS, *PX86_KTSS;

//
//  LDT descriptor entry
//

typedef struct _X86_LDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} X86_LDT_ENTRY, *PX86_LDT_ENTRY;

typedef struct _X86_DESCRIPTOR_TABLE_ENTRY {
    ULONG Selector;
    X86_LDT_ENTRY Descriptor;
} X86_DESCRIPTOR_TABLE_ENTRY, *PX86_DESCRIPTOR_TABLE_ENTRY;

typedef struct _X86_KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    ULONG   ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} X86_KTRAP_FRAME, *PX86_KTRAP_FRAME;


typedef struct _AMD64_KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    CCHAR PreviousMode;
    KIRQL PreviousIrql;

//
// Page fault load/store indicator.
//

    UCHAR FaultIndicator;
    UCHAR Fill0;

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 Spare0;

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    AMD64_M128 Xmm0;
    AMD64_M128 Xmm1;
    AMD64_M128 Xmm2;
    AMD64_M128 Xmm3;
    AMD64_M128 Xmm4;
    AMD64_M128 Xmm5;

//
// Page fault address.
//

    ULONG64 FaultAddress;

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
// Special debug registers.
//

    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    ULONG64 ErrorCode;
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} AMD64_KTRAP_FRAME, *PAMD64_KTRAP_FRAME;


typedef struct _IA64_KNONVOLATILE_CONTEXT_POINTERS {
    PFLOAT128  FltS0;                       // Intel-IA64-Filler
    PFLOAT128  FltS1;                       // Intel-IA64-Filler
    PFLOAT128  FltS2;                       // Intel-IA64-Filler
    PFLOAT128  FltS3;                       // Intel-IA64-Filler
    PFLOAT128  HighFloatingContext[10];     // Intel-IA64-Filler
    PFLOAT128  FltS4;                       // Intel-IA64-Filler
    PFLOAT128  FltS5;                       // Intel-IA64-Filler
    PFLOAT128  FltS6;                       // Intel-IA64-Filler
    PFLOAT128  FltS7;                       // Intel-IA64-Filler
    PFLOAT128  FltS8;                       // Intel-IA64-Filler
    PFLOAT128  FltS9;                       // Intel-IA64-Filler
    PFLOAT128  FltS10;                      // Intel-IA64-Filler
    PFLOAT128  FltS11;                      // Intel-IA64-Filler
    PFLOAT128  FltS12;                      // Intel-IA64-Filler
    PFLOAT128  FltS13;                      // Intel-IA64-Filler
    PFLOAT128  FltS14;                      // Intel-IA64-Filler
    PFLOAT128  FltS15;                      // Intel-IA64-Filler
    PFLOAT128  FltS16;                      // Intel-IA64-Filler
    PFLOAT128  FltS17;                      // Intel-IA64-Filler
    PFLOAT128  FltS18;                      // Intel-IA64-Filler
    PFLOAT128  FltS19;                      // Intel-IA64-Filler

    PULONGLONG IntS0;                       // Intel-IA64-Filler
    PULONGLONG IntS1;                       // Intel-IA64-Filler
    PULONGLONG IntS2;                       // Intel-IA64-Filler
    PULONGLONG IntS3;                       // Intel-IA64-Filler
    PULONGLONG IntSp;                       // Intel-IA64-Filler
    PULONGLONG IntS0Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS1Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS2Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS3Nat;                    // Intel-IA64-Filler
    PULONGLONG IntSpNat;                    // Intel-IA64-Filler

    PULONGLONG Preds;                       // Intel-IA64-Filler

    PULONGLONG BrRp;                        // Intel-IA64-Filler
    PULONGLONG BrS0;                        // Intel-IA64-Filler
    PULONGLONG BrS1;                        // Intel-IA64-Filler
    PULONGLONG BrS2;                        // Intel-IA64-Filler
    PULONGLONG BrS3;                        // Intel-IA64-Filler
    PULONGLONG BrS4;                        // Intel-IA64-Filler

    PULONGLONG ApUNAT;                      // Intel-IA64-Filler
    PULONGLONG ApLC;                        // Intel-IA64-Filler
    PULONGLONG ApEC;                        // Intel-IA64-Filler
    PULONGLONG RsPFS;                       // Intel-IA64-Filler

    PULONGLONG StFSR;                       // Intel-IA64-Filler
    PULONGLONG StFIR;                       // Intel-IA64-Filler
    PULONGLONG StFDR;                       // Intel-IA64-Filler
    PULONGLONG Cflag;                       // Intel-IA64-Filler

} IA64_KNONVOLATILE_CONTEXT_POINTERS, *PIA64_KNONVOLATILE_CONTEXT_POINTERS;

typedef struct _IA64_KEXCEPTION_FRAME {

    // Preserved application registers // Intel-IA64-Filler
    ULONGLONG ApEC;       // epilogue count // Intel-IA64-Filler
    ULONGLONG ApLC;       // loop count // Intel-IA64-Filler
    ULONGLONG IntNats;    // Nats for S0-S3; i.e. ar.UNAT after spill // Intel-IA64-Filler

    // Preserved (saved) interger registers, s0-s3 // Intel-IA64-Filler
    ULONGLONG IntS0; // Intel-IA64-Filler
    ULONGLONG IntS1; // Intel-IA64-Filler
    ULONGLONG IntS2; // Intel-IA64-Filler
    ULONGLONG IntS3; // Intel-IA64-Filler

    // Preserved (saved) branch registers, bs0-bs4 // Intel-IA64-Filler
    ULONGLONG BrS0; // Intel-IA64-Filler
    ULONGLONG BrS1; // Intel-IA64-Filler
    ULONGLONG BrS2; // Intel-IA64-Filler
    ULONGLONG BrS3; // Intel-IA64-Filler
    ULONGLONG BrS4; // Intel-IA64-Filler

    // Preserved (saved) floating point registers, f2 - f5, f16 - f31 // Intel-IA64-Filler
    FLOAT128 FltS0; // Intel-IA64-Filler
    FLOAT128 FltS1; // Intel-IA64-Filler
    FLOAT128 FltS2; // Intel-IA64-Filler
    FLOAT128 FltS3; // Intel-IA64-Filler
    FLOAT128 FltS4; // Intel-IA64-Filler
    FLOAT128 FltS5; // Intel-IA64-Filler
    FLOAT128 FltS6; // Intel-IA64-Filler
    FLOAT128 FltS7; // Intel-IA64-Filler
    FLOAT128 FltS8; // Intel-IA64-Filler
    FLOAT128 FltS9; // Intel-IA64-Filler
    FLOAT128 FltS10; // Intel-IA64-Filler
    FLOAT128 FltS11; // Intel-IA64-Filler
    FLOAT128 FltS12; // Intel-IA64-Filler
    FLOAT128 FltS13; // Intel-IA64-Filler
    FLOAT128 FltS14; // Intel-IA64-Filler
    FLOAT128 FltS15; // Intel-IA64-Filler
    FLOAT128 FltS16; // Intel-IA64-Filler
    FLOAT128 FltS17; // Intel-IA64-Filler
    FLOAT128 FltS18; // Intel-IA64-Filler
    FLOAT128 FltS19; // Intel-IA64-Filler

} IA64_KEXCEPTION_FRAME, *PIA64_KEXCEPTION_FRAME;

typedef struct _IA64_KSWITCH_FRAME { // Intel-IA64-Filler

    ULONGLONG SwitchPredicates; // Predicates for Switch // Intel-IA64-Filler
    ULONGLONG SwitchRp;         // return pointer for Switch // Intel-IA64-Filler
    ULONGLONG SwitchPFS;        // PFS for Switch // Intel-IA64-Filler
    ULONGLONG SwitchFPSR;   // ProcessorFP status at thread switch // Intel-IA64-Filler
    ULONGLONG SwitchBsp;                     // Intel-IA64-Filler
    ULONGLONG SwitchRnat;                     // Intel-IA64-Filler
    // ULONGLONG Pad;

    IA64_KEXCEPTION_FRAME SwitchExceptionFrame; // Intel-IA64-Filler

} IA64_KSWITCH_FRAME, *PIA64_KSWITCH_FRAME; // Intel-IA64-Filler

#define IA64_KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args // Intel-IA64-Filler

typedef struct _IA64_KTRAP_FRAME {

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //

    ULONGLONG Reserved[(IA64_KTRAP_FRAME_ARGUMENTS+16)/8]; // Intel-IA64-Filler

    // Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel) // Intel-IA64-Filler
    FLOAT128 FltT0; // Intel-IA64-Filler
    FLOAT128 FltT1; // Intel-IA64-Filler
    FLOAT128 FltT2; // Intel-IA64-Filler
    FLOAT128 FltT3; // Intel-IA64-Filler
    FLOAT128 FltT4; // Intel-IA64-Filler
    FLOAT128 FltT5; // Intel-IA64-Filler
    FLOAT128 FltT6; // Intel-IA64-Filler
    FLOAT128 FltT7; // Intel-IA64-Filler
    FLOAT128 FltT8; // Intel-IA64-Filler
    FLOAT128 FltT9; // Intel-IA64-Filler

    // Temporary (volatile) interger registers
    ULONGLONG IntGp;    // global pointer (r1) // Intel-IA64-Filler
    ULONGLONG IntT0; // Intel-IA64-Filler
    ULONGLONG IntT1; // Intel-IA64-Filler
                        // The following 4 registers fill in space of preserved  (S0-S3) to align Nats // Intel-IA64-Filler
    ULONGLONG ApUNAT;   // ar.UNAT on kernel entry // Intel-IA64-Filler
    ULONGLONG ApCCV;    // ar.CCV // Intel-IA64-Filler
    ULONGLONG ApDCR;    // DCR register on kernel entry // Intel-IA64-Filler
    ULONGLONG Preds;    // Predicates // Intel-IA64-Filler

    ULONGLONG IntV0;    // return value (r8) // Intel-IA64-Filler
    ULONGLONG IntT2; // Intel-IA64-Filler
    ULONGLONG IntT3; // Intel-IA64-Filler
    ULONGLONG IntT4; // Intel-IA64-Filler
    ULONGLONG IntSp;    // stack pointer (r12) // Intel-IA64-Filler
    ULONGLONG IntTeb;   // teb (r13) // Intel-IA64-Filler
    ULONGLONG IntT5; // Intel-IA64-Filler
    ULONGLONG IntT6; // Intel-IA64-Filler
    ULONGLONG IntT7; // Intel-IA64-Filler
    ULONGLONG IntT8; // Intel-IA64-Filler
    ULONGLONG IntT9; // Intel-IA64-Filler
    ULONGLONG IntT10; // Intel-IA64-Filler
    ULONGLONG IntT11; // Intel-IA64-Filler
    ULONGLONG IntT12; // Intel-IA64-Filler
    ULONGLONG IntT13; // Intel-IA64-Filler
    ULONGLONG IntT14; // Intel-IA64-Filler
    ULONGLONG IntT15; // Intel-IA64-Filler
    ULONGLONG IntT16; // Intel-IA64-Filler
    ULONGLONG IntT17; // Intel-IA64-Filler
    ULONGLONG IntT18; // Intel-IA64-Filler
    ULONGLONG IntT19; // Intel-IA64-Filler
    ULONGLONG IntT20; // Intel-IA64-Filler
    ULONGLONG IntT21; // Intel-IA64-Filler
    ULONGLONG IntT22; // Intel-IA64-Filler

    ULONGLONG IntNats;  // Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill // Intel-IA64-Filler

    ULONGLONG BrRp;     // Return pointer on kernel entry // Intel-IA64-Filler

    ULONGLONG BrT0;     // Temporary (volatile) branch registers (b6-b7) // Intel-IA64-Filler
    ULONGLONG BrT1; // Intel-IA64-Filler

    // Register stack info // Intel-IA64-Filler
    ULONGLONG RsRSC;    // RSC on kernel entry // Intel-IA64-Filler
    ULONGLONG RsBSP;    // BSP on kernel entry // Intel-IA64-Filler
    ULONGLONG RsBSPSTORE; // User BSP Store at point of switch to kernel backing store // Intel-IA64-Filler
    ULONGLONG RsRNAT;   // old RNAT at point of switch to kernel backing store // Intel-IA64-Filler
    ULONGLONG RsPFS;    // PFS on kernel entry // Intel-IA64-Filler

    // Trap Status Information // Intel-IA64-Filler
    ULONGLONG StIPSR;   // Interruption Processor Status Register // Intel-IA64-Filler
    ULONGLONG StIIP;    // Interruption IP // Intel-IA64-Filler
    ULONGLONG StIFS;    // Interruption Function State // Intel-IA64-Filler
    ULONGLONG StFPSR;   // FP status // Intel-IA64-Filler
    ULONGLONG StISR;    // Interruption Status Register // Intel-IA64-Filler
    ULONGLONG StIFA;    // Interruption Data Address // Intel-IA64-Filler
    ULONGLONG StIIPA;   // Last executed bundle address // Intel-IA64-Filler
    ULONGLONG StIIM;    // Interruption Immediate // Intel-IA64-Filler
    ULONGLONG StIHA;    // Interruption Hash Address // Intel-IA64-Filler

    ULONG OldIrql;      // Previous Irql. // Intel-IA64-Filler
    ULONG PreviousMode; // Previous Mode. // Intel-IA64-Filler
    ULONGLONG TrapFrame;// Previous Trap Frame // Intel-IA64-Filler

    // Exception record
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD64) + 15) & (~15)];

    // End of frame marker (for debugging)
    ULONGLONG Handler;  // Handler for this trap
    ULONGLONG EOFMarker;
} IA64_KTRAP_FRAME, *PIA64_KTRAP_FRAME;

typedef struct _IA64_UNWIND_INFO {     // Intel-IA64-Filler
    USHORT Version;               // Intel-IA64-Filler ; Version Number
    USHORT Flags;                 // Intel-IA64-Filler ; Flags
    ULONG DataLength;             // Intel-IA64-Filler ; Length of Descriptor Data
} IA64_UNWIND_INFO, *PIA64_UNWIND_INFO;     // Intel-IA64-Filler

//
// Define unwind operation codes.
//

typedef enum _AMD64_UNWIND_OP_CODES {
    AMD64_UWOP_PUSH_NONVOL = 0,
    AMD64_UWOP_ALLOC_LARGE,
    AMD64_UWOP_ALLOC_SMALL,
    AMD64_UWOP_SET_FPREG,
    AMD64_UWOP_SAVE_NONVOL,
    AMD64_UWOP_SAVE_NONVOL_FAR,
    AMD64_UWOP_SAVE_XMM,
    AMD64_UWOP_SAVE_XMM_FAR,
    AMD64_UWOP_SAVE_XMM128,
    AMD64_UWOP_SAVE_XMM128_FAR,
    AMD64_UWOP_PUSH_MACHFRAME
} AMD64_UNWIND_OP_CODES, *PAMD64_UNWIND_OP_CODES;

//
// Define unwind code structure.
//

typedef union _AMD64_UNWIND_CODE {
    struct {
        UCHAR CodeOffset;
        UCHAR UnwindOp : 4;
        UCHAR OpInfo : 4;
    };

    USHORT FrameOffset;
} AMD64_UNWIND_CODE, *PAMD64_UNWIND_CODE;

//
// Define unwind information flags.
//

#define AMD64_UNW_FLAG_NHANDLER 0x0
#define AMD64_UNW_FLAG_EHANDLER 0x1
#define AMD64_UNW_FLAG_UHANDLER 0x2
#define AMD64_UNW_FLAG_CHAININFO 0x4

//
// Define unwind information structure.
//

typedef struct _AMD64_UNWIND_INFO {
    UCHAR Version : 3;
    UCHAR Flags : 5;
    UCHAR SizeOfProlog;
    UCHAR CountOfCodes;
    UCHAR FrameRegister : 4;
    UCHAR FrameOffset : 4;
    AMD64_UNWIND_CODE UnwindCode[1];

//
// The unwind codes are followed by an optional DWORD aligned field that
// contains the exception handler address or the address of chained unwind
// information. If an exception handler address is specified, then it is
// followed by the language specified exception handler data.
//
//  union {
//      ULONG ExceptionHandler;
//      ULONG FunctionEntry;
//  };
//
//  ULONG ExceptionData[];
//

} AMD64_UNWIND_INFO, *PAMD64_UNWIND_INFO;

#define IA64_IP_SLOT 2                         // Intel-IA64-Filler
#define Ia64InsertIPSlotNumber(IP, SlotNumber) /* Intel-IA64-Filler */  \
                ((IP) | (SlotNumber << IA64_IP_SLOT))  // Intel-IA64-Filler

#define IA64_MM_EPC_VA          0xe0000000ffa00000
#define IA64_STACK_SCRATCH_AREA 16
#define IA64_SYSCALL_FRAME      0
#define IA64_INTERRUPT_FRAME    1
#define IA64_EXCEPTION_FRAME    2
#define IA64_CONTEXT_FRAME      10

#define IA64_IFS_IFM        0
#define IA64_IFS_IFM_LEN    38
#define IA64_IFS_MBZ0       38
#define IA64_IFS_MBZ0_V     0x1ffffffi64
#define IA64_IFS_V          63
#define IA64_IFS_V_LEN      1
#define IA64_PFS_EC_SHIFT             52
#define IA64_PFS_EC_SIZE              6
#define IA64_PFS_EC_MASK              0x3F
#define IA64_PFS_SIZE_SHIFT           7
#define IA64_PFS_SIZE_MASK            0x7F
#define IA64_NAT_BITS_PER_RNAT_REG    63
#define IA64_RNAT_ALIGNMENT           (IA64_NAT_BITS_PER_RNAT_REG << 3)
#define IA64_FM_RRB_PR(Fm)  (((Fm) >> 32) & 0x3f)
#define IA64_FM_RRB_FR(Fm)  (((Fm) >> 25) & 0x7f)
#define IA64_FM_RRB_GR(Fm)  (((Fm) >> 18) & 0x7f)
#define IA64_FM_SOR(Fm)     (((Fm) >> 14) & 0xf)
#define IA64_FM_SOF(Fm)     ((Fm) & 0x7f)
#define IA64_FM_FROM_FS(Fs) \
    (((Fs) >> IA64_IFS_IFM) & ((1UI64 << IA64_IFS_IFM_LEN) - 1))

#define IA64_BREAK_DEBUG_BASE    0x080000
#define IA64_BREAK_SYSCALL_BASE  0x180000
#define IA64_BREAK_FASTSYS_BASE  0x1C0000
#define IA64_DEBUG_STOP_BREAKPOINT (IA64_BREAK_DEBUG_BASE+22)


#define ALPHA_PSR_USER_MODE 0x1
#define ALPHA_PSR_MODE 0x0              // Mode bit in PSR (bit 0)
#define ALPHA_PSR_MODE_MASK 0x1         // Mask (1 bit) for mode in PSR
#define ALPHA_PSR_IE 0x1                // Interrupt Enable bit in PSR (bit 1)
#define ALPHA_PSR_IE_MASK 0x1           // Mask (1 bit) for IE in PSR
#define ALPHA_PSR_IRQL 0x2              // IRQL in PSR (bit 2)
#define ALPHA_PSR_IRQL_MASK 0x7         // Mask (2 bits) for IRQL in PSR


#define X86_CONTEXT_X86               0x00010000

#define ALPHA_CONTEXT_ALPHA           0x00020000
#define ALPHA_CONTEXT_CONTROL         (ALPHA_CONTEXT_ALPHA | 0x00000001L)
#define ALPHA_CONTEXT_FLOATING_POINT  (ALPHA_CONTEXT_ALPHA | 0x00000002L)
#define ALPHA_CONTEXT_INTEGER         (ALPHA_CONTEXT_ALPHA | 0x00000004L)
#define ALPHA_CONTEXT_FULL \
    (ALPHA_CONTEXT_CONTROL | ALPHA_CONTEXT_FLOATING_POINT | \
     ALPHA_CONTEXT_INTEGER)

#define IA64_CONTEXT_IA64                  0x00080000
#define IA64_CONTEXT_CONTROL               (IA64_CONTEXT_IA64 | 0x00000001L)
#define IA64_CONTEXT_LOWER_FLOATING_POINT  (IA64_CONTEXT_IA64 | 0x00000002L)
#define IA64_CONTEXT_HIGHER_FLOATING_POINT (IA64_CONTEXT_IA64 | 0x00000004L)
#define IA64_CONTEXT_INTEGER               (IA64_CONTEXT_IA64 | 0x00000008L)
#define IA64_CONTEXT_DEBUG                 (IA64_CONTEXT_IA64 | 0x00000010L)
#define IA64_CONTEXT_IA32_CONTROL          (IA64_CONTEXT_IA64 | 0x00000020L)
#define IA64_CONTEXT_FLOATING_POINT \
    (IA64_CONTEXT_LOWER_FLOATING_POINT | IA64_CONTEXT_HIGHER_FLOATING_POINT)
#define IA64_CONTEXT_FULL \
    (IA64_CONTEXT_CONTROL | IA64_CONTEXT_FLOATING_POINT | IA64_CONTEXT_INTEGER | IA64_CONTEXT_IA32_CONTROL)

#define AMD64_CONTEXT_AMD64             0x00100000
#define AMD64_CONTEXT_CONTROL           (AMD64_CONTEXT_AMD64 | 0x1L)
#define AMD64_CONTEXT_INTEGER           (AMD64_CONTEXT_AMD64 | 0x2L)
#define AMD64_CONTEXT_SEGMENTS          (AMD64_CONTEXT_AMD64 | 0x4L)
#define AMD64_CONTEXT_FLOATING_POINT    (AMD64_CONTEXT_AMD64 | 0x8L)
#define AMD64_CONTEXT_DEBUG_REGISTERS   (AMD64_CONTEXT_AMD64 | 0x10L)
#define AMD64_CONTEXT_FULL \
    (AMD64_CONTEXT_CONTROL | AMD64_CONTEXT_INTEGER | AMD64_CONTEXT_FLOATING_POINT)

#define ARM_CONTEXT_ARM		    0x0000040
#define ARM_CONTEXT_CONTROL         (ARM_CONTEXT_ARM | 0x00000001L)
#define ARM_CONTEXT_INTEGER         (ARM_CONTEXT_ARM | 0x00000002L)

#define ARM_CONTEXT_FULL (ARM_CONTEXT_CONTROL | ARM_CONTEXT_INTEGER)


#define  X86_NT4_KPRCB_SIZE 0x9F0
#define  X86_NT5_KPRCB_SIZE 0x9F0
#define X86_NT51_KPRCB_SIZE 0xC50
#define     IA64_KPRCB_SIZE 0x1A40

#define DEF_KPRCB_CURRENT_THREAD_OFFSET_32 4
#define DEF_KPRCB_CURRENT_THREAD_OFFSET_64 8

#define X86_KPRCB_CPU_TYPE 0x18
#define IA64_KPRCB_PROCESSOR_MODEL 0x50

#define X86_1387_KPRCB_VENDOR_STRING  0x52D
#define X86_2087_KPRCB_VENDOR_STRING  0x72D
#define X86_2251_KPRCB_VENDOR_STRING  0x8AD
#define X86_2474_KPRCB_VENDOR_STRING  0x900
#define X86_VENDOR_STRING_SIZE           13
#define IA64_KPRCB_VENDOR_STRING      0x70

#define X86_1381_KPRCB_MHZ     0x53c
#define X86_2195_KPRCB_MHZ     0x73c
#define X86_2462_KPRCB_MHZ     0x8bc
#define X86_2505_KPRCB_MHZ     0x910
#define IA64_2462_KPRCB_MHZ    0x1728

#define X86_KPRCB_NUMBER   0x10
#define IA64_KPRCB_NUMBER  0x20
#define AMD64_KPRCB_NUMBER 4

#define X86_KPRCB_DPC_ROUTINE_ACTIVE 0x874

#define IA64_KPRCB_PCR_PAGE 0x38

#define X86_KPRCB_CONTEXT   0x1c
#define IA64_KPRCB_CONTEXT  0x190
#define AMD64_KPRCB_CONTEXT 0x120

#define X86_KPRCB_SPECIAL_REG   0x2e8
#define IA64_KPRCB_SPECIAL_REG  0xc00
#define AMD64_KPRCB_SPECIAL_REG 0x40

#define X86_1381_KPCR_SIZE 0x7f0
#define X86_2195_KPCR_SIZE 0xb10
#define X86_KPCR_SIZE      0xd70
#define IA64_KPCR_SIZE     0xe28
#define AMD64_KPCR_SIZE    0x12e0

#define X86_KPCR_SELF_PCR  0x1c
#define AMD64_KPCR_SELF    0x18

#define X86_KPCR_PRCB           0x20
#define IA64_KPCR_PRCB          0xb18
#define AMD64_KPCR_CURRENT_PRCB 0x38

#define X86_KPCR_PRCB_DATA 0x120
#define AMD64_KPCR_PRCB    0x180

#define AMD64_KPCR_KD_VERSION_BLOCK 0x108

#define IA64_KPCR_INITIAL_BSTORE 0xb68
#define IA64_KPCR_BSTORE_LIMIT   0xb78
#define IA64_KPCR_INITIAL_STACK  0xb60
#define IA64_KPCR_STACK_LIMIT    0xb70

#define    X86_NT5_EPROCESS_SIZE 0x288
#define   X86_NT51_EPROCESS_SIZE 0x258
#define  X86_NT511_EPROCESS_SIZE 0x278
#define       IA64_EPROCESS_SIZE 0x410

#define        X86_PEB_IN_EPROCESS 0x1B0
#define    X86_NT4_PEB_IN_EPROCESS 0x18C
#define       IA64_PEB_IN_EPROCESS 0x2D0
#define  IA64_3555_PEB_IN_EPROCESS 0x300

#define        X86_PCID_IN_EPROCESS 0x14C
#define    X86_NT4_PCID_IN_EPROCESS 0x1A4
#define       IA64_PCID_IN_EPROCESS 0x260

#define  IA64_DIRECTORY_TABLE_BASE_IN_EPROCESS 40
#define   X86_DIRECTORY_TABLE_BASE_IN_EPROCESS 24

#define       X86_ETHREAD_SIZE  0x258
#define  X86_NT51_ETHREAD_SIZE  0x260
#define      IA64_ETHREAD_SIZE  0x458
#define IA64_3555_ETHREAD_SIZE  0x440

#define       X86_KTHREAD_NEXTPROCESSOR_OFFSET 0x11f
#define  X86_2230_KTHREAD_NEXTPROCESSOR_OFFSET 0x123
#define  X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET 0x12b
#define  X86_3555_KTHREAD_NEXTPROCESSOR_OFFSET 0x107
#define      IA64_KTHREAD_NEXTPROCESSOR_OFFSET 0x23b
#define IA64_3555_KTHREAD_NEXTPROCESSOR_OFFSET 0x1F7

#define       X86_KTHREAD_TEB_OFFSET 0x020
#define  X86_3555_KTHREAD_TEB_OFFSET 0x02C
#define      IA64_KTHREAD_TEB_OFFSET 0x050
#define IA64_3555_KTHREAD_TEB_OFFSET 0x068

#define       X86_KTHREAD_INITSTACK_OFFSET 0x018
#define      IA64_KTHREAD_INITSTACK_OFFSET 0x028

#define       X86_KTHREAD_KERNELSTACK_OFFSET  0x028
#define  X86_3555_KTHREAD_KERNELSTACK_OFFSET  0x020
#define      IA64_KTHREAD_KERNELSTACK_OFFSET  0x060
#define IA64_3555_KTHREAD_KERNELSTACK_OFFSET  0x038

#define       X86_KTHREAD_APCPROCESS_OFFSET   0x044
#define  X86_3555_KTHREAD_APCPROCESS_OFFSET   0x040
#define      IA64_KTHREAD_APCPROCESS_OFFSET   0x098
#define IA64_3555_KTHREAD_APCPROCESS_OFFSET   0x090

#define       X86_KTHREAD_STATE_OFFSET  0x02d
#define  X86_3555_KTHREAD_STATE_OFFSET  0x028
#define      IA64_KTHREAD_STATE_OFFSET  0x071
#define IA64_3555_KTHREAD_STATE_OFFSET  0x064

#define      IA64_KTHREAD_BSTORE_OFFSET 0x038
#define IA64_3555_KTHREAD_BSTORE_OFFSET 0x040

#define      IA64_KTHREAD_BSTORELIMIT_OFFSET 0x040
#define IA64_3555_KTHREAD_BSTORELIMIT_OFFSET 0x048

#define PEB_FROM_TEB32    48
#define PEB_FROM_TEB64    96

#define STACK_BASE_FROM_TEB32 4
#define STACK_BASE_FROM_TEB64 8

#define PEBLDR_FROM_PEB32 12
#define PEBLDR_FROM_PEB64 24

#define MODULE_LIST_FROM_PEBLDR32 12
#define MODULE_LIST_FROM_PEBLDR64 16

#define IA64_TEB_BSTORE_BASE 0x1788

#define X86_SHARED_SYSCALL_BASE_LT2412  0x7ffe02e0
#define X86_SHARED_SYSCALL_BASE_GTE2412 0x7ffe02f8
#define X86_SHARED_SYSCALL_BASE_GTE2492 0x7ffe0300
#define X86_SHARED_SYSCALL_SIZE         0x20

#define X86_KI_USER_SHARED_DATA   0xffdf0000U
#define IA64_KI_USER_SHARED_DATA  0xe0000000fffe0000UI64
#define AMD64_KI_USER_SHARED_DATA 0xfffff78000000000UI64

// Triage dumps contain a KPRCB and the debugger
// needs a safe address to map it into virtual space
// so that it's accessible in a way consistent with
// other dumps and live debugs.  The debugger uses
// an address in the user-shared-memory area on the
// theory that nothing in that area should be present
// in a kernel triage dump so it's a safe place to map in.
#define X86_TRIAGE_PRCB_ADDRESS   0xffdff120U
#define IA64_TRIAGE_PRCB_ADDRESS  0xe0000000ffff0000UI64
#define AMD64_TRIAGE_PRCB_ADDRESS 0xfffff780ffff0000UI64

#define X86_KGDT_NULL       0
#define X86_KGDT_R0_CODE    8
#define X86_KGDT_R0_DATA    16
#define X86_KGDT_R3_CODE    24
#define X86_KGDT_R3_DATA    32
#define X86_KGDT_TSS        40
#define X86_KGDT_R0_PCR     48
#define X86_KGDT_R3_TEB     56
#define X86_KGDT_VDM_TILE   64
#define X86_KGDT_LDT        72
#define X86_KGDT_DF_TSS     80
#define X86_KGDT_NMI_TSS    88

#define X86_FRAME_EDITED            0xfff8
#define X86_MODE_MASK               1
#define X86_EFLAGS_V86_MASK         0x00020000

#define AMD64_KGDT64_NULL (0 * 16)            // NULL descriptor
#define AMD64_KGDT64_R0_CODE (1 * 16)         // kernel mode 64-bit code
#define AMD64_KGDT64_R0_DATA (1 * 16) + 8     // kernel mode 64-bit data (stack)
#define AMD64_KGDT64_R3_CMCODE (2 * 16)       // user mode 32-bit code
#define AMD64_KGDT64_R3_DATA (2 * 16) + 8     // user mode 32-bit data
#define AMD64_KGDT64_R3_CODE (3 * 16)         // user mode 64-bit code
#define AMD64_KGDT64_SYS_TSS (4 * 16)         // kernel mode system task state
#define AMD64_KGDT64_R3_CMTEB (5 * 16)        // user mode 32-bit TEB
#define AMD64_KGDT64_LAST (6 * 16)

//
// Memory management info
//

#define X86_BASE_VIRT                0xc0300000
#define X86_BASE_VIRT_PAE            0xc0600000
#define X86_PAGE_SIZE                0x1000
#define X86_PAGE_SHIFT               12L
#define X86_MM_PTE_TRANSITION_MASK   0x800
#define X86_MM_PTE_PROTOTYPE_MASK    0x400
#define X86_VALID_PFN_MASK           0xFFFFF000
#define X86_VALID_PFN_MASK_PAE       0x0000000FFFFFF000UI64
#define X86_VALID_PFN_SHIFT          12
#define X86_PDPE_SHIFT               30
#define X86_PDE_SHIFT                22
#define X86_PDE_SHIFT_PAE            21
#define X86_PDE_MASK_PAE             0x1ff
#define X86_PTE_SHIFT                12
#define X86_PTE_MASK                 0x3ff
#define X86_PTE_MASK_PAE             0x1ff
#define X86_LARGE_PAGE_MASK          0x80
#define X86_LARGE_PAGE_SIZE          (4 * 1024 * 1024)
#define X86_LARGE_PAGE_SIZE_PAE      (2 * 1024 * 1024)
#define X86_PDBR_MASK                0xFFFFFFE0

#define IA64_PAGE_SIZE               0x2000
#define IA64_PAGE_SHIFT              13L
#define IA64_MM_PTE_TRANSITION_MASK  0x80
#define IA64_MM_PTE_PROTOTYPE_MASK   0x02
#define IA64_VALID_PFN_MASK          0x0007FFFFFFFFE000UI64
#define IA64_VALID_PFN_SHIFT         13
#define IA64_PDE1_SHIFT              33
#define IA64_PDE2_SHIFT              23
#define IA64_PDE_MASK                0x3ff
#define IA64_PTE_SHIFT               13
#define IA64_PTE_MASK                0x3ff
#define IA64_PHYSICAL1_START         0x8000000000000000UI64
#define IA64_PHYSICAL1_END           0x80000FFFFFFFFFFFUI64
#define IA64_PHYSICAL2_START         0xA000000000000000UI64
#define IA64_PHYSICAL2_END           0xA0000FFFFFFFFFFFUI64
#define IA64_PHYSICAL3_START         0xE000000080000000UI64
#define IA64_PHYSICAL3_END           0xE0000000BFFFFFFFUI64
#define IA64_PTA_BASE_MASK           0x1FFFFFFFFFFF8000UI64
#define IA64_REGION_MASK             0xE000000000000000UI64
#define IA64_REGION_SHIFT            61
#define IA64_REGION_COUNT            8
#define IA64_REGION_USER             0
#define IA64_REGION_SESSION          1
#define IA64_REGION_KERNEL           7
#define IA64_VHPT_MASK               0x000000FFFFFF8000UI64
#define IA64_LARGE_PAGE_PDE_MASK     0x1c
#define IA64_LARGE_PAGE_PDE_MARK     4
#define IA64_LARGE_PAGE_SIZE         0x800000

//
// Memory management info
//

#define AMD64_BASE_VIRT                0xFFFFF6FB7DBED000UI64
#define AMD64_PAGE_SIZE                0x1000
#define AMD64_PAGE_SHIFT               12L
#define AMD64_MM_PTE_TRANSITION_MASK   0x800
#define AMD64_MM_PTE_PROTOTYPE_MASK    0x400
#define AMD64_VALID_PFN_MASK           0x000000FFFFFFF000UI64
#define AMD64_VALID_PFN_SHIFT          12
#define AMD64_PML4E_SHIFT              39
#define AMD64_PML4E_MASK               0x1ff
#define AMD64_PDPE_SHIFT               30
#define AMD64_PDPE_MASK                0x1ff
#define AMD64_PDE_SHIFT                21
#define AMD64_PDE_MASK                 0x1ff
#define AMD64_PTE_SHIFT                12
#define AMD64_PTE_MASK                 0x1ff
#define AMD64_LARGE_PAGE_MASK          0x80
#define AMD64_LARGE_PAGE_SIZE          (2 * 1024 * 1024)
#define AMD64_PDBR_MASK                AMD64_VALID_PFN_MASK
#define AMD64_PHYSICAL_START           0xFFFFF80000000000UI64
#define AMD64_PHYSICAL_END             0xFFFFF8FFFFFFFFFFUI64

#define ARM_PAGE_SIZE                  4096
#define ARM_PAGE_SHIFT                 12

#define IA64_DEBUG_CONTROL_SPACE_PCR       1
#define IA64_DEBUG_CONTROL_SPACE_PRCB      2
#define IA64_DEBUG_CONTROL_SPACE_KSPECIAL  3
#define IA64_DEBUG_CONTROL_SPACE_THREAD    4

#define ALPHA_DEBUG_CONTROL_SPACE_PCR      1
#define ALPHA_DEBUG_CONTROL_SPACE_THREAD   2
#define ALPHA_DEBUG_CONTROL_SPACE_PRCB     3
#define ALPHA_DEBUG_CONTROL_SPACE_TEB      6

#define AMD64_DEBUG_CONTROL_SPACE_PCR      0
#define AMD64_DEBUG_CONTROL_SPACE_PRCB     1
#define AMD64_DEBUG_CONTROL_SPACE_KSPECIAL 2
#define AMD64_DEBUG_CONTROL_SPACE_THREAD   3

typedef enum _IA64_FUNCTION_TABLE_TYPE {
    IA64_RF_SORTED,
    IA64_RF_UNSORTED,
    IA64_RF_CALLBACK
} IA64_FUNCTION_TABLE_TYPE;

typedef struct _IA64_DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY64        Links;
    ULONG64             FunctionTable;
    LARGE_INTEGER       TimeStamp;
    ULONG64             MinimumAddress;
    ULONG64             MaximumAddress;
    ULONG64             BaseAddress;
    ULONG64             TargetGp;
    ULONG64             Callback;
    ULONG64             Context;
    ULONG64             OutOfProcessCallbackDll;
    IA64_FUNCTION_TABLE_TYPE Type;
    ULONG               EntryCount;
} IA64_DYNAMIC_FUNCTION_TABLE, *PIA64_DYNAMIC_FUNCTION_TABLE;

#define IA64_RF_BEGIN_ADDRESS(Base,RF)      (( (ULONG64) Base + (RF)->BeginAddress) & (0xFFFFFFFFFFFFFFF0)) // Instruction Size 16 bytes
#define IA64_RF_END_ADDRESS(Base, RF)        (((ULONG64) Base + (RF)->EndAddress+15) & (0xFFFFFFFFFFFFFFF0))   // Instruction Size 16 bytes


typedef enum _AMD64_FUNCTION_TABLE_TYPE {
    AMD64_RF_SORTED,
    AMD64_RF_UNSORTED,
    AMD64_RF_CALLBACK
} AMD64_FUNCTION_TABLE_TYPE;

typedef struct _AMD64_DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY64        ListEntry;
    ULONG64             FunctionTable;
    LARGE_INTEGER       TimeStamp;
    ULONG64             MinimumAddress;
    ULONG64             MaximumAddress;
    ULONG64             BaseAddress;
    ULONG64             Callback;
    ULONG64             Context;
    ULONG64             OutOfProcessCallbackDll;
    AMD64_FUNCTION_TABLE_TYPE Type;
    ULONG               EntryCount;
} AMD64_DYNAMIC_FUNCTION_TABLE, *PAMD64_DYNAMIC_FUNCTION_TABLE;

typedef struct _CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE {

    union {
        IA64_DYNAMIC_FUNCTION_TABLE  IA64Table;
        AMD64_DYNAMIC_FUNCTION_TABLE Amd64Table;
    };

} CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE, *PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE;


// More stuff currently used by crashdump


typedef struct _PAE_ADDRESS {
    union {
        struct {
            ULONG Offset : 12;                  // 0  .. 11
            ULONG Table : 9;                    // 12 .. 20
            ULONG Directory : 9;                // 21 .. 29
            ULONG DirectoryPointer : 2;         // 30 .. 31
        };
        struct {
            ULONG Offset : 21 ;
            ULONG Directory : 9 ;
            ULONG DirectoryPointer : 2;
        } LargeAddress;

        ULONG DwordPart;
    };
} PAE_ADDRESS, * PPAE_ADDRESS;

typedef struct _X86PAE_HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 24;
            ULONGLONG reserved1 : 28;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} X86PAE_HARDWARE_PTE, *PX86PAE_HARDWARE_PTE;

typedef X86PAE_HARDWARE_PTE X86PAE_HARDWARE_PDPTE;


typedef struct _X86PAE_HARDWARE_PDE {
    union {
        struct _X86PAE_HARDWARE_PTE Pte;

        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1;
            ULONGLONG Prototype : 1;
            ULONGLONG reserved0 : 1;
            ULONGLONG reserved2 : 9;
            ULONGLONG PageFrameNumber : 15;
            ULONGLONG reserved1 : 28;
        } Large;

        ULONGLONG QuadPart;
    };
} X86PAE_HARDWARE_PDE;

#if defined(_X86_)
typedef X86_DBGKD_CONTROL_REPORT   DBGKD_CONTROL_REPORT;
typedef X86_DBGKD_CONTROL_SET      DBGKD_CONTROL_SET;
#elif defined(_ALPHA_)
typedef ALPHA_DBGKD_CONTROL_REPORT DBGKD_CONTROL_REPORT;
typedef ALPHA_DBGKD_CONTROL_SET    DBGKD_CONTROL_SET;
#elif defined(_IA64_)
typedef IA64_DBGKD_CONTROL_REPORT  DBGKD_CONTROL_REPORT;
typedef IA64_DBGKD_CONTROL_SET     DBGKD_CONTROL_SET;
#elif defined(_AMD64_)
typedef AMD64_DBGKD_CONTROL_REPORT DBGKD_CONTROL_REPORT;
typedef AMD64_DBGKD_CONTROL_SET    DBGKD_CONTROL_SET;
#endif



//
// DbgKd APIs are for the portable kernel debugger
//

//
// KD_PACKETS are the low level data format used in KD. All packets
// begin with a packet leader, byte count, packet type. The sequence
// for accepting a packet is:
//
//  - read 4 bytes to get packet leader.  If read times out (10 seconds)
//    with a short read, or if packet leader is incorrect, then retry
//    the read.
//
//  - next read 2 byte packet type.  If read times out (10 seconds) with
//    a short read, or if packet type is bad, then start again looking
//    for a packet leader.
//
//  - next read 4 byte packet Id.  If read times out (10 seconds)
//    with a short read, or if packet Id is not what we expect, then
//    ask for resend and restart again looking for a packet leader.
//
//  - next read 2 byte count.  If read times out (10 seconds) with
//    a short read, or if byte count is greater than PACKET_MAX_SIZE,
//    then start again looking for a packet leader.
//
//  - next read 4 byte packet data checksum.
//
//  - The packet data immediately follows the packet.  There should be
//    ByteCount bytes following the packet header.  Read the packet
//    data, if read times out (10 seconds) then start again looking for
//    a packet leader.
//


typedef struct _KD_PACKET {
    ULONG PacketLeader;
    USHORT PacketType;
    USHORT ByteCount;
    ULONG PacketId;
    ULONG Checksum;
} KD_PACKET, *PKD_PACKET;


#define PACKET_MAX_SIZE 4000
#define INITIAL_PACKET_ID 0x80800000    // Don't use 0
#define SYNC_PACKET_ID    0x00000800    // Or in with INITIAL_PACKET_ID
                                        // to force a packet ID reset.

//
// BreakIn packet
//

#define BREAKIN_PACKET                  0x62626262
#define BREAKIN_PACKET_BYTE             0x62

//
// Packet lead in sequence
//

#define PACKET_LEADER                   0x30303030 //0x77000077
#define PACKET_LEADER_BYTE              0x30

#define CONTROL_PACKET_LEADER           0x69696969
#define CONTROL_PACKET_LEADER_BYTE      0x69

//
// Packet Trailing Byte
//

#define PACKET_TRAILING_BYTE            0xAA

//
// Packet Types
//

#define PACKET_TYPE_UNUSED              0
#define PACKET_TYPE_KD_STATE_CHANGE32   1
#define PACKET_TYPE_KD_STATE_MANIPULATE 2
#define PACKET_TYPE_KD_DEBUG_IO         3
#define PACKET_TYPE_KD_ACKNOWLEDGE      4       // Packet-control type
#define PACKET_TYPE_KD_RESEND           5       // Packet-control type
#define PACKET_TYPE_KD_RESET            6       // Packet-control type
#define PACKET_TYPE_KD_STATE_CHANGE64   7
#define PACKET_TYPE_KD_POLL_BREAKIN     8
#define PACKET_TYPE_KD_TRACE_IO         9
#define PACKET_TYPE_KD_CONTROL_REQUEST  10
#define PACKET_TYPE_KD_FILE_IO          11
#define PACKET_TYPE_MAX                 12

//
// If the packet type is PACKET_TYPE_KD_STATE_CHANGE, then
// the format of the packet data is as follows:
//

#define DbgKdMinimumStateChange       0x00003030L

#define DbgKdExceptionStateChange     0x00003030L
#define DbgKdLoadSymbolsStateChange   0x00003031L
#define DbgKdCommandStringStateChange 0x00003032L

#define DbgKdMaximumStateChange       0x00003033L

// If the state change is from an alternate source
// then this bit is combined with the basic state change code.
#define DbgKdAlternateStateChange     0x00010000L

#define KD_REBOOT    (-1)
#define KD_HIBERNATE (-2)
//
// Pathname Data follows directly
//

typedef struct _DBGKD_LOAD_SYMBOLS32 {
    ULONG PathNameLength;
    ULONG BaseOfDll;
    ULONG ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS32, *PDBGKD_LOAD_SYMBOLS32;

typedef struct _DBGKD_LOAD_SYMBOLS64 {
    ULONG PathNameLength;
    ULONG64 BaseOfDll;
    ULONG64 ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS64, *PDBGKD_LOAD_SYMBOLS64;

__inline
void
DbgkdLoadSymbols32To64(
    IN PDBGKD_LOAD_SYMBOLS32 Ls32,
    OUT PDBGKD_LOAD_SYMBOLS64 Ls64
    )
{
    Ls64->PathNameLength = Ls32->PathNameLength;
    Ls64->ProcessId = Ls32->ProcessId;
    COPYSE(Ls64,Ls32,BaseOfDll);
    Ls64->CheckSum = Ls32->CheckSum;
    Ls64->SizeOfImage = Ls32->SizeOfImage;
    Ls64->UnloadSymbols = Ls32->UnloadSymbols;
}

__inline
void
LoadSymbols64To32(
    IN PDBGKD_LOAD_SYMBOLS64 Ls64,
    OUT PDBGKD_LOAD_SYMBOLS32 Ls32
    )
{
    Ls32->PathNameLength = Ls64->PathNameLength;
    Ls32->ProcessId = (ULONG)Ls64->ProcessId;
    Ls32->BaseOfDll = (ULONG)Ls64->BaseOfDll;
    Ls32->CheckSum = Ls64->CheckSum;
    Ls32->SizeOfImage = Ls64->SizeOfImage;
    Ls32->UnloadSymbols = Ls64->UnloadSymbols;
}

//
// This structure is currently all zeroes.
// It just reserves a structure name for future use.
//

typedef struct _DBGKD_COMMAND_STRING {
    ULONG Flags;
    ULONG Reserved1;
    ULONG64 Reserved2[7];
} DBGKD_COMMAND_STRING, *PDBGKD_COMMAND_STRING;

#ifdef _IA64_
#include <pshpck16.h>
#endif

typedef struct _DBGKD_WAIT_STATE_CHANGE32 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG Thread;
    ULONG ProgramCounter;
    union {
        DBGKM_EXCEPTION32 Exception;
        DBGKD_LOAD_SYMBOLS32 LoadSymbols;
    } u;
    // A processor-specific control report and context follows.
} DBGKD_WAIT_STATE_CHANGE32, *PDBGKD_WAIT_STATE_CHANGE32;

// Protocol version 5 64-bit state change.
typedef struct _DBGKD_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    // A processor-specific control report and context follows.
} DBGKD_WAIT_STATE_CHANGE64, *PDBGKD_WAIT_STATE_CHANGE64;

// Protocol version 6 state change.
typedef struct _DBGKD_ANY_WAIT_STATE_CHANGE {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
        DBGKD_COMMAND_STRING CommandString;
    } u;
    // The ANY control report is unioned here to
    // ensure that this structure is always large
    // enough to hold any possible state change.
    union {
        DBGKD_CONTROL_REPORT ControlReport;
        DBGKD_ANY_CONTROL_REPORT AnyControlReport;
    };
} DBGKD_ANY_WAIT_STATE_CHANGE, *PDBGKD_ANY_WAIT_STATE_CHANGE;

#ifdef _IA64_
#include <poppack.h>
#endif

//
// If the packet type is PACKET_TYPE_KD_STATE_MANIPULATE, then
// the format of the packet data is as follows:
//
// Api Numbers for state manipulation
//

#define DbgKdMinimumManipulate              0x00003130L

#define DbgKdReadVirtualMemoryApi           0x00003130L
#define DbgKdWriteVirtualMemoryApi          0x00003131L
#define DbgKdGetContextApi                  0x00003132L
#define DbgKdSetContextApi                  0x00003133L
#define DbgKdWriteBreakPointApi             0x00003134L
#define DbgKdRestoreBreakPointApi           0x00003135L
#define DbgKdContinueApi                    0x00003136L
#define DbgKdReadControlSpaceApi            0x00003137L
#define DbgKdWriteControlSpaceApi           0x00003138L
#define DbgKdReadIoSpaceApi                 0x00003139L
#define DbgKdWriteIoSpaceApi                0x0000313AL
#define DbgKdRebootApi                      0x0000313BL
#define DbgKdContinueApi2                   0x0000313CL
#define DbgKdReadPhysicalMemoryApi          0x0000313DL
#define DbgKdWritePhysicalMemoryApi         0x0000313EL
//#define DbgKdQuerySpecialCallsApi           0x0000313FL
#define DbgKdSetSpecialCallApi              0x00003140L
#define DbgKdClearSpecialCallsApi           0x00003141L
#define DbgKdSetInternalBreakPointApi       0x00003142L
#define DbgKdGetInternalBreakPointApi       0x00003143L
#define DbgKdReadIoSpaceExtendedApi         0x00003144L
#define DbgKdWriteIoSpaceExtendedApi        0x00003145L
#define DbgKdGetVersionApi                  0x00003146L
#define DbgKdWriteBreakPointExApi           0x00003147L
#define DbgKdRestoreBreakPointExApi         0x00003148L
#define DbgKdCauseBugCheckApi               0x00003149L
#define DbgKdSwitchProcessor                0x00003150L
#define DbgKdPageInApi                      0x00003151L // obsolete
#define DbgKdReadMachineSpecificRegister    0x00003152L
#define DbgKdWriteMachineSpecificRegister   0x00003153L
#define OldVlm1                             0x00003154L
#define OldVlm2                             0x00003155L
#define DbgKdSearchMemoryApi                0x00003156L
#define DbgKdGetBusDataApi                  0x00003157L
#define DbgKdSetBusDataApi                  0x00003158L
#define DbgKdCheckLowMemoryApi              0x00003159L
#define DbgKdClearAllInternalBreakpointsApi 0x0000315AL
#define DbgKdFillMemoryApi                  0x0000315BL
#define DbgKdQueryMemoryApi                 0x0000315CL
#define DbgKdSwitchPartition                0x0000315DL

#define DbgKdMaximumManipulate              0x0000315EL

//
// Physical memory caching flags.
// These flags can be passed in on physical memory
// access requests in the ActualBytes field.
//

#define DBGKD_CACHING_UNKNOWN        0
#define DBGKD_CACHING_CACHED         1
#define DBGKD_CACHING_UNCACHED       2
#define DBGKD_CACHING_WRITE_COMBINED 3

//
// Response is a read memory message with data following
//

typedef struct _DBGKD_READ_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY32, *PDBGKD_READ_MEMORY32;

typedef struct _DBGKD_READ_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY64, *PDBGKD_READ_MEMORY64;

__inline
void
DbgkdReadMemory32To64(
    IN PDBGKD_READ_MEMORY32 r32,
    OUT PDBGKD_READ_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesRead = r32->ActualBytesRead;
}

__inline
void
DbgkdReadMemory64To32(
    IN PDBGKD_READ_MEMORY64 r64,
    OUT PDBGKD_READ_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesRead = r64->ActualBytesRead;
}

//
// Data follows directly
//

typedef struct _DBGKD_WRITE_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY32, *PDBGKD_WRITE_MEMORY32;

typedef struct _DBGKD_WRITE_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY64, *PDBGKD_WRITE_MEMORY64;


__inline
void
DbgkdWriteMemory32To64(
    IN PDBGKD_WRITE_MEMORY32 r32,
    OUT PDBGKD_WRITE_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesWritten = r32->ActualBytesWritten;
}

__inline
void
DbgkdWriteMemory64To32(
    IN PDBGKD_WRITE_MEMORY64 r64,
    OUT PDBGKD_WRITE_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesWritten = r64->ActualBytesWritten;
}
//
// Response is a get context message with a full context record following
//

typedef struct _DBGKD_GET_CONTEXT {
    ULONG Unused;
} DBGKD_GET_CONTEXT, *PDBGKD_GET_CONTEXT;

//
// Full Context record follows
//

typedef struct _DBGKD_SET_CONTEXT {
    ULONG ContextFlags;
} DBGKD_SET_CONTEXT, *PDBGKD_SET_CONTEXT;

#define BREAKPOINT_TABLE_SIZE   32      // max number supported by kernel

typedef struct _DBGKD_WRITE_BREAKPOINT32 {
    ULONG BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT32, *PDBGKD_WRITE_BREAKPOINT32;

typedef struct _DBGKD_WRITE_BREAKPOINT64 {
    ULONG64 BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT64, *PDBGKD_WRITE_BREAKPOINT64;


__inline
void
DbgkdWriteBreakpoint32To64(
    IN PDBGKD_WRITE_BREAKPOINT32 r32,
    OUT PDBGKD_WRITE_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakPointAddress);
    r64->BreakPointHandle = r32->BreakPointHandle;
}

__inline
void
DbgkdWriteBreakpoint64To32(
    IN PDBGKD_WRITE_BREAKPOINT64 r64,
    OUT PDBGKD_WRITE_BREAKPOINT32 r32
    )
{
    r32->BreakPointAddress = (ULONG)r64->BreakPointAddress;
    r32->BreakPointHandle = r64->BreakPointHandle;
}

typedef struct _DBGKD_RESTORE_BREAKPOINT {
    ULONG BreakPointHandle;
} DBGKD_RESTORE_BREAKPOINT, *PDBGKD_RESTORE_BREAKPOINT;

typedef struct _DBGKD_BREAKPOINTEX {
    ULONG     BreakPointCount;
    NTSTATUS  ContinueStatus;
} DBGKD_BREAKPOINTEX, *PDBGKD_BREAKPOINTEX;

typedef struct _DBGKD_CONTINUE {
    NTSTATUS ContinueStatus;
} DBGKD_CONTINUE, *PDBGKD_CONTINUE;

// This structure must be 32-bit packed for
// for compatibility with older, processor-specific
// versions of this structure.
#include <pshpack4.h>

typedef struct _DBGKD_CONTINUE2 {
    NTSTATUS ContinueStatus;
    // The ANY control set is unioned here to
    // ensure that this structure is always large
    // enough to hold any possible continue.
    union {
        DBGKD_CONTROL_SET ControlSet;
        DBGKD_ANY_CONTROL_SET AnyControlSet;
    };
} DBGKD_CONTINUE2, *PDBGKD_CONTINUE2;

#include <poppack.h>

typedef struct _DBGKD_READ_WRITE_IO32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO32, *PDBGKD_READ_WRITE_IO32;

typedef struct _DBGKD_READ_WRITE_IO64 {
    ULONG64 IoAddress;
    ULONG DataSize;                     // 1, 2, 4
    ULONG DataValue;
} DBGKD_READ_WRITE_IO64, *PDBGKD_READ_WRITE_IO64;

__inline
void
DbgkdReadWriteIo32To64(
    IN PDBGKD_READ_WRITE_IO32 r32,
    OUT PDBGKD_READ_WRITE_IO64 r64
    )
{
    COPYSE(r64,r32,IoAddress);
    r64->DataSize = r32->DataSize;
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIo64To32(
    IN PDBGKD_READ_WRITE_IO64 r64,
    OUT PDBGKD_READ_WRITE_IO32 r32
    )
{
    r32->IoAddress = (ULONG)r64->IoAddress;
    r32->DataSize = r64->DataSize;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED32, *PDBGKD_READ_WRITE_IO_EXTENDED32;

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG64 IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED64, *PDBGKD_READ_WRITE_IO_EXTENDED64;

__inline
void
DbgkdReadWriteIoExtended32To64(
    IN PDBGKD_READ_WRITE_IO_EXTENDED32 r32,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED64 r64
    )
{
    r64->DataSize = r32->DataSize;
    r64->InterfaceType = r32->InterfaceType;
    r64->BusNumber = r32->BusNumber;
    r64->AddressSpace = r32->AddressSpace;
    COPYSE(r64,r32,IoAddress);
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIoExtended64To32(
    IN PDBGKD_READ_WRITE_IO_EXTENDED64 r64,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED32 r32
    )
{
    r32->DataSize = r64->DataSize;
    r32->InterfaceType = r64->InterfaceType;
    r32->BusNumber = r64->BusNumber;
    r32->AddressSpace = r64->AddressSpace;
    r32->IoAddress = (ULONG)r64-> IoAddress;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_MSR {
    ULONG Msr;
    ULONG DataValueLow;
    ULONG DataValueHigh;
} DBGKD_READ_WRITE_MSR, *PDBGKD_READ_WRITE_MSR;


typedef struct _DBGKD_QUERY_SPECIAL_CALLS {
    ULONG NumberOfSpecialCalls;
    // ULONG64 SpecialCalls[];
} DBGKD_QUERY_SPECIAL_CALLS, *PDBGKD_QUERY_SPECIAL_CALLS;

typedef struct _DBGKD_SET_SPECIAL_CALL32 {
    ULONG SpecialCall;
} DBGKD_SET_SPECIAL_CALL32, *PDBGKD_SET_SPECIAL_CALL32;

typedef struct _DBGKD_SET_SPECIAL_CALL64 {
    ULONG64 SpecialCall;
} DBGKD_SET_SPECIAL_CALL64, *PDBGKD_SET_SPECIAL_CALL64;

__inline
void
DbgkdSetSpecialCall64To32(
    IN PDBGKD_SET_SPECIAL_CALL64 r64,
    OUT PDBGKD_SET_SPECIAL_CALL32 r32
    )
{
    r32->SpecialCall = (ULONG)r64->SpecialCall;
}

#define DBGKD_MAX_INTERNAL_BREAKPOINTS 20

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT32, *PDBGKD_SET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT64, *PDBGKD_SET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdSetInternalBreakpoint64To32(
    IN PDBGKD_SET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_SET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
}

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT32, *PDBGKD_GET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT64, *PDBGKD_GET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdGetInternalBreakpoint32To64(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT32 r32,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakpointAddress);
    r64->Flags = r32->Flags;
    r64->Calls = r32->Calls;
    r64->MaxCallsPerPeriod = r32->MaxCallsPerPeriod;
    r64->MinInstructions = r32->MinInstructions;
    r64->MaxInstructions = r32->MaxInstructions;
    r64->TotalInstructions = r32->TotalInstructions;
}

__inline
void
DbgkdGetInternalBreakpoint64To32(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
    r32->Calls = r64->Calls;
    r32->MaxCallsPerPeriod = r64->MaxCallsPerPeriod;
    r32->MinInstructions = r64->MinInstructions;
    r32->MaxInstructions = r64->MaxInstructions;
    r32->TotalInstructions = r64->TotalInstructions;
}

#define DBGKD_INTERNAL_BP_FLAG_COUNTONLY 0x00000001 // don't count instructions
#define DBGKD_INTERNAL_BP_FLAG_INVALID   0x00000002 // disabled BP
#define DBGKD_INTERNAL_BP_FLAG_SUSPENDED 0x00000004 // temporarily suspended
#define DBGKD_INTERNAL_BP_FLAG_DYING     0x00000008 // kill on exit


//
// The packet protocol was widened to 64 bits in version 5.
// The PTR64 flag allows the debugger to read the right
// size of pointer when neccessary.
//
// The version packet was changed in the same revision, to remove the
// data that are now available in KDDEBUGGER_DATA.
//
// Version 6 adjusted the structures to use
// cross-platform versions all the time.
//
#define DBGKD_64BIT_PROTOCOL_VERSION1 5
#define DBGKD_64BIT_PROTOCOL_VERSION2 6


typedef struct _DBGKD_SEARCH_MEMORY {
    union {
        ULONG64 SearchAddress;
        ULONG64 FoundAddress;
    };
    ULONG64 SearchLength;
    ULONG PatternLength;
} DBGKD_SEARCH_MEMORY, *PDBGKD_SEARCH_MEMORY;


typedef struct _DBGKD_GET_SET_BUS_DATA {
    ULONG BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
    ULONG Offset;
    ULONG Length;
} DBGKD_GET_SET_BUS_DATA, *PDBGKD_GET_SET_BUS_DATA;


#define DBGKD_FILL_MEMORY_VIRTUAL  0x00000001
#define DBGKD_FILL_MEMORY_PHYSICAL 0x00000002

typedef struct _DBGKD_FILL_MEMORY {
    ULONG64 Address;
    ULONG Length;
    USHORT Flags;
    USHORT PatternLength;
} DBGKD_FILL_MEMORY, *PDBGKD_FILL_MEMORY;

// Input AddressSpace values.
#define DBGKD_QUERY_MEMORY_VIRTUAL 0x00000000

// Output AddressSpace values.
#define DBGKD_QUERY_MEMORY_PROCESS 0x00000000
#define DBGKD_QUERY_MEMORY_SESSION 0x00000001
#define DBGKD_QUERY_MEMORY_KERNEL  0x00000002

// Output Flags.
// Currently the kernel always returns rwx.
#define DBGKD_QUERY_MEMORY_READ    0x00000001
#define DBGKD_QUERY_MEMORY_WRITE   0x00000002
#define DBGKD_QUERY_MEMORY_EXECUTE 0x00000004
#define DBGKD_QUERY_MEMORY_FIXED   0x00000008

typedef struct _DBGKD_QUERY_MEMORY {
    ULONG64 Address;
    ULONG64 Reserved;
    ULONG AddressSpace;
    ULONG Flags;
} DBGKD_QUERY_MEMORY, *PDBGKD_QUERY_MEMORY;


#define DBGKD_PARTITION_DEFAULT   0x00000000
#define DBGKD_PARTITION_ALTERNATE 0x00000001

typedef struct _DBGKD_SWITCH_PARTITION {
    ULONG Partition;
} DBGKD_SWITCH_PARTITION;


#include <pshpack4.h>

typedef struct _DBGKD_MANIPULATE_STATE32 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY32 ReadMemory;
        DBGKD_WRITE_MEMORY32 WriteMemory;
        DBGKD_READ_MEMORY64 ReadMemory64;
        DBGKD_WRITE_MEMORY64 WriteMemory64;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO32 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED32 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL32 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT32 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT32 GetInternalBreakpoint;
        DBGKD_GET_VERSION32 GetVersion32;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
    } u;
} DBGKD_MANIPULATE_STATE32, *PDBGKD_MANIPULATE_STATE32;

#include <poppack.h>


typedef struct _DBGKD_MANIPULATE_STATE64 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY64 ReadMemory;
        DBGKD_WRITE_MEMORY64 WriteMemory;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO64 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED64 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL64 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT64 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT64 GetInternalBreakpoint;
        DBGKD_GET_VERSION64 GetVersion64;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
        DBGKD_GET_SET_BUS_DATA GetSetBusData;
        DBGKD_FILL_MEMORY FillMemory;
        DBGKD_QUERY_MEMORY QueryMemory;
        DBGKD_SWITCH_PARTITION SwitchPartition;
    } u;
} DBGKD_MANIPULATE_STATE64, *PDBGKD_MANIPULATE_STATE64;

__inline
ULONG
DbgkdManipulateState32To64(
    IN PDBGKD_MANIPULATE_STATE32 r32,
    OUT PDBGKD_MANIPULATE_STATE64 r64,
    OUT PULONG AdditionalDataSize
    )
{
    r64->ApiNumber = r32->ApiNumber;
    r64->ProcessorLevel = r32->ProcessorLevel;
    r64->Processor = r32->Processor;
    r64->ReturnStatus = r32->ReturnStatus;

    *AdditionalDataSize = 0;

    //
    // translate the messages which may be sent by the kernel
    //

    switch (r64->ApiNumber) {

        case DbgKdSetContextApi:
        case DbgKdRestoreBreakPointApi:
        case DbgKdContinueApi:
        case DbgKdContinueApi2:
        case DbgKdRebootApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRestoreBreakPointExApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
        case DbgKdWriteMachineSpecificRegister:
        case DbgKdWriteIoSpaceApi:
        case DbgKdSetSpecialCallApi:
        case DbgKdSetInternalBreakPointApi:
        case DbgKdWriteIoSpaceExtendedApi:
            break;



        case DbgKdReadMachineSpecificRegister:
            r64->u.ReadWriteMsr = r32->u.ReadWriteMsr;
            break;

        //
        // GetVersion may need to be handled by the calling code;
        // it needs to call DbgkdGetVersion32To64 with the DebuggerDataBlock.
        //

        case DbgKdGetVersionApi:
            break;

        case DbgKdGetContextApi:
            *AdditionalDataSize = sizeof(CONTEXT);
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r64->u.QuerySpecialCalls = r32->u.QuerySpecialCalls;
        //    *AdditionalDataSize = r64->u.QuerySpecialCalls.NumberOfSpecialCalls * sizeof(ULONG);
        //    break;

        case DbgKdWriteBreakPointExApi:
            r64->u.BreakPointEx = r32->u.BreakPointEx;
            *AdditionalDataSize = r64->u.BreakPointEx.BreakPointCount * sizeof(ULONG);
            break;

        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
        case DbgKdReadControlSpaceApi:
            DbgkdReadMemory32To64(&r32->u.ReadMemory, &r64->u.ReadMemory);
            if (NT_SUCCESS(r32->ReturnStatus)) {
                *AdditionalDataSize = r64->u.ReadMemory.ActualBytesRead;
            }
            break;

        case DbgKdWriteVirtualMemoryApi:
        case DbgKdWritePhysicalMemoryApi:
        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory32To64(&r32->u.WriteMemory, &r64->u.WriteMemory);
            break;



        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint32To64(&r32->u.WriteBreakPoint, &r64->u.WriteBreakPoint);
            break;

        case DbgKdReadIoSpaceApi:
            DbgkdReadWriteIo32To64(&r32->u.ReadWriteIo, &r64->u.ReadWriteIo);
            break;

        case DbgKdReadIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended32To64(&r32->u.ReadWriteIoExtended, &r64->u.ReadWriteIoExtended);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint32To64(&r32->u.GetInternalBreakpoint, &r64->u.GetInternalBreakpoint);
            break;

        case DbgKdSearchMemoryApi:
            r64->u.SearchMemory = r32->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE64);
}

__inline
ULONG
DbgkdManipulateState64To32(
    IN PDBGKD_MANIPULATE_STATE64 r64,
    OUT PDBGKD_MANIPULATE_STATE32 r32
    )
{
    r32->ApiNumber = r64->ApiNumber;
    r32->ProcessorLevel = r64->ProcessorLevel;
    r32->Processor = r64->Processor;
    r32->ReturnStatus = r64->ReturnStatus;

    //
    // translate the messages sent by the debugger
    //

    switch (r32->ApiNumber) {

        //
        // These send nothing in the u part.
        case DbgKdGetContextApi:
        case DbgKdSetContextApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRebootApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
            break;


        case DbgKdRestoreBreakPointApi:
            r32->u.RestoreBreakPoint = r64->u.RestoreBreakPoint;
            break;

        case DbgKdContinueApi:
            r32->u.Continue = r64->u.Continue;
            break;

        case DbgKdContinueApi2:
            r32->u.Continue2 = r64->u.Continue2;
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r32->u.QuerySpecialCalls = r64->u.QuerySpecialCalls;
        //    break;

        case DbgKdRestoreBreakPointExApi:
            // NYI
            break;

        case DbgKdReadMachineSpecificRegister:
        case DbgKdWriteMachineSpecificRegister:
            r32->u.ReadWriteMsr = r64->u.ReadWriteMsr;
            break;

        case DbgKdGetVersionApi:
            r32->u.GetVersion32.ProtocolVersion = r64->u.GetVersion64.ProtocolVersion;
            break;

        case DbgKdWriteBreakPointExApi:
            r32->u.BreakPointEx = r64->u.BreakPointEx;
            break;

        case DbgKdWriteVirtualMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        //
        // 32 bit systems only support 32 bit physical r/w
        //
        case DbgKdReadControlSpaceApi:
        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
            DbgkdReadMemory64To32(&r64->u.ReadMemory, &r32->u.ReadMemory);
            break;

        case DbgKdWritePhysicalMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint64To32(&r64->u.WriteBreakPoint, &r32->u.WriteBreakPoint);
            break;

        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdReadIoSpaceApi:
        case DbgKdWriteIoSpaceApi:
            DbgkdReadWriteIo64To32(&r64->u.ReadWriteIo, &r32->u.ReadWriteIo);
            break;

        case DbgKdSetSpecialCallApi:
            DbgkdSetSpecialCall64To32(&r64->u.SetSpecialCall, &r32->u.SetSpecialCall);
            break;

        case DbgKdSetInternalBreakPointApi:
            DbgkdSetInternalBreakpoint64To32(&r64->u.SetInternalBreakpoint, &r32->u.SetInternalBreakpoint);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint64To32(&r64->u.GetInternalBreakpoint, &r32->u.GetInternalBreakpoint);
            break;

        case DbgKdReadIoSpaceExtendedApi:
        case DbgKdWriteIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended64To32(&r64->u.ReadWriteIoExtended, &r32->u.ReadWriteIoExtended);
            break;

        case DbgKdSearchMemoryApi:
            r32->u.SearchMemory = r64->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE32);
}

//
// This is the format for the trace data passed back from the kernel to
// the debugger to describe multiple calls that have returned since the
// last trip back.  The basic format is that there are a bunch of these
// (4 byte) unions stuck together.  Each union is of one of two types: a
// 4 byte unsigned long integer, or a three field struct, describing a
// call (where "call" is delimited by returning or exiting the symbol
// scope).  If the number of instructions executed is too big to fit
// into a USHORT -1, then the Instructions field has
// TRACE_DATA_INSTRUCTIONS_BIG and the next union is a LongNumber
// containing the real number of instructions executed.
//
// The very first union returned in each callback is a LongNumber
// containing the number of unions returned (including the "size"
// record, so it's always at least 1 even if there's no data to return).
//
// This is all returned to the debugger when one of two things
// happens:
//
//   1) The pc moves out of all defined symbol ranges
//   2) The buffer of trace data entries is filled.
//
// The "trace done" case is hacked around on the debugger side.  It
// guarantees that the pc address that indicates a trace exit never
// winds up in a defined symbol range.
//
// The only other complexity in this system is handling the SymbolNumber
// table.  This table is kept in parallel by the kernel and the
// debugger.  When the PC exits a known symbol range, the Begin and End
// symbol ranges are set by the debugger and are allocated to the next
// symbol slot upon return.  "The next symbol slot" means the numerical
// next slot number, unless we've filled all slots, in which case it is
// #0.  (ie., allocation is cyclic and not LRU or something).  The
// SymbolNumber table is flushed when a SpecialCalls call is made (ie.,
// at the beginning of the WatchTrace).
//

typedef union _DBGKD_TRACE_DATA {
    struct {
        UCHAR SymbolNumber;
        CHAR LevelChange;
        USHORT Instructions;
    } s;
    ULONG LongNumber;
} DBGKD_TRACE_DATA, *PDBGKD_TRACE_DATA;

#define TRACE_DATA_INSTRUCTIONS_BIG 0xffff

#define TRACE_DATA_BUFFER_MAX_SIZE 40

//
// If the packet type is PACKET_TYPE_KD_DEBUG_IO, then
// the format of the packet data is as follows:
//

#define DbgKdPrintStringApi     0x00003230L
#define DbgKdGetStringApi       0x00003231L

//
// For print string, the Null terminated string to print
// immediately follows the message
//
typedef struct _DBGKD_PRINT_STRING {
    ULONG LengthOfString;
} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING;

//
// For get string, the Null terminated prompt string
// immediately follows the message. The LengthOfStringRead
// field initially contains the maximum number of characters
// to read. Upon reply, this contains the number of bytes actually
// read. The data read immediately follows the message.
//
//
typedef struct _DBGKD_GET_STRING {
    ULONG LengthOfPromptString;
    ULONG LengthOfStringRead;
} DBGKD_GET_STRING, *PDBGKD_GET_STRING;

typedef struct _DBGKD_DEBUG_IO {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    union {
        DBGKD_PRINT_STRING PrintString;
        DBGKD_GET_STRING GetString;
    } u;
} DBGKD_DEBUG_IO, *PDBGKD_DEBUG_IO;


//
// If the packet type is PACKET_TYPE_KD_TRACE_IO, then
// the format of the packet data is as follows:
//

#define DbgKdPrintTraceApi      0x00003330L

//
// For print trace, the trace buffer data
// immediately follows the message
//
typedef struct _DBGKD_PRINT_TRACE {
    ULONG LengthOfData;
} DBGKD_PRINT_TRACE, *PDBGKD_PRINT_TRACE;

typedef struct _DBGKD_TRACE_IO {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    union {
        ULONG64 ReserveSpace[7];
        DBGKD_PRINT_TRACE PrintTrace;
    } u;
} DBGKD_TRACE_IO, *PDBGKD_TRACE_IO;


//
// If the packet type is PACKET_TYPE_KD_CONTROL_REQUEST, then
// the format of the packet data is as follows:
//

#define DbgKdRequestHardwareBp  0x00004300L
#define DbgKdReleaseHardwareBp  0x00004301L

typedef struct _DBGKD_REQUEST_BREAKPOINT {
    ULONG HardwareBreakPointNumber;
    ULONG Available;
} DBGKD_REQUEST_BREAKPOINT, *PDBGKD_REQUEST_BREAKPOINT;

typedef struct _DBGKD_RELEASE_BREAKPOINT {
    ULONG HardwareBreakPointNumber;
    ULONG Released;
} DBGKD_RELEASE_BREAKPOINT, *PDBGKD_RELEASE_BREAKPOINT;


typedef struct _DBGKD_CONTROL_REQUEST {
    ULONG ApiNumber;
    union {
        DBGKD_REQUEST_BREAKPOINT RequestBreakpoint;
        DBGKD_RELEASE_BREAKPOINT ReleaseBreakpoint;
    } u;
} DBGKD_CONTROL_REQUEST, *PDBGKD_CONTROL_REQUEST;


//
// If the packet type is PACKET_TYPE_KD_FILE_IO, then
// the format of the packet data is as follows:
//

#define DbgKdCreateFileApi      0x00003430L
#define DbgKdReadFileApi        0x00003431L
#define DbgKdWriteFileApi       0x00003432L
#define DbgKdCloseFileApi       0x00003433L

// Unicode filename follows as additional data.
typedef struct _DBGKD_CREATE_FILE {
    ULONG DesiredAccess;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    // Return values.
    ULONG64 Handle;
    ULONG64 Length;
} DBGKD_CREATE_FILE, *PDBGKD_CREATE_FILE;

// Data is returned as additional data in the response.
typedef struct _DBGKD_READ_FILE {
    ULONG64 Handle;
    ULONG64 Offset;
    ULONG Length;
} DBGKD_READ_FILE, *PDBGKD_READ_FILE;

// Data is given as additional data.
typedef struct _DBGKD_WRITE_FILE {
    ULONG64 Handle;
    ULONG64 Offset;
    ULONG Length;
} DBGKD_WRITE_FILE, *PDBGKD_WRITE_FILE;

typedef struct _DBGKD_CLOSE_FILE {
    ULONG64 Handle;
} DBGKD_CLOSE_FILE, *PDBGKD_CLOSE_FILE;

typedef struct _DBGKD_FILE_IO {
    ULONG ApiNumber;
    NTSTATUS Status;
    union {
        ULONG64 ReserveSpace[7];
        DBGKD_CREATE_FILE CreateFile;
        DBGKD_READ_FILE ReadFile;
        DBGKD_WRITE_FILE WriteFile;
        DBGKD_CLOSE_FILE CloseFile;
    } u;
} DBGKD_FILE_IO, *PDBGKD_FILE_IO;


//
// Define debug object access types. No security is present on this object.
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE  (0x1) // Kill all debuggees on last handle close

typedef enum _DEBUGOBJECTINFOCLASS {
    DebugObjectFlags = 1,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

NTSTATUS
NtRemoveProcessDebug (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    );

NTSTATUS
NtWaitForDebugEvent (
    IN HANDLE DebugObjectHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

NTSTATUS
NtDebugContinue (
    IN HANDLE DebugObjectHandle,
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ContinueStatus
    );

NTSTATUS
NtCreateDebugObject (
    OUT PHANDLE DebugObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );

NTSTATUS
NtDebugActiveProcess (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    );

NTSTATUS
NtSetInformationDebugObject (
    IN HANDLE DebugObjectHandle,
    IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    IN PVOID DebugInformation,
    IN ULONG DebugInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // _NTDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\ntiodump.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntiodump.h

Abstract:

    This is the include file that defines all constants and types for
    accessing memory dump files.

Revision History:


--*/

#ifndef _NTIODUMP_
#define _NTIODUMP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef MIDL_PASS
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif


#define USERMODE_CRASHDUMP_SIGNATURE    'RESU'
#define USERMODE_CRASHDUMP_VALID_DUMP32 'PMUD'
#define USERMODE_CRASHDUMP_VALID_DUMP64 '46UD'

typedef struct _USERMODE_CRASHDUMP_HEADER {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONG_PTR   ThreadOffset;
    ULONG_PTR   ModuleOffset;
    ULONG_PTR   DataOffset;
    ULONG_PTR   MemoryRegionOffset;
    ULONG_PTR   DebugEventOffset;
    ULONG_PTR   ThreadStateOffset;
    ULONG_PTR   VersionInfoOffset;
    ULONG_PTR   Spare1;
} USERMODE_CRASHDUMP_HEADER, *PUSERMODE_CRASHDUMP_HEADER;

typedef struct _USERMODE_CRASHDUMP_HEADER32 {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONG       ThreadOffset;
    ULONG       ModuleOffset;
    ULONG       DataOffset;
    ULONG       MemoryRegionOffset;
    ULONG       DebugEventOffset;
    ULONG       ThreadStateOffset;
    ULONG       VersionInfoOffset;
    ULONG       Spare1;
} USERMODE_CRASHDUMP_HEADER32, *PUSERMODE_CRASHDUMP_HEADER32;

typedef struct _USERMODE_CRASHDUMP_HEADER64 {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONGLONG   ThreadOffset;
    ULONGLONG   ModuleOffset;
    ULONGLONG   DataOffset;
    ULONGLONG   MemoryRegionOffset;
    ULONGLONG   DebugEventOffset;
    ULONGLONG   ThreadStateOffset;
    ULONGLONG   VersionInfoOffset;
    ULONGLONG   Spare1;
} USERMODE_CRASHDUMP_HEADER64, *PUSERMODE_CRASHDUMP_HEADER64;

typedef struct _CRASH_MODULE {
    ULONG_PTR   BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE, *PCRASH_MODULE;

typedef struct _CRASH_MODULE32 {
    ULONG       BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE32, *PCRASH_MODULE32;

typedef struct _CRASH_MODULE64 {
    ULONGLONG   BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE64, *PCRASH_MODULE64;

typedef struct _CRASH_THREAD {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONG_PTR   Teb;
    ULONG_PTR   Spare0;
    ULONG_PTR   Spare1;
    ULONG_PTR   Spare2;
    ULONG_PTR   Spare3;
    ULONG_PTR   Spare4;
    ULONG_PTR   Spare5;
    ULONG_PTR   Spare6;
} CRASH_THREAD, *PCRASH_THREAD;

typedef struct _CRASH_THREAD32 {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONG       Teb;
    ULONG       Spare0;
    ULONG       Spare1;
    ULONG       Spare2;
    ULONG       Spare3;
    ULONG       Spare4;
    ULONG       Spare5;
    ULONG       Spare6;
} CRASH_THREAD32, *PCRASH_THREAD32;

typedef struct _CRASH_THREAD64 {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONGLONG   Teb;
    ULONGLONG   Spare0;
    ULONGLONG   Spare1;
    ULONGLONG   Spare2;
    ULONGLONG   Spare3;
    ULONGLONG   Spare4;
    ULONGLONG   Spare5;
    ULONGLONG   Spare6;
} CRASH_THREAD64, *PCRASH_THREAD64;


typedef struct _CRASHDUMP_VERSION_INFO {
    int     IgnoreGuardPages;       // Whether we should ignore GuardPages or not
    ULONG   PointerSize;            // 32, 64 bit pointers
} CRASHDUMP_VERSION_INFO, *PCRASHDUMP_VERSION_INFO;

//
// usermode crash dump data types
//
#define DMP_EXCEPTION                 1 // obsolete
#define DMP_MEMORY_BASIC_INFORMATION  2
#define DMP_THREAD_CONTEXT            3
#define DMP_MODULE                    4
#define DMP_MEMORY_DATA               5
#define DMP_DEBUG_EVENT               6
#define DMP_THREAD_STATE              7
#define DMP_DUMP_FILE_HANDLE          8

//
// usermode crashdump callback function
//
typedef int (__stdcall *PDMP_CREATE_DUMP_CALLBACK)(
    ULONG       DataType,
    PVOID*      DumpData,
    PULONG      DumpDataLength,
    PVOID       UserData
    );


//
// Define the information required to process memory dumps.
//


typedef enum _DUMP_TYPES {
    DUMP_TYPE_INVALID           = -1,
    DUMP_TYPE_UNKNOWN           = 0,
    DUMP_TYPE_FULL              = 1,
    DUMP_TYPE_SUMMARY           = 2,
    DUMP_TYPE_HEADER            = 3,
    DUMP_TYPE_TRIAGE            = 4,
} DUMP_TYPE;


//
// Signature and Valid fields.
//

#define DUMP_SIGNATURE32   ('EGAP')
#define DUMP_VALID_DUMP32  ('PMUD')

#define DUMP_SIGNATURE64   ('EGAP')
#define DUMP_VALID_DUMP64  ('46UD')

#define DUMP_SUMMARY_SIGNATURE  ('PMDS')
#define DUMP_SUMMARY_VALID      ('PMUD')

#define DUMP_SUMMARY_VALID_KERNEL_VA                     (1)
#define DUMP_SUMMARY_VALID_CURRENT_USER_VA               (2)

//
//
// NOTE: The definition of PHYISCAL_MEMORY_RUN and PHYSICAL_MEMORY_DESCRIPTOR
// MUST be the same as in mm.h. The kernel portion of crashdump will
// verify that these structs are the same.
//

typedef struct _PHYSICAL_MEMORY_RUN32 {
    ULONG BasePage;
    ULONG PageCount;
} PHYSICAL_MEMORY_RUN32, *PPHYSICAL_MEMORY_RUN32;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR32 {
    ULONG NumberOfRuns;
    ULONG NumberOfPages;
    PHYSICAL_MEMORY_RUN32 Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR32, *PPHYSICAL_MEMORY_DESCRIPTOR32;

typedef struct _PHYSICAL_MEMORY_RUN64 {
    ULONG64 BasePage;
    ULONG64 PageCount;
} PHYSICAL_MEMORY_RUN64, *PPHYSICAL_MEMORY_RUN64;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR64 {
    ULONG NumberOfRuns;
    ULONG64 NumberOfPages;
    PHYSICAL_MEMORY_RUN64 Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR64, *PPHYSICAL_MEMORY_DESCRIPTOR64;


typedef struct _UNLOADED_DRIVERS32 {
    UNICODE_STRING32 Name;
    ULONG StartAddress;
    ULONG EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS32, *PUNLOADED_DRIVERS32;

typedef struct _UNLOADED_DRIVERS64 {
    UNICODE_STRING64 Name;
    ULONG64 StartAddress;
    ULONG64 EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS64, *PUNLOADED_DRIVERS64;

#define MAX_UNLOADED_NAME_LENGTH 24

typedef struct _DUMP_UNLOADED_DRIVERS32
{
    UNICODE_STRING32 Name;
    WCHAR DriverName[MAX_UNLOADED_NAME_LENGTH / sizeof (WCHAR)];
    ULONG StartAddress;
    ULONG EndAddress;
} DUMP_UNLOADED_DRIVERS32, *PDUMP_UNLOADED_DRIVERS32;

typedef struct _DUMP_UNLOADED_DRIVERS64
{
    UNICODE_STRING64 Name;
    WCHAR DriverName[MAX_UNLOADED_NAME_LENGTH / sizeof (WCHAR)];
    ULONG64 StartAddress;
    ULONG64 EndAddress;
} DUMP_UNLOADED_DRIVERS64, *PDUMP_UNLOADED_DRIVERS64;

typedef struct _DUMP_MM_STORAGE32
{
    ULONG Version;
    ULONG Size;
    ULONG MmSpecialPoolTag;
    ULONG MiTriageActionTaken;

    ULONG MmVerifyDriverLevel;
    ULONG KernelVerifier;
    ULONG MmMaximumNonPagedPool;
    ULONG MmAllocatedNonPagedPool;

    ULONG PagedPoolMaximum;
    ULONG PagedPoolAllocated;

    ULONG CommittedPages;
    ULONG CommittedPagesPeak;
    ULONG CommitLimitMaximum;
} DUMP_MM_STORAGE32, *PDUMP_MM_STORAGE32;

typedef struct _DUMP_MM_STORAGE64
{
    ULONG Version;
    ULONG Size;
    ULONG MmSpecialPoolTag;
    ULONG MiTriageActionTaken;

    ULONG MmVerifyDriverLevel;
    ULONG KernelVerifier;
    ULONG64 MmMaximumNonPagedPool;
    ULONG64 MmAllocatedNonPagedPool;

    ULONG64 PagedPoolMaximum;
    ULONG64 PagedPoolAllocated;

    ULONG64 CommittedPages;
    ULONG64 CommittedPagesPeak;
    ULONG64 CommitLimitMaximum;
} DUMP_MM_STORAGE64, *PDUMP_MM_STORAGE64;


//
// Define the dump header structure. You cannot change these
// defines without breaking the debuggers, so don't.
//

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32   (700)
#define DMP_CONTEXT_RECORD_SIZE_32          (1200)
#define DMP_RESERVED_0_SIZE_32              (1768)
#define DMP_RESERVED_2_SIZE_32              (16)
#define DMP_RESERVED_3_SIZE_32              (56)

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64   (700)
#define DMP_CONTEXT_RECORD_SIZE_64          (3000)
#define DMP_RESERVED_0_SIZE_64              (4020)

#define DMP_HEADER_COMMENT_SIZE             (128)

// Unset WriterStatus value from the header fill.
#define DUMP_WRITER_STATUS_UNINITIALIZED    DUMP_SIGNATURE32

// WriterStatus codes for the dbgeng.dll dump writers.
enum
{
    DUMP_DBGENG_SUCCESS,
    DUMP_DBGENG_NO_MODULE_LIST,
    DUMP_DBGENG_CORRUPT_MODULE_LIST,
};

//
// The 32-bit memory dump structure requires 4-byte alignment.
//

#include <pshpack4.h>

typedef struct _DUMP_HEADER32 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG DirectoryTableBase;
    ULONG PfnDataBase;
    ULONG PsLoadedModuleList;
    ULONG PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG BugCheckParameter1;
    ULONG BugCheckParameter2;
    ULONG BugCheckParameter3;
    ULONG BugCheckParameter4;
    CHAR VersionUser[32];
    UCHAR PaeEnabled;               // Present only for Win2k and better
    UCHAR Spare3[3];
    ULONG KdDebuggerDataBlock;      // Present only for Win2k SP1 and better.

    union {
        PHYSICAL_MEMORY_DESCRIPTOR32 PhysicalMemoryBlock;
        UCHAR PhysicalMemoryBlockBuffer [ DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32 ];
    };
    UCHAR ContextRecord [ DMP_CONTEXT_RECORD_SIZE_32 ];
    EXCEPTION_RECORD32 Exception;
    CHAR Comment [ DMP_HEADER_COMMENT_SIZE ];   // May not be present.
    UCHAR _reserved0 [ DMP_RESERVED_0_SIZE_32 ];
    ULONG DumpType;                             // Present for Win2k and better.
    ULONG MiniDumpFields;
    ULONG SecondaryDataState;
    ULONG ProductType;
    ULONG SuiteMask;
    ULONG WriterStatus;
    LARGE_INTEGER RequiredDumpSpace;            // Present for Win2k and better.
    UCHAR _reserved2 [ DMP_RESERVED_2_SIZE_32 ];
    LARGE_INTEGER SystemUpTime;                 // Present only for Whistler and better.
    LARGE_INTEGER SystemTime;                   // Present only for Win2k and better.
    UCHAR _reserved3 [ DMP_RESERVED_3_SIZE_32 ];
} DUMP_HEADER32, *PDUMP_HEADER32;


typedef struct _FULL_DUMP32 {
    CHAR Memory [1];                // Variable length to the end of the dump file.
} FULL_DUMP32, *PFULL_DUMP32;

typedef struct _SUMMARY_DUMP32 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG DumpOptions;  // Summary Dump Options
    ULONG HeaderSize;   // Offset to the start of actual memory dump
    ULONG BitmapSize;   // Total bitmap size (i.e., maximum #bits)
    ULONG Pages;        // Total bits set in bitmap (i.e., total pages in sdump)

    //
    // These next three fields essentially form an on-disk RTL_BITMAP structure.
    // The RESERVED field is stupidness introduced by the way the data is
    // serialized to disk.
    //

    struct {
        ULONG SizeOfBitMap;
        ULONG _reserved0;
        ULONG Buffer[];
    } Bitmap;
    
} SUMMARY_DUMP32, * PSUMMARY_DUMP32;


typedef struct _TRIAGE_DUMP32 {
    ULONG ServicePackBuild;             // What service pack of NT was this ?
    ULONG SizeOfDump;                   // Size in bytes of the dump
    ULONG ValidOffset;                  // Offset valid ULONG
    ULONG ContextOffset;                // Offset of CONTEXT record
    ULONG ExceptionOffset;              // Offset of EXCEPTION record
    ULONG MmOffset;                     // Offset of Mm information
    ULONG UnloadedDriversOffset;        // Offset of Unloaded Drivers
    ULONG PrcbOffset;                   // Offset of KPRCB
    ULONG ProcessOffset;                // Offset of EPROCESS
    ULONG ThreadOffset;                 // Offset of ETHREAD
    ULONG CallStackOffset;              // Offset of CallStack Pages
    ULONG SizeOfCallStack;              // Size in bytes of CallStack
    ULONG DriverListOffset;             // Offset of Driver List
    ULONG DriverCount;                  // Number of Drivers in list
    ULONG StringPoolOffset;             // Offset to the string pool
    ULONG StringPoolSize;               // Size of the string pool
    ULONG BrokenDriverOffset;           // Offset into the driver of the driver that crashed
    ULONG TriageOptions;                // Triage options in effect at crashtime
    ULONG TopOfStack;                   // The top (highest address) of the call stack

    ULONG DataPageAddress;
    ULONG DataPageOffset;
    ULONG DataPageSize;

    ULONG DebuggerDataOffset;
    ULONG DebuggerDataSize;

    ULONG DataBlocksOffset;
    ULONG DataBlocksCount;
    
} TRIAGE_DUMP32, * PTRIAGE_DUMP32;


typedef struct _MEMORY_DUMP32 {
    DUMP_HEADER32 Header;

    union {
        FULL_DUMP32 Full;               // DumpType == DUMP_TYPE_FULL
        SUMMARY_DUMP32 Summary;         // DumpType == DUMP_TYPE_SUMMARY
        TRIAGE_DUMP32 Triage;           // DumpType == DUMP_TYPE_TRIAGE
    };
    
} MEMORY_DUMP32, *PMEMORY_DUMP32;


#include <poppack.h>

typedef struct _DUMP_HEADER64 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG64 DirectoryTableBase;
    ULONG64 PfnDataBase;
    ULONG64 PsLoadedModuleList;
    ULONG64 PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG64 BugCheckParameter1;
    ULONG64 BugCheckParameter2;
    ULONG64 BugCheckParameter3;
    ULONG64 BugCheckParameter4;
    CHAR VersionUser[32];
    ULONG64 KdDebuggerDataBlock;

    union {
        PHYSICAL_MEMORY_DESCRIPTOR64 PhysicalMemoryBlock;
        UCHAR PhysicalMemoryBlockBuffer [ DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64 ];
    };
    UCHAR ContextRecord [ DMP_CONTEXT_RECORD_SIZE_64 ];
    EXCEPTION_RECORD64 Exception;
    ULONG DumpType;
    LARGE_INTEGER RequiredDumpSpace;
    LARGE_INTEGER SystemTime;
    CHAR Comment [ DMP_HEADER_COMMENT_SIZE ];   // May not be present.
    LARGE_INTEGER SystemUpTime;
    ULONG MiniDumpFields;
    ULONG SecondaryDataState;
    ULONG ProductType;
    ULONG SuiteMask;
    ULONG WriterStatus;
    UCHAR _reserved0[ DMP_RESERVED_0_SIZE_64 ];
} DUMP_HEADER64, *PDUMP_HEADER64;

typedef struct _FULL_DUMP64 {
    CHAR Memory[1];             // Variable length to the end of the dump file.
} FULL_DUMP64, *PFULL_DUMP64;

//
// ISSUE - 2000/02/17 - math: NT64 Summary dump.
//
// This is broken. The 64 bit summary dump should have a ULONG64 for
// the BitmapSize to match the size of the PFN_NUMBER.
//

typedef struct _SUMMARY_DUMP64 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG DumpOptions;  // Summary Dump Options
    ULONG HeaderSize;   // Offset to the start of actual memory dump
    ULONG BitmapSize;   // Total bitmap size (i.e., maximum #bits)
    ULONG Pages;        // Total bits set in bitmap (i.e., total pages in sdump)

    //
    // ISSUE - 2000/02/17 - math: Win64
    //
    // With a 64-bit PFN, we should not have a 32-bit bitmap.
    //
    
    //
    // These next three fields essentially form an on-disk RTL_BITMAP structure.
    // The RESERVED field is stupidness introduced by the way the data is
    // serialized to disk.
    //

    struct {
        ULONG SizeOfBitMap;
        ULONG64 _reserved0;
        ULONG Buffer[];
    } Bitmap;

} SUMMARY_DUMP64, * PSUMMARY_DUMP64;


typedef struct _TRIAGE_DUMP64 {
    ULONG ServicePackBuild;             // What service pack of NT was this ?
    ULONG SizeOfDump;                   // Size in bytes of the dump
    ULONG ValidOffset;                  // Offset valid ULONG
    ULONG ContextOffset;                // Offset of CONTEXT record
    ULONG ExceptionOffset;              // Offset of EXCEPTION record
    ULONG MmOffset;                     // Offset of Mm information
    ULONG UnloadedDriversOffset;        // Offset of Unloaded Drivers
    ULONG PrcbOffset;                   // Offset of KPRCB
    ULONG ProcessOffset;                // Offset of EPROCESS
    ULONG ThreadOffset;                 // Offset of ETHREAD
    ULONG CallStackOffset;              // Offset of CallStack Pages
    ULONG SizeOfCallStack;              // Size in bytes of CallStack
    ULONG DriverListOffset;             // Offset of Driver List
    ULONG DriverCount;                  // Number of Drivers in list
    ULONG StringPoolOffset;             // Offset to the string pool
    ULONG StringPoolSize;               // Size of the string pool
    ULONG BrokenDriverOffset;           // Offset into the driver of the driver that crashed
    ULONG TriageOptions;                // Triage options in effect at crashtime
    ULONG64 TopOfStack;                 // The top (highest address) of the callstack

    //
    // Architecture Specific fields.
    //
    
    union {

        //
        // For IA64 we need to store the BStore as well.
        //
        
        struct {
            ULONG BStoreOffset;         // Offset of BStore region.
            ULONG SizeOfBStore;         // The size of the BStore region.
            ULONG64 LimitOfBStore;      // The limit (highest memory address)
        } Ia64;                         //  of the BStore region.
        
    } ArchitectureSpecific;

    ULONG64 DataPageAddress;
    ULONG   DataPageOffset;
    ULONG   DataPageSize;

    ULONG   DebuggerDataOffset;
    ULONG   DebuggerDataSize;

    ULONG   DataBlocksOffset;
    ULONG   DataBlocksCount;
    
} TRIAGE_DUMP64, * PTRIAGE_DUMP64;


typedef struct _MEMORY_DUMP64 {
    DUMP_HEADER64 Header;

    union {
        FULL_DUMP64 Full;               // DumpType == DUMP_TYPE_FULL
        SUMMARY_DUMP64 Summary;         // DumpType == DUMP_TYPE_SUMMARY
        TRIAGE_DUMP64 Triage;           // DumpType == DUMP_TYPE_TRIAGE
    };
    
} MEMORY_DUMP64, *PMEMORY_DUMP64;


typedef struct _TRIAGE_DATA_BLOCK {
    ULONG64 Address;
    ULONG Offset;
    ULONG Size;
} TRIAGE_DATA_BLOCK, *PTRIAGE_DATA_BLOCK;

//
// In the triage dump ValidFields field what portions of the triage-dump have
// been turned on.
//

#define TRIAGE_DUMP_CONTEXT          (0x0001)
#define TRIAGE_DUMP_EXCEPTION        (0x0002)
#define TRIAGE_DUMP_PRCB             (0x0004)
#define TRIAGE_DUMP_PROCESS          (0x0008)
#define TRIAGE_DUMP_THREAD           (0x0010)
#define TRIAGE_DUMP_STACK            (0x0020)
#define TRIAGE_DUMP_DRIVER_LIST      (0x0040)
#define TRIAGE_DUMP_BROKEN_DRIVER    (0x0080)
#define TRIAGE_DUMP_BASIC_INFO       (0x00FF)
#define TRIAGE_DUMP_MMINFO           (0x0100)
#define TRIAGE_DUMP_DATAPAGE         (0x0200)
#define TRIAGE_DUMP_DEBUGGER_DATA    (0x0400)
#define TRIAGE_DUMP_DATA_BLOCKS      (0x0800)

#define TRIAGE_OPTION_OVERFLOWED     (0x0100)

#define TRIAGE_DUMP_VALID       ( 'DGRT' )
#define TRIAGE_DUMP_SIZE32      ( 0x1000 * 16 )
#define TRIAGE_DUMP_SIZE64      ( 0x2000 * 16 )

#ifdef _NTLDRAPI_

typedef struct _DUMP_DRIVER_ENTRY32 {
    ULONG DriverNameOffset;
    KLDR_DATA_TABLE_ENTRY32 LdrEntry;
} DUMP_DRIVER_ENTRY32, * PDUMP_DRIVER_ENTRY32;

typedef struct _DUMP_DRIVER_ENTRY64 {
    ULONG DriverNameOffset;
    ULONG __alignment;
    KLDR_DATA_TABLE_ENTRY64 LdrEntry;
} DUMP_DRIVER_ENTRY64, * PDUMP_DRIVER_ENTRY64;

#endif // _NTLDRAPI

//
// The DUMP_STRING is guaranteed to be both NULL terminated and length prefixed
// (prefix does not include the NULL).
//

typedef struct _DUMP_STRING {
    ULONG Length;                   // Length IN BYTES of the string.
    WCHAR Buffer [0];               // Buffer.
} DUMP_STRING, * PDUMP_STRING;


//
// Secondary dumps can be generated at bugcheck time after
// the primary dump has been generated.  The data in these
// dumps is arbitrary and not interpretable, so the file
// format is just a sequence of tagged blobs.
//
// Each blob header is aligned on an eight-byte boundary
// and the data immediately follows it.  Padding
// may precede and/or follow the data for alignment purposes.
//
// Blobs are streamed into the file so there is no overall count.
//

#define DUMP_BLOB_SIGNATURE1 'pmuD'
#define DUMP_BLOB_SIGNATURE2 'bolB'

typedef struct _DUMP_BLOB_FILE_HEADER {
    ULONG Signature1;
    ULONG Signature2;
    ULONG HeaderSize;
    ULONG BuildNumber;
} DUMP_BLOB_FILE_HEADER, *PDUMP_BLOB_FILE_HEADER;

typedef struct _DUMP_BLOB_HEADER {
    ULONG HeaderSize;
    GUID Tag;
    ULONG DataSize;
    ULONG PrePad;
    ULONG PostPad;
} DUMP_BLOB_HEADER, *PDUMP_BLOB_HEADER;

#ifdef __cplusplus
}
#endif

//
// These defines should be used only by components
// that know the architecture of the dump matches
// the architecture of the machine they are on; i.e.,
// the kernel and savedump. In particular, the debugger
// should always explicitly use either the 32 or
// 64 bit versions of the headers.
//

#ifndef __NTSDP_HPP__
#if defined (_WIN64)

typedef DUMP_HEADER64 DUMP_HEADER;
typedef PDUMP_HEADER64 PDUMP_HEADER;
typedef MEMORY_DUMP64 MEMORY_DUMP;
typedef PMEMORY_DUMP64 PMEMORY_DUMP;
typedef SUMMARY_DUMP64 SUMMARY_DUMP;
typedef PSUMMARY_DUMP64 PSUMMARY_DUMP;
typedef TRIAGE_DUMP64 TRIAGE_DUMP;
typedef PTRIAGE_DUMP64 PTRIAGE_DUMP;
#ifdef _NTLDRAPI_
typedef DUMP_DRIVER_ENTRY64 DUMP_DRIVER_ENTRY;
typedef PDUMP_DRIVER_ENTRY64 PDUMP_DRIVER_ENTRY;
#endif
#define DUMP_SIGNATURE DUMP_SIGNATURE64
#define DUMP_VALID_DUMP DUMP_VALID_DUMP64
#define TRIAGE_DUMP_SIZE TRIAGE_DUMP_SIZE64
typedef PPHYSICAL_MEMORY_RUN64 PPHYSICAL_MEMORYRUN;
typedef PPHYSICAL_MEMORY_DESCRIPTOR64 PPHYSICAL_MEMORYDESCRIPTOR;

#else

typedef DUMP_HEADER32 DUMP_HEADER;
typedef PDUMP_HEADER32 PDUMP_HEADER;
typedef MEMORY_DUMP32 MEMORY_DUMP;
typedef PMEMORY_DUMP32 PMEMORY_DUMP;
typedef SUMMARY_DUMP32 SUMMARY_DUMP;
typedef PSUMMARY_DUMP32 PSUMMARY_DUMP;
typedef TRIAGE_DUMP32 TRIAGE_DUMP;
typedef PTRIAGE_DUMP32 PTRIAGE_DUMP;
#ifdef _NTLDRAPI_
typedef DUMP_DRIVER_ENTRY32 DUMP_DRIVER_ENTRY;
typedef PDUMP_DRIVER_ENTRY32 PDUMP_DRIVER_ENTRY;
#endif
#define DUMP_SIGNATURE DUMP_SIGNATURE32
#define DUMP_VALID_DUMP DUMP_VALID_DUMP32
#define TRIAGE_DUMP_SIZE TRIAGE_DUMP_SIZE32
typedef PPHYSICAL_MEMORY_RUN32 PPHYSICAL_MEMORYRUN;
typedef PPHYSICAL_MEMORY_DESCRIPTOR32 PPHYSICAL_MEMORYDESCRIPTOR;

#endif
#endif

#ifndef MIDL_PASS
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#endif
#endif // MIDL_PASS

#endif // _NTIODUMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\pdhicalc.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    pdhicalc.h

Abstract:

    calculation functions for the Data Provider Helper.

--*/

#ifndef _PDHICALC_H_
#define _PDHICALC_H_

#include <pdh.h>        // for public PDH data types
#include <winperf.h>    // for perf counter type constants

#if defined(__cplusplus)
#define LINK_SPEC extern "C"
#else
#define LINK_SPEC
#endif

// special perf counter type used by text log files
// value is stored as a double precision floating point value
#define PERF_DOUBLE_RAW  (PERF_SIZE_DWORD | 0x00002000 | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL)

typedef double (APIENTRY   COUNTERCALC)   (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG *, LPDWORD);
typedef double (APIENTRY * LPCOUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG *, LPDWORD);

typedef PDH_STATUS (APIENTRY   COUNTERSTAT)   (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);
typedef PDH_STATUS (APIENTRY * LPCOUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);

// calc functions
extern COUNTERCALC PdhiCalcDouble;
extern COUNTERCALC PdhiCalcAverage;
extern COUNTERCALC PdhiCalcElapsedTime;
extern COUNTERCALC PdhiCalcRawFraction;
extern COUNTERCALC PdhiCalcCounter;
extern COUNTERCALC PdhiCalcTimer;
extern COUNTERCALC PdhiCalcInverseTimer;
extern COUNTERCALC PdhiCalcRawCounter;
extern COUNTERCALC PdhiCalcNoData;
extern COUNTERCALC PdhiCalcDelta;

// status functions
extern COUNTERSTAT PdhiComputeFirstLastStats;
extern COUNTERSTAT PdhiComputeRawCountStats;
extern COUNTERSTAT PdhiComputeNoDataStats;

LINK_SPEC
PDH_STATUS 
PdhiComputeFormattedValue(
    IN      LPCOUNTERCALC           pCalcFunc,
    IN      DWORD                   dwCounterType,
    IN      LONG                    lScale,
    IN      DWORD                   dwFormat,
    IN      PPDH_RAW_COUNTER        pRawValue1,
    IN      PPDH_RAW_COUNTER        pRawValue2,
    IN      PLONGLONG               pTimeBase,
    IN      DWORD                   dwReserved,
    IN  OUT PPDH_FMT_COUNTERVALUE   fmtValue
);

LINK_SPEC
BOOL
AssignCalcFunction(
    IN  DWORD           dwCounterType,
    IN  LPCOUNTERCALC * pCalcFunc,
    IN  LPCOUNTERSTAT * pStatFunc
);

#endif // _PDHICALC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\tracectr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __TRACECTR__01042001_
#define __TRACECTR__01042001_

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Trace Section
\*****************************************************************************/

#define CPDAPI  __stdcall

#define TRACE_LOGGER_START_IF  0x00000001
#define TRACE_LOGGER_EXISTING  0x00000002

#define TRACE_ZERO_ON_QUERY    0x00000004
#define TRACE_REDUCE           0x00000008
#define TRACE_LOG_REPLAY       0x00000010
#define TRACE_DS_ONLY          0x00000020
#define TRACE_DUMP             0x00000080
#define TRACE_USE_WBEM         0x00000100
#define TRACE_EXTENDED_FMT     0x00000200
#define TRACE_SUMMARY          0x00000400
#define TRACE_MERGE_ETL        0x00000800
#define TRACE_INTERPRET        0x00001000

#define TRACE_MEMORY_REPORT    0x00002000
#define TRACE_HARDFAULT_REPORT 0x00004000
#define TRACE_BASIC_REPORT     0x00008000
#define TRACE_TOTALS_REPORT    0x00010000
#define TRACE_FILE_REPORT      0x00020000
#define TRACE_TRANSFORM_XML    0x00040000

#define DEFAULT_FILE_REPORT_SIZE   50

#define TRACE_STATUS_PROCESSING   0x00000001
#define TRACE_STATUS_REPORTING    0x00000002

typedef enum _MM_REPORT_TYPE
{
    REPORT_SUMMARY_PROCESS,
    REPORT_SUMMARY_MODULE,
    REPORT_LIST_PROCESS,
    REPORT_LIST_MODULE
} MM_REPORT_TYPE;

typedef enum _MM_REPORT_SORT_KEY
{
    REPORT_SORT_ALL,
    REPORT_SORT_HPF,
    REPORT_SORT_TF,
    REPORT_SORT_DZF,
    REPORT_SORT_COW
} MM_REPORT_SORT_KEY;

typedef struct _USER_CONTEXT_MM
{
    MM_REPORT_TYPE     reportNow;
    MM_REPORT_SORT_KEY sortNow;
    PWCHAR             strImgName;
} CPD_USER_CONTEXT_MM, * PCPD_USER_CONTEXT_MM;

typedef struct _TRACE_MODULE_INFO
{
    ULONG       PID;
    ULONG       lBaseAddress;
    ULONG       lModuleSize;
    ULONG       lDataFaultHF;
    ULONG       lDataFaultTF;
    ULONG       lDataFaultDZF;
    ULONG       lDataFaultCOW;
    ULONG       lCodeFaultHF;
    ULONG       lCodeFaultTF;
    ULONG       lCodeFaultDZF;
    ULONG       lCodeFaultCOW;
    ULONG       NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR      strModuleName;
    LPWSTR      strImageName;
} TRACE_MODULE_INFO, * PTRACE_MODULE_INFO;

typedef struct _TRACE_PROCESS_FAULT_INFO {
    ULONG    PID;
    ULONG    lDataFaultHF;
    ULONG    lDataFaultTF;
    ULONG    lDataFaultDZF;
    ULONG    lDataFaultCOW;
    ULONG    lCodeFaultHF;
    ULONG    lCodeFaultTF;
    ULONG    lCodeFaultDZF;
    ULONG    lCodeFaultCOW;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
} TRACE_PROCESS_FAULT_INFO, *PTRACE_PROCESS_FAULT_INFO;

typedef struct _TRACE_TRANSACTION_INFO {
    ULONG   TransactionCount;
    ULONG   AverageResponseTime;    // in milliseconds
    ULONG   MaxResponseTime;
    ULONG   MinResponseTime;
    ULONG   NextEntryOffset;
    LPWSTR  Name;
} TRACE_TRANSACTION_INFO, *PTRACE_TRANSACTION_INFO;

typedef struct _TRACE_FILE_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;    // From the Current; Not from the top. 
    LPWSTR  FileName;  // The string immediatealy follows this structure. 
    ULONG   DiskNumber;
} TRACE_FILE_INFOW, *PTRACE_FILE_INFOW;

typedef struct _TRACE_PROCESS_INFOW {
    ULONG    ReadCount;
    ULONG    WriteCount;
    ULONG    ReadSize;
    ULONG    WriteSize;
    ULONG    SendCount;
    ULONG    RecvCount;
    ULONG    SendSize;
    ULONG    RecvSize;
    ULONG    NextEntryOffset;
    LPWSTR   ImageName;
    ULONG    PID;
    ULONG    DeadFlag; 
    ULONG    HPF;
    ULONG    SPF;
    ULONG    PrivateWSet;
    ULONG    GlobalWSet;
    ULONG   UserCPU;
    ULONG   KernelCPU;
    ULONG   TransCount;
    ULONGLONG   LifeTime;
    ULONGLONG   ResponseTime;
    ULONGLONG   TxnStartTime;
    ULONGLONG   TxnEndTime; 
    LPWSTR      UserName;
} TRACE_PROCESS_INFOW, *PTRACE_PROCESS_INFOW;

typedef struct _TRACE_THREAD_INFO {
    ULONG     ThreadId;
} TRACE_THREAD_INFO, *PTRACE_THREAD_INFO;

typedef struct _TRACE_DISK_INFOW {
    ULONG   ReadCount;
    ULONG   WriteCount;
    ULONG   ReadSize;
    ULONG   WriteSize;
    ULONG   NextEntryOffset;
    LPWSTR  DiskName;
    ULONG   DiskNumber;
} TRACE_DISK_INFOW, *PTRACE_DISK_INFOW;

//
// tracelib will not start up a logger anymore. It is external to the dll
// You can provide either Logfiles or LoggerNames (RealTime) as data feed
//
typedef struct _TRACE_BASIC_INFOW {
    ULONG     FlushTimer;
    HANDLE    hEvent;
    ULONG     LogFileCount;
    ULONG     LoggerCount;
    LPCWSTR    *LogFileName;
    LPCWSTR    *LoggerName;
    LPCWSTR     MergeFileName;
    LPCWSTR     ProcFileName;
    LPCWSTR     SummaryFileName;
    LPCWSTR     DumpFileName;
    LPCWSTR     MofFileName;
    LPCWSTR     DefMofFileName;
    LPCWSTR     CompFileName;
    LPCWSTR     XSLDocName;
    ULONGLONG StartTime;
    ULONGLONG EndTime;
    ULONGLONG DSStartTime;
    ULONGLONG DSEndTime;
    ULONG Flags;
    void    (*StatusFunction)(int, double);
    PVOID     pUserContext;
} TRACE_BASIC_INFOW, *PTRACE_BASIC_INFOW;

#define TRACE_FILE_INFO TRACE_FILE_INFOW
#define PTRACE_FILE_INFO PTRACE_FILE_INFOW
#define TRACE_PROCESS_INFO  TRACE_PROCESS_INFOW
#define PTRACE_PROCESS_INFO PTRACE_PROCESS_INFOW
#define TRACE_DISK_INFO TRACE_DISK_INFOW
#define PTRACE_DISK_INFO PTRACE_DISK_INFOW
#define TRACE_BASIC_INFO   TRACE_BASIC_INFOW
#define PTRACE_BASIC_INFO  PTRACE_BASIC_INFOW

#ifdef DBG

extern BOOLEAN TracectrDbgEnabled;
#define TrctrDbgPrint(_x_) { if (TracectrDbgEnabled) DbgPrint _x_ ; }

#endif

//
// APIs 
//

ULONG 
CPDAPI
GetTempName( LPTSTR strFile, size_t cchSize );

BOOLEAN
CPDAPI
TraceCtrDllInitialize (
    HINSTANCE hinstDll,
    DWORD fdwReason,
    LPVOID fImpLoad
    );


ULONG 
CPDAPI
InitTraceContextW(
    IN OUT PTRACE_BASIC_INFOW pTraceBasic,
    PULONG pMergedEventsLost
    );

ULONG
CPDAPI
DeinitTraceContext(
    IN OUT PTRACE_BASIC_INFO pTraceBasic
    );

ULONG
CPDAPI
GetMaxLoggers();

void DecodeIpAddressA(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PCHAR pszA
    );

void DecodeIpAddressW(
    USHORT AddrType, 
    PULONG IpAddrV4,
    PUSHORT IpAddrV6,
    PWCHAR pszW
    );

HRESULT TransformXML( LPWSTR szXML, LPWSTR szXSL, LPWSTR szResult );

#define InitTraceContext    InitTraceContextW

#ifdef __cplusplus
}
#endif

#endif // __TRACECTR__01042001_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\traceprt.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    traceprt.h

Abstract:

    Trace formatting external definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
#ifndef _TRACEPRT_
#define _TRACEPRT_

#define MAXLOGFILES       16
#define MAXSTR          1024

#define GUID_FILE       _T("default")
#define GUID_EXT        _T("tmf")

//
// Now the routines we export
//

#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

#ifdef UNICODE
#define FormatTraceEvent               FormatTraceEventW
#define GetTraceGuids                  GetTraceGuidsW
#define SummaryTraceEventList          SummaryTraceEventListW
#else
#define FormatTraceEvent               FormatTraceEventA
#define GetTraceGuids                  GetTraceGuidsA
#define SummaryTraceEventList          SummaryTraceEventListA
#endif

TRACE_API 
HRESULT
InitializeCSharpDecoder();

TRACE_API 
void
UninitializeCSharpDecoder();


TRACE_API SIZE_T
WINAPI
FormatTraceEventA(
        PLIST_ENTRY  HeadEventList,
        PEVENT_TRACE pEvent,
        CHAR       * EventBuf,
        ULONG        SizeEventBuf,
        CHAR       * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsA(
        CHAR        * GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListA(
        CHAR      * SummaryBlock ,
        ULONG       SizeSummaryBlock ,
        PLIST_ENTRY EventListhead
        );

TRACE_API SIZE_T
WINAPI
FormatTraceEventW(
        PLIST_ENTRY    HeadEventList,
        PEVENT_TRACE   pEvent,
        TCHAR        * EventBuf,
        ULONG          SizeEventBuf,
        TCHAR        * pszMask
        );


TRACE_API ULONG 
WINAPI
GetTraceGuidsW(
        LPTSTR        GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListW(
        TCHAR     * SummaryBlock,
        ULONG       SizeSummaryBlock,
        PLIST_ENTRY EventListhead
        );

TRACE_API void
WINAPI
CleanupTraceEventList(
        PLIST_ENTRY EventListHead
        );

TRACE_API void
WINAPI
GetTraceElapseTime(
        __int64 * pElpaseTime
        );

#define TRACEPRT_INTERFACE_VERSION 1

typedef enum _PARAM_TYPE
{
    ParameterINDENT,
    ParameterSEQUENCE,
    ParameterGMT,
    ParameterTraceFormatSearchPath,
    ParameterInterfaceVersion,
    ParameterUsePrefix,
    ParameterSetPrefix,
    ParameterStructuredFormat,
    ParameterDebugPrint
} PARAMETER_TYPE ;


TRACE_API ULONG
WINAPI
SetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API ULONG
WINAPI
GetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API LPTSTR
WINAPI
GetTraceFormatSearchPath(void);


#define NAMESIZE 256
#define STRUCTUREDMESSAGEVERSION  0
typedef struct _STRUCTUREDMESSAGE {
        ULONG    Version  ;             // Structure Version Number
        GUID     TraceGuid ;            // Message Guid
        ULONG    GuidName ;             // %1   Guid Friendly Name  Offset
        ULONG    GuidTypeName ;         // %2   Guid Type Name Offset
        ULONG    ThreadId ;             // %3   Thread ID  Value
        SYSTEMTIME SystemTime ;         // %4   System Time Value
        ULONG    UserTime ;             // %5   Kernel Time Value
        ULONG    KernelTime ;           // %6   User Time Value
        ULONG    SequenceNum ;          // %7   Sequence Number Value
        ULONG    ProcessId ;            // %8   Process ID Value
        ULONG    CpuNumber ;            // %9   CPU Number Value
        ULONG    Indent ;               //  Indentation level Value
        ULONG    FlagsName ;            //  Trace Flag settings Name Offset
        ULONG    LevelName ;            //  Trace Level Name Offset
        ULONG    FunctionName ;         //  Function Name Offset
        ULONG    ComponentName ;        //  Component Name Offset
        ULONG    SubComponentName ;     //  Sub Component Name Offset
        ULONG    FormattedString ;      //  Formatted String Offset
// Version 0 values before this comment, all new values after this point.
}  STRUCTUREDMESSAGE, *PSTRUCTUREDMESSAGE ;

#define TRACEPRINT(a,b) {PVOID lTracePrint ; if(!((lTracePrint = TracePrint) != NULL)) { *(lTracePrint) b } };

#endif  // #ifndef _TRACEPRT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\pdhp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __PDHP__
#define __PDHP__

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Private Pdh Section
\*****************************************************************************/

#define PDH_RELOG_STATUS_PROCESSING       1

typedef struct _PDH_RELOG_INFO_A {
    LPSTR           strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    void            (*StatusFunction)(int, double);
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_A, *PPDH_RELOG_INFO_A;

typedef struct _PDH_RELOG_INFO_W {
    LPWSTR          strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    void            (*StatusFunction)(int, double);
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_W, *PPDH_RELOG_INFO_W;

PDH_FUNCTION
PdhRelogA( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_A  pRelogInfo
);

PDH_FUNCTION
PdhRelogW( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_W pRelogInfo
);

#ifdef UNICODE
#define PdhRelog            PdhRelogW
#define PDH_RELOG_INFO      PDH_RELOG_INFO_W
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_W
#else
#define PdhRelog            PdhRelogA
#define PDH_RELOG_INFO      PDH_RELOG_INFO_A
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_A
#endif

/*****************************************************************************\
    Performance Logs and Alerts Section
\*****************************************************************************/


#ifdef UNICODE
#define PdhPlaStart                PdhPlaStartW
#define PdhPlaStop                 PdhPlaStopW
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateW
#define PdhPlaDelete               PdhPlaDeleteW
#define PdhPlaAddItem              PdhPlaAddItemW
#define PdhPlaSetItemList          PdhPlaSetItemListW
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemsW
#define PdhPlaGetInfo              PdhPlaGetInfoW
#define PdhPlaSetInfo              PdhPlaSetInfoW
#define PdhPlaSetRunAs             PdhPlaSetRunAsW
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsW
#define PdhPlaValidateInfo         PdhPlaValidateInfoW
#define PDH_PLA_INFO               PDH_PLA_INFO_W
#define PPDH_PLA_INFO              PPDH_PLA_INFO_W
#define PDH_PLA_ITEM               PDH_PLA_ITEM_W
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_W
#define PdhTranslate009Counter     PdhTranslate009CounterW
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterW
#define PdhAdd009Counter           PdhAdd009CounterW
#define PdhGetLogFileType          PdhGetLogFileTypeW
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameW
#define PdhPlaGetSchedule          PdhPlaGetScheduleW
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksW
#else
#define PdhPlaStart                PdhPlaStartA
#define PdhPlaStop                 PdhPlaStopA
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateA
#define PdhPlaDelete               PdhPlaDeleteA
#define PdhPlaAddItem              PdhPlaAddItemA
#define PdhPlaSetItemList          PdhPlaSetItemListA
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemA
#define PdhPlaGetInfo              PdhPlaGetInfoA
#define PdhPlaSetInfo              PdhPlaSetInfoA
#define PdhPlaSetRunAs             PdhPlaSetRunAsA
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsA
#define PdhPlaValidateInfo         PdhPlaValidateInfoA
#define PDH_PLA_INFO               PDH_PLA_INFO_A
#define PPDH_PLA_INFO              PPDH_PLA_INFO_A
#define PDH_PLA_ITEM               PDH_PLA_ITEM_A
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_A
#define PdhTranslate009Counter     PdhTranslate009CounterA
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterA
#define PdhAdd009Counter           PdhAdd009CounterA
#define PdhGetLogFileType          PdhGetLogFileTypeA
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameA
#define PdhPlaGetSchedule          PdhPlaGetScheduleA
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksA
#endif

// wDataType values
#define PLA_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define PLA_TT_DTYPE_UNITS      ((WORD)0x0002)

// dwMode values
#define PLA_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define PLA_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define PLA_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define PLA_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define PLA_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Schedule Calender

// wTimeType values
#define PLA_TT_TTYPE_START              ((WORD)0x0001)
#define PLA_TT_TTYPE_STOP               ((WORD)0x0002)
#define PLA_TT_TTYPE_RESTART            ((WORD)0x0003)
#define PLA_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define PLA_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define PLA_TT_TTYPE_CREATENEWFILE      ((WORD)0x0006)
#define PLA_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)

// dwUnitType values
#define PLA_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define PLA_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define PLA_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define PLA_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define PLA_TT_UTYPE_DAYSOFWEEK     ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _PLA_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} PLA_TIME_INFO, *PPLA_TIME_INFO;

typedef struct _PDH_PLA_ITEM_W {
    DWORD dwType;
    union {
        LPWSTR strCounters;
        struct {
            LPWSTR strProviders;
            LPWSTR strFlags;
            LPWSTR strLevels;
        };
    };
} PDH_PLA_ITEM_W, *PPDH_PLA_ITEM_W;

typedef struct _PDH_PLA_ITEM_A {
    DWORD dwType;
    union {
        LPSTR strCounters;
        struct {
            LPSTR strProviders;
            LPSTR strFlags;
            LPSTR strLevels;
        };
    };
} PDH_PLA_ITEM_A, *PPDH_PLA_ITEM_A;

// Generic Fields
#define PLA_INFO_FLAG_USER        0x00000001
#define PLA_INFO_FLAG_FORMAT      0x00000002
#define PLA_INFO_FLAG_MAXLOGSIZE  0x00000004
#define PLA_INFO_FLAG_RUNCOMMAND  0x00000008
#define PLA_INFO_FLAG_FILENAME    0x00000010
#define PLA_INFO_FLAG_AUTOFORMAT  0x00000020
#define PLA_INFO_FLAG_DATASTORE   0x00000040
#define PLA_INFO_FLAG_REPEAT      0x00000080
#define PLA_INFO_FLAG_STATUS      0x00000100
#define PLA_INFO_FLAG_TYPE        0x00000200
#define PLA_INFO_FLAG_BEGIN       0x00000400
#define PLA_INFO_FLAG_END         0x00000800
#define PLA_INFO_FLAG_CRTNEWFILE  0x00001000
#define PLA_INFO_FLAG_DEFAULTDIR  0x00002000
#define PLA_INFO_FLAG_SRLNUMBER   0x00004000
#define PLA_INFO_FLAG_SQLNAME     0x00008000
#define PLA_INFO_FLAG_ALL         0xFFFFFFFF

// Trace Fields
#define PLA_INFO_FLAG_BUFFERSIZE  0x00010000
#define PLA_INFO_FLAG_LOGGERNAME  0x00020000
#define PLA_INFO_FLAG_MODE        0x00040000
#define PLA_INFO_FLAG_MINBUFFERS  0x00080000
#define PLA_INFO_FLAG_MAXBUFFERS  0x00100000
#define PLA_INFO_FLAG_FLUSHTIMER  0x00200000
#define PLA_INFO_FLAG_PROVIDERS   0x00400000
#define PLA_INFO_FLAG_TRACE       0x00FFFFFF

// Performance Fields
#define PLA_INFO_FLAG_INTERVAL    0x01000000
#define PLA_INFO_FLAG_COUNTERS    0x02000000
#define PLA_INFO_FLAG_PERF        0xFF00FFFF

#define PLA_INFO_CREATE_FILENAME    \
    (PLA_INFO_FLAG_FORMAT|          \
    PLA_INFO_FLAG_FILENAME|         \
    PLA_INFO_FLAG_AUTOFORMAT|       \
    PLA_INFO_FLAG_TYPE|             \
    PLA_INFO_FLAG_CRTNEWFILE|       \
    PLA_INFO_FLAG_DEFAULTDIR|       \
    PLA_INFO_FLAG_SRLNUMBER|        \
    PLA_INFO_FLAG_SQLNAME|          \
    PLA_INFO_FLAG_STATUS )          \


typedef struct _PDH_PLA_INFO_W {
    DWORD       dwMask;
    LPWSTR      strUser;
    LPWSTR      strPassword;
    DWORD       dwType;
    DWORD       dwMaxLogSize;
    DWORD       dwFlags;
    DWORD       dwLogQuota;
    LPWSTR      strLogFileCaption;
    LPWSTR      strDefaultDir;
    LPWSTR      strBaseFileName;
    LPWSTR      strSqlName;
    DWORD       dwFileFormat;
    DWORD       dwAutoNameFormat;
    DWORD       dwLogFileSerialNumber;
    LPWSTR      strCommandFileName;
    DWORD       dwDatastoreAttributes;
    PLA_TIME_INFO    ptLogBeginTime;
    PLA_TIME_INFO    ptLogEndTime;
    PLA_TIME_INFO    ptCreateNewFile;
    PLA_TIME_INFO    ptRepeat;
    DWORD       dwStatus;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    union {
        struct {
            PDH_PLA_ITEM_W  piCounterList;
            DWORD           dwAutoNameInterval;
            DWORD           dwAutoNameUnits;
            PLA_TIME_INFO   ptSampleInterval;
        } Perf;
        struct {
            PDH_PLA_ITEM_W  piProviderList;
            LPWSTR  strLoggerName;
            DWORD   dwMode;
            DWORD   dwNumberOfBuffers;
            DWORD   dwMaximumBuffers;
            DWORD   dwMinimumBuffers;
            DWORD   dwBufferSize;
            DWORD   dwFlushTimer;
        } Trace;
    };
} PDH_PLA_INFO_W, *PPDH_PLA_INFO_W;

typedef struct _PDH_PLA_INFO_A {
    DWORD       dwMask;
    // NOT YET IMPLEMENTED
} PDH_PLA_INFO_A, *PPDH_PLA_INFO_A;

#pragma warning ( default : 4201 )

typedef struct _PLA_VERSION_ {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuild;
    DWORD dwSubBuild;
} PLA_VERSION, *PPLA_VERSION;

HRESULT
PdhiPlaFormatBlanksA( 
    LPSTR strComputer, 
    LPSTR strFormat 
);

HRESULT
PdhiPlaFormatBlanksW( 
    LPWSTR strComputer, 
    LPWSTR strFormat 
);

PDH_FUNCTION
PdhPlaGetScheduleA(
    LPSTR strName, 
    LPSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhPlaGetScheduleW(
    LPWSTR strName, 
    LPWSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);


PDH_FUNCTION
PlaTimeInfoToMilliSeconds(
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs
);

PDH_FUNCTION
PdhPlaValidateInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaValidateInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION 
PdhPlaScheduleA( 
    LPSTR strName, 
    LPSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaScheduleW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaStartA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaStartW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION 
PdhPlaStopA( 
    LPSTR strName, 
    LPSTR strComputer  
);

PDH_FUNCTION 
PdhPlaStopW( 
    LPWSTR strName, 
    LPWSTR strComputer  
);

PDH_FUNCTION 
PdhPlaCreateA( 
    LPSTR strName, 
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION 
PdhPlaCreateW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION 
PdhPlaDeleteA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaDeleteW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaAddItemA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A  pItem
);

PDH_FUNCTION 
PdhPlaAddItemW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItem
);

PDH_FUNCTION 
PdhPlaSetItemListA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A pItems
);

PDH_FUNCTION 
PdhPlaSetItemListW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsA(
    LPSTR strName,
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
    LPWSTR strName,
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaGetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaGetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
);

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion 
);


PDH_FUNCTION
PdhPlaEnumCollectionsA( 
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    LPSTR mszCollections
);

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
    LPWSTR strComputer,
    LPDWORD pcchBufferSize,
    LPWSTR mszCollections
);

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pcchBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR      szLocalePath,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR       szLocalePath,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR      sz009Path,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR       sz009Path,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhAdd009CounterW(
    IN  HQUERY      hQuery,
    IN  LPWSTR      szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhAdd009CounterA(
    IN  HQUERY      hQuery,
    IN  LPSTR       szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN LPCSTR  LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

#define PLA_SECONDS_IN_DAY      86400
#define PLA_SECONDS_IN_HOUR      3600
#define PLA_SECONDS_IN_MINUTE      60
#define _PLA_CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _PLA_SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define PLA_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define PLA_MAX_COLLECTION_NAME   ((DWORD)(_MAX_FNAME - PLA_MAX_AUTO_NAME_LEN - 1))

#define PLA_FILENAME_USE_SUBEXT     0x00000001
#define PLA_FILENAME_GET_SUBFMT     0x00000002
#define PLA_FILENAME_GET_SUBXXX     0x00000004
#define PLA_FILENAME_CREATEONLY     0x00000008
#define PLA_FILENAME_CURRENTLOG     0x00000010
#define PLA_FILENAME_NOEXPANDEV     0x00000020

#define PLA_SERVICE_CONTROL_SYNCHRONIZE 128
#define PLA_QUERY_STOPPED       ((DWORD)0x00000000)              
#define PLA_QUERY_RUNNING       ((DWORD)0x00000001)
#define PLA_QUERY_START_PENDING ((DWORD)0x00000002)

#define PLA_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define PLA_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define PLA_COUNTER_LOG     ((DWORD)0x00000000)
#define PLA_TRACE_LOG       ((DWORD)0x00000001)
#define PLA_ALERT           ((DWORD)0x00000002)
#define PLA_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define PLA_NUM_LOG_TYPES   ((DWORD)0x00000003)

// Sysmon log output file configuration definitions

#define PLA_DATASTORE_APPEND_MASK       ((DWORD)0x000000F)     
#define PLA_DATASTORE_OVERWRITE         ((DWORD)0x0000001)     
#define PLA_DATASTORE_APPEND            ((DWORD)0x0000002)     

#define PLA_DATASTORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define PLA_DATASTORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define PLA_DATASTORE_SIZE_KB           ((DWORD)0x0000020)     
#define PLA_DATASTORE_SIZE_MB           ((DWORD)0x0000040)     

#define PLA_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define PLA_CSV_FILE        ((DWORD)0x00000000)
#define PLA_TSV_FILE        ((DWORD)0x00000001)
#define PLA_BIN_FILE        ((DWORD)0x00000002)
#define PLA_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define PLA_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define PLA_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define PLA_SQL_LOG         ((DWORD)0x00000006)
#define PLA_NUM_FILE_TYPES  ((DWORD)0x00000007)

#define PLA_SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define PLA_SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define PLA_SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define PLA_SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define PLA_SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define PLA_SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define PLA_SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define PLA_SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define PLA_SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define PLA_SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

// Sysmon log query types and constants

// Constants
#define PLA_DISK_MAX_SIZE   ((DWORD)-1)

#define PLA_LOG_SIZE_UNIT_MB                (1024*1024)
#define PLA_LOG_SIZE_UNIT_KB                1024

#define PLA_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define PLA_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define PLA_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define PLA_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define PLA_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define PLA_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define PLA_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define PLA_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define PLA_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// alert action flags
#define PLA_ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define PLA_ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define PLA_ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define PLA_ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define PLA_ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define PLA_ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define PLA_ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define PLA_ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define PLA_ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define PLA_ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define PLA_ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define PLA_ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define PLA_ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define PLA_ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define PLA_AIBF_UNDER  0L
#define PLA_AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define PLA_AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define PLA_AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box
 
typedef struct _PLA_ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} PLA_ALERT_INFO_BLOCK, *PPLA_ALERT_INFO_BLOCK;

#ifdef __cplusplus
}
#endif

#endif // __PDHP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\sdktools\inc\sptlib.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.h

Abstract:

    SCSI_PASS_THROUGH header for user-mode apps

Environment:

    User mode only

Revision History:

    4/10/2000 - created

--*/

#ifndef __SPTLIB_H__
#define __SPTLIB_H__

#ifdef __cplusplus
extern "C" {
#endif
#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include <windows.h>  // sdk
#include <devioctl.h> // sdk
#include <ntddscsi.h> // sdk
#include <ntddstor.h> // sdk

#define _NTSRB_       // allow user-mode scsi.h
#include <scsi.h>     // ddk
#undef  _NTSRB_

#define SPT_DEFAULT_TIMEOUT    60 // one minute timeout is default
#define SPT_MODE_SENSE_TIMEOUT 10 // more than this is not likely

typedef enum _SPT_MODE_PAGE_TYPE {
    SptModePageTypeCurrent   = 0x00,
    SptModePageTypeChangable = 0x40,
    SptModePageTypeDefault   = 0x80,
    SptModePageTypeSaved     = 0xc0
} SPT_MODE_PAGE_TYPE, *PSPT_MODE_PAGE_TYPE;

//
// this simplified and speeds processing of MODE_SENSE
// and MODE_SELECT commands
//

struct _SPT_MODE_PAGE_INFO;
typedef struct _SPT_MODE_PAGE_INFO
                SPT_MODE_PAGE_INFO,
              *PSPT_MODE_PAGE_INFO;

#define SPT_NOT_READY_RETRY_INTERVAL 100 // 10 seconds
#define MAXIMUM_DEFAULT_RETRIES        5 //  5 retries

/*++

Routine Description:

    Validates the CDB length matches the opcode's command group.

Arguments:

Return Value:

    TRUE if size is correct or cannot be verified.
    FALSE if size is mismatched.

--*/
BOOL
SptUtilValidateCdbLength(
    IN PCDB Cdb,
    IN UCHAR CdbSize
    );

/*++

Routine Description:

    Simplistic way to send a command to a device.

Arguments:

    DeviceHandle - handle to device to send command to

    Cdb - command to send to the device

    CdbSize - size of the cdb

    Buffer - Buffer to send to/get from the device

    BufferSize - Size of available buffer on input.
                 Size of returned data when routine completes
                   iff GetDataFromDevice is TRUE

    GetDataFromDevice - TRUE if getting data from device
                        FALSE if sending data to the device

Return Value:

    TRUE if the command completed successfully

--*/
BOOL
SptSendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PUCHAR  Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN GetDataFromDevice
    );

/*++

Routine Description:

Arguments:

    DeviceHandle - handle to device to send command to

    Cdb - command to send to the device

    CdbSize - size of the cdb

    Buffer - Buffer to send to/get from the device

    BufferSize - Size of available buffer on input.
                 Size of returned data when routine completes
                   iff GetDataFromDevice is TRUE

    SenseData - Optional buffer to store sense data on errors.
                Must be NULL if SenseDataSize is zero.
                Must be non-NULL if SenseDataSize is non-zero.

    SenseDataSize - Size of sense data to return to host.
                    Must be zero if SenseData is NULL.
                    Must be non-zero if SenseData is non-NULL.


    GetDataFromDevice - TRUE if getting data from device
                        FALSE if sending data to the device

    TimeOut - Number of seconds before the command should timeout

Return Value:

    TRUE if the command completed successfully.

    FALSE if the command encountered an error
        Data will also be transferred (check *BufferSize) if there is sense
          data, but validity is not guaranteed.
        SenseData may be valid, and may report ERROR_SUCCESS, meaning that
          the resulting data is valid. (call SptUtilInterpretSenseInfo)

--*/
BOOL
SptSendCdbToDeviceEx(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN OUT  PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
       OUT  PSENSE_DATA SenseData,         // if non-null, size must be non-zero
    IN      UCHAR       SenseDataSize,
    IN      BOOLEAN     GetDataFromDevice, // true = receive data
    IN      DWORD       TimeOut            // in seconds
    );


/*++

Routine Description:

    This is a user-mode translation of ClassInterpretSenseInfo()
    from classpnp.sys.  The ErrorValue is deduced based upon the
    sense data, as well as whether the command should be retried or
    not (and in approximately how long).

    NOTE: we default to RETRY==TRUE except for known error classes


Arguments:

    SenseData - pointer to the sense data

    SenseDataSize - size of sense data

    ErrorValue - pointer to location to store resulting error value.
        NOTE: may return ERROR_SUCCESS

    SuggestedRetry - pointer to location to store if the command should
        be retried.  it is the responsibility of the caller to limit the
        number of retries.

    SuggestedRetryDelay - pointer to location to store how long the caller
        should delay (in 1/10 second increments) before retrying the command
        if SuggestedRetry ends up being set to TRUE.

Return Value:

    None

--*/
VOID
SptUtilInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    );

/*++

Routine Description:
    Locks the device for exclusive access.  Uses the same method format and
    chkdsk use to gain exclusive access to the volume.  This is a safe method
    to use, as the FS is automatically remounted when the handle to the device
    is closed.

Arguments:
    VolumeHandle  - Handle to the volume.  Typically created using CreateFile()
                    to a device of the format \\.\D:
    ForceDismount - If TRUE, will try to force dismount the disk even if
                    there are open handles.  Else this call fails if the volume
                    is already opened by some other application.  The UI to
                    make the decision to force a dismount is left to the
                    calling application.

Return Value:

    TRUE if the volume was locked for exclusive access
    FALSE if the volume could not be locked.

--*/
BOOL
SptUtilLockVolumeByHandle(
    IN HANDLE  VolumeHandle,
    IN BOOLEAN ForceDismount
    );

#if 0
/*++

Routine Description:
    Acquires a volume handle for the provided drive letter.

Arguments:
    VolumeHandle  - Handle to the volume.  Typically created using CreateFile()
                    to a device of the format \\.\D:
    ForceDismount - If TRUE, will try to force dismount the disk without
                    prompting the user.
    Quiet         - If TRUE, will not prompt the user.  Can be used to fail
                    if the volume is already opened without providing the
                    user an opportunity to force the volume to dismount

Return Value:

    TRUE if the volume was locked for exclusive access
    FALSE if the volume could not be locked.

--*/
BOOL
SptGetVolumeHandleByDriveLetter(
    OUT HANDLE * VolumeHandle,
    IN  UCHAR DriveLetter
    );

BOOL
SptGetDeviceHandleByScsiAddress(
    OUT HANDLE * VolumeHandle,
    IN  SCSI_ADDRESS ScsiAddress
    );

BOOL
SptGetDeviceInfo(
    IN  HANDLE VolumeHandle,
    IN  PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptorBuffer,
    IN  ULONG BufferSize
    );

BOOL
SptGetAdapterInfo(
    IN HANDLE VolumeHandle,
    IN PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptorBuffer,
    IN ULONG BufferSize
    );

BOOL
SptAllocAlignedBuffer(
    OUT PVOID * Buffer,    // must be free'd with SptFreeAlignedBuffer()
    IN ULONG BufferSize,
    IN ULONG AlignmentMask // from STORAGE_ADAPTER_DESCRIPTOR
    );

BOOL
SptFreeAlignedBuffer(
    IN PVOID Buffer        // must have been allocated by SptAllocAlignedBuffer()
    );

#endif // 0


#if 0
typedef struct _SCSI_ASC_ASCQ_RETURN_VALUES_TEXT {
    ULONG Number;
    PCHAR Name;
} SCSI_ASC_ASCQ_RETURN_VALUES_TEXT, *PSCSI_ASC_ASCQ_RETURN_VALUES_TEXT;

#define MAKE_IT(name, number) \
    { (number), #name }

SCSI_ASC_ASCQ_RETURN_VALUES_TEXT data[] = {
    MAKE_IT(NO_ADDITIONAL_SENSE_INFORMATION                        , 0x0000),
    MAKE_IT(FILEMARK_DETECTED                                      , 0x0001),
    MAKE_IT(END_OF_PARTITION_OR_MEDIUM_DETECTED                    , 0x0002),
    MAKE_IT(SETMARK_DETECTED                                       , 0x0003),
    MAKE_IT(BEGINNING_OF_PARTITION_OR_MEDIUM_DETECTED              , 0x0004),
    MAKE_IT(END_OF_DATA_DETECTED                                   , 0x0005),
    MAKE_IT(PLAY_OPERATION_ABORTED                                 , 0x0006),
    MAKE_IT(AUDIO_PLAY_OPERATION_IN_PROGRESS                       , 0x0011),
    MAKE_IT(AUDIO_PLAY_OPERATION_PAUSED                            , 0x0012),
    MAKE_IT(AUDIO_PLAY_OPERATION_SUCCESSFULLY_COMPLETED            , 0x0013),
    MAKE_IT(AUDIO_PLAY_OPERATION_STOPPED_DUE_TO_ERROR              , 0x0014),
    MAKE_IT(NO_CURRENT_AUDIO_STATUS_TO_RETURN                      , 0x0015),
    MAKE_IT(OPERATION_IN_PROGRESS                                  , 0x0016),
    MAKE_IT(CLEANING_REQUESTED                                     , 0x0017),
    MAKE_IT(NO_INDEX_OR_SECTOR_SIGNAL                              , 0x0100),
    MAKE_IT(NO_SEEK_COMPLETE                                       , 0x0200),
    MAKE_IT(PERIPHERAL_DEVICE_WRITE_FAULT                          , 0x0300),
    MAKE_IT(NO_WRITE_CURRENT                                       , 0x0301),
    MAKE_IT(EXCESSIVE_WRITE_ERRORS                                 , 0x0302),
    MAKE_IT(LU_NOT_READY_CAUSE_NOT_REPORTABLE                      , 0x0400),
    MAKE_IT(LU_NOT_READY_BECOMING_READY                            , 0x0401),
    MAKE_IT(LU_NOT_READY_INIT_COMMAND_REQUIRED                     , 0x0402),
    MAKE_IT(LU_NOT_READY_MANUAL_INTERVENTION_REQUIRED              , 0x0403),
    MAKE_IT(LU_NOT_READY_FORMAT_IN_PROGRESS                        , 0x0404),
    MAKE_IT(LU_NOT_READY_REBUILD_IN_PROGRESS                       , 0x0405),
    MAKE_IT(LU_NOT_READY_RECALCULATION_IN_PROGRESS                 , 0x0406),
    MAKE_IT(LU_NOT_READY_OPERATION_IN_PROGRESS                     , 0x0407),
    MAKE_IT(LU_NOT_READY_LONG_WRITE_IN_PROGRESS                    , 0x0408),
    MAKE_IT(LU_DOES_NOT_RESPOND_TO_SELECTION                       , 0x0500),
    MAKE_IT(NO_REFERENCE_POSITION_FOUND__MEDIUM_MAY_BE_UPSIDE_DOWN , 0x0600),
    MAKE_IT(MULTIPLE_PERIPHERAL_DEVICES_SELECTED                   , 0x0700),
    MAKE_IT(LU_COMMUNICATION_FAILURE                               , 0x0800),
    MAKE_IT(LU_COMMUNICATION_TIMEOUT                               , 0x0801),
    MAKE_IT(LU_COMMUNICATION_PARITY_ERROR                          , 0x0802),
    MAKE_IT(LU_COMMUNICATION_CRC_ERROR_UDMA32                      , 0x0803),
    MAKE_IT(TRACK_FOLLOWING_ERROR                                  , 0x0900),
    MAKE_IT(TRACKING_SERVO_FAILURE                                 , 0x0901),
    MAKE_IT(FOCUS_SERVO_FAILURE                                    , 0x0902),
    MAKE_IT(SPINDLE_SERVO_FAILURE                                  , 0x0903),
    MAKE_IT(HEAD_SELECT_FAULT                                      , 0x0904),
    MAKE_IT(ERROR_LOG_OVERFLOW                                     , 0x0A00),
    MAKE_IT(WARNING                                                , 0x0B00),
    MAKE_IT(WARNING_SPECIFIED_TEMPERATURE_EXCEEDED                 , 0x0B01),
    MAKE_IT(WARNING_ENCLOSURE_DEGRADED                             , 0x0B02),
    MAKE_IT(WRITE_ERROR                                            , 0x0C00),
    MAKE_IT(WRITE_ERROR__RECOVERED_WITH_AUTO_REALLOCATION          , 0x0C01),
    MAKE_IT(WRITE_ERROR__AUTO_REALLOCATION_FAILED                  , 0x0C02),
    MAKE_IT(WRITE_ERROR__RECOMMEND_REASSIGNMENT                    , 0x0C03),
    MAKE_IT(COMPRESSION_CHECK_MISCOMPARE_ERROR                     , 0x0C04),
    MAKE_IT(DATA_EXPANSION_OCCURRED_DURING_COMPRESSION             , 0x0C05),
    MAKE_IT(BLOCK_NOT_COMPRESSABLE                                 , 0x0C06),
    MAKE_IT(WRITE_ERROR__RECOVERY_NEEDED                           , 0x0C07),
    MAKE_IT(WRITE_ERROR__RECOVERY_FAILED                           , 0x0C08),
    MAKE_IT(WRITE_ERROR__LOSS_OF_STREAMING                         , 0x0C09),
    MAKE_IT(WRITE_ERROR__PADDING_BLOCKS_ADDED                      , 0x0C0A),
    MAKE_IT(ID_CRC_OR_ECC_ERROR                                    , 0x1000),
    MAKE_IT(UNRECOVERED_READ_ERROR                                 , 0x1100),
    MAKE_IT(READ_RETRIES_EXHAUSTED                                 , 0x1101),
    MAKE_IT(ERROR_TOO_LONG_TO_CORRECT                              , 0x1102),
    MAKE_IT(MULTIPLE_READ_ERRORS                                   , 0x1103),
    MAKE_IT(UNRECOVERED_READ_ERROR__AUTO_REALLOCATE_FAILED         , 0x1104),
    MAKE_IT(LEC_UNCORRECTABLE_ERROR                                , 0x1105),
    MAKE_IT(CIRC_UNCORRECTABLE_ERROR                               , 0x1106),
    MAKE_IT(RESYNCHRONIZATION_ERROR                                , 0x1107),
    MAKE_IT(INCOMPLETE_BLOCK_READ                                  , 0x1108),
    MAKE_IT(NO_GAP_FOUND                                           , 0x1109),
    MAKE_IT(MISCORRECTED_ERROR                                     , 0x110A),
    MAKE_IT(UNRECOVERED_READ_ERROR__RECOMMEND_REASSIGNMENT         , 0x110B),
    MAKE_IT(UNRECOVERED_READ_ERROR__RECOMMEND_REWRITE_DATA         , 0x110C),
    MAKE_IT(DECOMPRESSION_CRC_ERROR                                , 0x110D),
    MAKE_IT(CANNOT_DECOMPRESS_USING_DECLARED_ALGORITHM             , 0x110E),
    MAKE_IT(ERROR_READING_UPC_OR_EAN_NUMBER                        , 0x110F),
    MAKE_IT(ERROR_READING_ISRC_NUMBER                              , 0x1110),
    MAKE_IT(READ_ERROR__LOSS_OF_STREAMING                          , 0x1111),
    MAKE_IT(ADDRESS_MARK_NOT_FOUND_FOR_ID_FIELD                    , 0x1200),
    MAKE_IT(ADDRESS_MARK_NOT_FOUND_FOR_DATA_FIELD                  , 0x1300),
    MAKE_IT(RECORDED_ENTITY_NOT_FOUND                              , 0x1400),
    MAKE_IT(RECORD_NOT_FOUND                                       , 0x1401),
    MAKE_IT(FILEMARK_OR_SETMARK_NOT_FOUND                          , 0x1402),
    MAKE_IT(END_OF_DATA_NOT_FOUND                                  , 0x1403),
    MAKE_IT(BLOCK_SEQUENCE_ERROR                                   , 0x1404),
    MAKE_IT(RECORD_NOT_FOUND__RECOMMEND_REASSIGNMENT               , 0x1405),
    MAKE_IT(RECORD_NOT_FOUND__DATA_AUTO_REALLOCATED                , 0x1406),
    MAKE_IT(RANDOM_POSITIONING_ERROR                               , 0x1500),
    MAKE_IT(MECHANICAL_POSITIONING_ERROR                           , 0x1501),
    MAKE_IT(POSITIONING_ERROR_DETECTED_BY_READ_OF_MEDIUM           , 0x1502),
    MAKE_IT(DATA_SYNCHRONIZATION_MARK_ERROR                        , 0x1600),
    MAKE_IT(DATA_SYNC_ERROR__DATA_REWRITTEN                        , 0x1601),
    MAKE_IT(DATA_SYNC_ERROR__RECOMMEND_REWRITE                     , 0x1602),
    MAKE_IT(DATA_SYNC_ERROR__DATA_AUTO_REALLOCATED                 , 0x1603),
    MAKE_IT(DATA_SYNC_ERROR__RECOMMEND_REASSIGNMENT                , 0x1604),
    MAKE_IT(RECOVERED_DATA_WITH_NO_ERROR_CORRECTION_APPLIED        , 0x1700),
    MAKE_IT(RECOVERED_DATA_WITH_RETRIES                            , 0x1701),
    MAKE_IT(RECOVERED_DATA_WITH_POSITIVE_HEAD_OFFSET               , 0x1702),
    MAKE_IT(RECOVERED_DATA_WITH_NEGATIVE_HEAD_OFFSET               , 0x1703),
    MAKE_IT(RECOVERED_DATA_WITH_RETRIES_AND_OR_CIRC_APPLIED        , 0x1704),
    MAKE_IT(RECOVERED_DATA_USING_PREVIOUS_SECTOR_ID                , 0x1705),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__DATA_AUTO_REALLOCATED      , 0x1706),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__RECOMMEND_REASSIGNMENT     , 0x1707),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__RECOMMEND_REWRITE          , 0x1708),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__DATA_REWRITTEN             , 0x1709),
    MAKE_IT(RECOVERED_DATA_WITH_ECC_APPLIED                        , 0x1800),
    MAKE_IT(RECOVERED_DATA_WITH_ECC_AND_RETRIES_APPLIED            , 0x1801),
    MAKE_IT(RECOVERED_DATA__DATA_AUTO_REALLOCATED                  , 0x1802),
    MAKE_IT(RECOVERED_DATA_WITH_CIRC                               , 0x1803),
    MAKE_IT(RECOVERED_DATA_WITH_LEC                                , 0x1804),
    MAKE_IT(RECOVERED_DATA__RECOMMEND_REASSIGNMENT                 , 0x1805),
    MAKE_IT(RECOVERED_DATA__RECOMMEND_REWRITE                      , 0x1806),
    MAKE_IT(RECOVERED_DATA_WITH_ECC__DATA_REWRITTEN                , 0x1807),
    MAKE_IT(RECOVERED_DATA_WITH_LINKING                            , 0x1808),
    MAKE_IT(DEFECT_LIST_ERROR                                      , 0x1900),
    MAKE_IT(DEFECT_LIST_NOT_AVAILABLE                              , 0x1901),
    MAKE_IT(DEFECT_LIST_ERROR_IN_PRIMARY_LIST                      , 0x1902),
    MAKE_IT(DEFECT_LIST_ERROR_IN_GROWN_LIST                        , 0x1903),
    MAKE_IT(PARAMETER_LIST_LENGTH_ERROR                            , 0x1A00),
    MAKE_IT(SYNCHRONOUS_DATA_TRANSFER_ERROR                        , 0x1B00),
    MAKE_IT(DEFECT_LIST_NOT_FOUND                                  , 0x1C00),
    MAKE_IT(PRIMARY_DEFECT_LIST_NOT_FOUND                          , 0x1C01),
    MAKE_IT(GROWN_DEFECT_LIST_NOT_FOUND                            , 0x1C02),
    MAKE_IT(MISCOMPARE_DURING_VERIFY_OPERATION                     , 0x1D00),
    MAKE_IT(RECOVERED_ID_WITH_ECC_CORRECTION                       , 0x1E00),
    MAKE_IT(PARTIAL_DEFECT_LIST_TRANSFER                           , 0x1F00),
    MAKE_IT(INVALID_COMMAND_OPERATION_CODE                         , 0x2000),
    MAKE_IT(LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     , 0x2100),
    MAKE_IT(INVALID_ELEMENT_ADDRESS                                , 0x2101),
    MAKE_IT(INVALID_ADDRESS_FOR_WRITE                              , 0x2102),
    MAKE_IT(_OBSOLETE__ILLEGAL_FUNCTION                            , 0x2200),
    MAKE_IT(INVALID_FIELD_IN_CDB                                   , 0x2400),
    MAKE_IT(LOGICAL_UNIT_NOT_SUPPORTED                             , 0x2500),
    MAKE_IT(INVALID_FIELD_IN_PARAMETER_LIST                        , 0x2600),
    MAKE_IT(PARAMETER_NOT_SUPPORTED                                , 0x2601),
    MAKE_IT(PARAMETER_VALUE_NOT_SUPPORTED                          , 0x2602),
    MAKE_IT(THRESHOLD_PARAMETERS_NOT_SUPPORTED                     , 0x2603),
    MAKE_IT(INVALID_RELEASE_OF_ACTIVE_PERSISTENT_RESERVATION       , 0x2604),
    MAKE_IT(WRITE_PROTECTED                                        , 0x2700),
    MAKE_IT(HARDWARE_WRITE_PROTECTED                               , 0x2701),
    MAKE_IT(LU_SOFTWARE_WRITE_PROTECTED                            , 0x2702),
    MAKE_IT(ASSOCIATED_WRITE_PROTECT                               , 0x2703),
    MAKE_IT(PERSISTENT_WRITE_PROTECT                               , 0x2704),
    MAKE_IT(PERMANENT_WRITE_PROTECT                                , 0x2705),
    MAKE_IT(CONDITIONAL_WRITE_PROTECT                              , 0x2706),
    MAKE_IT(NOT_READY_TO_READY__MEDIUM_MAY_HAVE_CHANGED            , 0x2800),
    MAKE_IT(IMPORT_OR_EXPORT_ELEMENT_ACCESSED                      , 0x2801),
    MAKE_IT(POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED            , 0x2900),
    MAKE_IT(POWER_ON_OCCURRED                                      , 0x2901),
    MAKE_IT(SCSI_BUS_RESET_OCCURRED                                , 0x2902),
    MAKE_IT(BUS_DEVICE_RESET_FUNCTION_OCCURRED                     , 0x2903),
    MAKE_IT(DEVICE_INTERNAL_RESET                                  , 0x2904),
    MAKE_IT(PARAMETERS_CHANGED                                     , 0x2A00),
    MAKE_IT(MODE_PARAMETERS_CHANGED                                , 0x2A01),
    MAKE_IT(LOG_PARAMETERS_CHANGED                                 , 0x2A02),
    MAKE_IT(RESERVATIONS_PREEMPTED                                 , 0x2A03),
    MAKE_IT(COPY_CANNOT_EXECUTE_SINCE_HOST_CANNOT_DISCONNECT       , 0x2B00),
    MAKE_IT(COMMAND_SEQUENCE_ERROR                                 , 0x2C00),
    MAKE_IT(TOO_MANY_WINDOWS_SPECIFIED                             , 0x2C01),
    MAKE_IT(INVALID_COMBINATION_OF_WINDOWS_SPECIFIED               , 0x2C02),
    MAKE_IT(CURRENT_PROGRAM_AREA_IS_NOT_EMPTY                      , 0x2C03),
    MAKE_IT(CURRENT_PROGRAM_AREA_IS_EMPTY                          , 0x2C04),
    MAKE_IT(PERSISTENT_PREVENT_CONFLICT                            , 0x2C05),
    MAKE_IT(OVERWRITE_ERROR_ON_UPDATE_IN_PLACE                     , 0x2D00),
    MAKE_IT(INSUFFICIENT_TIME_FOR_OPERATION                        , 0x2E00),
    MAKE_IT(COMMANDS_CLEARED_BY_ANOTHER_INITIATOR                  , 0x2F00),
    MAKE_IT(INCOMPATIBLE_MEDIUM_INSTALLED                          , 0x3000),
    MAKE_IT(CANNOT_READ_MEDIUM__UNKNOWN_FORMAT                     , 0x3001),
    MAKE_IT(CANNOT_READ_MEDIUM__INCOMPATIBLE_FORMAT                , 0x3002),
    MAKE_IT(CANNOT_READ_MEDIUM__CLEANING_CARTRIDGE_INSTALLED       , 0x3003),
    MAKE_IT(CANNOT_WRITE_MEDIUM__UNKNOWN_FORMAT                    , 0x3004),
    MAKE_IT(CANNOT_WRITE_MEDIUM__INCOMPATIBLE_FORMAT               , 0x3005),
    MAKE_IT(CANNOT_FORMAT_MEDIUM__INCOMPATIBLE_MEDIUM              , 0x3006),
    MAKE_IT(CLEANING_FAILURE                                       , 0x3007),
    MAKE_IT(CANNOT_WRITE__APPLICATION_CODE_MISMATCH                , 0x3008),
    MAKE_IT(CURRENT_SESSION_NOT_FIXATED_FOR_APPEND                 , 0x3009),
    MAKE_IT(MEDIUM_FORMAT_CORRUPTED                                , 0x3100),
    MAKE_IT(FORMAT_COMMAND_FAILED                                  , 0x3101),
    MAKE_IT(ZONED_FORMATTING_FAILED_DUE_TO_SPARE_LINKING           , 0x3102),
    MAKE_IT(NO_DEFECT_SPARE_LOCATION_AVAILABLE                     , 0x3200),
    MAKE_IT(DEFECT_LIST_UPDATE_FAILURE                             , 0x3201),
    MAKE_IT(TAPE_LENGTH_ERROR                                      , 0x3300),
    MAKE_IT(ENCLOSURE_FAILURE                                      , 0x3400),
    MAKE_IT(ENCLOSURE_SERVICES_FAILURE                             , 0x3500),
    MAKE_IT(UNSUPPORTED_ENCLOSURE_FUNCTION                         , 0x3501),
    MAKE_IT(ENCLOSURE_SERVICES_UNAVAILABLE                         , 0x3502),
    MAKE_IT(ENCLOSURE_SERVICES_TRANSFER_FAILURE                    , 0x3503),
    MAKE_IT(ENCLOSURE_SERVICES_TRANSFER_REFUSED                    , 0x3504),
    MAKE_IT(RIBBON_INK_OR_TONER_FAILURE                            , 0x3600),
    MAKE_IT(ROUNDED_PARAMETER                                      , 0x3700),
    MAKE_IT(SAVING_PARAMETERS_NOT_SUPPORTED                        , 0x3900),
    MAKE_IT(MEDIUM_NOT_PRESENT                                     , 0x3A00),
    MAKE_IT(MEDIUM_NOT_PRESENT__TRAY_CLOSED                        , 0x3A01),
    MAKE_IT(MEDIUM_NOT_PRESENT__TRAY_OPEN                          , 0x3A02),
    MAKE_IT(SEQUENTIAL_POSITIONING_ERROR                           , 0x3B00),
    MAKE_IT(TAPE_POSITION_ERROR_AT_BEGINNING_OF_MEDIUM             , 0x3B01),
    MAKE_IT(TAPE_POSITION_ERROR_AT_END_OF_MEDIUM                   , 0x3B02),
    MAKE_IT(TAPE_OR_ELECTRONIC_VERTICAL_FORMS_UNIT_NOT_READY       , 0x3B03),
    MAKE_IT(SLEW_FAILURE                                           , 0x3B04),
    MAKE_IT(PAPER_JAM                                              , 0x3B05),
    MAKE_IT(FAILED_TO_SENSE_TOP_OF_FORM                            , 0x3B06),
    MAKE_IT(FAILED_TO_SENSE_BOTTOM_OF_FORM                         , 0x3B07),
    MAKE_IT(REPOSITION_ERROR                                       , 0x3B08),
    MAKE_IT(READ_PAST_END_OF_MEDIUM                                , 0x3B09),
    MAKE_IT(READ_PAST_BEGINNING_OF_MEDIUM                          , 0x3B0A),
    MAKE_IT(POSITION_PAST_END_OF_MEDIUM                            , 0x3B0B),
    MAKE_IT(POSITION_PAST_BEGINNING_OF_MEDIUM                      , 0x3B0C),
    MAKE_IT(MEDIUM_DESTINATION_ELEMENT_FULL                        , 0x3B0D),
    MAKE_IT(MEDIUM_SOURCE_ELEMENT_FULL                             , 0x3B0E),
    MAKE_IT(END_OF_MEDIUM_REACHED                                  , 0x3B0F),
    MAKE_IT(MEDIUM_MAGAZINE_NOT_ACCESSIBLE                         , 0x3B11),
    MAKE_IT(MEDIUM_MAGAZINE_REMOVED                                , 0x3B12),
    MAKE_IT(MEDIUM_MAGAZINE_INSERTED                               , 0x3B13),
    MAKE_IT(MEDIUM_MAGAZINE_LOCKED                                 , 0x3B14),
    MAKE_IT(MEDIUM_MAGAZINE_UNLOCKED                               , 0x3B15),
    MAKE_IT(MECHANICAL_POSITIONING_OR_CHANGER_ERROR                , 0x3B16),
    MAKE_IT(INVALID_BITS_IN_IDENTIFY_MESSAGE                       , 0x3D00),
    MAKE_IT(LU_HAS_NOT_SELF_CONFIGURED_YET                         , 0x3E00),
    MAKE_IT(LU_FAILURE                                             , 0x3E01),
    MAKE_IT(TIMEOUT_ON_LU                                          , 0x3E02),
    MAKE_IT(TARGET_OPERATING_CONDITIONS_HAVE_CHANGED               , 0x3F00),
    MAKE_IT(MICROCODE_HAS_BEEN_CHANGED                             , 0x3F01),
    MAKE_IT(CHANGED_OPERATING_DEFINITION                           , 0x3F02),
    MAKE_IT(INQUIRY_DATA_HAS_CHANGED                               , 0x3F03),
    MAKE_IT(_OBSOLETE__RAM_FAILURE                                 , 0x4000),
    // ALL 40/nn ARE VENDOR-UNIQUE NOTIFICATIONS OF FAILURE ON COMPONENT nn
    MAKE_IT(_OBSOLETE__DATA_PATH_FAILURE                           , 0x4100),
    MAKE_IT(_OSBOLETE__POWER_ON_OR_SELF_TEST_FAILURE               , 0x4200),
    MAKE_IT(MESSAGE_ERROR                                          , 0x4300),
    MAKE_IT(INTERNAL_TARGET_FAILURE                                , 0x4400),
    MAKE_IT(SELECT_OR_RESELECT_FAILURE                             , 0x4500),
    MAKE_IT(UNSUCCESSFUL_SOFT_RESET                                , 0x4600),
    MAKE_IT(SCSI_PARITY_ERROR                                      , 0x4700),
    MAKE_IT(INITIATOR_DETECTED_ERROR_MESSAGE_RECEIVED              , 0x4800),
    MAKE_IT(INVALID_MESSAGE_ERROR                                  , 0x4900),
    MAKE_IT(COMMAND_PHASE_ERROR                                    , 0x4A00),
    MAKE_IT(DATA_PHASE_ERROR                                       , 0x4B00),
    MAKE_IT(LOGICAL_UNIT_FAILED_SELF_CONFIGURATION                 , 0x4C00),
    // TAGGED_OVERLAPPED_COMMANDS
    MAKE_IT(OVERLAPPED_COMMANDS_ATTEMPTED                          , 0x4E00),
    MAKE_IT(WRITE_APPEND_ERROR                                     , 0x5000),
    MAKE_IT(WRITE_APPEND_POSITION_ERROR                            , 0x5001),
    MAKE_IT(POSITION_ERROR_RELATED_TO_TIMING                       , 0x5002),
    MAKE_IT(ERASE_FAILURE                                          , 0x5100),
    MAKE_IT(ERASE_FAILURE__INCOMPLETE_ERASE_DETECTED               , 0x5101),
    MAKE_IT(CARTRIDGE_FAULT                                        , 0x5200),
    MAKE_IT(MEDIA_LOAD_OR_EJECT_FAILURE                            , 0x5300),
    MAKE_IT(UNLOAD_TAPE_FAILURE                                    , 0x5301),
    MAKE_IT(MEDIUM_REMOVAL_PREVENTED                               , 0x5302),
    MAKE_IT(SCSI_TO_HOST_SYSTEM_INTERFACE_FAILURE                  , 0x5400),
    MAKE_IT(SYSTEM_RESOURCE_FAILURE                                , 0x5500),
    MAKE_IT(SYSTEM_BUFFER_FULL                                     , 0x5501),
    MAKE_IT(UNABLE_TO_RECOVER_TABLE_OF_CONTENTS                    , 0x5700),
    MAKE_IT(GENERATION_DOES_NOT_EXIST                              , 0x5800),
    MAKE_IT(UPDATED_BLOCK_READ                                     , 0x5900),
    MAKE_IT(OPERATOR_REQUEST_OR_STATE_CHANGE_INPUT                 , 0x5A00),
    MAKE_IT(OPERATOR_MEDIUM_REMOVAL_REQUEST                        , 0x5A01),
    MAKE_IT(OPERATOR_SELECTED_WRITE_PROTECT                        , 0x5A02),
    MAKE_IT(OPERATOR_SELECTED_WRITE_PERMIT                         , 0x5A03),
    MAKE_IT(LOG_EXCEPTION                                          , 0x5B00),
    MAKE_IT(THRESHOLD_CONDITION_MET                                , 0x5B01),
    MAKE_IT(LOG_COUNTER_AT_MAXIMUM                                 , 0x5B02),
    MAKE_IT(LOG_LIST_CODES_EXHAUSTED                               , 0x5B03),
    MAKE_IT(RPL_STATUS_CHANGE                                      , 0x5C00),
    MAKE_IT(SPINDLES_SYNCHRONIZED                                        , 0x5C01),
    MAKE_IT(SPINDLES_NOT_SYNCHRONIZED                                    , 0x5C02),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__LU_FAILURE            , 0x5D00),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__MEDIA_FAILURE         , 0x5D01),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__SPARE_AREA_EXHAUSTION , 0x5D03),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__TEST_VALUE            , 0x5DFF),
    MAKE_IT(LOW_POWER_CONDITION_ON                                       , 0x5E00),
    MAKE_IT(IDLE_CONDITION_ACTIVATED_BY_TIMER                            , 0x5E01),
    MAKE_IT(STANDBY_CONDITION_ACTIVATED_BY_TIMER                         , 0x5E02),
    MAKE_IT(IDLE_CONDITION_ACTIVATED_BY_COMMAND                          , 0x5E03),
    MAKE_IT(STANDBY_CONDITION_ACTIVATED_BY_COMMAND                       , 0x5E04),
    MAKE_IT(LAMP_FAILURE                                                 , 0x6000),
    MAKE_IT(VIDEO_ACQUISITION_ERROR                                      , 0x6100),
    MAKE_IT(UNABLE_TO_ACQUIRE_VIDEO                                      , 0x6101),
    MAKE_IT(OUT_OF_FOCUS                                                 , 0x6102),
    MAKE_IT(SCAN_HEAD_POSITIONING_ERROR                                  , 0x6200),
    MAKE_IT(END_OF_USER_AREA_ENCOUNTERED_ON_THIS_TRACK                   , 0x6300),
    MAKE_IT(PACKET_DOES_NOT_FIT_IN_AVAILABLE_SPACE                       , 0x6301),
    MAKE_IT(ILLEGAL_MODE_FOR_THIS_TRACK                                  , 0x6400),
    MAKE_IT(INVALID_PACKET_SIZE                                          , 0x6401),
    MAKE_IT(VOLTAGE_FAULT                                                , 0x6500),
    MAKE_IT(AUTOMATIC_DOCUMENT_FEEDER_COVER_UP                           , 0x6600),
    MAKE_IT(AUTOMATIC_DOCUMENT_FEEDER_LIFT_UP                            , 0x6601),
    MAKE_IT(DOCUMENT_JAM_IN_AUTOMATIC_DOCUMENT_FEEDER                    , 0x6602),
    MAKE_IT(DOCUMENT_MISS_FEED_AUTOMATIC_IN_DOCUMENT_FEEDER              , 0x6603),
    MAKE_IT(CONFIGURATION_FAILURE                                        , 0x6700),
    MAKE_IT(CONFIGURATION_OF_INCAPABLE_LOGICAL_UNITS_FAILED              , 0x6701),
    MAKE_IT(ADD_LOGICAL_UNIT_FAILED                                      , 0x6702),
    MAKE_IT(MODIFICATION_OF_LOGICAL_UNIT_FAILED                          , 0x6703),
    MAKE_IT(EXCHANGE_OF_LOGICAL_UNIT_FAILED                              , 0x6704),
    MAKE_IT(REMOVE_OF_LOGICAL_UNIT_FAILED                                , 0x6705),
    MAKE_IT(ATTACHMENT_OF_LOGICAL_UNIT_FAILED                            , 0x6706),
    MAKE_IT(CREATION_OF_LOGICAL_UNIT_FAILED                              , 0x6707),
    MAKE_IT(LOGICAL_UNIT_NOT_CONFIGURED                                  , 0x6800),
    MAKE_IT(DATA_LOSS_ON_LOGICAL_UNIT                                    , 0x6900),
    MAKE_IT(MULTIPLE_LOGICAL_UNIT_FAILURES                               , 0x6901),
    MAKE_IT(A_PARITY__DATA_MISMATCH                                      , 0x6902),
    MAKE_IT(INFORMATIONAL__REFER_TO_LOG                                  , 0x6A00),
    MAKE_IT(STATE_CHANGE_HAS_OCCURRED                                    , 0x6B00),
    MAKE_IT(REDUNDANCY_LEVEL_GOT_BETTER                                  , 0x6B01),
    MAKE_IT(REDUNDANCY_LEVEL_GOT_WORSE                                   , 0x6B02),
    MAKE_IT(REBUILD_FAILURE_OCCURRED                                     , 0x6C00),
    MAKE_IT(RECALCULATE_FAILURE_OCCURRED                                  , 0x6D00),
    MAKE_IT(COMMAND_TO_LOGICAL_UNIT_FAILED                                , 0x6E00),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__AUTHENTICATION_FAILURE  , 0x6F00),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__KEY_NOT_PRESENT         , 0x6F01),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__KEY_NOT_ESTABLISHED     , 0x6F02),
    MAKE_IT(READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION               , 0x6F03),
    MAKE_IT(MEDIA_REGION_CODE_IS_MISMATCHED_TO_LOGICAL_UNIT_REGION        , 0x6F04),
    MAKE_IT(DRIVE_REGION_MUST_BE_PERMANENT_REGION_RESET_COUNT_ERROR       , 0x6F05),
    // DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF NN                   = 0x70NN,
    MAKE_IT(DECOMPRESSION_EXCEPTION_LONG_ALGORITHM_ID                     , 0x7100),
    MAKE_IT(SESSION_FIXATION_ERROR                                        , 0x7200),
    MAKE_IT(SESSION_FIXATION_ERROR_WRITING_LEAD_IN                        , 0x7201),
    MAKE_IT(SESSION_FIXATION_ERROR_WRITING_LEAD_OUT                       , 0x7202),
    MAKE_IT(SESSION_FIXATION_ERROR__INCOMPLETE_TRACK_IN_SESSION           , 0x7203),
    MAKE_IT(EMPTY_OR_PARTIALLY_WRITTEN_RESERVED_TRACK                     , 0x7204),
    MAKE_IT(NO_MORE_RZONE_RESERVATIONS_ARE_ALLOWED                        , 0x7205),
    MAKE_IT(CD_CONTROL_ERROR                                              , 0x7300),
    MAKE_IT(POWER_CALIBRATION_AREA_ALMOST_FULL                            , 0x7301),
    MAKE_IT(POWER_CALIBRATION_AREA_IS_FULL                                , 0x7302),
    MAKE_IT(POWER_CALIBRATION_AREA_ERROR                                  , 0x7303),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_UPDATE_FAILURE                        , 0x7304),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_IS_FULL                               , 0x7305),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_IS_ALMOST_FULL                        , 0x7306),
};

#undef MAKE_IT
#define MAKE_IT(name, number) \
    SPTLIB_##name = number

typedef enum _SCSI_ASC_ASCQ_RETURN_VALUES {
    MAKE_IT(NO_ADDITIONAL_SENSE_INFORMATION                        , 0x0000),
    MAKE_IT(FILEMARK_DETECTED                                      , 0x0001),
    MAKE_IT(END_OF_PARTITION_OR_MEDIUM_DETECTED                    , 0x0002),
    MAKE_IT(SETMARK_DETECTED                                       , 0x0003),
    MAKE_IT(BEGINNING_OF_PARTITION_OR_MEDIUM_DETECTED              , 0x0004),
    MAKE_IT(END_OF_DATA_DETECTED                                   , 0x0005),
    MAKE_IT(PLAY_OPERATION_ABORTED                                 , 0x0006),
    MAKE_IT(AUDIO_PLAY_OPERATION_IN_PROGRESS                       , 0x0011),
    MAKE_IT(AUDIO_PLAY_OPERATION_PAUSED                            , 0x0012),
    MAKE_IT(AUDIO_PLAY_OPERATION_SUCCESSFULLY_COMPLETED            , 0x0013),
    MAKE_IT(AUDIO_PLAY_OPERATION_STOPPED_DUE_TO_ERROR              , 0x0014),
    MAKE_IT(NO_CURRENT_AUDIO_STATUS_TO_RETURN                      , 0x0015),
    MAKE_IT(OPERATION_IN_PROGRESS                                  , 0x0016),
    MAKE_IT(CLEANING_REQUESTED                                     , 0x0017),
    MAKE_IT(NO_INDEX_OR_SECTOR_SIGNAL                              , 0x0100),
    MAKE_IT(NO_SEEK_COMPLETE                                       , 0x0200),
    MAKE_IT(PERIPHERAL_DEVICE_WRITE_FAULT                          , 0x0300),
    MAKE_IT(NO_WRITE_CURRENT                                       , 0x0301),
    MAKE_IT(EXCESSIVE_WRITE_ERRORS                                 , 0x0302),
    MAKE_IT(LU_NOT_READY_CAUSE_NOT_REPORTABLE                      , 0x0400),
    MAKE_IT(LU_NOT_READY_BECOMING_READY                            , 0x0401),
    MAKE_IT(LU_NOT_READY_INIT_COMMAND_REQUIRED                     , 0x0402),
    MAKE_IT(LU_NOT_READY_MANUAL_INTERVENTION_REQUIRED              , 0x0403),
    MAKE_IT(LU_NOT_READY_FORMAT_IN_PROGRESS                        , 0x0404),
    MAKE_IT(LU_NOT_READY_REBUILD_IN_PROGRESS                       , 0x0405),
    MAKE_IT(LU_NOT_READY_RECALCULATION_IN_PROGRESS                 , 0x0406),
    MAKE_IT(LU_NOT_READY_OPERATION_IN_PROGRESS                     , 0x0407),
    MAKE_IT(LU_NOT_READY_LONG_WRITE_IN_PROGRESS                    , 0x0408),
    MAKE_IT(LU_DOES_NOT_RESPOND_TO_SELECTION                       , 0x0500),
    MAKE_IT(NO_REFERENCE_POSITION_FOUND__MEDIUM_MAY_BE_UPSIDE_DOWN , 0x0600),
    MAKE_IT(MULTIPLE_PERIPHERAL_DEVICES_SELECTED                   , 0x0700),
    MAKE_IT(LU_COMMUNICATION_FAILURE                               , 0x0800),
    MAKE_IT(LU_COMMUNICATION_TIMEOUT                               , 0x0801),
    MAKE_IT(LU_COMMUNICATION_PARITY_ERROR                          , 0x0802),
    MAKE_IT(LU_COMMUNICATION_CRC_ERROR_UDMA32                      , 0x0803),
    MAKE_IT(TRACK_FOLLOWING_ERROR                                  , 0x0900),
    MAKE_IT(TRACKING_SERVO_FAILURE                                 , 0x0901),
    MAKE_IT(FOCUS_SERVO_FAILURE                                    , 0x0902),
    MAKE_IT(SPINDLE_SERVO_FAILURE                                  , 0x0903),
    MAKE_IT(HEAD_SELECT_FAULT                                      , 0x0904),
    MAKE_IT(ERROR_LOG_OVERFLOW                                     , 0x0A00),
    MAKE_IT(WARNING                                                , 0x0B00),
    MAKE_IT(WARNING_SPECIFIED_TEMPERATURE_EXCEEDED                 , 0x0B01),
    MAKE_IT(WARNING_ENCLOSURE_DEGRADED                             , 0x0B02),
    MAKE_IT(WRITE_ERROR                                            , 0x0C00),
    MAKE_IT(WRITE_ERROR__RECOVERED_WITH_AUTO_REALLOCATION          , 0x0C01),
    MAKE_IT(WRITE_ERROR__AUTO_REALLOCATION_FAILED                  , 0x0C02),
    MAKE_IT(WRITE_ERROR__RECOMMEND_REASSIGNMENT                    , 0x0C03),
    MAKE_IT(COMPRESSION_CHECK_MISCOMPARE_ERROR                     , 0x0C04),
    MAKE_IT(DATA_EXPANSION_OCCURRED_DURING_COMPRESSION             , 0x0C05),
    MAKE_IT(BLOCK_NOT_COMPRESSABLE                                 , 0x0C06),
    MAKE_IT(WRITE_ERROR__RECOVERY_NEEDED                           , 0x0C07),
    MAKE_IT(WRITE_ERROR__RECOVERY_FAILED                           , 0x0C08),
    MAKE_IT(WRITE_ERROR__LOSS_OF_STREAMING                         , 0x0C09),
    MAKE_IT(WRITE_ERROR__PADDING_BLOCKS_ADDED                      , 0x0C0A),
    MAKE_IT(ID_CRC_OR_ECC_ERROR                                    , 0x1000),
    MAKE_IT(UNRECOVERED_READ_ERROR                                 , 0x1100),
    MAKE_IT(READ_RETRIES_EXHAUSTED                                 , 0x1101),
    MAKE_IT(ERROR_TOO_LONG_TO_CORRECT                              , 0x1102),
    MAKE_IT(MULTIPLE_READ_ERRORS                                   , 0x1103),
    MAKE_IT(UNRECOVERED_READ_ERROR__AUTO_REALLOCATE_FAILED         , 0x1104),
    MAKE_IT(LEC_UNCORRECTABLE_ERROR                                , 0x1105),
    MAKE_IT(CIRC_UNCORRECTABLE_ERROR                               , 0x1106),
    MAKE_IT(RESYNCHRONIZATION_ERROR                                , 0x1107),
    MAKE_IT(INCOMPLETE_BLOCK_READ                                  , 0x1108),
    MAKE_IT(NO_GAP_FOUND                                           , 0x1109),
    MAKE_IT(MISCORRECTED_ERROR                                     , 0x110A),
    MAKE_IT(UNRECOVERED_READ_ERROR__RECOMMEND_REASSIGNMENT         , 0x110B),
    MAKE_IT(UNRECOVERED_READ_ERROR__RECOMMEND_REWRITE_DATA         , 0x110C),
    MAKE_IT(DECOMPRESSION_CRC_ERROR                                , 0x110D),
    MAKE_IT(CANNOT_DECOMPRESS_USING_DECLARED_ALGORITHM             , 0x110E),
    MAKE_IT(ERROR_READING_UPC_OR_EAN_NUMBER                        , 0x110F),
    MAKE_IT(ERROR_READING_ISRC_NUMBER                              , 0x1110),
    MAKE_IT(READ_ERROR__LOSS_OF_STREAMING                          , 0x1111),
    MAKE_IT(ADDRESS_MARK_NOT_FOUND_FOR_ID_FIELD                    , 0x1200),
    MAKE_IT(ADDRESS_MARK_NOT_FOUND_FOR_DATA_FIELD                  , 0x1300),
    MAKE_IT(RECORDED_ENTITY_NOT_FOUND                              , 0x1400),
    MAKE_IT(RECORD_NOT_FOUND                                       , 0x1401),
    MAKE_IT(FILEMARK_OR_SETMARK_NOT_FOUND                          , 0x1402),
    MAKE_IT(END_OF_DATA_NOT_FOUND                                  , 0x1403),
    MAKE_IT(BLOCK_SEQUENCE_ERROR                                   , 0x1404),
    MAKE_IT(RECORD_NOT_FOUND__RECOMMEND_REASSIGNMENT               , 0x1405),
    MAKE_IT(RECORD_NOT_FOUND__DATA_AUTO_REALLOCATED                , 0x1406),
    MAKE_IT(RANDOM_POSITIONING_ERROR                               , 0x1500),
    MAKE_IT(MECHANICAL_POSITIONING_ERROR                           , 0x1501),
    MAKE_IT(POSITIONING_ERROR_DETECTED_BY_READ_OF_MEDIUM           , 0x1502),
    MAKE_IT(DATA_SYNCHRONIZATION_MARK_ERROR                        , 0x1600),
    MAKE_IT(DATA_SYNC_ERROR__DATA_REWRITTEN                        , 0x1601),
    MAKE_IT(DATA_SYNC_ERROR__RECOMMEND_REWRITE                     , 0x1602),
    MAKE_IT(DATA_SYNC_ERROR__DATA_AUTO_REALLOCATED                 , 0x1603),
    MAKE_IT(DATA_SYNC_ERROR__RECOMMEND_REASSIGNMENT                , 0x1604),
    MAKE_IT(RECOVERED_DATA_WITH_NO_ERROR_CORRECTION_APPLIED        , 0x1700),
    MAKE_IT(RECOVERED_DATA_WITH_RETRIES                            , 0x1701),
    MAKE_IT(RECOVERED_DATA_WITH_POSITIVE_HEAD_OFFSET               , 0x1702),
    MAKE_IT(RECOVERED_DATA_WITH_NEGATIVE_HEAD_OFFSET               , 0x1703),
    MAKE_IT(RECOVERED_DATA_WITH_RETRIES_AND_OR_CIRC_APPLIED        , 0x1704),
    MAKE_IT(RECOVERED_DATA_USING_PREVIOUS_SECTOR_ID                , 0x1705),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__DATA_AUTO_REALLOCATED      , 0x1706),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__RECOMMEND_REASSIGNMENT     , 0x1707),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__RECOMMEND_REWRITE          , 0x1708),
    MAKE_IT(RECOVERED_DATA_WITHOUT_ECC__DATA_REWRITTEN             , 0x1709),
    MAKE_IT(RECOVERED_DATA_WITH_ECC_APPLIED                        , 0x1800),
    MAKE_IT(RECOVERED_DATA_WITH_ECC_AND_RETRIES_APPLIED            , 0x1801),
    MAKE_IT(RECOVERED_DATA__DATA_AUTO_REALLOCATED                  , 0x1802),
    MAKE_IT(RECOVERED_DATA_WITH_CIRC                               , 0x1803),
    MAKE_IT(RECOVERED_DATA_WITH_LEC                                , 0x1804),
    MAKE_IT(RECOVERED_DATA__RECOMMEND_REASSIGNMENT                 , 0x1805),
    MAKE_IT(RECOVERED_DATA__RECOMMEND_REWRITE                      , 0x1806),
    MAKE_IT(RECOVERED_DATA_WITH_ECC__DATA_REWRITTEN                , 0x1807),
    MAKE_IT(RECOVERED_DATA_WITH_LINKING                            , 0x1808),
    MAKE_IT(DEFECT_LIST_ERROR                                      , 0x1900),
    MAKE_IT(DEFECT_LIST_NOT_AVAILABLE                              , 0x1901),
    MAKE_IT(DEFECT_LIST_ERROR_IN_PRIMARY_LIST                      , 0x1902),
    MAKE_IT(DEFECT_LIST_ERROR_IN_GROWN_LIST                        , 0x1903),
    MAKE_IT(PARAMETER_LIST_LENGTH_ERROR                            , 0x1A00),
    MAKE_IT(SYNCHRONOUS_DATA_TRANSFER_ERROR                        , 0x1B00),
    MAKE_IT(DEFECT_LIST_NOT_FOUND                                  , 0x1C00),
    MAKE_IT(PRIMARY_DEFECT_LIST_NOT_FOUND                          , 0x1C01),
    MAKE_IT(GROWN_DEFECT_LIST_NOT_FOUND                            , 0x1C02),
    MAKE_IT(MISCOMPARE_DURING_VERIFY_OPERATION                     , 0x1D00),
    MAKE_IT(RECOVERED_ID_WITH_ECC_CORRECTION                       , 0x1E00),
    MAKE_IT(PARTIAL_DEFECT_LIST_TRANSFER                           , 0x1F00),
    MAKE_IT(INVALID_COMMAND_OPERATION_CODE                         , 0x2000),
    MAKE_IT(LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     , 0x2100),
    MAKE_IT(INVALID_ELEMENT_ADDRESS                                , 0x2101),
    MAKE_IT(INVALID_ADDRESS_FOR_WRITE                              , 0x2102),
    MAKE_IT(_OBSOLETE__ILLEGAL_FUNCTION                            , 0x2200),
    MAKE_IT(INVALID_FIELD_IN_CDB                                   , 0x2400),
    MAKE_IT(LOGICAL_UNIT_NOT_SUPPORTED                             , 0x2500),
    MAKE_IT(INVALID_FIELD_IN_PARAMETER_LIST                        , 0x2600),
    MAKE_IT(PARAMETER_NOT_SUPPORTED                                , 0x2601),
    MAKE_IT(PARAMETER_VALUE_NOT_SUPPORTED                          , 0x2602),
    MAKE_IT(THRESHOLD_PARAMETERS_NOT_SUPPORTED                     , 0x2603),
    MAKE_IT(INVALID_RELEASE_OF_ACTIVE_PERSISTENT_RESERVATION       , 0x2604),
    MAKE_IT(WRITE_PROTECTED                                        , 0x2700),
    MAKE_IT(HARDWARE_WRITE_PROTECTED                               , 0x2701),
    MAKE_IT(LU_SOFTWARE_WRITE_PROTECTED                            , 0x2702),
    MAKE_IT(ASSOCIATED_WRITE_PROTECT                               , 0x2703),
    MAKE_IT(PERSISTENT_WRITE_PROTECT                               , 0x2704),
    MAKE_IT(PERMANENT_WRITE_PROTECT                                , 0x2705),
    MAKE_IT(CONDITIONAL_WRITE_PROTECT                              , 0x2706),
    MAKE_IT(NOT_READY_TO_READY__MEDIUM_MAY_HAVE_CHANGED            , 0x2800),
    MAKE_IT(IMPORT_OR_EXPORT_ELEMENT_ACCESSED                      , 0x2801),
    MAKE_IT(POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED            , 0x2900),
    MAKE_IT(POWER_ON_OCCURRED                                      , 0x2901),
    MAKE_IT(SCSI_BUS_RESET_OCCURRED                                , 0x2902),
    MAKE_IT(BUS_DEVICE_RESET_FUNCTION_OCCURRED                     , 0x2903),
    MAKE_IT(DEVICE_INTERNAL_RESET                                  , 0x2904),
    MAKE_IT(PARAMETERS_CHANGED                                     , 0x2A00),
    MAKE_IT(MODE_PARAMETERS_CHANGED                                , 0x2A01),
    MAKE_IT(LOG_PARAMETERS_CHANGED                                 , 0x2A02),
    MAKE_IT(RESERVATIONS_PREEMPTED                                 , 0x2A03),
    MAKE_IT(COPY_CANNOT_EXECUTE_SINCE_HOST_CANNOT_DISCONNECT       , 0x2B00),
    MAKE_IT(COMMAND_SEQUENCE_ERROR                                 , 0x2C00),
    MAKE_IT(TOO_MANY_WINDOWS_SPECIFIED                             , 0x2C01),
    MAKE_IT(INVALID_COMBINATION_OF_WINDOWS_SPECIFIED               , 0x2C02),
    MAKE_IT(CURRENT_PROGRAM_AREA_IS_NOT_EMPTY                      , 0x2C03),
    MAKE_IT(CURRENT_PROGRAM_AREA_IS_EMPTY                          , 0x2C04),
    MAKE_IT(PERSISTENT_PREVENT_CONFLICT                            , 0x2C05),
    MAKE_IT(OVERWRITE_ERROR_ON_UPDATE_IN_PLACE                     , 0x2D00),
    MAKE_IT(INSUFFICIENT_TIME_FOR_OPERATION                        , 0x2E00),
    MAKE_IT(COMMANDS_CLEARED_BY_ANOTHER_INITIATOR                  , 0x2F00),
    MAKE_IT(INCOMPATIBLE_MEDIUM_INSTALLED                          , 0x3000),
    MAKE_IT(CANNOT_READ_MEDIUM__UNKNOWN_FORMAT                     , 0x3001),
    MAKE_IT(CANNOT_READ_MEDIUM__INCOMPATIBLE_FORMAT                , 0x3002),
    MAKE_IT(CANNOT_READ_MEDIUM__CLEANING_CARTRIDGE_INSTALLED       , 0x3003),
    MAKE_IT(CANNOT_WRITE_MEDIUM__UNKNOWN_FORMAT                    , 0x3004),
    MAKE_IT(CANNOT_WRITE_MEDIUM__INCOMPATIBLE_FORMAT               , 0x3005),
    MAKE_IT(CANNOT_FORMAT_MEDIUM__INCOMPATIBLE_MEDIUM              , 0x3006),
    MAKE_IT(CLEANING_FAILURE                                       , 0x3007),
    MAKE_IT(CANNOT_WRITE__APPLICATION_CODE_MISMATCH                , 0x3008),
    MAKE_IT(CURRENT_SESSION_NOT_FIXATED_FOR_APPEND                 , 0x3009),
    MAKE_IT(MEDIUM_FORMAT_CORRUPTED                                , 0x3100),
    MAKE_IT(FORMAT_COMMAND_FAILED                                  , 0x3101),
    MAKE_IT(ZONED_FORMATTING_FAILED_DUE_TO_SPARE_LINKING           , 0x3102),
    MAKE_IT(NO_DEFECT_SPARE_LOCATION_AVAILABLE                     , 0x3200),
    MAKE_IT(DEFECT_LIST_UPDATE_FAILURE                             , 0x3201),
    MAKE_IT(TAPE_LENGTH_ERROR                                      , 0x3300),
    MAKE_IT(ENCLOSURE_FAILURE                                      , 0x3400),
    MAKE_IT(ENCLOSURE_SERVICES_FAILURE                             , 0x3500),
    MAKE_IT(UNSUPPORTED_ENCLOSURE_FUNCTION                         , 0x3501),
    MAKE_IT(ENCLOSURE_SERVICES_UNAVAILABLE                         , 0x3502),
    MAKE_IT(ENCLOSURE_SERVICES_TRANSFER_FAILURE                    , 0x3503),
    MAKE_IT(ENCLOSURE_SERVICES_TRANSFER_REFUSED                    , 0x3504),
    MAKE_IT(RIBBON_INK_OR_TONER_FAILURE                            , 0x3600),
    MAKE_IT(ROUNDED_PARAMETER                                      , 0x3700),
    MAKE_IT(SAVING_PARAMETERS_NOT_SUPPORTED                        , 0x3900),
    MAKE_IT(MEDIUM_NOT_PRESENT                                     , 0x3A00),
    MAKE_IT(MEDIUM_NOT_PRESENT__TRAY_CLOSED                        , 0x3A01),
    MAKE_IT(MEDIUM_NOT_PRESENT__TRAY_OPEN                          , 0x3A02),
    MAKE_IT(SEQUENTIAL_POSITIONING_ERROR                           , 0x3B00),
    MAKE_IT(TAPE_POSITION_ERROR_AT_BEGINNING_OF_MEDIUM             , 0x3B01),
    MAKE_IT(TAPE_POSITION_ERROR_AT_END_OF_MEDIUM                   , 0x3B02),
    MAKE_IT(TAPE_OR_ELECTRONIC_VERTICAL_FORMS_UNIT_NOT_READY       , 0x3B03),
    MAKE_IT(SLEW_FAILURE                                           , 0x3B04),
    MAKE_IT(PAPER_JAM                                              , 0x3B05),
    MAKE_IT(FAILED_TO_SENSE_TOP_OF_FORM                            , 0x3B06),
    MAKE_IT(FAILED_TO_SENSE_BOTTOM_OF_FORM                         , 0x3B07),
    MAKE_IT(REPOSITION_ERROR                                       , 0x3B08),
    MAKE_IT(READ_PAST_END_OF_MEDIUM                                , 0x3B09),
    MAKE_IT(READ_PAST_BEGINNING_OF_MEDIUM                          , 0x3B0A),
    MAKE_IT(POSITION_PAST_END_OF_MEDIUM                            , 0x3B0B),
    MAKE_IT(POSITION_PAST_BEGINNING_OF_MEDIUM                      , 0x3B0C),
    MAKE_IT(MEDIUM_DESTINATION_ELEMENT_FULL                        , 0x3B0D),
    MAKE_IT(MEDIUM_SOURCE_ELEMENT_FULL                             , 0x3B0E),
    MAKE_IT(END_OF_MEDIUM_REACHED                                  , 0x3B0F),
    MAKE_IT(MEDIUM_MAGAZINE_NOT_ACCESSIBLE                         , 0x3B11),
    MAKE_IT(MEDIUM_MAGAZINE_REMOVED                                , 0x3B12),
    MAKE_IT(MEDIUM_MAGAZINE_INSERTED                               , 0x3B13),
    MAKE_IT(MEDIUM_MAGAZINE_LOCKED                                 , 0x3B14),
    MAKE_IT(MEDIUM_MAGAZINE_UNLOCKED                               , 0x3B15),
    MAKE_IT(MECHANICAL_POSITIONING_OR_CHANGER_ERROR                , 0x3B16),
    MAKE_IT(INVALID_BITS_IN_IDENTIFY_MESSAGE                       , 0x3D00),
    MAKE_IT(LU_HAS_NOT_SELF_CONFIGURED_YET                         , 0x3E00),
    MAKE_IT(LU_FAILURE                                             , 0x3E01),
    MAKE_IT(TIMEOUT_ON_LU                                          , 0x3E02),
    MAKE_IT(TARGET_OPERATING_CONDITIONS_HAVE_CHANGED               , 0x3F00),
    MAKE_IT(MICROCODE_HAS_BEEN_CHANGED                             , 0x3F01),
    MAKE_IT(CHANGED_OPERATING_DEFINITION                           , 0x3F02),
    MAKE_IT(INQUIRY_DATA_HAS_CHANGED                               , 0x3F03),
    MAKE_IT(_OBSOLETE__RAM_FAILURE                                 , 0x4000),
    // ALL 40/nn ARE VENDOR-UNIQUE NOTIFICATIONS OF FAILURE ON COMPONENT nn
    MAKE_IT(_OBSOLETE__DATA_PATH_FAILURE                           , 0x4100),
    MAKE_IT(_OSBOLETE__POWER_ON_OR_SELF_TEST_FAILURE               , 0x4200),
    MAKE_IT(MESSAGE_ERROR                                          , 0x4300),
    MAKE_IT(INTERNAL_TARGET_FAILURE                                , 0x4400),
    MAKE_IT(SELECT_OR_RESELECT_FAILURE                             , 0x4500),
    MAKE_IT(UNSUCCESSFUL_SOFT_RESET                                , 0x4600),
    MAKE_IT(SCSI_PARITY_ERROR                                      , 0x4700),
    MAKE_IT(INITIATOR_DETECTED_ERROR_MESSAGE_RECEIVED              , 0x4800),
    MAKE_IT(INVALID_MESSAGE_ERROR                                  , 0x4900),
    MAKE_IT(COMMAND_PHASE_ERROR                                    , 0x4A00),
    MAKE_IT(DATA_PHASE_ERROR                                       , 0x4B00),
    MAKE_IT(LOGICAL_UNIT_FAILED_SELF_CONFIGURATION                 , 0x4C00),
    // TAGGED_OVERLAPPED_COMMANDS
    MAKE_IT(OVERLAPPED_COMMANDS_ATTEMPTED                          , 0x4E00),
    MAKE_IT(WRITE_APPEND_ERROR                                     , 0x5000),
    MAKE_IT(WRITE_APPEND_POSITION_ERROR                            , 0x5001),
    MAKE_IT(POSITION_ERROR_RELATED_TO_TIMING                       , 0x5002),
    MAKE_IT(ERASE_FAILURE                                          , 0x5100),
    MAKE_IT(ERASE_FAILURE__INCOMPLETE_ERASE_DETECTED               , 0x5101),
    MAKE_IT(CARTRIDGE_FAULT                                        , 0x5200),
    MAKE_IT(MEDIA_LOAD_OR_EJECT_FAILURE                            , 0x5300),
    MAKE_IT(UNLOAD_TAPE_FAILURE                                    , 0x5301),
    MAKE_IT(MEDIUM_REMOVAL_PREVENTED                               , 0x5302),
    MAKE_IT(SCSI_TO_HOST_SYSTEM_INTERFACE_FAILURE                  , 0x5400),
    MAKE_IT(SYSTEM_RESOURCE_FAILURE                                , 0x5500),
    MAKE_IT(SYSTEM_BUFFER_FULL                                     , 0x5501),
    MAKE_IT(UNABLE_TO_RECOVER_TABLE_OF_CONTENTS                    , 0x5700),
    MAKE_IT(GENERATION_DOES_NOT_EXIST                              , 0x5800),
    MAKE_IT(UPDATED_BLOCK_READ                                     , 0x5900),
    MAKE_IT(OPERATOR_REQUEST_OR_STATE_CHANGE_INPUT                 , 0x5A00),
    MAKE_IT(OPERATOR_MEDIUM_REMOVAL_REQUEST                        , 0x5A01),
    MAKE_IT(OPERATOR_SELECTED_WRITE_PROTECT                        , 0x5A02),
    MAKE_IT(OPERATOR_SELECTED_WRITE_PERMIT                         , 0x5A03),
    MAKE_IT(LOG_EXCEPTION                                          , 0x5B00),
    MAKE_IT(THRESHOLD_CONDITION_MET                                , 0x5B01),
    MAKE_IT(LOG_COUNTER_AT_MAXIMUM                                 , 0x5B02),
    MAKE_IT(LOG_LIST_CODES_EXHAUSTED                               , 0x5B03),
    MAKE_IT(RPL_STATUS_CHANGE                                      , 0x5C00),
    MAKE_IT(SPINDLES_SYNCHRONIZED                                        , 0x5C01),
    MAKE_IT(SPINDLES_NOT_SYNCHRONIZED                                    , 0x5C02),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__LU_FAILURE            , 0x5D00),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__MEDIA_FAILURE         , 0x5D01),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__SPARE_AREA_EXHAUSTION , 0x5D03),
    MAKE_IT(FAILURE_PREDICTION_THRESHOLD_EXCEEDED__TEST_VALUE            , 0x5DFF),
    MAKE_IT(LOW_POWER_CONDITION_ON                                       , 0x5E00),
    MAKE_IT(IDLE_CONDITION_ACTIVATED_BY_TIMER                            , 0x5E01),
    MAKE_IT(STANDBY_CONDITION_ACTIVATED_BY_TIMER                         , 0x5E02),
    MAKE_IT(IDLE_CONDITION_ACTIVATED_BY_COMMAND                          , 0x5E03),
    MAKE_IT(STANDBY_CONDITION_ACTIVATED_BY_COMMAND                       , 0x5E04),
    MAKE_IT(LAMP_FAILURE                                                 , 0x6000),
    MAKE_IT(VIDEO_ACQUISITION_ERROR                                      , 0x6100),
    MAKE_IT(UNABLE_TO_ACQUIRE_VIDEO                                      , 0x6101),
    MAKE_IT(OUT_OF_FOCUS                                                 , 0x6102),
    MAKE_IT(SCAN_HEAD_POSITIONING_ERROR                                  , 0x6200),
    MAKE_IT(END_OF_USER_AREA_ENCOUNTERED_ON_THIS_TRACK                   , 0x6300),
    MAKE_IT(PACKET_DOES_NOT_FIT_IN_AVAILABLE_SPACE                       , 0x6301),
    MAKE_IT(ILLEGAL_MODE_FOR_THIS_TRACK                                  , 0x6400),
    MAKE_IT(INVALID_PACKET_SIZE                                          , 0x6401),
    MAKE_IT(VOLTAGE_FAULT                                                , 0x6500),
    MAKE_IT(AUTOMATIC_DOCUMENT_FEEDER_COVER_UP                           , 0x6600),
    MAKE_IT(AUTOMATIC_DOCUMENT_FEEDER_LIFT_UP                            , 0x6601),
    MAKE_IT(DOCUMENT_JAM_IN_AUTOMATIC_DOCUMENT_FEEDER                    , 0x6602),
    MAKE_IT(DOCUMENT_MISS_FEED_AUTOMATIC_IN_DOCUMENT_FEEDER              , 0x6603),
    MAKE_IT(CONFIGURATION_FAILURE                                        , 0x6700),
    MAKE_IT(CONFIGURATION_OF_INCAPABLE_LOGICAL_UNITS_FAILED              , 0x6701),
    MAKE_IT(ADD_LOGICAL_UNIT_FAILED                                      , 0x6702),
    MAKE_IT(MODIFICATION_OF_LOGICAL_UNIT_FAILED                          , 0x6703),
    MAKE_IT(EXCHANGE_OF_LOGICAL_UNIT_FAILED                              , 0x6704),
    MAKE_IT(REMOVE_OF_LOGICAL_UNIT_FAILED                                , 0x6705),
    MAKE_IT(ATTACHMENT_OF_LOGICAL_UNIT_FAILED                            , 0x6706),
    MAKE_IT(CREATION_OF_LOGICAL_UNIT_FAILED                              , 0x6707),
    MAKE_IT(LOGICAL_UNIT_NOT_CONFIGURED                                  , 0x6800),
    MAKE_IT(DATA_LOSS_ON_LOGICAL_UNIT                                    , 0x6900),
    MAKE_IT(MULTIPLE_LOGICAL_UNIT_FAILURES                               , 0x6901),
    MAKE_IT(A_PARITY__DATA_MISMATCH                                      , 0x6902),
    MAKE_IT(INFORMATIONAL__REFER_TO_LOG                                  , 0x6A00),
    MAKE_IT(STATE_CHANGE_HAS_OCCURRED                                    , 0x6B00),
    MAKE_IT(REDUNDANCY_LEVEL_GOT_BETTER                                  , 0x6B01),
    MAKE_IT(REDUNDANCY_LEVEL_GOT_WORSE                                   , 0x6B02),
    MAKE_IT(REBUILD_FAILURE_OCCURRED                                     , 0x6C00),
    MAKE_IT(RECALCULATE_FAILURE_OCCURRED                                  , 0x6D00),
    MAKE_IT(COMMAND_TO_LOGICAL_UNIT_FAILED                                , 0x6E00),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__AUTHENTICATION_FAILURE  , 0x6F00),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__KEY_NOT_PRESENT         , 0x6F01),
    MAKE_IT(COPY_PROTECTION_KEY_EXCHANGE_FAILURE__KEY_NOT_ESTABLISHED     , 0x6F02),
    MAKE_IT(READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION               , 0x6F03),
    MAKE_IT(MEDIA_REGION_CODE_IS_MISMATCHED_TO_LOGICAL_UNIT_REGION        , 0x6F04),
    MAKE_IT(DRIVE_REGION_MUST_BE_PERMANENT_REGION_RESET_COUNT_ERROR       , 0x6F05),
    //SPTLIB_DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF NN              = 0x70NN,
    MAKE_IT(DECOMPRESSION_EXCEPTION_LONG_ALGORITHM_ID                     , 0x7100),
    MAKE_IT(SESSION_FIXATION_ERROR                                        , 0x7200),
    MAKE_IT(SESSION_FIXATION_ERROR_WRITING_LEAD_IN                        , 0x7201),
    MAKE_IT(SESSION_FIXATION_ERROR_WRITING_LEAD_OUT                       , 0x7202),
    MAKE_IT(SESSION_FIXATION_ERROR__INCOMPLETE_TRACK_IN_SESSION           , 0x7203),
    MAKE_IT(EMPTY_OR_PARTIALLY_WRITTEN_RESERVED_TRACK                     , 0x7204),
    MAKE_IT(NO_MORE_RZONE_RESERVATIONS_ARE_ALLOWED                        , 0x7205),
    MAKE_IT(CD_CONTROL_ERROR                                              , 0x7300),
    MAKE_IT(POWER_CALIBRATION_AREA_ALMOST_FULL                            , 0x7301),
    MAKE_IT(POWER_CALIBRATION_AREA_IS_FULL                                , 0x7302),
    MAKE_IT(POWER_CALIBRATION_AREA_ERROR                                  , 0x7303),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_UPDATE_FAILURE                        , 0x7304),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_IS_FULL                               , 0x7305),
    MAKE_IT(PROGRAM_MEMORY_AREA_RMA_IS_ALMOST_FULL                        , 0x7306),
} SCSI_ASC_ASCQ_RETURN_VALUES, *PSCSI_ASC_ASCQ_RETURN_VALUES;
#endif // 0


#pragma warning(pop)
#ifdef __cplusplus
}
#endif

#endif // __SPTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\shell\inc\badapps.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    badapp.h

Abstract:

    Declares the structures used for CheckBadApps data.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006

#define APPTYPE_FLAG_MASK     0xFFFFFF00

#define APPTYPE_FLAG_NONET    0x00000100
#define APPTYPE_FLAG_FAT32    0x00000200
#define APPTYPE_FLAG_NTFS     0x00000400

typedef struct {
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} BADAPP_PROP, *PBADAPP_PROP;

typedef struct {
    DWORD Size;
    PCTSTR FilePath;
    PBYTE Blob;
    DWORD BlobSize;
} BADAPP_DATA, *PBADAPP_DATA;

BOOL
SHIsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    );

#define EDIT    TRUE
#define NOEDIT  FALSE

// version allowances
#define VA_ALLOWMAINFILE     0x01
#define VA_ALLOWADDNLFILES   0x02

#define VA_ALLOWALLFILES     0x03

//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,
    VTID_PREVOSMAJORVERSION = VTID_REQFILE +21,
    VTID_PREVOSMINORVERSION = VTID_REQFILE +22,
    VTID_PREVOSPLATFORMID   = VTID_REQFILE +23,
    VTID_PREVOSBUILDNO      = VTID_REQFILE +24,

    // add new versions here

    VTID_LASTID
};

#define VERSION_STAMPS \
    LIBARGS(VTID_FILESIZE, ShCheckFileSize) \
    TOOLARGS(TEXT("FILESIZE"), TEXT("File Size:"), VA_ALLOWALLFILES, NOEDIT, QueryFileSize, OutputHexValue)\
    \
    LIBARGS(VTID_EXETYPE, ShCheckModuleType) \
    TOOLARGS(TEXT("EXETYPE"), TEXT("Module Type:"), VA_ALLOWADDNLFILES, NOEDIT, QueryModuleType, OutputModuleTypeValue)\
    \
    LIBARGS(VTID_BINFILEVER, ShCheckBinFileVer) \
    TOOLARGS(TEXT("BINFILEVER"), TEXT("Binary File Version:"), VA_ALLOWALLFILES, EDIT, QueryBinFileVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_BINPRODUCTVER, ShCheckBinProductVer) \
    TOOLARGS(TEXT("BINPRODUCTVER"), TEXT("Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_FILEDATEHI, ShCheckFileDateHi) \
    TOOLARGS(TEXT("FILEDATEHI"), TEXT("File Date (HI):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateHi, OutputHexValue)\
    \
    LIBARGS(VTID_FILEDATELO, ShCheckFileDateLo) \
    TOOLARGS(TEXT("FILEDATELO"), TEXT("File Date (LO):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateLo, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVEROS, ShCheckFileVerOs) \
    TOOLARGS(TEXT("FILEVEROS"), TEXT("File OS Version:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerOs, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVERTYPE, ShCheckFileVerType) \
    TOOLARGS(TEXT("FILEVERTYPE"), TEXT("File Type:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerType, OutputHexValue)\
    \
    LIBARGS(VTID_CHECKSUM, ShCheckFileCheckSum) \
    TOOLARGS(TEXT("CHECKSUM"), TEXT("File CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFileCheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_PECHECKSUM, ShCheckFilePECheckSum) \
    TOOLARGS(TEXT("PECHECKSUM"), TEXT("File Header CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFilePECheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_COMPANYNAME, ShCheckCompanyName) \
    TOOLARGS(TEXT("COMPANYNAME"), TEXT("Company Name:"), VA_ALLOWALLFILES, EDIT, QueryCompanyName, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTVERSION, ShCheckProductVersion) \
    TOOLARGS(TEXT("PRODUCTVERSION"), TEXT("Product Version:"), VA_ALLOWALLFILES, EDIT, QueryProductVersion, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTNAME, ShCheckProductName) \
    TOOLARGS(TEXT("PRODUCTNAME"), TEXT("Product Name:"), VA_ALLOWALLFILES, EDIT, QueryProductName, OutputStrValue)\
    \
    LIBARGS(VTID_FILEDESCRIPTION, ShCheckFileDescription) \
    TOOLARGS(TEXT("FILEDESCRIPTION"), TEXT("File Description:"), VA_ALLOWALLFILES, EDIT, QueryFileDescription, OutputStrValue)\
    \
    LIBARGS(VTID_FILEVERSION, ShCheckFileVersion) \
    TOOLARGS(TEXT("FILEVERSION"), TEXT("File Version:"), VA_ALLOWALLFILES, EDIT, QueryFileVersion, OutputStrValue)\
    \
    LIBARGS(VTID_ORIGINALFILENAME, ShCheckOriginalFileName) \
    TOOLARGS(TEXT("ORIGINALFILENAME"), TEXT("Original File Name:"), VA_ALLOWALLFILES, EDIT, QueryOriginalFileName, OutputStrValue)\
    \
    LIBARGS(VTID_INTERNALNAME, ShCheckInternalName) \
    TOOLARGS(TEXT("INTERNALNAME"), TEXT("Internal Name:"), VA_ALLOWALLFILES, EDIT, QueryInternalName, OutputStrValue)\
    \
    LIBARGS(VTID_LEGALCOPYRIGHT, ShCheckLegalCopyright) \
    TOOLARGS(TEXT("LEGALCOPYRIGHT"), TEXT("Legal Copyright:"), VA_ALLOWALLFILES, EDIT, QueryLegalCopyright, OutputStrValue)\
    \
    LIBARGS(VTID_16BITDESCRIPTION, ShCheck16BitDescription) \
    TOOLARGS(TEXT("DESCRIPTION"), TEXT("16 Bit Description:"), VA_ALLOWALLFILES, EDIT, Query16BitDescription, OutputStrValue)\
    \
    LIBARGS(VTID_UPTOBINPRODUCTVER, ShCheckUpToBinProductVer) \
    TOOLARGS(TEXT("UPTOBINPRODUCTVER"), TEXT("Up To Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputUpToBinVerValue)\
    \
    LIBARGS(VTID_PREVOSMAJORVERSION, ShCheckPrevOsMajorVersion) \
    TOOLARGS(TEXT("PREVOSMAJORVERSION"), TEXT("Previous OS Major Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMajorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSMINORVERSION, ShCheckPrevOsMinorVersion) \
    TOOLARGS(TEXT("PREVOSMINORVERSION"), TEXT("Previous OS Minor Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMinorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSPLATFORMID, ShCheckPrevOsPlatformId) \
    TOOLARGS(TEXT("PREVOSPLATFORMID"), TEXT("Previous OS Platform Id:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsPlatformId, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSBUILDNO, ShCheckPrevOsBuildNo) \
    TOOLARGS(TEXT("PREVOSBUILDNR"), TEXT("Previous OS Build No:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsBuildNo, OutputDecValue)\
    \

#define S_KEY_PREVOSVERSION     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PrevOsVersion")
#define S_VAL_BUILDNO           TEXT("BuildNumber")
#define S_VAL_MAJORVERSION      TEXT("MajorVersion")
#define S_VAL_MINORVERSION      TEXT("MinorVersion")
#define S_VAL_PLATFORMID        TEXT("PlatformId")

#define S_VER_COMPANYNAME       TEXT("CompanyName")
#define S_VER_PRODUCTVERSION    TEXT("ProductVersion")
#define S_VER_PRODUCTNAME       TEXT("ProductName")
#define S_VER_FILEDESCRIPTION   TEXT("FileDescription")
#define S_VER_FILEVERSION       TEXT("FileVersion")
#define S_VER_ORIGINALFILENAME  TEXT("OriginalFileName")
#define S_VER_INTERNALNAME      TEXT("InternalName")
#define S_VER_LEGALCOPYRIGHT    TEXT("LegalCopyright")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\shell\inc\cleanoc.h ===
#ifndef __CLEANOC_API__
#define __CLEANOC_API__

// Flags used in GetControlInfo()
#define GCI_NAME         1
#define GCI_FILE         2
#define GCI_CLSID        3
#define GCI_TYPELIBID    4
#define GCI_TOTALSIZE    5
#define GCI_SIZESAVED    6
#define GCI_TOTALFILES   7
#define GCI_CODEBASE     8
#define GCI_ISDISTUNIT   9
#define GCI_DIST_UNIT_VERSION 10
#define GCI_STATUS       11
#define GCI_HAS_ACTIVEX  12
#define GCI_HAS_JAVA     13

// control status flags
#define STATUS_CTRL_UNKNOWN             0   // Errors prevent determining the actual control state
#define STATUS_CTRL_INSTALLED           1   // Control is properly installed and ready for use
#define STATUS_CTRL_SHARED              2   // One or more components are shared by more than one control
#define STATUS_CTRL_DAMAGED             3   // The control file or some part of the installation is damaged or missing
#define STATUS_CTRL_UNPLUGGED           4   // The control has been re-registered in another location, the cache's
                                            // instance of the control is no longer being used.

// RemoveExpiredControls flags
#define REC_SILENT     1    // If set, controls whose deletion would require confirmation are not removed.

///////////////////////////////////////////////////////////////////////////////
// FindFirstControl
//
// Purpose:
//     Initiate a search on the registry for an installed ActiveX control.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h
//
// Parameters:
//     hFindHandle    -- a handle needed for resuming the search.  Caller must
//                       pass this handle to FindNextControl to retrieve the
//                       the next installed ActiveX control.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//     lpCachePath    -- points to a string buffer that has the path where
//                       all controls to be retrieved are located.  If it
//                       is NULL, the internet cache path will be read
//                       from the registry.  If a path is to be supplied,
//                       the path must be a full pathname without any ~'s
//                       in order for the enumeration to work correctly.
//
#define axcFINDFIRSTCONTROL "FindFirstControl"

LONG WINAPI FindFirstControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );

typedef LONG (WINAPI *FINDFIRSTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath /*= NULL*/
                     );


///////////////////////////////////////////////////////////////////////////////
// FindNextControl
//
// Purpose:
//     Resume a previously started search for installed ActiveX controls. The
//     search must have been initiated by a call to FirstFirstControl.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.  In this situation, the caller can choose to continue
//       the search with another call to FindNextControl, or simply abort.
//
// Parameters:
//     hFindHandle    -- a handle received from a call to FindFirstControl.
//                       Pass this handle to subsequent calls to
//                       FindNextControl to retrieve controls one at a time.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//
#define axcFINDNEXTCONTROL "FindNextControl"

LONG WINAPI FindNextControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

typedef LONG (WINAPI *FINDNEXTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

///////////////////////////////////////////////////////////////////////////////
// FindControlClose
//
// Purpose:
//     Called when search is over.  Missing a call to this function after a
//     search might contribute memory leak.  This function can be called
//     regardless of what FindFirstControl and/or FindNextControl return.
//
// Return Value:
//     None.
//
// Parameters:
//     hFindHandle -- a handle obtained from calls to FindFirstControl and
//                    FindNextControl in the current search.
//
#define axcFINDCONTROLCLOSE "FindControlClose"

void WINAPI FindControlClose(
                     HANDLE hFindHandle
                     );

typedef void (WINAPI *FINDCONTROLCLOSE)(
                     HANDLE hFindHandle
                     );


///////////////////////////////////////////////////////////////////////////////
// ReleaseControlHandle
//
// Purpose:
//     When a handle of a control is retrieved via FindFirstControl or
//     FindNextControl, the caller is responsible to release that handle
//     by call this function.
//
// Return Value:
//     None.
//
// Parameters:
//     hControlHandle -- a handle to a control obtained from FindFirstControl
//                       or FindNextControl.
//
#define axcRELEASECONTROLHANDLE "ReleaseControlHandle"

void WINAPI ReleaseControlHandle(
                          HANDLE hControlHandle
                          );

typedef void (WINAPI *RELEASECONTROLHANDLE)(
                          HANDLE hControlHandle
                          );


///////////////////////////////////////////////////////////////////////////////
// GetControlInfo
//
// Purpose:
//     Once a handle to a control is obtained via FindFirstControl or
//     FindNextControl, the caller may retrieve information about the control
//     by call this function with a flag (nFlag) indicating what info to
//     retrieve.  The supported flags are:
//     GCI_NAME       -- friendly name of control
//     GCI_FILE       -- main full path & file name of control
//     GCI_CLSID      -- clsid of control, in a NULL-terminated string
//     GCI_TYPELIBID  -- typelib guid of control, in a NULL-terminated string
//     GCI_TOTALSIZE  -- total size in bytes of all control's dependent files
//     GCI_SIZESAVED  -- total size in bytes restored if control is removed
//                       It can be different from GCI_TOTALSIZE since some
//                       of the control's dependent files might be shared dlls
//     GCI_TOTALFILES -- total number of control dependent files, including
//                       shared dlls if there are any
//     GCI_STATUS     -- the controls status value from STATUS_CTRL_* <above>
//     GCI_HAS_ACTIVEX -- non-zero if control includes ActiveX contols(s)
//     GCI_HAS_JAVA   -- non-zero if control includes Java packages
//
// Return Value:
//     TRUE if succeeded, FALSE otherwise.
//
// Parameters:
//     hControlHandle -- handle to a control for which information is to be
//                       retrieved.
//     nFlag          -- indicate which information to retrieve. Please refer
//                       to Purpose section above for a list of supported 
//                       flags.  nFlag can only equal to one of them so do
//                       not pass in multiple flags OR'ed together.
//     lpdwData       -- address of a buffer for storing a numerical value.
//                       (ie. GCI_TOTALSIZE, GCI_SIZESAVED & GCI_TOTALFILES)
//                       This parameter is ignored for other flags.
//     lpszData       -- address of a buffer for storing a NULL-terminated
//                       string value (ie. GCI_NAME, GCI_FILE, GCI_CLSID &
//                       GCI_TYPELIBID)  This paramter is ignored if other
//                       flags are specified.
//     nBufLen        -- length of string buffer pointed to by lpszData.
//                       This parameter is ignored if a numerical value is
//                       being retrieved.
//
#define axcGETCONTROLINFO "GetControlInfo"

BOOL WINAPI GetControlInfo(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );

typedef BOOL (WINAPI *GETCONTROLINFO)(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );


///////////////////////////////////////////////////////////////////////////////
// GetControlDependentFile
//
// Purpose:
//     A given control might depend on other files.  For instance, FOO.OCX
//     might need FOO.INF and MFCXX.DLL in order to work.  This function
//     retrieves one file at a time from a list of files depended upon by a
//     given ActiveX control.  The list of files is NOT sorted.
//
// Return Value:
//     - ERROR_SUCCESS if a file is found at position iFile in the list.
//     - ERROR_NO_MORE_FILES if no file is found at position iFile in the list.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.
//     
// Parameters:
//     iFile          -- a zero-based index indicating which file in the list
//                       to retrieve.
//     hControlHandle -- handle to a control obtained via FindFirstControl
//                       or FindNextControl.
//     lpszFile       -- points to a buffer used to store the retrieved name.
//     lpszSize       -- points to a DWORD variable that is to store the size
//                       in bytes of the file retrieved.  If it is 0, the file
//                       does not exist.
//     bToUpper       -- TRUE if the filename returned is to be converted to
//                       uppercase.  No conversion takes place if FALSE
//          
#define axcGETCONTROLDEPENDENTFILE "GetControlDependentFile"
         
LONG WINAPI GetControlDependentFile(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );

typedef LONG (WINAPI *GETCONTROLDEPENDENTFILE)(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// IsModuleRemovable
//
// Purpose:
//     Checks whether a file can be removed by looking into the registry.
//     This function is called "IsModuleRemovable" instead of
//     "IsFileRemovable" because this routine does not check the actual file
//     for its status.  For instance, a file can be deemed removable even if
//     is being exclusively opened by someone.  This routine only tells from
//     the registry's point of view if a file can be safely removed or not.
//
// Return Value:
//     - FALSE if there is any indication that the given file is being shared
//       by other applications.
//     - TRUE otherwise.
//
// Parameter: 
//     lpszFile -- points to a buffer that has the name (with full path) of
//                 the file whose removal status is to be verified.
//
#define axcISMODULEREMOVABLE "IsModuleRemovable"

BOOL WINAPI IsModuleRemovable(
             LPCTSTR lpszFile
             );

typedef BOOL (WINAPI *ISMODULEREMOVABLE)(
             LPCTSTR lpszFile
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByHandle
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpControlData -- points to an instance of CONTROL_DATA representing the
//                      control to be removed.  The struct must have been
//                      initialized by a call to FindFirstControl or
//                      FindNextControl.  Be sure to call ReleaseControlData
//                      on this struct after successful removal, for the data
//                      in this struct is no longer useful.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//
#define axcREMOVECONTROLBYHANDLE "RemoveControlByHandle"

HRESULT WINAPI RemoveControlByHandle(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYHANDLE)(
             HANDLE hControlHandle,
             BOOL bForceRemove /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByName
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  It is an overloaded version.
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpszFile      -- Address of a null-terminated string which is the main
//                      file for the control (ie "FOO.OCX" for FOO control).
//     lpszCLSID     -- Address of a null-terminated string which is the CLSID
//                      of the control.
//     lpszTypeLibID -- Address of a null-terminated string which is the TypeLib
//                      clsid of the control.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//     dwIsDistUnit  -- boolean value to tell if this is really a dist unit
//
#define axcREMOVECONTROLBYNAME "RemoveControlByName"

HRESULT WINAPI RemoveControlByName(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYNAME)(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove /*= FALSE*/,
             DWORD dwIsDistUnit /*= FALSE*/
             );


///////////////////////////////////////////////////////////////////////////////
// type PFNDOBEFOREREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right before removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the control will be removed.
//     If a fail code (E_XXX) is returned, the control will be skipped.
//
// Parameters:
//     HANDLE -- handle to the control to be removed.  One can get information
//               about the control using the GetControlInfo function.  Do NOT
//               call ReleaseControlHandle on the handle.
//     UINT   -- number of remaining controls including this one.
//
typedef HRESULT (CALLBACK *PFNDOBEFOREREMOVAL)(HANDLE, UINT);


///////////////////////////////////////////////////////////////////////////////
// type PFNDOAFTERREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right after removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the removal operation proceeds.
//     If a fail code (E_XXX) is returned, the removal operation is aborted.
//
// Parameters:
//     HRESULT -- result of removing the control.  The handle to this control
//                was passed to the callback of type PFNDOBEFOREREMOVAL before
//                the control was removed.  The possible values for this
//                HRESULT parameter are:
//                - S_OK (succeeded)
//                - S_FALSE (control had been removed with possibly some very
//                  minor errors)
//                - E_ACCESSDENIED (control not safe for removal)
//                - STG_E_SHAREVIOLATION (control being used by others)
//                - Other errors returned by registry functions
//                It is up to the implementator of this function to decide
//                what to do given the result of removing the last control.
//     UINT    -- number of remaining controls, NOT including the one just
//                removed.
//
typedef HRESULT (CALLBACK *PFNDOAFTERREMOVAL)(HRESULT, UINT);


///////////////////////////////////////////////////////////////////////////////
// SweepControlsByLastAccessDate
//
// Purpose:
//     Remove all controls whose last access date is before and on a given
//     date.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     pLastAccessTime -- specify a last access date.  All controls accessed
//                        before and on this date are to be removed.  Note
//                        that all fields except wYear, wMonth and wDay are
//                        ignored.  If NULL, all control will be removed.
//     pfnDoBefore     -- callback function called just before a control is
//                        removed.  Please read the description for type
//                        PFNDOBEFOREREMOVAL for details.  If NULL, nothing
//                        is to be done prior to removing a control.
//     pfnDoAfter      -- callback function called right after a control is
//                        removed.  Please read the description for type
//                        PFNDOAFTERREMOVAL for details.  If NULL, nothing
//                        is to be done after a control is removed.
//     dwSizeLimit     -- controls will be removed only if the total size
//                        (in bytes) of all controls exceeds the size
//                        specified by this paramter.  This parameter is
//                        ignored if 0 is specified.
//
#define axcSWEEPCONTROLSBYLASTACCESSDATE "SweepControlsByLastAccessDate"

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );

typedef HRESULT (WINAPI *SWEEPCONTROLSBYLASTACCESSDATE)(
                              SYSTEMTIME *pLastAccessTime /*= NULL*/,
                              PFNDOBEFOREREMOVAL pfnDoBefore /*= NULL*/,
                              PFNDOAFTERREMOVAL pfnDoAfter /*= NULL*/,
                              DWORD dwSizeLimit /*= 0*/
                              );


///////////////////////////////////////////////////////////////////////////////
// RemoveExpiredControls
//
// Purpose:
//     Similar to IEmptyVolumeCache. Removes all controls with a last
//     access date in the distant past and all controls flagged for more
//     rapid auto-expire.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     dwFlags         -- Currently, only REC_SILENT is defined.
//     dwReserved      -- Must be 0.
//
#define axcREMOVEEXPIREDCONTROLS "RemoveExpiredControls"

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *REMOVEEXPIREDCONTROLS)(DWORD dwFlags, DWORD dwReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\shell\inc\cmnquryp.h ===
#ifndef __cmnquryp_h
#define __cmnquryp_h

DEFINE_GUID(IID_IQueryFrame, 0x7e8c7c20, 0x7c9d, 0x11d0, 0x91, 0x3f, 0x0, 0xaa, 0x00, 0xc1, 0x6e, 0x65);
DEFINE_GUID(IID_IQueryHandler,  0xa60cc73f, 0xe0fc, 0x11d0, 0x97, 0x50, 0x0, 0xa0, 0xc9, 0x06, 0xaf, 0x45);

#ifndef GUID_DEFS_ONLY
#define CQFF_ISNEVERLISTED  0x0000004       // = 1 => form not listed in the form selector
#define CQPF_ISGLOBAL               0x00000001  // = 1 => this page is global, and added to all forms
#define OQWF_HIDESEARCHPANE         0x00000100 // = 1 => hide the search pane by on opening

//-----------------------------------------------------------------------------
// Query handler interfaces structures etc
//-----------------------------------------------------------------------------

//
// Query Scopes
// ============
//  A query scope is an opaque structure passed between the query handler
//  and the query frame.  When the handler is first invoked it is asked
//  to declare its scope objects, which inturn the frame holds.  When the
//  query is issued the scope is passed back to the handler.
//
//  When a scope is registered the cbSize field of the structure passed
//  is used to define how large the scope is, that entire blob is then
//  copied into a heap allocation.  Therefore allowing the handler
//  to create scope blocks on the stack, knowing that the frame will
//  take a copy when it calls the AddProc.
//

struct _cqscope;
typedef struct _cqscope CQSCOPE;
typedef CQSCOPE*        LPCQSCOPE;

typedef HRESULT (CALLBACK *LPCQSCOPEPROC)(LPCQSCOPE pScope, UINT uMsg, LPVOID pVoid);

struct _cqscope
{
    DWORD         cbStruct;
    DWORD         dwFlags;
    LPCQSCOPEPROC pScopeProc;
    LPARAM        lParam;
};

#define CQSM_INITIALIZE         0x0000000
#define CQSM_RELEASE            0x0000001
#define CQSM_GETDISPLAYINFO     0x0000003   // pVoid -> CQSCOPEDISPLAYINFO
#define CQSM_SCOPEEQUAL         0x0000004   // pVoid -> CQSCOPE

typedef struct
{
    DWORD  cbStruct;
    DWORD  dwFlags;
    LPWSTR pDisplayName;
    INT    cchDisplayName;
    LPWSTR pIconLocation;
    INT    cchIconLocation;
    INT    iIconResID;
    INT    iIndent;
} CQSCOPEDISPLAYINFO, * LPCQSCOPEDISPLAYINFO;


//
// Command ID's reserved for the frame to use when talking to
// the handler.  The handler must use only the IDs in the
// range defined by CQID_MINHANDLERMENUID and CQID_MAXHANDLERMENUID
//

#define CQID_MINHANDLERMENUID   0x0100
#define CQID_MAXHANDLERMENUID   0x4000                              // all handler IDs must be below this threshold

#define CQID_FILE_CLOSE         (CQID_MAXHANDLERMENUID + 0x0100)
#define CQID_VIEW_SEARCHPANE    (CQID_MAXHANDLERMENUID + 0x0101)

#define CQID_LOOKFORLABEL       (CQID_MAXHANDLERMENUID + 0x0200)
#define CQID_LOOKFOR            (CQID_MAXHANDLERMENUID + 0x0201)

#define CQID_LOOKINLABEL        (CQID_MAXHANDLERMENUID + 0x0202)
#define CQID_LOOKIN             (CQID_MAXHANDLERMENUID + 0x0203)
#define CQID_BROWSE             (CQID_MAXHANDLERMENUID + 0x0204)

#define CQID_FINDNOW            (CQID_MAXHANDLERMENUID + 0x0205)
#define CQID_STOP               (CQID_MAXHANDLERMENUID + 0x0206)
#define CQID_CLEARALL           (CQID_MAXHANDLERMENUID + 0x0207)

#define CQID_RESULTSLABEL       (CQID_MAXHANDLERMENUID + 0x0208)

//
// When calling IQueryHandler::ActivateView the following reason cod