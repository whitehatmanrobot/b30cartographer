 EM_GETRECT	   (WM_USER+2)
#define EM_SETRECT	   (WM_USER+3)
#define EM_SETRECTNP	   (WM_USER+4)
#define EM_SCROLL	   (WM_USER+5)
#define EM_LINESCROLL	   (WM_USER+6)
#define EM_GETMODIFY	   (WM_USER+8)
#define EM_SETMODIFY	   (WM_USER+9)
#define EM_GETLINECOUNT    (WM_USER+10)
#define EM_LINEINDEX	   (WM_USER+11)
#define EM_SETHANDLE	   (WM_USER+12)
#define EM_GETHANDLE	   (WM_USER+13)
#define EM_GETTHUMB	   (WM_USER+14)
#define EM_LINELENGTH	   (WM_USER+17)
#define EM_REPLACESEL	   (WM_USER+18)
#define EM_SETFONT	   (WM_USER+19)
#define EM_GETLINE	   (WM_USER+20)
#define EM_LIMITTEXT	   (WM_USER+21)
#define EM_CANUNDO	   (WM_USER+22)
#define EM_UNDO 	   (WM_USER+23)
#define EM_FMTLINES	   (WM_USER+24)
#define EM_LINEFROMCHAR    (WM_USER+25)
#define EM_SETWORDBREAK    (WM_USER+26)
#define EM_SETTABSTOPS	   (WM_USER+27)
#define EM_SETPASSWORDCHAR (WM_USER+28)
#define EM_EMPTYUNDOBUFFER (WM_USER+29)
#define EM_MSGMAX          (WM_USER+30)

#endif /* NOWINMESSAGES */


typedef WORD ICH;


typedef struct tagED
	{
	char *	hText;             // Block of text we are editing 
	ICH		cchAlloc;          // Number of chars we have allocated for hText 
	ICH		cchTextMax;        // Max number bytes allowed in edit control 
	ICH		cch;               // Current number of bytes of actual text 
   int      cLines;            // Number of lines of text 
	BYTE		charPasswordChar;  // If non null, display this character instead
										 // of the real text. So that we can implement
										 // hidden text fields. 

	BYTE		chFillDialog;

	HBRUSH	hbrDisabled;		// Disabled color brush. 
	HBRUSH	hbrEbBk;				// Background color brush.
	HBRUSH	hbrHiliteText;		// Hilite color brush


    ICH     ichMinSel;         // Selection extent.  MinSel is first selected                                   char 
    ICH     ichMaxSel;         // MaxSel is first unselected character 
    ICH     ichCaret;          // Caret location. Caret is on left side of                                   char 
    int     iCaretLine;        // The line the caret is on. So that if word
										 //	 wrapping, we can tell if the caret is at end
										 //	 of a line of at beginning of next line... 
    ICH     screenStart;       // Index of left most character displayed on
										 // screen for sl ec and index of top most line
										 // for multiline edit controls 
    int     ichLinesOnScreen;  // Number of lines we can display on screen 
    WORD    xOffset;           // x (horizontal) scroll position in pixels
										 // (for multiline text horizontal scroll bar) 
    WORD    cPasswordCharWidth;// Width of password char 
    HWND    hwnd;              // Window for this edit control 
    RECT    rcFmt;             // Client rectangle 
    HWND    hwndParent;        // Parent of this edit control window 
                               // These vars allow us to automatically scroll
										// when the user holds the mouse at the bottom
										// of the multiline edit control window. 
	 POINT   ptPrevMouse;       // Previous point for the mouse for system timer
    WORD    prevKeys;          // Previous key state for the mouse 
    WORD    fSingle       : 1; // Single line edit control? (or multiline) 
    WORD    fNoRedraw     : 1; // Redraw in response to a change? 
    WORD    fMouseDown    : 1; // Is mouse button down? when moving mouse 
    WORD    fFocus        : 1; // Does ec have the focus ? 
    WORD    fDirty        : 1; // Modify flag for the edit control 
    WORD    fDisabled     : 1; // Window disabled? 
    WORD    fNonPropFont  : 1; // Fixed width font? 
    WORD    fBorder       : 1; // Draw a border? 
    WORD    fAutoVScroll  : 1; // Automatically scroll vertically 
    WORD    fAutoHScroll  : 1; // Automatically scroll horizontally 
    WORD    fNoHideSel    : 1; // Hide sel when we lose focus? 
    WORD    fKanji        : 1;
    WORD    fFmtLines     : 1; // For multiline only. Do we insert CR CR LF at word wrap breaks? 
    WORD    fWrap         : 1; // Do word wrapping? 
    WORD    fCalcLines    : 1; // Recalc ped->chLines array? (recalc line breaks? )
    WORD    fEatNextChar  : 1; // Hack for ALT-NUMPAD stuff with combo boxes.
											// If numlock is up, we want to eat the next
											// character generated by the keyboard driver
											// if user enter num pad ascii value...  
    WORD    fStripCRCRLF:1;     // CRCRLFs have been added to text. Strip them
											// before doing any internal edit control
											// stuff 
    WORD    fInDialogBox:1;     // True if the ml edit control is in a dialog
											// box and we have to specially treat TABS and ENTER 
    int     *chLines;          // index of the start of each line 
    WORD    format;            // Left, center, or right justify multiline	text
    LPSTR   (FAR *lpfnNextWord)(); // Next word function 
    ICH     maxPixelWidth;     // Width (in pixels) of longest line 
    WORD    undoType;          // Current type of undo we support 
    HANDLE  hDeletedText;      // Handle to text which has been deleted (for undo )
    ICH     ichDeleted;        // Starting index from which text was deleted
    ICH     cchDeleted;        // Count of deleted characters in buffer 
    ICH     ichInsStart;       // Starting index from which text was inserted 
    ICH     ichInsEnd;         // Ending index of inserted text 
//    HANDLE  hFont;             // Handle to the font for this edit control.
    int     aveCharWidth;      // Ave width of a character in the hFont 
    int     lineHeight;        // Height of a line in the hFont 
    int     charOverhang;      // Overhang associated with the hFont      
    int     cxSysCharWidth;    // System font ave width 
    int     cySysCharHeight;   // System font height 
    HWND    listboxHwnd;       // ListBox hwnd. Non null if we are a combo box
    int     *pTabStops;	       // Points to an array of tab stops; First
										// element contains the number of elements in
										// the array 
    HANDLE  charWidthBuffer;  
	} ED;

typedef ED *PED;


#endif //FULL_EDIT


#define GetDC(hWnd)	(hWnd)

#define ReleaseDC(hWnd, hDC)

#define UpdateWindow(pwnd)  XSendMessage((pwnd), WM_PAINT, 0, 0L )

VOID	FARPUBLIC InvalidateRect	( PVOID, NPRRC );			/*OPTIONAL*/

VOID FARPUBLIC GetClientRect(PVOID, RRC *);					/*OPTIONAL*/

VOID	FARPUBLIC SiblingToTop		(PVOID, BOOL);          /*OPTIONAL*/	

PWND	FARPUBLIC GetTopSibling	(PVOID);							/*OPTIONAL*/

BOOL	FARPUBLIC IsTopSibling	(PVOID);							/*OPTIONAL*/

#define GetWindowRect(hwnd, parc )	*(parc) = (hwnd)->arcWindow	

#define GetUpdateRect(hwnd, prrc, bErase )	*(prrc) = (hwnd)->rrcInvalid

VOID	FARPUBLIC FillRect	(PVOID, NPRRC, ACHAR, WORD);/*OPTIONAL*/

#define GetDesktopWindow()	pwndDesktop

PWND FARPUBLIC GetActiveWindow ( VOID );/*OPTIONAL*/

// winget.c
PWND FARPUBLIC GetWindow ( PVOID, WORD );
PWND FARPUBLIC GetTopWindow ( PVOID );

// GetWindow() Constants 

#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER		4
#define GW_CHILD		5

//wincoord.c
VOID FARPUBLIC ScreenToClient ( PVOID, NPARC, NPRRC );
VOID FARPUBLIC ClientToScreen ( PVOID, NPARC, NPRRC );

// winenum.c
BOOL FARPUBLIC EnumWindows ( PFFN, DWORD );
BOOL FARPUBLIC EnumChildWindows ( PVOID, PFFN, DWORD );

// winpos.c
VOID FARPUBLIC CloseWindow ( PVOID );

//winwhere.c
HWND FARPUBLIC WindowFromPoint ( AX, AY );
VOID	FARPUBLIC SetWindowPos ( PWND,HWND,AX,AY,BYTE,BYTE,WORD );

#ifndef NOCOLOR


// Color Types 
#define CTLCOLOR_MSGBOX		0
#define CTLCOLOR_EDIT		1
#define CTLCOLOR_LISTBOX	2
#define CTLCOLOR_BTN		3
#define CTLCOLOR_DLG		4
#define CTLCOLOR_SCROLLBAR	5
#define CTLCOLOR_STATIC		6
#define CTLCOLOR_MAX		8     /* three bits max */


//wincolor.c
BOOL FARPUBLIC SetSysColors ( WORD,WORD FAR *,WORD FAR * );
DWORD FARPUBLIC GetSysColor ( WORD );

// Defines for colors. These are Windows compatible, and we map
// them to internal isa defines within uisa.h ( ugh. )

#define COLOR_SCROLLBAR			0
#define COLOR_BACKGROUND		1
#define COLOR_ACTIVECAPTION	2
#define COLOR_INACTIVECAPTION	3
#define COLOR_MENU				4
#define COLOR_WINDOW				5
#define COLOR_WINDOWFRAME		6	
#define COLOR_MENUTEXT			7
#define COLOR_WINDOWTEXT		8
#define COLOR_CAPTIONTEXT		9
#define COLOR_ACTIVEBORDER		10
#define COLOR_INACTIVEBORDER	11
#define COLOR_APPWORKSPACE		12
#define COLOR_HIGHLIGHT			13
#define COLOR_HIGHLIGHTTEXT	14
#define COLOR_BTNFACE			15
#define COLOR_BTNSHADOW			16
#define COLOR_GRAYTEXT			17
#define COLOR_BTNTEXT			18
#define COLOR_ENDCOLORS 		COLOR_BTNTEXT

#endif

//sysmenu.c

// VOID** FARPUBLIC GetSystemMenu( PVOID, BOOL );

BOOL FARPUBLIC OpenSystemMenu ( PVOID );


//winmenu.c
#define	MF_BYPOSITION	0x0001
#define	MF_BYCOMMAND	0x0002
#define	MF_CHECKED		0x0004
#define	MF_UNCHECKED	0x0008
#define	MF_ENABLED		0x0010
#define	MF_DISABLED		0x0020
#define	MF_HILITE		0x0040
#define	MF_UNHILITE		0x0080


//wincaret.c

VOID FARPUBLIC ShowCaret ( PVOID );
VOID FARPUBLIC	SetCaretPos ( BYTE, BYTE );

VOID FARPUBLIC SetCaretBlinkTime ( WORD );
VOID FARPUBLIC	HideCaret ( PVOID );
VOID FARPUBLIC	GetCaretPos ( VOID * );
WORD FARPUBLIC	GetCaretBlinkTime (VOID );
VOID FARPUBLIC	DestroyCaret (VOID );
VOID FARPUBLIC	CreateCaret ( PVOID, HANDLE, WORD, WORD );

//wintext.c

DWORD FARPUBLIC GetTextExtent ( HDC, LPSTR, int );
int FARPUBLIC DrawText ( HDC, LPSTR, int, LPRECT, WORD );


// DrawText() Format Flags 

#define DT_TOP				0x0000
#define DT_LEFT			0x0000
#define DT_CENTER			0x0001
#define DT_RIGHT			0x0002
#define DT_VCENTER		0x0004
#define DT_BOTTOM			0x0008
#define DT_WORDBREAK		0x0010
#define DT_SINGLELINE	0x0020
#define DT_EXPANDTABS	0x0040
#define DT_TABSTOP		0x0080
#define DT_NOCLIP			0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT		0x0400
#define DT_NOPREFIX		0x0800
#define DT_INTERNAL		0x1000



typedef struct tagTEXTMETRIC
  {
    int 	tmHeight;
    int 	tmAscent;
    int 	tmDescent;
    int 	tmInternalLeading;
    int 	tmExternalLeading;
    int 	tmAveCharWidth;
    int 	tmMaxCharWidth;
    int 	tmWeight;
    BYTE	tmItalic;
    BYTE	tmUnderlined;
    BYTE	tmStruckOut;
    BYTE	tmFirstChar;
    BYTE	tmLastChar;
    BYTE	tmDefaultChar;
    BYTE	tmBreakChar;
    BYTE	tmPitchAndFamily;
    BYTE	tmCharSet;
    int 	tmOverhang;
    int 	tmDigitizedAspectX;
    int 	tmDigitizedAspectY;
  } TEXTMETRIC;

typedef TEXTMETRIC	    *PTEXTMETRIC;
typedef TEXTMETRIC NEAR     *NPTEXTMETRIC;
typedef TEXTMETRIC FAR	    *LPTEXTMETRIC;

BOOL FARPUBLIC GetTextMetrics ( HDC, LPTEXTMETRIC );

//winclip.c

BOOL FARPUBLIC	OpenClipboard ( PVOID );
HWND FARPUBLIC	GetClipboardOwner ( VOID );
HWND FARPUBLIC	GetClipboardViewer ( VOID );
HANDLE FARPUBLIC	GetClipboardData ( WORD );
BOOL FARPUBLIC	CloseClipboard ( VOID );

#ifndef NOCLIPBOARD

// Predefined Clipboard Formats 
#define CF_TEXT 	    1
#define CF_BITMAP	    2
#define CF_METAFILEPICT     3
#define CF_SYLK 	    4
#define CF_DIF		    5
#define CF_TIFF 	    6
#define CF_OEMTEXT	    7
#define CF_DIB		    8
#define CF_PALETTE	    9

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

#endif // NOCLIPBOARD 

//winrect.c
VOID FARPUBLIC InflateRect ( LPRECT, int, int );
VOID FARPUBLIC OffsetRect ( LPRECT, int, int );

//winscroll.c
VOID FARPUBLIC ScrollWindow(PVOID, int, int, LPRECT, LPRECT );



// The idStaticPath parameter to DlgDirList can have the following values
// ORed if the list box should show other details of the files along with
// the name of the files;

#define LBD_UPPERCASE  	0x8001	// Should the file name be in upper case 
#define LBD_SIZE			0x8002	// Should the file size be shown
#define LBD_DATE			0x8004	// Date stamp of the file to be shown ?
#define LBD_TIME			0x8008	// Time stamp of the file to be shown ?
#define LBD_ATTRIBUTE	0x8010	// The dos attributes of the file ?
#define LBD_FULLDETAILS 0x801E	// Name, size, date and time 
#define LBD_SENDDETAILS 0x8020	// In DlgDirSelect(), along with file name
											// all other details also will be returned

// DlgDirList flags values 
#define DDL_NORMAL	    0x0000
#define DDL_READWRITE    0x0001
#define DDL_READONLY	    0x0002
#define DDL_HIDDEN	    0x0004
#define DDL_SYSTEM	    0x0008
#define DDL_DIRECTORY    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE    0x8000
#define DDL_VALID			 0xe03f	/* ;Internal */


// A lot of these typedef's and macros should be made globally available.

typedef char *PSTR;

#define MAKEPOINT(l)		(*((POINT FAR *)&(l)))

#define lstrlen(sz) fstrlen((char far *)(sz))

#define lstrcpy(dest,src) fstrcpy((LPSTR)(dest), (LPSTR)(src))

typedef int near *PINT;

#define LCopyStruct(lpSrc,lpDest,cch) bltbytex(lpSrc,lpDest,cch)

#define SwapHandle(hHandle) 

DWORD FARPUBLIC SendDlgItemMessage ( HWND,WORD,WORD,WORD,DWORD );

#ifdef OLD_API
#include "old_api.h"
#endif

#endif //BROADSWORD
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\videoid.asm ===
;
; Name:         VideoID
;
; Function:     Detects the presence of various video subsystems and
;                associated monitors.
;
; Caller:       Microsoft C:
;
;                       void VideoID(VIDstruct);
;
;                       struct
;                       {
;                         char VideoSubsystem;
;                         char Display;
;                       }
;                               *VIDstruct[2];
;
;               Subsystem ID values:
;                                0  = (none)
;                                1  = MDA
;                                2  = CGA
;                                3  = EGA
;                                4  = MCGA
;                                5  = VGA
;                                6  = 8514/A
;                                7  = XGA
;                               80h = HGC
;                               81h = HGC+
;                               82h = Hercules InColor
;
;               Display types:   0  = (none)
;                                1  = MDA-compatible monochrome
;                                2  = CGA-compatible color
;                                3  = EGA-compatible color
;                                4  = PS/2-compatible monochrome
;                                5  = PS/2-compatible color
;                                6  = 8514/A Monitor
;
;
;       The values returned in VIDstruct[0].VideoSubsystem and
;       VIDstruct[0].Display indicate the currently active subsystem.
;
;----------------------------------------------------------------------------


cssize equ 2    ;Used for small memory model

ARGpVID         EQU     [bp+4+cssize]   ; Pointer to structure

VIDstruct       STRUC                   ; corresponds to C data structure

Video0Type      DB      ?               ; first subsystem type
Display0Type    DB      ?               ; display attached to first
                                        ;  subsystem
Mode0           DB      ?               ; Mode of first subsystem
NumCols0        DB      ?               ; Number of columns on first
iMemory0        DW      ?               ; Memory in first system
Video1Type      DB      ?               ; second subsystem type
Display1Type    DB      ?               ; display attached to second
                                        ;  subsystem
Mode1           DB      ?               ; Mode of second subsystem
NumCols1        DB      ?               ; Number of columns on second
iMemory1        DW      ?               ; Memory in second system

VIDstruct       ENDS


Device0          EQU     word ptr Video0Type[di]
Device1          EQU     word ptr Video1Type[di]


MDA              EQU     1               ; subsystem types
CGA              EQU     2
EGA              EQU     3
MCGA             EQU     4
VGA              EQU     5
Eighty514        EQU     6
XGA              EQU     7
HGC              EQU     80h
HGCPlus          EQU     81h
InColor          EQU     82h

MDADisplay       EQU     1               ; display types
CGADisplay       EQU     2
EGAColorDisplay  EQU     3
VGAMonoDisplay   EQU     4
VGAColorDisplay  EQU     5
Eighty514Display EQU     6

TRUE             EQU     1
FALSE            EQU     0


DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _VideoID
                EXTRN   C ArcnetCardPresent:FAR

_VideoID        PROC    far

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    es              ; Save caller's ES
                push    si
                push    di

; initialize the data structure that will contain the results

                les     di,ARGpVID  ; ES:DI -> start of data structure

                mov     es:Device0,0       ; zero these variables
                mov     es:Device1,0

; look for the various subsystems using the subroutines whose addresses are
;  tabulated in TestSequence; each subroutine sets flags in TestSequence
;  to indicate whether subsequent subroutines need to be called

                mov     byte ptr TestSequence,TRUE
                mov     byte ptr XGAflag,FALSE
                mov     byte ptr Eighty514flag,FALSE
                mov     byte ptr EGAflag,TRUE
                mov     byte ptr CGAflag,TRUE
                mov     byte ptr Monoflag,TRUE

                mov     cx,NumberOfTests
                mov     si,offset DGROUP:TestSequence

L01:            lodsb                   ; AL := flag
                test    al,al
                lodsw                   ; AX := subroutine address
                jz      L02             ; skip subroutine if flag is false

                push    si
                push    cx
                call    ax              ; call subroutine to detect
                                        ;  subsystem
                pop     cx
                pop     si

L02:            loop    L01

; determine which subsystem is active

                call    FindActive

                pop     di              ; restore caller registers and
                                        ;  return
                pop     si
                pop     es
                mov     sp,bp
                pop     bp
                ret

_VideoID        ENDP


; FindXGA
;
; Note:  XGA adapters MAY be able to be detected by checking port
; 2110H.  Read the port, toggle bit 0, write to the port, wait,
; read the port and see if the port's value is the changed.  If it
; did, it is an XGA.  Don't forget to toggle the bit back again,
; and it might not hurt to disable interrupts (CLI) during the check.
;
; Bit 0 toggles the XGA's coprocessor between Intel and Motorola
; modes (backwards storage for 16 and 32 bit values).  Also, the XGA
; standard allows for up to six XGA adapters to exist in a system
; at one time, each port address is 16 (10H) higher than the other.
; Checking 2120H, 2130H, 2140H, 2150H, and 2160H may be well advised.
;
; In the short time we had to hand over our code, I was not able to
; determine how to detect the monitor type attached to the XGA.
; Sorry about that.  Also, I was not able to test this XGA detection
; theory out (except to see that VGAs did NOT retain the toggling of
; bit zero).
;


FindXGA         PROC    near

         mov  bx, OFFSET DGROUP:rgXgaPorts ; Store the XGA port address array location

XgaTestLoop:
         mov  dx, [bx]            ; Get the XGA's port address
         and  dx, dx              ; Jump out if it's zero
         jz   fnXgaDone

         in   al, dx              ; Read the port
         mov  ch, al              ; Store the "original" port value

         xor  al, 1               ; change bit 0

         cli                      ; Clear all interrupts.  This is
                                  ;   important because this routine
                                  ;   changes the way the XGA functions.

         out  dx, al              ; Output the new value to the XGA port.

         jmp  short XgaWait01     ; Pause briefly, to allow the change
XgaWait01:                        ;   to take effect.
         jmp  short XgaWait02
XgaWait02:
         jmp  short XgaWait03
XgaWait03:

         in   al, dx              ; Get the "changed" value from the port.
         mov  cl, al              ; Store the "changed" value.

         mov  al, ch              ; Send the "original" back to the port.
         out  dx, al

         jmp  short XgaWait04     ; Pause briefly, to allow the change
XgaWait04:                        ;   to take effect.
         jmp  short XgaWait05
XgaWait05:
         jmp  short XgaWait06
XgaWait06:

         sti                      ; Restore all interrupts.

; I consider it a sucessful test if only bit zero changed.  More changes
;   might indicate that I am communicating with a different device.

         mov  ch, cl              ; Copy the "changed" port value to bh
         mov  ah, al              ; Copy the "original" port value to ah
         and  ch, 0FEh            ; Mask off bit 0 of "changed" value.
         and  ah, 0FEh            ; Mask off bit 0 of "original" value.

         cmp  ch, ah              ; Q: Do they match?
         jne  fnXgaNotFound       ; N: This is not an XGA port.

         cmp  cl, al              ; Q: Since bits 1-7 match, do all 8
                                  ;    bits match?
         jne  fnFoundXga          ; N: This is an XGA port.

; Keep looking
fnXgaNotFound:

         inc  bx                  ; Bump the port pointer.
         inc  bx
         jmp  short XgaTestLoop   ; Test the next port.


; This is an XGA.
fnFoundXga:

         mov  al, XGA             ; Say it is an XGA adapter.

; Currently, I do not have a test for the monitor.  I will assume it
;   is an 8514/A Monitor until I have an accurate test.

         mov  ah,Eighty514Display ; AH := Display type.

         call FoundDevice         ; Store the answer.

fnXgaDone:
         ret

FindXGA         ENDP


;
; Find8514
;
; This function detects the presence of an 8514 display card.
;
; The way we do this is to first write to the Error Term Register and then
; make sure we can read back the value we wrote. Then we check to see
; what kind of monitor is attached since the 8514 can function like a VGA.
;

Find8514        PROC    near

ERR_TERM        equ     92e8h     ; 8514 error term register.
SUBSYS_STAT     equ     42e8h     ; 8514 Subsystem status register.

         call ArcnetCardPresent
         or   ax,ax               ; if Arcnet Present do not do the 8514/a
         jnz  fn8514NotFound      ;   test as the Arcnet Card will be reset.

         mov  dx, ERR_TERM        ; load DX with port address (error term port
         in   ax, dx              ; Store original port value ...
         mov  ax, bx              ; ... in BX
         mov  ax, 5555h           ; load AX with value to write to port.
         out  dx, ax              ; Write the data.

         mov  cx, 10h             ; Wait for the port to respond
wait001: loop wait001

         in   ax, dx              ; Read the data back in.
         push ax                  ; Store the value on the stack for a moment
         mov  ax, bx              ; Restore the original value of the port
         out  dx, ax
         pop  ax                  ; Now restore the value we wish to check
         cmp  ax, 5555h           ; Q: is 8524 present ?
         jne  fn8514NotFound      ;   N: indicate 8514 not present.
                                  ;   Y: 8514 is present, now check monitor.
         ;
         ; Now we need to determine what type of monitor is attached to the
         ; 8514 card. To do this we check ID bits 0,1,2 in the subsystem
         ; status register. Depending on the Monitor attached we return:
         ;
         ; 8503 Display = VGAMonoDisplay
         ; 8512 Display = VGAColorDisplay
         ; 8513 Display = VGAColorDisplay
         ; 8514 Display = Eighty514Display
         ;
         mov  dx,SUBSYS_STAT      ; Now, we have the adapter. Check monitor.
         in   ax,dx               ; Get word from SUBSYS_STAT
         test ax,0040h            ; Check Bit 2.
         jz   Disp_8514           ; Bit 2 == 0 = 8514 Display = GAD_8514.
         test ax,0020h            ; Bit 1 == 0 = 8503 Display = VGA_MONO.
         jz   Disp_8503

         mov  ah,VGAColorDisplay  ; AH := Display type
         jmp  short fn8514Found

Disp_8503:
         mov  ah,VGAMonoDisplay   ; AH := Display type
         jmp  short fn8514Found

Disp_8514:
         mov  ah,Eighty514Display ; AH := Display type
         jmp  short fn8514Found

fn8514Found:
         mov  al,Eighty514        ; AL := subystem type
         call FoundDevice

; reset flags for subsystems that have been ruled out

         mov  byte ptr CGAflag,FALSE
         mov  byte ptr EGAflag,FALSE
         jmp  short fn8514Done

fn8514NotFound:

; Set the flag for subsystem yet to be checked

         mov  byte ptr XGAflag,TRUE

fn8514Done:
         ret

Find8514        ENDP

;
; FindVGA
;
;       This subroutine uses INT 10H function 1Ah to determine the video
;        BIOS Display Combination Code (DCC) for each video subsystem
;        present.
;

FindVGA         PROC    near

                mov     ax,1A00h
                int     10h             ; call video BIOS for info

                cmp     al,1Ah
                jne     L13             ; exit if function not supported
                                        ;  (i.e., no MCGA or VGA in system)

; convert BIOS DCCs into specific subsystems & displays

                mov     cx,bx
                xor     bh,bh           ; BX := DCC for active subsystem
                or      ch,ch
                jz      L11             ; jump if only one subsystem
                                        ;  present

                mov     bl,ch           ; BX := inactive DCC
                add     bx,bx
                mov     ax,[bx+offset DGROUP:DCCtable]

                mov     es:Device1,ax

                mov     bl,cl
                xor     bh,bh           ; BX := active DCC

L11:            add     bx,bx
                mov     ax,[bx+offset DGROUP:DCCtable]

                mov     es:Device0,ax

; reset flags for subsystems that have been ruled out

                mov     byte ptr CGAflag,FALSE
                mov     byte ptr EGAflag,FALSE
                mov     byte ptr Monoflag,FALSE

; set flag for subsystem that may be possible

                mov     byte ptr Eighty514Flag,TRUE

                push    ds                 ; Save DS -- Needed for large model
                push    es                 ; Put ES into DS -- see above
                pop     ds
                lea     bx,Video0Type[di]  ; if the BIOS reported an
                                           ;  MDA...
                cmp     byte ptr [bx],MDA
                pop     ds                 ; Restore DS -- Needed for large model
                je      L12

                push    ds                 ; Save DS -- Needed for large model
                push    es                 ; Put ES into DS -- see above
                pop     ds
                lea     bx,Video1Type[di]
                cmp     byte ptr [bx],MDA
                pop     ds                 ; Restore DS -- Needed for large model
                jne     L13

L12:            mov     word ptr [bx],0    ; ... Hercules can't be ruled
                                           ;      out
                mov     byte ptr Monoflag,TRUE

L13:            ret



FindVGA         ENDP


;
; FindEGA
;
; Look for an EGA.  This is done by making a call to an EGA BIOS function
;  which doesn't exist in the default (MDA, CGA) BIOS.

FindEGA         PROC    near            ; Caller:       AH = flags
                                        ; Returns:      AH = flags
                                        ;               Video0Type and
                                        ;                Display0Type
                                        ;                updated

                mov     bl,10h          ; BL := 10h (return EGA info)
                mov     ah,12h          ; AH := INT 10H function number
                int     10h             ; call EGA BIOS for info
                                        ; if EGA BIOS is present,
                                        ;  BL <> 10H
                                        ;  CL = switch setting
                cmp     bl,10h
                je      L22             ; jump if EGA BIOS not present

                mov     al,cl
                shr     al,1            ; AL := switches/2
                mov     bx,offset DGROUP:EGADisplays
                xlat                    ; determine display type from
                                        ;  switches
                mov     ah,al           ; AH := display type
                mov     al,EGA          ; AL := subystem type
                call    FoundDevice

                cmp     ah,MDADisplay
                je      L21             ; jump if EGA has a monochrome
                                        ;  display

                mov     CGAflag,FALSE   ; no CGA if EGA has color display
                jmp     short L22

L21:            mov     Monoflag,FALSE  ; EGA has a mono display, so MDA
                                        ;  and Hercules are ruled out
L22:            ret

FindEGA         ENDP


;
; FindCGA
;
;       This is done by looking for the CGA's 6845 CRTC at I/O port 3D4H.
;

FindCGA         PROC    near            ; Returns:      VIDstruct updated

                mov     dx,3D4h         ; DX := CRTC address port
                call    Find6845
                jc      L31             ; jump if not present

                mov     al,CGA
                mov     ah,CGADisplay
                call    FoundDevice

L31:            ret

FindCGA         ENDP


;
; FindMono
;
;       This is done by looking for the MDA's 6845 CRTC at I/O port 3B4H.
;       If a 6845 is found, the subroutine distinguishes between an MDA
;       and a Hercules adapter by monitoring bit 7 of the CRT Status byte.
;       This bit changes on Hercules adapters but does not change on an
;       MDA. The various Hercules adapters are identified by bits 4 through
;       6 of the CRT Status value:
;
;               000b = HGC
;               001b = HGC+
;               101b = InColor card

FindMono        PROC    near            ; Returns:      VIDstruct updated

                mov     dx,3B4h         ; DX := CRTC address port
                call    Find6845
                jc      L44             ; jump if not present

                mov     dl,0BAh         ; DX := 3BAh (status port)
                in      al,dx
                and     al,80h
                mov     ah,al           ; AH := bit 7 (vertical sync on
                                        ;        HGC)

                mov     cx,8000h        ; do this 32768 times 
L41:            in      al,dx
                and     al,80h          ; isolate bit 7
                cmp     ah,al
                loope   L41             ; wait for bit 7 to change

                jne     L42             ; if bit 7 changed, it's a Hercules

                mov     al,MDA          ; if bit 7 didn't change, it's an
                                        ;  MDA
                mov     ah,MDADisplay
                call    FoundDevice
                jmp     short L44

L42:            in      al,dx
                mov     dl,al           ; DL := value from status port

                mov     ah,MDADisplay   ; assume it's a monochrome display

                mov     al,HGC          ; look for an HGC
                and     dl,01110000b    ; mask off bits 4 thru 6
                jz      L43

                mov     al,HGCPlus      ; look for an HGC+
                cmp     dl,00010000b
                je      L43             ; jump if it's an HGC+

                mov     al,InColor      ; Check for InColor card
                mov     ah,EGAColorDisplay
                cmp     dl,01010000b
                je      L43             ; jump if it's an InColor card

                mov     al,HGC          ; Fall through to a HGC
                mov     ah,MDADisplay

L43:            call    FoundDevice

L44:            ret

FindMono        ENDP


;
; Find6845
;
;       This routine detects the presence of the CRTC on an MDA, CGA, or
;       HGC. The technique is to write and read register 0Fh of the chip
;       (Cursor Location Low). If the same value is read as written,
;       assume the chip is present at the specified port address.
;

Find6845        PROC    near            ; Caller:       DX = port addr
                                        ; Returns:      cf set if not
                                        ;                present
                mov     al,0Fh
                out     dx,al           ; select 6845 reg 0Fh (Cursor Low)
                inc     dx

                in      al,dx           ; AL := current Cursor Low value
                mov     ah,al           ; preserve in AH
                mov     al,66h          ; AL := arbitrary value
                out     dx,al           ; try to write to 6845

                mov     cx,100h

L51:            loop    L51             ; wait for 6845 to respond

                in      al,dx
                xchg    ah,al           ; AH := returned value
                                        ; AL := original value
                out     dx,al           ; restore original value

                cmp     ah,66h          ; test whether 6845 responded
                je      L52             ; jump if it did (cf is reset)

                stc                     ; set carry flag if no 6845 present

L52:            ret

Find6845        ENDP


;
; FindActive
;
;       This subroutine stores the currently active device as Device0.  The
;       current video mode determines which subsystem is active.
;

FindActive      PROC    near

                cmp     word ptr es:Device1,0
                je      L63                     ; exit if only one
                                                ;  subsystem

                cmp     es:Video0Type[di],4     ; exit if MCGA or VGA
                                                ;  present
                jge     L63                     ;  (INT 10H function 1AH
                cmp     es:Video1Type[di],4     ;  already did the work)
                jge     L63

                mov     ah,0Fh
                int     10h                     ; AL := current BIOS video
                                                ;        mode

                and     al,7
                cmp     al,7                    ; jump if monochrome
                je      L61                     ;  (mode 7 or 0Fh)

                cmp     es:Display0Type[di],MDADisplay
                jne     L63                     ; exit if Display0 is color
        jmp   short L62

L61:            cmp     es:Display0Type[di],MDADisplay
                je      L63                     ; exit if Display0 is
                                                ;  monochrome

L62:            mov     ax,es:Device0           ; make Device0 currently
                                                ;  active
                xchg    ax,es:Device1
                mov     es:Device0,ax

L63:            ret

FindActive      ENDP

;
; FoundDevice
;
;       This routine updates the list of subsystems.
;

FoundDevice     PROC    near               ; Caller:  AH = display #
                                           ;          AL = subsystem #
                                           ; Destroys: BX
                push    ds                 ; Save DS -- Needed for large model
                push    es                 ; Put ES into DS -- Needed for large model
                pop     ds

                lea     bx,Video0Type[di]
                cmp     byte ptr [bx],0
                je      L71                ; jump if 1st subsystem

                lea     bx,Video1Type[di]  ; must be 2nd subsystem

L71:            mov     [bx],ax            ; update list entry

                pop     ds                 ; Restore DS -- Needed for large model
                ret

FoundDevice     ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

EGADisplays     DB      CGADisplay      ; 0000b, 0001b  (EGA switch values)
                DB      EGAColorDisplay ; 0010b, 0011b
                DB      MDADisplay      ; 0100b, 0101b
                DB      CGADisplay      ; 0110b, 0111b
                DB      EGAColorDisplay ; 1000b, 1001b
                DB      MDADisplay      ; 1010b, 1011b

DCCtable        DB      0,0             ; translate table for INT 10h func
                                        ;  1Ah
                DB      MDA,MDADisplay
                DB      CGA,CGADisplay
                DB      0,0
                DB      EGA,EGAColorDisplay
                DB      EGA,MDADisplay
                DB      0,0
                DB      VGA,VGAMonoDisplay
                DB      VGA,VGAColorDisplay
                DB      0,0
                DB      MCGA,EGAColorDisplay
                DB      MCGA,VGAMonoDisplay
                DB      MCGA,VGAColorDisplay





TestSequence    DB      ?               ; this list of flags and addresses
                DW      FindVGA         ;  determines the order in which
                                        ;  this program looks for the
Eighty514flag   DB      ?               ;  various subsystems
                DW      Find8514

XGAflag         DB      ?
                DW      FindXGA

EGAflag         DB      ?
                DW      FindEGA

CGAflag         DB      ?   
                DW      FindCGA

Monoflag        DB      ?   
                DW      FindMono

NumberOfTests   EQU     ($-TestSequence)/3

rgXgaPorts      DW      2110h           ; Port addresses for XGA adapters.
                DW      2120h
                DW      2130h
                DW      2140h
                DW      2150h
                DW      2160h
                DW      0
_DATA           ENDS

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\wndstruc.h ===
/*******************************************************************************

	This header contains various CW window structure definitions, and for
	the early versions of CW, the macros for accessing all the varius extra
	words of information that existed beyond the basic WND structure.

	Created: 3-January-1991 MWP

	 6-Feb-91 MWP : Moved function prototypes for Get/SetWindowWord to uwindows.h
	11-Feb-91 MWP : Added wDropState to DROP_WND struc.
	14-Feb-91 MWP : Added definition for dialog file processing windows.
	15-Feb-91 MWP : Added pwndAccel variable to static window structure. This
						 allows us to maintain an accelerator for static text, and
						 not have the control that is to get the focus be defined
						 exactly after the static control within dialogs. 
						 BRILLIANT!

	 5-Mar-91 MWP : Re-sync the EDIT and PEDIT struc definitions. They were not
						 totally aligned, causing code in sedit to overwrite the end
						 of a pwnd allocation.

	 7-Mar-91 MWP : Create a DESKTOP window struc. 	

	11-Mar-91 MWP : Added wFrameHeight to Frame window def.

	 1-Apr-91 MWP : Added hidHelp parameter to dialog window struc.

	 3-Jun-91 MWP : Fixed incorrect casting of drop down window macros.
******************************************************************************/

/***BEGIN_PUBLIC***/

// Control Procedure 
typedef WORD	(FARPUBLIC *PWFN_CTL)(WORD, char *, WORD, WORD, WORD, WORD);


// BLADE enhanced version.

#ifdef BLADE

#ifdef BROADSWORD

#ifdef FULL_EDIT

#ifdef BASED
	typedef struct _winwnded _based(pWndSeg)  WND_WINEDIT;
#else
	typedef struct _winwnded WND_WINEDIT;
#endif

typedef WND_WINEDIT *PWND_WINEDIT;


typedef struct _winwnded
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PED ped;
	};

#define GetEditPed(pwnd) (((PWND_WINEDIT)pwnd)->ped)
#define SetEditPed(pwnd, ped) ( ((PWND_WINEDIT)pwnd)->ped = ped)

#endif

#endif


#ifdef BASED
	typedef struct _wndmle _based(pWndSeg) WND_MLE;
#else
	typedef struct _wndmle WND_MLE;
#endif

typedef WND_MLE *PWND_MLE;

typedef struct _wndmle
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;
#endif
	WORD	padding;
	WORD  pEF_Structure;
	};

#ifdef BASED
	typedef struct _wnddesktop _based(pWndSeg) WND_DESKTOP;
#else
	typedef struct _wnddesktop WND_DESKTOP;
#endif

typedef WND_DESKTOP *PWND_DESKTOP;

typedef struct _wnddesktop
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	BYTE  bFill;
	WORD  isaDesktop;
	};



#ifdef BASED
	typedef struct _wndgeneric _based(pWndSeg) WND_GEN;
#else
	typedef struct _wndgeneric WND_GEN;
#endif

typedef WND_GEN *PWND_GEN;

typedef struct _wndgeneric
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;			//	 6 bytes
	};



#ifdef BASED
	typedef struct _wndgenpic _based(pWndSeg) WND_GENPIC;
#else
	typedef struct _wndgeneric WND_GENPIC;
#endif

typedef WND_GENPIC *PWND_GENPIC;

typedef struct _wndgenpic
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;			//	 6 bytes
	PWFN_CTL pfnGenProc;
 	WORD wParam;				//	 6 bytes
	};

// General window stuff

// #define	PwfnCtlGeneral(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	PwfnCtlGeneral(pwnd)	((PWND_GENPIC)pwnd)->pfnGenProc
#define	WParamGeneral(pwnd)	((PWND_GENPIC)pwnd)->wParam


#define SetAccelerator(pwnd, Position, szText) \
	 ((PWND_GEN)(pwnd))->aclDialog = (((BYTE)((Position) - 1)) << 8) + \
					    *((unsigned char *)(szText) + ((Position) - 1))

#ifdef BASED
	typedef struct _wndgroup _based(pWndSeg) WND_GROUP;
#else
	typedef struct _wndgroup WND_GROUP;
#endif

typedef WND_GROUP *PWND_GROUP;

typedef struct _wndgroup
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;
#endif
	WORD aclDialog;
 	char *szDialog;
	PWND pwndAccel;	
	};


#ifdef BASED
	typedef struct _wndstatic _based(pWndSeg) WND_STATIC;
#else
	typedef struct _wndstatic WND_STATIC;
#endif

typedef WND_STATIC *PWND_STATIC;

typedef struct _wndstatic
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;						// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;
	PWND pwndAccel;	
	};

#ifdef BASED
	typedef struct _dlgwnd _based(pWndSeg)  WND_DLG;
#else
	typedef struct _dlgwnd WND_DLG;
#endif

typedef WND_DLG *PWND_DLG;

typedef struct _dlgwnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD wParamEnd;
	VOID *pmbsDialog;
	PLFN pfnUserProc;			// 12 bytes
 	WORD hidHelp;
	};

// so that rspAppIdle can determine where the current msg box dialog is 
extern PWND_DLG	pwndDlg;		// Again, app should never use 


typedef struct _drop DROP;
typedef DROP *PDROP;

typedef struct _Drop {
		WORD Dummy;
		WORD wDropFlags;
		PWND pwndDropListBox;
		PWND pwndDropButton;
		PWND pwndDropEdit;
		PLFN_WNDPROC pfnDropListBoxProc;
		PLFN_WNDPROC pfnDropEditProc;
	};


#ifdef BASED
	typedef struct _wnddrop _based(pWndSeg)  WND_DROP;
#else
	typedef struct _wnddrop WND_DROP;
#endif

typedef WND_DROP *PWND_DROP;

typedef struct _wnddrop	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD wDropState;
	WORD wDropFlags;			// TRUE ( 1 ) = Combo, FALSE ( 0 ) = Plain
	PWND pwndDropListBox;
	PWND pwndDropButton;
	PWND pwndDropEdit;
	PLFN_WNDPROC pfnDropListBoxProc;
	PLFN_WNDPROC pfnDropEditProc;		// 20 bytes
	};

#define PwndDropListBox(pwnd) ( (PWND_LIST)( (PWND_DROP)pwnd )->pwndDropListBox ) 
#define PwndDropButton(pwnd) 	( (PWND_BTN)( (PWND_DROP)pwnd )->pwndDropButton )
#define PwndDropEdit(pwnd)		( (PWND_EDIT)( (PWND_DROP)pwnd )->pwndDropEdit)
#define PfnDropListBoxProc(pwnd) ( ( (PWND_DROP)pwnd )->pfnDropListBoxProc)
#define PfnDropEditProc(pwnd)		( ( (PWND_DROP)pwnd )->pfnDropEditProc)


#ifdef BASED
	typedef struct _wnddroplist _based(pWndSeg)  WND_DROP_LIST;
#else
	typedef struct _wnddroplist WND_DROP_LIST;
#endif

typedef WND_DROP_LIST *PWND_DROP_LIST;

typedef struct _wnddroplist	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb; 			// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				// colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 	  // 36 bytes
	PWND_DROP pwndDrop;
	};



#ifdef BASED
	typedef struct _wnddlgdir _based(pWndSeg)  WND_DLGDIR;
#else
	typedef struct _wnddlgdir WND_DLGDIR;
#endif

typedef WND_DLGDIR *PWND_DLGDIR;

typedef struct _wnddlgdir	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWND	pwndDirDrivesBox;
	PWND	pwndFilesBox;
	PWND	pwndDirEdit;
	PWND  pwndDirStatic;
	};


#define PwndDlgDirEdit(pwnd)	( ( (PWND_DLGDIR)pwnd )->pwndDirEdit)
#define PwndDirStatic(pwnd)	( ( (PWND_DLGDIR)pwnd )->pwndDirStatic)


typedef struct _Scroll SCROLL;
typedef SCROLL *PSCROLL;

typedef struct _Scroll {
	WORD ctickRepSb;	 	// # of ticks to repeat
	short ptCurSb; 			// current position on scroll line
	short ptMinSb; 			// minimum position on scroll line
	short ptMaxSb; 			// end position on scroll line 
	BYTE ptElevatorSb;		// elevator position
	BYTE dummy; 				// word alignment
	};


#ifdef BASED
	typedef struct _wndscroll _based(pWndSeg)  WND_SCROLL;
#else
	typedef struct _wndscroll WND_SCROLL;
#endif

typedef WND_SCROLL *PWND_SCROLL;

typedef struct _wndscroll
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;			
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD ctickRepSb;	 		// # of ticks to repeat
	short ptCurSb; 				// current position on scroll line
	short ptMinSb; 				// minimum position on scroll line
	short ptMaxSb; 				// end position on scroll line 
	short ptElevatorSb;		// elevator position (lower byte)	// 10 bytes
	};

typedef struct _List LISTBOX;
typedef LISTBOX *PLISTBOX;


typedef struct _List {
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb;				// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				//	colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 
	};


#ifdef BASED
	typedef struct _wndlist _based(pWndSeg)  WND_LIST;
#else
	typedef struct _wndlist WND_LIST;
#endif

typedef WND_LIST *PWND_LIST;

typedef struct _wndlist	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	PWFN_CTL pfnLBFtn;
	WORD wParam;
	WORD wUnknown;
	WORD iszTopLb; 			// first item in Display 
	WORD cszLb;					// # of strings in list in list 
	WORD iszCurLb;				// currently selected item 
	WORD hmemMpiszoffLb;		// array of offsets in string buffer
	WORD hmemGpszLb;			// string buffer pool 
	WORD offLb; 				// next string buffer pointer 
	WORD offMaxLb; 			// size of string buffer 
	WORD iszMacLb; 			// max isz before index buf is grown
	WORD fSelectedLb;			// do we have a selection ? 
	WORD isaColor;				// colour of the listbox 
	WORD isaHiliteColor;		// colour of the listbox hilite
	WORD ctickRepLb;			// scrolling rate 
	WORD drxItemLb;			// width of a single item (add 1 for space) 
	WORD citemWidthLb;		// max # of items wide 	  // 36 bytes
	};


#define	PwfnCtlLb(pwnd)	(((PWND_LIST)pwnd)->pfnLBFtn)
#define	WParamLb(pwnd)		(((PWND_LIST)pwnd)->wParam)

// special listbox window specific isa's 

#define IsaListbox(pwnd)			(((PWND_LIST)pwnd)->isaColor)
#define IsaHiliteListbox(pwnd)	(((PWND_LIST)pwnd)->isaHiliteColor)

typedef struct _Edit EDIT;
typedef EDIT *PEDIT;

typedef struct _Edit {
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;
	WORD isaEb;					// color 
	WORD isaSelEb;				// selected color 
	BYTE chFillDialog;			// fill char for trailing spaces 
	WORD ichMacEb;				// last character in edit buffer 
	WORD ichLeftEb;				// leftmost character displayed 
	WORD ichCursorEb;			// current cursor position, to the left of  insertion point 
	WORD ichSelEb;				// start of selection 
	WORD fNoBracketEb;			// don't show brackets ?? 
	WORD wEb;						// random flags 
	WORD cchMaxEb;				// for fixed length edit items 
	WORD isaDisabledEb;			// disabled color 
	char *szWildCardEb;			// auxilary edit field 
	BOOL fCWAllocated;
	BOOL Dummy;
};

#ifdef BASED
	typedef struct _wnded _based(pWndSeg)  WND_EDIT;
#else
	typedef struct _wnded WND_EDIT;
#endif

typedef WND_EDIT *PWND_EDIT;

typedef struct _wnded
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	WORD cchDialog;
	WORD isaEb;					// color 
	WORD isaSelEb;				// selected color 
	BYTE chFillDialog;		// fill char for trailing spaces 
	WORD ichMacEb;				// last character in edit buffer 
	WORD ichLeftEb;			// leftmost character displayed 
	WORD ichCursorEb;			// current cursor position, to the left of  insertion point 
	WORD ichSelEb;				// start of selection 
	WORD fNoBracketEb;		// don't show brackets ?? 
	WORD wEb;					// random flags 
	WORD cchMaxEb;				// for fixed length edit items 
	WORD isaDisabledEb;		// disabled color 
	char *szWildCardEb;		// auxilary edit field 
	BOOL fCWAllocated;
	BOOL Dummy;					// 34 bytes
	};


#define ShowEditBracket(pwnd, fNoBracket ) (((PWND_EDIT)pwnd)->fNoBracketEb = !(fNoBracket)	)
#define SetEditFillCharacter(pwnd, ch)		 (((PWND_EDIT)pwnd)->chFillDialog = (BYTE)(ch) )
#define SetEditDisabledIsa(pwnd, isa)		 (((PWND_EDIT)pwnd)->isaDisabledEb = (isa) )
#define SetEditSelectedIsa(pwnd, isa)		 (((PWND_EDIT)pwnd)->isaSelEb = (isa) )
#define SetEditIsa(pwnd, isa)					 (((PWND_EDIT)pwnd)->isaEb = (isa) )

// special edit window specific isa's 
#define IsaEdit(pwnd)			(((PWND_EDIT)pwnd)->isaEb)
#define IsaSelEdit(pwnd)		(((PWND_EDIT)pwnd)->isaSelEb )
#define IsaDisabledEdit(pwnd)	(((PWND_EDIT)pwnd)->isaDisabledEb)

#ifdef BASED
	typedef struct _btnwnd  _based(pWndSeg) WND_BTN;
#else
	typedef struct _btnwnd WND_BTN;
#endif

typedef WND_BTN *PWND_BTN;

typedef struct _btnwnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;			// 31 bytes
#endif
	WORD aclDialog;
 	char *szDialog;	
 	BYTE cchDialog;
	BYTE wButton;
#ifndef WIN_BTN
	PWND_BTN pwndButtonNext;		//	 8 bytes
#endif
	};


#ifndef WIN_BTN
// walking the list of radio buttons 
#define	PwndButtonNext(pwnd) ((PWND_BTN) (pwnd)->pwndButtonNext)

// is it a (radio) button? 
#define	FPwndIsButton(pwnd) (((pwnd)->style & WS_TYPE) == WS_BUTTON)
#define	FButtonIsRadio(pwnd) (((pwnd)->style & WS_SUBSTYLE) == BS_RADIOBUTTON)

// bits :
//  0..1 '=> bst (button state)
//  2 => fButtonDown
//  3 => first in group
//
// button states 


#ifdef BLADE

#define bstOff		(BYTE)0
#define bstOn		(BYTE)1
#define bstGreyed	(BYTE)2 
#define bstMax		(BYTE)3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~((BYTE)3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= (BYTE)4; \
	  else (pwnd)->wButton &= ~(BYTE)4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= (BYTE)8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)


#else

#define bstOff		0
#define bstOn		1
#define bstGreyed	2 
#define bstMax		3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~(3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= 4; \
	  else (pwnd)->wButton &= ~4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= 8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)

#endif //BLADE


#endif //WIN_BTN


#ifdef BASED
	typedef struct _framewnd _based(pWndSeg)  WND_FRAME;
#else
	typedef struct _framewnd WND_FRAME;
#endif

typedef WND_FRAME *PWND_FRAME;

typedef struct _framewnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	WORD	wExtStyle;
	ARC	arcWindow;
	ARC	arcClipping;
#ifdef BROADSWORD
	ARC	rrcInvalid;
	BYTE  hbrDraw;			  	// Color for drawing.
	BYTE  hbrBackGround;		//	Color for background.
#else
	RRC	rrcInvalid;
#endif
	PLFN_WNDPROC pfnWndProc;
	PWND  pwndParent;
	PWND  pwndSibling;
	PWND  pwndChild;
#ifdef BROADSWORD
	WORD	pcls;
#endif
	BYTE	axCursor;
	BYTE	ayCursor;
#ifndef BROADSWORD
	BYTE	wndBytes;				// 31 bytes
#endif
	BOOL  fWinActive;
	char *szFrameText;
	VOID **hFrameMenu;
	WORD 	 axyLastPos;
	WORD 	 rxyLastPos;
	BOOL	 fZoomFrame;
	ARC	 arcMenuArc;				//	16 bytes
	WORD	 wFrameHeight;
	PLFN_WNDPROC pfnClientWndProc;
	};

#else	 // Non-Blade stuff follows

typedef PWND PWND_MLE;
typedef PWND PWND_SCROLL;
typedef PWND PWND_EDIT;
typedef PWND PWND_BTN;
typedef PWND PWND_DLG;
typedef PWND PWND_GEN;
typedef PWND PWND_STATIC;
typedef PWND PWND_LIST;
typedef PWND PWND_DROP_LIST;
typedef PWND PWND_DROP;
typedef PWND PWND_FRAME;
typedef PWND PWND_DESKTOP;
typedef PWND PWND_GROUP;

#define	GetWindowWord(pwnd, iw) 	((pwnd)->rgwExtra[(iw)])
#define	SetWindowWord(pwnd, iw, w) {(pwnd)->rgwExtra[(iw)] = (w);}


// special edit window specific isa's 

#define IsaEdit(pwnd)			((pwnd)->rgwExtra[3])
#define IsaSelEdit(pwnd)		((pwnd)->rgwExtra[4])
#define IsaDisabledEdit(pwnd)	((pwnd)->rgwExtra[13])


// Common portion of all dialog windows 

#define	cwExtraMin	1		// at least 1 field for all items 
									// not used for dialog box 

#define	aclDialog	rgwExtra[0]	// dialog accelerator 

// Text info for : edit, static and button controls 

#define cwExtraText	(cwExtraMin+2)	// 2 more for text controls 
#define szDialog	rgwExtra[1]			// also Dialog Box caption 
#define cchDialog	rgwExtra[2]			// edit, static & buttons 

// flag indicating whether EndDialog has been
// called.  Used to prevent multiple calls
// to PostQuitMessage 

#define wParamEnd		rgwExtra[2]


// sizes of rgwExtra for the various controls 

#define cwExtraDialog	(cwExtraMin+2)		// szDialog + wParamEnd 

#define cwExtraSdmDlg	(cwExtraDialog+((sizeof(SDS)+1)/2))	// ... + sds 

#define cwExtraMsgBox	(cwExtraDialog+1) // ... + pmbs 
#define cwExtraStatic	(cwExtraText)		// simple text 
#define cwExtraButton	(cwExtraText+2)	// text + button state + next radio
#define cwExtraGroup    (cwExtraText+2)	// text 


#define cwExtraEdit		(cwExtraText+11)	// see sedit.h for details 
#define cwExtraEditAux	(cwExtraEdit+1)	
#define cwExtraGeneral	(cwExtraMin+3)		// see general.h for details 

#ifndef LISTBOX_HORIZ
	#define cwExtraListBox	(cwExtraMin+15)	// see _listbox.h for details 
#else
	#define cwExtraListBox	(cwExtraMin+17)	// see _listbox.h for details 
#endif


#define cwExtraDropDown		(cwExtraMin+9)		// 10
#define cwExtraDropHolder 	(cwExtraMin+1)		// 2
#define cwExtraDropButton 	(cwExtraMin)		// 1


#define wButton 	rgwExtra[cwExtraText]

// flag word for button control 

#define	pwndButtonNext	rgwExtra[cwExtraText+1]	 // next radio button 

//#if cwExtraButton != cwExtraText+2
//.....
//#endif

// walking the list of radio buttons 
#define	PwndButtonNext(pwnd) ((PWND_BTN) (pwnd)->pwndButtonNext)

// is it a (radio) button? 
#define	FPwndIsButton(pwnd) (((pwnd)->style & WS_TYPE) == WS_BUTTON)
#define	FButtonIsRadio(pwnd) (((pwnd)->style & WS_SUBSTYLE) == BS_RADIOBUTTON)

// bits :
//  0..1 '=> bst (button state)
//  2 => fButtonDown
//  3 => first in group
//
// button states 



#define bstOff		0
#define bstOn		1
#define bstGreyed	2 
#define bstMax		3


// Macros for bit accesses 


#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) (pwnd)->wButton = ((pwnd)->wButton & ~(3)) | (bst) 

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= 4; \
	  else (pwnd)->wButton &= ~4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)

#define SetFFirstButton(pwnd) (pwnd)->wButton = ((pwnd)->wButton |= 8)

#define SetNextGroupButton(pwnd, pwndNext )  (pwnd)->pwndButtonNext =(pwndNext)



#define cwExtraFrame (cwExtraText + 4)	

#define fWinActive   rgwExtra[1]
#define szFrameText  rgwExtra[2]
#define hFrameMenu   rgwExtra[3]

#define axyLastPos	rgwExtra[4]
#define rxyLastPos	rgwExtra[5]
#define fZoomFrame	rgwExtra[6]
#define arcMenuArc   rgwExtra[7]

// General window stuff

#define	PwfnCtlGeneral(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	WParamGeneral(pwnd)	(pwnd->rgwExtra[cwExtraMin+2])

//#if cwExtraGeneral != cwExtraMin+3
//.....
//#endif

// General window stuff


//listbox stuff

// customization 

// extra word usage 

// 0,1,2 are listbox function and wParam (for on-demand) 

#define iszTopLb 	rgwExtra[cwExtraMin+3]			// first item in Display 
#define cszLb		rgwExtra[cwExtraMin+4]			// # of strings in list in list 
#define iszCurLb	rgwExtra[cwExtraMin+5]			// currently selected item 
#define hmemMpiszoffLb	rgwExtra[cwExtraMin+6]	// array of offsets in string buffer
#define hmemGpszLb	rgwExtra[cwExtraMin+7]		// string buffer pool 
#define offLb 		rgwExtra[cwExtraMin+8]			// next string buffer pointer 
#define offMaxLb 	rgwExtra[cwExtraMin+9]			// size of string buffer 
#define iszMacLb 	rgwExtra[cwExtraMin+10]			// max isz before index buf is grown
#define fSelectedLb	rgwExtra[cwExtraMin+11]		// do we have a selection ? 
#define isaColor	rgwExtra[cwExtraMin+12]			// colour of the listbox 
#define isaHiliteColor	rgwExtra[cwExtraMin+13]	// colour of the listbox hilite
#define ctickRepLb	rgwExtra[cwExtraMin+14]		// scrolling rate 

#ifndef LISTBOX_HORIZ
	#define	cwExtraNeeded	(cwExtraMin+15)
#else
	// Horizontal scrolling extra info 

	#define	drxItemLb	rgwExtra[cwExtraMin+15]		// width of a single item (add 1 for space) 
	#define	citemWidthLb	rgwExtra[cwExtraMin+16]	// max # of items wide 
	#define	cwExtraNeeded	(cwExtraMin+17)
#endif

//#if cwExtraListBox != cwExtraNeeded
//.....
//#endif

#define	PwfnCtlLb(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))
#define	WParamLb(pwnd)		(pwnd->rgwExtra[cwExtraMin+2])


// special listbox window specific isa's 

#define IsaListbox(pwnd)			((pwnd)->rgwExtra[13])
#define IsaHiliteListbox(pwnd)	((pwnd)->rgwExtra[14])

//listbox stuff

//Scrollbar defs

#define cwExtraScroll	5	// size of rgwExtra for scroll windows 

// scroll bar definitions 

#define ctickRepSb	rgwExtra[0]	// # of ticks to repeat 
#define ptCurSb		rgwExtra[1]	// current position on scroll line 
#define ptMinSb		rgwExtra[2]	// minimum position on scroll line 
#define ptMaxSb		rgwExtra[3]	// end position on scroll line 
#define ptElevatorSb	rgwExtra[4]	// elevator position (lower byte) 

//Scrollbar defs



//Editbox defs

// extra word usage (filled by SDM) 

#define	isaEb		rgwExtra[cwExtraText+0]			// color 
#define	isaSelEb	rgwExtra[cwExtraText+1]			// selected color 
#define chFillDialog	rgwExtra[cwExtraText+2]		// fill char for trailing spaces 
#define ichMacEb	rgwExtra[cwExtraText+3]			// last character in edit buffer 
#define ichLeftEb	rgwExtra[cwExtraText+4]			// leftmost character displayed 
#define ichCursorEb	rgwExtra[cwExtraText+5]		// current cursor position, to the left of
															   // insertion point 
#define ichSelEb	rgwExtra[cwExtraText+6]			// start of selection 
#define	fNoBracketEb	rgwExtra[cwExtraText+7]	// don't show brackets ?? 
#define wEb		rgwExtra[cwExtraText+8]				// random flags 
#define cchMaxEb	rgwExtra[cwExtraText+9]			// for fixed length edit items 
#define isaDisabledEb	rgwExtra[cwExtraText+10]// disabled color 
#define szWildCardEb	rgwExtra[cwExtraText+11]	// auxilary edit field 

//#if cwExtraEdit != cwExtraText+11
//.....
//#endif

//#if cwExtraEditAux != cwExtraText+12
//.....
//#endif

//Editbox defs


// Message box defs

// this structure is defined only so that C will allocate enough extra
// words in the msg box window structures put on the stack 

typedef struct _wndm
	{
	WND	wnd;
	WORD 	rgwExtraPlus[cwExtraMsgBox-1];
	} WNDM;

// message box state 
#define pmbsDialog		rgwExtra[cwExtraDialog]

// Message box defs


// Dropdown defs

// dropdown rgwExtra aliases 
#define wDropFlags      rgwExtra[cwExtraMin]
#define pwndDropListBox rgwExtra[cwExtraMin+1]
#define pwndDropButton  rgwExtra[cwExtraMin+2]
#define pwndDropEdit    rgwExtra[cwExtraMin+3]
#define pwndDropHolder  rgwExtra[cwExtraMin+4]
#define pfnDropListBoxProc	rgwExtra[cwExtraMin+5]	// actually two words 
#define pfnDropEditProc	rgwExtra[cwExtraMin+7]		// actually two words 


#define PwndDropListBox(pwnd)		(*(PWND*)&((pwnd)->pwndDropListBox))
#define PwndDropButton(pwnd)		(*(PWND*)&((pwnd)->pwndDropButton))
#define PwndDropEdit(pwnd)			(*(PWND*)&((pwnd)->pwndDropEdit))
#define PwndDropHolder(pwnd)		(*(PWND*)&((pwnd)->pwndDropHolder))
#define PfnDropListBoxProc(pwnd) (*(PLFN_WNDPROC*)&((pwnd)->pfnDropListBoxProc))
#define PfnDropEditProc(pwnd)		(*(PLFN_WNDPROC*)&((pwnd)->pfnDropEditProc))

// dropdown holding window rgwExtra aliases and macros 

#define pwndHolderDrop rgwExtra[cwExtraMin]

#define PwndHolderDrop(pwnd) (*(PWND*)&((pwnd)->pwndHolderDrop))

// Dropdown defs

extern PWND_DLG	pwndDlg;		// Again, app should never use 

#endif //	BLADE

extern PWND_DESKTOP PASCAL pwndDesktop;

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\wksta.h ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1987-1990		**/
/*****************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  WKSTA.H				    *
 *								    *
 *  This file contains information about the NetWksta APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

#ifndef NETWKSTA_INCLUDED

#define NETWKSTA_INCLUDED


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetWkstaGetInfo ( const char far *     pszServer,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcbTotalAvail );

extern API_FUNCTION
  NetWkstaSetInfo ( const char far * pszServer,
                    short            sLevel,
                    char far *       pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


extern API_FUNCTION
  NetWkstaSetUID ( const char far * pszServer,
                   const char far * pszUserName,
                   const char far * pszPassword,
                   const char far * pszParms,
                   unsigned short   fsLogOff );

extern API_FUNCTION
  NetWkstaSetUID2 ( char far *           pszReserved,
                    char far *           pszDomain,
                    char far *           pszUserName,
                    char far *           pszPassword,
                    char far *           pszParms,
                    unsigned short       usLogoffForce,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/

struct wksta_info_0 {
    unsigned short  wki0_reserved_1;
    unsigned long   wki0_reserved_2;
    char far *	    wki0_root;
    char far *	    wki0_computername;
    char far *	    wki0_username;
    char far *      wki0_langroup;
    unsigned char   wki0_ver_major;
    unsigned char   wki0_ver_minor;
    unsigned long   wki0_reserved_3;
    unsigned short  wki0_charwait;
    unsigned long   wki0_chartime;
    unsigned short  wki0_charcount;
    unsigned short  wki0_reserved_4;
    unsigned short  wki0_reserved_5;
    unsigned short  wki0_keepconn;
    unsigned short  wki0_keepsearch;
    unsigned short  wki0_maxthreads;
    unsigned short  wki0_maxcmds;
    unsigned short  wki0_reserved_6;
    unsigned short  wki0_numworkbuf;
    unsigned short  wki0_sizworkbuf;
    unsigned short  wki0_maxwrkcache;
    unsigned short  wki0_sesstimeout;
    unsigned short  wki0_sizerror;
    unsigned short  wki0_numalerts;
    unsigned short  wki0_numservices;
    unsigned short  wki0_errlogsz;
    unsigned short  wki0_printbuftime;
    unsigned short  wki0_numcharbuf;
    unsigned short  wki0_sizcharbuf;
    char far *	    wki0_logon_server;	
    char far *	    wki0_wrkheuristics;
    unsigned short  wki0_mailslots;
};	/* wksta_info_0 */

struct wksta_info_1 {
    unsigned short  wki1_reserved_1;
    unsigned long   wki1_reserved_2;
    char far *	    wki1_root;
    char far *	    wki1_computername;
    char far *	    wki1_username;
    char far *	    wki1_langroup;
    unsigned char   wki1_ver_major;
    unsigned char   wki1_ver_minor;
    unsigned long   wki1_reserved_3;
    unsigned short  wki1_charwait;
    unsigned long   wki1_chartime;
    unsigned short  wki1_charcount;
    unsigned short  wki1_reserved_4;
    unsigned short  wki1_reserved_5;
    unsigned short  wki1_keepconn;
    unsigned short  wki1_keepsearch;
    unsigned short  wki1_maxthreads;
    unsigned short  wki1_maxcmds;
    unsigned short  wki1_reserved_6;
    unsigned short  wki1_numworkbuf;
    unsigned short  wki1_sizworkbuf;
    unsigned short  wki1_maxwrkcache;
    unsigned short  wki1_sesstimeout;
    unsigned short  wki1_sizerror;
    unsigned short  wki1_numalerts;
    unsigned short  wki1_numservices;
    unsigned short  wki1_errlogsz;
    unsigned short  wki1_printbuftime;
    unsigned short  wki1_numcharbuf;
    unsigned short  wki1_sizcharbuf;
    char far *	    wki1_logon_server;
    char far *	    wki1_wrkheuristics;
    unsigned short  wki1_mailslots;
    char far *	    wki1_logon_domain;
    char far *	    wki1_oth_domains;
    unsigned short  wki1_numdgrambuf;
};	/* wksta_info_1 */

struct wksta_info_10 {
    char far *	    wki10_computername;
    char far *	    wki10_username;
    char far *	    wki10_langroup;
    unsigned char   wki10_ver_major;
    unsigned char   wki10_ver_minor;
    char far *	    wki10_logon_domain;
    char far *	    wki10_oth_domains;
};	/* wksta_info_10 */

/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/


/*
 * 	Constants for use as NetWkstaSetInfo parmnum parameter
 */

#define WKSTA_CHARWAIT_PARMNUM	   	10
#define WKSTA_CHARTIME_PARMNUM	   	11	
#define WKSTA_CHARCOUNT_PARMNUM    	12
#define WKSTA_ERRLOGSZ_PARMNUM     	27
#define WKSTA_PRINTBUFTIME_PARMNUM 	28
#define WKSTA_WRKHEURISTICS_PARMNUM 	32
#define WKSTA_OTHDOMAINS_PARMNUM	35

/*
 * 	Definitions for NetWkstaSetUID's ucond parameter
 */

#define WKSTA_NOFORCE         0
#define WKSTA_FORCE           1
#define WKSTA_LOTS_OF_FORCE   2
#define WKSTA_MAX_FORCE       3



/*
 *	Maximum number of additional domains
 */
#define MAX_OTH_DOMAINS     4


#endif /* NETWKSTA_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\_msd.h ===
/*********************************************************************
 * Microsoft Diagnostics Version 2.0
 *
 * A diagnostic utility to detect as much useful information about a
 *   customer's computer system as is possible.
 *
 * Microsoft Diagnostics:  We detect the World.
 *
 * _MSD.H - Header file for use within MSD.C
 *
 * Note:  _MSD.H and MSD.H are interdependent.
 ********************************************************************/

#ifdef CW_INCLUDED

/* Comment this line out when we're sure the 'C' startup */
/*   code will not jump to space.                        */
float flTemp = (float) 0.0;

#include "SRMENU.H"
#include "dialogs.adm"

#endif /* CW_INCLUDED */


/* Global Variables */

BOOL fCwIsReady      = FALSE;  /* TRUE when CW is initialized           */
BOOL fBlackWhite     = FALSE;  /* TRUE for black and white operation    */
BOOL fFastStart      = FALSE;  /* TRUE for no initial detection         */
BOOL fReportFlag     = FALSE;  /* TRUE if a report is underway          */
BOOL fReportOnly     = FALSE;  /* TRUE if "/F filename" was used, or if */
                               /*   CW_INCLUDED is not defined          */
BOOL fSummaryOnly    = FALSE;  /* TRUE if MSD is to report summary      */
                               /*   information only to a file          */
BOOL fCriticalError  = FALSE;  /* Critical Error Flag                   */
BOOL fWindowsRunning = FALSE;  /* TRUE if windows is running            */

WORD wDosMajor;           /* Stores the DOS version */
WORD wDosMinor;

#ifdef CW_INCLUDED

BYTE fAdjustMsgBox = FALSE;

PWND pwndSummaryFrame = NULL;
PWND pwndMainFrame    = NULL;
PWND pwndStatusLine   = NULL;

/* For subclassing MessageBox types */
PLFN_WNDPROC OldMsgBoxProc;

LONG FAR MyMsgBoxProc (REGISTER PWND_DLG, WORD, WORD, DWORD);

/* For subclassing Edit Item types */
PLFN_WNDPROC OldEditItemProc;

LONG FAR MyEditItemProc (REGISTER PWND_EDIT, WORD, WORD, DWORD);


HMNU hmnuMenuBar = (HMNU) &pmenuBlade;

ISA_PAIR aisapColor[isaMax] =
  {
    {  7,  8 },   /*  0 = isaBackground                                   */

    { 15,  0 },   /*  1 = isaHilite                                       */
    {  8, 15 },   /*  2 = isaGreyed                                       */
    {  0, 15 },   /*  3 = isaEnabled                                      */
    {  8, 15 },   /*  4 = isaDisabled                                     */
    {  0, 15 },   /*  5 = isaAlert                                        */

    {  0, 15 },   /*  6 = isaDialogBox,     isaStatic, isaButton, isaEdit */
    {  0,  7 },   /*  7 = isaPushButton                                   */
    {  8,  7 },   /*  8 = isaButtonDown                                   */
    {  0, 15 },   /*  9 = isaListBox                                      */
    {  0, 15 },   /* 10 = isaScrollbar                                    */

    {  7,  0 },   /* 11 = isaElevator                                     */
    {  0, 15 },   /* 12 = isaMenuBox                                      */
    {  0, 15 },   /* 13 = isaMenu                                         */
    { 15,  0 },   /* 14 = isaMenuSelected                                 */
    { 12, 15 },   /* 15 = isaMenuHilite                                   */

    {  7,  0 },   /* 16 = isaMenuHiliteSel                                */
    { 12,  0 },   /* 17 = isaItemHiliteSel                                */
    { 12, 15 },   /* 18 = isaDialogAccel                                  */
    { 12, 15 },   /* 19 = isaDialogAccelBor                               */
    {  8,  8 },   /* 20 = isaShadow                                       */

    {  7,  0 },   /* 21 = isaDialogBar                                    */
    {  7,  0 },   /* 22 = isaDialogTitle                                  */
    {  0,  0 },   /* 23 = isa3DGroupBoxIn,  isa3DGroupBoxUL               */
    { 15,  7 },   /* 24 = isa3DGroupBoxOut, isa3DGroupBoxBR               */
    {  0,  7 },   /* 25 = isa3DListboxIn,   isa3DListboxUL                */

    { 15,  7 },   /* 26 = isa3DListboxOut,  isa3DListboxBR                */
    { 15,  7 },   /* 27 = isa3DPushBtnIn,   isa3DPushBtnUL                */
    {  8,  7 },   /* 28 = isa3DPushBtnOut,  isa3DPushBtnBR                */
    { 14,  7 },   /* 29 = isaButtonAccel,   isaSystemMax                  */
    { 15,  1 },   /* 30 = isaUserMin,       isaSummaryBlank               */

    { 15,  1 },   /* 31 = isaSummaryText                                  */
    {  0, 15 },   /* 32 = isaInfoActive                                   */
    {  0, 15 },   /* 33 = isaInfoActiveBorder                             */
    {  0,  8 },   /* 34 = isaInfoInactive                                 */
    {  0,  7 },   /* 35 = isaStatusLine                                   */

    {  7,  0 },   /* 36 = isaAlternate                                    */
    { 14,  0 },   /* 37 = isaMemoryMap                                    */
    {  7,  1 },   /* 38 = isaSummaryBtnShadow                             */
    {  7, 15 },   /* 39 = isaMessageBtn1                                  */
    {  4,  7 },   /* 40 = isa3DBtnHilite                                  */

    {  7,  0 },   /* 41 =                                                 */
    {  7,  0 },   /* 42 =                                                 */
    {  7,  0 },   /* 43 =                                                 */
    {  7,  0 },   /* 44 =                                                 */
    {  7,  0 }    /* 45 = isaMax,           isaUserMax, isaTemp           */
  };

ISA_PAIR aisapBlackAndWhite[isaMax] =
  {
    {  7,  0 },   /*  0 = isaBackground                                   */

    {  7,  0 },   /*  1 = isaHilite                                       */
    {  7,  0 },   /*  2 = isaGreyed                                       */
    {  0,  7 },   /*  3 = isaEnabled                                      */
    {  0,  7 },   /*  4 = isaDisabled                                     */
    {  0,  7 },   /*  5 = isaAlert                                        */

    {  0,  7 },   /*  6 = isaDialogBox,     isaStatic, isaButton, isaEdit */
    {  0,  7 },   /*  7 = isaPushButton                                   */
    {  7,  0 },   /*  8 = isaButtonDown                                   */
    {  0,  7 },   /*  9 = isaListBox                                      */
    {  0,  7 },   /* 10 = isaScrollbar                                    */

    {  7,  0 },   /* 11 = isaElevator                                     */
    {  0,  7 },   /* 12 = isaMenuBox                                      */
    {  0,  7 },   /* 13 = isaMenu                                         */
    {  7,  0 },   /* 14 = isaMenuSelected                                 */
    {  7,  0 },   /* 15 = isaMenuHilite                                   */

    {  7,  0 },   /* 16 = isaMenuHiliteSel                                */
    {  7,  0 },   /* 17 = isaItemHiliteSel                                */
    {  7,  0 },   /* 18 = isaDialogAccel                                  */
    {  7,  0 },   /* 19 = isaDialogAccelBor                               */
    {  0,  0 },   /* 20 = isaShadow                                       */

    {  7,  0 },   /* 21 = isaDialogBar                                    */
    {  7,  0 },   /* 22 = isaDialogTitle                                  */
    {  0,  0 },   /* 23 = isa3DGroupBoxIn,  isa3DGroupBoxUL               */
    {  0,  7 },   /* 24 = isa3DGroupBoxOut, isa3DGroupBoxBR               */
    {  0,  7 },   /* 25 = isa3DListboxIn,   isa3DListboxUL                */

    {  0,  7 },   /* 26 = isa3DListboxOut,  isa3DListboxBR                */
    {  0,  7 },   /* 27 = isa3DPushBtnIn,   isa3DPushBtnUL                */
    {  0,  7 },   /* 28 = isa3DPushBtnOut,  isa3DPushBtnBR                */
    {  0,  7 },   /* 29 = isaButtonAccel,   isaSystemMax                  */
    {  7,  0 },   /* 30 = isaUserMin,       isaSummaryBlank               */

    {  7,  0 },   /* 31 = isaSummaryText                                  */
    {  0,  7 },   /* 32 = isaInfoActive                                   */
    {  0,  7 },   /* 33 = isaInfoActiveBorder                             */
    {  0,  7 },   /* 34 = isaInfoInactive                                 */
    {  0,  7 },   /* 35 = isaStatusLine                                   */

    {  7,  0 },   /* 36 = isaAlternate                                    */
    {  7,  0 },   /* 37 = isaMemoryMap                                    */
    {  7,  0 },   /* 38 = isaSummaryBtnShadow                             */
    {  7,  0 },   /* 39 =                                                 */
    {  7,  0 },   /* 40 =                                                 */

    {  7,  0 },   /* 41 =                                                 */
    {  7,  0 },   /* 42 =                                                 */
    {  7,  0 },   /* 43 =                                                 */
    {  7,  0 },   /* 44 =                                                 */
    {  7,  0 }    /* 45 = isaMax,           isaUserMax, isaTemp           */
  };

#endif /* CW_INCLUDED */

/* Variables for reporting */

WORD wLineCount;          /* Current line number   */
WORD wPageCount;          /* Current page number   */
WORD wColumnCount = 0;    /* Current column number */
WORD wReportIndent = 40 - (REPORT_WIDTH / 2);  /* Left indent for reports */

PSZ  pszReportFilename = NULL;  /* Pointer to report filename */


/* Global Strings */

PSZ  paszReportTo[] =     /* Filenames to report to */
  {
    "LPT1",
    "LPT2",
    "LPT3",
    "COM1",
    "COM2",
    "COM3",
    "COM4",
    NULL
  };

WORD wReportToIndex = 0;  /* Index to paszReportTo */

FILE_INFO FAR *pfiDlg;    /* File Info for dialog processing */
TEST_PRINTER tpValue;     /* Printer test info structure */


QSZ * pqszBrowseStrings = NULL;  /* Browsed strings are returned here */
PSZ   pszBrowseTitle    = NULL;  /* Title for browsed strings         */

#define MSD_VERSION_NUMBER "2.01"
PSZ  pszVersionNumber   = MSD_VERSION_NUMBER;

PSZ  pszNull            = "";
PSZ  pszYes             = "Yes";
PSZ  pszNo              = "No";
PSZ  pszNo_             = "No ";
PSZ  pszNone            = "None";
PSZ  pszUnknown         = "Unknown";

PSZ  pszInsufMemory     = "Insufficient Memory";
PSZ  pszErrorOpening    = "Error opening";
PSZ  pszErrorClosing    = "Error Closing File";
PSZ  pszErrorWriting    = "Error Writing";
PSZ  pszErrorReading    = "Error Reading";

PSZ  pszCon             = "CON";

PSZ  pszHeaderFormatString = "   Microsoft Diagnostics version %s   %2d/%02d/%02d   %2d:%02d%s   Page%3d";

PSZ  pszPostscriptTest1 = "initgraphics\r\n"
                          "/Times-Roman findfont 18 scalefont setfont\r\n"
                          "100 700 moveto\r\n"
                          "(Microsoft Corporation ) show\r\n"
                          "100 680 moveto\r\n"
                          "(Postscript Printer Connection and Processor Test) show\r\n"
                          "100 660 moveto\r\n"
                          "(Postscript version: )show 8 0 rmoveto version show\r\n";
PSZ  pszPostscriptTest2 = "100 640 moveto\r\n"
                          "(Date:  %d/%02d/%d   Time:  %d:%02d %s) show\r\n";
PSZ  pszPostscriptTest3 = "/Times-Roman findfont 12 scalefont setfont\r\n";

PSZ  pszOutput          = "w";  /* Used for OpenFile/fopen */

BOOL rgfReportItemFlag[] =
  {
    FALSE,  /* IDI_ALL_RECORDS           */
    FALSE,  /* IDI_MSD_HEADER_RECORD     */
    TRUE,   /* IDI_CUSTOMER_INFORMATION  */
    TRUE,   /* IDI_SUMMARY_SCREEN        */
    TRUE,   /* IDI_COMPUTER_RECORD       */
    TRUE,   /* IDI_MEMORY_RECORD         */
    TRUE,   /* IDI_VIDEO_RECORD          */
    TRUE,   /* IDI_NETWORK_RECORD        */
    TRUE,   /* IDI_OS_VERSION_RECORD     */
    TRUE,   /* IDI_MOUSE_RECORD          */
    TRUE,   /* IDI_OTHER_ADAPTERS_RECORD */
    TRUE,   /* IDI_DISK_DRIVE_RECORD     */
    TRUE,   /* IDI_LPT_RECORD            */
    TRUE,   /* IDI_COM_RECORD            */
    TRUE,   /* IDI_IRQ_RECORD            */
    TRUE,   /* IDI_TSR_PROGRAMS_RECORD   */
    TRUE,   /* IDI_DEVICE_DRIVERS_RECORD */
    TRUE,   /* Memory Browser            */
    TRUE,   /* AUTOEXEC.BAT              */
    TRUE,   /* CONFIG.SYS                */
    TRUE,   /* WIN.INI                   */
    TRUE,   /* SYSTEM.INI                */
    TRUE,   /* MSMAIL.INI                */
    TRUE,   /* PROTOCOL.INI		 */
    TRUE,   /* DBLSPACE.INI		 */
    TRUE    /* MEMMAKER.STS		 */
  };


PSZ  paszDefaultMsdIni[] =
  {
    "FILES=40, , CONFIG.SYS",
    "BUFFERS=20, , CONFIG.SYS",
    "SET TEMP=C:\\WINDOWS\\TEMP, , AUTOEXEC.BAT",
    NULL
  };


char * rgszSystemFiles[] =
  {
    "AUTOEXEC.BAT",
    "CONFIG.SYS",
    "SYSTEM.INI",
    "WIN.INI",
    "MSMAIL.INI",
    "PROTOCOL.INI",
    "DBLSPACE.INI",
    "MEMMAKER.STS",
    NULL
  };

WORD iszMax2 = sizeof (rgszSystemFiles) / sizeof (PSZ);

WORD rgwSystemFiles[] =
  {
    SEARCH_BOOT_DRIVE,
    SEARCH_BOOT_DRIVE,
    SEARCH_WINDIR,
    SEARCH_WINDIR,
    SEARCH_WINDIR,
    SEARCH_LANMAN_ROOT,
    SEARCH_LOCAL_DRIVES|SEARCH_ROOT|RECURSE_INTO_SUB_DIRS,
    SEARCH_LOCAL_DRIVES|SEARCH_ROOT|RECURSE_INTO_SUB_DIRS
  };

PSZ  pszInsertCommand  = NULL;
PSZ  pszInsertSection  = NULL;
PSZ  pszInsertFilename = NULL;


/* "Computer" strings */

PSZ  paszComputerTitles[] =
  {
        "Computer Name: ",
    "BIOS Manufacturer: ",
         "BIOS Version: ",
                       "",
                       "",
        "BIOS Category: ",
        "BIOS ID Bytes: ",
            "BIOS Date: ",
            "Processor: ",
     "Math Coprocessor: ",
             "Keyboard: ",
             "Bus Type: ",
       "DMA Controller: ",
        "Cascaded IRQ2: ",
    "BIOS Data Segment: ",
    NULL
  };

PSZ  pszEnhanced        = "Enhanced";
PSZ  pszNonEnhanced     = "Non-Enhanced";

PSZ  pszXtBus           = "ISA/XT/Classic Bus";
PSZ  pszAtBus           = "ISA/AT/Classic Bus";
PSZ  pszMicroChannel    = "Micro Channel";
PSZ  pszEisaBus         = "EISA";

PSZ  pszIntel8088       = "8088 or 8086";
PSZ  pszIntel80188      = "80188";
PSZ  pszIntel80186      = "80186";
PSZ  pszIntel80286      = "80286";
PSZ  pszIntel80386      = "80386";
PSZ  pszNECV20          = "NECV20 or NECV30";
PSZ  pszIntel8087       = "8087";
PSZ  pszIntel80287      = "80287";
PSZ  pszIntel80387      = "80387";
PSZ  pszInternal        = "Internal";
PSZ  pszInteli486       = "486DX";
PSZ  pszIntel486SX      = "486SX";


/* Memory strings */

PSZ  paszMemoryTitles[] =
  {
    "Conventional Memory",
                   "Total: ",
               "Available: ",

    "Extended Memory",
                   "Total: ",

    "MS-DOS Upper Memory Blocks",
              "Total UMBs: ",
         "Total Free UMBs: ",
      "Largest Free Block: ",

    "Expanded Memory (EMS)",
             "LIM Version: ",
      "Page Frame Address: ",
                   "Total: ",
               "Available: ",

    "XMS Information",
             "XMS Version: ",
          "Driver Version: ",
        "A20 Address Line: ",
        "High Memory Area: ",
               "Available: ",
      "Largest Free Block: ",
          "Available SXMS: ",
       "Largest Free SXMS: ",
      "Total Free XMS UMB: ",
    "Largest Free XMS UMB: ",

    "VCPI Information",
           "VCPI Detected: ",
                 "Version: ",
        "Available Memory: ",

    "DPMI Information",
           "DPMI Detected: ",
                 "Version: ",
  };

PSZ  pszNoPageFrame = "No Page Frame";
PSZ  pszEnabled     = "Enabled";
PSZ  pszNotEnabled  = "Not Enabled";
PSZ  pszError       = "Error";


/* Video strings */

PSZ  paszVideoTitles[] =
  {
        "Video Adapter Type: ",
              "Manufacturer: ",
                     "Model: ",
              "Display Type: ",
                "Video Mode: ",
         "Number of Columns: ",
            "Number of Rows: ",
        "Video BIOS Version: ",
                            "",
                            "",
           "Video BIOS Date: ",
    "VESA Support Installed: ",
              "VESA Version: ",
             "VESA OEM Name: ",
         "Secondary Adapter: ",
              "TIGA Version: ",
    "TIGA Interrupt/Address: ",
    NULL
  };


/* Network Types */

PSZ  paszNetworkTypes[] =
  {
    "No Network",
    "Unknown Network",
    "MS-NET Compatible",
    "LANMAN",
    "LANMAN Basic",
    "LANMAN Enhanced",
    "Novell",
    "Banyan",
    "LANtastic",
    "PC-NFS",
    "MS Workgroup Client",
    NULL
  };

PSZ  paszNetworkTitles[] =
  {
    /* Generic network strings */

            "Network Detected: ",
                "Network Name: ",
             "Network Version: ",
    "MS-DOS Network Functions: ",
               "Computer Name: ",
             "NetBIOS Present: ",
      "NetBIOS INT 5C Address: ",

    /* LANMAN strings */

                "Network Root: ",
                   "User Name: ",
/*            "Primary Domain: ", */
                   "Workgroup: ",
           "Server Connection: ",
            "Mailslot Support: ",
                 "API Support: ",
            "LAN Manager Date: ",
         "Current Patch Level: ",

    "NetBIOS Card Information:",
    "Workstation Services:",
    "PROTOCOL.INI Information:",
    "LANMAN.INI Driver Information:",

    /* Novell strings */

               "Shell Version: ",
            "Shell Located in: ",
                    "Shell OS: ",
            "Shell OS Version: ",
               "Hardware Type: ",
              "Station Number: ",
     "Physical Station Number: ",
               "IPX Installed: ",
               "SPX Installed: ",
           "ODI/LSL Installed: ",

    /* LANtastic strings */


            "LANtastic Server: ",
             "LANtastic Redir: ",
             "LANtastic Popup: ",
  };

PSZ pszSupported    = "Supported";
PSZ pszNotSupported = "Not Supported";


/* Operating System strings */

PSZ  paszOsVersionTitles[] =
  {
              "Operating System: ",
             "Internal Revision: ",
             "OEM Serial Number: ",
            "User Serial Number: ",
            "OEM Version String: ",
                "DOS Located in: ",
                    "Boot Drive: ",
        "DOSSHELL Task Switcher: ",
             "Microsoft Windows: ",
              "DESQview Version: ",
    "3270 ", /* Control Program: */
           "DoubleDOS Installed: ",
            "TaskView Installed: ",
               "TopView Version: ",
               "Path to Program: ",
    NULL
  };

PSZ  pszOs2                = "OS/2";
PSZ  pszMsDos              = "  Non MS-DOS";
PSZ  pszRom                = "ROM";
PSZ  pszHma                = "HMA";
PSZ  pszConventional       = "Conventional Memory";
PSZ  pszWin286             = "Windows/286";
PSZ  pszWin386             = "Windows/386";
PSZ  pszWindows            = "Windows";
PSZ  pszRealMode           = "Real Mode";
PSZ  pszStandardMode       = "Standard Mode";
PSZ  pszEnhancedMode       = "Enhanced Mode";
PSZ  psz_2dotX             = " 2.x";
PSZ  pszPCControlProgram   = "PC Control Program: ";
PSZ  pszWorkstationProgram = "Workstation Program: ";
PSZ  pszActive             = "Active";
PSZ  pszDosShell           = "DOSSHELL";
PSZ  pszEnvironmentStr     = "Environment Strings";
PSZ  pszEnvironInvalid     = "Environment string is invalid";
PSZ  pszTemp               = "TEMP";
PSZ  pszTmp                = "TMP";

PSZ  pszPathToProgram      = NULL;  /* Global variable -- stores argv[0] */
BOOL fTempPathInvalid      = FALSE;
BOOL fTmpPathInvalid       = FALSE;


/* Mouse strings */

PSZ  paszMouseMfgrs[] =
  {
    "No Mouse Driver",
    "Microsoft",
    "PC Mouse",
    "Logitech",
  };

PSZ  paszMouseTypes[] =
  {
    "Unknown Mouse Type",
    "Bus Mouse",
    "Serial Mouse",
    "InPort Mouse",
    "IBM PS/2 Mouse",
    "Hewlett-Packard Mouse",
    "Not Detected",
    "Logitech Serial Mouse",
    "Logitech PS/2 Mouse",
    "Microsoft PS/2 Mouse",
    "Ballpoint Mouse",
    "PS/2 Style Mouse"
  };

PSZ  paszMouseLanguages[] =
  {
    "English",
    "French",
    "Dutch",
    "German",
    "Swedish",
    "Finnish",
    "Spanish",
    "Portugese",
    "Italian"
  };

PSZ  paszMouseRatios[] =
  {
    "0.31",
   "0.062",
   "0.125",
    "0.25",
   "0.375",
     "0.5",
   "0.625",
    "0.75",
   "0.875",
       "1",
    "1.25",
     "1.5",
    "1.75",
       "2",
    "2.25",
     "2.5",
    "2.75",
       "3",
    "3.25",
     "3.5",
    NULL
  };

PSZ  paszDriverFileTypes[] =
  {
    "",
    ".COM File",
    ".SYS File"
  };

PSZ  paszMouseTitles[] =
  {
               "Mouse Hardware: ",
          "Driver Manufacturer: ",
              "DOS Driver Type: ",
             "Driver File Type: ",
           "DOS Driver Version: ",
     "Microsoft Driver Version: ",
                    "Mouse IRQ: ",
               "Mouse COM Port: ",
       "Mouse COM Port Address: ",
      "Number of Mouse Buttons: ",
       "Horizontal Sensitivity: ",
        "Mouse to Cursor Ratio: ",
         "Vertical Sensitivity: ",
        "Mouse to Cursor Ratio: ",
              "Threshold Speed: ",
               "Mouse Language: ",
            "Path to MOUSE.INI: ",
    NULL
  };


PSZ  pszBallPoint          = "BallPoint Mouse";
PSZ  pszDeviceNotDetected  = "Device Not Detected";
PSZ  pszColonOne           = " : 1";
PSZ  pszUndefined          = "Undefined";
PSZ  pszUnexplainedError   = "Non-fatal error detected in MSD.EXE: error %u\n(Please contact Windows 3.1 beta support)";


/* Other Adapter strings */

PSZ paszOtherTitles[] =
  {
        "Game Adapter: ",
      "Joystick A - X: ",
                   "Y: ",
            "Button 1: ",
            "Button 2: ",
      "Joystick B - X: ",
                   "Y: ",
            "Button 1: ",
            "Button 2: ",
/*
        "Sound Device: ",
           "Sound IRQ: ",
            "I/O Port: ",
*/
    NULL
  };

PSZ  pszGameAdapter        = "Game Adapter";
PSZ  pszDetected           = "Detected";
PSZ  pszNotDetected        = "Not Detected";


/* Disk Drive strings */

PSZ  pszDiskHeader         = "Drive  Type                                  Free Space  Total Size";
PSZ  pszDiskUnderline      = "-----  ------------------------------------  ----------  ----------";

PSZ  pszCylinders          = "%u Cylinders";
PSZ  pszHeads              = "%u Heads";
PSZ  pszBytesPerSector     = "%u Bytes/Sector";
PSZ  pszSectorsPerTrack    = "%u Sectors/Track";
PSZ  pszCommaSpace         = ", ";

PSZ  pszJoinInstalled      = "JOIN Installed";
PSZ  pszSubstInstalled     = "SUBST Installed";
PSZ  pszShareInstalled     = "SHARE Installed";
PSZ  pszAssignInstalled    = "ASSIGN Installed";
PSZ  pszAssign             = "ASSIGN";
PSZ  pszAppendInstalled    = "APPEND Installed";
PSZ  pszAppendPath         = "APPEND Path: ";
PSZ  pszMscdexInstalled    = "MSCDEX Version %u.%02u Installed";
PSZ  pszMscdex1x           = "MSCDEX Version %u.x Installed";
PSZ  pszLastdrive          = "LASTDRIVE=%c:";

PSZ  paszDriveTypes[] =
  {
    "Unknown Drive Type",
    "Floppy Drive",
    "Floppy Drive, 5.25\" 360K",
    "Floppy Drive, 5.25\" 1.2M",
    "Floppy Drive, 3.5\" 720K",
    "Floppy",
    "Floppy",
    "Fixed Disk",
    "Tape Drive",
    "Floppy Drive, 3.5\" 1.44M",
    "Optical Disk",
    "Floppy Drive, 3.5\" 2.88M",
    "Remote Drive",
    "RAM Disk",
    "CD-ROM Drive",
    "SUBST Drive",
    "ASSIGN Drive"
  };


/* IRQ data */

PSZ  pszIrqHeader    = "IRQ  Address    Description       Detected            Handled By";
PSZ  pszIrqUnderline = "---  ---------  ----------------  ------------------  ----------------";

PSZ  paszPcIrqDescriptions[] =
  {
    "Timer",
    "Keyboard",
    "I/O Channel",
    "COM2:, COM4:",
    "COM1:, COM3:",
    "Fixed Disk",
    "Floppy Disk",
    "LPT1:"
  };

PSZ  paszAtIrqDescriptions[] =
  {
    "Timer Click",
    "Keyboard",
    "Second 8259A",
    "COM2: COM4:",
    "COM1: COM3:\0COM4:",
    "LPT2:",
    "Floppy Disk",
    "LPT1:",
    "Real-Time Clock",
    "Redirected IRQ2",
    "(Reserved)",
    "(Reserved)",
    "(Reserved)",
    "Math Coprocessor",
    "Fixed Disk",
    "(Reserved)"
  };

PSZ  pszCom[] =
  {
    "",
    "COM1:",
    "COM2:",
    "COM3:",
    "COM4:"
  };

PSZ  pszBIOS               = "BIOS";


/* LPT strings */

PSZ  pszLptHeader1         = "         Port     On     Paper    I/O    Time";
PSZ  pszLptHeader2         = "Port   Address   Line     Out    Error    Out    Busy     ACK";
PSZ  pszLptUnderline       = "-----  -------   ----    -----   -----   ----    ----     ---";


/* COM strings */

PSZ  pszComHeader          = "COM1:      COM2:      COM3:      COM4:";
PSZ  pszComUnderline       = "-----      -----      -----      -----";

PSZ  psz1point5            = "1.5";
PSZ  pszNA                 = "N/A";
PSZ  pszOn                 = "On";
PSZ  pszOff                = "Off";

PSZ  paszComTitles[] =
  {
    "Port Address",
    "Baud Rate",
    "Parity",
    "Data Bits",
    "Stop Bits",
    "Carrier Detect (CD)",
    "Ring Indicator (RI)",
    "Data Set Ready (DSR)",
    "Clear To Send (CTS)",
    "UART Chip Used"
  };

PSZ  paszUartChips[] =   /* UART chip names */
  {
    "8250",
    "Unknown",
    "16550",
    "16550AF"
  };

PSZ  paszParityDesc[] = /* Parity descriptions */
  {
    "None",
    "Odd",
    "Even",
    "Mark",
    "Space"
  };


/* TSR strings */

PSZ  pszTsrHeader       = "Program Name        Address   Size   Command Line Parameters";
PSZ  pszTsrUnderline    = "------------------  -------  ------  --------------------------------";

PSZ  pszFreeMemory      = "Free Memory";
PSZ  pszDosSystemArea   = "System Area";
PSZ  pszCommandCom      = "COMMAND.COM";
PSZ  pszCommand         = "COMMAND";
PSZ  pszExcludedUmbArea = "Excluded UMB Area";
PSZ  pszVideoRom        = "  Video ROM BIOS";
PSZ  pszHardDiskRom     = "  Disk Controller";
PSZ  pszOptionRom       = "  Option ROM";
PSZ  pszVideoRam        = "  Video Memory";
PSZ  pszDosSystemCode   = "System Code";
PSZ  pszDosSystemData   = "System Data";
PSZ  pszDeviceAppenage  = "  Device Appendage";
PSZ  pszFileHandles     = "  File Handles";
PSZ  pszFCBS            = "  FCBS";
PSZ  pszBuffers         = "  BUFFERS";
PSZ  pszDirectories     = "  Directories";
PSZ  pszStacksArea      = "  Default Handlers";
PSZ  pszIntTable        = "Interrupt Table";
PSZ  pszRomDataArea     = "ROM Data Area";
PSZ  pszDosDataArea     = "System Data Area";


/* Device driver strings */

PSZ  pszDeviceHeader    = "Device        Filename  Units    Header      Attributes";
PSZ  pszDeviceUnderline = "------------  --------  -----  ---------  ----------------";

PSZ  pszBlockDevice     = "Block Device";


/* File Viewer strings */

PSZ  pszDot             = ".";
PSZ  pszDotDot          = "..";


PSZ  pszPathNotThere    = "Path does not exist";


PSZ  paszButtonNames[] =
  {
    "",
    "MSD Version Number",
    "Customer Information",
    "Summary Information",
    "Computer",
    "Memory",
    "Video",
    "Network",
    "OS Version",
    "Mouse",
    "Other Adapters",
    "Disk Drives",
    "LPT Ports",
    "COM Ports",
    "IRQ Status",
    "TSR Programs",
    "Device Drivers",
  };

PSZ  paszMainBtnArray[] =
  {
    "Computer...",
    "Memory...",
    "Video...",
    "Network...",
    "OS Version...",
    "Mouse...",
    "Other Adapters...",
    "Disk Drives...",
    "LPT Ports...",
    "COM Ports...",
    "IRQ Status...",
    "TSR Programs...",
    "Device Drivers...",
  };

SUMMARY_STRUCT *pSum;


#ifdef CW_INCLUDED

PSZ  paszCommandLineHelp[] =
  {
"Provides detailed technical information about your computer.\n"
"\n"
"MSD [/I] [/F[drive:][path]filename] [/P[drive:][path]filename]\n"
"    [/S[drive:][path][filename]]\n"
"\n"
"MSD [/B][/I]\n"
"\n"
"  /B                         Runs MSD using a black and white color scheme.\n"
"  /I                         Bypasses initial hardware detection.\n"
"  /F[drive:][path]filename   Requests input and writes an MSD report to the\n"
"                             specified file.\n"
"  /P[drive:][path]filename   Writes an MSD report to the specified file\n"
"                             without first requesting input.\n"
"  /S[drive:][path][filename] Writes a summary MSD report to the specified\n"
"                             file. If no filename is specified, output is to\n"
"                             the screen.\n"
"\n"
"Use MSD [/B] [/I] to examine technical information through the MSD interface.\n",
    NULL
  };

#else /* CW_INCLUDED */

PSZ  paszCommandLineHelp[] =
  {
"Provides detailed technical information about your computer.\n"
"\n"
"MSD [/S[drive:][path][filename]]\n"
"\n"
"  /S[drive:][path][filename] Writes a summary MSD report to the specified\n"
"                             file. If no filename is specified, output is to\n"
"                             the screen.\n",
    NULL
  };

#endif /* CW_INCLUDED */


/* Box description for the info window */

#ifdef CW_INCLUDED

BOX boxInfoBox =
  {
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
  };

PBOX pboxInfoBox = &boxInfoBox;

#endif /* CW_INCLUDED */


/* Title lines, displayed during the /F report to file */

PSZ  paszMsdTitleLines[] =
  {
    "\nMSD Microsoft Diagnostics Version " MSD_VERSION_NUMBER,
    "Copyright (C) Microsoft Corporation 1990-92\n",
    "Please enter your Name, Company Name,",
    "Address (two lines), City, State, ZIP code",
    "telephone number, and comment on the lines below:\n",
    NULL
  };

PSZ  paszCustInfoTitle[] =
  {
    "        Name: ",
    "Company Name: ",
    "    Address1: ",
    "    Address2: ",
    " City/ST/Zip: ",
    "     Country: ",
    "       Phone: ",
    "    Comments: ",
    NULL
  };

CUSTINFO *pCustInfoDlg;   /* Customer information for the dialog box */


/* Record Types */

WORD rwRecordTypes[] =
  {
    IDI_ALL_RECORDS,
    IDI_MSD_HEADER_RECORD,
    IDI_CUSTOMER_INFORMATION,
    IDI_SUMMARY_SCREEN,
    IDI_COMPUTER_RECORD,
    IDI_MEMORY_RECORD,
    IDI_VIDEO_RECORD,
    IDI_NETWORK_RECORD,
    IDI_OS_VERSION_RECORD,
    IDI_MOUSE_RECORD,
    IDI_OTHER_ADAPTERS_RECORD,
    IDI_DISK_DRIVE_RECORD,
    IDI_LPT_RECORD,
    IDI_COM_RECORD,
    IDI_IRQ_RECORD,
    IDI_TSR_PROGRAMS_RECORD,
    IDI_DEVICE_DRIVERS_RECORD,
    0
  };

WORD wMaxRecords = 15;

WORD rwIrqRecordTypes[] =
  {
    IDI_COMPUTER_RECORD,
    IDI_MOUSE_RECORD,
    IDI_DISK_DRIVE_RECORD,
    IDI_LPT_RECORD,
    IDI_COM_RECORD,
    0
  };


/* Language ID */

LANGUAGE_ID rgLang[] =
  {
    { 0x0401, "Arabic" },
    { 0x0402, "Bulgarian" },
    { 0x0403, "Catalan" },
    { 0x0404, "Traditional Chinese" },
    { 0x0804, "Simplified Chinese" },
    { 0x0405, "Czech" },
    { 0x0406, "Danish" },
    { 0x0407, "German" },
    { 0x0807, "Swiss German" },
    { 0x0408, "Greek" },
    { 0x0409, "U.S. English" },
    { 0x0809, "U.K. English" },
    { 0x040A, "Castilian Spanish" },
    { 0x080A, "Mexican Spanish" },
    { 0x040B, "Finnish" },
    { 0x040C, "French" },
    { 0x080C, "Belgian French" },
    { 0x0C0C, "Canadian French" },
    { 0x100C, "Swiss French" },
    { 0x040D, "Hebrew" },
    { 0x040E, "Hungarian" },
    { 0x040F, "Icelandic" },
    { 0x0410, "Italian" },
    { 0x0810, "Swiss Italian" },
    { 0x0411, "Japanese" },
    { 0x0412, "Korean" },
    { 0x0413, "Dutch" },
    { 0x0813, "Belgian Dutch" },
    { 0x0414, "Norwegian - Bokmal" },
    { 0x0814, "Norwegian - Nynorsk" },
    { 0x0415, "Polish" },
    { 0x0416, "Brazilian Portuguese" },
    { 0x0417, "Rhaeto-Romanic" },
    { 0x0418, "Romanian" },
    { 0x0419, "Russian" },
    { 0x041A, "Croato-Serbian (Latin)" },
    { 0x081A, "Serbo-Croatian (Cyrillic)" },
    { 0x041B, "Slovak" },
    { 0x041C, "Albanian" },
    { 0x041D, "Swedish" },
    { 0x041E, "Thai" },
    { 0x041F, "Turkish" },
    { 0x0420, "Urdu" },
    { 0x0421, "Bahasa" },
    { 0xFFFF, "Unknown" }
  };


CODEPAGE_ID rgCP[] =
  {
    {  932, "Windows, Japan (Shift-JIS X-0208)" },
    {  949, "Windows, Korea (Shift-KSC 5601)" },
    {  950, "Windows, Taiwan (GB5)" },
    { 1200, "Unicode" },
    { 1250, "Windows, Latin-2 (Easter European)" },
    { 1251, "Windows, Cryillic" },
    { 1252, "Windows, Multilingual (ANSI)" },
    { 1253, "Windows, Greek" },
    { 1254, "Windows, Turkish" },
    { 1255, "Windows, Hebrew" },
    { 1256, "Windows, Arabic" },
    {65535, "Unknown" }
  };
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\deltree.c ===
/***    DELTREE.C - Delete directory tree
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992
 *      All Rights Reserved.
 *
 *      History:
 *          07-Nov-1992 bens   Copied from ZTOOLS project
 *	    02-Dec-1992 rhogue Remove sargv.obj which doesn't recognize
 *			       hidden/system files.
 */

#include <tools.h>
#include <ctype.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>

#include "deltree.msg" // Localizable strings

#define BS    0x08
#define CTRLC 0x03
#define CTRLZ 0x1A
#define ENTER 0x0d

flagType fAsk = TRUE;  // global variable for asking confirmation

/***    Usage - show command line /? help
 *
 */
void Usage(void)
{
    int     i;

    for (i=0; i<(sizeof(apszHelp)/sizeof(char *)); i++) {
        printf ("%s\n",apszHelp[i]);
    }
    exit(1);
}

static void fConfirm (
    char		*name,
    struct findType	*pBuf,
    va_list		ap
    )
{
    int ch, chLast;
    char sz[MAXPATHLEN];

    fileext (name, sz);
    if (!strcmp ("..", sz) || !strcmp (".", sz))
	return;

    if (fAsk == FALSE) {
	printf (pszMsgDeleting, name);
	delnode (name);
	return;
    }

    /*	flush pending inut
     */
    while (!kbhit ())
	zgetch ();  //int 21 ah 7 call

    /* if name is a directory then display the del dir msg, else display
     * the del file msg.
     */
    if ( ((char) getattr (name)) == A_D)
	printf (pszMsgDelDirPrompt, name);
    else
	printf (pszMsgDelFilePrompt, name);

    /*	Wait until we see a Y<CR> or N<CR>
     */

    chLast = 0;
    while (TRUE) {
	ch = getch ();
	ch = tolower (ch);
        if (ch == ENTER && (chLast == chYES || chLast == chNO)) {
	    printf ("\n");
	    if (ch == ENTER && (chLast == chYES)) {
		//"Deleting %s...\n"
		printf (pszMsgDeleting, name);
		delnode (name);
		return;
		} else
		    return;
	    }
	if (ch == CTRLC || ch == CTRLZ)
	    return;
	if (ch == chYES || ch == chNO) {
	    putch (ch);
	    putch (BS);
            chLast = ch;    // Remember most recent selection
	    }
	}
}

void
main(int c, char **v)
{
    char sz[MAXPATHLEN];
    int i;

    SHIFT (c, v);
    while (c && fSwitChr (**v)) {
        /*
         *  /Y is NOT localized, as is the standard for 1-char switch names
         */
	if (!strcmp (*v+1, "y") || !strcmp (*v+1, "Y"))
	    fAsk = FALSE;
	else {
            if (!strcmp (*v+1, "?")) {
		Usage ();
                exit (0);
                }
            else {
		printf (pszMsgInvalidSwitch,*v+1);
                exit (1);
                }
	    }
	SHIFT (c, v);
	}
    if (c == 0) {
	printf (pszMsgNoParameters);
	exit (1);
    }
    for (i=0; i < c; i++) {

	/* create a full path so forfile doesn't get confused */
	if (!fileext (v[i], sz))
	    /*	We have a directory.  upd() produces a "canonical" path
	     *	name (c:\foo\bar), eliminating any .\.. meta character
	     *	stuff, so that forfile will be happy.
	     */
	    upd ("*.*", v[i], sz);
	else {
	    /*	We have a file name.  If it is "." or "..", we need to
	     *	append \*.*, so that forfile will delete the specified
	     *	directory.  If we do not append the \*.*, forfile gets
	     *	confused and refuses to delete anything.
	     */
	    if (!strcmp ("..", sz) || !strcmp (".", sz)) {
		strcpy (sz, v[i]);
		pathcat (sz, "*.*");
	    } else
		strcpy (sz, v[i]);
	}

	forfile (sz, A_H | A_S | A_D, fConfirm);
    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\move.c ===
/***    MOVE.C - Move and Rename files and directories
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1992
 *      All Rights Reserved.
 *
 *      History:
 *          07-Nov-1992 bens   Copied from ZTOOLS project
 *          14-Nov-1992 bens   Update to \\TOOLSVR\SOURCE\...\SYSTOOLS project,
 *                                 and link with SETARGV.OBJ from C RTL!
 *	    02-Dec-1992 rhogue Remove sargv.obj which doesn't recognize
 *			       hidden/system files. Other bugs too.
 */

#include <dos.h>
#include <tools.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <io.h>
#include <direct.h>

#include "move.msg" // localizable strings

#define BS    0x08
#define CTRLC 0x03
#define CTRLZ 0x1A
#define ENTER 0x0d
#define MAX_DIR_PATH 66

char attr;    // keeps track of the destination files attribute (file, directory, etc...)
char * dst;   // pointer to destination path
char * src;   // pointer to source path
char * name;  // temp variable for parts of source path from forfile
int erc;      // variable for error condition

/***    Usage - show command line /? help
 *
 */
void Usage(void)
{
    int     i;

    for (i=0; i<(sizeof(apszHelp)/sizeof(char *)); i++) {
        printf ("%s\n",apszHelp[i]);
    }
}

/* find_longest - find the longest path in a subtree.  Recursive
*  function.
*
*	Input : full path name from which to start search
*	Output : length of longest path found
*	Stops if path length greater than MAX_DIR_PATH is found
*/
int
find_longest(register char *start_path)
{
	struct	find_t	findbuf;		/* buffer for DOS info */
	char	save_path[128]; 		/* save area for path */
	register int	 len1, len2;		/* length holders */

	/* save original path, and set up search path */
	strcpy(save_path,start_path);
	strcat(start_path,"\\*.*");
	len1 = strlen(save_path);		/* save starting length */

	/* skip over . and .. if present.  Return if not found */
	if (_dos_findfirst(start_path,_A_SUBDIR|_A_HIDDEN|_A_SYSTEM,&findbuf) ||
	    _dos_findnext(&findbuf))
		return(len1);

	/* find each subdirectory and check the path size */
	while (_dos_findnext(&findbuf) == 0)
	{
		if (!(findbuf.attrib & _A_SUBDIR))
			continue;		/* bounce files */
		strcpy(start_path,save_path);
		strcat(start_path,"\\");
		strcat(start_path,findbuf.name);
		len2 = find_longest(start_path);
		if (len2 > len1)
			len1 = len2;
	}

	return(len1);	/* return longest path found */
}

/* PromptUser - prompts the user for chYes or chNo
 *
 * return TRUE if chYes, and FALSE if chNo.
 */
int PromptUser(void)
{
    int ch, chLast;

    /*	flush pending inut */
    while (!kbhit ())
	zgetch ();  //int 21 ah 7 call

    /*	Wait until we see a Y<CR> or N<CR>
     */
    chLast = 0;
    while (TRUE) {
	ch = getch ();
	ch = tolower (ch);
        if (ch == ENTER && (chLast == chYES || chLast == chNO)) {
	    printf ("\n");
	    if (ch == ENTER && (chLast == chYES)) {
		return TRUE;
		} else
		    return FALSE;
	    }
	if (ch == CTRLC || ch == CTRLZ)
	    return FALSE;
	if (ch == chYES || ch == chNO) {
	    putch (ch);
	    putch (BS);
            chLast = ch;    // Remember most recent selection
	    }
	}
    // return FALSE;
}

/* fConfirm is called from forfile() to deltree a specific file or directory
   sz	   : file name or directory to deltree
   pBuf    : file attribute type, hidden,system etc...
   va_list : forfile() expected parameter
*/
static void fConfirm (
    char		*sz,
    struct findType	*pBuf,
    va_list		ap
    )
{
    int cb;
    char *s, szDstName[_MAX_PATH],szSrcPath[_MAX_PATH];

	fileext (sz, name);
	if (!strcmp ("..", name) || !strcmp (".", name))
	    return;

	if ( (rootpath (sz, src) == -1) )
	    goto cantmove;

	/* Check to see of the src file exists. fmove() doesn't check,
	 * and will delete the dst file even if the src doesn't exists
	 */
	if (access (sz,0) == -1)
	    goto cantmove;

	/* if src file is a system or hidden file tell the user we can't/won't move it */
	if ( ((char) getattr (src)) & (A_S|A_H) ) {
	    errno = EACCES;
	    goto cantmove;
	}

	/* If src is a directory then we are renaming a directory. We
	 * need to make sure the the rename doesn't create a path length
	 * greater than MAX_DIR_PATH.
	 */
	if ( ((char) getattr (src)) == A_D) {

	    /* Get the Destination directory name */
	    fileext (dst, szDstName);

	    /* if the destination dir name is longer than the src name,
	     * then we need to check to see of the creation of a longer
	     * directory will cause an path larger than MAX_DIR_PATH.
	     */
	    cb = (strlen(szDstName)) - (strlen(name));
	    strcpy (szSrcPath, src); // find_longest() modifies the string - make copy
	    if ( cb > 0 ) {

	       /* if the longest path plus the extra characters from the
		* new directory is greater than MAX_DIR_PATH then error.
		*/
	       if ( ((find_longest(szSrcPath))+cb) > MAX_DIR_PATH) {
		   errno = EACCES;
		   // "Cannot move %s - %s"
		   printf (pszErrCannotMove, sz, error ());
		   erc++;
		   return;
		   }
		}
	     }

	cb = strlen(src);
	if ( !strncmp(src, dst, cb) && *strbscan(dst+cb, "\\/") ) {
	    // takes 'loop'ers out with permissions error;
	    //	if match for all of source and there's a subdir, it's loop
	    errno = EACCES;
            // "Cannot move %s - %s"
cantmove:   printf (pszErrCannotMove, sz, error ());
            erc++;
	    return;
            }
	strcpy (name, dst);
        if (TESTFLAG(attr, A_D)) {
            if (!fPathChr (name[strlen(name)-1]))
                strcat (name, "\\");
            upd (src, name, name);
            }

	/* Check to see if the destination and source file are not identical */
	if (strcmpi (src,name) == 0) {
	    printf (pszMsgSrcEqualsDst, src, error ());
            erc++;
	    return;
	    }

	printf ("%s => %s ", src, name);
	fflush (stdout);
	s = fmove( src, name );
	if (s) {
	    erc++;
	    printf ("[%s]\n", s);
	    }
	else
	    // "[ok]\n"
	    printf (pszMsgOK);
}

void 
main (int c, char **v)
{
    int i, iLen, isMultipleFile=FALSE;
    char * pszBeginTokenString, * pszEndTokenString; // pointers strchr call
    char * pszSourceArgs;
    char * pszCwd;		    /* save current directory */
    unsigned num_drives;	    /* for setdrive call */
    unsigned cur_drive; 	    /* records current drive */
    struct findType *fbuf;	    /* for find first - find next */
    flagType fAsk = TRUE;	    /* for asking confirmation */

    pszSourceArgs = malloc (MAXPATHLEN);
    memset(pszSourceArgs, 0, MAXPATHLEN);
    src = malloc (MAXPATHLEN);
    memset(src, 0, MAXPATHLEN);
    dst = malloc (MAXPATHLEN);
    memset(dst, 0, MAXPATHLEN);
    name = malloc (MAXPATHLEN);
    memset(name, 0, MAXPATHLEN);

    /* check parameter validity */
    SHIFT (c,v);
    while (c && fSwitChr (**v)) {
        /*
         *  /Y is NOT localized, as is the standard for 1-char switch names
         */
	if (!strcmp (*v+1, "y") || !strcmp (*v+1, "Y"))
	    fAsk = FALSE;
	else {
	    /* check for /? switch to display usage */
	    if (!strcmp (*v+1, "?")) {
		Usage ();
		exit (0);
		}
	    else {
		printf (pszMsgInvalidSwitch,*v+1);
		exit (1);
		}
	    }
	SHIFT (c, v);
	}
    if (c < 2) {
        /* not enough parameters */
	printf (pszMsgNoParameters);
        exit (1);
	}

    if ( rootpath (v[c-1], dst) ) {
        // "Cannot move %s - %s\n"
        printf (pszErrCannotMove, v[c-1], error ());
        exit(1);
	}

    /* see if last char is path char ; if so remove it unless x:\ */
    if (fPathChr (dst[strlen(dst)-1])) {
	/* if not at root */
	if (strlen(dst) > 3) {
            /* get rid of trailing path char */
	    dst[strlen(dst)-1] = 0;
	}
    }

    /* White space is allowed in the command line with the comma used as a
     * delimeter.
     */
    strcpy (pszSourceArgs,v[0]);
    for (i=1; i < c-1; i++) {
	if ((v[i][0] == ',') || (v[i-1][(strlen(v[i-1]))-1] == ',') )
	    strcat (pszSourceArgs, v[i]);
	else {
	    printf (pszMsgTooManyParameters, v[i]);
	    exit (1);
	}
    }

    /* If the command line has the last arg as a source file, then
     * there isn't a destination file (assumed to be the last arg).
     *
     * Note: i is at least one because the for loop sets it to 1.
     */
    if ((v[c-1][0] == ',') || (v[i-1][(strlen(v[i-1]))-1] == ',') ) {
        /* not enough parameters */
	printf (pszMsgNoParameters);
        exit (1);
	}

    /* All the args are now in a single array in "file1,file2,..." format.
     * We need to find out if the dest is a directory or a file.
     *	   if move of multiple files to file	     - error.
     *	   if move of multiple files to non existant - confirm creation of dir.
     *	   if move of single file to non existant    - dest is a file.
     *	   if move of multiple files to dir	     - continue.
     *	   if move of single file to file | dir      - continue.
     */

    /* Check to see if there are muliple source files */

    pszBeginTokenString = pszSourceArgs;
    pszEndTokenString = strchr (pszBeginTokenString, ',');

    if (pszEndTokenString != NULL)
	isMultipleFile = TRUE;
    else {
    /* Even though we only have one src file, it could be a wildcard file.
     * if we can't access the source file then we will assume it is a
     * multiple file
     */
	/* Since there is only one src file, we can do a findfirst findnext
	 * to see if multiple files exist. If ffist fails, the error will
	 * get picked up during file forfile() process
	 */
	if (ffirst (pszBeginTokenString,A_ALL,fbuf) == FALSE) {
	    if (fnext (fbuf) == FALSE)
		isMultipleFile = TRUE;

	    findclose (fbuf);
	}
    }

    /* get the destinations file attribute FILE or DIRECTORY */
    attr = (char) getattr (dst);

    /* getattr will return -1 if the file doesn't exist.
     * if destintation doesn't exist (attr=-1), then if src is multiple file, ask
     * if the user wants to create the destination as a direcory. If the
     * src is a single file, then destination is a file
     */
    if (attr == -1) {
	if (isMultipleFile == TRUE) {
	    /* ask if the user wants to make the direcory for the mulitple file
	     * copy. If they don't, then we error because you can't copy multiple
	     * files to a file.
	     */

	    /*	if the /Y switch was given to suppress prompting, skip it */
	    if (fAsk == TRUE) {
		printf (pszMsgMakeDirPrompt, dst);
		i = PromptUser();
	    } else
		i=TRUE;

	    if (i == TRUE) {
		i = MkPath(dst);
		/* see if MkPath gave us an error */
		if (i != 0) {
		    // "Cannot move > 1 file to another file\n"
		    printf (pszErrCannotMoveMultiple);
		    exit (1);
		}
	    } else {
		// "Cannot move > 1 file to another file\n"
		printf (pszErrCannotMoveMultiple);
		exit (1);
	    }

	    /* set dest attribute to be of a directory type */
	    SETFLAG (attr, A_D);
	} else
	  /* set dest attribute to be a file type */
	  RSETFLAG (attr, A_D);
    } else {
	/* If multiple files and destination is a file then error */
	if ( !TESTFLAG(attr, A_D) && (isMultipleFile==TRUE) ) {
	    // "Cannot move > 1 file to another file\n"
	    printf (pszErrCannotMoveMultiple);
	    exit (1);
	}
    }

    erc = 0;
    while (pszBeginTokenString != NULL) {
	pszEndTokenString = strchr (pszBeginTokenString, ',');
	if (pszEndTokenString != NULL) {
	    *pszEndTokenString = '\0';
	    pszEndTokenString += 1;
	    }

	/* if the file is null, don't process it, otherwise we get an error message */
	if (*pszBeginTokenString != '\0') {

	    /* We may change drives in case of a directory move changing the CWD
	     * So keep track of the current drive.
	     */
	    _dos_getdrive(&cur_drive);	    /* remember current drive */

	    /* set CWD - to source file/dir drive. If the user changes
	     * the CWD for this drive, we will set the CWD to the root.
	     */
	    if (*(pszBeginTokenString+1) == ':')
		_dos_setdrive(toupper(*pszBeginTokenString) - 'A' + 1, &num_drives);

	    /* save current directory and drive */
	    pszCwd = getcwd (NULL,_MAX_PATH);


	    if (forfile (pszBeginTokenString, A_H | A_S | A_D, fConfirm) == FALSE)
		/* If forfile fails, it does not call fConfirm.  To avoid
		   duplicating error message code, we call fConfirm with
		   special parameters to force it to generate an error
		   message. */
		fConfirm (pszBeginTokenString,NULL,NULL);
	    }

	    /* if CWD has been changed we will remain an the root */
	    chdir("\\");			    /* change to root */
	    chdir(pszCwd);			    /* attempt to change dir to old CWD */
	    free((void *) pszCwd);

	    /* go back to the drive we originally came from */
	    _dos_setdrive(cur_drive, &num_drives);

	    pszBeginTokenString = pszEndTokenString;
	}

    exit (erc != 0);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\args.h ===
#ifndef ARGS_H
#define ARGS_H (1)

// args.h - definitions for argument parsing

#ifndef MAPSTR_H
#include <mapstr.h>
#endif // MAPSTR_H

// basic lookup structures
typedef char *ArgName;
typedef int *ArgOrder;

// argument detection routine
typedef int (*ArgTestFunc) ( char *, char ** );

int argStdNameTest (
        char *szArg,
        char *szMrk,
        char **pszText
        );

extern MapItemPtr argMapSplit (
        char *szArg,
        char *szSplit,
        MapItemPtr pMapTable,
        char **pszValu
        );

// configuration routines
extern void argConfig (
        MapItemPtr pNames,
        ArgOrder piSeqn,
        int cSeqn,
        char *szMrk,
        char *szSep
        );

extern void argSeqn (
        ArgOrder piSeqn,
        int cSeqn
        );

// argv transfer
extern void argOpen (
        char **argv
        );

extern char **argShut ( void );

// argument handling
extern int argName (
        int bad,
        ArgName *pszText
        );

extern int argPeek (
        int bad,
        ArgName *pszText
        );

extern char *argValu ( void );

#endif // ARGS_H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\dir.h ===
/* dir.h - structure of a directory entry */

struct dirType {
    char	name[8];		/* 00  packed FCB filename	     */
    char	ext[3]; 		/* 08  packed FCB extention	     */
    char	attr;			/* 0B  attribute		     */
    char	pad[10];		/* 0C  reserved space		     */
    unsigned	time;			/* 16  time of last modification     */
    unsigned	date;			/* 18  date of last modification     */
    unsigned	clusFirst;		/* 1A  first cluster on disk	     */
    long	size;			/* 1C  file size		     */
};


/* the following is what gets returned on FCB search calls */

struct srchdirType {
    char	drv;			/* 00  drive			     */
    char	name[8];		/* 01  packed FCB filename	     */
    char	ext[3]; 		/* 09  packed FCB extention	     */
    char	attr;			/* 0C  attribute		     */
    char	pad[10];		/* 0D  reserved space		     */
    unsigned	time;			/* 17  time of last modification     */
    unsigned	date;			/* 19  date of last modification     */
    unsigned	clusFirst;		/* 1B  first cluster on disk	     */
    long	size;			/* 1D  file size		     */
};


struct esrchdirType {
    char	eflg;			/* 00  must be 0xFF for extended     */
    char	pad1[5];		/* 01  padding			     */
    char	sattr;			/* 06  search attribute 	     */
    char	drv;			/* 07  drive			     */
    char	name[8];		/* 08  packed FCB filename	     */
    char	ext[3]; 		/* 10  packed FCB extention	     */
    char	attr;			/* 13  attribute		     */
    char	pad[10];		/* 14  reserved space		     */
    unsigned	time;			/* 1E  time of last modification     */
    unsigned	date;			/* 20  date of last modification     */
    unsigned	clusFirst;		/* 22  first cluster on disk	     */
    long	size;			/* 24  file size		     */
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright Microsoft Corp. 1984, 1985, 1986
$
if1
ASMpass=1
outif MACRO name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
%out ! onmsg
endif
else
ifnb <offmsg>
%out ! offmsg
endif
endif
endm
??error macro msg
E r r o r ----- msg
endm
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
%out cMacros Version 2.07 - 9/19/86
%out Copyright (C) Microsoft Corp. 1984, 1985, 1986. All rights reserved.
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
??error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows Support>
outif ?PLM,1,<PLM calling convention>
ifndef ?NODATA
?NODATA1=0
else
?NODATA1=1
%out ! NODATA module
endif
ifndef ?CHKSTK
?CHKSTK1=0
else
?CHKSTK1=1
ifdef ?CHKSTKPROC
%out ! Private stack checking enabled
else
%out ! Stack checking enabled
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
%out ! DOS5 module
endif
ifdef ?PROFILE
%out ! Native Profiling Enabled
endif
else
ASMpass=2
endif
.XCREF
.XCREF ?N,?AX,?AH,?AL,?BX,?BH
.XCREF ?BL,?CX,?CH,?CL,?DX,?DH
.XCREF ?DL,?SI,?DI,?ES,?DS,?BP
.XCREF ?SP,?SS,?CS
.XCREF ?RSL,?CPD,?argl,?argc,?BA
.XCREF ?ACB,???,?PO
.XCREF ?PAS,?PC
.XCREF Uconcat,mPush,mPop
.XCREF ?RI,?pp,?pp1,?al1
.XCREF ?aD,?AP,?Atal,?dd,?dd1
.XCREF ?pg,?pg1,?aloc,?cs1,?cs2
.XCREF ?DF,?TF,?FF,?PLM,?WIN,?IA,?PU,?ADJ
.XCREF ?UF,?RP,?NX,?ND,?NODATA1,?CHKSTK1,?DOS5
.XCREF ?WFP
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?RP = 0
?UF = 0
?ND = 0
?NX = 0
?WFP = 0
?FF = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
.CREF
uconcat macro a,b,c,d,e,f
a&b c&d e&f
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if r AND ?&&x
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if r AND ?&&x
pop x
endif
endm
endm
save macro r
?RSL=0
?RI ?RSL,<r>
endm
?RI macro n,r
irp x,<r>
ifdef ?&&x
n=n OR ?&&x
endif
endm
endm
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<n>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<QWORD>,8,8
endm
parmT macro n
?pp <n>,<TBYTE>,10,10
endm
if sizeC
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sizeD
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?CPD
.xcref
irp x,<n>
.xcref ?T&&x
?T&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?PO+?adj)
?PO=?PO+l
else
?PO=?PO+l
?pp1 x,<t>,%?PO,%?adj
endif
endm
.cref
else
??error <Parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
ifndef ?NOPARMR
.XCREF
.XCREF ?pr
.CREF
parmR macro n,r,r2
?pr n,r,r2,%?RP,%(?IA+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR SEG_&n,r
parmR OFF_&n,r2
n equ dword ptr [bp-o-2]
.xcref ?T&n
?T&n=4
else
.xcref ?RP&i
?RP&i=0
ifdef ?&r
?RP&i=?&r
endif
if ??? OR (?CPD EQ 0) OR (?RP&i EQ 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ word ptr [bp-o]
?T&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x EQ ?&r
n equ byte ptr [bp-o]
?T&n=1
exitm
endif
endm
?IA=?IA+2
?RP=?RP+1
endif
.cref
endm
endif
localB macro n
?aLoc <n>,<BYTE ptr>,1,1,0
endm
localW macro n
?aLoc <n>,<WORD PTR>,2,2,1
endm
localD macro n
irp x,<n>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro n
?aLoc <n>,<QWORD PTR>,8,8,1
endm
localT macro n
?aLoc <n>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sizeD
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aLoc <n>,,%(a),0,1
endm
?aLoc macro n,t,l,s,a
if ?CPD
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) AND 0FFFEH)
endif
?aL1 x,<t>,%(???+?IA)
.xcref ?T&&x
?T&&x=s
endm
.cref
else
??error <Locals "&n" declared outside procedure def>
endif
endm
?aL1 macro n,t,o
n equ t [bp-o]
endm
ifndef ?NOGLOBAL
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
endif
ifndef ?NOSTATIC
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
ifndef ?NOEXTERN
.XCREF
.XCREF ?ex1
.CREF
externB macro n
?ex1 <n>,1,<BYTE>
endm
externW macro n
?ex1 <n>,2,<WORD>
endm
externD macro n
?ex1 <n>,4,<DWORD>
endm
externQ macro n
?ex1 <n>,8,<QWORD>
endm
externT macro n
?ex1 <n>,10,<TBYTE>
endm
externNP macro n
?ex1 <n>,2,<NEAR>
endm
externFP macro n
?ex1 <n>,4,<FAR>
endm
if sizeC
externP macro n
?ex1 <n>,4,<FAR>
endm
else
externP macro n
?ex1 <n>,2,<NEAR>
endm
endif
if sizeC
externCP macro n
?ex1 <n>,4,<DWORD>
endm
else
externCP macro n
?ex1 <n>,2,<WORD>
endm
endif
if sizeD
externDP macro n
?ex1 <n>,4,<DWORD>
endm
else
externDP macro n
?ex1 <n>,2,<WORD>
endm
endif
?ex1 macro n,s,d
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
endif
ifndef ?NOLABEL
.XCREF
?lblpu = 0
.XCREF ?lb1,?lblpu
.CREF
labelB macro n
?lb1 <n>,1,<BYTE>
endm
labelW macro n
?lb1 <n>,2,<WORD>
endm
labelD macro n
?lb1 <n>,4,<DWORD>
endm
labelQ macro n
?lb1 <n>,8,<QWORD>
endm
labelT macro n
?lb1 <n>,10,<TBYTE>
endm
labelNP macro n
?lb1 <n>,2,<NEAR>
endm
labelFP macro n
?lb1 <n>,4,<FAR>
endm
if sizeC
labelP macro n
?lb1 <n>,4,<FAR>
endm
else
labelP macro n
?lb1 <n>,2,<NEAR>
endm
endif
if sizeC
labelCP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelCP macro n
?lb1 <n>,2,<WORD>
endm
endif
if sizeD
labelDP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelDP macro n
?lb1 <n>,2,<WORD>
endm
endif
?lb1 macro n,s,d
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
defB macro n
?aD <n>,1
endm
defW macro n
?aD <n>,2
endm
defD macro n
?aD <n>,4
endm
defQ macro n
?aD <n>,8
endm
defT macro n
?aD <n>,10
endm
if sizeC
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sizeD
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?aD macro n,s
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
endm
endm
ifndef ?NOPTR
regPtr macro n,S,O
farPtr n,S,O
endm
farptr macro n,S,O
.xcref
.xcref ?T&n
.cref
n &macro
push S
push O
&endm
?T&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
.xcref
.xcref ?ALI&i
.cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl=?argl+2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?T&n AND 80h
n
?argl=?argl+2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
ife ?PLM
?ACB=?argc
else
?ACB=1
endif
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
ife ?PLM
?ACB=?ACB-1
else
?ACB=?ACB+1
endif
endm
ife ?PLM
ifb <sleaze>
call _&n
else
call n
endif
if ?argl
add sp,?argl
endif
else
call n
endif
mpop %?RSL
?RSL=0
?argc= 0
?argl= 0
endm
cProc macro n,c,a
if ?CPD
?UTPE
endif
?CPD=1
???=0
?argc=0
?BA=0
?PO=0
?PU=0
?IA=0
?adj=4
?RP=0
?UF=0
?WFP=0
?FF=0
?PAS=0
ifnb <a>
?RI ?PAS,<a>
endif
?PC=sizeC
?ND=?NODATA1
?NX=0
irp x,<c>
ifidn <x>,<FAR>
?PC=1
endif
ifidn <x>,<NEAR>
?PC=0
endif
ifidn <x>,<PUBLIC>
?PU=1
endif
ifidn <x>,<SMALL>
?UF=1
endif
ifidn <x>,<DATA>
?ND=0
endif
ifidn <x>,<NODATA>
?ND=1
endif
ifidn <x>,<ATOMIC>
?NX=1
endif
ifidn <x>,<FORCEFRAME>
?FF=1
endif
endm
if (?NX eq 1) AND (?ND eq 0)
?NX = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?PC
if ?WIN
?WFP=1
ife ?NX
?IA=2
?PAS = ?PAS AND (NOT ?ds)
endif
endif
?adj=?adj+2
endif
?PAS = ?PAS AND (NOT (?sp+?cs+?ss))
if ?UF
?PAS = ?PAS AND (NOT (?bp+?si+?di))
endif
ife ?PLM
?pg <_&n>,%?PU,%?PC,%?PAS,%?WFP,<n>
else
?pg <n>,%?PU,%?PC,%?PAS,%?WFP,<n>
endif
endm
?pg macro n,p,c,a,w,nu
.xcref
if ?UF
if ?RP
??error <parmR encountered in &n - user frame ignored>
?UF=0
endif
if ?ND
??error <NODATA encountered in &n - user frame ignored>
?UF=0
endif
endif
cBegin &macro g
.xcref
?pg1 <n>,c,a,%?PO,w,%?UF,%?ND,%?RP
?CPD=0
?argc=0
?BA=1
???=(???+1) AND 0FFFEH
if p
PUBLIC n
endif
ife ?PLM
ife c
nu label near
else
nu label far
endif
endif
ife c
n proc NEAR
else
n proc FAR
endif
ifidn <g>,<nogen>
if ???+?PO+a+?RP
%out <cBegin - possible invalid use of nogen>
endif
else
if ?UF
?MF c,%???,%?PO
mPush a
else
if w
ife ?ND
mov ax,ds
nop
endif
ife ?NX
ife ?DOS5
inc bp
endif
push bp
mov bp,sp
push ds
else
if ?FF+???+?PO+?RP
push bp
mov bp,sp
endif
endif
ife ?ND
mov ds,ax
endif
else
if ?FF+???+?PO+?RP
push bp
mov bp,sp
endif
endif
if ?RP
?UF=0
rept ?RP
uconcat mpush,,?RP,%?UF
?UF=?UF+1
endm
endif
if ???
if ?CHKSTK1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
mov ax,???
ife ?PLM
call _chkstk
else
call chkstk
endif
endif
else
sub sp,???
endif
endif
mPush a
endif
ifdef ?PROFILE
if c
call StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
?UTPE &macro
??error <Unterminated Procedure Definition: "&n">
&endm
endm
?pg1 macro n,c,a,o,w,f,d,r
.xcref
cEnd &macro g
.xcref
?BA=0
ifidn <g>,<nogen>
if o+a+r
%out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mPop a
if f
db 0C3h
else
if w
ife ?NX
if (?TF eq 0) OR (???+?RP)
lea sp,-2[bp]
endif
pop ds
pop bp
ife ?DOS5
dec bp
endif
else
if (?TF eq 0) OR (???+?RP)
mov sp,bp
endif
if ???+?PO+?RP
pop bp
endif
endif
else
if ?FF+???+?PO+?RP
if (?TF eq 0) OR (???+?RP)
mov sp,bp
endif
pop bp
endif
endif
ife ?PLM
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addSeg grp,n
else
ln&OFFSET equ OFFSET n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addSeg macro grp,seg
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
grp&_add &macro s
grp&_in <seg>,s
&endm
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defGrp macro grp,ln
addSeg grp
ifnb <ln>
?cs3 <ln>,<grp>
ln&OFFSET equ OFFSET grp:
ln&BASE equ grp
endif
endm
?cs1 macro ln,n
ln&_sBegin &macro
?MF &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
sEnd &macro
n ends
purge ?MF
&endm
endm
?cs3 macro ln,n
ln&_assumes &macro s
assume s:&n
&endm
endm
sBegin macro ln
ln&_sBegin
endm
ife ?DF
createSeg _TEXT,code,word,public,CODE
ife ?NODATA1
createSeg _DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA
endif
if ?CHKSTK1
ifndef ?CHKSTKPROC
externP <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *ERRNZ* x1 = x2
endm
errn$ macro l,x
errnz <OFFSET $ - OFFSET l x>
ENDM
ifdef ?PROFILE
externFP <StartNMeas, StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\parse.h ===
/* parse.h - support tops-20 comnd jsys on MSDOS */

#include <setjmp.h>

/* flags in pair.flags. Not examined by tbLook				     */
#define PINVIS	0x4000			/* invisible in HELP, but recognized */
#define PABBREV 0x2000			/* abbreviation. Value is pointer    */

/* parse support */
extern struct tbPairType *valParse;
extern jmp_buf ParseAC;
extern jmp_buf PromptAC;
extern char bufField[MAXLINELEN];

#define SETPROMPT(p,b) setjmp(PromptAC);initParse(b,p);setjmp(ParseAC)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\fcb.h ===
/* fcb.h - structure of a 1.0 fcb */

struct EFCBType {
    char	eflg;			/* 00  must be 0xFF for extended FCB */
    char	pad[5]; 		/* 01  padding			     */
    char	attr;			/* 06  enabling attribute	     */
    char	drv;			/* 07  drive code		     */
    char	nam[8]; 		/* 08  file name		     */
    char	ext[3]; 		/* 10  file name extension	     */
    int 	cb;			/* 13  current block number	     */
    int 	lrs;			/* 15  logical record size	     */
    long	lfs;			/* 17  logical file size	     */
    unsigned	dat;			/* 1B  create/change date	     */
    unsigned	tim;			/* 1D  create/change time	     */
    char	sys[8]; 		/* 1F  reserved 		     */
    unsigned char cr;			/* 27  current record number	     */
    long	rec;			/* 28  random record number	     */
};

struct FCB {
    char	drv;			/* 00  drive code		     */
    char	nam[8]; 		/* 01  file name		     */
    char	ext[3]; 		/* 09  file name extension	     */
    int 	cb;			/* 0C  current block number	     */
    int 	lrs;			/* 0E  logical record size	     */
    long	lfs;			/* 10  logical file size	     */
    unsigned	dat;			/* 14  create/change date	     */
    unsigned	tim;			/* 16  create/change time	     */
    char	sys[8]; 		/* 18  reserved 		     */
    unsigned char cr;			/* 20  current record number	     */
    long	rec;			/* 21  random record number	     */
};

#define FCBSIZ sizeof(struct FCB)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\doscalls.inc ===
EXTRN DOSREAD:FAR
EXTRN DOSCREATETHREAD:FAR
EXTRN DOSSEMREQUEST:FAR
EXTRN DOSSEMCLEAR:FAR
EXTRN DOSSEMSETWAIT:FAR
EXTRN DOSSEMWAIT:FAR
EXTRN DOSSEMSET:FAR
EXTRN DOSBEEP:FAR
EXTRN DOSEXIT:FAR
EXTRN DOSSLEEP:FAR
EXTRN DOSALLOCSEG:FAR
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\dirent.h ===
struct dirent
	{
	char d_name[_MAX_PATH];
	};

typedef void DIR;

DIR *opendir(char *);
int closedir(DIR *);
struct dirent *readdir(DIR *);
void rewinddir(DIR *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\mapstr.h ===
#ifndef MAPSTR_H
#define MAPSTR_H (1)

// mapstr.h - definitions for text mapping

// basic lookup structure
typedef char *MapAbbr;
typedef int MapValu;
typedef char* (*MapTest) ( char*, char* );

typedef struct {
    MapAbbr szLabel;
    MapValu value;			// use your favorite enum here
    } MapItemRec, *MapItemPtr;

// public routines
extern MapItemPtr mapAbbrStr (
    MapAbbr szArg,
    MapItemPtr pTable,
    MapTest pTest );

#endif // MAPSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\ftw.h ===
#define FTW_NS	0
#define FTW_DNR	1
#define FTW_D	2
#define FTW_F	3

int ftw(char *, int (*)(char *, struct stat *, int), int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\exe.h ===
/* exe.h - structure of an exe file header */
/* Include some new .exe file info from \link\newexe.h */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words (OLD) */
#define ERES1WDS        0x0004          /* No. of reserved words in e_res */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      8               /* Eight bytes reserved (now) */
#define NECRC           8               /* Offset into new header of NE_CRC */
#define NEDEFSTUBMSG	0x4E	    /* Offset into file of default stub msg */

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_IPHI(x)      (x).ne_iphi
#define NE_SPHI(x)      (x).ne_sphi
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     xxxxx                            Unused
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               x                      Unused
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEIERR          0x2000          /* Errors in image */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */


struct exeType {
    char	signature[2];		/* zibo's signature                  */
    unsigned	cbPage; 		/* bytes in image mod 512	     */
    unsigned	cPage;			/* size of file in 512 byte pages    */
    unsigned	cReloc; 		/* number of relocation items	     */
    unsigned	cParDir;		/* number of paragraphs before image */
    unsigned	cMinAlloc;		/* minimum number of paragrapsh      */
    unsigned	cMaxAlloc;		/* maximum number of paragrapsh      */
    unsigned	sStack; 		/* segment of stack in image	     */
    unsigned	oStack; 		/* offset of stack in image	     */
    unsigned	chksum; 		/* checksum of file		     */
    unsigned	oEntry; 		/* offset of entry point	     */
    unsigned	sEntry; 		/* segment of entry point	     */
    unsigned	oReloc; 		/* offset in file of reloc table     */
    unsigned	iOverlay;		/* overlay number		     */
};

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERES1WDS];/* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_iphi;        /* High word of initial IP */
    unsigned short      ne_sphi;        /* High word of initial SP */
    char                ne_res[NERESBYTES];
                                        /* Pad structure to 64 bytes */
  };


enum exeKind {
    IOERROR,				/* Error, file cannot be accessed    */
    NOTANEXE,				/* Error, file is not an .EXE file   */
    OLDEXE,				/* "oldstyle" DOS 3.XX .exe	     */
    NEWEXE,				/* "new" .exe, OS is unknown	     */
    WINDOWS,				/* Windows executable		     */
    DOS4,				/* DOS 4.XX .EXE		     */
    DOS286,				/* 286DOS .EXE			     */
    EXEBOUND,				/* 286DOS .EXE, bound		     */
    DYNALINK				/* Dynamlink link module	     */
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\subcalls.inc ===
KeyData STRUC
    char_code	DB  ?
    scan_code	DB  ?
    status	DB  ?
    nls_shift	DB  ?
    shift_state DW  ?
    time	DB  4 DUP(?)
KeyData ENDS

ModeData STRUC
    MDlength	DW  12
    VAtype	DB  ?
    color	DB  ?
    col 	DW  ?
    row 	DW  ?
    hres	DW  ?
    vres	DW  ?
ModeData ENDS

ConfigData STRUC
    CDlength	    DW	10
    adapter_type    DW	?
    display_type    DW	?
    memory_size     DD	?
ConfigData ENDS

PhysBufData STRUC
    buf_start	    DD	?
    buf_length	    DD	?
    selectors	    DW	?, ?
PhysBufData ENDS

CursorData STRUC
    cur_start	    DW	?
    cur_end	    DW	?
    cur_width	    DW	?
    cur_attribute   DW	?
CursorData ENDS

EXTRN  KBDPEEK:FAR
EXTRN  KBDCHARIN:FAR
EXTRN  KBDOPEN:FAR
EXTRN  KBDCLOSE:FAR
EXTRN  KBDFREEFOCUS:FAR
EXTRN  KBDGETFOCUS:FAR
EXTRN  VIOGETMODE:FAR
EXTRN  VIOGETCONFIG:FAR
EXTRN  VIOSETMODE:FAR
EXTRN  VIOWRTCHARSTRATT:FAR
EXTRN  VIOWRTNCELL:FAR
EXTRN  VIOSETCURPOS:FAR
EXTRN  VIOSCROLLUP:FAR
EXTRN  VIOSCROLLDN:FAR
EXTRN  VIOGETBUF:FAR
EXTRN  VIOSETCURTYPE:FAR
EXTRN  VIOSHOWBUF:FAR
EXTRN  VIOWRTCELLSTR:FAR
EXTRN  VIOGETPHYSBUF:FAR
EXTRN  VIOSCRLOCK:FAR
EXTRN  VIOSCRUNLOCK:FAR
EXTRN  VIOGETCURTYPE:FAR
EXTRN  VIOGETCURPOS:FAR
EXTRN  VIOREADCELLSTR:FAR
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\strpfx.h ===
#ifndef STRPREFIX_H
#define STRPREFIX_H (1)

// strpfx.h - definitions for string prefix routines

extern char* strprefix ( char* szTest, char* szFull );
extern char* striprefix ( char* szTest, char* szFull );

#endif // STRPREFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\ttypes.h ===
/* ttypes.h - type definitions for tools library */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#undef max
#undef min

/* assembly routines */
#if defined(DOS)
flagType int25 (char, char far *, unsigned int, unsigned int);
flagType int26 (char, char far *, unsigned int, unsigned int);
#endif
// flagType kbhit ();  // already defined by C6
int getch (void);
void cursor (int, int);
#if defined(DOS) || defined(OS2)
void Move (void far *, void far *, unsigned int);
void Fill (char far *, char, unsigned int);
#elif defined(NT)
#define Move(src, dest, count)	memmove(dest, src, count)
#define Fill(dest, val, count)	memset(dest, val, count)
#endif
char *strbscan (char const *, char const *);
char *strbskip (char const *, char const *);
char *strncrlfend (char *, int);
flagType strpre (char *, char *);
long getlpos (void);
void getlinit (char far *, int, int);
int getl (char *, int);
int   max (int, int);
int   min (int, int);
#if defined(DOS) || defined(OS2)
long lmax (long, long);
long lmin (long, long);
#elif defined(NT)
#define lmax(x, y)  max(x, y)
#define lmin(x, y)  min(x, y)
#endif


/* c routines */
#define lower(x)    (strlwr(x))
#define upper(x)    (strupr(x))
#define MakeStr(x)  (strdup(x))
#define strend(x)   ((x)+strlen(x))

#if defined(DOS)
void ZSleep(long);
#elif defined(OS2)
#define ZSleep(x)   DosSleep(x)
#elif defined(NT)
#define ZSleep(x)   Sleep(x)
#endif
flagType delnode (char *);
char  *error(void);
long fexpunge(char *, FILE *);
char  *fcopy(char *, char *);
int fgetl(char	*, int, FILE  *);
int fputl(char	*, int, FILE  *);
int ffirst(char *, int, struct findType *);
int fnext(struct findType * );
void findclose(struct findType * );
char forsemi(char  *,flagType (*)(char *, va_list), ... );
long freespac(int);
long sizeround(long, int);
#if defined(OS2)
struct spawnInfo * rspawnl(char  *,char  *,char  *, ... );
struct spawnInfo * rspawnv(char  *,char  *,char  *,char  *[0]);
#elif defined(DOS)
int rspawnl(char  *,char  *,char  *, ... );
int rspawnv(char  *,char  *,char  *,char  *[0]);
#endif
#if defined(OS2) || defined(NT)
char * fastcopy (HANDLE hfSrcParm, HANDLE hfDstParm);
#endif
void mapenv (char *src, char *dst);
char  *ismark(char  *);
FILE  *swopen(char  *,char  *);
int swclose(FILE  *);
int swread(char  *,int ,FILE  *);
flagType swgoto (FILE *, char *);
char *swmatch (FILE *, char *);
int swparse(char *, char **, char **, char **, char **);
char  *swfind(char  *,FILE *,char  *);
char *getenvini(char  *,char  *);
char fPathChr(char );
char fSwitChr(char );
flagType findpath(char	*,char	*, flagType );
FILE  *pathopen(char  *,char  *,char  *);
int forfile(char *, int, void (*)(char *, struct findType *, va_list), ... );
int EnFile (char *, int, void (*)(char *, struct findType *, va_list), ... );
int rootpath(char  *,char  *);
int sti(char  *,int );
int ntoi(char  *,int );
int strcmps(const char  *,const char  *);
int strcmpis(const char  *,const char  *);
char *strrchrs(char *, char *);
int upd(char  *,char  *,char  *);
int drive(char	*,char	*);
int extention(char  *,char  *);
int filename(char  *,char  *);
int filenamx(char  *,char  *);
int fileext(char *, char *);
int path(char  *,char  *);
int curdir(char *, char );
int getattr(char *);
int MkPath(char *);
int fdelete(char  *);
char *fmove(char  *, char *);
char *fappend(char  *, HANDLE);
long ctime2l(char *);
struct tm *ctime2tm(char *);
long date2l(int, int, int, int, int, int);
VECTOR *VectorAlloc(int);
flagType fAppendVector(VECTOR **, void *);
int pipe( int [] );
int pgetl( char *, int, int );
enum exeKind exeType ( char * );
char *strExeType( enum exeKind );
flagType fMatch (char *, char *);

extern char * (*tools_alloc) (unsigned int);

#if defined(DOS)
int Connect (char *path, char *con, char *sub);
flagType fDisconnect (int drive);
#endif
char *pathcat (char *pDst, char *pSrc);
int setattr (char *pname, int attr);

/*  swchng.c */
flagType swchng (char *strSwFile, char *strTag, char *strLHS, char *strRHS, flagType fNoUndel);
flagType swchnglhs (char *strSwFile, char *strTag, char *strLHS, char *strRHS);
flagType swchange (char *strSwFile, char *strTag, char *strLHS, char *strRHS,
    flagType fNoUndel, flagType *fError);
flagType swchanglhs (char *strSwFile, char *strTag, char *strLHS, char *strRHS,
    flagType *fError);

/*  heapdump.c */
int	heapdump ( FILE *fp, int iFormat );

/*  heapchk.c */
int	heapinfo (void);


/*  pname.c */
char *pname (char *);
unsigned short IsMixedCaseSupported (char *);

#if defined(DOS)
/* msexec.c */
int do_exec (char *xfn, char *pars, int spwn, unsigned needed, char **envp);
#endif


#if defined(NT)
/* ztoolasm.c */
HANDLE	z_handle(int crtfh);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\times.h ===
/* times.h - format of time stamp */

#define STAMP	    "%2d:%02d:%02d %2d %3s %4d"
#define STAMPLEN    20
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\args.c ===
// args.c -- Command line argument support
//

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "strpfx.h"

#include "args.h"

////////////////////
// EXPORTED STATE //
////////////////////

static
int isName (
    char *szArg,
    char **pszText
    );

ArgTestFunc argIsName = isName;

////////////////////
// INTERNAL STATE //
////////////////////

static char** pszArgCurr;

static MapItemPtr pArgNames;

static ArgOrder piArgSeqn;
static int cArgSeqn;
static int mArgSeqn;

static char* szArgMrk;
static char* szArgSep;

/////////////////////////////////
// Support for "bound" options //
/////////////////////////////////

static char* szArgValu;

////////////////////////////////////////
// argRead                            //
// - Map the current option to a code //
////////////////////////////////////////

static
int argRead (
    int bad,
    ArgName *pszText,
    char **pszValu,
    int bump
    )
{
    // assume we fail, for easy exit
    *pszText = NULL;
    *pszValu = NULL;

    // any thing to look at?
    if ( pszArgCurr == NULL ) return bad;
    if ( *pszArgCurr == NULL ) return bad;

    // explicit argument
    if ( (*argIsName) ( *pszArgCurr, pszText )) {
        MapItemPtr found;

        found = argMapSplit ( *pszText, szArgSep, pArgNames, pszValu );

        pszArgCurr += bump;

        return ( found ? found->value : bad );
	}

    // positional values
    if ( cArgSeqn < mArgSeqn ) {
        int found;

        found = piArgSeqn [ cArgSeqn ];

        cArgSeqn += bump;
        pszArgCurr += bump;
        *pszValu = *pszText;
	*pszText = NULL;

        return found;
	}

    // no apparent arguments
    return bad;
    }

/////////////////////////////////////////////
// isName                                  //
// - StdName wrapper with local test chars //
/////////////////////////////////////////////

static
int isName (
    char *szArg,
    char **pszText
    )
{
    return argStdNameTest ( szArg, szArgMrk, pszText );
    }

/////////////////////
// PUBLIC ROUTINES //
/////////////////////

/////////////////////////////////////////////
// argStdNameTest                          //
// - Determine if current option is a name //
/////////////////////////////////////////////

int argStdNameTest (
    char *szArg,
    char *szMrk,
    char **pszText
    )
{
    // not an arg if it doesn't starts with a mark character
    if ( strchr ( szMrk, *szArg ) == NULL ) {
	*pszText = szArg;
	return 0;
	}

    // not an arg if the mark character is repeated
    if (( strlen ( szArg ) >= 2 ) && ( szArg[0] == szArg[1] )) {
	*pszText = szArg + 1;
	return 0;
	}

    // must be an argument
    *pszText = szArg + 1;
    return ~0;
    }

////////////////////////////////////////////////////////////
// argMapSplit                                            //
// - Determine if the current option has a bound argument //
////////////////////////////////////////////////////////////

MapItemPtr argMapSplit (
    char *szArg,
    char *szSplit,
    MapItemPtr pMapTable,
    char **pszValu
    )
{
    char *szFlag;
    MapItemPtr item;
    int cFlag;

    char *szBreak = strpbrk ( szArg, szSplit );

    // easy case:  no options with argument
    if ( szBreak == NULL ) {
        *pszValu = NULL;
        return mapAbbrStr ( szArg, pMapTable, striprefix );
	}

    // hard case:  option appended to argument
    // - build temp string for lookup
    cFlag = szBreak - szArg;

    szFlag = malloc ( cFlag + 1 );

    if ( szFlag == NULL ) {
        *pszValu = NULL;
	return NULL;
	}

    strncpy ( szFlag, szArg, cFlag );
    szFlag [ cFlag ] = '\0';

    // set up values for argOpts
    *pszValu = szBreak + 1;

    // map the string
    item = mapAbbrStr ( szFlag, pMapTable, striprefix );

    // cleanup and go
    free ( szFlag );
    return item;
    }

///////////////////////////////////////
// argOpen			     //
// - Establish the list of arguments //
///////////////////////////////////////

void
argOpen (
    char **argv
    )
{
    // establish internal state
    pszArgCurr = argv;
    szArgValu = NULL;
    }

/////////////////////////////////////
// argShut			   //
// - Release the list of arguments //
/////////////////////////////////////

char **
argShut ( void )
{
    char **argv = pszArgCurr;

    // clear the internal state;
    pszArgCurr = NULL;
    szArgValu = NULL;

    // return the current argument
    return argv;
    }

////////////////////////////////////////
// argSeqn			      //
// - (Re)Set the positional arguments //
////////////////////////////////////////

void
argSeqn (
    ArgOrder piSeqn,
    int mSeqn
    )
{
    piArgSeqn = piSeqn;
    mArgSeqn = mSeqn;
    cArgSeqn = 0;
    }

//////////////////////////////////
// argConfig			//
// -  Create the internal state //
//////////////////////////////////

void
argConfig (
    MapItemPtr pNames,
    ArgOrder piSeqn,
    int mSeqn,
    char* szMrk,
    char* szSep
    )
{
    // establish internal state
    pArgNames = pNames;

    szArgMrk = ( szMrk == NULL ) ? "/-" : szMrk ;
    szArgSep = ( szSep == NULL ) ? ":=" : szSep ;

    argSeqn ( piSeqn, mSeqn );
    }

////////////////////////////////////////
// argName			      //
// - Map the current option to a code //
////////////////////////////////////////

int
argName (
    int bad,
    ArgName *pszText
    )
{
    return argRead ( bad, pszText, &szArgValu, 1 );
    }

////////////////////////////////////////
// argPeek                            //
// - Map the current option to a code //
////////////////////////////////////////

int
argPeek (
    int bad,
    ArgName *pszText
    )
{
    char *szTemp;

    return argRead ( bad, pszText, &szTemp, 0 );
    }

////////////////////////////////////////////
// argValu				  //
// - Get the next argument value (if any) //
////////////////////////////////////////////

char *
argValu ( void )
{
    char *szValu;

    // check for bound/positional values
    if ( szArgValu != NULL ) {
	szValu = szArgValu;

	// could actually parse out comma separated options here

	// make sure we don't hand out the same value twice
	if ( *szArgValu == '\0' ) return NULL;
	szArgValu += strlen ( szArgValu );

	// return bound value
	return szValu;
	}

    // no "bound" options
    if ( pszArgCurr == NULL ) return NULL;
    if ( *pszArgCurr == NULL ) return NULL;
    if ( (*argIsName) ( *pszArgCurr, &szValu )) return NULL;

    // Unbound value found - advance over it.
    // Also, since an unbound value confuses the
    //   position, shut down positional argument support
    pszArgCurr++;
    cArgSeqn = mArgSeqn;

    // done
    return szValu;
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\rm.h ===
/* rm.h - include file for rm and undel facility
 *
 * Revision History:
 *  ??-???-???? ?? Created
 *  27-Dec-1989 SB Added new index file header stuff
 *
 * Index file format:
 *  The indexed file is composed of records of length RM_RECLEN.
 *	The old index file was composed of entries each the size of a record
 *  and composed of filename padded by NULs. The hash function mapped the
 *  Nth record (i.e. Nth INDEXED entry) to 'deleted.xxx', where, 'xxx' is (N+1)
 *  padded by leading zeroes.
 *	The new index file has an header record, rm_header, followed by entries
 *  of one or more records padded by NULs. Longfilenames occupy multiple
 *  records. The hash function maps the entry starting at Nth record to
 *  'deleted.xxx' where xxx is (N+1) padded by leading zeroes. This works out
 *  to be basically the same as that for the old format. The differences are :-
 *	-No entry is mapped to 'deleted.000'
 *	-Entries for filenames longer than (RM_RECLEN-1) bytes cause gaps in
 *	    mapping.
 *
 * Notes:
 *  RM/EXP/UNDEL work as follows:-
 *	    'RM foo' saves a copy of 'foo' and places it in an hidden
 *	sub-directory of RM_DIR (of foo) as file 'deleted.xxx', where, xxx is
 *	determined from the index file RM_IDX in RM_DIR. An entry is made in
 *	the index file for this.
 *	    'UNDEL foo' reads the index file in RM_DIR and determines xxx for
 *	foo and renames 'deleted.xxx' as foo. The entry for foo in the index
 *	file is filled with NULLs.
 *	    'EXP' picks up the index file from RM_DIR and deletes 'deleted.xxx'
 *	for each entry in the index file. It then deletes the index file and
 *	RM_DIR.
 *
 *  The new index file format can coexist with the old one because :-
 *	The header has a starting NULL which causes it to be ignored by
 *	    the old utilities,
 *	When the old utilities attempt to read in a long filename entry they
 *	fail without harm as the hashed 'deleted.xx' does not exist.
 */

#define RM_DIR	    "deleted."
#define RM_IDX	    "index."
#define RM_RECLEN   16

/* The header record in the index file has
 *	'\0IXn.nn\0' padded to RM_RECLEN bytes
 */

#define RM_SIG	    (char)0x00
#define RM_MAGIC    "IX"	  /* IX - IndeXed file */
#define RM_VER	    "1.01"
#define RM_NULL     '\0'

/* Forms header for Index file using RM_MAGIC, RM_VER and RM_NULL */

extern char rm_header[RM_RECLEN];

/* Function prototypes */

    // Converts Index file to the new format
int convertIdxFile (int fhidx, char *dir);

    // Determines if the record is a new index file header
flagType fIdxHdr (char *rec);

    // Reads an Index file record
int readIdxRec (int fhIdx, char *rec);

    // Reads index file records and returns INDEXED entry
int readNewIdxRec (int fhIdx, char *szRec, unsigned int cbMax);

    // Writes an new index file header
int writeIdxHdr (int fhIdx);

    // Writes an index file record
int writeIdxRec (int fhIdx, char *rec);

    // Indexes an entry into the Index file
int writeNewIdxRec (int fhIdx, char *szRec);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\blank.asm ===
;
; Blank a region of the screen
;
;   09-Dec-1986 bw  Added DOS 5 support
;   26-Jan-1987 bw  Fix 286DOS support
;   30-Oct-1987 bw  Changed 'DOS5' to 'OS2'

.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\subcalls.inc
if1
%out  ! OS2 module
endif
endif
.list

sBegin code

assumes cs,code

;
;
; blank (x1, y1, x2, y2, a) blanks a region
;
;
ifdef  OS2
cProc	blank,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmB	a
localW	cell
else
cProc	blank,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2
parmB	y2
parmB	a
endif
cBegin

ifdef  OS2
	mov	ah, a
	mov	al, 20H
	mov	cell, ax
	push	y1
	push	x1
	push	y2
	push	x2
	mov	ax, y2
	sub	ax, y1
	inc	ax
	push	ax
	push	ss
	lea	ax, cell
	push	ax
	xor	ax, ax
	push	ax	    ; VIO handle
	call	VIOSCROLLUP
else
        mov     ah,6
	mov	cl,x1
	mov	ch,y1
	mov	dl,x2
	mov	dh,y2
	mov	bh,a
	mov	al,0	    ; use special case al=0 clear entire window
        push    bp
	int	10h
        pop     bp
endif

cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\h\tools.h ===
/*
 *  tools.h - Header file for accessing TOOLS.LIB routines
 *  includes stdio.h and ctype.h
 *  under NT, includes windows.h
 *
 */

#if !defined(NT) && !defined(OS2) && !defined(DOS)
#error must define operating system (one of NT, OS2, DOS)
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdarg.h>
#if defined(NT)
#include <windows.h>
#endif

#if !defined (FALSE)
#define FALSE	0
#endif

#if !defined (TRUE)
#define TRUE	(!FALSE)
#endif

#if defined(DOS) || defined(OS2)
#if !defined(FAR)
#define FAR _far
#endif
#elif defined(NT)
#if !defined(FAR)
#define FAR
#endif
#endif


#if MSDOS
#define     PSEPSTR "\\"
#define     PSEPCHR '\\'
#else
#define     PSEPSTR "/"
#define     PSEPCHR '/'
#endif

#if !defined( _FLAGTYPE_DEFINED_ )
#define _FLAGTYPE_DEFINED_ TRUE
typedef char flagType;
#endif
typedef long ptrType;

#if defined(DOS) || defined(OS2)
typedef unsigned short HANDLE;
#endif

#if defined(DOS)
typedef char CHAR, *PCHAR;
#endif

#define SETFLAG(l,f)	((l) |= (f))
#define TESTFLAG(v,f)	(((v)&(f))!=0)
#define RSETFLAG(l,f)	((l) &= ~(f))

#define SHIFT(c,v)	{c--; v++;}

#if !defined(CW)
#if !defined(MAKEWORD)
#define MAKEWORD(l, h)	 ((LOW((h))<<8)|LOW((l)))
#endif
#if !defined(MAKELONG)
#define MAKELONG(l, h)	((DLOW(h)<<16|DLOW(l)))
#endif
#endif

#define LOW(w)		((int)(w)&0xFF)
#define HIGH(w) 	LOW((int)(w)>>8)
#define DLOW(l) 	((long)(l)&0xFFFF)
#define DHIGH(l)	DLOW((long)(l)>>16)
#define POINTER(seg,off) ((((long)(seg))<<4)+ (long)(off))
#define MAKEDWORD(h,l)	((DLOW(h)<<16|DLOW(l)))

#define FNADDR(f)	(f)

#define SELECT		if(FALSE){
#define CASE(x) 	}else if((x)){
#define OTHERWISE	}else{
#define ENDSELECT	}

#define MAXARG	    128 		/* obsolete and begin deleted */
#define MAXLINELEN  1024		/* longest line of input */
#define MAXPATHLEN  260 		/* longest filename acceptable */


#if defined(OS2) || defined(NT)

#define PIPE_READ   0
#define PIPE_WRITE  1


/*
 *  This is the value returned by rspawnl.  The PID field will always hold
 *  the process ID of the background process.  The in* fields will hold the
 *  handles of the pipe attached to the new processes stdin, and the out*
 *  fields correspond to stdout.  If input/output from/to a pipe has not been
 *  requested, the fields will be -1.  The fields are ordered read-write
 *  to allow a call pipe(&val.inReadHndl) or pipe(&val.outreadHndl).
*/
struct spawnInfo {
    unsigned PID;
    int inReadHndl;
    int inWriteHndl;
    int outReadHndl;
    int outWriteHndl;
};


/* buffer description for findfirst and findnext
   When DOS 3 and DOS 5 version have the same field name, the field contains
   the same information
   DOS 5 version includes the directory handle
*/
#if defined(OS2)
struct findType {
    unsigned	     type ;		/* type of object being searched    */
    unsigned   dir_handle ;		/* Dir search handle for FindNext   */
    unsigned  create_date ;		/* File date of creation	    */
    unsigned  create_time ;		/* File time of creation	    */
    unsigned  access_date ;		/* File date of last access	    */
    unsigned  access_time ;		/* File time of last access	    */
    unsigned	     date ;		/* File date of last write	    */
    unsigned	     time ;		/* File time of last write	    */
    long	   length ;		/* File end of data		    */
    long	    alloc ;		/* File allocation		    */
    unsigned	     attr ;		/* File attribute		    */
    unsigned char nam_len ;		/* Length of ASCIIZ name string     */
    char name[MAXPATHLEN] ;		/* ASCIIZ name string		    */
};
#define FT_FOUNDNAME(findType)		findType.name
#define FT_FOUNDATTR(findType)		findType.attr
#define PFT_FOUNDNAME(pfindType)	pfindType->name
#define PFT_FOUNDATTR(pfindType)	pfindType->attr
#elif defined(NT)
struct findType {
    unsigned		type;		/* type of object being searched    */
    HANDLE		dir_handle;	/* Dir search handle for FindNext   */
    long		attr;		/* File attributes		    */
    WIN32_FIND_DATA	fbuf;		/* Aligned structure for Cruiser and NT */
};
#define FT_FOUNDNAME(findType)		findType.fbuf.cFileName
#define FT_FOUNDATTR(findType)		findType.fbuf.dwFileAttributes
#define PFT_FOUNDNAME(pfindType)	pfindType->fbuf.cFileName
#define PFT_FOUNDATTR(pfindType)	pfindType->fbuf.dwFileAttributes
#endif

#define FT_DONE     0xFF		/* closed handle */
#define FT_FILE     0x00		/* enumerating files */
#define FT_SERV     0x01		/* enumerating servers */
#define FT_SHAR     0x02		/* enumerating shares */
#define FT_MASK     0xFF		/* mask for type */

#define FT_MIX	    0x8000		/* mixed case supported flag */

struct DOS3findType {
    char reserved[21];			/* reserved for start up	     */
    char attr;				/* attribute found		     */
    unsigned time;			/* time of last modify		     */
    unsigned date;			/* date of last modify		     */
    long length;			/* file size			     */
    char name[13];			/* asciz file name		     */
};

#else

struct findType {
    char reserved[21];			/* reserved for start up	     */
    char attr;				/* attribute found		     */
    unsigned time;			/* time of last modify		     */
    unsigned date;			/* date of last modify		     */
    long length;			/* file size			     */
    char name[13];			/* asciz file name		     */
};
#define FT_FOUNDNAME(findType)		findType.name
#define FT_FOUNDATTR(findType)		findType.attr
#define PFT_FOUNDNAME(pfindType)	pfindType->name
#define PFT_FOUNDATTR(pfindType)	pfindType->attr

#endif

typedef struct findType FIND;
typedef FIND near * NPFIND;


/* attributes */
#if defined(OS2) || defined(DOS)
#define A_NO	0			//normal or none
#define A_RO	1			/* read only			     */
#define A_H	2			/* hidden			     */
#define A_S	4			/* system			     */
#define A_V	8			/* volume id			     */
#define A_D	16			/* directory			     */
#define A_A	32			/* archive			     */
#define FILE_ATTRIBUTE_NORMAL		A_NO
#define FILE_ATTRIBUTE_READONLY 	A_RO
#define FILE_ATTRIBUTE_HIDDEN		A_H
#define FILE_ATTRIBUTE_SYSTEM		A_S
#define FILE_ATTRIBUTE_VOLUME_LABEL	A_V
#define FILE_ATTRIBUTE_DIRECTORY	A_D
#define FILE_ATTRIBUTE_ARCHIVE		A_A
#elif defined(NT)
#define FILE_ATTRIBUTE_VOLUME_LABEL	0x00   //BUGBUG NT Temp redef for compile
#define A_NO	FILE_ATTRIBUTE_NORMAL
#define A_RO	FILE_ATTRIBUTE_READONLY
#define A_H	FILE_ATTRIBUTE_HIDDEN
#define A_S	FILE_ATTRIBUTE_SYSTEM
#define A_V	FILE_ATTRIBUTE_VOLUME_LABEL
#define A_D	FILE_ATTRIBUTE_DIRECTORY
#define A_A	FILE_ATTRIBUTE_ARCHIVE
#endif

#define A_MOD	(A_NO|A_RO+A_H+A_S+A_A)	/* changeable attributes	     */
#define A_ALL	(A_NO|A_RO|A_H|A_S|A_V|A_D|A_A)

#define HASATTR(a,v)	TESTFLAG(a,v)	/* true if a has attribute v	     */

extern char XLTab[], XUTab[];

struct vectorType {
    int vmax;				/* max the vector can hold	     */
    int count;				/* count of elements in vector	     */
    void *elem[1];			/* vector element(s)		     */
};

typedef struct vectorType VECTOR;

#include "parse.h"
#include "exe.h"
#include "fcb.h"
#include "dir.h"
#include "times.h"
#include "ttypes.h"

/* return flags for upd */
#define U_DRIVE 0x8
#define U_PATH	0x4
#define U_NAME	0x2
#define U_EXT	0x1

/*  Connect definitions */

#define REALDRIVE	0x8000
#define ISTMPDRIVE(x)	(((x)&REALDRIVE)==0)
#define TOKTODRV(x)	((x)&~REALDRIVE)

/*  Heap Checking return codes */

#define HEAPOK           0
#define HEAPBADBEGIN    -1
#define HEAPBADNODE     -2

/* internal module prototypes here, not for api */
int frenameNO(char *, char *);

#if defined(DOS)
/* msspawn.c: return codes */

#define RC_PREPERR   0x0100
#define RC_NOFILE    0x0200
#define RC_EXECERR   0x0300
#define RC_ENVERR    0x0400
#define RC_SWAPERR   0x0500

/* msspawn.c: Swap method and option flags */

#define USE_EMS      0x01
#define USE_XMS      0x02
#define USE_FILE     0x04
#define EMS_FIRST    0x00
#define XMS_FIRST    0x10
#define HIDE_FILE    0x40
#define NO_PREALLOC  0x100
#define CHECK_NET    0x200

#define USE_ALL      (USE_EMS | USE_XMS | USE_FILE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\crterr.asm ===
;	Static Name Aliases
;
	TITLE   crterr.asm
	NAME    crterr

	.8087
CRTERR_TEXT	SEGMENT  WORD PUBLIC 'CODE'
CRTERR_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME  CS: CRTERR_TEXT, DS: DGROUP, SS: DGROUP
EXTRN	__acrtused:ABS
EXTRN	__dosret:FAR
CRTERR_TEXT      SEGMENT
	ASSUME	CS: CRTERR_TEXT

;	Map an OS/2 error to an ANSI errno value
;	Use the undocumented OS/2 C runtime function __dosret
;	to perform the mapping.  __dosret sets the globals
;	_errno and __doserrno.

	PUBLIC	_DosErrToErrno
_DosErrToErrno	PROC FAR
	push	bp
	mov	bp,sp
	mov	ax,WORD PTR [bp+6]
	jmp	FAR PTR __dosret
_DosErrToErrno	ENDP
CRTERR_TEXT	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\cursor.asm ===
;
; Curor locationrt for openlist
;
;   09-Dec-1986 bw  Added DOS 5 support
;   30-Oct-1987 bw  Changed 'DOS5' to 'OS2'


.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\subcalls.inc
if1
%out  ! OS2 module
endif
endif
.list

sBegin code

assumes cs,code

; cursor (x, y) sets the current cursor
;
cProc	cursor,<PUBLIC>
ifdef OS2
parmW	x
parmW	y
else
parmB	x
parmB	y
endif
cBegin

ifdef  OS2
	push	y
	push	x
	xor	ax, ax
	push	ax	    ; VIO handle
	call	VIOSETCURPOS
else
	mov	ah,2
	mov	dh,y
	mov	dl,x
	xor	bh,bh
        push    bp
	int	10h
        pop     bp
endif

cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\delnode.c ===
/* delnode - removes a node and its descendants */

#include "..\h\tools.h"
#include <string.h>
#include <direct.h>

static void fDoDel (
    char		*name,
    struct findType	*pBuf,
    va_list		ap
    )
{
    char *p;

    /* if it is a file, attempt to delete it */
    if (!TESTFLAG(PFT_FOUNDATTR(pBuf), A_D)) {
	/* if file is read-only, make it writable */
	if (TESTFLAG(PFT_FOUNDATTR(pBuf), A_RO))
	    if (setattr (name, PFT_FOUNDATTR(pBuf) & ~A_RO))
		return;
	unlink (name);
	}
    else if (strcmp (PFT_FOUNDNAME(pBuf), ".") &&
	     strcmp (PFT_FOUNDNAME(pBuf), "..")) {
	/* clear out subdir first */
	p = strend (name);
	pathcat (name, "*.*");
	forfile (name, A_H | A_S | A_D, fDoDel);
	*p = 0;
	rmdir (name);
	}
    return;
    ap;     //to access, as we don't use the vararg list
}

flagType delnode (name)
char *name;
{
    return (flagType) forfile (name, A_H | A_S | A_D, fDoDel);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\enfile.c ===
/*  enfile.c - perform generalized file enumeration
 *
 *  Modifications:
 *
 *	31-Jul-1986 mz	Use tools.h definitions
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 */

#include "..\h\tools.h"
#include <malloc.h>
#include <signal.h>
#include <string.h>
#include <direct.h>

static flagType iforfile (char *, char *, int, 
		void (*)(char *, struct findType *, va_list),
		va_list);

/*  EnFile - apply a procedure to all files that match the input pattern
 *
 *  pat 	pattern of file to enumerate
 *  attr	attribute to see
 *  rtn 	routine to call
 *  args	arguments to pass to routine
 */
int EnFile (pat, attr, rtn, ...)
char *pat;
int attr;
void (*rtn)(char *, struct findType *, va_list	);
{

    va_list	ap;	//unsigned args;
    flagType f = FALSE;

#if defined(DOS)
    int drive = -1;
    char *conn = (*tools_alloc) (MAXPATHLEN);
    char *rest = (*tools_alloc) (MAXPATHLEN);
    int (*sig)();


    if (conn != NULL && rest != NULL) {
	conn[0] = '\0';
	if (pat[0] && pat[1] == ':' && fPathChr (pat[2]) && fPathChr (pat[3]))
	    pat += 2;

	sig = signal (SIGINT, SIG_IGN);
	if ((drive = Connect (pat, conn, rest+2)) != -1) {
	    rest[0] = (char) (TOKTODRV(drive) +  'A');
	    rest[1] = ':';
	    pat = rest;
	    }
	va_start(ap, rtn);
	f = iforfile (conn, pat, attr, rtn, ap);
	va_end(ap);
	fDisconnect (drive);
	signal (SIGINT, sig);
	}

    if (conn != NULL)
	free (conn);
    if (rest != NULL)
	free (rest);

    return f;
#else
    va_start(ap, rtn);
    f = iforfile ("", pat, attr, rtn, ap);
    va_end(ap);
    return f;
#endif
}

static flagType iforfile (conn, pat, attr, rtn, ap)
char *conn;
char *pat;
int attr;
void (*rtn)(char *, struct findType *, va_list);
va_list ap;
{
    struct findType *fbuf = (struct findType *) (*tools_alloc) (sizeof (*fbuf));
    char *buf = (*tools_alloc) (MAXPATHLEN);
    flagType f = FALSE;
    va_list pass_ap;

    if (fbuf != NULL && buf != NULL && !ffirst (pat, attr, fbuf)) {
	if (conn[0] != 0)
	    strcpy (buf, conn);
	else
	    drive (pat, buf);
	path (pat, strend (buf));
	pat = strend (buf);

	do {
	    strcpy (pat, PFT_FOUNDNAME(fbuf));
	    /*	Assume the case correct form has been returned by ffirst/fnext
	     */
	    memcpy(pass_ap, ap, sizeof(va_list));
	    (*rtn) (buf, fbuf, pass_ap);
	    va_end(pass_ap);
	} while (!fnext (fbuf));
	f = TRUE;
	}

    if (buf != NULL)
	free (buf);
    if (fbuf != NULL) {
	findclose(fbuf);
	free ((char *) fbuf);
	}

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\connect.c ===
/*  connect.c - perform network connections/disconnections
 *
 *  Modifications:
 *
 *	31-Jul-1986 mz	Use tools.h definitions
 *	03-Mar-1987 bw	Stub DOS5 version
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 */

#include "..\h\tools.h"
#include <string.h>

#include <dos.h>

/*  Forward internal declarations
 */
static int FindFreeDrive (void);
static int MachineConnect (char *con);

/*  FindFreeDrive - find the lowest drive that is not in use
 *
 *  returns 0-based index of first drive not in use
 */
static int FindFreeDrive ()
{
    union REGS regs;

    for (regs.x.bx = 1; regs.x.bx <= 26; regs.x.bx++) {
	regs.x.ax = 0x4409;
	intdos (&regs, &regs);
	if (regs.x.cflag)
	    return regs.x.bx-1;
	}
    return -1;
}

/*  MachineConnect - attempt a connection to a particular drive
 *
 *  MachineConnect will attempt a drive connection to a connection without
 *  a password, reusing a drive if it exists.
 *
 *  con 	text of connection
 *
 *  returns	drive token if successful, -1 otherwise
 */
static int MachineConnect (char *con)
{
    char dev[MAXPATHLEN];
    char path[MAXPATHLEN];
    union REGS regs;
    struct SREGS sregs;
    int i;

    segread (&sregs);
    sregs.es = sregs.ds;

    /* try existing connections first */
    for (i = 0; ; i++) {
	regs.x.ax = 0x5F02;
	regs.x.bx = i;
	regs.x.si = (unsigned) dev;
	regs.x.di = (unsigned) path;

	intdosx (&regs, &regs, &sregs);
	if (regs.x.cflag)
	    break;
	if (!strcmpi (con, path))
	    return ((int) (dev[0] | 0x20) - (int) 'a') | REALDRIVE;
	}

    /* try creating a new drive */
    if ((i = FindFreeDrive ()) == -1)
	return -1;
    dev[0] = (char) (i + 'a');
    dev[1] = ':';
    dev[2] = 0;
    con[strlen(con)+1] = 0;

    regs.x.ax = 0x5F03;
    regs.x.bx = 0x0004;
    regs.x.cx = 0x4D5A;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    segread( &sregs);
    sregs.ds = FP_SEG(dev);
    regs.x.si = FP_OFF(dev);
	 sregs.es = FP_SEG(con);
	 regs.x.di = FP_OFF(con);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.si = (unsigned) dev;
    regs.x.di = (unsigned) con;
    intdos (&regs, &regs);
#endif

    if (regs.x.cflag)
	return -1;
    else
	return i;
}

/*  Connect - take an arbitrary pathname and connect to the appropriate
 *  server.
 *
 *  connect takes a name in the form \\mach\path and attempts to connect to
 *  the named machine.	Since DOS 3.x has problems with connections, we
 *  attach the connection to a drive.
 *
 *  path	network name of the form
 *		    \\machine\path  -or-
 *		    \\machine\shortname\path
 *  con 	buffer to place the successful connection
 *  sub 	buffer to place the remainder of the path
 *
 *  returns	-1 if connection was not successful, otherwise
 *		returns drive token
 */
int Connect (path, con, sub)
char *path;
char *con;
char *sub;
{
    int drive;
    char *p;

    /* make sure double backslash present */
    if (!fPathChr (path[0]) || !fPathChr (path[1]))
	return -1;

    /* find end of machine name */
    p = path+2;
    while (*p && !fPathChr (*p))
	p++;

    Move ((char far *) path, (char far *) con, p-path);
    con[p-path] = 0;
    strcpy (sub, p);
    if ((drive = MachineConnect (con)) != -1)
	return drive;

    /* try finding end of shortname */
    p++;
    while (*p && !fPathChr (*p))
	p++;

    Move ((char far *) path, (char far *) con, p-path);
    con[p-path] = 0;
    strcpy (sub, p);
    if ((drive = MachineConnect (con)) != -1)
	return drive;

    return -1;
}

/*  fDisconnect - remove a network connection
 *
 *  fDisconnect will delete a connection to a particular drive
 *
 *  drive	drive token of drive to be torched
 *
 *  returns	TRUE iff disconnection was successful
 */
flagType fDisconnect (drive)
int drive;
{
    char bufDrive[3];
    union REGS regs;

    if (ISTMPDRIVE(drive)) {
	bufDrive[0] = (char) (TOKTODRV(drive) + 'A');
	bufDrive[1] = ':';
	bufDrive[2] = 0;

	regs.x.ax = 0x5F04;
	regs.x.si = (unsigned) bufDrive;

	intdos (&regs, &regs);
	return (flagType) (regs.x.cflag == 0);
	}
    else
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\curdir.c ===
/* return text of current directory
 *
 *  Modifications:
 *
 *	29-Oct-1986 mz	Lower case output
 *	09-Dec-1986 bw	Added DOS 5 support.
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *	20-Nov-1987 bw	Set errno to 19 for invalid drive
 *	03-Mar-1989 bw	Set C RTL _doserrno in OS/2.
 *	05-Jul-1989 bw	use MAXPATHLEN
 *
 */
#if defined(NT)
#define INCL_DOSERRORS
#include <windows.h>
#elif defined(OS2)
#define INCL_DOSERRORS
#include <os2.h>
#elif defined(DOS)
#include <dos.h>
#endif

#include <stdlib.h>
#include <string.h>

#include "..\h\tools.h"

int curdir (
char *buf,
char drive
) {
#if defined(DOS)

    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    struct SREGS sregs;
#endif

    /* stick in drive */
    if (drive == 0) {
	regs.h.ah = 0x19;
	intdos (&regs, &regs);
	drive = (char) (regs.h.al + 1);
	}
    *buf++ = (char) ('a' + drive - 1);
    *buf++ = ':';
    if (fSwitChr ('/')) *buf++ = '\\' ; else *buf++ =  '/';
    // *buf++ = fSwitChr ('/') ? '\\' : '/';

    // Get current dir. intdosx(), segread() are used to
    // correctly load segment registers (ds) depending upon
    // the "model".

    regs.h.ah = 0x47;
    regs.h.dl = drive;
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86LM))
    segread( &sregs);
    sregs.ds = FP_SEG(buf);
    regs.x.si = FP_OFF(buf);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.si = (unsigned) buf;
    intdos (&regs, &regs);
#endif
    if (!regs.x.cflag)
	strlwr (buf);
    else
	errno = 19;
    return regs.x.cflag;

#elif defined(OS2)

    int  DirPathLen = MAXPATHLEN;
    long LogicalDriveMap;

    if (drive == 0)
    {
	DosQCurDisk( (PUSHORT)&drive , (PULONG)&LogicalDriveMap );
    }

    *buf++ = (char) ('a' + drive - 1);
    *buf++ = ':';
    if (fSwitChr ('/')) *buf++ = '\\' ; else *buf++ =  '/';
    // *buf++ = fSwitChr ('/') ? '\\' : '/';

    if (_doserrno = DosQCurDir( drive, buf, (PUSHORT)&DirPathLen ))
    {
	switch (_doserrno) {
	    case ERROR_INVALID_DRIVE:
		errno = 19;
		break;
	    case ERROR_BUFFER_OVERFLOW:
		errno = 33;
		break;
	    default:
		break;
	    }
	return 1;
    }
    pname (buf - 3);
    return 0;

#elif defined(NT)

    DWORD dwLength;

    //assert( !drive );
    drive;	//NT doesn't use the concept internally

    dwLength = GetCurrentDirectory( MAXPATHLEN, (LPSTR)buf );

    return( !dwLength );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\ctime2l.c ===
/* routines for converting from ASCII time to long int */
#include <stdio.h>
#include <time.h>

/*  Intended to be the "inverse" of the asctime function of the C library
 *
 *  ctime2l  - takes ascii string in the format returned by ctime
 *	       representing local time and returns a long that is the
 *	       elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *  ctime2tm - takes ascii string in the format returned by ctime and
 *	       fills a struct tm
 *  date2l   - takes a date representing local time and returns a long that
 *	       is the elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *
 *  Modifications:
 *
 *	08-Sep-1986 mz	Extend time formats accepted to include:
 *	    day mon dd hh:mm:ss yyyy
 *	    mm/dd/yy			(presume 00:00:00)
 *	    hh:mm:ss			(presume hh:mm:ss today)
 *	    hh:mm			(presume hh:mm:00 today)
 *	    +hh:mm:ss			(hh:mm:ss from now)
 *	    +hh:mm			(hh:mm from now)
 *	    +hh 			(hh from now)
 *	    yesterday			(at midnight)
 *	    tomorrow			(at midnight)
 *	    now
 */

#include <string.h>

static int dayinmon[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static char *strMon[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
    "Aug", "Sep", "Oct", "Nov", "Dec"};
static char *strDay[7] =  {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
static struct tm tb;

// extern long timezone;
// extern int daylight;
extern int _days[];

static time_t _dtoxtime(int, int, int, int, int, int);
static istr(char *, char **, int);
static yday(int, int, int);
static leapyear(int);
struct tm *ctime2tm(char *);
long date2l(int, int, int, int, int, int);

/****************************************************************************/
/* start of copy of code in C lib					    */
/****************************************************************************/

#define DaySec	(24*60*60L)
#define YearSec (365*DaySec)
#define DecSec	315532800L	/* secs in 1970-1979 */
#define Day1	4		/* Jan. 1, 1970 was a Thursday */
#define Day180	2		/* Jan. 1, 1980 was a Tuesday */

#ifdef DANL_OLD_AND_BROKEN

/*
 *  _isindst - Tells whether Xenix-type time value falls under DST
 *
 *  This is the rule:  a time is in DST iff it is on or after 0200:00 on
 *  the last Sunday in April and before 0100:00 on the last Sunday in
 *  October.
 *
 *  ENTRY   tb	- 'time' structure holding broken-down time value
 *
 *  RETURN  1 if time represented is in DST, else 0
 */

static _isindst(tb)
struct tm *tb;
{
    int mdays;
    int yr;
    int lastsun;

/* If the month is before April or after October, then we know immediately
 * it can't be DST. */

	if (tb->tm_mon < 3 || tb->tm_mon > 9)
		return(0);

/* If the month is after April and before October then we know immediately
 * it must be DST. */

	if (tb->tm_mon > 3 && tb->tm_mon < 9)
		return(1);
	/*
	 * Now for the hard part.  Month is April or October; see if date
	 * falls between appropriate Sundays.
	 */

/* The objective si to determine if the day is on or after 2:00 am on the
 * last Sunday in April, or before 1:00 am on the last Sunday in October.
 * We know the year-day( 0 .. 365 ) of the current time structure. We must
 * determine the year-day of the last Sunday itn this month, April or October,
 * and then do the comparison.
 * To determine the year-day of the last Sunday, we do the following:
 *	  1. Get the year-day of the 1st day of the month after the current
 *	     month: May or November.
 *	  2. Determine the week-day number of #1, which is defined as 0 = Sun,
 *	     1 = Mon, ... 6 = Sat
 *	  3. Subtract #2 from #1
 */

	yr = tb->tm_year + 1900;			/* To see if this is a leap-year */

/* First we get #1. The year-days for each month are stored in _days[]
 * they're all off by -1 */

	mdays = 1 + _days[tb->tm_mon+1];

/* if this is a leap-year, add an extra day */
	if (!(yr % 4) && ((yr % 100) || !(yr % 400)))
		mdays++;


/* mdays now has #1 */

	yr = tb->tm_year - 70;

/* Now get #2.	We know the week-day number of the beginning of the epoch,
 * Jan. 1, 1970, which is defined as the constant Day1.  We then add the
 * number of days that have passed from Day1 to the day of #2
 *	mdays + 365 * yr
 * correct for the leap years which intervened
 *	+ (yr + 1)/ 4
 * and take the result mod 7. This is #2, which we then subtract from
 * #1, mdays:
 */

	lastsun = mdays - ((mdays + 365*yr + ((yr+1)/4) + Day1) % 7);

/* Now we know 1 and 3; we're golden: */

	if (tb->tm_mon==3)
		return(tb->tm_yday > lastsun || (tb->tm_yday == lastsun && tb->tm_hour >= 2));
	else
		return(tb->tm_yday < lastsun || (tb->tm_yday == lastsun && tb->tm_hour < 1));
}

#else

/*
 *  _isindst - Tells whether Xenix-type time value falls under DST
 *
 *  This is the rule for years before 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the last Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  This is the rule for years starting with 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the first Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  ENTRY   tb  - 'time' structure holding broken-down time value
 *
 *  RETURN  1 if time represented is in DST, else 0
 */

static int _isindst(register struct tm *tb)
{
    int mdays;
    register int yr;
    int lastsun;

    /* If the month is before April or after October, then we know immediately
     * it can't be DST. */

    if (tb->tm_mon < 3 || tb->tm_mon > 9)
        return(0);

    /* If the month is after April and before October then we know immediately
     * it must be DST. */

    if (tb->tm_mon > 3 && tb->tm_mon < 9)
        return(1);
    /*
     * Now for the hard part.  Month is April or October; see if date
     * falls between appropriate Sundays.
     */

    /*
     * The objective for years before 1987 (after 1986) is to determine
     * if the day is on or after 2:00 am on the last (first) Sunday in April,
     * or before 1:00 am on the last Sunday in October.
     *
     * We know the year-day (0..365) of the current time structure. We must
     * determine the year-day of the last (first) Sunday in this month,
     * April or October, and then do the comparison.
     *
     * To determine the year-day of the last Sunday, we do the following:
     *        1. Get the year-day of the last day of the current month (Apr or Oct)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     *
     * To determine the year-day of the first Sunday, we do the following:
     *        1. Get the year-day of the 7th day of the current month (April)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     */

    yr = tb->tm_year + 1900;    /* To see if this is a leap-year */

    /* First we get #1. The year-days for each month are stored in _days[]
     * they're all off by -1 */

    if (yr > 1986 && tb->tm_mon == 3)
        mdays = 7 + _days[tb->tm_mon];
    else
        mdays = _days[tb->tm_mon+1];

    /* if this is a leap-year, add an extra day */
    if (!(yr & 3))
        mdays++;

    /* mdays now has #1 */

    yr = tb->tm_year - 70;

    /* Now get #2.  We know the week-day number of the beginning of the epoch,
     * Jan. 1, 1970, which is defined as the constant Day1.  We then add the
     * number of days that have passed from Day1 to the day of #2
     *      mdays + 365 * yr
     * correct for the leap years which intervened
     *      + (yr + 1)/ 4
     * and take the result mod 7, except that 0 must be mapped to 7.
     * This is #2, which we then subtract from #1, mdays
     */

    lastsun = mdays - ((mdays + 365*yr + ((yr+1)/4) + Day1) % 7);

    /* Now we know 1 and 3; we're golden: */

    return (tb->tm_mon==3
        ? (tb->tm_yday > lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour >= 2))
        : (tb->tm_yday < lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour < 1)));
}

#endif

static time_t _dtoxtime(yr, mo, dy, hr, mn, sc)
int yr;
int mo, dy, hr, mn, sc;
{
    int mdays;
    long scount;

    scount = ((yr+3)/4)*(long)DaySec;

    /* This is no good beyond the year 2099 */

    mdays = _days[mo-1];
    if (!(yr % 4) && (mo > 2))
	mdays++;
    scount += (yr*365 + dy + mdays)*(long)DaySec + (long)hr*3600L + mn*60L +
		sc + (long)DecSec;
    tb.tm_yday = mdays + dy;
    tzset();
    scount += timezone;
    tb.tm_year = yr + 80;
    tb.tm_mon = mo - 1;
    tb.tm_hour = hr;
    if (daylight && _isindst(&tb))
	scount -= 3600L;
    return(scount);
}


/****************************************************************************/
/* end of copy of code in C lib 					    */
/****************************************************************************/







long date2l(year, month, day, hour, min, sec)
int year, month, day, hour, min, sec;
{
    /* month is (1..12) */
    return _dtoxtime (year - 1980, month, day, hour, min, sec);
}

struct tm *ctime2tm(p)
char *p;
{
    char day[4], mon[4];
    int date, year, hour, min, sec, month;
    long now;

    if (sscanf (p, " %3s %3s %2d %2d:%2d:%2d %4d ",
		   day, mon, &date, &hour, &min, &sec, &year) == 7) {
	tzset();
	tb.tm_sec = sec;
	tb.tm_min = min;
	tb.tm_hour = hour;
	tb.tm_mday = date;
	tb.tm_year = year-1900;
	tb.tm_mon  = istr(mon, strMon, 12);
	tb.tm_wday = istr(day, strDay, 7);
	tb.tm_yday = yday(tb.tm_year, tb.tm_mon, tb.tm_mday);
	tb.tm_isdst = (daylight && _isindst(&tb) ? 1 : 0);
	return &tb;
	}

    if (*p == '+' && sscanf (p+1, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
	time (&now);
	now += 3600L * hour + 60L * min + sec;
	tb = *localtime (&now);
	return &tb;
	}
    if (*p == '+' && sscanf (p+1, " %2d:%2d ", &hour, &min) == 2) {
	time (&now);
	now += 3600L * hour + 60L * min;
	tb = *localtime (&now);
	return &tb;
	}
    if (*p == '+' && sscanf (p+1, " %2d ", &hour) == 1) {
	time (&now);
	now += 3600L * hour;
	tb = *localtime (&now);
	return &tb;
	}

    if (sscanf (p, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
	time (&now);
	tb = *localtime (&now);
	tb.tm_sec = sec;
	tb.tm_min = min;
	tb.tm_hour = hour;
	return &tb;
	}
    if (sscanf (p, " %2d:%2d ", &hour, &min) == 2) {
	time (&now);
	tb = *localtime (&now);
	tb.tm_sec = 0;
	tb.tm_min = min;
	tb.tm_hour = hour;
	return &tb;
	}

    if (sscanf (p, " %2d/%2d/%2d ", &month, &date, &year) == 3) {
	if (year < 70)
	    year += 2000;
	if (year < 100)
	    year += 1900;
	tzset();
	now = _dtoxtime (year - 1980, month, date, 0, 0, 0);
	tb = *localtime (&now);
	return &tb;
	}

    if (!strcmp (p, "yesterday")) {
	time (&now);
	now -= 24 * 3600L;
	tb = *localtime (&now);
	tb.tm_sec = 0;
	tb.tm_min = 0;
	tb.tm_hour = 0;
	return &tb;
	}
    if (!strcmp (p, "now")) {
	time (&now);
	tb = *localtime (&now);
	return &tb;
	}
    if (!strcmp (p, "tomorrow")) {
	time (&now);
	now += 24 * 3600L;
	tb = *localtime (&now);
	tb.tm_sec = 0;
	tb.tm_min = 0;
	tb.tm_hour = 0;
	return &tb;
	}

    return NULL;
}

long ctime2l(p)
char *p;
{
    if (ctime2tm(p) == NULL)
	return -1L;
    return date2l (tb.tm_year +1900, tb.tm_mon + 1, tb.tm_mday, tb.tm_hour,
	tb.tm_min, tb.tm_sec);
}


static leapyear(i)
int i;
{
    return (!i%4 && i%100);
}


static yday(year, mon, day)
int year, mon, day;
{
    int i, j;

    /* year = 1986 is 86 */
    /* mon (0..11)	 */
    j = day -1;
    for (i=0; i < mon; i++)
	j += dayinmon[i];
    if (mon > 2 && leapyear(year))
	j++;
    return j;
}

static istr(p, q, len)
char *p;
char **q;
int len;
{
    int i;

    for (i=0; i < len; i++)
	if (strcmpi(p, *q++)== 0)
	    break;
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\envorini.c ===
#include <stdlib.h>
#include <string.h>
#include "..\h\tools.h"


/* getenvini - get environment or tools.ini,
 * looks for pstrTag_pstrEnv as an environment variable,
 *   if found return copy of its value
 * if not found in env look for pstrEnv in pstrTag sect of $USER:\TOOLS.INI,
 *   if found return copy of its value
 * else return NULL.
 *
 * Returned value should be deallocated
 *
 * N.B. even if there is an entry in TOOLS.INI, non-NULL is returned iff
 * there are non-white space characters following the '=', e.g.
 *
 *  [tag]
 *      entry1=
 *      entry2=nonnull
 *
 *  getenvini ("entry1", "tag");  will return NULL
 *  getenvini ("entry2", "tag");  will return copy of "nonnull"
 *
 */

char *getenvini(pstrEnv, pstrTag)
char *pstrEnv;
char *pstrTag;
{
    char *p;
    char *pstrTmp;

    if (!(pstrTmp = (*tools_alloc) (strlen (pstrEnv) + strlen (pstrTag) + 2)))
        return NULL;
    strcpy (pstrTmp, pstrTag);
    strcat (pstrTmp, "_");
    strcat (pstrTmp, pstrEnv);
    pstrTmp = strupr (pstrTmp); /* getenv requires upper case */
    if ((p = getenv (pstrTmp))) {
        /* found in env so do NOT look into switch file */
        if (*(p = strbskip (p, "\t ")))
            /* found non-white space char so return non-NULL */
            p = strdup (p);
        else
            /* rhs has only white space char */
            p = NULL;
        }
    else
        p = swfind (pstrEnv, NULL, pstrTag); /* swfind does an alloc if found */
    free (pstrTmp);
    return p;
 }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\error.c ===
/* error.c - return text of error corresponding to the most recent DOS error
 *
 *  Modifications:
 *
 *	05-Jul-1989 bw	    Use MAXPATHLEN
 *      01-Jan-1993 jh      Localization of error messages
 */


#include <stdlib.h>
#define  UNKNOWN    37

char *sys_errorlist[] =
{
#include "syserr.msg"    /* -> IPG, localize syserr.msg */
};

int system_nerr = sizeof( sys_errorlist ) / sizeof( sys_errorlist[ 0 ] ) - 1;

char *error ()
{
    if (errno < 0 || errno >= system_nerr)
	return sys_errorlist[UNKNOWN];
    else
        return sys_errorlist[errno];
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fdelete.c ===
/* fdelete.c - perform undeleteable delete
 *
 *	5/10/86     dl	Use frenameNO instead of rename
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *	06-Jan-1987 mz	Use rename instead of frenameNO
 *	02-Sep-1988 bw	Keep original file if index file update fails.
 *			Overwrite existing DELETED.XXX if necessary.
 *	22-Dec-1989 SB	Changes for new Index file format
 *      14-Nov-1992 bws Disable [DELETED] directory behavior for MS-DOS 6
 *                       (#define DELETED_DIR to enable this behavior)
 */

#if defined (OS2)
#include <os2.h>
#endif

#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include "..\h\tools.h"
#include "..\h\rm.h"
#include <string.h>
#include <direct.h>
#include <malloc.h>

char rm_header[RM_RECLEN] = { RM_NULL, RM_MAGIC RM_VER };

/* fdelete returns:
 *  0 if fdelete was successful
 *  1 if the source file did not exist
#ifdef DELETED_DIR
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessible, could not be updated, or corrupted
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
#else // simple delete!
 *  2 if the source was read-only
 *
 * The specified file is deleted.
#endif
 */
int fdelete(p)
char *p;                                /* name of file to be deleted */
{
#ifdef DELETED_DIR
    char *dir;				/* deleted directory */
    char *idx;				/* deleted index */
    int   fhidx;
    char *szRec;			/* deletion entry in index */
#endif
    int   attr;
    int   erc;

#ifdef DELETED_DIR
    dir = idx = szRec = NULL;
    fhidx = -1;
    if ((dir = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	(idx = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	(szRec = (*tools_alloc) (MAXPATHLEN)) == NULL) {
	erc = 3;
	goto cleanup;
	}
#endif

    /* See if the file exists */
    if ((attr = getattr (p)) == -1) {
	erc = 1;
	goto cleanup;
	}

    /* what about read-only files? */
    if (TESTFLAG (attr, A_RO)) {
	erc = 2;
	goto cleanup;
	}

#ifndef DELETED_DIR
    if (unlink(p) == -1)
        erc = 2;
    else
        erc = 0;
cleanup:
    return erc;
#else // DELETED_DIR
    /*	Form an attractive version of the name
     */
    pname (p);

    /* generate deleted directory name, using defaults from input file
     */
    upd (p, RM_DIR, dir);

    /* generate index name */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

    /* make sure directory exists (reasonably) */
    if (mkdir (dir) == 0)
        setattr (dir, A_H | A_S);

    /* extract filename/extention of file being deleted */
    fileext (p, szRec);

    /* try to open or create the index */
    if ((fhidx = open (idx, O_CREAT | O_RDWR | O_BINARY,
		       S_IWRITE | S_IREAD)) == -1) {
	erc = 3;
	goto cleanup;
	}

    if (!convertIdxFile (fhidx, dir)) {
	erc = 3;
	goto cleanup;
    }

    /* determine new name */
    sprintf (strend (dir), "\\deleted.%03x",
	     lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

    /* move the file into the directory */
    unlink (dir);
    if (rename (p, dir) == -1) {
	erc = 2;
	goto cleanup;
        }

    /* index the file */
    if (!writeNewIdxRec (fhidx, szRec)) {
	rename (dir, p);
	erc = 2;
	goto cleanup;
        }
    erc = 0;

cleanup:
    if (fhidx != -1)
	close(fhidx);
    if (dir != NULL)
	free (dir);
    if (idx != NULL)
	free (idx);
    if (szRec != NULL)
	free (szRec);
    return erc;
#endif // DELETED_DIR
}


#ifdef DELETED_DIR
/* writeIdxRec - Write an index record
 *
 * Returns: 1 when no error
 *	    0 when it fails
 */
int writeIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return write (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}

/* readIdxRec - Read an index record
 *
 * Returns: 1 when no error
 *	    0 when it fails
 */
int readIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return read (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}


/* convertIdxFile - convert index file to new Index File format.
 *
 * Note: If new index file then we do nothing.
 *
 * Returns:  1	if successful
 *	     0	if it fails
 */
int convertIdxFile (fhIdx, dir)
int fhIdx;
char *dir;
{
    // char rec[RM_RECLEN];	    /* record for index files */
    char firstRec[RM_RECLEN];	    /* firstRec */
    int iRetCode = TRUE;
    char *oldName, *newName;

    oldName = newName = NULL;
    if ((oldName = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	    (newName = (*tools_alloc) (MAXPATHLEN)) == NULL) {
	iRetCode = FALSE;
	goto cleanup;
    }

    /* If index file is just created then write header */
    if (lseek (fhIdx, 0L, SEEK_END) == 0L)
	writeIdxHdr (fhIdx);
    else {
	/* Go to the beginning */
	lseek (fhIdx, 0L, SEEK_SET);

	/* If New Index format then we are done */
	readIdxRec (fhIdx, firstRec);
	if (fIdxHdr (firstRec))
	    goto cleanup;
	else {
	    if (!writeIdxHdr (fhIdx)) {
		iRetCode = FALSE;
		goto cleanup;
	    }
	    strcpy (oldName, dir);
	    strcpy (newName, dir);
	    pathcat (oldName, "\\deleted.000");
	    sprintf (strend (newName), "\\deleted.%03x",
		     lseek (fhIdx, 0L, SEEK_END) / RM_RECLEN);
	    if (rename (oldName, newName) || !writeIdxRec (fhIdx, firstRec)) {
		iRetCode = FALSE;
		goto cleanup;
	    }
	}
    }
cleanup:
    if (oldName != NULL)
	free (oldName);
    if (newName != NULL)
	free (newName);
    return iRetCode;
}

/* fIdxHdr - Is the Index record a new index format header
 */
flagType fIdxHdr (rec)
char*rec;
{
    return (flagType) (rec[0] == RM_SIG
	     && !strncmp(rec+1, RM_MAGIC, strlen(RM_MAGIC)));
}

/* writeIdxHdr - Write an header record into a header file
 *
 * Returns: 1 when no error
 *	    0 when it fails
 */
int writeIdxHdr (fhIdx)
int fhIdx;
{
    /* Seek to the beginning of the file */
    lseek (fhIdx, 0L, SEEK_SET);

    /* Use rm_header[] from rm.h */
    return writeIdxRec (fhIdx, rm_header);
}

/* writeNewIdxRec - creates entry for file in new index file format.
 *
 * Returns: 1	if successful
 *	    0	if it fails
 */
int writeNewIdxRec (fhIdx, szRec)
int fhIdx;
char *szRec;
{
    char rec[RM_RECLEN];
    int cbLen;

    cbLen = strlen(szRec) + 1; // Include NUL at end
    while (cbLen > 0) {
	Fill (rec, 0, RM_RECLEN);
	strncpy (rec, szRec, RM_RECLEN);
	szRec += RM_RECLEN;
	if (!writeIdxRec (fhIdx, rec))
	    return FALSE;
	cbLen -= RM_RECLEN;
    }
    return TRUE;
}

/* readNewIdxRec - reads in records in new index file corresponding to
 *		   one index entry.
 *
 * Note: It returns the file name read in szRec.
 *
 * Returns: TRUE    if successful
 *	    FALSE   if it fails
 */
int readNewIdxRec (
int fhIdx,
char *szRec,
unsigned int cbMax
) {
    // char *pEndRec;		    /* End of file name */
    char rec[RM_RECLEN];	    /* read at one go */
    unsigned int cb = 0;

    /* Read the entry */
    do {
	if (!readIdxRec (fhIdx, rec))
	    return FALSE;
	strncpy (szRec, rec, RM_RECLEN);
	szRec += RM_RECLEN;
	cb += RM_RECLEN;
    } while (!memchr (rec, '\0', RM_RECLEN) && (cb < cbMax));

    return TRUE;
}
#endif // DELETED_DIR
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fexpunge.c ===
/* fexpunge.c - remove all deleted objects from the index
 *
 *  HISTORY:
 *
 *	??-???-???? ??	 Original Version
 *	06-Sep-1988 bw	 Issue error is directory removal fails
 *	20-Dec-1989 SB	 Change for new Index file format, added NOTES
 *
 * NOTES:
 *  The old-format index file was composed of elements of size RM_RECLEN having
 *  the following syntax :-
 *
 *     <element> := <valid-element> | <deleted-element>
 *     <valid-element> := <8.3filename> <padding>
 *     <deleted-element> := <padding>
 *	   where,
 *	       <padding> is series of (RM_RECLEN - sizeof(8.3filename) 0x00's
 *
 *  If the first RM_RECLEN bytes of the index file match the new index file
 *  header then the index file has new-format.
 *
 *  The new-format index file is composed of elements of size (n * RM_RECLEN)
 *  having the following syntax :-
 *
 *	<header>	  := <0x00> <magic> <version> <0x00> <first-padding>
 *	<valid-element>   := <longfilename> <padding>
 *	<deleted-element> := <padding>
 *	    where,
 *		<padding> is a series is 0x00 to round off to RM_RECLEN length
 *		<magic> is RM_MAGIC (currently IX)
 *		<version> is RM_VERSION (currently 1.01)
 *  When <longfilename> is a multiple of RM_RECLEN then an extra padding record
 *  is added to make it a NULL terminated string.
 *
 */

#if defined (OS2)
#include <os2.h>
#endif

#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include "..\h\tools.h"
#include "..\h\rm.h"
#include <string.h>
#include <time.h>
#include <direct.h>
#include <malloc.h>

/* we open the index corresponding to the named directory and release all
 * the deleted files present.  At the end, we remove the index and the deleted
 * directory */
long fexpunge (pDir, list)
char *pDir;
FILE *list;
{
    int fhidx;
    char *dir;				/* deleted dir */
    char *szRec;			/* name of file deleted */
    char *idx;				/* name of index */
    char *file;
    long totbytes;
    struct stat statbuf;

    totbytes = 0L;
    dir = idx = file = NULL;
    if ((dir = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	    (idx = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	    (file = (*tools_alloc) (MAXPATHLEN)) == NULL ||
	    (szRec = (*tools_alloc) (MAXPATHLEN)) == NULL) {
	if (list)
	    fprintf (list, "Unable to allocate internal storage\n");
	goto done;
    }

    /* generate deleted directory name from dir */
    strcpy (dir, pDir);
    pathcat (dir, RM_DIR);
    /* generate index name from deleted directory */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);
    /* try to open index.  If it fails, no problem */
    if ((fhidx = open (idx, O_RDWR | O_BINARY)) != -1) {
	if (list)
	    fprintf (list, "Expunging files in %s\n", pDir);

	readIdxRec (fhidx, szRec);
	if (fIdxHdr (szRec))
	    if (!readNewIdxRec (fhidx, szRec, MAXPATHLEN))
		goto done;
	do {
	    /* For each file that was RMed and not UNDELed */
	    if (szRec[0] != '\0') {
		/* The name starts earlier than current position in the index
		 * file. The deleted file index is derived from the current
		 * offset and the length of the string.
		 */
		sprintf (file, "%s\\deleted.%03x", dir, (lseek (fhidx, 0L, SEEK_CUR)
			 - strlen (szRec)) / RM_RECLEN);
		if (stat (file, &statbuf) == -1) {
		    if (list)
			fprintf (list, " (%s - %s)\n", file, error ());
		}
		else {
		    unlink (file);
		    totbytes += statbuf.st_size;
		    if (list) {
			char *pTime = ctime (&statbuf.st_mtime);

			/* ctime() returns a string which has a \n at
			 * fixed offset of 24. [ANSI draft]. We don't need
			 * it because we put the File Name before \n
			 */
			*(pTime + 24) = '\0';
			upd (dir, szRec, file);
			fprintf (list, "%8ld %s  %s\n", statbuf.st_size, pTime,
				 file);
			fflush (list);
		    }
		}
	    }
	} while (readNewIdxRec (fhidx, szRec, MAXPATHLEN));

	close (fhidx);
	unlink (idx);
	if (rmdir (dir))
	    fprintf (list, "ERROR: Unable to remove directory %s - %s\n", dir, error ());
	if (list)
	    fprintf (list, "%ld bytes freed\n", totbytes);
    }
    else
	if (!stat (dir, &statbuf))
	    fprintf (list, "Warning: Cannot open %s - %s\n", idx, error ());
done:
    if (dir)
	free (dir);
    if (idx)
	free (idx);
    if (file)
	free (file);
    if (szRec)
	free (szRec);
    return totbytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fappend.c ===
/* fappend.c - fast append of one file to another */

#if defined (OS2)
#include <os2.h>
#endif

#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <dos.h>
#include "..\h\tools.h"

#if defined(DOS)
#define IBUF 10240


char *fappend( src, dstfh )
char *src;
HANDLE dstfh;
{
    int srcfh, cnt, bufsiz;
    struct findType fbuf;
    char *copybuf, *result;

    result = "Out of memory";
    srcfh = -1;
    bufsiz = IBUF;
    while (!(copybuf = (*tools_alloc) (bufsiz) ))
        if ( !(bufsiz >>= 1) )
            goto done;

    result = "Unable to open source";
    if ( ffirst( src, ~A_V, (NPFIND)&fbuf ) )
        goto done;

    findclose(&fbuf);	/* Free dir handle for next ffirst */

        /* open source for read access */
    if ((srcfh = open (src, O_RDONLY | O_BINARY)) == -1)
        goto done;

        /* Loop, copying N bytes at a time until no more */
    lseek( dstfh, 0L, 2 );
    while ( ( cnt = read( srcfh, copybuf, bufsiz ) ) > 0)
        if ( write( dstfh, copybuf, cnt ) != cnt ) {
            result = "Unable to write destination";
            goto done;
            };

    if (cnt)
        result = "Unable to read source";
    else
        result = NULL;
done:
    cnt = errno;
    if (copybuf)
        free( copybuf );
    if (srcfh != -1)
        close( srcfh );
    errno = cnt;
    return result;
}


#elif defined(OS2) || defined(NT)

char *fappend(
    char *src,
    HANDLE dstfh
    )
{
    int srcfh;
    char *result;

    if ((srcfh = open (src, O_RDONLY | O_BINARY)) == -1)
	result = "Unable to open source";
    else {
	lseek( (int) dstfh, 0L, SEEK_END );
	result = fastcopy ((HANDLE)srcfh, dstfh);
        close( srcfh );
	}
    return result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\exetype.c ===
/*
 *  exeType( filename ) -   Return the type of .EXE, based on a quick
 *			    examination of the header.	If it is a new .EXE
 *			    and the OS ( Windows, DOS 4.X, 286DOS ) cannot
 *			    be guessed accurately, just return "new exe".
 *
 *  The algorithm is:
 *
 *	if ( File is too short for old-style header )	==> NOT AN EXE
 *	if ( MZ signature not found )			==> NOT AN EXE
 *	if ( Offset of relocation table != 0x40 )	==> Old-style .EXE
 *	if ( File is too short for new-style header )	==> NOT AN EXE
 *	if ( New Magic number is wrong )		==> Old-stype .EXE
 *	if ( Dynalink flag set )			==> Dyna-link lib
 *	if ( minalloc in old header is 0xFFFF ) 	==> 286DOS .EXE
 *	if ( Import table is empty )			==> DOS 4 .EXE
 *	if ( Resource Table is not empty )		==> Windows .EXE
 *	if ( Stub loader is present )
 *	   if ( "This" is at 0x4E )			==> 286DOS .EXE
	   else 					==> Bound .EXE
 *	else						==> New-style .EXE
 *
 *--------------------------------------------------------------------------
 *  strExeType( number ) - number is a value returned from exeType, and
 *			   a standard string associated with that type
 *			   is returned.
*/
#include "..\h\tools.h"
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <share.h>
#include <string.h>
#include <io.h>
#include <errno.h>


enum exeKind exeType( f )
char * f;
{
    struct exe_hdr oldhdr;
    struct new_exe newhdr;
    int fh, br;
    enum exeKind retc;
    char defstubmsg[4];

	errno = 0;
	if ( (fh = sopen( f, O_RDONLY | O_BINARY, SH_DENYWR )) == -1 )
	    return IOERROR;

	br = read( fh, (char *)&oldhdr, sizeof oldhdr );

	if ( br != sizeof oldhdr || E_MAGIC(oldhdr) != EMAGIC )
	    retc = NOTANEXE;
	else
	    if ( E_LFARLC(oldhdr) == ENEWEXE )
	    {
		lseek( fh, E_LFANEW(oldhdr), SEEK_SET);
		br = read( fh, (char *)&newhdr, sizeof newhdr );

		if ( br != sizeof newhdr ) retc = OLDEXE;
		else if ( NE_MAGIC(newhdr) != NEMAGIC )     retc = OLDEXE;
		else if ( NE_FLAGS(newhdr) & NENOTP )	    retc = DYNALINK;
		else if ( E_MINALLOC(oldhdr) == 0xFFFF )    retc = DOS286;
		else if ( NE_ENTTAB(newhdr) - NE_IMPTAB(newhdr) == 0 )
							    retc = DOS4;
		else if ( NE_RESTAB(newhdr) - NE_RSRCTAB(newhdr) )
							    retc = WINDOWS;
		else if ( E_LFANEW(oldhdr) != ENEWEXE )
		     {
			lseek( fh, (long)NEDEFSTUBMSG, SEEK_SET );
			read( fh, defstubmsg, 4 );
			if ( !strncmp (defstubmsg, "This", 4))
							    retc = DOS286;
			else				    retc = EXEBOUND;
		     }
		else					    retc = NEWEXE;
	    }
	    else					    retc = OLDEXE;

	close(fh);
	return retc;
}

char * strExeType (exenum)
enum exeKind exenum;
{
    switch ( exenum )
    {
	case IOERROR:	return "???????";   break;
	case NOTANEXE:	return "Not_EXE";   break;
	case OLDEXE:	return "DOS";	    break;
	case NEWEXE:	return "New";	    break;
	case WINDOWS:	return "Windows";   break;
	case DOS4:	return "Dos4";	    break;
	case DOS286:	return "Protect";   break;
	case EXEBOUND:	return "Bound";     break;
	case DYNALINK:	return "DynaLink";  break;
	default:	return "Unknown";   break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fcopy.c ===
/* fcopy.c - fast copy between two file specs
 *
 *	09-Dec-1986 bw	Added DOS 5 support
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *      13-May-1989 wc  use sopen for sourcefile. For System Languages Testing.
 *                      also include share.h, and io.h.
 *
*/

#define INCL_DOSFILEMGR
#if defined (OS2)
#include <os2.h>
#endif

#include <stdlib.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <share.h>
#include <io.h>
#if !defined(OS2)
#include <dos.h>
#endif
#include "..\h\tools.h"
#include "fcopytxt.h"

#if defined (DOS)
#define IBUF    10240
#define IBUFSM  1024

/* fcopy (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fcopy (char *src,char *dst)
{
    int srcfh, dstfh, cnt;
    char *copybuf, *result;
    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
	 struct SREGS sregs;
#endif
    int cBuf = IBUF;

    result = NOT_ENOUGH_MEM;
    srcfh = dstfh = -1;
    if ((copybuf = (*tools_alloc) (IBUF)) == NULL) {
        cBuf = IBUFSM;
	if ((copybuf = (*tools_alloc) (IBUFSM)) == NULL)
            goto done;
        }

    result = CANT_OPEN_SOURCE;

/*    if ((srcfh = open (src, O_RDONLY | O_BINARY)) == -1) */

    if ((srcfh = sopen (src, O_RDONLY | O_BINARY, SH_DENYNO)) == -1) 
        goto done;

    result = CANT_CREATE_DEST;
    if ((dstfh = open (dst, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY,
                       S_IREAD | S_IWRITE)) == -1)
        goto done;

    result = CANT_WRITE_DEST;
    while ((cnt = read (srcfh, copybuf, cBuf)))
        if (write (dstfh, copybuf, cnt) != cnt)
            goto done;

    result = CANT_READ_SOURCE;
    if (cnt)
        goto done;


    /* get the last-modify time for source */
    result = CANT_GET_SRC_TIME;
    regs.x.ax = 0x5700;
    regs.x.bx = srcfh;
    intdos (&regs, &regs);
    if (regs.x.cflag)
        goto done;
    close (srcfh);
    srcfh = -1;
    /* set the last modification time */
    result = CANT_SET_DEST_TIME;
    regs.x.ax = 0x5701;
    regs.x.bx = dstfh;
    intdos (&regs, &regs);
    if (regs.x.cflag)
        goto done;
    close (dstfh);
    dstfh = -1;
    /* get source attributes */
    result = CANT_GET_SRC_ATTR;
    regs.x.ax = 0x4300;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    segread( &sregs);
    sregs.ds = FP_SEG(src);
    regs.x.dx = FP_OFF(src);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) src;
    intdos (&regs, &regs);
#endif
    if (regs.x.cflag)
        goto done;
    /* set destination attributes (leave off readonly) */
    result = CANT_SET_DEST_ATTR;
//  RSETFLAG (regs.x.cx, A_RO);
    regs.x.ax = 0x4301;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    segread( &sregs);
    sregs.ds = FP_SEG(dst);
    regs.x.dx = FP_OFF(dst);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) dst;
    intdos (&regs, &regs);
#endif
    if (regs.x.cflag)
        goto done;
    result = NULL;


done:
    if (copybuf)
        free( copybuf );
    if (srcfh != -1)
        close( srcfh );
    if (dstfh != -1)
        close( dstfh );
    return result;
}


#elif defined(OS2) || defined(NT)

/* fcopy (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fcopy (char *src, char *dst)
{
    int srcfh, dstfh;
    char *result;
#if defined(OS2)
    FILESTATUS SrcStatus;
    FEALIST far *fpfeal = NULL;
#elif defined(NT)
    FILETIME CreationTime, LastAccessTime, LastWriteTime;
    DWORD    attrib;
#endif

    srcfh = dstfh = -1;

// if ((srcfh = open (src, O_RDONLY | O_BINARY)) == -1) {
    if ((srcfh = sopen (src, O_RDONLY | O_BINARY, SH_DENYNO)) == -1) {
	result = CANT_OPEN_SOURCE;
        goto done;
	}

    if ((dstfh = open (dst, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY,
		       S_IREAD | S_IWRITE)) == -1) {
	result = CANT_CREATE_DEST;
        goto done;
	}

    result = fastcopy ((HANDLE) srcfh, (HANDLE) dstfh);

    if (result != NULL)
	goto done;

#if defined(OS2)

    /*	If we're on v1.2 or later, do an EA copy and skip any errors
     *	about unsupported EAs
     */

    if (_osmajor > 10 || _osminor >= 20) {
	EAOP eaop;
	USHORT erc;

	erc = DosAllocSeg (0, &SELECTOROF (fpfeal), SEG_NONSHARED);
	if (erc != 0) {
	    result = "Out of memory for EA copy";
	    }
	else {
	    eaop.fpFEAList = fpfeal;
	    fpfeal->cbList = 65534L; //1.3 doesn't like it if you give all 64K
	    erc = DosQFileInfo (srcfh, 4, &eaop, sizeof (eaop));

	    if (!erc) {
		DosSetFileInfo (dstfh, 2, (PBYTE) &eaop, sizeof (eaop));
		}

	    }
	}

    if (NULL == result) {
	if (DosQFileInfo (srcfh, 1, (PBYTE) &SrcStatus, sizeof SrcStatus) != 0) {
	    result = "Unable to get source file information";
	    }
	else {
	    RSETFLAG ( SrcStatus.attrFile , A_RO );

	    if (DosSetFileInfo (dstfh, 1, (PBYTE) &SrcStatus, sizeof SrcStatus) != 0) {
		result = "Unable to set destination file attributes";
		}
	    }
	}

done:
    if (fpfeal != NULL)
	DosFreeSeg (SELECTOROF (fpfeal));
#elif defined(NT)
    if (!GetFileTime(z_handle(srcfh), &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to get time of source";
        goto done;
    }

    if (!SetFileTime(z_handle(dstfh), &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to set time of destination";
        goto done;
    }

    if( ( attrib = GetFileAttributes( src ) ) == -1 ) {
	result = "Unable to get source file information";
	goto done;
    }

    RSETFLAG( attrib, FILE_ATTRIBUTE_READONLY );

    if( SetFileAttributes( dst, attrib ) == FALSE ) {
	result = "Unable to set destination file attributes";
	goto done;
    }

done:
#endif

    if (srcfh != -1)
	close( srcfh );
    if (dstfh != -1)
	close( dstfh );
    return result;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fgetl.c ===
/*  fgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 */

#include "..\h\tools.h"

/* returns line from file (no CRLFs); returns NULL if EOF */
fgetl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    register int c;
    register char *p;

    /* remember NUL at end */
    len--;
    p = buf;
    while (TRUE) {
        c = fgetc (fh);
	if (c == EOF || c == '\n')
	    break;
	if (c != '\r')
	    if (len == 0) {
		ungetc (c, fh);
		break;
		}
	    else
	    if (c != '\t') {
		*p++ = (char) c;
		len--;
		}
	    else {
		c = min (8 - ((p-buf) & 0x0007), len);
		Fill (p, ' ', c);
		p += c;
		len -= c;
		}
	}
    *p = 0;
    return ! ( (c == EOF) && (p == buf) );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fastcopy.c ===
/*  fastcopy - use multiple threads to whack data from one file to another
 */

#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES

#if defined (OS2)
#include <os2.h>
#endif
#include <malloc.h>
#include <process.h>
#include <stdlib.h>
#include "..\h\tools.h"

#define BUFSIZE     0xFE00		/*  full segment minus sector	      */
#define STACKSIZE   256 		/*  stack size for child thread       */

typedef struct BUF BUF;

#if defined (OS2)

struct BUF {
    BOOL flag;
    USHORT cch;
    BUF far * fpbufNext;
    BYTE ach[BUFSIZE];
    };

#define LAST	TRUE
#define NOTLAST FALSE

#define TO_INFINITE 0xFFFFFFFF

static long	   avail;
static long	   queue;
static BUF far *   fpbufHead = NULL;
static BUF far *   fpbufTail = NULL;
static HANDLE	   hfSrc, hfDst;

/*  forward type definitions
 */

static NPSZ writer (void);
static void far reader (void);
static BUF far * dequeue (void);
static void enqueue (BUF far * fpbuf);

static NPSZ writer ()
{
    BUF far *fpbuf;
    USHORT cch;
    BOOL f = !LAST;
    NPSZ npsz = NULL;

    while (f != LAST && npsz == NULL) {
	fpbuf = dequeue ();
	if ((f = fpbuf->flag) != LAST)
	    if (DosWrite (hfDst, fpbuf->ach, fpbuf->cch, &cch) != 0)
		npsz = "DosWrite error";
	    else
	    if (cch != fpbuf->cch)
		npsz = "DosWrite out-of-space";
	    else
		;
	else
	    npsz = *(NPSZ far *)fpbuf->ach;
	if (DosFreeSeg (SELECTOROF (fpbuf)) != 0)
	    npsz = "DosFreeSeg error";
	}
    return npsz;
}

static void far reader ()
{
    BUF far * fpbuf;
    USHORT erc;
    BOOL f = !LAST;

    while (f != LAST) {
	if (DosAllocSeg (sizeof (BUF), (PSEL) & SELECTOROF (fpbuf), (USHORT) 0) != 0) {
	    printf ("DosAllocSeg error\n");
	    exit (1);
	    }
	OFFSETOF (fpbuf) = 0;
	f = fpbuf->flag = NOTLAST;
	erc = DosRead (hfSrc, (CHAR far *) fpbuf->ach, BUFSIZE, & fpbuf->cch);
	if (fpbuf->cch == 0 || erc != 0) {
	    f = fpbuf->flag = LAST;
	    *(PSZ far *)fpbuf->ach = erc != 0 ? "DosReadError" : NULL;
	    }
	enqueue (fpbuf);
	}
}

static BUF far * dequeue (void)
{
    USHORT erc;
    BUF far * fpbuf;

    while (TRUE) {
	erc = DosSemSet (&avail);
	if (fpbufHead != NULL) {
	    erc = DosSemRequest (&queue, TO_INFINITE);
	    fpbufHead = (fpbuf = fpbufHead)->fpbufNext;
	    if (fpbufTail == fpbuf)
		fpbufTail = NULL;
	    erc = DosSemClear (&queue);
	    break;
	    }
	erc = DosSemWait (&avail, TO_INFINITE);
	}
    return fpbuf;
}

static void enqueue (fpbuf)
BUF far * fpbuf;
{
    USHORT erc;

    fpbuf->fpbufNext = NULL;
    erc = DosSemRequest (&queue, TO_INFINITE);
    if (fpbufTail == NULL)
	fpbufHead = fpbuf;
    else
	fpbufTail->fpbufNext = fpbuf;
    fpbufTail = fpbuf;
    erc = DosSemClear (&queue);
    erc = DosSemClear (&avail);
}

/*  fastcopy - copy data quickly from one handle to another
 *
 *  hfSrcParm	    file handle to read from
 *  hfDstParm	    file handle to write to
 *
 *  returns	    NULL if successful
 *		    pointer to error string otherwise
 */
char * fastcopy (HANDLE hfSrcParm, HANDLE hfDstParm)
//HFILE hfSrcParm, hfDstParm;
{
    BYTE *pchStack;
    USHORT erc;
    USHORT ignore;
    NPSZ npsz;

    hfSrc = hfSrcParm;
    hfDst = hfDstParm;

    pchStack = (*tools_alloc)  (STACKSIZE);
    if (pchStack == NULL)
	return "not enough memory";

    erc = DosCreateThread (reader, &ignore, pchStack + STACKSIZE);
    if (erc) {
	free (pchStack);
	return "can't create thread";
	}
    npsz = writer ();
    free (pchStack);
    return npsz;
}

#elif defined(NT)
#include <io.h>

struct BUF {
    BOOL  flag;
    ULONG cbBuf;
    BUF  *fpbufNext;
    BYTE  ach[BUFSIZE];
    };

typedef unsigned char *NPSZ;

#define LAST    TRUE
#define NOTLAST FALSE

static HANDLE            hevQNotEmpty;
static CRITICAL_SECTION  hcrtQLock;
//static HMTX            hmtxQLock;
//static HEV             hevQNotEmpty;
static BUF              *fpbufHead = NULL;
static BUF              *fpbufTail = NULL;
static int		 hfSrc, hfDst;
static HANDLE		 hThread;
static BOOL		 fAbort;

/*  forward type definitions
 */

NPSZ	writer( void ); 	  //static
DWORD	reader( void ); 	  //static
BUF	*dequeue( void );	  //static
void	enqueue( BUF *fpbuf );	  //static

//static
 NPSZ writer ()
{
    BUF *fpbuf;
    DWORD cbBytesOut;
    BOOL f = !LAST;
    NPSZ npsz = NULL;
    CHAR szErr[50] = "WriteFile: error ";

    while (f != LAST && npsz == NULL) {
        fpbuf = dequeue ();
        if ((f = fpbuf->flag) != LAST) {
	    if( (cbBytesOut = _write( hfDst, fpbuf->ach, fpbuf->cbBuf)) == -1 ) {
		npsz = szErr;
		//ultoa((unsigned long) errno, szErr+17, 10);
		strcpy(szErr+17, strerror(errno));
            } else if( cbBytesOut != ( DWORD )fpbuf->cbBuf ) {
                npsz = "WriteFile: out-of-space";
            }
        } else {
            npsz = *(NPSZ *)fpbuf->ach;
        }
        LocalFree(fpbuf);
    }
    if ( f != LAST )
	fAbort = TRUE;
    WaitForSingleObject( hThread, -1 );
    CloseHandle(hThread);
    CloseHandle(hevQNotEmpty);
    DeleteCriticalSection(&hcrtQLock);
    return npsz;
}


//static
 DWORD reader()
{
    BUF *fpbuf;
    BOOL f = !LAST;

    while ( !fAbort && f != LAST) {
        if ( (fpbuf = LocalAlloc(LMEM_FIXED,sizeof(BUF)) ) == 0) {
            printf ("LocalAlloc error %ld\n",GetLastError());
            exit (1);
        }
        f = fpbuf->flag = NOTLAST;
	if ( ((fpbuf->cbBuf = _read( hfSrc, fpbuf->ach, BUFSIZE)) == -1) || (fpbuf->cbBuf == 0) ) {
	    f = fpbuf->flag = LAST;
	    if (fpbuf->cbBuf == -1) { //error
		fpbuf->cbBuf = 0;
		*(NPSZ *)fpbuf->ach = "read error";
		}
	    else
		*(NPSZ *)fpbuf->ach = NULL;
        }
        enqueue (fpbuf);
    }
    return( 0 );
}

//static
 BUF *dequeue( void )
{
    BUF *fpbuf;

    while (TRUE) {

        if (fpbufHead != NULL) {
            EnterCriticalSection( &hcrtQLock );
            fpbufHead = (fpbuf = fpbufHead)->fpbufNext;
            if( fpbufTail == fpbuf ) {
                fpbufTail = NULL;
            }
            LeaveCriticalSection( &hcrtQLock );
            break;
        }

        /*
           the head pointer is null so the list is empty.
           block on eventsem until enqueue posts (ie. adds to queue)
        */

        WaitForSingleObject( hevQNotEmpty, -1 );
    }
    return fpbuf;
}

//static
 void enqueue( BUF *fpbuf )
{
    fpbuf->fpbufNext = NULL;

    EnterCriticalSection( &hcrtQLock );

    if( fpbufTail == NULL ) {
        fpbufHead = fpbuf;
    } else {
        fpbufTail->fpbufNext = fpbuf;
    }
    fpbufTail = fpbuf;
    LeaveCriticalSection( &hcrtQLock );

    SetEvent( hevQNotEmpty );
}

/*  fastcopy - copy data quickly from one handle to another
 *
 *  hfSrcParm       file handle to read from
 *  hfDstParm       file handle to write to
 *
 *  returns         NULL if successful
 *                  pointer to error string otherwise
 */
char *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm)
{
    DWORD dwReader;

    hfSrc = (int)hfSrcParm;
    hfDst = (int)hfDstParm;

    hevQNotEmpty = CreateEvent( NULL, (BOOL)FALSE, (BOOL)FALSE,NULL );
    if ( hevQNotEmpty == INVALID_HANDLE_VALUE )
	return "can't create Event object";
    fAbort = FALSE;
    InitializeCriticalSection( &hcrtQLock );

    hThread = CreateThread( 0, STACKSIZE, (LPTHREAD_START_ROUTINE)reader, 0, 0, &dwReader );
    if( hThread == INVALID_HANDLE_VALUE ) {
        return "can't create thread";
    }
    return( writer() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\forsemi.c ===
/* forsemi.c - walk a semicolon separated sstring */

#include "..\h\tools.h"
#include <stdarg.h>

flagType forsemi (register char *p,
		  flagType (*proc)(char *, va_list),
		  ...)
{
    char	*p1, c;
    flagType	f;
    va_list	ap;


    do {
	p1 = strbscan (p, ";");
	c = *p1;
	*p1 = 0;
	va_start(ap, proc);
	f = (*proc)(p, ap);
	va_end(ap);
	p = p1;
	*p++ = c;
	if (f)
	    return TRUE;
    } while (c);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fputl.c ===
/*  fputl.c - write a CRLF line to a file
 */

#include "..\h\tools.h"

/* writes a line to file (with trailing CRLFs) from buf, return <> 0 if
 * writes fail
 */
fputl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    return (fwrite (buf, 1, len, fh) != (unsigned) len || fputs ("\r\n", fh) == EOF) ? EOF : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\forfile.c ===
/* forfile (filename, attr, routine) step through file names calling routine
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *	24-Feb-1987 bw	Do findclose() to make FAPI happy.
 */

#include <dos.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include "..\h\tools.h"

#include "messages.msg" // Localizable strings

/* internal functions */
int AllowXLinkError (void);
int Novell_Installed (void);
int isDecnet(void);

/* internal global variables */
char sz[MAXPATHLEN];

/**********************************************************************
 *
 * Determine the existance of DECNET Pathworks.
 *
 * INPUT : None
 *
 * OUTPUT: return version of Pathworks currently running. return zero
 *    if Decnet is not found
 *
 * DEPENDENCY: Only rung in real mode
 *
 **********************************************************************/
int isDecnet()
{
#define DECNET_DNP        0x6E
#define DECNET_GETVEC     0x35

   static int uResult=-1;
   register int i;
   char rgchMemBuf[10];
   union REGS inregs, outregs;
   struct SREGS segments;
   char far *lpReturnDos;

   if (-1 != uResult)
      return uResult;

   /*
    * this inturrupt only works on real mode.
    * Segment selector have to be determine in protected mode.
    * which I didn't implement (w-johny)
    */ 
   inregs.h.al = DECNET_DNP;
   inregs.h.ah = DECNET_GETVEC;
   segread( &segments );
   intdosx( &inregs, &outregs, &segments );

   FP_SEG (lpReturnDos) = segments.es;
   FP_OFF (lpReturnDos) = outregs.x.bx;

   for(i=0; i < 10; i++)  /* copy the memmoy content */
      rgchMemBuf[i] = *( lpReturnDos + (i-5) );

   for(i=0; i < 10; i++)
      /*
       * Search for the string "DNP"
       */
      if (
         ('D' == toupper( rgchMemBuf[i] ) )   && 
            ('N' == toupper( rgchMemBuf[i+1] ) ) && 
            ('P' == toupper( rgchMemBuf[i+2] ) )
         )
         break;  /* found the DNP signiture */

   if (10 == i)
      return ( uResult = 0 ); /* not found */
   else
      /*
       * version number is two bytes before the DNP signiture
       */
      return ( uResult = (
                ( (unsigned)(rgchMemBuf[i-2]) << 8 ) |
                ( (unsigned)(rgchMemBuf[i-1]) )
               ) );

} /* isDecnet() */


/*******************************************************************
*
* Function Novell_Installed
*
* This function checks for the existence of a Novell Netware
* network. It returns 1 if Netware is detected, 0 if not
*
*
* Local Variables Used
* --------------------
*
* inregs, outregs : Used to read and write the general purpose
*                   registers.
*
*******************************************************************/
int Novell_Installed (void)
{
  union REGS inregs, outregs;

  inregs.x.ax = 0x7A00;
  inregs.x.bx = 0x0000;
  int86(0x2F, &inregs, &outregs);

  if (outregs.h.al == 0xFF)
      /* Novell is installed */
      return (TRUE);
  else
      /* Novell is not installed */
      return (FALSE);
}

/*******************************************************************
*
* Function AllowXLinkError
*
* This function determines whether the cross link error should be allowed or
* skipped. Because we are determining a xlink by the existance of a '.' file
* in a subdir, and some networks do not return a '.' file, we only want to
* allow the XLink error when a '.' file is returned from find first.
*
*******************************************************************/
int AllowXLinkError (void)
{
    static int fAllowXLinkError=-1;

    if (-1 != fAllowXLinkError)
       return fAllowXLinkError;

    /* if novell is installed we don't allow the xlink error */
    if (Novell_Installed() == TRUE) {
       fAllowXLinkError = FALSE;
       return fAllowXLinkError;
    }

    /* if DEC is installed we don't allow the xlink error */
    if (isDecnet() != 0) {
       fAllowXLinkError = FALSE;
       return fAllowXLinkError;
    }

    /* if we get this far, we can allow the xlink error. */
    fAllowXLinkError = TRUE;
    return fAllowXLinkError;
}

/*******************************************************************
*
* Function forfile
*
* This function enumerates a file pattern using findfirst and findnext.
* If a file is found, a user function is called with the found file.
*
* Parameters used:
*      pat:	     file pattern to search for
*      attr:	     file to search for must have this file attribute
*      rtn:	     function to call with enumerated file
*
*******************************************************************/
forfile (pat, attr, rtn, ...)
char *pat;
int attr;
void (*rtn)(char *, struct findType *, va_list);
{
    struct findType *fbuf;
    char	    *buf;
    va_list	    ap;

    if ((fbuf = (struct findType *) (*tools_alloc) (sizeof (*fbuf))) == NULL)
	return FALSE;

    if (ffirst (pat, attr, fbuf)) {
	free ((char *) fbuf);
	return FALSE;
	}

    /* Verify subdir\*.* is a valid directory. First entry from fbuf must be a
     * '.' else we fail because it is a cross link; unless we are at the root.
     * If you call ffirst(*.*), the fbuf->name must be '.' else it is the root
     * or a cross link. A check must be made that we are not at the root before
     * giving the cross link error.
     */

    /* get the file extention from path */
    fileext (pat,sz);

    /* Check if extention is '*.*'. We can only check for a valid subdir if
     * we have called ffirst(path\*.*). This puts a '.' in the fbuf->name field.
     * Caller procs like delnode, append *.* to dir paths in order to recurse.
     * This allows us to check and make sure the sub dir is valid.
     */
    if (strcmp (sz,"*.*") == 0) {
	/* create a canonical path in sz[] */
	rootpath (pat, sz);

	/* strip off '*.*' */
	sz[((strlen(sz))-3)] = '\0';

	/* see if last char is path char ; if so remove it unless x:\ */
	if (fPathChr (sz[strlen(sz)-1])) {
	    /* if not at root */
	    if (strlen(sz) > 3) {
		/* get rid of trailing path char */
		sz[strlen(sz)-1] = '\0';
	    }
	}

	/* if the path we have is a directory and it is not the root directory
	 * then fbuf->name must be '.' otherwise we have a cross link.
	 */
	if ( ( ((char) getattr (sz)) == A_D) && (strlen(sz) > 3) ) {

	    /* The file must be a '.' else it is xlinked - unless
	     * we don't allow the cross link error
	     */
	    if ((fbuf->name[0] != '.') && (AllowXLinkError() == TRUE)) {
		    printf (pszMsgRunChkDsk);
		    exit(1);
	    }
	}

    }

    if ((buf = (*tools_alloc) (MAXPATHLEN)) == NULL) {
	findclose (fbuf);
	free ((char *) fbuf);
	return FALSE;
	}

    drive (pat, buf);
    path (pat, strend (buf));
    pat = strend (buf);

    do {
	/*  Assume the case correct form has been returned by ffirst/fnext
	 */
	strcpy (pat, PFT_FOUNDNAME(fbuf));
	va_start(ap, rtn);
	(*rtn) (buf, fbuf, ap);
	va_end(ap);
    } while (!fnext (fbuf));

    findclose (fbuf);

    free (buf);
    free ((char *) fbuf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\find.c ===
/* find.c - MSDOS find first and next matching files
 *
 *	09-Dec-1986 bw	Added DOS5 support
 *	24-Feb-1987 bw	Define findclose() function.
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *	08-Dec-1988 mz	Add net enum
 */

#if defined (DOS)
#include <dos.h>

#include <string.h>
#include "..\h\tools.h"

/*  ffirst - begin find enumeration given a pattern
 *
 *  file	char pointer to name string with pattern in last component.
 *  attr	inclusive attributes for search
 *  fbuf	pointer to buffer for find stuff
 *
 *  returns	(DOS) TRUE if error, FALSE if success
 *		(OS2) error code or NO_ERROR
 */

/*  fnext - continue find enumeration
 *
 *  fbuf	pointer to find buffer
 *
 *  returns	(DOS) TRUE if error, FALSE if success
 *		(OS2) error code or NO_ERROR
 */

/*  findclose - release system resources upon find completion
 *
 *  Allows z runtime and filesystem to release resources
 *
 *  fbuf	pointer to find buffer
 */

ffirst (file, attr, fbuf)
char *file;
int attr;
struct findType *fbuf;
{
    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    struct SREGS sregs;
#endif

    /* point DTA to buffer */
    regs.h.ah = 0x1A;
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
    segread(&sregs);
    sregs.ds = FP_SEG(fbuf);
    regs.x.dx = FP_OFF(fbuf);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) fbuf;
    intdos (&regs, &regs);
#endif
    /* issue find first call */
    regs.h.ah = 0x4e;
    regs.x.cx = attr;
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
    segread(&sregs);
    sregs.ds = FP_SEG(file);
    regs.x.dx = FP_OFF(file);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) file;
    intdos (&regs, &regs);
#endif
    if (!regs.x.cflag)
	strlwr (fbuf->name);
    return regs.x.cflag;
}

fnext (fbuf)
struct findType *fbuf;
{
    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    struct SREGS sregs;
#endif

    /* point DTA to buffer */
    regs.h.ah = 0x1A;
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
    segread(&sregs);
    sregs.ds = FP_SEG(fbuf);
    regs.x.dx = FP_OFF(fbuf);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) fbuf;
    intdos (&regs, &regs);
#endif
    /* issue find next call */
    regs.h.ah = 0x4F;
#if (defined(M_I86CM) || defined(M_I86LM) || defined(M_I86HM))
    sregs.ds = FP_SEG(fbuf);
    intdosx(&regs, &regs, &sregs);
#else
    intdos (&regs, &regs);
#endif
    if (!regs.x.cflag)
	strlwr (fbuf->name);
    return regs.x.cflag;
}


void findclose (fbuf)
struct findType *fbuf;
{
}

#elif defined(OS2) || defined(NT)

#define INCL_DOSERRORS
#define INCL_DOSMODULEMGR
#if defined(OS2)
#include <os2.h>
#elif defined(NT)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif
#include "..\h\tools.h"

#include <malloc.h>
#include <string.h>
#include <stdio.h>

#if defined (OS2)
#include <netcons.h>
#include <neterr.h>
#include <server.h>
#include <shares.h>
#include <access.h>
#include <wksta.h>
#elif defined (NT)
#define _LM_
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <lmwksta.h>
#endif

#define CCHPAT	128
#if defined(OS2)
#define STATUS_OK		NO_ERROR
#define NO_MORE_FILES		ERROR_NO_MORE_FILES
typedef struct share_info_1	SHARE_INFO_1;
typedef struct server_info_0	SERVER_INFO_100;
#define SV_NAME 		sv0_name
#define CLOSEFIND		DosFindClose
#elif defined(NT)
#define SRCHATTR		(FILE_ATTRIBUTE_HIDDEN | \
				 FILE_ATTRIBUTE_SYSTEM | \
				 FILE_ATTRIBUTE_DIRECTORY)
static BOOL AttributesMatch( NPFIND fbuf );
#define CLOSEFIND		FindClose
#define SV_NAME 		sv100_name
#endif

#if defined(OS2)
HANDLE hmodOEM;
#endif
HANDLE hmodAPI;

#if defined(OS2)
USHORT (pascal FAR *pNetServerGetInfo) (const char FAR *,
					short,
					char FAR *,
					unsigned short,
					unsigned short FAR *);

USHORT (pascal FAR *pNetServerEnum) (const char FAR *,
				     short,
				     char FAR *,
				     unsigned short,
				     unsigned short FAR *,
				     unsigned short FAR *);

USHORT (pascal FAR *pNetShareEnum) (const char FAR *,
				    short,
				    char FAR *,
				    unsigned short,
				    unsigned short FAR *,
				    unsigned short FAR *);
#elif defined (NT)
NET_API_STATUS (NET_API_FUNCTION
*pNetServerEnum) (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPTSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS (NET_API_FUNCTION
*pNetServerGetInfo) (
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS (NET_API_FUNCTION
*pNetShareEnum) (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );
#endif


typedef SERVER_INFO_100 SI;
typedef struct serverbuf {
    USHORT csi; 			/* count of si's in array */
    USHORT isiLast;			/* index of last returned server */
    int    attr;			/* attribute of search */
    BYTE   szPattern[CCHPAT];		/* pattern for matching */
    SI	   asi[1];			/* array of server blocks */
    } SB;
typedef SB FAR * PSB;

typedef SHARE_INFO_1 SHI;
typedef struct sharebuf {
    USHORT cshi;			/* count of shi's in array */
    USHORT ishiLast;			/* index of last returned share */
    int    attr;			/* attribute of search */
    BYTE   szServer[CCHPAT];		/* server name */
    BYTE   szPattern[CCHPAT];		/* pattern for matching */
    SHI    ashi[1];			/* array of share blocks */
    } SHB;
typedef SHB FAR * PSHB;

static int	 usFileFindNext (struct findType *fbuf);

static int	 usSharFindFirst (char *npsz, int attr, struct findType *fbuf);
static int	 usSharFindNext (struct findType *fbuf);
static int	 usServFindFirst (char *npsz, int attr, struct findType *fbuf);
static int	 usServFindNext (struct findType *fbuf);
static int	 usLoadNet (void);

#if defined(OS2)
#define InNetServerGetInfo	    (*pNetServerGetInfo)
#define InNetServerEnum 	    (*pNetServerEnum)
#define InNetShareEnum		    (*pNetShareEnum)
#elif defined(NT)
static InNetServerGetInfo (const char *pszServer,
				short sLevel,
				char *pbBuffer,
				unsigned short cbBuffer,
				unsigned short *pcbTotalAvail);

static InNetServerEnum (const char *pszServer,
			     short sLevel,
			     char * pbBuffer,
			     unsigned short cbBuffer,
			     unsigned short *pcEntriesRead,
			     unsigned short *pcTotalAvail);

static InNetShareEnum (const char *pszServer,
			     short sLevel,
			     char * pbBuffer,
			     unsigned short cbBuffer,
			     unsigned short *pcEntriesRead,
			     unsigned short *pcTotalAvail);
#endif

/*  returns error code or NO_ERROR
 */
int ffirst (char *file, int attr, struct findType *fbuf)
{
    int erc;

    fbuf->type = FT_DONE;

    {	char *p = file;
#if !defined(NT) || defined(_LM_)
	char *p1;
#else
	UNREFERENCED_PARAMETER( attr );
#endif // !NT || _LM_

	/*  We need to handle the following cases:
	 *
	 *  [D:]\\pattern
	 *  [D:]\\machine\pattern
	 *  [D:]\\machine\share\pattern
	 *  [D:]path\pattern
	 */

	/*  skip drive
	 */
	if (p[0] != 0 && p[1] == ':')
	    p += 2;

#if !defined(NT) || defined(_LM_)
	/*  If UNC present
	 */

	if (fPathChr (p[0]) && fPathChr (p[1]))
	    /*	If not fully specified then set up server enumerate
	     */
	    if (*(p1 = strbscan (p + 2, "/\\")) == 0) {
		erc = usLoadNet ();
		if (erc == 0)
		    erc = usServFindFirst (p, attr, fbuf);
		goto casefix;
		}
	    else {
		p1 = strbskip (p1, "/\\");
		if (*strbscan (p1, "/\\") == 0) {
		    erc = usLoadNet ();
		    if (erc == 0)
			erc = usSharFindFirst (p, attr, fbuf);
		    goto casefix;
		    }
		}
#endif // !NT || _LM_
    }

    fbuf->type = FT_FILE;
#if defined(OS2)
    {	unsigned SearchCount = 1;

	fbuf->type = FT_FILE;
	fbuf->dir_handle = 0xFFFF;		 /*  Give me a directory handle */

	erc =  DosFindFirst
		(   file ,			    /*		File path name */
		    (PHDIR)&fbuf->dir_handle,	    /* Directory search handle */
		    attr & A_ALL & ~A_V ,	    /*	      Search attribute */
		    (PFILEFINDBUF)&fbuf->create_date,
						    /*		 Result buffer */
		    sizeof(*fbuf) - sizeof(fbuf->dir_handle) ,
						    /*	  Result buffer length */
		    (PUSHORT)&SearchCount,	    /*	  # of entries to find */
		    0L				    /* Reserved (must be zero) */
		);
    }
#elif defined(NT)
    {
        fbuf->attr = attr;
        erc = ( ( fbuf->dir_handle = FindFirstFile( file, &( fbuf->fbuf ) ) ) == (HANDLE)-1 ) ? 1 : 0;
	if ( (!erc) && !AttributesMatch( fbuf ) ) {
            erc = fnext( fbuf );
        }
    }
#endif

casefix:
    if (
#if defined(OS2)
	erc == NO_ERROR
#elif defined(NT)
	fbuf->dir_handle != (HANDLE)-1
#endif
    )
	if (!IsMixedCaseSupported (file))
	    strlwr (PFT_FOUNDNAME(fbuf));
	else
	    SETFLAG (fbuf->type, FT_MIX);

    return erc;
}

fnext (struct findType *fbuf)
{
    int erc;

    switch (fbuf->type & FT_MASK ) {
    case FT_FILE:
	erc = usFileFindNext (fbuf);
	break;
#if !defined(NT) || defined(_LM_)
    case FT_SERV:
	erc = usServFindNext (fbuf);
	break;
    case FT_SHAR:
	erc = usSharFindNext (fbuf);
	break;
#endif // !NT || _LM_
    default:
	erc = ERROR_NO_MORE_FILES;
	}

    if (erc == NO_ERROR && !TESTFLAG (fbuf->type, FT_MIX))
	strlwr (PFT_FOUNDNAME(fbuf));
    return erc;
}

void findclose (struct findType *fbuf)
{
    switch (fbuf->type & FT_MASK ) {
    case FT_FILE:
	CLOSEFIND (fbuf->dir_handle);
	break;
#if !defined(NT) || defined(_LM_)
    case FT_SERV:
    case FT_SHAR:
#if defined(OS2)
	DosFreeSeg ((SEL) fbuf->dir_handle);
#else
	free( (void *)fbuf->dir_handle );
#endif
	break;
#endif // !NT || _LM_
	}
    fbuf->type = FT_DONE;
}

#if defined(NT)

static BOOL AttributesMatch( NPFIND fbuf )
{
    //
    //	We emulate the OS/2 behaviour of attribute matching. The semantics
    //	are evil, so I provide no explanation.
    //
    fbuf->fbuf.dwFileAttributes &= (0x000000FF & ~(FILE_ATTRIBUTE_NORMAL));

    if (! ((fbuf->fbuf.dwFileAttributes & SRCHATTR) & ~(fbuf->attr))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#endif	//NT


/*  Find next routines
 */



static int
usFileFindNext (struct findType *fbuf)
{
#if defined(OS2)

    unsigned SearchCount = 1;

    return DosFindNext (fbuf->dir_handle,
			(PFILEFINDBUF)&fbuf->create_date,
			sizeof(*fbuf) - sizeof(fbuf->dir_handle),
			(PUSHORT)&SearchCount);

#elif defined(NT)

    while ( TRUE ) {
	if ( !FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) )
	    return GetLastError();
	else if ( AttributesMatch( fbuf ) )
	    return NO_ERROR;
	}
    // return( FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) );

#endif
}

#if !defined(NT) || defined(_LM_)

static int
usServFindNext (struct findType *fbuf)
{
    BYTE szPattern[CCHPAT];
    PSB psb;
    SI si;
    USHORT isiNext;

#if defined(OS2)
    SELECTOROF (psb) = fbuf->dir_handle;
    OFFSETOF (psb) = 0;
#elif defined(NT)
    // Retrive the psb stored in fbuf->dir_handle
    psb = (PSB)fbuf->dir_handle;
#endif

    Move (psb->szPattern, szPattern, CCHPAT);
    for (isiNext = (USHORT)(psb->isiLast + 1); isiNext < psb->csi; isiNext++) {
	si = psb->asi[isiNext];
	if (TESTFLAG (psb->attr, A_D) && fMatch (szPattern, si.SV_NAME)) {
	    psb->isiLast = isiNext;
#if defined(OS2)
	    fbuf->create_date = fbuf->create_time = 0;
	    fbuf->access_date = fbuf->access_time = 0;
	    fbuf->date = fbuf->time = 0;
	    fbuf->length = fbuf->alloc = 0;
	    fbuf->attr = A_D;
	    strcpy (fbuf->name, si.SV_NAME);
	    fbuf->nam_len = (unsigned char) strlen (fbuf->name);
#elif defined(NT)
	    fbuf->fbuf.ftCreationTime.dwLowDateTime = 0;
	    fbuf->fbuf.ftCreationTime.dwHighDateTime = 0;
	    fbuf->fbuf.ftLastAccessTime.dwLowDateTime = 0;
	    fbuf->fbuf.ftLastAccessTime.dwHighDateTime = 0;
	    fbuf->fbuf.ftLastWriteTime.dwHighDateTime = 0;
	    fbuf->fbuf.ftLastWriteTime.dwLowDateTime = 0;
	    fbuf->fbuf.nFileSizeLow = 0;
	    fbuf->fbuf.nFileSizeHigh = 0;
	    fbuf->attr = A_D;
	    fbuf->fbuf.dwFileAttributes = A_D;
	    strcpy (fbuf->fbuf.cFileName, si.SV_NAME);
#endif
	    return NO_ERROR;
	    }
	}
    return ERROR_NO_MORE_FILES;
}

/***	usServFindFirst - set up findbuf to do enumeration on server
 */
static int
usServFindFirst (char *npsz, int attr, struct findType *fbuf)
{
    PSB     psb;
    int     erc;
    USHORT  read, total;
    char    *npszServ = NULL;

    /*	If there is no meta matching, just see if server exists
     */
    if (*strbscan (npsz, "?*") == 0) {
	npszServ = npsz;

#if defined(OS2)
	erc = DosAllocSeg (sizeof(SB),
			   (PSEL) & fbuf->dir_handle,
			   0x0000);
	if (erc != 0)
	    return erc;

	SELECTOROF (psb) = fbuf->dir_handle;
	OFFSETOF (psb) = 0;
#elif defined(NT)
    if( ( psb = (PSB)malloc( sizeof(SB) ) ) == NULL )
	return ERROR_NOT_ENOUGH_MEMORY;
#endif
	/* Get array of server info
	 */
	erc = InNetServerGetInfo   (npszServ,
				    0,
				    (PBYTE) psb->asi,
				    sizeof(SI),
				    &total);

	psb->csi = 1;
	psb->isiLast = -1;
	}

    /*	Get list of known servers
    */
    else {
	/*  Adjust pattern
	 */
	if (!strcmp (npsz + 2, "*.*") || !strcmp (npsz + 2, "*."))
	    strcpy (npsz + 2, "*");

	/* Find number of servers
	 */
	erc = InNetServerEnum (npszServ,
				 0,
				 NULL,
				 0,
				 &read,
				 &total);

	if (erc != ERROR_MORE_DATA || total == 0)
	    if (erc != 0)
		return erc;
	    else
		return ERROR_NO_MORE_FILES;

	/* The LANMAN API's are useless in that it is difficult to get an accurate
	 * count of bytes necessary to store a particular enumeration.	As a
	 * result, we allocate a max-sized segment and waste space
	 */
#if defined(OS2)
	erc = DosAllocSeg (0xFFFF,
			   (PSEL) & fbuf->dir_handle,
			   0x0000);
	if (erc != 0)
	    return erc;

	SELECTOROF (psb) = fbuf->dir_handle;
	OFFSETOF (psb) = 0;
#elif defined(NT)
    if( ( psb = (PSB)malloc( 0xFFFF ) ) == NULL )
	return ERROR_NOT_ENOUGH_MEMORY;
#endif

	/*  Get array of server info
	 */
	erc = InNetServerEnum (npszServ,
				 0,
				 (PBYTE) psb->asi,
				 0xFFFF - sizeof (SB),
				 &read,
				 &total);

	psb->csi = read;
	psb->isiLast = -1;
	}

    /*	Fill in search attributes
     */
    psb->attr = attr;
    Fill (psb->szPattern, 0, CCHPAT);
    Move (npsz + 2, psb->szPattern, min (CCHPAT-1, strlen (npsz + 2)));
    fbuf->type = FT_SERV;

    /*	Find/return first matching
     */
    if (fnext (fbuf)) {
	Fill ((char far *) fbuf, 0, sizeof (*fbuf));
#if defined(OS2)
	DosFreeSeg (SELECTOROF (psb));
#elif defined(NT)
	free (psb);
#endif
	return ERROR_NO_MORE_FILES;
	}
    return NO_ERROR;
}

/***	usSharFindFirst - begin enumeration of share set
 *
 *	npsz	pointer to pattern of the form \\machine\pattern
 *	attr	attribute allowing search
 *	fbuf	buffer for find poop
 */
static int
usSharFindFirst (char *npsz, int attr, struct findType *fbuf)
{
    char    *npszPat = strbscan (npsz + 2, "\\/");
    char    *npsz1 = npszPat;
    BYTE    c = *npszPat;
    PSHB    pshb;
    int     erc;
    USHORT  read, total;

    *npszPat++ = 0;

    /*	npszPat now points to pattern portion
     *	Adjust pattern
     */
    if (!strcmp (npszPat, "*.*") || !strcmp (npszPat, "*."))
	npszPat = "*";

    /*	Find number of shares
     */
    erc = InNetShareEnum (npsz,
			    0,
			    NULL,
			    0,
			    &read,
			    &total);

    if (erc != ERROR_MORE_DATA || total == 0) {
	*npsz1 = c;
	if (erc != 0)
	    return erc;
	else
	    return ERROR_NO_MORE_FILES;
	}

    /*	Allocate segment for share data
     */
#if defined (OS2)
    erc = DosAllocSeg (0xFFFF,
		       (PSEL) & fbuf->dir_handle,
		       0x0000);
    if (erc != 0) {
	*npsz1 = c;
	return erc;
	}

    SELECTOROF (pshb) = fbuf->dir_handle;
    OFFSETOF (pshb) = 0;
#elif defined(NT)
    if( ( pshb = malloc( 0xFFFF ) ) == NULL ) {
	*npsz1 = c;
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Store the pointer to the memory block so it may be used again for the
    // next file - cast it to a unsigned and store it in fbuf->dir_handle.
    // When retrieved, cast it back to a pointer.

    fbuf->dir_handle = ( void * )pshb;
#endif

    /*	Get array of server info
     */
    erc = InNetShareEnum (npsz,
			    1,
			    (PBYTE) pshb->ashi,
			    0xFFFF - sizeof (SHB),
			    &read,
			    &total);

    pshb->cshi = read;
    pshb->ishiLast = -1;
    pshb->attr = attr;
    Fill (pshb->szPattern, 0, CCHPAT);
    Fill (pshb->szServer,  0, CCHPAT);
    Move (npszPat, pshb->szPattern, min (CCHPAT-1, strlen (npszPat)));
    Move (npsz,    pshb->szServer,  min (CCHPAT-1, strlen (npsz)));
    *npsz1 = c;
    fbuf->type = FT_SHAR;

    /*	Find/return first matching
     */
    if (fnext (fbuf)) {
	Fill ((char far *) fbuf, 0, sizeof (*fbuf));
#if defined(OS2)
	DosFreeSeg (SELECTOROF (pshb));
#elif defined(NT)
	free( pshb );
#endif
	return ERROR_NO_MORE_FILES;
	}
    return NO_ERROR;
}

static int
usSharFindNext (struct findType *fbuf)
{
    BYTE szPattern[CCHPAT];
    PSHB pshb;
    SHI shi;
    USHORT ishiNext;

    // Retrive the psb stored in fbuf->dir_handle
#if defined (OS2)
    SELECTOROF (pshb) = fbuf->dir_handle;
    OFFSETOF (pshb) = 0;
#elif defined (NT)
    pshb = (PSHB)fbuf->dir_handle;
#endif

    Move (pshb->szPattern, szPattern, CCHPAT);
    for (ishiNext = (USHORT)(pshb->ishiLast + 1); ishiNext < pshb->cshi; ishiNext++) {
	shi = pshb->ashi[ishiNext];
	if (shi.shi1_netname[strlen (shi.shi1_netname) - 1] != '$' &&
	    fMatch (szPattern, shi.shi1_netname)) {

	    if (shi.shi1_type != STYPE_DISKTREE || TESTFLAG (pshb->attr, A_D)) {
		pshb->ishiLast = ishiNext;
#if defined(OS2)
		fbuf->create_date = fbuf->create_time = 0;
		fbuf->access_date = fbuf->access_time = 0;
		fbuf->date = fbuf->time = 0;
		fbuf->length = fbuf->alloc = 0;
		fbuf->attr = shi.shi1_type == STYPE_DISKTREE ? A_D : 0;
		strcpy (fbuf->name, shi.shi1_netname);
		fbuf->nam_len = (UCHAR) strlen (fbuf->name);
#elif defined(NT)
		fbuf->fbuf.ftCreationTime.dwLowDateTime = 0;
		fbuf->fbuf.ftCreationTime.dwHighDateTime = 0;
		fbuf->fbuf.ftLastAccessTime.dwLowDateTime = 0;
		fbuf->fbuf.ftLastAccessTime.dwHighDateTime = 0;
		fbuf->fbuf.ftLastWriteTime.dwHighDateTime = 0;
		fbuf->fbuf.ftLastWriteTime.dwLowDateTime = 0;
		fbuf->fbuf.nFileSizeLow = 0;
		fbuf->fbuf.nFileSizeHigh = 0;
		fbuf->fbuf.dwFileAttributes =
		  fbuf->attr = shi.shi1_type == STYPE_DISKTREE ? A_D : 0;
		strcpy (fbuf->fbuf.cFileName, shi.shi1_netname);
#endif
		return NO_ERROR;
		}
	    }
	}
    return ERROR_NO_MORE_FILES;
}


static int
usLoadNet ()
{
#if defined(OS2)
    int erc;
#endif

    if (hmodAPI != 0)
	return NO_ERROR;

#if defined(OS2)
    if ((erc = DosLoadModule (NULL, 0, "netoem", &hmodOEM)) != 0)
	return erc;
    if ((erc = DosGetProcAddr (hmodOEM, "NETSERVERENUM", (PFN far *)&pNetServerEnum)) != 0)
	return erc;
    if ((erc = DosLoadModule (NULL, 0, "netapi", &hmodAPI)) != 0)
	return erc;
    if ((erc = DosGetProcAddr (hmodAPI, "NETSERVERGETINFO", (PFN far *)&pNetServerGetInfo)) != 0)
	return erc;
    return DosGetProcAddr (hmodAPI, "NETSHAREENUM", (PFN far *)&pNetShareEnum);
#elif defined(NT)
    if( !( hmodAPI = LoadLibrary( "netapi32" ) )			  ||
#pragma message ("Known different function parameter lists")
	!( pNetServerEnum = GetProcAddress( hmodAPI, "NETSERVERENUM" ) ) ||
#pragma message ("Known different function parameter lists")
	!( pNetShareEnum = GetProcAddress( hmodAPI, "NETSHAREENUM" ) )	||
#pragma message ("Known different function parameter lists")
	!( pNetServerGetInfo = GetProcAddress( hmodAPI, "NETSERVERGETINFO" ) ) )
        return( GetLastError() );
    else
	return( 0 );
#endif
}

#endif // !NT || _LM_

#if defined(NT)
static InNetServerGetInfo (const char *pszServer,
					short sLevel,
					char *pbBuffer,
					unsigned short cbBuffer,
					unsigned short *pcbTotalAvail)
{
int		status;
LPBYTE		bufGiven;

status = (*pNetServerGetInfo) (
IN	(LPTSTR)	pszServer,
IN	(DWORD)		sLevel,
OUT	(LPBYTE *)	&bufGiven
    );
memmove(pbBuffer, bufGiven, cbBuffer);
free(bufGiven);
*pcbTotalAvail = 0;	//Return isn't used here
return status;
}

static InNetServerEnum (const char *pszServer,
				     short sLevel,
				     char * pbBuffer,
				     unsigned short cbBuffer,
				     unsigned short *pcEntriesRead,
				     unsigned short *pcTotalAvail)
{
DWORD		entriesread, totalentries;
LPBYTE		bufGiven;
int		status;

status = (*pNetServerEnum) (
IN	(LPTSTR)	pszServer,
IN	(DWORD)		sLevel,
OUT	(LPBYTE *)	&bufGiven,
IN	(DWORD)		cbBuffer,
OUT	(LPDWORD)	&entriesread,
OUT	(LPDWORD)	&totalentries,
IN	(DWORD)		SV_TYPE_ALL,
IN	(LPTSTR)	NULL,
IN OUT	(LPDWORD)	NULL
    );
memmove(pbBuffer, bufGiven, cbBuffer);
free(bufGiven);
*pcEntriesRead = (USHORT) entriesread;
*pcTotalAvail = (USHORT) totalentries;
return status;
}

static InNetShareEnum (const char *pszServer,
				     short sLevel,
				     char * pbBuffer,
				     unsigned short cbBuffer,
				     unsigned short *pcEntriesRead,
				     unsigned short *pcTotalAvail)
{
DWORD		entriesread, totalentries;
static DWORD	resume_handle = 0;
LPBYTE		bufGiven;
int		status;

status = (*pNetShareEnum) (
IN	(LPTSTR)	pszServer,
IN	(DWORD)		sLevel,
OUT	(LPBYTE *)	&bufGiven,
IN	(DWORD)		cbBuffer,
OUT	(LPDWORD)	&entriesread,
OUT	(LPDWORD)	&totalentries,
IN OUT	(LPDWORD)	resume_handle
    );
memmove(pbBuffer, bufGiven, cbBuffer);
free(bufGiven);
*pcEntriesRead = (USHORT) entriesread;
*pcTotalAvail = (USHORT) totalentries;
return status;
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\freespac.c ===
/* return amount of freespace on a drive
 *
 *  09-Dec-1986 bw - Added DOS 5 support
 *
*/

#if defined(OS2)
#include <os2.h>
#else
#include <dos.h>
#endif

#include "..\h\tools.h"

long freespac (d)
int d;
{
#if defined(NT)

    char root[] = "a:\\";

    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    // Constuct a drive string from the given drive number.
    root[0] = (char)( 'a' + d - 1 );

    return (!GetDiskFreeSpace(root, &cSecsPerClus, &cBytesPerSec,
      &cFreeClus, &cTotalClus)) ?
	-1L :
	cBytesPerSec * cSecsPerClus * cFreeClus;

#elif defined(OS2)

    FSALLOCATE FS;

    if ( DosQFSInfo ( d, 1, (char far *)&FS, sizeof FS ) )
    {
	return -1L;
    }

    return FS.cbSector * FS.cSectorUnit * FS.cUnitAvail;

#elif defined(DOS)

    union REGS regs;

    regs.h.ah = 0x36;
    regs.h.dl = (unsigned char) d;
    intdos (&regs, &regs);
    if (regs.x.cflag)
	return -1L;
    return (long)regs.x.ax * (long)regs.x.bx * (long)regs.x.cx;

#endif
}

long sizeround (l, d)
long l;
int d;
{
#if defined(NT)

    char root[] = "a:\\";
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    ULONG BytesPerCluster;

    root[0] = (char)( 'a' + d - 1 );

    if( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        return -1L;
    }

    BytesPerCluster = cSecsPerClus * cBytesPerSec;
    l += BytesPerCluster - 1;
    l /= BytesPerCluster;
    l *= BytesPerCluster;

    return l;


#elif defined(OS2)

    FSALLOCATE FS;
    unsigned long BytesPerCluster;

    if ( DosQFSInfo( d, 1, (char far *)&FS, sizeof FS ) )
    {
	return -1L;
    }

    BytesPerCluster = FS.cbSector * FS.cSectorUnit;
    l += BytesPerCluster - 1;
    l /= BytesPerCluster;
    l *= BytesPerCluster;

    return l;

#elif defined(DOS)

    union REGS regs;

    regs.h.ah = 0x36;
    regs.h.dl = (unsigned char) d;
    intdos (&regs, &regs);
    if (regs.x.cflag == -1)
	return -1L;
    l += regs.x.ax * regs.x.cx - 1;
    l /= regs.x.ax * regs.x.cx;
    l *= regs.x.ax * regs.x.cx;

    return l;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\fmove.c ===
/* fmove.c - fast copy between two file specs
 *
 *   5/10/86  daniel lipkie     Added frenameNO.  fmove uses frenameNO
 */

#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <dos.h>
#include "..\h\tools.h"
#include <errno.h>

#include "messages.msg"     // Localizable strings

// extern int errno;

#define IBUF    10240

/* frenameNO (newname, oldname) renames a file from the oldname to the
 * newname.  This interface parallels the C rename function in the
 * pre version 4.0 of C.  The rename function changed the order of the
 * params with version 4.0.  This interface isolates the change.
 * pre-4.0: rename (newname, oldname)
 * 4.0:     rename (oldname, newname);
 */
int frenameNO(strNew, strOld)
char *strNew, *strOld;
{
    rename(strOld, strNew);  /* assumes we are compiling with 4.0 lib */
    return(0);
}

/* fmove (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fmove (src,dst)
char *src, *dst;
{
    char *result;

    /*	Try a simple rename first
     */
    if (rename (src, dst) == 0)
	return NULL;

    /*	Try to fdelete the destination
     */
    if (fdelete (dst) > 2)
        // "Unable to delete destination";
        return szErrUnableToDelete;

    /*	Destination is gone.  See if we can simply rename again
     */
    if (rename (src, dst) == -1) {

	/* Since networks don't imitate DOS error code behavior exactly,
	 * we will assume we have failed because of a external device move.
	 * The fcopy() routine will return the correct errors of access violation
	 * or invalide filaname or directory name.
	 */

	 /*  Try a copy across devices
	  */
	    if ((result = fcopy (src, dst)) != NULL) {
		unlink(dst);
		return result;
	    }

	/*  Cross-device copy worked.  Must delete source
	 */

        /* Mark file *not* read-only, so we can delete it */
	setattr (src, A_NO);

	fdelete (src);
        }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\getattr.c ===
/* getattr - return attribute for a directory entry
 *
 *	09-Dec-1986 bw	Added DOS 5 support
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *
*/

#if defined(OS2)
#include <os2.h>
#include <string.h>
#else
#include <dos.h>
#endif

#include "..\h\tools.h"

int getattr (pname)
char *pname;
{
#if defined(NT) || defined(OS2)
    {	int CurAttr;

#if defined(NT)
	if ((CurAttr = GetFileAttributes(pname)) != -1)
#elif defined(OS2)
	if (DosQFileMode ((char far *)pname, (PUSHORT)&CurAttr , 0L) == 0)
#endif
	    return CurAttr;
    }

    if (*strbscan (pname, "?*") != 0)
	return -1;

    {	FIND fnd;

	if (!ffirst (pname, A_ALL, &fnd)) {
	    findclose (&fnd);
	    return fnd.attr;
	    }
    }

    if (strlen (pname) == 2 && fPathChr (pname[0]) && fPathChr (pname[1]))
	return A_D;

    return -1;
#elif defined(DOS)
    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    struct SREGS sregs;
#endif

    // Get File Attributes. ds:dx are correctly loaded depending
    // upon the memory model.

    regs.x.ax = 0x4300;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    segread( &sregs);
    sregs.ds = FP_SEG(pname);
    regs.x.dx = FP_OFF(pname);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) pname;
    intdos (&regs, &regs);
#endif
    return regs.x.cflag ? -1 : regs.x.cx;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\ftw.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>
#include "..\h\dirent.h"
#include "..\h\ftw.h"

struct odl
	{
	DIR *pd;
	struct odl *podlNext;
	char szFileCur[_MAX_FNAME + _MAX_EXT];
	};

static int ftwRecurse(char [], int (*)(char *, struct stat *, int), int, struct stat *, struct odl *);
static DIR *SearchDir(char [], char *);
static int CloseTop(struct odl *);
static int DoDir(char [], int (*)(char *, struct stat *, int), int, struct stat *, struct odl *);

int ftw(
char *path,
int (*fn)(char *, struct stat *, int),
int depth)
	{
	char szPath[_MAX_PATH];
	struct stat st;

	if ((NULL == path) || (NULL == fn) || (strlen(path) <= 0))
		{
		errno = EINVAL;
		return -1;
		}
	else
		{
		strcpy(szPath, path);
		return ftwRecurse(szPath, fn, max(depth, 1), &st, NULL);
		}
	}

static int ftwRecurse(
char szPath[_MAX_PATH],
int (*fn)(char *, struct stat *, int),
int depth,
struct stat *pst,
struct odl *podl)
	{
	struct odl odl;
	int rc = 0;

	assert((NULL != szPath) && (strlen(szPath) < _MAX_PATH));
	assert(depth >= 0);
	assert(NULL != pst);

	errno = 0;
	if (stat(szPath, pst))
		return (*fn)(szPath, pst, FTW_NS);
	else if ((pst->st_mode & S_IFDIR) != S_IFDIR)
		return (*fn)(szPath, pst, FTW_F);
	else if ((1 > depth) && (++depth, (rc = CloseTop(podl))))
		return rc;
	else if (NULL == (odl.pd = opendir(szPath)))
		return (*fn)(szPath, pst, FTW_DNR);
	else if (rc = (*fn)(szPath, pst, FTW_D))
		{
		closedir(odl.pd);
		return rc;
		}
	else
		{
		if ((NULL == podl) || (NULL == podl->pd))
			odl.podlNext = NULL;
		else
			odl.podlNext = podl;
		return DoDir(szPath, fn, depth, pst, &odl);
		}
	}

static int DoDir(
char szPath[_MAX_PATH],
int (*fn)(char *, struct stat *, int),
int depth,
struct stat *pst,
struct odl *podl)
	{
	int rc;
	struct dirent *pde;
	char *szFile = szPath + strlen(szPath);

	assert((NULL != szPath) && (strlen(szPath) < _MAX_PATH));
	assert(depth >= 0);
	assert(NULL != pst);
	assert(NULL != podl);
	
	if (('/' != *(szFile - 1)) && ('\\' != *(szFile - 1)))
		{
		*szFile = '\\';
		*++szFile = '\0';
		}
	for (rc = 0; (NULL != (pde = readdir(podl->pd))) && (0 == rc);)
		{
		if (!strcmp(pde->d_name, ".") ||
		    !strcmp(pde->d_name, ".."))
			continue;
		else
			strcpy(podl->szFileCur, strcpy(szFile, pde->d_name));

		if (rc = ftwRecurse(szPath, fn, depth - 1, pst, podl))
			;
		else if ((NULL == podl->pd) && ((*szFile = '\0'),
			 (NULL == (podl->pd =
				SearchDir(szPath, podl->szFileCur)))))
			rc = -1;
		else
			errno = 0;
		}
	if ((NULL != podl->pd) && closedir(podl->pd) && (0 == rc))
		rc = -1;
	return rc;
	}


static DIR *SearchDir(
char szPath[_MAX_PATH],
char *szFile)
	{
	register struct dirent *pde;
	register DIR *pd;

	assert((NULL != szPath) && (strlen(szPath) < _MAX_PATH));
	assert((NULL != szFile) && (strlen(szFile) > 0));

	errno = 0;
	if (NULL == (pd = opendir(szPath)))
		{
		return NULL;
		}
	while (NULL != (pde = readdir(pd)))
		if (!strcmp(pde->d_name, szFile))
			return pd;
	if (0 == errno)
		errno = ENOENT;	// Can't find file
	closedir(pd);		// Don't care if we fail, might change errno
	return NULL;
	}

static int CloseTop(register struct odl *podl)
	{
	register struct odl *podlPrev = podl;

	while (NULL != podl)
		{
		if (NULL == podl->podlNext)
			{
			int rc = closedir(podl->pd);
			podl->pd = NULL;
			podlPrev->podlNext = NULL;
			return rc;
			}
		else
			{
			podlPrev = podl;
			podl = podl->podlNext;
			}
		}
	return -1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\int.asm ===
;
; Perform MSDOS absolute disk read/write
;
;   09-Dec-1986 bw  Added DOS 5 switch
;   30-Oct-1987 bw  Changed 'DOS5' to 'OS2'

ifdef OS2
    if2
    %out int25() and int26() are not implemented under OS/2 Protect Mode.
    .ERR
    endif
else

.xlist
include ..\h\cmacros.inc
.list

sBegin	data
assumes ds,data

externW _doserrno

sEnd

sBegin	code
assumes cs,code

cProc	int25,<PUBLIC>,<SI,DI>
parmB	drive
parmD	dst
parmW	count
parmW	sector
cBegin
	push	ds
	mov	al,drive
	lds	bx,dst
	mov	cx,count
	mov	dx,sector
	push	bp
	int	25h
	pop	bx			; INT 25 leaves flags on stack
	pop	bp
	pop	ds
	jc	err25
	xor	ax,ax
	mov	_doserrno,ax
	jmp	short end25
err25:
	mov	_doserrno,ax
	mov	ax,-1
end25:
cEnd

cProc	int26,<PUBLIC>,<si,di>
parmB	drive
parmD	src
parmW	count
parmW	sector
cBegin
	push	ds
	mov	al,drive
	lds	bx,src
	mov	cx,count
	mov	dx,sector
	push	bp
	int	26h			; INT 25 leaves flags on stack
	pop	bx
	pop	bp
	pop	ds
	jc	err26
	xor	ax,ax
	mov	_doserrno,ax
	jmp	short end26
err26:
	mov	_doserrno,ax
	mov	ax,-1
end26:
cEnd

sEnd

endif

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\mapenv.c ===
/* snoop through the environment for a name and return the value end of things
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 */

#include <stdlib.h>
#include "..\h\tools.h"
#include <malloc.h>
#include <string.h>

/* Map will scan a buffer for $(name) and attempt to replace it with
 * text from the environment
 */
void mapenv (char *src, char *dst)
{
    char *buf, *env;
    char *p, *p1, *p2, *p3;

    if ((buf = (*tools_alloc) (MAXLINELEN)) != NULL) {
	if ((env = (*tools_alloc) (MAXLINELEN)) != NULL) {
	    p = src;
	    p1 = buf;
	    while (*p != 0) {
		if (strpre ("$(", p) && ((p2 = strchr (p+2, ')')) != NULL)) {
		    Move ((char far *)(p+2), (char far *)env, p2-(p+2));
		    env[p2-(p+2)] = '\0';
		    strupr (env);
		    if ((p3 = getenv (env)) != NULL) {
			strcpy (p1, p3);
			p1 += strlen (p3);
			p = p2+1;
			continue;
			}
		    }
		*p1++ = *p++;
		}
	    *p1++ = '\0';
	    strcpy (dst, buf);
	    free (env);
	    }
	free (buf);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\init.c ===
/*  init.c - routines for managing TOOLS.INI-like files
 *
 *  Modifications
 *	15-Jul-87   danl    Start of section is <optionalwhitespace>[...]
 *	05-Aug-1988 mz	    Use buffer equate for swgoto.
 *	05-Jul-1989 bw	    Use MAXPATHLEN
 *
 */

#include <string.h>
#include <limits.h>
#include "..\h\tools.h"
#include "..\h\strpfx.h"

#define BUFLEN 256

static flagType fMatchMark (char *, char *);
static char *space = "\t ";

/*  fMatchMark - see if a tag in in a mark set
 *
 *  We treat the mark set as a collection of whitespace-separated names
 *
 *  pMark	pointer to mark set (contents modified)
 *  pTag	tag to find
 *
 *  returns	TRUE if match was found
 */
static flagType fMatchMark (pMark, pTag)
char *pMark, *pTag;
{
    char *p, c;

    while (*pMark != 0) {
	pMark = strbscan (p = strbskip (pMark, space), space);
	c = *pMark;
	*pMark = 0;
	if (!stricmp (p, pTag))
	    return TRUE;
	*pMark = c;
	}
    return FALSE;
}


/* returns pointer to tag if line is marker; NULL otherwise */
char *ismark (buf)
register char *buf;
{
    register char *p;

    buf = strbskip (buf, space);
    if (*buf++ == '[')
	if (*(p = strchr (buf, ']')) != '\0') {
            *p = 0;
            return buf;
            }
    return NULL;
}

flagType swgoto (fh, tag)
FILE *fh;
char *tag;
{
    char buf[BUFLEN];

    if (fh) {
	while (fgetl (buf, BUFLEN, fh)) {
            register char *p;

            if ((p = ismark (buf)) != NULL) {
		if (fMatchMark (p, tag))
                    return TRUE;
                }
            }
        }
    return FALSE;
}

/* returns fh of file if tag found, else NULL */
FILE *swopen (file, tag)
char *file, *tag;
{
    FILE *fh;
    char buf[MAXPATHLEN];

    if ((fh = pathopen (file, buf, "rb")) == NULL)
        return NULL;

    if (swgoto (fh, tag))
	return fh;

    fclose (fh);
    return NULL;
}

/* close a switch file */
swclose (fh)
FILE *fh;
{
    return fclose (fh);
}

/* read a switch line; return FALSE if end of file.  Skips leading spaces
 * and lines that begin with ; and blank lines
 */
int swread (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    register char *p;

    while (fgetl (buf, len, fh))
        if (ismark (buf) != NULL)
	    break;
        else {
	    p = strbskip (buf, space);
            if (*p != 0 && *p != ';') {
                strcpy (buf, p);
		return TRUE;
            }
        }
    return FALSE;
}

/* Reads lines from the file fh looking in the section pstrTag for one with
 * "entry=" and if there are non-white space characters following the '='
 * a copy of these characters is returned else NULL is returned.
 *
 * If fh == 0 then the file $INIT:\TOOLS.INI is used as the switch file
 *
 * If a non-NULL value is returned, it should eventually be free'd.
 *
 * N.B. if there are only white space characters, space and tab, following
 * the '=', NULL is returned
 *
 */
char *swfind (pstrEntry, fh, pstrTag)
char *pstrEntry;
FILE *fh;
char *pstrTag;
{
    char *p;
    char *q;
    FILE *fhIn = fh;
    char buf[BUFLEN];

    q = NULL;
    if (fh || (fh = swopen ("$INIT:\\TOOLS.INI", pstrTag))) {
	while (swread (buf, BUFLEN, fh) && !ismark(buf) ) {
	    if ((p = strchr (buf, '=')) != NULL) {
                *p++ = '\0';
		if (!strcmpis (buf, pstrEntry)) {
		    if (*(p = strbskip (p, space)))
                        q = strdup (p);
                    break;
                    }
                }
            }
        }
    if (!fhIn)
        swclose (fh);
    return q;
}

/* Returns a ptr to the separator in buf & fills in sep */
static char *FindSep(char *buf, char **seps, char **sep)
{
    char *szBrk;
    unsigned i, index, len = 0;

    index = UINT_MAX;
    *sep = NULL;

    // find longest leftmost separator from given list in buf
    while (NULL != *seps)
    {
	szBrk = strstr(buf, *seps);
	if (szBrk )
	{
	   i = szBrk - buf;
	   if (i < index || (i == index && len < strlen(*seps)))
	   {
	       index = i;
	       *sep = *seps;
	       len = strlen(*sep);
	   }
	}
	seps++;
    }

    if (*sep)
	return (buf + index);
    else
	return NULL;
}

/*
 * Parse the given buffer. Return the lhs, rhs and the actual separator.
 *
 * buf	switch line contents (!!!contents modified!!!)
 * seps null-terminated list of allowed separators
 * lhs  ptr to parameter (left-hand side value)
 * rhs  ptr to value (value to the right of the separator)
 * sep	actual separator found in buf
 *
 * Returns TRUE if successful else FALSE.
 */

int swparse(char *buf, char *seps[], char **lhs, char **rhs, char **sep)
{
    char *szBrk = NULL;

    *lhs = *rhs = *sep = NULL;
    if (NULL == buf || '\0' == *buf || (NULL != ismark(buf)))
	return FALSE;

    buf += strspn(buf, space);
    if (';' == *buf)
	return FALSE;

    // sep
    szBrk = FindSep(buf, seps, sep);

    // lhs
    *lhs = buf;

    // rhs
    if (szBrk)
    {
	// place 0 at sep 
	*szBrk = '\0';
	szBrk += strspn(szBrk += strlen(*sep), space);
	*rhs = szBrk;
    }

    return TRUE;
}

static flagType fMatchPat (char *pMark, char *pTag)
{
    char *p, c;

    while (*pMark != 0) {
	pMark = strbscan (p = strbskip (pMark, space), space);
	c = *pMark;
	*pMark = 0;
	if (striprefix (pTag, p))
	    return TRUE;
	*pMark = c;
	}
    return FALSE;
}

/*
 * Variation of goto where the tag is of the form <string>*
 *
 * fh  file handle
 * tag tag to match
 * 
 * Retruns ptr to match found if successful else NULL
 */

char *swmatch(FILE *fh, char *tag)
{
    char buf[BUFLEN];

    if (fh) {
	while (fgetl (buf, BUFLEN, fh)) {
            register char *p;

            if ((p = ismark (buf)) != NULL) {
		if (fMatchPat (p, tag))
                    return (strdup(p));
                }
            }
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\kbhit.asm ===
;
; kbhit () return 0 if character waiting, non-0 otherwise
;     Differs from C runtime version in that ^C is not checked for and kbhit
; returns FALSE instead of TRUE if a keystroke is waiting.
;
;   09-Dec-1986 bw  Added DOS 5 support
;   28-Aug-1987 dl  Remove getch
;   30-Oct-1987 bw  Changed 'DOS5' to 'OS2'


.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\subcalls.inc
if1
%out  ! OS2 module
endif
endif
.list

sBegin	data
assumes ds,data

staticB input,?
staticB fInput,0

ifdef  OS2
staticB Extend, 0
endif

sEnd

sBegin	code
assumes cs,code

cProc	kbhit,<PUBLIC>
ifdef OS2
localV	PeekBuff, %(size KeyData)
endif
cBegin

ifdef OS2
	mov	ax, 0
	cmp	Extend, 0   ; If last getch got byte 0 of extend char ...
	jne	Done

	push	ss
	lea	ax, PeekBuff
	push	ax
;	 mov	 ax, 1	     ; Don't wait for keystroke
;	 push	 ax
	xor	ax, ax
	push	ax	    ; KBD handle
	CALL	KBDPEEK
	cmp	PeekBuff.status, 0   ; Status non-0 means char waiting or error.
	jne	Done
	mov	ax, 1		     ; 0, so no char
Done:

else
;
; If character pre-read, then say OK.
;
	MOV	AL,fInput
	OR	AL,AL
	JNZ	Done
;
; Use call 6 to interrogate/read the input characters.
;
	mov	ah,6
	mov	dl,0FFh
	int	21h
	jz	Done		    ; convert the 0 in AL to no-char
	mov	Input,al
	mov	AL,0FFH
	mov	fInput,al
Done:
	CBW
	NOT	AX

endif

cEnd


cProc   zgetch,<PUBLIC>
ifdef OS2
localV	CharBuff, %(size KeyData)
endif
cBegin

ifdef OS2
	cmp	Extend, 0
	je	Ask
	mov	al, Extend
	mov	Extend, 0
	jmp	short gotit

Ask:
	push	ss
	lea	ax, CharBuff
	push	ax
	xor	ax, ax
	push	ax		; Wait for input
	push	ax		; KBD handle
	call	KBDCHARIN
	mov	ax, word ptr CharBuff.char_code   ; ALSO picks up scan_code
	test	al, 0FFH
	jne	gotit
	mov	Extend, ah
gotit:	xor	ah, ah

else

	cmp	fInput,0
	jz	Ask
	mov	fInput,0
	mov	al,Input
	jmp	short finish
Ask:
	MOV	AH,7
	INT	21h
finish:
	XOR	AH,AH

endif

cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\heapchk.c ===
#include <string.h>
#include "..\h\tools.h"

#define	REG	register

typedef unsigned short	word ;

union	Ptr
{
	word near *	w ;
	char near *	b ;
} ;

extern	unsigned short	_asegds ;
extern	unsigned short	_asizds ;


/*
 * int heapset ( int ) - set contents of heap free nodes
 *
 *      HEAPOK          - completed okay
 *      HEAPCANTFIND    - can't find heap
 *      HEAPBADNODE     - malformed node somewhere
 */

int     heapset ( fillbyte )
int     fillbyte;
{
REG     union   Ptr     cp ;
REG     word    size ;

        if ( ! _asegds )
            /*
            ** Not initialized yet
            */
            return ( HEAPOK );

	/*
	** Check the beginning of the heap
	** Consisting of a zero-byte unused entry and a two-byte used entry
	*/

	cp.w = (word near *) _asegds ;
	if ( * cp.w ++ != 1 || * cp.w ++ != 2 )
                return ( HEAPBADBEGIN );
	cp.b += 2 ;	/* Skip contents of dummy entry */

	/*
	** Scan through the Heap
	*/
	while ( ( size = * cp.w ++ & ~1 ) != 0xFFFE )
	{
		/*
		** Set unallocated blocks to the value "fillbyte"
		**	This call to memset() even sets the unused
		**	byte in an odd allocation, since _nmalloc()
		**	always allocates an even number of bytes.
		*/
		if ( cp.w [ -1 ] & 1 )
			memset ( cp.b , fillbyte , (size+1) & ~1 ) ;

		if ( _asizds < size || _asizds - size < (word) cp.w )
                        return ( HEAPBADNODE );
		cp.b += size ;
	}

        return ( HEAPOK );
}



/*
 * int heapchk ( void ) - does minimal consistency check on heap
 *
 *      HEAPOK          - okay
 *      HEAPBADBEGIN    - bad beginning, couldn't find initial header info
 *      HEAPBADNODE     - bad node, damaged heap
 */

int     heapchk ( )
{
REG     union   Ptr     cp ;
REG     word            size ;

        if ( ! _asegds )
            /*
            ** Not initialized yet
            */
            return ( HEAPOK );

        /*
        ** Check the beginning of the heap
        ** Consisting of a zero-byte unused entry and a two-byte used entry
        */
        cp.w = (word near *) _asegds ;
        if ( * cp.w ++ != 1 || * cp.w ++ != 2 )
                return HEAPBADBEGIN;
        cp.b += 2 ;     /* Skip contents of dummy entry */

        /*
        ** Scan through the Heap
        */
        while ( ( size = * cp.w ++ & ~1 ) != 0xFFFE )
        {
                if ( _asizds < size || _asizds - size < (word) cp.w )
                        return HEAPBADNODE;

                cp.b += size ;
        }
        return ( HEAPOK );
}


/*
 * int  heapinfo ( void ) - determines heap size and free space
 *      leaves info in lHeapSize lHeapFree
 *
 * long heapsize ( void ) - determines heap size
 *      if return >= 0 then size else error below
 *
 * long heapfree ( void ) - determines heap free
 *      if return >= 0 then size else error below
 *
 *      HEAPOK          - okay
 *      HEAPBADBEGIN    - bad beginning, couldn't find initial header info
 *      HEAPBADNODE     - bad node, damaged heap
 */

long    lHeapSize, lHeapFree;
long    lHeapLargest;

int     heapinfo ( )
{
REG	union	Ptr	cp ;
REG	word		size ;

        lHeapSize = lHeapFree = 0L;
        lHeapLargest = 0;

        if ( ! _asegds )
            /*
            ** Not initialized yet
            */
            return ( HEAPOK );

        /*
        ** Check the beginning of the heap
        ** Consisting of a zero-byte unused entry and a two-byte used entry
        */

        cp.w = (word near *) _asegds ;
        if ( * cp.w ++ != 1 || * cp.w ++ != 2 )
                return ( HEAPBADBEGIN );
        cp.b += 2 ;     /* Skip contents of dummy entry */

        /*
        ** Scan through the Heap
        */
        while ( ( size = * cp.w ++ & ~1 ) != 0xFFFE )
        {
                /*
                ** Add two for the header node
                */
                lHeapSize += size + 2;

		if ( cp.w [ -1 ] & 1 ) {
                        lHeapFree += size + 2;
		    if ( (long) size > lHeapLargest )
			lHeapLargest = (long) size;
		}

                if ( _asizds < size || _asizds - size < (word) cp.w )
                        return ( HEAPBADNODE );
                cp.b += size ;
        }

        return ( HEAPOK );
}


long    heapsize ( )
{
        int i = heapinfo ( );

        return ( ( i == HEAPOK ) ? lHeapSize : i );
}


long    heapfree ( )
{
        int i = heapinfo ( );

        return ( ( i == HEAPOK ) ? lHeapFree : i );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\heapdump.c ===
#include <ctype.h>
#include "..\h\tools.h"

#define BUFSIZE 40
#define	REG	register

typedef unsigned short	word ;

union	Ptr
{
	word near *	w ;
	char near *	b ;
} ;

extern	unsigned short	_asegds ;
extern	unsigned short	_asizds ;
extern  long            lHeapSize;

/*
**     heapdump - dump  heap info to fp
**
**     output to fp:
**         _asegds      unsigned
**         _asizds      unsigned
**         lHeapSize    long        if == -1 then heap error
**         lHeapFree    long        if lHeapSize == -1 then this is heap
**                                     error code
**         lHeapLargest long        if lHeapSize == -1 then zero
**
**     returns
**         zero    - info written to fp
**         nonzero - error writing to fp
**
**     Note: APPENDS to fp
**
**
*/
int     heapdump ( fp, iFormat )
FILE    *fp;
int     iFormat;
{
REG     union   Ptr     cp ;
        word    size;
        int     iMax;
        int     i;
        long    lSize;
        char    buf [ BUFSIZE + 1 ];
        char    *p, *q;
        char    ch;

        heapinfo ( );
        if ( lHeapSize ) {
            fprintf ( fp, "%ld %d\n", lHeapSize + 6, iFormat);
            /*
            **  skip over signature word
            */
            cp.w = (word near *) _asegds + 1;
            if ( iFormat ) {
                while ( ( size = *cp.w & ~1 ) != 0xFFFE ) {
                    fprintf ( fp, "%6u %6u%s", cp.w, *cp.w,
                      ( *cp.w & 1 ? "*  " : "   " ) );
                    p = buf;
                    q = cp.b + 2;
                    iMax = ( size < BUFSIZE ? size : BUFSIZE );
                    for ( i = 0; i < iMax; i++ )
			if ((ch = *q++) && 0x20 <= ch && ch < 0x7f) *p++ = ch ;
			else *p++ = '.' ;
                    *p = '\0';
                    fprintf ( fp, "%s\n", buf );
                    cp.b += size + 2;
                }
            }
            else {
                /*
                **  lHeapSize is the number of bytes in heap exclusive of the
                **  4 that are the initial dummy node and 2 that are the
                **  end marker.  So we add 6 to write starting with dummy
                **  node through the end marker
                */
                lSize = lHeapSize + 6;
                while ( lSize ) {
                    i = ( (long) 512 < lSize ? 512 : (int) lSize );
                    if ( fwrite ( cp.b, i, 1, fp ) != 1 )
                        return 1;
                    lSize -= i;
                    cp.b += i;
                }
                fprintf ( fp, "\n" );
            }
        }
        else
            fprintf ( fp, "0 %d\n", lHeapSize + 6, iFormat);

        fprintf ( fp, "<EndOfHeap>\n" );
        return 0;
 }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\match.c ===
#include "..\h\tools.h"
#include <ctype.h>

flagType fMatch (pat, text)
char *pat, *text;
{
    switch (*pat) {
    case '\0':
        return (flagType) (*text == '\0');
    case '?':
	return (flagType) (*text != '\0' && fMatch (pat + 1, text + 1));
    case '*':
        do {
	    if (fMatch (pat + 1, text))
                return (flagType) TRUE;
        } while (*text++);
        return FALSE;
    default:
	return (flagType) (toupper (*text) == toupper (*pat) && 
			 	fMatch (pat + 1, text + 1));
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\getl.asm ===
;
; blindingly fast assembly help for Z
;

.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\doscalls.inc
if1
%out  ! OS2 module
endif
endif
.list

sBegin  data
assumes ds,data

bufstart    dd     ?
staticW bufsrc,?
staticW buflen,?
staticW buflength,?
staticW buffh,?
globalB fGetlCR,?
bufpos      dd      ?

sEnd
sBegin code

assumes cs,code

;
; getlpos returns current seek position in file
;
cProc   getlpos,<PUBLIC>
cBegin
        mov     dx,word ptr bufpos+2
        mov     ax,word ptr bufpos
cEnd

;
; getlinit (buf, len, fh) initializes the getl routine for buffer buf and fh fh
;
cProc   getlinit,<PUBLIC>
parmD   buf
parmW   len
parmW   fh
cBegin
        mov     ax,off_buf
        mov     word ptr bufstart,ax
        mov     ax,seg_buf
        mov     word ptr bufstart+2,ax
        mov     ax,fh
        mov     buffh,ax
        mov     ax,len
        mov     buflength,ax
        mov     buflen,0
        mov     word ptr bufpos,0
        mov     word ptr bufpos+2,0
        mov     fGetlCR,0
cEnd

;
; getl (dst, len) returns TRUE if a line was read.
;
cProc   getl,<PUBLIC>,<DS,SI,DI>
parmW   dst
parmW   dstlen
ifdef OS2
localW	BytesRead
endif
cBegin
        assumes ss,data
        cld
        push    ds
        pop     es
        mov     ds,word ptr bufstart+2
        assumes ds,nothing
        mov     si,bufsrc
        mov     di,dst
        mov     cx,buflen
        mov     dx,dstlen
        dec     dx                  ; room for NUL at end
        jcxz    fill

movc:   lodsb                       ; get a byte
        cmp     al,13               ; is it special?
        jbe     spec                ; yes, go handle special case
stoc:   stosb                       ; put character in buffer
        dec     dx                  ; one less space in buffer
endl:   loopnz  movc                ; go back for more characters
        jnz     fill                ; no more characters => go fill buffer
                                    ; cx = 0, buflen = length moved
fin:    dec     cx
fin1:   xor     ax,ax
        stosb
        mov     bufsrc,si           ; length moved = buflen - cx
        xchg    buflen,cx
        sub     cx,buflen
        add     word ptr bufpos,cx
        adc     word ptr bufpos+2,0
        not     ax
        jmp     short getldone

fill:
        mov     cx, buflen          ; add length moved to bufpos
        add     word ptr bufpos,cx
        adc     word ptr bufpos+2,0
ifdef OS2
	push	buffh
	push	word ptr bufstart + 2
	push	word ptr bufstart
	push	buflength
	push	ss
	lea	ax, BytesRead
	push	ax
	call	DOSREAD
	mov	cx, BytesRead
	mov	buflen, cx
	mov	si, word ptr bufstart
	or	cx, cx
	jnz	movc
else
        push    dx
        mov     dx,word ptr bufstart
        mov     cx,buflength
        mov     bx,buffh
        mov     ah,3Fh
        int     21h
        mov     cx,ax
        mov     buflen,ax
        mov     si,dx
        pop     dx
        or      ax,ax
        jnz     movc
endif
; if we've stored chars then terminate line else return with 0
        cmp     di,dst
        jnz     fin1
        jmp     short getldone

spec:   jz      setnz
        cmp     al,10
        jz      fin
        cmp     al,9
        jnz     stoc
        push    cx
        mov     ax,di
        sub     ax,dst
        and     ax,7
        mov     cx,8
        sub     cx,ax
        cmp     cx,dx
        jbe     ok
        mov     cx,dx
ok:     sub     dx,cx
        mov     al," "
        rep     stosb
        pop     cx
        jmp     endl

setnz:	or	al,1
	mov	fGetlCR,-1		; indicate we've seen a CR
	jmp	endl

getldone:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\mgetl.c ===
/*  mgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 */

#include "..\h\tools.h"

/*
**  Copies next line from pSrc to buf
**  Removes \r and \n, expands tabs
**  If *pSrc == NULL at entry return NULL
**  else copy line to buf and return char * to next char to be processed
**  from pSrc
**
**      p = pInput;
**      while ( ( p = mgetl ( buf, len, p ) ) )
**          process content of buf
**
**  N.B. buf [ 0 ] == 0 on return does NOT mean end of source, merely that
**  a line of no char was read, e.g. ...\n\n seen in pSrc
**
*/

char *mgetl (buf, len, pSrc)
char *buf;
int len;
char *pSrc;
{
    register int c;
    register char *p;

    /* remember NUL at end */
    if ( *pSrc == '\0' ) {
        *buf = 0;
        return NULL;
    }
    len--;
    p = buf;
    while (TRUE) {
        c = *pSrc++;
        if (c == '\0' || c == '\n')
            break;
        if (c != '\r')
	    if (len == 0) {
		pSrc--;
		break;
		}
	    else
            if (c != '\t') {
                *p++ = (char) c;
                len--;
                }
            else {
                c = min (8 - ((p-buf) & 0x0007), len);
                Fill (p, ' ', c);
                p += c;
                len -= c;
                }
        }
    *p = 0;
    return ( pSrc );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\mapstr.c ===
// mapstr.c -- match abbreviated strings from list
//

#include <stdlib.h>

#include "mapstr.h"

// Find the "best" argument mapping
MapItemPtr
mapAbbrStr (
    MapAbbr szArg,
    MapItemPtr pTable,
    MapTest pTest
    )
{
    MapItemPtr pFirst = NULL;	// first partial match
    MapItemPtr pAmbig = NULL;	// ambigous partial match

    // search list for exact and partial matches
    while ( pTable->szLabel ) {
	char *pchPos = (*pTest) ( szArg, pTable->szLabel );

	// example quality of match
	if ( pchPos != NULL ) {

	    // exact matches cause an immediate return
	    if ( *pchPos == '\0' )
		return pTable;

	    // first partial match is remembered
	    if ( pFirst == NULL )
		pFirst = pTable;

	    // the last ambigous partial match is remembered
	    // can't reject immediately: exact match may be pending
	    else if ( pFirst->value != pTable->value )
		pAmbig = pTable;
	    }

	// advance for next interation
	pTable++;
	}

    // No exact match.	If no matches, table is the
    // "unknown" argument value.  If two or more partial
    // matches, ambig is set and no well defined match.
    if ( pFirst == NULL ) return pTable;
    if ( pAmbig == NULL ) return pFirst;
    return NULL;
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\maxmin.asm ===
;
; maximum and minimum routines.
;

.xlist
include ..\h\cmacros.inc
.list

sBegin	code
assumes cs,code

cProc	max,<PUBLIC>
parmW	a
parmW	b
cBegin
	mov	ax,a
	cmp	ax,b
	jg	maxdone
	mov	ax,b
maxdone:
cEnd

cProc	min,<PUBLIC>
parmW	a
parmW	b
cBegin
	mov	ax,a
	cmp	ax,b
	jl	mindone
	mov	ax,b
mindone:
cEnd

cProc	lmax,<PUBLIC>
parmD	a
parmD	b
cBegin
	mov	ax, word ptr (a)
	mov	dx, word ptr (a + 2)
	cmp	dx, word ptr (b + 2)
	jg	lmaxdone
	jl	lmaxswap
	cmp	ax, word ptr (b)
	jae	lmaxdone
lmaxswap:
	mov	ax, word ptr (b)
	mov	dx, word ptr (b + 2)
lmaxdone:
cEnd

cProc	lmin,<PUBLIC>
parmD	a
parmD	b
cBegin
	mov	ax, word ptr (a)
	mov	dx, word ptr (a + 2)
	cmp	dx, word ptr (b + 2)
	jl	lmindone
	jg	lminswap
	cmp	ax, word ptr (b)
	jbe	lmindone
lminswap:
	mov	ax, word ptr (b)
	mov	dx, word ptr (b + 2)
lmindone:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\move.asm ===
;
; memory routines
;
;   Modifications:
;
;	01-Dec-1986 mz	Optimize odd move using rcl hack
;

.xlist
include ..\h\cmacros.inc
.list

sBegin	code
assumes cs,code

cProc	Move,<PUBLIC>,<DS,SI,DI>
parmD	src
parmD	dst
parmW	count
cBegin
	mov	cx,count
	jcxz	NoByte			; No characters to move
	les	di,dst			; grab pointers
	lds	si,src
	cld
	mov	ax,ds
	cmp	ax,Seg_dst
	jnz	SimpleMove		; segments are NOT the same, no opt
	cmp	si,di			; is the start of source before dest
	jb	TestMove		; yes, try to optimize

SimpleMove:
	shr	cx,1
	rep	movsw
	rcl	cx,1
	rep	movsb
	jmp	short NoByte

TestMove:
	mov	ax,di
	sub	ax,si			; ax = difference between regions
	cmp	ax,cx			; is difference greater than region?
	jae	SimpleMove		; yes, no optimize
	mov	ax,cx			; optimize by copying down from top
	dec	ax
	add	di,ax
	add	si,ax
	std
	rep	movsb			; no word optimization here

	cld
NoByte:
cEnd

cProc	Fill,<PUBLIC>,<DI>
parmD	dst
parmB	value
parmW	count
cBegin
	cld
	les	di,dst
	mov	al,value
	mov	ah,value
	mov	cx,count
	shr	cx,1
	jcxz	fill1
	rep	stosw
fill1:
	jnc	fill2
	stosb
fill2:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\mkpath.c ===
#include <stdio.h>
#include <io.h>
#include <direct.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "..\h\tools.h"

/* strrchrs() -- find the last instance in a string of any one of
**	a set of characters.  Return a pointer into the string at
**	the matchpoint.  Analogous to strrchr() in the CRT.
*/

char *strrchrs(char *szText, char * szSSet)
	{
	register char *pchSSet;
	register char *pchEnd;

	if ((NULL == szText) || (NULL == szSSet))
		return NULL;
	for (pchEnd = szText + (strlen(szText) - 1); pchEnd >= szText; --pchEnd)
		for (pchSSet = szSSet; '\0' != *pchSSet; ++pchSSet)
			if (*pchSSet == *pchEnd)
				return pchEnd;
	return NULL;
	}

/* MkPath() -- Make any directories necessary to ensure that a
**	directory name passed in exists.  Essentially, if the
**	argument exists and is a directory, return success.  If
**	not, strip off the last path component and recurse,
**	creating the directories on returning up the stack.
*/

int MkPath(char *szPath)
	{
	char *pchSlash;
	char chSep;
	static struct stat stBuf;

	//Does it exist?
	if (!stat(szPath, &stBuf))
		if (S_IFDIR == (stBuf.st_mode & S_IFDIR))
			return 0;
		else
			return -1;
	//Can we create it?
	else if (!mkdir(szPath))
		return 0;
	// are we out of path components?
	else if (NULL == (pchSlash = strrchrs(szPath, "\\/")))
		return -1;
	// Can we make its parent directory?
	else if ((chSep = *pchSlash), (*pchSlash = '\0'), MkPath(szPath))
		{
#ifndef DEBUG
		*pchSlash = chSep;
#endif
		return -1;
		}
	// Can we make it now that we've made its parent?
	else if ((*pchSlash = chSep), ('\0' != pchSlash[1]))
		return mkdir(szPath);
	else				//don't try trailing slash
		return 0;
	}


#ifdef STANDALONE

/* Standalone testbed for MkPath() */

int main(int argc, char *argv[])
	{
	int i;
	int iRet = 0;
	int cbsz;

	for (i = 1; i <argc; ++i)
		{
		if ('\"' == *argv[i])		//strip quotes, if any
		    (argv[i])++;
		if ('\"' == argv[i][(cbsz = strlen(argv[i]) - 1)])
		    argv[i][cbsz] = '\0';
		if (MkPath(argv[i]))
			{
			fprintf(stderr,
				"%s: Cannot create %s\n", argv[0], argv[i]);
			iRet = -1;
			}
		}
	return iRet;
	}

#endif /* STANDALONE */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\msexec.c ===
/*
   EXEC.C: EXEC function with memory swap - Prepare parameters.

   Public domain software by

        Thomas Wagner
        Ferrari electronic GmbH
        Beusselstrasse 27
        D-1000 Berlin 21
        Germany
*/

//#include "compat.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <dos.h>
#include <malloc.h>
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>


#define MK_FP(seg,ofs)	((void far *)(((unsigned long)(seg) << 16) | \
			    (unsigned short)(ofs)))

#include <ctype.h>
#include <tools.h>

#define SWAP_FILENAME "$$AAAAAA.AAA" 

/* internal flags for prep_swap */

#define CREAT_TEMP      0x0080
#define DONT_SWAP_ENV   0x4000

/* local variables */

static char l_drive [_MAX_DRIVE], dir [_MAX_DIR];
static char name [_MAX_FNAME], ext [_MAX_EXT];


#ifdef __cplusplus
extern "C" int
#else
extern int _cdecl
#endif
do_spawn (int swapping,     /* swap if non-0 */
          char *xeqfn,      /* file to execute */
          char *cmdtail,    /* command tail string */
          unsigned envlen,  /* environment length */
          char *envp);      /* environment pointer */

#ifdef __cplusplus
extern "C" int
#else
extern int _cdecl
#endif
prep_swap (int method,      /* swap method */
           char *swapfn);   /* swap file name and/or path */


/* Returns TRUE if a file with name 'fn' exists. */

static int exists (char *fn)
{
   struct find_t fb;

   return !_dos_findfirst (fn, _A_RDONLY|_A_HIDDEN|_A_SYSTEM|_A_ARCH, &fb);
}


/* Try '.COM' and '.EXE' on current filename, modify filename if found. */

static int tryext (char *fn)
{
   int i;

   i = strlen (fn);
   strcat (fn, ".COM");
   if (exists (fn))
      return 1;
   fn [i] = 0;
   strcat (fn, ".EXE");
   if (exists (fn))
      return 1;
   fn [i] = 0;
   return 0;
}


/* Try to find the file 'fn' in the current path. Modifies the filename
   accordingly. */

static int findfile (char *fn)
{
   char *path, *penv;
   char *prfx;
   int found;

   if (!fn [0])
      strcpy (fn, getenv ("COMSPEC"));

   _splitpath (fn, l_drive, dir, name, ext);

   if (ext [0])
      found = exists (fn);
   else
      found = tryext (fn);

   if (!found && !dir [0] && !l_drive [0])
      {
      penv = getenv ("PATH");
      if (!penv)
         return 0;
      path = (char *)malloc (strlen (penv) + 1);
      if (path == NULL)
         return 0;

      strcpy (path, penv);
      prfx = strtok (path, ";");

      while (!found && prfx != NULL)
         {
	 _makepath (fn, l_drive, prfx, name, ext);
         if (ext [0])
            found = exists (fn);
         else
            found = tryext (fn);

         prfx = strtok (NULL, ";");
         }
      free (path);
      }
   return found;
}


/*
   tempdir: Set temporary file path.
            Read "TMP/TEMP" environment. If empty or invalid, clear path.
	    If TEMP is l_drive or l_drive+backslash only, return TEMP.
            Otherwise check if given path is a valid directory.
            If so, add a backslash, else clear path.
*/

static void tempdir (char *outfn)
{
   int l;
   char *s;
   struct stat ff;
   union REGS regs;
   struct SREGS segregs;

   *outfn = 0;
   if ((s = getenv ("TMP")) == NULL)
      if ((s = getenv ("TEMP")) == NULL)
         return;

   strcpy (outfn, s);
   l = strlen (outfn);
   if (!l)
      return;

   if (outfn [l - 1] == '\\' || outfn [l - 1] == '/')
      outfn [--l] = 0;

   _splitpath (outfn, l_drive, dir, name, ext);

   if (l_drive [0])
      {
      regs.h.dl = (unsigned char)(toupper (l_drive [0]) - 'A' + 1);
      regs.h.ah = 0x1c;
      intdosx (&regs, &regs, &segregs);
      if (regs.h.al == 0xff)
         {
         *outfn = 0;
         return;
         }
      }

   if (!name [0])   /* No dir name */
      {
      if (dir [0])
         *outfn = 0;
      else
         {
         outfn [l++] = '\\';
         outfn [l] = 0;
         }
      return;
      }

   if (stat (outfn, &ff))
      *outfn = 0;
   /* the following won't work with TC/BC - directories never have the
      write attribute set (don't ask me why). So only check for dir.
   */
#if (0)
   else if (!(ff.st_mode & S_IFDIR) || !(ff.st_mode & S_IWRITE))
#else
   else if (!(ff.st_mode & S_IFDIR))
#endif
      *outfn = 0;
   else
      {
      outfn [l++] = '\\';
      outfn [l] = 0;
      }
}


int do_exec (char *exfn, char *epars, int spwn, unsigned needed, char **envp)
{
   static char swapfn [82];
   static char execfn [82];
   unsigned avail;
   union REGS regs;
   unsigned envlen;
   int rc;
   int idx;
   char **env;
   char *ep, *envptr, *envbuf;
   int swapping;

   strcpy (execfn, exfn);

   /* First, check if the file to execute exists. */

   if (!findfile (execfn))
      return RC_NOFILE;

   /* Now create a copy of the environment if the user wants it. */

   envlen = 0;
   envptr = NULL;

   if (envp != NULL)
      for (env = envp; *env != NULL; env++)
         envlen += strlen (*env) + 1;

   if (envlen)
      {
      /* round up to paragraph, and alloc another paragraph leeway */
      envlen = (envlen + 32) & 0xfff0;
      envbuf = (char *)malloc (envlen);
      if (envbuf == NULL)
         return RC_ENVERR;

      /* align to paragraph */
      envptr = envbuf;
      if (FP_OFF (envptr) & 0x0f)
         envptr += 16 - (FP_OFF (envptr) & 0x0f);
      ep = envptr;

      for (env = envp; *env != NULL; env++)
         {
	 ep = (strcpy (ep, *env), ep + strlen (*env)) + 1;
         }
      *ep = 0;
      }

   if (!spwn)
      swapping = -1;
   else
      {
      /* Determine amount of free memory */

      regs.x.ax = 0x4800;
      regs.x.bx = 0xffff;
      intdos (&regs, &regs);
      avail = regs.x.bx;

      /* No swapping if available memory > needed */

      if (needed < avail)
         swapping = 0;
      else
         {
         /* Swapping necessary, use 'TMP' or 'TEMP' environment variable
           to determine swap file path if defined. */

         swapping = spwn;
         if (spwn & USE_FILE)
            {
            tempdir (swapfn);

	    if (_osmajor >= 3)
               swapping |= CREAT_TEMP;
            else
               {
               strcat (swapfn, SWAP_FILENAME);
               idx = strlen (swapfn) - 1;
               while (exists (swapfn))
                  {
                  if (swapfn [idx] == 'Z')
                     idx--;
                  if (swapfn [idx] == '.')
                     idx--;
                  swapfn [idx]++;
                  }
               }
            }
         }
      }

   /* All set up, ready to go. */

   if (swapping > 0)
      {
      if (!envlen)
         swapping |= DONT_SWAP_ENV;

      rc = prep_swap (swapping, swapfn);
      if (rc < 0)
         return RC_PREPERR | -rc;
      }

   rc = do_spawn (swapping, execfn, epars, envlen, envptr);

   /* Free the environment buffer if it was allocated. */

   if (envlen)
      free (envbuf);

   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pathcat.c ===
/***	pathcat.c - concatenate a string onto another, handing path seps
 *
 *	Modifications
 *	    23-Nov-1988 mz  Created
 */

#include "..\h\tools.h"
#include <string.h>

/**	pathcat - handle concatenation of path strings
 *
 *	Care must be take to handle:
 *	    ""	    XXX     =>	XXX
 *	    A	    B	    =>	A\B
 *	    A\      B	    =>	A\B
 *	    A	    \B	    =>	A\B
 *	    A\      \B	    =>	A\B
 *
 *	pDst	char pointer to location of 'A' above
 *	pSrc	char pointer to location of 'B' above
 *
 *	returns pDst
 */
char *pathcat (char *pDst, char *pSrc)
{
    /*	If dest is empty and src begins with a drive
     */
    if (*pDst == '\0')
	return strcpy (pDst, pSrc);

    /*	Make destination end in a path char
     */
    if (*pDst == '\0' || !fPathChr (strend (pDst)[-1]))
	strcat (pDst, PSEPSTR);

    /*	Skip leading path separators on source
     */
    while (fPathChr (*pSrc))
	pSrc++;

    return strcat (pDst, pSrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\ntoi.c ===
/* convert an arbitrary based number to an integer */

#include <ctype.h>
#include "..\h\tools.h"

/* p points to characters, return -1 if no good characters found
 * and base is 2 <= base <= 16
 */
int ntoi (p, base)
char *p;
int base;
{
    register int i, c;
    flagType fFound;

    if (base < 2 || base > 16)
	return -1;
    i = 0;
    fFound = FALSE;
    while (c = *p++) {
	c = tolower (c);
	if (!isxdigit (c))
	    break;
	if (c <= '9')
	    c -= '0';
	else
	    c -= 'a'-10;
	if (c >= base)
	    break;
	i = i * base + c;
	fFound = TRUE;
	}
    if (fFound)
	return i;
    else
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pathchr.c ===
/* pathchr.c - return configuration dependent info on MSDOS
 *
 *  09-Dec-1986 bw - Added DOS 5 support
 *  27-Jan-1987 bw - Make bindable by removing DOSQSWITCHAR call
 *  27-Apr-1987 bw - Make unbindable again.
 *  29-May-1987 bw - Remove DOSQSWITCHAR completely ( it's gone from OS/2 )
 *  08-Aug-1989 bw - Make '-' and '/' switches.
 */

#include "..\h\tools.h"

flagType fPathChr (c)
char c;
{
    return (flagType) (c == '\\' || c == '/');
}

flagType fSwitChr (c)
char c;
{
    return (flagType) (c == '/' || c == '-');
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pathopen.c ===
/* reasonable imitation of logical names
 *
 *	4/14/86     dl	findpath: test for trailing && leading \ before
 *                          appending a \
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *      03-Sep-1987 dl  fPFind: rtn nonzero iff exists AND is ordinary file
 *                      i.e., return false for directories
 *	11-Sep-1987 mz	Remove static declaration from findpath
 *	01-Sep-1988 bw	Allow $filenam.ext as a filename in findpath
 *	23-Nov-1988 mz	Use pathcat, allow $(VAR)
 */
#include "..\h\tools.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>

/* iterative routine takes args as pbuf, pfile */
static flagType fPFind (char *p, va_list ap)
{
    char *	pa[2];

     // Note that the call gives a pointer to the original args passed
     //     to pathopen rother than passing the parms themselves
    pa[1] = (char *)va_arg(ap, int *);
    pa[0] = (char *)va_arg(ap, int *);

    va_end(ap);

    /*  p == dir from env variable expansion or null
     *	pa[1] == file name
     *	pa[0] == buffer for getting p\pa[1] or pa[1] if p null
     */

    strcpy ((char *)pa[0], p);
    pathcat ((char *) pa[0], (char *) pa[1]);
#if defined(DOS) || defined(OS2)
    {
    struct stat sbuf;

    if (stat ((char *)pa[0], &sbuf) == -1)
	return FALSE;

    if ((sbuf.st_mode & S_IFREG) == 0)
	return FALSE;
    }
#elif defined(NT)
    {
        HANDLE TmpHandle;
        WIN32_FIND_DATA buffer;

        TmpHandle = FindFirstFile((LPSTR)pa[0],&buffer);

	if (TmpHandle == INVALID_HANDLE_VALUE)
            return FALSE;

        FindClose(TmpHandle);

	if (!(buffer.dwFileAttributes & FILE_ATTRIBUTE_NORMAL))
            return FALSE;
    }
#endif
    pname ((char *) pa[0]);
    return TRUE;
}

/*  $ENV:foo uses pathcat
 *  foo uses strcat
 */
flagType findpath (filestr, pbuf, fNew)
char *filestr, *pbuf;
flagType fNew;
{
    char *p;
    char *pathstr;
    size_t n;

    /*	Set pathstr to be text to walk or empty.
     *	Set filestr to be file name to look for.
     */
    pathstr = NULL;

    /*	Are we starting $ENV: or $(ENV)?
     */
    if (*filestr == '$')

	/*  Are we starting $(ENV)?
	 */
	if (filestr[1] == '(')

	    /*	Do we have $(ENV)?
	     */
	    if ((p = strchr (filestr, ')')) != NULL) {
		*p = 0;
		pathstr = getenv (filestr + 2);
		*p++ = ')';
		filestr = p;
		}
	    else
		;
	else
	/*  Do we have $ENV: ?
	 */
	if ((p = strchr (filestr, ':')) != NULL) {
	    *p = 0;
	    pathstr = getenv (filestr + 1);
	    *p++ = ':';
	    filestr = p;
	    }
	else
	    ;
    else
	;

    /*	Convert pathstr into true string
     */
    if (pathstr == NULL)
	pathstr = "";

    /*	If we find an existing file in the path
     */
    if (forsemi (pathstr, fPFind, filestr, pbuf))
	return TRUE;

    /*	If this is not a new file
     */
    if (!fNew)
        return FALSE;

    /*	File does not exist.  Take first dir from pathstr and use it
     *	as prefix for result
     */
    p = strchr (pathstr, ';');
    n = ((p == NULL) ? strlen (pathstr) : p - pathstr);
    strncpy (pbuf, pathstr, n);
    pbuf[n] = '\0';

    if (*pathstr == 0)
	strcat (pbuf, filestr);
    else
	pathcat (pbuf, filestr);

    return TRUE;
}

FILE *pathopen (name, buf, mode)
char *name, *mode, *buf;
{
    return findpath (name, buf, TRUE) ? fopen (buf, mode) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\opendir.c ===
#define INCL_BASE
#include <os2.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <limits.h>
#include <errno.h>
#include <assert.h>
#include "..\h\dirent.h"

struct DirBuf				// The real DIR, hidden from the user.
	{				// Hide OS/2 include files
	HDIR hdir;			// OS/2 directory handle
	char *szPath;			// Path to directory name 
	unsigned int bInvalid: 1;	// At EOF on directory
	unsigned int bRewind: 1;	// Rewind on next read.
	char *szFNCur;			// pointer to current file name
	USHORT usSearchCount;		// number of filenames buffered
	USHORT cff2;			// number of FILFINDBUF2 structures
	FILEFINDBUF2 aff2[1];		// variable size array (cff2 #)
	};

static USHORT usMyDFF2(struct DirBuf *);
static USHORT usMyDFN(struct DirBuf *);
static USHORT usDFToPosix(struct DirBuf *, USHORT);
static struct DirBuf *pdbMake(char *);
void DosErrToErrno(USHORT);

// Default number of FILEFINDBUF2 buffers.
// User settable before opendir() calls.
USHORT _cff2Bufs = max((2 * BUFSIZ / sizeof(FILEFINDBUF2)), 1);

// opendir() -- POSIX 1003.1 compliant routine.
//	Open a directory stream corresponding to the directory
//	named by the argment.  Return a pointer to the stream
//	of type DIR *, or NULL on error.

DIR *opendir(char *szDirName)
	{
	enum {enBadArg, enAlloc, enFF2, enGood} enErr;
	struct DirBuf *pdb = NULL;

	if (NULL == szDirName)
		enErr = enBadArg;
	else if (NULL == (pdb = pdbMake(szDirName)))
		enErr = enAlloc;
	else if (usMyDFF2(pdb))
		enErr = enFF2;
	else
		enErr = enGood;
	switch (enErr)
		{
		case enFF2:
			free((char *) pdb);
		default:
		case enAlloc:
			pdb = NULL;
			break;
		case enBadArg:
			errno = EINVAL;
			pdb = NULL;
			break;
		case enGood:
			break;
		};
	return (DIR *) pdb;
	}

// readdir() -- POSIX 1003.1 compliant routine.
// 	read a file name from a directory stream.
//	return NULL if error or EOF, or a pointer 
//	to a struct dirent if not.
//	Special handling for rewinddir(), EOF, and
//	filling th buffer with DOSFINDNEXT().

struct dirent *readdir(DIR *pd)
	{
	struct DirBuf *pdb = (struct DirBuf *) pd;
	struct dirent *pde = NULL;

	if (NULL == pdb)
		{
		errno = EBADF;
		pde = NULL;
		}
	else if (pdb->bRewind && ((pdb->bRewind = 0), usMyDFF2(pdb)))
		pde = NULL;
	else if (pdb->bInvalid)
		pde = NULL;
	else if (NULL != pdb->szFNCur)
		{
		pde = (struct dirent *) pdb->szFNCur;
		if (--(pdb->usSearchCount) == 0)
			pdb->szFNCur = NULL;
		else
			pdb->szFNCur = ((FILEFINDBUF2 *) (pdb->szFNCur + 1 +
					strlen(pdb->szFNCur)))->achName;
		}
	else if (usMyDFN(pdb))
		pde = NULL;
	else 
		pde = readdir(pd);
	return pde;
	}

// closedir() -- POSIX 1003.1 compliant routine.
//	Close a directory stream and free the memory allocated to 
//	it.  This might want to return an error is the szPath field
//	of the DirBuf structure is empty -- that's an internal error.

int closedir(DIR *pd)
	{
	struct DirBuf *pdb = (struct DirBuf *) pd;
	USHORT usDFCRet;
	int iRetVal = -1;

	if (NULL == pdb)
		{
		errno = EBADF;
		return -1;
		}
	if (usDFCRet = DosFindClose(pdb->hdir))
		{
		DosErrToErrno(usDFCRet);
		iRetVal = -1;
		}
	else
		iRetVal = 0;
	if (NULL != pdb->szPath)
		free(pdb->szPath);
	free((char *) pd);
	return iRetVal;
	}

// rewinddir() -- POSIX 1003.1 compliant routine.
//	Rewind a directory stream to the beginning. 
//	Set the rewind flag, and clear the EOF flag.
//	This is to postpone errors on the DosFindFirst2()
//	until readdir(), since this is specified as a 
//	function of type void.

void rewinddir(DIR *pd)
	{
	struct DirBuf *pdb = (struct DirBuf *) pd;

	if (NULL != pdb)
		{
		pdb->bRewind = 1;
		pdb->bInvalid = 0;
		}
	}

// usMyDFF2 -- wrapper for DosFindFirst2() for POSIX functions.
//	Pass in the right arguments, and map the return code
//	through the C runtime error mapping functions.
//	Always try to squeeze as many names in the buffer as 
//	will fit.

static USHORT usMyDFF2(struct DirBuf *pdb)
	{
	assert(NULL != pdb);

	pdb->usSearchCount = USHRT_MAX;
	return usDFToPosix(pdb, DosFindFirst2((PSZ) (pdb->szPath),
					(PHDIR) &(pdb->hdir),
					FILE_NORMAL | FILE_READONLY |
					FILE_HIDDEN | FILE_SYSTEM |
					FILE_DIRECTORY | FILE_ARCHIVED,
					(PVOID) (pdb->aff2),
					sizeof(FILEFINDBUF2) * pdb->cff2,
					(PUSHORT) &(pdb->usSearchCount),
					FIL_QUERYEASIZE, (ULONG) 0L));
	}

// usMyDFN -- wrapper for DosFindNext() for POSIX functions.
//	Pass in the right arguments, and map the return code
//	through the C runtime error mapping functions.
//	Always try to squeeze as many names in the buffer as 
//	will fit.

static USHORT usMyDFN(struct DirBuf *pdb)
	{
	assert(NULL != pdb);

	pdb->usSearchCount = USHRT_MAX;
	return usDFToPosix(pdb, DosFindNext(pdb->hdir,
					(PFILEFINDBUF) (pdb->aff2),
					sizeof(FILEFINDBUF2) * pdb->cff2,
					(PUSHORT) &(pdb->usSearchCount)));
	}

// usDFToPosix -- map DosFind?() functions to the data
//	structures used to implement the POSIX layer.
//	Map the return code, set the EOF flag, 
//	set the pointer to the filename in the structure.

static USHORT usDFToPosix(struct DirBuf *pdb, USHORT usDFRet)
	{
	assert(NULL != pdb);

	switch (usDFRet)
		{
		default:
			DosErrToErrno(usDFRet);
			pdb->szFNCur = NULL;
			break;
		case ERROR_NO_MORE_FILES:
			pdb->bInvalid = 1;
			pdb->szFNCur = NULL;
			usDFRet = 0;
			break;
		case 0:
			pdb->szFNCur = pdb->aff2[0].achName;
			break;
		};
	return usDFRet;
	}

// pdbMake -- Create and initialize the DirBuf structure to
//	support the POSIX layer for opendir() etc.
//	Clear the flags, make a buffer of the size determined
//	by the global _cff2Bufs, record the size (in case 
//	the global value is changed.  Returns NULL on failure.
//	

static struct DirBuf *pdbMake(char *szDirName)
	{
	struct DirBuf *pdb = NULL;
	char szPath[_MAX_PATH];
	size_t cchdb;
	enum
		{
		enInternal, enNoDIR, enNoPath, enGood
		} enErr = enInternal;
	
	assert(NULL != szDirName);

	_cff2Bufs = max(_cff2Bufs, 1);
	cchdb = sizeof(struct DirBuf) +
		(sizeof(FILEFINDBUF2) * (_cff2Bufs - 1));
	if (NULL == (pdb = (struct DirBuf *) malloc(cchdb)))
		enErr = enNoDIR;
	else if (_makepath(szPath, "", szDirName, "*", "*"),
	         (NULL == (pdb->szPath = strdup(szPath))))
		enErr = enNoPath;
	else
		{
		pdb->bInvalid = 0;
		pdb->bRewind = 0;
		pdb->hdir = HDIR_CREATE;
		pdb->cff2 = _cff2Bufs;
		pdb->usSearchCount = 0;
		enErr = enGood;
		}
	switch (enErr)
		{
		case enNoPath:
			free((char *) pdb);
		default:
		case enNoDIR:
			pdb = NULL;
			break;
		case enGood:
			break;
		};
	return pdb;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\msspawn.asm ===
;
;	--- Version 3.0 91-05-27 17:56 ---
;
;	SPAWN.ASM - Main function for memory swapping spawn call.
;
;	Public Domain Software written by
;		Thomas Wagner
;		Ferrari electronic GmbH
;		Beusselstrasse 27
;		D-1000 Berlin 21
;		Germany
;
;
; Assemble with
;
; ?asm  spawn;		  		- C, default model (small)
; ?asm  /DMODL=large spawn  		- C, large model
;
;	NOTE:	For C, change the 'model' directive below according to your
;		memory model, or define MODL=xxx on the command line.
;
;
; Main function:
;
;   	int do_spawn (int swapping,
;		      char *execfname, 
;		      char *cmdtail,
;		      unsigned envlen, 
;		      char *envp)
;
;   Parameters:
;
;	swapping - swap/spawn/exec function:
;			< 0: Exec, don't swap
;		  	  0: Spawn, don't swap
;			> 0: Spawn, swap
;			     in this case, prep_swap must have 
;			     been called beforehand (see below).
;
;	cmdtail - command tail for EXEC.
;
;	execfname - name and path of file to execute.
;
;	envlen - length of environment copy (may be 0).
;
;	envp -  pointer to environment block (must be aligned on
;		paragraph boundary). Unused if envlen is 0.
;
;   Returns:
;	0000..00ff:	Returncode of EXECed program
;	03xx:		DOS-Error xx calling EXEC
;	0500:		Swapping requested, but prep_swap has not 
;			been called or returned an error
;	0501:		MCBs don't match expected setup
;	0502:		Error while swapping out
;
;
; For swapping, the swap method must be prepared before calling do_spawn.
;
;	int prep_swap (unsigned method, char *swapfname)
;
;   Parameters:
;
;	method	- bit-map of allowed swap devices:
;			01 - Allow EMS
;			02 - Allow XMS
;			04 - Allow File swap
;			10 - Try XMS first, then EMS
;			40 - Create file as "hidden"
;			80 - Use "create temp" call for file swap
;		       100 - Don't preallocate file
;		       200 - Check for Network, don't preallocate if net
;		      4000 - Environment block will not be swapped
;
;	swapfname - swap file name (may be undefined if the
;		    "method" parameters disallows file swap).
;
;   Returns:
;
;   	A positive integer on success:
;		1 - EMS swap initialized
;		2 - XMS swap initialized
;		4 - File swap initialized
;	A negative integer on failure:
;		-1 - Couldn't allocate swap space
;		-2 - The spawn module is located too low in memory
;
;
	IFDEF	?LARGE
	.model	large,c
	%out	  large model
	ELSE
	IFDEF	?MEDIUM
	.model	medium,c
	%out	  medium model
	ELSE
	.model	small,c
	%out	  small model
	ENDIF
	ENDIF
;
ptrsize	=	@DataSize
;
	extrn	_psp: word
;
	public	do_spawn
	public	prep_swap
;
stacklen	=	256		; local stack
;
;	"ems_size" is the EMS block size: 16k.
;
ems_size	=	16 * 1024	; EMS block size
ems_parasize	=	ems_size / 16	; same in paragraphs
ems_shift	=	10		; shift factor for paragraphs
ems_paramask	=	ems_parasize-1	; block mask
;
;	"xms_size" is the unit of measurement for XMS: 1k
;
xms_size	=	1024		; XMS block size
xms_parasize	=	xms_size / 16	; same in paragraphs
xms_shift	=	6		; shift factor for paragraphs
xms_paramask	=	xms_parasize-1	; block mask
;
;	Method flags
;
USE_EMS		=	01h
USE_XMS		=	02h
USE_FILE	=	04h
XMS_FIRST	=	10h
HIDE_FILE	=	40h
CREAT_TEMP	=	80h
NO_PREALLOC	=	100h
CHECK_NET	=	200h
DONT_SWAP_ENV	=	4000h
;
;	Return codes
;
RC_TOOLOW	=	0102h
RC_BADPREP	=	0500h
RC_MCBERROR	=	0501h
RC_SWAPERROR	=	0502h
;
EMM_INT		=	67h
;
;	The EXEC function parameter block
;
exec_block	struc
envseg	dw	?		; environment segment
ppar	dw	?		; program parameter string offset
pparseg	dw	?		; program parameter string segment
fcb1	dw	?		; FCB offset
fcb1seg	dw	?		; FCB segment
fcb2	dw	?		; FCB offset
fcb2seg	dw	?		; FCB segment
exec_block	ends
;
;	Structure of an XMS move control block
;
xms_control	struc
lenlo		dw	?	; length to move (doubleword)
lenhi		dw	?
srchnd		dw	?	; source handle (0 for standard memory)
srclo		dw	?	; source address (doubleword or seg:off)
srchi		dw	?
desthnd		dw	?	; destination handle (0 for standard memory)
destlo		dw	?	; destination address (doubleword or seg:off)
desthi		dw	?
xms_control	ends
;
;	The structure of the start of an MCB (memory control block)
;
mcb		struc
id		db	?
owner		dw	?
paras		dw	?
mcb		ends
;
;	The structure of an internal MCB descriptor.
;	CAUTION: This structure is assumed to be no larger than 16 bytes
;	in several places in the code, and to be exactly 16 bytes when
;	swapping in from file. Be careful when changing this structure.
;
mcbdesc		struc
addr		dw	?	; paragraph address of the MCB
msize		dw	?	; size in paragraphs (excluding header)
swoffset	dw	?	; swap offset (0 in all blocks except first)
swsize		dw	?	; swap size (= msize + 1 except in first)
num_follow	dw	?	; number of following MCBs
		dw	3 dup(?) ; pad to paragraph (16 bytes)
mcbdesc		ends
;
;	The variable block set up by prep_swap
;
prep_block	struc
xmm		dd	?		; XMM entry address
first_mcb	dw	?		; Segment of first MCB
psp_mcb		dw	?		; Segment of MCB of our PSP
env_mcb		dw	?		; MCB of Environment segment
noswap_mcb	dw	?		; MCB that may not be swapped
ems_pageframe	dw	?		; EMS page frame address
handle		dw	?		; EMS/XMS/File handle
total_mcbs	dw	?		; Total number of MCBs
swapmethod	db	?		; Method for swapping
swapfilename	db	81 dup(?)	; Swap file name if swapping to file
prep_block	ends
;
;----------------------------------------------------------------------
;
;	Since we'll be moving code and data around in memory,
;	we can't address locations in the resident block with
;	normal address expressions. MASM does not support
;	defining variables with a fixed offset, so we have to resort
;	to a kludge, and define the shrunk-down code as a structure.
;	It would also be possible to use an absolute segment for the
;	definition, but this is not supported by the Turbo Pascal linker.
;
;	All references to low-core variables from low-core itself 
;	are made through DS, so we define a text macro "lmem" that 
;	expands to "ds:". When setting up low core from the normal
;	code, ES is used to address low memory, so this can't be used.
;
lmem	equ	<ds:>
;
;	The memory structure for the shrunk-down code, excluding the
;	code itself. The code follows this block.
;
parseg		struc
		db	2ch dup(?)
psp_envptr	dw	?
		db	5ch-2eh dup(?)	; start after PSP
;
save_ss		dw	?		; 5C - saved global ss
save_sp		dw	?		; 5E - saved global sp
xfcb1		db	16 dup(?)	; 60..6F - default FCB
xfcb2		db	16 dup(?)	; 70..7F - default FCB
zero		dw	?		; 80 Zero command tail length (dummy)
;
expar		db	TYPE exec_block dup (?) ; exec-parameter-block
spx		dw	?		; saved local sp
div0_off	dw	?		; divide by zero vector save
div0_seg	dw	?
filename	db	82 dup(?)	; exec filename
progpars	db	128 dup(?)	; command tail
		db	stacklen dup(?)	; local stack space
mystack		db	?
lprep		db	TYPE prep_block dup(?)	; the swapping variables
lcurrdesc	db	TYPE mcbdesc dup(?)	; the current MCB descriptor
lxmsctl		db	TYPE xms_control dup(?)
eretcode	dw	?		; EXEC return code
retflags	dw	?		; EXEC return flags
cgetmcb		dw	?		; address of get_mcb
;
parseg	ends
;
param_len	=	((TYPE parseg + 1) / 2) * 2	; make even
codebeg		=	param_len
;
	.code
;
;------------------------------------------------------------------------
;
lowcode_begin:
;
;       The following parts of the program code will be moved to
;	low core and executed there, so there must be no absolute 
;	memory references.
;	The call to get_mcb must be made indirect, since the offset
;	from the swap-in routine to get_mcb will not be the same
;	after moving.
;
;
;	get_mcb allocates a block of memory by modifying the MCB chain
;	directly.
;
;	On entry, lcurrdesc has the mcb descriptor for the block to
;		  allocate.
;
;	On exit,  Carry is set if the block couldn't be allocated.
;
;	Uses 	AX, BX, CX, ES
;	Modifies lprep.first_mcb
;
get_mcb	proc	near
;
	mov	ax,lmem lprep.first_mcb
	mov	bx,lmem lcurrdesc.addr
;
getmcb_loop:
	mov	es,ax
	cmp	ax,bx
	ja	gmcb_abort		; halt if MCB > wanted
	je	mcb_found		; jump if same addr as wanted
	add	ax,es:paras		; last addr
	inc	ax			; next mcb
	cmp	ax,bx
	jbe	getmcb_loop		; Loop if next <= wanted
;
;
;	The wanted MCB starts within the current MCB. We now have to
;	create a new MCB at the wanted position, which is initially
;	free, and shorten the current MCB to reflect the reduced size.
;
	cmp	es:owner,0
	jne	gmcb_abort		; halt if not free
	mov	bx,es			; current
	inc	bx			; + 1 (header doesn't count)
	mov	ax,lmem lcurrdesc.addr
	sub	ax,bx			; paragraphs between MCB and wanted
	mov	bx,es:paras		; paras in current MCB
	sub	bx,ax			; remaining paras
	dec	bx			; -1 for header
	mov	es:paras,ax		; set new size for current
	mov	cl,es:id		; old id
	mov	es:id,4dh		; set id: there is a next
	mov	ax,lmem lcurrdesc.addr
	mov	es,ax
	mov	es:id,cl		; and init to free
	mov	es:owner,0
	mov	es:paras,bx
;
;	We have found an MCB at the right address. If it's not free,
;	abort. Else check the size. If the size is ok, we're done 
;	(more or less).
;
mcb_found:
	mov	es,ax
	cmp	es:owner,0
	je	mcb_check		; continue if free
;
gmcb_abort:
	stc
	ret
;
mcb_check:
	mov	ax,es:paras		; size
	cmp	ax,lmem lcurrdesc.msize	; needed size
	jae	mcb_ok			; ok if enough space
;
;	If there's not enough room in this MCB, check if the next
;	MCB is free, too. If so, coalesce both MCB's and check again.
;
	cmp	es:id,4dh
	jnz	gmcb_abort		; halt if no next
	push	es			; save current
	mov	bx,es
	add	ax,bx
	inc	ax			; next MCB
	mov	es,ax
	cmp	es:owner,0		; next free ?
	jne	gmcb_abort		; halt if not
	mov	ax,es:paras		; else load size
	inc	ax			; + 1 for header
	mov	cl,es:id		; and load ID
	pop	es			; back to last MCB
	add	es:paras,ax		; increase size
	mov	es:id,cl		; and store ID
	jmp	mcb_check		; now try again
;
;	The MCB is free and large enough. If it's larger than the
;	wanted size, create another MCB after the wanted.
;
mcb_ok:
	mov	bx,es:paras
	sub	bx,lmem lcurrdesc.msize
	jz	mcb_no_next		; ok, no next to create
	push	es
	dec	bx			; size of next block
	mov	ax,es
	add	ax,lmem lcurrdesc.msize
	inc	ax			; next MCB addr
	mov	cl,es:id		; id of this block
	mov	es,ax			; address next
	mov	es:id,cl		; store id
	mov	es:paras,bx		; store size
	mov	es:owner,0		; and mark as free
	pop	es			; back to old MCB
	mov	es:id,4dh		; mark next block present
	mov	ax,lmem lcurrdesc.msize	; and set size to wanted
	mov	es:paras,ax
;
mcb_no_next:
	mov	es:owner,cx		; set owner to current PSP
;
;	Set the 'first_mcb' pointer to the current one, so we don't
;	walk through all the previous blocks the next time.
;	Also, check if the block we just allocated is the environment
;	segment of the program. If so, restore the environment pointer
;	in the PSP.
;
	mov	ax,es
	mov	lmem lprep.first_mcb,ax
	cmp	lmem lprep.env_mcb,ax
	jne	getmcb_finis
	inc	ax
	mov	lmem psp_envptr,ax
;
getmcb_finis:
	clc
	ret				; all finished (whew!)
;
get_mcb	endp
;
;
ireti:
	iret
;
;
;	The actual EXEC call.
;	Registers on entry:
;		BX	= paragraphs to keep (0 if no swap)
;		CX 	= length of environment to copy (words) or zero
;		DS:SI	= environment source
;		ES:DI	= environment destination
;		(ES = our low core code segment)
;
;
;	copy environment buffer down if present
;
doexec:
	jcxz	noenvcpy
	rep movsw
;
noenvcpy:
	push	es			; DS = ES = low core = PSP
	pop	ds
	or	bx,bx
	jz	no_shrink
;
;	first, shrink the base memory block down.
;
        mov	ah,04ah
	int     21h                     ; resize memory block
;
;	Again walk all MCBs. This time, all blocks owned by the 
;	current process are released.
;
	mov	si,lmem lprep.first_mcb
	or	si,si
	jz	no_shrink
	mov	dx,lmem lprep.psp_mcb
	mov	bx,dx
	inc	bx			; base PSP (MCB owner)
	mov	di,lmem lprep.noswap_mcb
;
free_loop:
	cmp	si,dx
	je	free_next		; don't free base block
	cmp	si,di
	je	free_next
	mov	es,si
	cmp	bx,es:owner		; our process?
	jne	free_next		; next if not
	cmp	si,lmem lprep.env_mcb	; is this the environment block?
	jne	free_noenv
	mov	ds:psp_envptr,0		; else clear PSP pointer
;
free_noenv:
	inc	si
	mov	es,si
	dec	si
	mov	ah,049h			; free memory block
	int	21h
;
free_next:
	mov	es,si
	cmp	es:id,4dh		; normal block?
	jne	free_ready		; ready if end of chain
	add	si,es:paras		; start + length
	inc	si			; next MCB
	jmp	free_loop
;
free_ready:
	mov	ax,ds
	mov	es,ax
;
no_shrink:
	mov	dx,filename		; params for exec
	mov	bx,expar
	mov	ax,04b00h
	int	21h			; exec
;
;	Return from EXEC system call. Don't count on any register except
;	CS to be restored (DOS 2.11 and previous versions killed all regs).
;
	mov	bx,cs
	mov	ds,bx
	mov	es,bx
	mov	ss,bx
	mov	sp,lmem spx
	cld
	mov	lmem eretcode,ax	; save return code
	pushf
	pop	bx
	mov	lmem retflags,bx	; and returned flags
;
	cmp	lmem lprep.swapmethod,0
	je	exec_memok
	jg	exec_expand
;
;	Terminate.
;
	test	bx,1			; carry?
	jnz	exec_term		; use EXEc retcode if set
	mov	ah,4dh			; else get program return code
	int	21h
;
exec_term:
	mov	ah,4ch
	int	21h
;
;
exec_expand:
	mov	ah,4ah			; expand memory
	mov	bx,lmem lcurrdesc.msize
	int	21h
	jnc	exec_memok
	mov	ax,4cffh
	int	21h			; terminate on error
;
;	Swap memory back
;
	nop
;
exec_memok:
;
;	FALL THROUGH to the appropriate swap-in routine
;
;
getmcboff	=	offset get_mcb - offset lowcode_begin
iretoff		=	offset ireti - offset lowcode_begin
doexec_entry	=	offset doexec - offset lowcode_begin
base_length	=	offset $ - offset lowcode_begin
;
;-----------------------------------------------------------------------
;
;	The various swap in routines follow. Only one of the routines
;	is copied to low memory.
;	Note that the routines are never actually called, the EXEC return
;	code falls through. The final RET thus will return to the restored
;	memory image.
;
;	On entry, DS must point to low core.
;	On exit to the restored code, DS is unchanged.
;
;
;	swapin_ems:	swap in from EMS.
;
swapin_ems	proc	far
;
	xor	bx,bx
	mov	si,ems_parasize
	mov	dx,lmem lprep.handle	; EMS handle
;
swinems_main:
	push	ds
	mov	cx,lmem lcurrdesc.swsize	; block length in paras
	mov	di,lmem lcurrdesc.swoffset	; swap offset
	mov	es,lmem lcurrdesc.addr		; segment to swap
	mov	ds,lmem lprep.ems_pageframe	; page frame address
;
	mov	ax,ems_parasize		; max length
	sub	ax,si			; minus current offset
	jnz	swinems_ok		; go copy if nonzero
;
swinems_loop:
	mov	ax,4400h		; map in next page
	int	EMM_INT
	or	ah,ah
	jnz	swinems_error
	mov	si,0			; reset offset
	inc	bx			; bump up page number
	mov	ax,ems_parasize		; max length to copy
;
swinems_ok:
	cmp	ax,cx			; length to copy
	jbe	swinems_doit		; go do it if <= total length
	mov	ax,cx			; else use total length
;
swinems_doit:
	sub	cx,ax			; subtract copy length from total
	push	cx			; and save
	push	ax			; save the copy length in paras
	push	si
	push	di
	mov	cl,3
	shl	ax,cl			; convert to number of words (!)
	inc	cl
	shl	si,cl			; convert to byte address
	mov	cx,ax
	rep movsw
	pop	di
	pop	si
	pop	cx			; copy length in paras
	mov	ax,es
	add	ax,cx			; add copy length to dest segment
	add	si,cx			; and EMS page offset
	mov	es,ax
	pop	cx			; remaining length
	or	cx,cx			; did we copy everything?
	jnz	swinems_loop		; go loop if not
;
	pop	ds
	cmp	lmem lcurrdesc.num_follow,0	; another MCB?
	je	swinems_complete	; exit if not
;
;	Another MCB follows, read next mcb descriptor into currdesc
;
	cmp	si,ems_parasize
	jb	swinems_nonewpage	; no new block needed
	mov	ax,4400h		; map page, phys = 0
	int	EMM_INT
	or	ah,ah
	jnz	swinems_error1
	mov	si,0
	inc	bx
;
swinems_nonewpage:
	push	si
	push	ds
	mov	ax,ds
	mov	es,ax
	mov	ds,lmem lprep.ems_pageframe	; page frame address
	mov	cl,4
	shl	si,cl			; convert to byte address
	mov	cx,TYPE mcbdesc
	mov	di,lcurrdesc
	rep movsb
	pop	ds
	pop	si
	inc	si			; one paragraph
;
	push	bx
	call	lmem cgetmcb
	pop	bx
	jc	swinems_error1
	jmp	swinems_main
;
swinems_complete:
	mov	ah,45h			; release EMS pages
	int	EMM_INT
	ret
;
swinems_error:
	pop	ds
swinems_error1:
	mov	ah,45h			; release EMS pages on error
	int	EMM_INT
	mov	ax,4cffh
	int	21h			; terminate
;
swapin_ems	endp
;
swinems_length	= offset $ - offset swapin_ems
;
;
;	swapin_xms:	swap in from XMS.
;
swapin_xms	proc	far
;
	mov	ax,lmem lprep.handle	; XMS handle
	mov	lmem lxmsctl.srchnd,ax 	; source is XMS
	mov	lmem lxmsctl.desthnd,0 	; dest is normal memory
	mov	lmem lxmsctl.srclo,0
	mov	lmem lxmsctl.srchi,0
;
swinxms_main:
	mov	ax,lmem lcurrdesc.swsize ; size in paragraphs
	mov	cl,4
	rol	ax,cl			; size in bytes + high nibble
	mov	dx,ax
	and	ax,0fff0h		; low word
	and	dx,0000fh		; high word
	mov	lmem lxmsctl.lenlo,ax	; into control block
	mov	lmem lxmsctl.lenhi,dx
	mov	ax,lmem lcurrdesc.swoffset	; swap offset
	mov	lmem lxmsctl.destlo,ax 		; into control block
	mov	ax,lmem lcurrdesc.addr		; segment to swap
	mov	lmem lxmsctl.desthi,ax
	mov	si,lxmsctl
	mov	ah,0bh
	call	lmem lprep.xmm		; move it
	or	ax,ax
	jz	swinxms_error
	mov	ax,lmem lxmsctl.lenlo	; adjust source addr
	add	lmem lxmsctl.srclo,ax
	mov	ax,lmem lxmsctl.lenhi
	adc	lmem lxmsctl.srchi,ax
;
	cmp	lmem lcurrdesc.num_follow,0	; another MCB?
	je	swinxms_complete
;
	mov	lmem lxmsctl.lenlo,TYPE mcbdesc
	mov	lmem lxmsctl.lenhi,0
	mov	lmem lxmsctl.desthi,ds
	mov	lmem lxmsctl.destlo,lcurrdesc
	mov	si,lxmsctl
	mov	ah,0bh
	call	lmem lprep.xmm		; move it
	or	ax,ax
	jz	swinxms_error
	add	lmem lxmsctl.srclo,16	; one paragraph
	adc	lmem lxmsctl.srchi,0
;
	call	lmem cgetmcb
	jc	swinxms_error
	jmp	swinxms_main
;
swinxms_complete:
	mov	ah,0ah			; release XMS frame
	mov	dx,lmem lprep.handle   	; XMS handle
	call	lmem lprep.xmm
	ret
;
swinxms_error:
	mov	ah,0ah			; release XMS frame on error
	call	lmem lprep.xmm
	mov	ax,4c00h
	int	21h
;
swapin_xms	endp
;
swinxms_length	= offset $ - offset swapin_xms
;
;
;	swapin_file:	swap in from file.
;
swapin_file	proc	far
;
	mov	dx,lprep.swapfilename
	mov	ax,3d00h			; open file
	int	21h
	jc	swinfile_error2
	mov	bx,ax				; file handle
;
swinfile_main:
	push	ds
	mov	cx,lmem lcurrdesc.swsize	; size in paragraphs
	mov	dx,lmem lcurrdesc.swoffset	; swap offset
	mov	ds,lmem lcurrdesc.addr		; segment to swap
;
swinfile_loop:
	mov	ax,cx
	cmp	ah,8h			; above 32k?
	jbe	swinfile_ok		; go read if not
	mov	ax,800h			; else read 32k
;
swinfile_ok:
	sub	cx,ax			; remaining length
	push	cx			; save it
	push	ax			; and save paras to read
	mov	cl,4
	shl	ax,cl			; convert to bytes
	mov	cx,ax
	mov	ah,3fh			; read
	int	21h
	jc	swinfile_error
	cmp	ax,cx
	jne	swinfile_error
	pop	cx			; paras read
	mov	ax,ds
	add	ax,cx			; bump up dest segment
	mov	ds,ax
	pop	cx			; remaining length
	or	cx,cx			; anything left?
	jnz	swinfile_loop		; go loop if yes
;
	pop	ds
	cmp	lmem lcurrdesc.num_follow,0	; another MCB?
	je	swinfile_complete	; ready if not
	mov	cx,16			; read one paragraph
	mov	dx,lcurrdesc
	mov	ah,3fh
	int	21h
	jc	swinfile_error1
	cmp	ax,cx
	jne	swinfile_error1
;
	push	bx
	call	lmem cgetmcb
	pop	bx
	jc	swinfile_error1
	jmp	swinfile_main
;
;
swinfile_complete:
	mov	ah,3eh			; close file
	int	21h
	mov	dx,lprep.swapfilename
	mov	ah,41h			; delete file
	int	21h
	ret
;
swinfile_error:
	pop	cx
	pop	cx
	pop	ds
swinfile_error1:
	mov	ah,3eh			; close file
	int	21h
swinfile_error2:
	mov	dx,lprep.swapfilename
	mov	ah,41h			; delete file
	int	21h
	mov	ax,4cffh
	int	21h
;
swapin_file	endp
;
swinfile_length	= offset $ - offset swapin_file
;
;
;	swapin_none:	no swap, return immediately.
;
swapin_none	proc	far
;
	ret
;
swapin_none	endp
;
;
	IF	swinems_length GT swinxms_length
swcodelen	=	swinems_length
	ELSE
swcodelen	=	swinxms_length
	ENDIF
	IF	swinfile_length GT swcodelen
swcodelen	=	swinfile_length
	ENDIF
;
swap_codelen	=	((swcodelen + 1) / 2) * 2
;
codelen		=	base_length + swap_codelen
reslen		=	codebeg + codelen
keep_paras	=	(reslen + 15) shr 4	; paragraphs to keep
swapbeg		=	keep_paras shl 4	; start of swap space
savespace	=	swapbeg - 5ch	; length of overwritten area
;
;--------------------------------------------------------------------
;
	.data?
;
;
;	Space for saving the part of the memory image below the
;	swap area that is overwritten by our code.
;
save_dat	db	savespace dup(?)
;
;	Variables used while swapping out.
;	The "prep" structure is initialized by prep_swap.
;
prep		prep_block	<>
nextmcb		mcbdesc		<>
currdesc	mcbdesc		<>
xmsctl		xms_control	<>
ems_curpage	dw		?	; current EMS page number
ems_curoff	dw		?	; current EMS offset (paragraph)
;
;--------------------------------------------------------------------
;       
	.code
;
;	swapout_ems:	swap out an MCB block to EMS.
;
;	Entry:	"currdesc" 	contains description of block to swap
;		"nextmcb"	contains MCB-descriptor of next block
;				if currdesc.num_follow is nonzero
;
;	Exit:	0 if OK, != 0 if error, Zero-flag set accordingly.
;
;	Uses:	All regs excpt DS
;
swapout_ems	proc	near
;
	push	ds
	mov	cx,currdesc.swsize	; block length in paras
	mov	si,currdesc.swoffset	; swap offset
	mov	dx,prep.handle		; EMS handle
	mov	bx,ems_curpage		; current EMS page
	mov	di,ems_curoff		; current EMS page offset (paras)
	mov	es,prep.ems_pageframe	; page frame address
	mov	ds,currdesc.addr	; segment to swap
;
	mov	ax,ems_parasize		; max length
	sub	ax,di			; minus current offset
	jnz	swems_ok		; go copy if there's room
;
swems_loop:
	mov	ax,4400h		; map in next page
	int	EMM_INT
	or	ah,ah
	jnz	swems_error
	mov	di,0			; reset offset
	inc	bx			; bump up page number
	mov	ax,ems_parasize		; max length to copy
;
swems_ok:
	cmp	ax,cx			; length to copy
	jbe	swems_doit		; go do it if <= total length
	mov	ax,cx			; else use total length
;
swems_doit:
	sub	cx,ax			; subtract copy length from total
	push	cx			; and save
	push	ax			; save the copy length in paras
	push	si
	push	di
	mov	cl,3
	shl	ax,cl			; convert to number of words (!)
	inc	cl
	shl	di,cl			; convert to byte address
	mov	cx,ax
	rep movsw
	pop	di
	pop	si
	pop	cx			; copy length in paras
	mov	ax,ds
	add	ax,cx			; add copy length to source segment
	add	di,cx			; and EMS page offset
	mov	ds,ax
	pop	cx			; remaining length
	or	cx,cx			; did we copy everything?
	jnz	swems_loop		; go loop if not
;
	pop	ds
	cmp	currdesc.num_follow,0	; another MCB?
	je	swems_complete		; exit if not
;
;	Another MCB follows, append nextmcb to save block.
;
	cmp	di,ems_parasize
	jb	swems_nonewpage		; no new block needed
	mov	ax,4400h		; map page, phys = 0
	int	EMM_INT
	or	ah,ah
	jnz	swems_error1
	mov	di,0
	inc	bx
;
swems_nonewpage:
	push	di
	mov	cl,4
	shl	di,cl			; convert to byte address
	mov	cx,TYPE mcbdesc
	mov	si,offset nextmcb
	rep movsb
	pop	di
	inc	di			; one paragraph
;
swems_complete:
	mov	ems_curpage,bx
	mov	ems_curoff,di
	xor	ax,ax
	ret
;
swems_error:
	pop	ds
swems_error1:
	mov	ah,45h			; release EMS pages on error
	int	EMM_INT
	mov	ax,RC_SWAPERROR
	or	ax,ax
	ret
;
swapout_ems	endp
;
;
;	swapout_xms:	swap out an MCB block to XMS.
;
;	Entry:	"currdesc" 	contains description of block to swap
;		"nextmcb"	contains MCB-descriptor of next block
;				if currdesc.num_follow is nonzero
;
;	Exit:	0 if OK, -1 if error, Zero-flag set accordingly.
;
;	Uses:	All regs excpt DS
;
swapout_xms	proc	near
;
	mov	ax,currdesc.swsize	; size in paragraphs
	mov	cl,4
	rol	ax,cl			; size in bytes + high nibble
	mov	dx,ax
	and	ax,0fff0h		; low word
	and	dx,0000fh		; high word
	mov	xmsctl.lenlo,ax		; into control block
	mov	xmsctl.lenhi,dx
	mov	xmsctl.srchnd,0		; source is normal memory
	mov	ax,currdesc.swoffset	; swap offset
	mov	xmsctl.srclo,ax		; into control block
	mov	ax,currdesc.addr	; segment to swap
	mov	xmsctl.srchi,ax
	mov	ax,prep.handle		; XMS handle
	mov	xmsctl.desthnd,ax
	mov	si,offset xmsctl
	mov	ah,0bh
	call	prep.xmm		; move it
	or	ax,ax
	jz	swxms_error
	mov	ax,xmsctl.lenlo		; adjust destination addr
	add	xmsctl.destlo,ax
	mov	ax,xmsctl.lenhi
	adc	xmsctl.desthi,ax
;
	cmp	currdesc.num_follow,0	; another MCB?
	je	swxms_complete
;
	mov	xmsctl.lenlo,TYPE mcbdesc
	mov	xmsctl.lenhi,0
	mov	xmsctl.srchi,ds
	mov	xmsctl.srclo,offset nextmcb
	mov	si,offset xmsctl
	mov	ah,0bh
	call	prep.xmm		; move it
	or	ax,ax
	jz	swxms_error
	add	xmsctl.destlo,16	; one paragraph
	adc	xmsctl.desthi,0
;
swxms_complete:
	xor	ax,ax
	ret
;
swxms_error:
	mov	ah,0ah			; release XMS frame on error
	mov	dx,prep.handle		; XMS handle
	call	prep.xmm
	mov	ax,RC_SWAPERROR
	or	ax,ax
	ret
;
swapout_xms	endp
;
;
;	swapout_file:	swap out an MCB block to file.
;
;	Entry:	"currdesc" 	contains description of block to swap
;		"nextmcb"	contains MCB-descriptor of next block
;				if currdesc.num_follow is nonzero
;
;	Exit:	0 if OK, -1 if error, Zero-flag set accordingly.
;
;	Uses:	All regs excpt DS
;
swapout_file	proc	near
;
	push	ds
	mov	cx,currdesc.swsize	; size in paragraphs
	mov	bx,prep.handle		; file handle
	mov	dx,currdesc.swoffset	; swap offset
	mov	ds,currdesc.addr	; segment to swap
;
swfile_loop:
	mov	ax,cx
	cmp	ah,8h			; above 32k?
	jbe	swfile_ok		; go write if not
	mov	ax,800h			; else write 32k
;
swfile_ok:
	sub	cx,ax			; remaining length
	push	cx			; save it
	push	ax			; and save paras to write
	mov	cl,4
	shl	ax,cl			; convert to bytes
	mov	cx,ax
	mov	ah,40h			; write
	int	21h
	jc	swfile_error
	cmp	ax,cx
	jne	swfile_error
	pop	cx			; paras written
	mov	ax,ds
	add	ax,cx			; bump up source segment
	mov	ds,ax
	pop	cx			; remaining length
	or	cx,cx			; anything left?
	jnz	swfile_loop		; go loop if yes
;
	pop	ds
	cmp	currdesc.num_follow,0	; another MCB?
	je	swfile_complete		; ready if not
	mov	cx,16			; write one paragraph
	mov	dx,offset nextmcb
	mov	ah,40h
	int	21h
	jc	swfile_error1
	cmp	ax,cx
	jne	swfile_error1
;
swfile_complete:
	xor	ax,ax
	ret
;
swfile_error:
	pop	cx
	pop	cx
	pop	ds
swfile_error1:
	mov	ah,3eh			; close file
	int	21h
	mov	dx,offset prep.swapfilename
	mov	ah,41h			; delete file
	int	21h
	mov	ax,RC_SWAPERROR
	or	ax,ax
	ret
;
swapout_file	endp
;
;--------------------------------------------------------------------------
;--------------------------------------------------------------------------
;
;
do_spawn	PROC	uses si di,swapping: word, execfname:ptr byte,params:ptr byte,envlen:word,envp:ptr byte
	local	datseg,pspseg,currmcb
;
	mov	datseg,ds		; save default DS
;
	mov	bx,_psp
	mov	pspseg,bx
;
;
;	Check if spawn is too low in memory
;
	mov	ax,cs
	mov	dx,offset lowcode_begin
	mov	cl,4
	shr	dx,cl
	add	ax,dx			; normalized start of this code
	mov	dx,keep_paras		; the end of the modified area
	add	dx,bx			; plus PSP = end paragraph
	cmp	ax,dx
	ja	doswap_ok	; ok if start of code > end of low mem
	mov	ax,RC_TOOLOW
	ret
;
doswap_ok:
	cmp	swapping,0
	jle	method_ok
;
;	check the swap method, to make sure prep_swap has been called
;
	mov	al,prep.swapmethod
	cmp	al,USE_EMS
	je	method_ok
	cmp	al,USE_XMS
	je	method_ok
	cmp	al,USE_FILE
	je	method_ok
	mov	ax,RC_BADPREP
	ret
;
;	Save the memory below the swap space.
;	We must do this before swapping, so the saved memory is
;	in the swapped out image.
;	Anything else we'd want to save on the stack or anywhere
;	else in "normal" memory also has to be saved here, any
;	modifications done to memory after the swap will be lost.
;
;	Note that the memory save is done even when not swapping,
;	because we use some of the variables in low core for
;	simplicity.
;
method_ok:
	push	ds
	pop	es
	push	ds
	mov	ds,pspseg		; DS points to PSP
	mov	si,5ch
	mov	di,offset save_dat
	mov	cx,savespace / 2	; NOTE: savespace is always even
	rep movsw
	pop	ds
;
	mov	ax,swapping
	cmp	ax,0
	jg	begin_swap
;
;	not swapping, prep_swap wasn't called. Init those variables in
;  	the 'prep' block we need in any case.
;
	mov	prep.swapmethod,al
	je	no_reduce
;
	mov	ax,pspseg
	dec	ax
	mov	prep.psp_mcb,ax
	mov	prep.first_mcb,ax
	inc	ax
	mov	es,ax
	mov	bx,es:psp_envptr
	mov	prep.env_mcb,bx
	mov	prep.noswap_mcb,0
	cmp	envlen,0
	jne	swp_can_swap_env
	mov	prep.noswap_mcb,bx
;
swp_can_swap_env:
	xor	bx,bx
	mov	es,bx
	mov	ah,52h			; get list of lists
	int	21h
	mov	ax,es
	or	ax,bx
	jz	no_reduce
	mov	es,es:[bx-2]		; first MCB
	cmp	es:id,4dh		; normal ID?
	jne	no_reduce
	mov	prep.first_mcb,es
;
no_reduce:
	jmp	no_swap1
;
;	set up first block descriptor
;
begin_swap:
	mov	ax,prep.first_mcb
	mov	currmcb,ax
	mov	es,prep.psp_mcb		; let ES point to base MCB
	mov	ax,es:paras
	mov	currdesc.msize,ax
	sub	ax,keep_paras
	mov	currdesc.swsize,ax
	mov	currdesc.addr,es
	mov	currdesc.swoffset,swapbeg + 16
;		NOTE: swapbeg is 1 para higher when seen from MCB
	mov	ax,prep.total_mcbs
	mov	currdesc.num_follow,ax
;
;	init other vars
;
	mov	xmsctl.destlo,0
	mov	xmsctl.desthi,0
	mov	ems_curpage,0
	mov	ems_curoff,ems_parasize
;
;	Do the swapping. Each MCB block (except the last) has an 
;	"mcbdesc" structure appended that gives location and size 
;	of the next MCB.
;
swapout_main:
	cmp	currdesc.num_follow,0	; next block?
	je	swapout_no_next		; ok if not
;
;	There is another MCB block to be saved. So we don't have
;	to do two calls to the save routine with complicated
;	parameters, we set up the next MCB descriptor beforehand.
;	Walk the MCB chain starting at the current MCB to find
;	the next one belonging to this process.
;
	mov	ax,currmcb
	mov	bx,pspseg
	mov	cx,prep.psp_mcb
	mov	dx,prep.noswap_mcb
;
swm_mcb_walk:
	mov	es,ax
	cmp	ax,cx
	je	swm_next_mcb
	cmp	ax,dx
	je	swm_next_mcb
;
	cmp	bx,es:owner		; our process?
	je	swm_mcb_found		; found it if yes
;
swm_next_mcb:
	cmp	es:id,4dh		; normal block?
	jne	swm_mcb_error		; error if end of chain
	add	ax,es:paras		; start + length
	inc	ax			; next MCB
	jmp	swm_mcb_walk
;
;	MCB found, set up an mcbdesc in the "nextmcb" structure
;
swm_mcb_found:
	mov	nextmcb.addr,es
	mov	ax,es:paras		; get number of paragraphs
	mov	nextmcb.msize,ax	; and save
	inc	ax
	mov	nextmcb.swsize,ax
	mov	bx,es
	add	bx,ax
	mov	currmcb,bx
	mov	nextmcb.swoffset,0
	mov	ax,currdesc.num_follow
	dec	ax
	mov	nextmcb.num_follow,ax
;
swapout_no_next:
	cmp	prep.swapmethod,USE_EMS
	je	swm_ems
	cmp	prep.swapmethod,USE_XMS
	je	swm_xms
	call	swapout_file
	jmp	short swm_next
;
swm_ems:
	call	swapout_ems
	jmp	short swm_next
;
swm_xms:
	call	swapout_xms
;
swm_next:
	jnz	swapout_error
	cmp	currdesc.num_follow,0
	je	swapout_complete
;
;	next MCB exists, copy the "nextmcb" descriptor into
;	currdesc, and loop.
;
	mov	es,datseg
	mov	si,offset nextmcb
	mov	di,offset currdesc
	mov	cx,TYPE mcbdesc
	rep movsb
	jmp	swapout_main
;
;
swm_mcb_error:
	cmp	prep.swapmethod,USE_FILE
	je	swm_mcberr_file
	cmp	prep.swapmethod,USE_EMS
	je	swm_mcberr_ems
;
	mov	ah,0ah			; release XMS frame on error
	mov	dx,prep.handle		; XMS handle
	call	prep.xmm
	mov	ax,RC_MCBERROR
	jmp	short swapout_error
;
swm_mcberr_ems:
	mov	dx,prep.handle		; EMS handle
	mov	ah,45h			; release EMS pages on error
	int	EMM_INT
	mov	ax,RC_MCBERROR
	jmp	short swapout_error
;
swm_mcberr_file:
	mov	ah,3eh			; close file
	mov	bx,prep.handle
	int	21h
	mov	dx,offset prep.swapfilename
	mov	ah,41h			; delete file
	int	21h
	mov	ax,RC_MCBERROR
;
swapout_error:
	ret
;
;
;	Swapout complete. Close the handle (EMS/file only),
;	then set up low memory.
;
swapout_complete:
	cmp	prep.swapmethod,USE_FILE
	jne	swoc_nofile
;
;	File swap: Close the swap file to make the handle available
;
	mov	bx,prep.handle
	mov	ah,3eh
	int	21h			; close file
	mov	si,offset swapin_file
	jnc	swoc_ready
	mov	ax,RC_SWAPERROR
	jmp	swapout_error
;
swoc_nofile:
	cmp	prep.swapmethod,USE_EMS
	jne	swoc_xms
;
;	EMS: Unmap page
;
	mov	ax,4400h
	mov	bx,-1
	mov	dx,prep.handle
	int	EMM_INT
	mov	si,offset swapin_ems
	jmp	short swoc_ready
;
swoc_xms:
	mov	si,offset swapin_xms
	jmp	short swoc_ready
;
no_swap1:
	mov	si,offset swapin_none
;	
;	Copy the appropriate swap-in routine to low memory.
;
swoc_ready:
	mov	es,pspseg
	mov	cx,swap_codelen / 2
	mov	di,codebeg + base_length
	push	ds
	mov	ax,cs
	mov	ds,ax
	rep movsw
;
;	And while we're at it, copy the MCB allocation routine (which
;	also includes the initial MCB release and exec call) down.
;
	mov	cx,base_length / 2
	mov	di,param_len
	mov	si,offset lowcode_begin
	rep movsw
;
	pop	ds
	mov	bx,es
	dec	bx
	mov	es,bx		; let ES point to base MCB
;
;	Again set up the base MCB descriptor, and copy it as well as
;	the variables set up by prep_swap to low memory.
;	This isn't too useful if we're not swapping, but it doesn't
;	hurt, either. The only variable used when not swapping is
;	lprep.swapmethod.
;
	mov	ax,es:paras
	mov	currdesc.msize,ax
	sub	ax,keep_paras
	mov	currdesc.swsize,ax
	mov	currdesc.addr,es
	mov	currdesc.swoffset,swapbeg + 16
	mov	ax,prep.total_mcbs
	mov	currdesc.num_follow,ax
;
	mov	es,pspseg		; ES points to PSP again
;
	mov	cx,TYPE prep_block
	mov	si,offset prep
	mov	di,lprep
	rep movsb
	mov	cx,TYPE mcbdesc
	mov	si,offset currdesc
	mov	di,lcurrdesc
	rep movsb
;
;	now set up other variables in low core
;
	mov	es:cgetmcb,getmcboff + codebeg
	mov	es:eretcode,0
	mov	es:retflags,0
;
;	Prepare exec parameter block
;
	mov	ax,es
	mov	es:expar.fcb1seg,ax
	mov	es:expar.fcb2seg,ax
	mov	es:expar.pparseg,ax
	mov	es:expar.envseg,0
;
;	The 'zero' word is located at 80h in the PSP, the start of
;	the command line. So as not to confuse MCB walking programs,
;	a command line length of zero is inserted here.
;
	mov	es:zero,0d00h		; 00h,0dh = empty command line
;
;	Init default fcb's by parsing parameter string
;
	IF	ptrsize
	lds	si,params
	ELSE
	mov	si,params
	ENDIF
	push	si
	mov	di,xfcb1
	mov	es:expar.fcb1,di
	push	di
	mov	cx,16
	xor	ax,ax
	rep stosw			; init both fcb's to 0
	pop	di
	mov	ax,2901h
	int	21h
	mov	di,xfcb2
	mov	es:expar.fcb2,di
	mov	ax,2901h
	int	21h
	pop	si
;
;	move command tail string into low core
;
	mov	di,progpars
	mov	es:expar.ppar,di
	xor	cx,cx
	inc	di
cmdcpy:
	lodsb
	or	al,al
	jz	cmdcpy_end
	stosb
	inc	cx
	jmp	cmdcpy
;
cmdcpy_end:
	mov	al,0dh
	stosb
	mov	es:progpars,cl
;
;	move filename string into low core
;
	IF	ptrsize
	lds	si,execfname
	ELSE
	mov	si,execfname
	ENDIF
	mov	di,filename
fncpy:
	lodsb
	stosb
	or	al,al
	jnz	fncpy
;
;	Setup environment copy
;
	mov	bx,keep_paras		; paras to keep
	mov	cx,envlen		; environment size
	jcxz	no_environ		; go jump if no environment
	cmp	swapping,0
	jne	do_envcopy
;
;	Not swapping, use the environment pointer directly.
;	Note that the environment copy must be paragraph aligned.
;
	IF	ptrsize
	mov	ax,word ptr (envp)+2
	mov	bx,word ptr (envp)
	ELSE
	mov	ax,ds
	mov	bx,envp
	ENDIF
	add	bx,15			; make sure it's paragraph aligned
	mov	cl,4
	shr	bx,cl			; and convert to segment addr
	add	ax,bx
	mov	es:expar.envseg,ax	; new environment segment
	xor	cx,cx			; mark no copy
	xor	bx,bx			; and no shrink
	jmp	short no_environ
;
;	Swapping or EXECing without return. Set up the pointers for
;	an environment copy (we can't do the copy yet, it might overwrite
;	this code).
;
do_envcopy:
	inc	cx
	shr	cx,1			; words to copy
	mov	ax,cx			; convert envsize to paras
	add	ax,7
	shr	ax,1
	shr	ax,1
	shr	ax,1
	add	bx,ax			; add envsize to paras to keep
	IF	ptrsize
	lds	si,envp
	ELSE
	mov	si,envp
	ENDIF
;
	mov	ax,es			; low core segment
	add	ax,keep_paras		; plus fixed paras
	mov	es:expar.envseg,ax	; = new environment segment
;
;	Save stack regs, switch to local stack
;
no_environ:
	mov	es:save_ss,ss
	mov	es:save_sp,sp
	mov	ax,es
	mov	ss,ax
	mov	sp,mystack
;
	push	cx			; save env length
	push	si			; save env pointer
	push	ds			; save env segment
;
;	save and patch INT0 (division by zero) vector
;
	xor	ax,ax
	mov	ds,ax
	mov	ax,word ptr ds:0
	mov	es:div0_off,ax
	mov	ax,word ptr ds:2
	mov	es:div0_seg,ax
	mov	word ptr ds:0,codebeg + iretoff
	mov	word ptr ds:2,es
;
	pop	ds			; pop environment segment
	pop	si			; pop environment offset
	pop	cx			; pop environment length
	mov	di,swapbeg		; environment destination
;
;	Push return address on local stack
;
	push	cs			; push return segment
	mov	ax,offset exec_cont
	push	ax			; push return offset
	mov	es:spx,sp		; save stack pointer
;
;	Goto low core code
;
	push	es			; push entry segment
        mov	ax,codebeg + doexec_entry
        push	ax			; push entry offset
;	ret	far			; can't use RET here because
	db	0cbh			; of .model
;
;----------------------------------------------------------------
;
;	Low core code will return to this location, with DS set to
;	the PSP segment.
;
exec_cont:
	push	ds
	pop	es
	mov	ss,ds:save_ss		; reload stack
	mov	sp,ds:save_sp
;
;	restore INT0 (division by zero) vector
;
	xor	cx,cx
	mov	ds,cx
	mov	cx,es:div0_off
	mov	word ptr ds:0,cx
	mov	cx,es:div0_seg
	mov	word ptr ds:2,cx
;
	mov	ax,es:eretcode
	mov	bx,es:retflags
	mov	ds,datseg
;
;	Restore overwritten part of program
;
	mov	si,offset save_dat
	mov	di,5ch
	mov	cx,savespace
	rep movsb
;
	test	bx,1			; carry set?
	jnz	exec_fault		; return EXEC error code if fault
	mov	ah,4dh			; else get program return code
	int	21h
	ret
;
exec_fault:
	mov	ah,3			; return error as 03xx
	ret
;	
do_spawn	ENDP
;
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;
emm_name	db	'EMMXXXX0'
;
;	prep_swap - prepare for swapping.
;
;	This routine checks all parameters necessary for swapping,
;	and attempts to set up the swap-out area in EMS/XMS, or on file.
;	In detail:
;
;	     1) Check whether the do_spawn routine is located
;		too low in memory, so it would get overwritten.
;		If this is true, return an error code (-2).
;
;	     2) Walk the memory control block chain, adding up the
;		paragraphs in all blocks assigned to this process.
;
;	     3) Check EMS (if the method parameter allows EMS):
;		- is an EMS driver installed?
;		- are sufficient EMS pages available?
;		if all goes well, the EMS pages are allocated, and the
;		routine returns success (1).
;
;	     4) Check XMS (if the method parameter allows XMS):
;		- is an XMS driver installed?
;		- is a sufficient XMS block available?
;		if all goes well, the XMS block is allocated, and the
;		routine returns success (2).
;
;	     5) Check file swap (if the method parameter allows it):
;		- try to create the file
;		- pre-allocate the file space needed by seeking to the end
;		  and writing a byte.
;		If the file can be written, the routine returns success (4).
;
;	     6) Return an error code (-1).
;
prep_swap	PROC	uses si di,pmethod:word,swapfname:ptr byte
	LOCAL	totparas: word
;
	mov	ax,_psp
;
	dec	ax
	mov	prep.psp_mcb,ax
	mov	prep.first_mcb,ax	; init first MCB to PSP
;
;	Make a copy of the environment pointer in the PSP
;
	inc	ax
	mov	es,ax
	mov	bx,es:psp_envptr
	dec	bx
	mov	prep.env_mcb,bx
	mov	prep.noswap_mcb,0
	test	pmethod,DONT_SWAP_ENV
	jz	can_swap_env
	mov	prep.noswap_mcb,bx
;
;	Check if spawn is too low in memory
;
can_swap_env:
	mov	bx,cs
	mov	dx,offset lowcode_begin
	mov	cl,4
	shr	dx,cl
	add	bx,dx			; normalized start of this code
	mov	dx,keep_paras		; the end of the modified area
	add	dx,ax			; plus PSP = end paragraph
	cmp	bx,dx
	ja	prepswap_ok	; ok if start of code > end of low mem
	mov	ax,-2
	mov	prep.swapmethod,al
	ret
;
;	Walk the chain of memory blocks, adding up the paragraphs
;	in all blocks belonging to this process.
;	We try to find the first MCB by getting DOS's "list of lists",
;	and fetching the word at offset -2 of the returned address.
;	If this fails, we use our PSP as the starting point.
;
prepswap_ok:
	xor	bx,bx
	mov	es,bx
	mov	ah,52h			; get list of lists
	int	21h
	mov	ax,es
	or	ax,bx
	jz	prep_no_first
	mov	es,es:[bx-2]		; first MCB
	cmp	es:id,4dh		; normal ID?
	jne	prep_no_first
	mov	prep.first_mcb,es
;
prep_no_first:
	mov	es,prep.psp_mcb		; ES points to base MCB
	mov	cx,es			; save this value
	mov	bx,es:owner		; the current process
	mov	dx,es:paras		; memory size in the base block
	sub	dx,keep_paras		; minus resident paragraphs
	mov	si,0			; number of MCBs except base
	mov	di,prep.noswap_mcb
	mov	ax,prep.first_mcb
	mov	prep.first_mcb,0
;
prep_mcb_walk:
	mov	es,ax
	cmp	ax,cx			; base block?
	je	prep_walk_next		; then don't count again
	cmp	ax,di			; Non-swap MCB?
	je	prep_walk_next		; then don't count
;
	cmp	bx,es:owner		; our process?
	jne	prep_walk_next		; next if not
	inc	si
	mov	ax,es:paras		; else get number of paragraphs
	add	ax,2			; + 1 for descriptor + 1 for MCB
	add	dx,ax			; total number of paras
	cmp	prep.first_mcb,0
	jne	prep_walk_next
	mov	prep.first_mcb,es
;
prep_walk_next:
	cmp	es:id,4dh		; normal block?
	jne	prep_mcb_ready		; ready if end of chain
	mov	ax,es
	add	ax,es:paras		; start + length
	inc	ax			; next MCB
	jmp	prep_mcb_walk
;
prep_mcb_ready:
	mov	totparas,dx
	mov	prep.total_mcbs,si
;
	test	pmethod,XMS_FIRST
	jnz	check_xms
;
;	Check for EMS swap
;
check_ems:
	test	pmethod,USE_EMS
	jz	prep_no_ems
;
	push	ds
	mov	al,EMM_INT
	mov	ah,35h
	int	21h			; get EMM int vector
	mov	ax,cs
	mov	ds,ax
	mov	si,offset emm_name
	mov	di,10
	mov	cx,8
	repz cmpsb			; EMM name present?
	pop	ds
	jnz	prep_no_ems
;
	mov	ah,40h			; get EMS status
	int	EMM_INT
	or	ah,ah			; EMS ok?
	jnz	prep_no_ems
;
	mov	ah,46h			; get EMS version
	int	EMM_INT
	or	ah,ah			; AH must be 0
	jnz	prep_no_ems
;
	cmp	al,30h			; >= version 3.0?
	jb	prep_no_ems
;
	mov	ah,41h			; Get page frame address
	int	EMM_INT
	or	ah,ah
	jnz	prep_no_ems
;
;	EMS present, try to allocate pages
;
	mov	prep.ems_pageframe,bx
	mov	bx,totparas
	add	bx,ems_paramask
	mov	cl,ems_shift
	shr	bx,cl
	mov	ah,43h			; allocate handle and pages
	int	EMM_INT
	or	ah,ah			; success?
	jnz	prep_no_ems
;
;	EMS pages allocated, swap to EMS
;
	mov	prep.handle,dx
	mov	ax,USE_EMS
	mov	prep.swapmethod,al
	ret
;
;	No EMS allowed, or EMS not present/full. Try XMS.
;
prep_no_ems:
	test	pmethod,XMS_FIRST
	jnz	check_file		; don't try again
;
check_xms:
	test	pmethod,USE_XMS
	jz	prep_no_xms
;
	mov	ax,4300h		; check if XMM driver present
	int	2fh
	cmp	al,80h			; is XMM installed?
	jne	prep_no_xms
	mov	ax,4310h		; get XMM entrypoint
	int	2fh
	mov	word ptr prep.xmm,bx	; save entry address
	mov	word ptr prep.xmm+2,es
;
	mov	dx,totparas
	add	dx,xms_paramask		; round to nearest multiple of 1k
	mov	cl,xms_shift
	shr	dx,cl			; convert to k
	mov	ah,9			; allocate extended memory block
	call	prep.xmm
	or	ax,ax
	jz	prep_no_xms
;
;	XMS block allocated, swap to XMS
;
	mov	prep.handle,dx
	mov	ax,USE_XMS
	mov	prep.swapmethod,al
	ret
;
;	No XMS allowed, or XMS not present/full. Try File swap.
;
prep_no_xms:
	test	pmethod,XMS_FIRST
	jz	check_file
	jmp	check_ems
;
check_file:
	test	pmethod,USE_FILE
	jnz	prep_do_file
	jmp	prep_no_file
;
prep_do_file:
	push	ds
	IF	ptrsize
	lds	dx,swapfname
	ELSE
	mov	dx,swapfname
	ENDIF
	mov	cx,2			; hidden attribute
	test	pmethod,HIDE_FILE
	jnz	prep_hide
	xor	cx,cx			; normal attribute
;
prep_hide:
	mov	ah,3ch			; create file
	test	pmethod,CREAT_TEMP
	jz	prep_no_temp
	mov	ah,5ah
;
prep_no_temp:
	int	21h			; create/create temp
	jnc	prep_got_file
	jmp	prep_no_file
;
prep_got_file:
	mov	bx,ax			; handle
;
;	save the file name
;
	pop	es
	push	es
	mov	di,offset prep.swapfilename
	mov	cx,81
	mov	si,dx
	rep movsb
;
	pop	ds
	mov	prep.handle,bx
;
;	preallocate the file
;
	test	pmethod,NO_PREALLOC
	jnz	prep_noprealloc
	test	pmethod,CHECK_NET
	jz	prep_nonetcheck
;
;	check whether file is on a network drive, and don't preallocate
;	if so. preallocation can slow down swapping significantly when
;	running on certain networks (Novell)
;
	mov	ax,440ah	; check if handle is remote
	int	21h
	jc	prep_nonetcheck	; assume not remote if function fails
	test	dh,80h		; DX bit 15 set ?
	jnz	prep_noprealloc	; remote if yes
;
prep_nonetcheck:
	mov	dx,totparas
	mov	cl,4
	rol	dx,cl
	mov	cx,dx
	and	dx,0fff0h
	and	cx,0000fh
	sub	dx,1
	sbb	cx,0
	mov	si,dx			; save
	mov	ax,4200h		; move file pointer, absolute
	int	21h
	jc	prep_file_err
	cmp	dx,cx
	jne	prep_file_err
	cmp	ax,si
	jne	prep_file_err
	mov	cx,1			; write 1 byte
	mov	ah,40h
	int	21h
	jc	prep_file_err
	cmp	ax,cx
	jne	prep_file_err
;
	mov	ax,4200h		; move file pointer, absolute
	xor	dx,dx
	xor	cx,cx			; rewind to beginning
	int	21h
	jc	prep_file_err
;
prep_noprealloc:
	mov	ax,USE_FILE
	mov	prep.swapmethod,al
	ret
;
prep_file_err:
	mov	ah,3eh			; close file
	int	21h
	mov	dx,offset prep.swapfilename
	mov	ah,41h			; delete file
	int	21h
;
prep_no_file:
	mov	ax,-1
	mov	prep.swapmethod,al
	ret
;
prep_swap	endp
;
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pipe.c ===
/*
 *  pipe()
 *	Xenix pipe using 286DOS call.  Try to make a 16K pipe, then halve
 *	request until success.	Minimum pipe is 512 bytes.
 *	    If not enough core for pipe, set errno to ENOMEM.
 *	    If not enough file handles,  set errno to EMFILE.
 *
*/

#define INCL_DOSQUEUES

#include <os2.h>
#include "..\h\tools.h"
#include <errno.h>


// extern int errno;
#define ERROR_NOT_ENOUGH_MEMORY 8

pipe( pd )
int pd[2];
{
    unsigned psize = 16384;
    int retc;


	do
	{
	    retc = DosMakePipe( (unsigned far *)&pd[0],
				(unsigned far *)&pd[1],
				psize  );
	} while ( retc == ERROR_NOT_ENOUGH_MEMORY  &&  (psize /= 2) > 256);


	if ( retc )
	{
	    if ( retc == ERROR_NOT_ENOUGH_MEMORY )  errno = ENOMEM;
	    else				    errno = EMFILE;

	    return -1;
	}


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pgetl.c ===
/*
 *  18-Feb-1987  bw Fix off-by-one errors.
 *  22-Dec-1987  bw Fix strncrlf hang, redo buffer handling.
 *		    Pay attention to max argument
 *---------------------------------------------------------------------------
 *
 *  pgetl.c - do fgetl() from a pipe without blocking. In particular, do this:
 *
 *	    If ( Buffer is empty )
 *		Fill Buffer
 *	    If ( 0 length request ) return ( there is more data )?
 *	    { - 1 allows for '\0' byte in target }
 *	    set max to min(max - 1, count of valid bytes);
 *	    If ( "full line" is buffered )
 *		Transfer Full line.
 *		Clean up and go
 *	    Move partial line to base of buffer
 *	    Fill rest of buffer
 *	    If ( we have a "full line" now ) transfer it
 *	    Else
 *		return	FALSE
 *
 *	A "full line" is either LF terminated or len bytes long, whichever
 *	comes first.
 *
 *	The Fill Buffer method is this:
 *
 *	    Set Read Semaphore
 *	    Read Asynch
 *	    Wait on Read Semaphore with Timeout ( ~.1 seconds )
 *
 *  Note that if a 0 length read is requested, the effect is to check for
 *  unread data.
 *
 *  Note that if the destination buffer is NULL, one line is read and flushed.
*/
#include <os2.h>
#include "..\h\tools.h"


static int FilBuf( int, char *, int );


pgetl ( buf, max, fh )
char *buf;
int max;
int fh;
{
    static char buffer[BUFSIZ];
    static int cnt = 0; 	    /* Valid bytes remaining in buffer	     */
    static char * pValid = buffer;  /* First valid byte 		     */
    char * eos;


	if ( ! cnt )
	    if ( ! (cnt = FilBuf( fh, buffer, BUFSIZ )) ) return FALSE;
	    else pValid = buffer;

	/* There is now at least 1 character in buffer */

	if ( ! max-- ) return cnt;    /* max == 0 means ret unread chars    */
				      /* dec max for '\0' byte		    */
	max = min( max , BUFSIZ );

	/* Check for full line already present */
	if ( (eos = strncrlfend(pValid, cnt))  ||  max <= cnt ) goto full_line;

	/* Move partial line down to base of buffer */
	Move ((char far *)pValid, (char far *)buffer, cnt);
	pValid = buffer;

	cnt += FilBuf( fh, buffer + cnt, BUFSIZ - cnt );

	if ( (eos = strncrlfend(buffer, cnt))  ||  max <= cnt ) goto full_line;

	return FALSE;


full_line:
	{
	  int linelen, deadchars;

	    if ((linelen = eos ? eos - pValid : max) > max)
		linelen = max;


	    if ( buf ) /* Give user their line, if they want it */
	    {
		Move( (char far *)pValid, (char far *)buf, linelen );
		buf[linelen] = '\0';
	    }


	    deadchars = linelen + (eos != 0) + (eos && *eos == '\r');
	    cnt -= deadchars;

	    /* Now remove it from my buffer */
	    pValid += deadchars;

	    return TRUE;
	}
}


/*
 *  strncrlfend - Return a pointer to the first of:
 *
 *	    The CR in a CR/LF pair
 *	    A lone LF
 *	    The 0 byte.
 *
 *  or return NULL if none of these can be found in the first 'max' characters.
 *
 *  Note: If the LF in a CR/LF pair is the 'max' + 1st character, return NULL.
*/
char * strncrlfend( str, max )
char * str;
int max;
{
    int i;

	for (i = 0; i < max; i++)
	    if (!str[i] || str[i] == '\n')
		    return str + i - (i && str[i-1] == '\r');

	return NULL;
}


/*
 *  FilBuf - read from handle, assuming that the read may block.  If the block
 *  last more than .1 seconds, return 0 bytes read.  In this case, assume that
 *  the caller is willing to have 'buf' filled at some random later time.
*/
static int FilBuf( fh, buf, amt )
int fh;
char * buf;
int amt;
{
    static unsigned long semRead;
    static unsigned BytesRead, retC;
    static flagType pending = FALSE;

	if ( ! pending )
	{
	    DosSemSet ( (HSEM)&semRead );

	    DosReadAsync (   fh,
			    (unsigned long far *)&semRead,
			    (PUSHORT)&retC,
			    (char far *)buf,
			    amt,
			    (PUSHORT)&BytesRead       );
	}

	if ( DosSemWait ( (HSEM)&semRead, 100L ) )
	{
	    pending = TRUE;
	    return 0;
	}
	else
	{
	    pending = FALSE;
	    return BytesRead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\scrolldn.asm ===
;
; Scroll a region of the screen down
;
;   09-Dec-1986 bw - Added DOS 5 support


.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\subcalls.inc
endif
.list

sBegin code

assumes cs,code

;
;
; ScrollDn (x1, y1, x2, y2, n, a) scrolls a region down with attribute
;
ifdef  OS2
cProc	ScrollDn,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmW	n
parmW	a
else
cProc	ScrollDn,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2
parmB	y2
parmB	n
parmB	a
endif
cBegin

ifdef OS2
	push	y1
	push	x1
	push	y2
	push	x2
	push	n

	mov	ax,a		;OS/2 expects a Cell => ATTR | VALUE
	xchg	ah,al
	mov	al,' '
	mov	a,ax

	push	ss
	lea	ax,  a		; Assume SS == DS
	push	ax
	xor	ax, ax
	push	ax		; VIO handle
	call	VIOSCROLLDN
else
	mov	ah,7

	mov	cl,x1
	mov	ch,y1

	mov	dl,x2
	mov	dh,y2

	mov	bh,a

	mov	al,n
	push	bp
	int	10h
	pop	bp
endif

cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\scrollup.asm ===
;
; Scroll a region of the screen up
;
;   09-Dec-1986 bw - Added DOS 5 support



.xlist
include ..\h\cmacros.inc
ifdef OS2
include ..\h\subcalls.inc
endif
.list

sBegin code

assumes cs,code

;
;
; ScrollUp (x1, y1, x2, y2, n, a) scrolls a region up with attribute
;
ifdef OS2
cProc	ScrollUp,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmW	n
parmW	a
else
cProc	ScrollUp,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2
parmB	y2
parmB	n
parmB	a
endif
cBegin

ifdef OS2
	push	y1
	push	x1
	push	y2
	push	x2
	push	n

	mov	ax,a		    ;OS/2 expects a Cell => ATTR | VALUE
	xchg	ah,al
	mov	al,' '
	mov	a,ax

	push	ss
	lea	ax, a		    ; Assume SS == DS
	push	ax
	xor	ax, ax
	push	ax		    ; VIO handle
	call	VIOSCROLLUP
else
	mov	ah,6

	mov	cl,x1
	mov	ch,y1

	mov	dl,x2
	mov	dh,y2

	mov	bh,a

	mov	al,n
	push	bp
	int	10h
	pop	bp
endif

cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\rspawn.c ===
/* start a child task but do it with stdin/stdout redirected
 * this relies on the assumption that by duping 0 and 1, the child will NOT
 * attempt to access handles other than 0,1 and those that it has opened
 *
 * OS/2 -   The process will be executed asynchronously.  In addition, support
 *	    for redirection from/to pipes is added.  If fin or fout is the
 *	    string <pipe>, then a new pipe will be created and attached to the
 *	    new processes input or ouput.  If the form is <ascii-number> then
 *	    the input/output will be attached to handle #ascii-number.	This
 *	    number will usually be the the read or write handle of an open
 *	    pipe.
 *		The values will be returned in a static structure.  Both read
 *	    and write handles for pipes will be open on return.
 */

#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include "..\h\tools.h"

#if defined(OS2)
struct spawnInfo * rspawnl (fin, fout, name, args)
#else
int rspawnl (fin, fout, name, args)
#endif
char *fin, *fout, *name, *args;
{
    return rspawnv (fin, fout, name, &args);
}

#if defined(OS2)
struct spawnInfo * rspawnv (fin, fout, name, parg)
#else
int rspawnv (fin, fout, name, parg)
#endif
char *fin, *fout, *name, *parg[];
{
#if defined(OS2)
    static struct spawnInfo retval;
    int inh = -1, outh = -1;
/*  extern unsigned char _osmode; */
#endif
    int savin, savout, saverr, ret;

    ret = -1;
#if defined(OS2)
	retval.inReadHndl = -1;
	retval.inWriteHndl = -1;
	retval.outReadHndl = -1;
	retval.outWriteHndl = -1;
#endif


    if (fin) {
#if defined(OS2)
	if (_osmode)
	{
	    if ( *fin == '<' )
	    {
		if ( !stricmp( fin, "<pipe>" ) )
		{
		    if ( pipe( &retval.inReadHndl ) ) goto error;
		}
		else retval.inReadHndl = atoi(fin + 1);

		inh = retval.inReadHndl;
	    }
	    else if ( (inh = open (fin, O_RDONLY | O_TEXT)) == -1 ) goto error;

	    savin = dup(0);
	    close(0);
	    dup(inh);
	    if ( *fin != '<' ) close(inh);
	}
	else
	{
#endif
	savin = dup (0);
	close(0);
	if (open (fin, O_RDONLY | O_TEXT) == -1)
	     goto done;
	}
#if defined(OS2)
	}
#endif

    if (fout) {
#if defined(OS2)
	if (_osmode)
	{
	    if ( *fout == '<' )
	    {
		if ( !stricmp( fout, "<pipe>" ) )
		{
		    if ( pipe(&retval.outReadHndl) ) goto error;
		}
		else retval.outWriteHndl = atoi(fout + 1);

		outh = retval.outWriteHndl;
	    }
	    else if ( (outh = open (fout, O_CREAT | O_TRUNC | O_WRONLY | O_TEXT,
					  S_IWRITE | S_IREAD)) == -1 ) goto error;

	    savout = dup(1);
	    saverr = dup(2);
	    close(1);
	    dup(outh);
	    close(2);
	    dup(1);
	    if ( *fout != '<' ) close(outh);
	}
	else
	{
#endif
	savout = dup (1);
	saverr = dup (2);
	close(1);
	if (open (fout, O_CREAT | O_TRUNC | O_WRONLY | O_TEXT,
			S_IWRITE | S_IREAD) == -1 )
	     goto done;
	close (2);
	dup (1);
	}
#if defined(OS2)
	}
#endif

#if defined(OS2)
    if (_osmode)
	retval.PID = spawnvp( P_NOWAIT, name, parg);
    else
#endif
    ret = spawnvp (P_WAIT, name, parg);

done:
    if (fin) {
	close(0);
	dup(savin);
	close(savin);
	}
    if (fout) {
	close(1);
	dup(savout);
	close(savout);
	close (2);
	dup (saverr);
	close (saverr);
	}
#if defined(OS2)
    if (_osmode)
    {
	if ( retval.PID == -1 )
	{
	    if ( retval.inReadHndl != -1 )
	    {
		close( retval.inReadHndl );
		close( retval.inWriteHndl );
		retval.inReadHndl = -1;
		retval.inWriteHndl = -1;
	    }
	    if ( retval.outReadHndl != -1 )
	    {
		close( retval.outReadHndl );
		close( retval.outWriteHndl );
		retval.outReadHndl = -1;
		retval.outWriteHndl = -1;
	    }
	}

    return &retval;
    }
#endif

#if defined(OS2)
error:
    retval.PID = 0xFFFF;
    return &retval;
#else
    return ret;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\pname.c ===
/***	pname.c - form a "pretty" version of a user file name
 *
 *	OS/2 v1.2 and later will allow filenames to retain the case
 *	when created while still being case insensitive for all operations.
 *	This allows the user to create more visually appealing file names.
 *
 *	All runtime routines should, therefore, preserve the case that was
 *	input.	Since the user may not have input in the case that the entries
 *	were created, we provide a service whereby a pathname is adjusted
 *	to be more visually appealing.	The rules are:
 *
 *	if (real mode)
 *	    lowercase the sucker
 *	else
 *	if (version is <= 1.1)
 *	    lowercase the sucker
 *	else
 *	if (filesystem is FAT)
 *	    lowercase the sucker
 *	else
 *	    for each component starting at the root, use DosFindFirst
 *		to retrieve the original case of the name.
 *
 *	Modifications:
 *	    10-Oct-1989 mz  First implementation
 *
 */

#if defined (OS2)
#define INCL_ERRORS
#define INCL_DOSFILEMGR
#define INCL_DOSMODULEMGR
#include <os2.h>
#endif

#include <string.h>
#include <stdlib.h>
#include <malloc.h>

#include "..\h\tools.h"

char *pname (char *pszName)
{
#if defined (DOS)
    return strlwr (pszName);
#else
    if (!IsMixedCaseSupported (pszName))
	return strlwr (pszName);

    /*	The underlying file system supports mixed case.  Iterate through
     *	the path doing find-firsts to elicit the correct case from the
     *	file system
     */
    {
#if defined(OS2)
	HDIR		hdir;
	FILEFINDBUF	findbuf;
#elif defined(NT)
	HANDLE		hdir;
	WIN32_FIND_DATA findbuf;
#endif
	unsigned int	cFound;
	char *pszSrc, *pszDst, *pszEnd, chEnd;

	/*  skip drive and leading / if present */
	pszDst = pszName;
	if (pszDst[1] == ':')
	    pszDst += 2;

	/*  We skip to first filename component.  If the path is UNC, then
	 *  we skip over machine name and sharename and LC them.
	 */

	if (fPathChr (*pszDst)) {
	    pszDst++;
	    if (fPathChr (*pszDst)) {
		pszDst = strbscan (pszDst + 1, "/\\");
		if (*pszDst != '\0')
		    pszDst = strbscan (pszDst + 1, "/\\");

		/*  pszDst points to the slash following the share name or
		 *  points to '\0' for mere computer or computer\share
		 */
		chEnd = *pszDst;
		*pszDst = '\0';
		strlwr (pszName);
		if ((*pszDst++ = chEnd) == '\0')
		    return pszName;
		}
	    }

	/*  If we are pointing at the root, just give up
	 */
	if (*pszDst == '\0')
	    return pszName;

	/*  pszDst points to first char of first component
	 */

	pszSrc = pszDst;
	while (TRUE) {
	    /*	Find and terminate next component after pszSrc
	     */
	    pszEnd = strbscan (pszSrc, "/\\");
	    chEnd = *pszEnd;
	    *pszEnd = 0;

	    /*	Pack next component up against pszDst
	     */
	    strcpy (pszDst, pszSrc);

	    /*	Use DosFindFirst to return "canonical" case-correct
	     *	version of last component EXCEPT if meta chars present
	     */
#if defined(OS2)
	    hdir = HDIR_CREATE;
#endif
	    cFound = 1;
	    if (*strbscan (pszDst, "*?") == 0 &&
		strcmp (pszDst, ".") && strcmp (pszDst, "..") &&
#if defined(OS2)
		DosFindFirst2 (pszName,
			      &hdir,
			      FILE_HIDDEN + FILE_SYSTEM + FILE_DIRECTORY,
			      &findbuf,
			      sizeof (findbuf),
			      &cFound,
			      FIL_STANDARD,
			      0L) == 0
#elif defined(NT)
		( ( hdir = FindFirstFile( pszName, &findbuf ) ) != (HANDLE)-1 )
#endif
		) {
		/*  The entry was found and is valid.  Go and
		 *  copy it from the returned buffer
		 */
#if defined(OS2)
#define FOUNDNAME   findbuf.achName
#elif defined(NT)
#define FOUNDNAME   findbuf.cFileName
#endif
		strcpy (pszDst, FOUNDNAME);

		/*  Release search handle
		 */
#if defined(OS2)
#define CLOSEFIND   DosFindClose
#elif defined(NT)
#define CLOSEFIND   FindClose
#endif
		CLOSEFIND (hdir);
		}
	    else
		/*  Meta char present or search did not find file
		 *  Just leave it alone
		 */
		;

	    /*	pszName points to name being constructed
	     *	pszDst	points to correctly-formed last component
	     *	chEnd	contains character that terminated last component
	     *	pszEnd	is where chEnd was retrieved from
	     */

	    /*	Terminate newly found component
	     */
	    pszDst += strlen (pszDst);
	    *pszDst++ = '\\';

	    /*	If we were at end of string,
	     *	then we're all done
	     */
	    if (chEnd == '\0') {
		pszDst[-1] = '\0';
		break;
		}

	    /*	Set pszSrc to point to beginning of next component
	     *	We can do this because we haven't seen a terminating NUL
	     */
	    pszSrc = pszEnd + 1;
	    }
	return pszName;
    }
#endif
}

#if defined (OS2) || defined(NT)
/*	IsMixedCaseSupported - determine if a file system supports mixed case
 *
 *	We presume that all OS's prior to OS/2 1.2 or FAT filesystems
 *	do not support mixed case.  It is up to the client to figure
 *	out what to do.
 *
 *	We presume that non FAT filesystems on 1.2 and later DO support mixed
 *	case
 *
 *	We do some caching to prevent redundant calls to the file systems.
 *
 *	returns     TRUE    (MCA_SUPPORT) if it is supported
 *		    FALSE   (MCA_NOTSUPP) if unsupported
 *
 */
#define MCA_UNINIT	123
#define MCA_SUPPORT	TRUE
#define MCA_NOTSUPP	FALSE

static	USHORT mca[27] = { MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
			   MCA_UNINIT, MCA_UNINIT, MCA_UNINIT };

USHORT (pascal far *pDosQPathInfo) (PSZ, USHORT, PBYTE, USHORT, ULONG);

USHORT static QueryMixedCaseSupport (char *psz)
{
#if defined(NT)
    psz;	//unreferenced

    return MCA_NOTSUPP;
#elif defined(OS2)

    UCHAR *pUpdPath;
    FILESTATUS fsts;
    USHORT erc;

    /*	If OS/2 before 1.2, presume no mixed case support
     */
    if (_osmajor < 10 || (_osmajor == 10 && _osminor < 2))
	return MCA_NOTSUPP;

    /*	Attach to v1.2 function
     */
    if (pDosQPathInfo == NULL) {
	HMODULE hmod;

	if (DosGetModHandle ("DOSCALLS", &hmod) != 0)
	    return MCA_NOTSUPP;

	if (DosGetProcAddr (hmod, "#98", (PPFN) &pDosQPathInfo) != 0) {
	    pDosQPathInfo = NULL;
	    return MCA_NOTSUPP;
	    }
	}

    pUpdPath = (*tools_alloc) (MAXPATHLEN);
    if (pUpdPath == NULL)
	return MCA_NOTSUPP;

    /*	Replace lowest path component with "." to force a directory
     */
    upd (psz, ".", pUpdPath);

    /*	Retrieve timestamp info
     */
    erc = (*pDosQPathInfo) (pUpdPath,
			    FIL_STANDARD,
			    (PBYTE) &fsts,
			    sizeof (fsts),
			    0L);
    free (pUpdPath);

    /*	If no error and if there was a creation time on the dir
     *	then we presume the mixed case is supported
     */
    if (erc == NO_ERROR && MAKETYPE (fsts.fdateCreation, USHORT) != 0)
	return MCA_SUPPORT;
    else
	return MCA_NOTSUPP;
#endif
}

USHORT IsMixedCaseSupported (char *psz)
{
    USHORT mcaSupp;
    unsigned int uDrvOrd;
    BOOL fUNC;
#if defined (OS2)
    ULONG  ulDrvMap;
#endif

    fUNC = (fPathChr (psz[0]) && fPathChr (psz[1])) ||
	    (psz[0] != 0 && psz[1] == ':' &&
	     fPathChr (psz[2]) && fPathChr (psz[3]));

    /*	Obtain drive ordinal and return cached value if valid
     */
    if (!fUNC) {
	if (psz[0] != 0 && psz[1] == ':')
	    uDrvOrd = (psz[0] | 0x20) - 'a' + 1;
	else {
#if defined (OS2)
	    DosQCurDisk (&uDrvOrd, &ulDrvMap);
#elif defined(NT)
            char buf[5];

            GetCurrentDirectory( 5, buf );
	    uDrvOrd = ( buf[0] | 0x20 ) - 'a' + 1;
#endif
	}

	if (mca[uDrvOrd] != MCA_UNINIT)
	    return mca[uDrvOrd];
	}

    /*	Get support value
     */
    mcaSupp = QueryMixedCaseSupport (psz);

    if (!fUNC)
	mca[uDrvOrd] = mcaSupp;

    return mcaSupp;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\root.c ===
/*  root.c - generate a path to a file from the root
 *
 *  Modifications:
 *
 *	30-Jul-1986 mz	Add sensitivity for network names
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *      18-Oct-1990 w-barry  Fixed case where '..' is passed in.  Function
 *                           now returns 'x:\' instead of 'x:' where x is a
 *                           drive letter.
 */

#include "..\h\tools.h"
#include <string.h>
#include <ctype.h>


/*  rootpath - construct a path from the root to the specified file
 *  correctly handling ., .. and current directory/drive references.
 *
 *  src 	source path for input
 *  dst 	destination buffer
 *  returns	TRUE if error detected
 */
rootpath (src, dst)
char *src, *dst;
{
#if defined(NT)

    LPSTR FilePart;

    return (!GetFullPathName( (LPSTR) src,
                              (DWORD) MAX_PATH,
                              (LPSTR) dst,
			      &FilePart ));

#else
    char *beg = dst;
    register char *p, *p1;
    char d;

    p = src;
    if (src[0] && src[1] == ':') {
	*p = (char) tolower (*p);
	p += 2;
	}
    if (!fPathChr (p[0]) || !fPathChr (p[1])) {
	d = 0;
	if (*src && src[1] == ':') {
	    d = (char) (toupper (*src) - 'A' + 1);
	    src += 2;
	    }
	if (curdir (dst, d))
	    /* invalid drive */
	    return TRUE;
	/* dst = cur dir on drive d, so now bump across d: */
	dst += 2;
	if (*src == '.' && (src[1] == '\0' ||
			    (fPathChr (src[1]) && src[2] == '\0')))
	    /* src == "." or ".\", i.e cur dir, we are done */
	    return FALSE;
	}
    else
	src = p;

    if (fPathChr (*src))
	strcpy (dst, src);
    else {
	d = dst[strlen(dst)-1];
	if (!fPathChr (d))
	    strcat (dst, PSEPSTR);
	strcat (dst, src);
	}
    p1 = src = dst;
    while (*src) {
	p1 = strbscan (p=p1, "\\/");
	d = *p1;
	*p1++ = 0;
	if (!strcmp (p, ".")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else
	if (!strcmp (p, "..")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else {
	    strcpy (dst, p);
	    dst += strlen (dst);
	    }
	if (fPathChr (d))
	    d = PSEPCHR;
	if (!(*dst++ = d))
	    break;
	}
    // If '..' was passed in one level above the root dir, beg at this point
    // will contain '<drive_letter>:' which will not be treated as a valid
    // directory - To account for this, add a '\' character.
    //
    // Note: This case does not occur if '<drive_letter>:' is passed in.
    //
    if( strlen( beg ) == 2 ) {
        *( beg + 2 ) = PSEPCHR;
        *( beg + 3 ) = '\0';
    }
    pname (beg);
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\setattr.c ===
/* setattr - set attribute for a directory entry */

#if defined(NT)
#include <windows.h>
#elif defined(OS2)
#include <os2.h>
#define RESV_BITS 0x3F	/* Bits not in this mask are documented as "reserved */
#elif defined(DOS)
#include <dos.h>
#endif


int setattr (pname, attr)
char *pname;
int attr;
{
#if defined(NT)

    return SetFileAttributes(pname, attr) ? 0 : GetLastError() ;

#elif defined(OS2)

    return DosSetFileMode( (char far *)pname , attr & RESV_BITS , 0L );

#else

    union REGS regs;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    struct SREGS sregs;
#endif

    // Set File Attributes. ds:dx are correctly loaded
    // depending upon the memory model.

    regs.x.ax = 0x4301;
    regs.x.cx = attr;
#if ( defined(M_I86CM) || defined (M_I86LM) || defined (M_I86HM) )
    segread( &sregs);
    sregs.ds = FP_SEG(pname);
    regs.x.dx = FP_OFF(pname);
    intdosx(&regs, &regs, &sregs);
#else
    regs.x.dx = (unsigned) pname;
    intdos (&regs, &regs);
#endif
    return regs.x.cflag;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\strcmps.c ===
/* strcmps - compare strings and ignore spaces */

#include <ctype.h>
#include "..\h\tools.h"

/* compare two strings, ignoring white space, case is significant, return
 * 0 if identical, <>0 otherwise
 */
strcmps (p1, p2)
register const char *p1, *p2;
{
    while (TRUE) {
	while (isspace (*p1))
	    p1++;
	while (isspace (*p2))
	    p2++;
	if (*p1 == *p2)
	    if (*p1++ == 0)
		return 0;
	    else
		p2++;
	else
	    return *p1-*p2;
	}
}

/* compare two strings, ignoring white space, case is not significant, return
 * 0 if identical, <>0 otherwise
 */
strcmpis (p1, p2)
register const char *p1, *p2;
{
    while (TRUE) {
	while (isspace (*p1))
	    p1++;
	while (isspace (*p2))
	    p2++;
	if (toupper (*p1) == toupper (*p2))
	    if (*p1++ == 0)
		return 0;
	    else
		p2++;
	else
	    return *p1-*p2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\string.c ===
// string.c - string functions carried over from Lattice C
//
// Modifications
//	28-Dec-90   leeca   Converted from .ASM for memory model independence
//

#include <string.h>

char *strbscan (
    char *str,
    char *set
    )
{
    return str + strcspn ( str, set );
    }

char *strbskip (
    char *str,
    char *set
    )
{
    return str + strspn ( str, set );
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\strpre.asm ===
;
; strpre functions for lattice C
;

.xlist
include ..\h\cmacros.inc
.list

sBegin	data
assumes ds,data

externB XLTab
externB XUTab

sEnd

sBegin	code
assumes cs,code

;
; strpre (s1, s2) returns -1 if s1 is a prefix of s2, 0 otherwise. Ignores
; case.
;
cProc	strpre,<PUBLIC>,<si,di>
parmW	pref
parmW	str
cBegin
	cld
	mov	si,pref
	mov	di,str
	mov	bx,dataOFFSET xltab
preCompare:
	lodsb
	mov	ah,[di]
	inc	di

	xlat
	xchg	ah,al
	xlat

	cmp	ah,al
	jnz	preDif
	or	ah,ah
	jnz	preCompare
preYes:
	mov	ax,-1
	jmp	short preDone
preDif:
	or	ah,ah
	jz	preYes
	xor	ax,ax
preDone:
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\strpfx.c ===
#include <stdlib.h>
#include <string.h>

#include "strpfx.h"

// Determine if a string is a prefix
// - case sensitive varient

char*
strprefix (
    char* szTest,
    char* szFull )
{
    int cch = strlen ( szTest );

    // if no match, return NULL
    if ( strncmp ( szTest, szFull, cch ))
	return NULL;

    // success.  return where prefix failed
    return szFull + cch;
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\stripfx.c ===
#include <stdlib.h>
#include <string.h>

#include "strpfx.h"

// Determine if a string is a prefix
// - case insensitive variant

char*
striprefix (
    char* szTest,
    char* szFull )
{
    int cch = strlen ( szTest );

    // if no match, return NULL
    if ( strnicmp ( szTest, szFull, cch ))
	return NULL;

    // success.  return where prefix failed
    return szFull + cch;
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\swchng.c ===
/*
 * HISTORY:
 *  16-Jul-87   danl    added istag fMatchTag
 *  15-Jul-87   danl    swchng: blank line is not end of section
 */

#include "..\h\tools.h"
#include <string.h>

char *haslhs(char *, char *);
istag (char *);
fMatchTag(char *, char *);

static char *space = "\t ";
static char LB = '[';
static char RB = ']';
static char chEQ  = '=';

/* pBuf has a left hand side that matches pLHS return a pointer to the
 * "=" in pBuf else return NULL
 */
char *haslhs(pBuf, pLHS)
char *pBuf;
char *pLHS;
{
    flagType f = FALSE;
    char *p;

    if ((p = strchr(pBuf, chEQ)) == NULL)
        return NULL;
    *p = '\0';
    f = (flagType) !strcmpis(pBuf, pLHS);
    *p = chEQ;
    return (f ? p : NULL);
}

/*  istag returns true if pBuf is a tag line, e.g.
 *      [pTag]
 */
fMatchTag(pBuf, pTag)
register char *pBuf;
register char *pTag;
{
    char *p, *pEnd, c;

    pBuf = strchr (pBuf, LB);
    pEnd = strchr (++pBuf, RB);
    *pEnd = '\0';
    while (*pBuf) {
        pBuf = strbscan (p = strbskip (pBuf, space), space);
        c = *pBuf;
        *pBuf = 0;
        if (!stricmp (p, pTag)) {
            *pBuf = c;
	    *pEnd = RB;
	    return TRUE;
            }
        *pBuf = c;
	}
    *pEnd = RB;
    return FALSE;
}

istag (pBuf)
register char *pBuf;
{
    return (( *(pBuf=strbskip(pBuf, space)) == LB) && (strchr (pBuf, RB) != NULL));
}

/*   Searchs the file strSwFile for
 *      [strTag]
 *          LHS=
 *
 *  and if strRHS is non-empty changes the right hand side to strRHS
 *  else deletes the line LHS=
 *
 *  swchnglhs: The original file is fdeleted for recovery via UNDEL.
 *  swchng   : if fNoUndel, then original file is deleted, no UNDEL possible
 *             else fdeleted for recovery via UNDEL.
 *
 *  LHS=RHS is output right after the start of section and any later
 *  instances of LHS are removed.  N.B. if RHS is "", no LHS= is output
 *
 *  If section doesn't exist in file, it is appended at end
 *
 */
flagType
swchnglhs (strSwFile, strTag, strLHS, strRHS)
char *strSwFile;
char *strTag;
char *strLHS;
char *strRHS;
{
    flagType	fError;

    return ( swchange (strSwFile, strTag, strLHS, strRHS, FALSE, &fError ) );
}

flagType swchng (char *strSwFile, char *strTag, char *strLHS, char *strRHS,
    flagType fNoUndel)
{
    flagType	fError;

    return ( swchange (strSwFile, strTag, strLHS, strRHS, fNoUndel, &fError ) );
}

flagType swchange (char *strSwFile, char *strTag, char *strLHS, char *strRHS,
    flagType fNoUndel, flagType *fError)
{
    FILE *fhin, *fhout;
    char strSwBuf[MAXPATHLEN];
    char strSwTmp[MAXPATHLEN];
    char strBuf[256];
    char *p;
    flagType fTagFound = FALSE;
    flagType fInTag = FALSE;
    flagType fFound = FALSE;

    *fError = FALSE;
    if ((fhin = pathopen (strSwFile, strSwBuf, "rb")) == NULL) {
        return FALSE;
        }
    upd (strSwBuf, ".$$$", strSwTmp);
    if ((fhout = fopen (strSwTmp, "wb")) == NULL) {
        fclose (fhin);
        return FALSE;
        }

    while (fgetl (strBuf, 256, fhin)) {
        if (fInTag) {
            if ((p = haslhs(strBuf, strLHS))) {
                /*
                **  consume continuation lines, i.e. consume until blank line
                **  or line containing []=
                */
                while (fgetl(strBuf, 256, fhin)) {
                    if ( !*strbskip(strBuf, space) || *strbscan(strBuf, "[]=")) {
			*fError |= fputl( strBuf, strlen(strBuf), fhout);
                        break;
                        }
                    }
                break;
                }
            else if (istag(strBuf)) {
                /*
                **  detected start of another section
                */
		*fError |= fputl( strBuf, strlen(strBuf), fhout);
                break;
                }
	    *fError |= fputl( strBuf, strlen(strBuf), fhout);
            }
        else if (istag (strBuf) && fMatchTag(strBuf, strTag)) {
            /*
            **  found start of section so output section head and
            **      LHS=RHS
            */
            fTagFound = fInTag = TRUE;
	    *fError |= fputl( strBuf, strlen(strBuf), fhout);
            if (*strRHS)
                fFound = TRUE;
                fprintf(fhout, "    %s=%s\r\n", strLHS, strRHS);
            }
        else
	    *fError |= fputl( strBuf, strlen(strBuf), fhout);
        }

    /*
    **  copy rest of input
    */
    while (fgetl (strBuf, 256, fhin))
	*fError |= fputl( strBuf, strlen(strBuf), fhout);

    if (!fTagFound && *strRHS && !*fError) {
        fFound = TRUE;
        fprintf(fhout, "\r\n[%s]\r\n    %s=%s\r\n\r\n", strTag, strLHS, strRHS);
        }

    fclose (fhin);
    fclose (fhout);
    if (*fError)	    //we had a write error, so remove the temp
	unlink (strSwTmp);  // instead of the original
    else {
	if ( fNoUndel )
	    unlink (strSwBuf);
	else
	    fdelete (strSwBuf);
	frenameNO (strSwBuf, strSwTmp);
    }

    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\untab.asm ===
;
; Expand all tabs to spaces
;

.xlist
include ..\h\cmacros.inc
.list

sBegin	code
assumes cs,code

cProc	UnTab,<PUBLIC>,<si,di>
ParmW	src
ParmW	dst
cBegin
	push	ds
	pop	es
	cld
	mov	si,src
	mov	di,dst
	mov	dx,di
	mov	cx,1
	mov	ah,' '
getc:
	lodsb
	cmp	al,9
	jz	tab
store:
	rep	stosb
	inc	cx
	or	al,al
	jnz	getc
	jmp	done
tab:
	mov	cx,di
	sub	cx,dx
	and	cx,7
	sub	cx,8
	neg	cx
	mov	al,ah
	jmp	store
done:
	lea	ax,[di-1]
	sub	ax,dst
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\vector.c ===
/*  vector.c - simple vector management
 *
 *  Modifications:
 *
 *	12-May-1988 mz	Add VECTOR typedef
 *
 */
#include <malloc.h>
#include "..\h\tools.h"

#define DELTA 10

VECTOR *VectorAlloc (count)
int count;
{
    register VECTOR *v;

    v = (VECTOR *) (*tools_alloc) (sizeof (*v) + (count-1) * sizeof (void *));
    if (v != NULL) {
	v->vmax  = count;
	v->count = 0;
	}
    return v;
}

flagType fAppendVector (ppVec, val)
VECTOR **ppVec;
void * val;
{
    register VECTOR *pVec = *ppVec;

    if (pVec == NULL)
	if ((pVec = VectorAlloc (DELTA)) == NULL)
	    return FALSE;
	else
	    ;
    else
    if (pVec->vmax == pVec->count) {
	register VECTOR *v;

	if ((v = VectorAlloc (DELTA + pVec->vmax)) == NULL)
	    return FALSE;
	Move ((char far *)(pVec->elem),
	      (char far *)(v->elem),
	      sizeof (v->elem[0]) * pVec->count);
	v->count = pVec->count;
	free ((char *) pVec);
	pVec = v;
	}
    pVec->elem[pVec->count++] = (void *) val;
    *ppVec = pVec;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\xtab.c ===
/***************************************************************************\

CLASS:	    XLTab and XUTab

PURPOSE:    Translate table for case conversion

HISTORY:    28-Jul-90 davegi
		Coverted from 286 MASM

\***************************************************************************/

char XLTab[ ] = {	// Table for lowercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};    



char XUTab[ ] = {	// Table for uppercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\update.c ===
/*
 * update takes a def string and update and fills the
 * update with missing defs the update allowing
 * specification of missing parameters.
 * the parts are: ^{[~:]#:}{%#</|\>}{[~.]#}{.[~./\:]}$
 * maximum size of MAXPATHLEN (80) bytes
 *
 *  Modifications:
 *	 4/14/86    dl	use U_ flags
 *	29-May-1987 mz	treat . and .. specially
 *
 */

#include "..\h\tools.h"
#include <string.h>

static char szDot[] =	    ".";
static char szDotDot[] =    "..";
static char szColon[] =     ":";
static char szPathSep[] =   "\\/:";


int upd (def, update, dst)
char *def, *update, *dst;
{
    char *p, buf[MAXPATHLEN];
    int f;

    f = 0;
    p = buf;

    /*	if the update doesn't contain a UNC path then copy drive
     */
    if (!fPathChr (update[0]) || !fPathChr (update[1])) {
	if (drive(update, p) || drive (def, p))
	    SETFLAG(f, U_DRIVE);
	p += strlen (p);
	}

    if (path(update, p) || path (def, p))
        SETFLAG(f, U_PATH);
    p += strlen (p);

    if (filename(update, p) || filename (def, p))
        SETFLAG(f, U_NAME);

    if (strcmp (p, szDot) && strcmp (p, szDotDot)) {
	p += strlen (p);

	if (extention(update, p) || extention (def, p))
	    SETFLAG(f, U_EXT);
	}

    strcpy (dst, buf);

    return f;
}

/* copy a drive from source to dest if present, return TRUE if we found one */
drive (src, dst)
char *src, *dst;
{

    if (src[0] != 0 && src[1] == ':') {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = 0;
	return TRUE;
	}
    else {
	dst[0] = 0;
	return FALSE;
	}
}

/**	FindFilename - find filename in string
 *
 *	Find last /\:-separated component in string
 *
 *	psz	    pointer to string to search
 *
 *	returns     pointer to filename
 */
static char *FindFilename (char *psz)
{
    char *p;

    while (TRUE) {
	p = strbscan (psz, szPathSep);
	if (*p == 0)
	    return psz;
	psz = p + 1;
	}
}

/**	FindExtention - find last dot-preceded portion in filename
 *
 *	psz	    pointer to filename string to search
 *
 *	returns     pointer to . or nul
 */
static char *FindExtention (char *psz)
{
    char *p;

    /*	Find first dot
     */
    p = strchr (psz, *szDot);

    /*	if none present then return EOS
     */
    if (p == NULL)
	return psz + strlen (psz);

    /*	Keep scanning for next dot
     */
    while (TRUE) {
	psz = p;
	p = strchr (psz + 1, *szDot);
	if (p == NULL)
	    return psz;
	}
}

/*  copy an extention from source to dest if present.  include the period.
    Return TRUE if one found.
 */
extention (src, dst)
char *src, *dst;
{
    register char *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p1 = "";
    else
	p1 = FindExtention (p1);

    strcpy (dst, p1);

    return dst[0] != 0;
}

/*  copy a filename part from source to dest if present.  return true if one
    is found
 */
filename (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p = strend (p1);
    else
	p = FindExtention (p1);

    strcpy (dst, p1);
    dst[p-p1] = 0;

    return dst[0] != 0;
}

/*  copy a filename.ext part from source to dest if present.  return true if one
    is found
 */
fileext  (src, dst)
char *src, *dst;
{
    if ( filename (src, dst) ) {
        dst += strlen (dst);
        extention (src, dst);
        return TRUE;
        }
    return FALSE;
}

/*  copy the paths part of the file description.  return true if found
 */
path (src, dst)
char *src, *dst;
{
    register char *p;

    if (src[0] != 0 && src[1] == ':')
	src += 2;

    /*	src points to potential beginning of path
     */

    p = FindFilename (src);

    /*	p points to beginning of filename
     */

    strcpy (dst, src);
    dst[p - src] = 0;
    return dst[0] != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\zalloc.c ===
/***	zalloc - hoookable ztools allocator
 *
 *	Modifications
 *	15-Dec-1988 mz	Created
 */

#include <malloc.h>

char * (*tools_alloc) (unsigned) = (char * (*)(unsigned))malloc;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\ztoolasm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    move.c

Abstract:

    Move and file routines that were previously in asm
    Done to ease porting of utilities (wzmail)

Author:

    Dave Thompson (Daveth) 7 May-1990


Revision History:


--*/

#include    <stdio.h>
#include    <io.h>
#include    <windows.h>
#include    <tools.h>

#include <memory.h>
#include <string.h>

#if 0
/* Move and Fill are implemented in NT as macros to their respective
 *  C runtime library functions.  They are left here for completeness.
 *	ErichS
 */

//
//  Move:  move count bytes src -> dst
//

void
Move (
    void * src,
    void * dst,
    unsigned int count)
    {

    memmove(dst, src, count);
}

//
//  Fill:  fill count bytes of dst with value
//

void
Fill (
    char * dst,
    char value,
    unsigned int count)
    {

    memset(dst, (int) value, count);
}
#endif

//
//  strpre - return -1 if s1 is a prefix of s2 - case insensitive
//

flagType
strpre (
    char * s1,
    char * s2)
    {
    if ( _strnicmp ( s1, s2, strlen(s1)) == 0 )
	return -1;
    else
	return 0;

}

/*** max - maximum function (non-macro to avoid double arg evaluation)
 */
int
max (int x, int y)
{
    return (x > y) ? x : y ;
}

/*** min - minimum function (non-macro to avoid double arg evaluation)
 */
int
min (int x, int y)
{
    return (x < y) ? x : y ;
}

/*** z_handle - gets OS handle from standard RTL handle
 *
 *  The NT runtime libraries hand back library handles, not file handles.
 *  This routine uses the _get_osfhandle() function to get
 *  a Win32 file handle for internal use, and assumes that any handle that
 *  is not accepted by this routine is valid as is.
 *
 *  Primary assumption: that the set of OS handles is disjoint from the set
 *  of CRT file handles.  The reason we assume this is the array of CRT
 *  handles is at most 256, the 64K at each end of user space is not mapped
 *  to catch runaway errors, and the OS handle is a pointer.
 *
 */
HANDLE
z_handle (int crtfh)
{
    HANDLE  ntfh;

    if ((ntfh = (HANDLE) _get_osfhandle(crtfh)) == (HANDLE) -1)
	return (HANDLE) crtfh;
    else
	return ntfh;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\auto.c ===
/**************************************************************************/
/***									***/
/***	AUTO.C	- AUTOEXEC.BAT file munging routines			***/
/***									***/
/***									***/
/***									***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include <io.h>
#include <stdio.h>
#include <string.h>
#include "smartmon.h"

#define MAX_LINE_LEN	128

extern char szBatchFile[];
char linebuf[ MAX_LINE_LEN ];

extern char szBuffer[];
extern HCURSOR hCurWait;
extern char CurDriveList[];
extern WORD CurDriveCount;

extern int  GetDriveIndex( WORD, WORD );
extern BOOL CheckForStacker( WORD );


LPSTR GetLine( LPSTR lpSrc, LPSTR lpEOF, char *pLine )
{
    //
    // Look for carriage return
    //
    while ( (*lpSrc != '\r') && (lpSrc < lpEOF) )
	*pLine++ = *lpSrc++;

    *pLine = 0;

    //
    // Skip next character if it's a linefeed
    //
    if ( lpSrc < lpEOF ) {
	lpSrc++;
	if ( (lpSrc < lpEOF) && (*lpSrc == '\n') )
	    lpSrc++;
    }

    return lpSrc;
}


BOOL IsSmartDrvLine( char *pLine )
{
    char ch;
    int nc;
    char *pLineOrg = pLine;
    char *pTemp;
    char *pSub;

    //
    // Skip leading spaces or any control chars
    //
    while ( ch = *pLine )
	if ( ch > ' ' )
	    break;
	else
	    pLine++;

    //
    // Make a copy of the line up to the first blank or tab
    //
    pSub = szBuffer;
    pTemp = pLine;
    while ( ch = *pLine ) {
	if ( (ch == ' ') || (ch == 0x09) )
	    break;
	else
	    if ( ch == '=' )
		//
		// Reject things like "path=smartdrv"
		//
		return FALSE;
	    else
		*pSub++ = ch;
	pLine++;
    }

    *pSub = 0;

    //
    // Reject labels
    //
    if ( szBuffer[0] == ':' )
	return FALSE;

    //
    // See if the substring ends with "smartdrv" or "smartdrv.exe"
    //
    AnsiLowerBuff( (LPSTR)szBuffer, nc = pLine-pTemp );
    if ( nc < 8 )
	return FALSE;
    if ( strcmp( (char *)(pSub-8), "smartdrv" ) == 0 )
	return TRUE;
    if ( (nc >= 12) && (strcmp( (char *)(pSub-12), "smartdrv.exe" ) == 0) )
	return TRUE;

    return FALSE;
}


BOOL WriteNewSmartDrvLine( int fh, char *pOldLine )
{
    extern DWORD DosCacheSize;	// Cache size (Kbyte) under DOS
    extern DWORD WinCacheSize;	// Cache size (Kbyte) under Windows

    int  i;
    char ch;
    char *pNewLine = szBuffer;
    WORD iDrv, iDrvIndex, status;

    //
    // Skip leading spaces or any control chars
    //
    while ( ch = *pOldLine )
	if ( ch > ' ' )
	    break;
	else
	    pOldLine++;

    //
    // Copy everything up to the first blank
    //
    while ( *pOldLine ) {
	ch = *pNewLine++ = *pOldLine++;
	if ( (ch == ' ') || (ch == 0x09) )
	    break;
    }

    //
    // Copy the options, if present
    //
    while ( TRUE )
	if ( *pOldLine == '/' )
	    while ( *pOldLine ) {
		ch = *pNewLine++ = *pOldLine++;
		if ( (ch == ' ') || (ch == 0x09) )
		    break;
	    }
	else
	    break;

    //
    // Eat the last blank
    //
    if ( *pOldLine )
	pNewLine--;


    //
    // Write out the status of each cacheable drive if it's
    // different from the default for that type of drive.
    // For floppy the default is read-only; for hard drive
    // it's read/write.
    //
    CurDriveCount = count_valid_drives( CurDriveList );
    for ( i = 0; i < CurDriveCount; i++ ) {

	iDrv = CurDriveList[i+1];
	status = cache_a_drive( GET, iDrv );
	iDrvIndex = GetDriveIndex( iDrv, GetDriveType( iDrv ) );

	if ( iDrvIndex == FLOPPYBMP ) {

	    if ( status & NO_READ )
		wsprintf( pNewLine, " %c-", (iDrv+'A') );
	    else if ( status & NO_WRITE )
		continue;   // default for floppy
	    else
		wsprintf( pNewLine, " %c+", (iDrv+'A') );

	    pNewLine += 3;

	} else if ( (iDrvIndex == HARDDRVBMP) && !CheckForStacker(iDrv) ) {

	    if ( status & NO_READ ) {
		wsprintf( pNewLine, " %c-", (iDrv+'A') );
		pNewLine += 3;
	    } else if ( status & NO_WRITE ) {
		wsprintf( pNewLine, " %c", (iDrv+'A') );
		pNewLine += 2;
	    } else
		continue;   // default for hard drives
	} else
	    continue;	    // default for non-cacheable drives
    }

    //
    // Write out cache size under DOS and Windows
    //
    wsprintf( pNewLine, " %lu %lu\r\n", DosCacheSize, WinCacheSize );

    if ( (i = lstrlen(szBuffer)) < MAX_LINE_LEN ) {
	if ( _lwrite( fh, (LPSTR)szBuffer, i ) == i )
	    return TRUE;
    }

    return FALSE;
}


BOOL WriteNewBatchFile( int fhNew, LPSTR lpf, LPSTR lpEOF )
{
    BOOL fFound = FALSE;
    BOOL rc = FALSE;

    *lpEOF = 0;
    while ( lpf < lpEOF ) {
	lpf = GetLine( lpf, lpEOF, linebuf );
	if ( linebuf[0] ) {
	    if ( IsSmartDrvLine( linebuf ) ) {
		if ( fFound )
		    //
		    // Abandon if found more than one smartdrv line
		    //
		    return FALSE;

		fFound = TRUE;
		rc = WriteNewSmartDrvLine( fhNew, linebuf );
		continue;
	    }
	    _lwrite( fhNew, (LPSTR)linebuf, lstrlen(linebuf) );
	}
	_lwrite( fhNew, (LPSTR)"\r\n", 2 );
    }

    return rc;
}


BOOL MungeBatchFile()
{
    BOOL rc = FALSE;
    int fhOld, fhNew, i;
    OFSTRUCT of;
    DWORD ulFileSize;
    HANDLE hFileBuf;
    BYTE far *lpf;
    char szNewFile[144];
    char szTempFile[144];
    HCURSOR hCur;
    BYTE cDrv;

    hCur = SetCursor( hCurWait );

    //
    // Because the rename function cannot do files on different drives,
    // find out where the targe batch file is, and force the temp files
    // to go there.
    //
    cDrv = (BYTE)AnsiUpper((DWORD)szBatchFile[0]) - 'A';
    if ( szBatchFile[1] != ':' )
	return FALSE;

    CurDriveCount = count_valid_drives( CurDriveList );
    for ( i = 0; i < CurDriveCount; i++ )
	if ( CurDriveList[i+1] == cDrv )
	    goto valid_drive;
    return FALSE;

valid_drive:

    cDrv = (cDrv + 'A') | TF_FORCEDRIVE;

    //
    // Open batch file for exclusive access
    //
    if (OpenFile( (LPSTR)szBatchFile, (OFSTRUCT FAR *)&of, OF_EXIST ) == -1)
	goto cleanup0;
    if ( (fhOld = OpenFile( (LPSTR)szBatchFile, (OFSTRUCT FAR*)&of,
	OF_READ | OF_SHARE_EXCLUSIVE )) == -1 )
	goto cleanup0;

    //
    // Don't do anything if file is > 64K.  Add an extra byte to
    // mark the end of file.
    //
    ulFileSize = _llseek( fhOld, 0L, 2 );
    if ( HIWORD( ulFileSize ) )
	goto cleanup1;

    //
    // Open a new file
    //
    GetTempFileName( cDrv, (LPSTR)"sdm", 0, (LPSTR)szNewFile );
    if ( (fhNew = OpenFile( (LPSTR)szNewFile, (OFSTRUCT FAR *)&of,
	OF_CREATE | OF_WRITE | OF_SHARE_EXCLUSIVE )) == -1 )
	goto cleanup1;

    //
    // See if there is enough space on the drive for the new
    // batch file plus one extra line.	The drive letter returned
    // by GetTempFileName is always in upper case.
    //
    if ( get_free_space(szNewFile[0]-'A') < (ulFileSize+MAX_LINE_LEN) )
	goto cleanup1;

    //
    // Load batch file into memory.  Don't close it until we are done.
    //
    _llseek( fhOld, 0L, 0 );
    if ( (hFileBuf = GlobalAlloc( GHND, ulFileSize+1 )) == 0 )
	goto cleanup1;
    lpf = GlobalLock( hFileBuf );
    if ( _lread( fhOld, lpf, ulFileSize ) != ulFileSize )
	goto cleanup2;

    //
    // Transfer old content to new file, modify SMARTDRV line in the process.
    //
    rc = WriteNewBatchFile( fhNew, lpf, lpf+(WORD)ulFileSize );

    _lclose( fhOld );
    _lclose( fhNew );

    //
    // Give new file the batch file name, and remove old one.
    //
    if ( rc ) {
	GetTempFileName( cDrv, (LPSTR)"sdm", 0, (LPSTR)szTempFile );
	DeletePathname( szTempFile );	// for the rename below

	if ( rename( szBatchFile, szTempFile ) == 0 ) {
	    if ( rename( szNewFile, szBatchFile ) == 0 ) {
		DeletePathname( szTempFile );
	    } else {
		//
		// Restore old AUTOEXEC.BAT
		//
		rename( szTempFile, szBatchFile );
		goto bail_out;
	    }
	} else
	    goto bail_out;
    } else {

bail_out:
	DeletePathname( szNewFile );
	rc = FALSE;
    }

cleanup2:
    GlobalUnlock( hFileBuf );
    GlobalFree( hFileBuf );
    _lclose( fhNew );

cleanup1:
    _lclose( fhOld );

cleanup0:
    SetCursor( hCur );
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\src\zsleep.c ===
/*** ZSleep - causes program to _politely_ wait at least X milliseconds
 *	for DOS only; OS/2 and NT have their own methods that should
 *	be set up in ttypes.h.	The routine calculates the number of
 *	clock ticks in X milliseconds and adds the current tick value
 */

#if defined(DOS)

#include <dos.h>
#include "..\h\tools.h"

void ZSleep(long lMilliseconds);

void ZSleep(long lMilliseconds)
{
    union REGS		    inregs, outregs;
    struct SREGS	    segregs;
    flagType		    fCanIdle;
    typedef unsigned long   TIX;
    TIX			    ticks, oldticks, newticks;

    /* Locate Idle interrupt address (to see if we can call it) */

    segread(&segregs);
    inregs.h.ah = 0x35;			//Get Interrupt Vector
    inregs.h.al = 0x2f;			//Specify the interrupt we're asking for
    segregs.es = inregs.x.bx = 0;	//Clear results
    intdosx(&inregs, &outregs, &segregs);
    fCanIdle = (flagType)(segregs.es | outregs.x.bx);

    //Determine number of ticks in x milliseconds, given that there
    //are ~54.9450 millisecs/tick at 18.2 ticks/sec

    ticks = lMilliseconds * 10;
    ticks /= 549;

    //and add those ticks to the current tick count

    newticks = oldticks = *(TIX far * volatile)0x46C;
    ticks += oldticks;

    // Wait until the tick changes to past the desired value.

    do {
	if (oldticks > newticks)
	    ticks -= (oldticks - newticks);
	oldticks = newticks;

	//Note that the Idle interrupt and the Idle call are two separate items

	int86(0x28, &inregs, &outregs); //DOS Idle interrupt

	if (fCanIdle) {
	    inregs.x.ax = 0x1680; //DOS Idle call
	    int86(0x2F, &inregs, &outregs);
	    fCanIdle = (flagType) !outregs.h.al; //don't call if not supported
	}
	newticks = *(TIX far * volatile)0x46C;

    } while (ticks >= newticks);
}
#endif



#ifdef STANDALONE

#include <stdio.h>

main()
{
    puts("Waiting for 10 seconds");
    fflush(stdout);
    ZSleep(10000L);
    puts("\aWait completed");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\int2f.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include bambi.inc

PUBLIC	get_cache_hits
PUBLIC	get_cache_misses
PUBLIC	get_cache_dirty_elements
PUBLIC	get_cache_info
PUBLIC	commit_cache
PUBLIC	reset_cache
PUBLIC	cache_a_drive

_TEXT	segment	public	para 'CODE'
	assume cs:_TEXT

;
;INPUT
;	none
;OUTPUT
;	DX:AX = cache hits
;
get_cache_hits proc near
	push	bp
	push	si
	push	di
	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_GET_STATS
	int	2fh
	cmp	ax,BAMBI_SIGNATURE
	jne	no_bambi
	mov	ax,bx
retout:
	pop	di
	pop	si
	pop	bp
	ret
no_bambi:
	mov	dx,-1
	mov	ax,dx
	jmp	short retout
get_cache_hits endp

;
;INPUT
;	none
;OUTPUT
;	DX:AX = cache hits
;
get_cache_misses proc near
	push	bp
	push	si
	push	di
	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_GET_STATS
	int	2fh
	cmp	ax,BAMBI_SIGNATURE
	jne	missno_bambi
	mov	dx,di
	mov	ax,si
missretout:
	pop	di
	pop	si
	pop	bp
	ret
missno_bambi:
	mov	dx,-1
	mov	ax,dx
	jmp	short missretout
get_cache_misses endp

;
;INPUT
;	none
;OUTPUT
;	AX = # dirty elements
;
get_cache_dirty_elements proc near
	push	si
	push	di
	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_GET_STATS
	int	2fh
	cmp	ax,BAMBI_SIGNATURE
	jne	dirtyno_bambi
	mov	ax,cx
dirtyretout:
	pop	di
	pop	si
	ret
dirtyno_bambi:
	mov	dx,-1
	mov	ax,dx
	jmp	short dirtyretout
get_cache_dirty_elements endp


;
;INPUT
;	none
;OUTPUT
;	none
commit_cache proc near
	mov	ah,0dh	    ; DOS disk reset function
	int	21h
	xor	ax,ax
	ret
commit_cache endp


;
;INPUT
;	none
;OUTPUT
;	none
reset_cache proc near
	push	bx
	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_REINITIALIZE
	int	2fh
	pop	bx
	xor	ax,ax
	ret
reset_cache endp


;
;INPUT
;	pointer to cache block count under DOS
;	pointer to cache block count under Windows
;
;OUTPUT
;	ax = cache block size in bytes
;
get_cache_info proc near
	push	bp
	mov	bp,sp
	push	bx
	push	cx
	push	si
	mov	si,[bp+6]
	mov	bp,[bp+4]

	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_GET_INFO
	int	2fh
	mov	word ptr [si],ax	; block # under DOS
	mov	word ptr [bp],bx	; block # under Win
	mov	ax,cx

	pop	si
	pop	cx
	pop	bx
	pop	bp
	ret	4
get_cache_info	endp


;
;INPUT
;	unit # (0 based) of drive
;	function # 0 = get,
;		   1 = enable read caching
;		   2 = disable read caching
;		   3 = enable write caching
;		   4 = disable write caching
;OUTPUT
;	al = drive cache info
;
cache_a_drive proc near
	push	bp
	mov	bp,sp
	mov	dx,[bp+6]	;function#
	mov	bp,[bp+4]	;drive unit
	push	si
	push	di

	mov	ax,MULT_BAMBI
	mov	bx,BAMBI_CACHE_DRIVE
	int	2fh
	cmp	ax,BAMBI_SIGNATURE
	jne	cacheno_bambi
	mov	al,dl
	xor	ah,ah
cacheout:
	pop	di
	pop	si
	pop	bp
	ret	4
cacheno_bambi:
	mov	ax,-1
	jmp	short cacheout
cache_a_drive endp

_TEXT ends

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\bambi.inc ===
MULT_BAMBI		equ	04a10h		;int 2f multiplex interface
BAMBI_SIGNATURE		equ	0BABEh
BAMBI_GET_STATS		equ	0		
BAMBI_COMMIT_ALL	equ	1
BAMBI_REINITIALIZE	equ	2
BAMBI_CACHE_DRIVE	equ	3
BAMBI_GET_INFO  	equ	4
BAMBI_GET_BUFFER_INFO   equ	5
BAMBI_DONT_CACHE_DRIVE	equ	6

CACHE_DRIVE_GET		equ	0
CACHE_DRIVE_READ_ENABLE	equ	1
CACHE_DRIVE_READ_DISABLE equ	2
CACHE_DRIVE_WRITE_ENABLE equ 	3
CACHE_DRIVE_WRITE_DISABLE equ	4


ERROR_NO_XMS_DRIVER	equ	1	;errors returned by xms.asm
ERROR_ALLOCATION_FAILEd equ	2


COMMAND_LINE_OFFSET	equ 	80h	;offset from starting segment of command line
COMMAND_LINE_TERMINATOR equ	0Dh	;carriage return ends command line
MAX_COMMAND_LINE_LENGTH equ	80h	;maximum length of command line is 128 chars
COMMAND_SWITCH_CHAR	equ	'/'	;the switch indicator
ELEMENTS_FLAG		equ	'n'
ELEMENT_SIZE_FLAG	equ	'e'
FLUSH_FLAG		equ	'c'
STATUS_FLAG		equ	's'
DRIVE_FLAG		equ	'd'
BUFFER_FLAG		equ	'b'
RESET_FLAG		equ	'r'
QUIET_FLAG		equ	'q'
BEEP_FLAG		equ	'!'	;bug bug debugging
LOAD_LOW_FLAG		equ	'l'


SCANCODE_RETRY		equ	13h
ASCIICODE_RETRY		equ	'R'
SCANCODE_IGNORE		equ	17h
ASCIICODE_IGNORE	equ	'I'



READ_CACHE		equ	1
WRITE_CACHE		equ	2
NO_CACHE		equ	0

;constants for drvtype.asm
INVALID_TYPE	EQU 0
FLOPPY_TYPE 	EQU 1
REMOTE_TYPE 	EQU 2
HARDDISK_TYPE  	EQU 3
RAMDRIVE_TYPE 	EQU 4 
CDROM_TYPE 	EQU 5
MEMORY_TYPE	EQU 6


;constants for detect processor
CPU086088       equ     0
CPU186          equ     1       ;not detected here
CPU286          equ     2
CPU386          equ     4
CPU486ORABV     equ     8



MINIMUM_CACHE_SIZE  	equ	16	;minimum legal cache size in K (must be >= 16)


smart_win_access	struc			;meaning (maintained by)
	accessing_swap_file	db	?	;current access swap file? (windows)
	enhanced_mode_flags	db	?	;current write is lazy? (smartdrv,windows)
	delay_write_drive_unit	db	?	;unit of lazy write (smartdrv)
	max_delayed_write_size	dw	?	;maximum lazy write size (smartdrv)
smart_win_access	ends

THIS_WRITE_IS_LAZY	equ	1
WRITE_IS_PENDING	equ	2
ENHANCED_MODE_WIN	equ	4



Win386_Startup_Info_Struc STRUC
	SIS_Version_High	db	?
	SIS_Version_Low		db	?
	SIS_Next_Dev_Ptr	dd	?
	SIS_Virt_Dev_File_Ptr	dd	?
	SIS_Reference_Data	dd	?
	SIS_Instance_Data_Ptr	dd	?
Win386_Startup_Info_Struc ENDS


BAMBI_VERSION_BCD	equ	0400h


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\drive.c ===
/**************************************************************************/
/***									***/
/***	DRIVE.C     - Drive selection routines				***/
/***									***/
/***	Largely borrowed from ClarkC's COMMDLG FILEOPEN.C               ***/
/***									***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include "smartmon.h"

#define cbCaption       64
#define _MAX_PATH	256
#define CBN_DRAW	0x8000	 /* Used with OFN_COMBODOWN */
#define dxSpace         4

extern WORD wWinVer;
extern HANDLE hInst;

static WORD dyItem = 0;
static WORD dyText;
WORD dxDirDrive = 0;
WORD dyDirDrive = 0;
HDC  hdcMemory = 0;
HBITMAP hbmpOrigMemBmp;
HBITMAP hbmpDirDrive = (HANDLE)NULL;
char CurDriveList[27] = {0};
WORD CurDriveCount;
WORD cCurDriveSel = -1;

static DWORD rgbWindowColor = 0xFF000000;  /* Not a valid RGB color */
static DWORD rgbWindowText  = 0xFF000000;
static DWORD rgbHiliteColor = 0xFF000000;
static DWORD rgbHiliteText  = 0xFF000000;
static DWORD rgbDDWindow    = 0xFF000000;
static DWORD rgbDDHilite    = 0xFF000000;

#define rgbSolidBlue	0x00FF0000

BOOL ChangeDrive( char );
void InitDriveBox( HWND );
void ListDrives( HWND );
char SimpleLower( char );
VOID StringLower( LPSTR );
int  GetDriveIndex( WORD, WORD );
HBITMAP LoadAlterBitmap( int, DWORD, DWORD );
void vDeleteDirDriveBitmap( void );
BOOL LoadDirDriveBitmap( void );
void MySetObjectOwner( HANDLE );
LONG RgbInvertRgb( LONG );
void SetRGBValues( void );
void ResetDriveBox( HWND );

/**************************************************************************/
/***                                                                    ***/
/***	ChangeDrive							***/
/***                                                                    ***/
/**************************************************************************/

BOOL ChangeDrive( char chDrv )
{
    char cCurDrive;
    BOOL rc = FALSE;

    chDrv |= 0x60;
    cCurDrive = get_current_drive();
    set_current_drive( chDrv - 'a' );

    if ( is_CDROM_drive( chDrv - 'a' ) )
	if ( !is_valid_CD() )
	    goto cd_failed;

    if ( chDrv == get_current_drive() )
	return TRUE;

cd_failed:

    set_current_drive( cCurDrive - 'a' );
    return FALSE;
}


/**************************************************************************/
/***                                                                    ***/
/***	SetRGBValues							***/
/***                                                                    ***/
/**************************************************************************/

void SetRGBValues()
{
    rgbWindowColor = GetSysColor( COLOR_WINDOW );
    rgbWindowText  = GetSysColor( COLOR_WINDOWTEXT );
    rgbHiliteColor = GetSysColor( COLOR_HIGHLIGHT );
    rgbHiliteText  = GetSysColor( COLOR_HIGHLIGHTTEXT );
}


void InitDriveBitmap()
{
    HBITMAP hbmpTemp;
    HDC hdcScreen;

    //
    // Create a DC that is compatible with the screen and find the
    // handle of the null bitmap
    //
    SetRGBValues();
    hdcScreen = GetDC( 0 );
    hdcMemory = CreateCompatibleDC( hdcScreen );
    hbmpTemp = CreateCompatibleBitmap( hdcMemory, 1, 1 );
    hbmpOrigMemBmp = SelectObject( hdcMemory, hbmpTemp );
    SelectObject( hdcMemory, hbmpOrigMemBmp );
    DeleteObject( hbmpTemp );
    MySetObjectOwner( hdcMemory );
    ReleaseDC( 0, hdcScreen );

    LoadDirDriveBitmap();
}


/**************************************************************************/
/***                                                                    ***/
/***	InitDriveBox							***/
/***                                                                    ***/
/**************************************************************************/

void InitDriveBox( HWND hWnd )
{
    if ( wWinVer >= 0x030A )
	SendDlgItemMessage( hWnd, IDD_DRIVEID, CB_SETEXTENDEDUI,
	    (WPARAM)1, (LPARAM)0);
    else if ( GetSysModalWindow() )
	/* Windows 3.00, sysmodal bug.	clarkc	 2 May 1991 */
	EnableWindow( GetDlgItem(hWnd, IDD_DRIVEID), FALSE );

    ResetDriveBox( hWnd );
}


/**************************************************************************/
/***                                                                    ***/
/***	ResetDriveBox							***/
/***									***/
/**************************************************************************/

void ResetDriveBox( HWND hWnd )
{
    int i;
    HWND hCtl;

    SetRGBValues();
    LoadDirDriveBitmap();

    CurDriveCount = count_valid_drives( CurDriveList );

    //
    // If the current drive selection is gone, (say someone removed
    // a network drive from a DOS session), select the current drive.
    //
    if ( cCurDriveSel != -1 ) {
	for ( i = 0; i < CurDriveCount; i++ )
	    if ( cCurDriveSel == CurDriveList[i+1] )
		goto drive_still_good;
    }

    cCurDriveSel = get_current_drive() - 'a';

drive_still_good:

    hCtl = GetDlgItem( hWnd, IDD_DRIVEID );
    InvalidateRect( hCtl, (LPRECT)NULL, TRUE );

    ListDrives( hWnd );

    PostMessage( hWnd, WM_COMMAND, IDD_DRIVEID, MAKELPARAM(hCtl, CBN_SELCHANGE) );
}


/**************************************************************************/
/***                                                                    ***/
/***	ListDrives							***/
/***                                                                    ***/
/**************************************************************************/

void ListDrives( HWND hWnd )
{
    short i;
    char cBuffer[_MAX_PATH];
    HWND hCmb = GetDlgItem( hWnd, IDD_DRIVEID );
    WORD iCurrentDrive, iCurrentDriveType;

    SendMessage( hCmb, WM_SETREDRAW, FALSE, 0L );
    SendMessage( hCmb, CB_RESETCONTENT, 0, 0L );

    for( i = 0; i < CurDriveCount; i++ ) {

	iCurrentDrive = (WORD)CurDriveList[i+1];

	/* Note: it is very important that the uppercase 'A' be used for the
	 *	 drive letter in cBuffer[0], as the Novell Netware driver
	 *	 will GP Fault if you pass in a lowercase drive letter.
	 *	 30 October 1991	 Clark Cyr
	 */
	cBuffer[0] = (char) (iCurrentDrive + 'A');
	cBuffer[1] = ':';
	cBuffer[2] = '\0';

	iCurrentDriveType = GetDriveType( iCurrentDrive );
	if ( iCurrentDriveType < 2)  /* Is it a phantom?  Skip it! */
	    continue;

	if ( (iCurrentDriveType != DRIVE_REMOVABLE) &&
	     !((iCurrentDriveType == DRIVE_REMOTE) &&
	       is_CDROM_drive(iCurrentDrive)) ) {
	    if ( ChangeDrive(cBuffer[0]) ) {
		if ( iCurrentDriveType != DRIVE_REMOTE ) {
		    cBuffer[2] = ' ';
		    get_volume_label( iCurrentDrive, (LPSTR)(cBuffer+3) );
		    OemToAnsi( (LPSTR)cBuffer, (LPSTR)cBuffer );
		} else {
		    WORD iSel;
		    char szTempField[cbCaption];

		    /* Set the first character to zero.  If the drive is
		     * disconnected, the call to WNetGetConnection() will
		     * return a value other than WN_SUCCESS, but the string
		     * will be valid.  If the string isn't altered, wsprintf
		     * will just place the null string after the space.
		     * 18 July 1991    ClarkC
		     */
		    szTempField[0] = '\0';
		    iSel = cbCaption;
		    WNetGetConnection( (LPSTR)cBuffer, (LPSTR)szTempField,
			(LPWORD)&iSel);
		    wsprintf( (LPSTR)(cBuffer+2), " %s", (LPSTR)szTempField );
		}
	    }
	}

	StringLower( (LPSTR)cBuffer );
	SendMessage( hCmb, CB_INSERTSTRING, (WPARAM)i,
	    (LPARAM)(LPSTR)cBuffer);
	SendMessage( hCmb, CB_SETITEMDATA, (WPARAM) i, (LPARAM)(DWORD)(
	    GetDriveIndex( iCurrentDrive, iCurrentDriveType ) ) );
	if ( iCurrentDrive == cCurDriveSel )
	   SendMessage( hCmb, CB_SETCURSEL, (WPARAM) i, 0 );
    }

    SendMessage( hCmb, WM_SETREDRAW, (WPARAM)TRUE, 0L );
    ChangeDrive( (char)(CurDriveList[0] + 'a') );
}


/**************************************************************************/
/***                                                                    ***/
/***	SimpleLower							***/
/***                                                                    ***/
/**************************************************************************/

char SimpleLower( char chChar )
{
    _asm {
	mov	al, chChar
	cmp	al,'A'
	jb	NoChange
	cmp	al,'Z'
	ja	NoChange
	add	al,'a'-'A'
NoChange:
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	StringLower							***/
/***                                                                    ***/
/**************************************************************************/

VOID StringLower( LPSTR lpsz )
{
    if ( lpsz )
	while ( *lpsz ) {
	    *lpsz = SimpleLower( *lpsz );
	    lpsz++;
        }
}


/**************************************************************************/
/***                                                                    ***/
/***	GetDriveIndex							***/
/***                                                                    ***/
/**************************************************************************/

int GetDriveIndex( WORD wDrive, WORD wDriveType )
{
    register short i = HARDDRVBMP;

    if ( wDriveType == 1 )	/* Drive doesn't exist! */
	return(0);

    if ( is_CDROM_drive( wDrive ) )
	i = CDDRVBMP;

    else if ( wDriveType == DRIVE_REMOVABLE )
	i = FLOPPYBMP;

    else if ( wDriveType == DRIVE_REMOTE )
	i = NETDRVBMP;

    else if ( is_RAM_drive( wDrive ) )
	i = RAMDRVBMP;

    return i;
}


/**************************************************************************/
/***                                                                    ***/
/***	MeasureItem							***/
/***                                                                    ***/
/**************************************************************************/

void MeasureItem( HANDLE hDlg, LPMEASUREITEMSTRUCT mis )
{
    HDC hDC = GetDC( hDlg );
    TEXTMETRIC tm;
    HANDLE hFont;

    if ( !dyItem ) {
	hFont = (HANDLE)(DWORD)SendMessage(hDlg, WM_GETFONT, 0, 0L);
	if (!hFont)
	    hFont = GetStockObject( SYSTEM_FONT );
	hFont = SelectObject( hDC, hFont );
	GetTextMetrics( hDC, &tm );
	SelectObject( hDC, hFont );
	ReleaseDC( hDlg, hDC );
	dyText = tm.tmHeight;
	dyItem = max( dyDirDrive, dyText );
    }

    mis->itemHeight = dyItem;
}


/**************************************************************************/
/***                                                                    ***/
/***	DrawItem							***/
/***                                                                    ***/
/**************************************************************************/

void DrawItem( HWND hDlg, WPARAM wParam, LPDRAWITEMSTRUCT lpdis, BOOL bSave )
{
    HDC hdcList;
    RECT rectHilite;
    char szText[_MAX_PATH+1];
    WORD dxAcross;
    short nHeight;
    LONG rgbBack, rgbText, rgbOldBack, rgbOldText;
    short nShift = 1;		     /* to shift directories right in lst2 */
    BOOL bSel;
    int BltItem;

    *szText = 0;
    if ( lpdis->CtlID != IDD_DRIVEID )
	return;

    hdcList = lpdis->hDC;

    SendDlgItemMessage( hDlg, lpdis->CtlID, CB_GETLBTEXT,
	(WPARAM)lpdis->itemID, (LPARAM)(LPSTR)szText );

//  This piece of code will cause the default optimization to truncate
//  the rest of the routine.
//
//  if (*szText == 0) {
//	/* if empty listing */
//	DefWindowProc( hDlg, WM_DRAWITEM, wParam, (LPARAM)lpdis );
//	return;
//  }

    AnsiLower((LPSTR) szText);

    nHeight = dyItem;

    CopyRect((LPRECT)&rectHilite, (LPRECT) &lpdis->rcItem);
    rectHilite.bottom = rectHilite.top + nHeight;

    /* Under Win 3.0 in a combobox, if it's in the listbox, it only has to
    /* be selected because focus isn't noted properly.
     */
    if ((wWinVer < 0x030A) && (lpdis->CtlType == ODT_COMBOBOX) &&
	(lpdis->rcItem.left == 0) && (lpdis->itemState & ODS_SELECTED))
	lpdis->itemState |= ODS_FOCUS;

    /* Careful checking of bSel is needed here.  Since the file listbox (lst1)
     * can allow multiselect, only ODS_SELECTED needs to be set.  But for the
     * directory listbox (lst2), ODS_FOCUS also needs to be set.
     * 03 September 1991      Clark Cyr
     */
    bSel = (lpdis->itemState & (ODS_SELECTED | ODS_FOCUS));
    if ((bSel & ODS_SELECTED) || (bSel & ODS_FOCUS)) {
	rgbBack = rgbHiliteColor;
	rgbText = rgbHiliteText;
    } else {
	rgbBack = rgbWindowColor;
	rgbText = rgbWindowText;
    }
    rgbOldBack = SetBkColor( hdcList, rgbBack );
    rgbOldText = SetTextColor( hdcList, rgbText );

    dxAcross = dxDirDrive / BMPHIOFFSET;
    BltItem = (int)(WORD)(DWORD)SendDlgItemMessage(hDlg, IDD_DRIVEID,
	CB_GETITEMDATA, (WPARAM) lpdis->itemID, 0);
    if ( bSel & ODS_SELECTED )
	BltItem += BMPHIOFFSET;

    /* Draw the name */
    ExtTextOut( hdcList, rectHilite.left+dxSpace+dxAcross + dxSpace * nShift,
	rectHilite.top + (nHeight - dyText)/2, ETO_OPAQUE | ETO_CLIPPED,
	(LPRECT) &rectHilite, (LPSTR) szText, lstrlen((LPSTR) szText),
	NULL );

    BitBlt(hdcList, rectHilite.left+dxSpace*nShift,
	rectHilite.top + (dyItem - dyDirDrive)/2,
	dxAcross, dyDirDrive, hdcMemory, BltItem*dxAcross, 0, SRCCOPY);

    SetTextColor( hdcList, rgbOldText );
    SetBkColor( hdcList, rgbOldBack );

    if ( lpdis->itemState & ODS_FOCUS )
	DrawFocusRect( hdcList, (LPRECT)&lpdis->rcItem );
    return;
}


/**************************************************************************/
/***                                                                    ***/
/***	vDeleteDirDriveBitmap						***/
/***                                                                    ***/
/**************************************************************************/

void vDeleteDirDriveBitmap()
{
    SelectObject( hdcMemory, hbmpOrigMemBmp );
    if ( hbmpDirDrive != (HANDLE)NULL ) {
	DeleteObject( hbmpDirDrive );
	hbmpDirDrive = (HANDLE)NULL;
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	LoadDirDriveBitmap						***/
/***                                                                    ***/
/***	Creates the drive/directory bitmap.  If an appropriate bitmap	***/
/***	already exists, it just returns immediately.  Otherwise, it	***/
/***	loads the bitmap and creates a larger bitmap with both regular	***/
/***	and highlight colors.						***/
/***                                                                    ***/
/**************************************************************************/

BOOL LoadDirDriveBitmap()
{
    BITMAP  bmp;
    HANDLE  hbmp, hbmpOrig;
    HDC     hdcTemp;
    BOOL    bWorked = FALSE;

    if ((hbmpDirDrive != (HANDLE)NULL) &&
	(rgbWindowColor == rgbDDWindow) && (rgbHiliteColor == rgbDDHilite))
	if ( SelectObject( hdcMemory, hbmpDirDrive ) )
            return(TRUE);

    vDeleteDirDriveBitmap();

    rgbDDWindow = rgbWindowColor;
    rgbDDHilite = rgbHiliteColor;

    if ( !(hdcTemp = CreateCompatibleDC(hdcMemory)) )
        goto LoadExit;

    if ( !(hbmp = LoadAlterBitmap(IDS_DRVBMP, rgbSolidBlue, rgbWindowColor)))
        goto DeleteTempDC;

    GetObject( hbmp, sizeof(BITMAP), (LPSTR) &bmp );
    dyDirDrive = bmp.bmHeight;
    dxDirDrive = bmp.bmWidth;

    hbmpOrig = SelectObject( hdcTemp, hbmp );

    hbmpDirDrive = CreateDiscardableBitmap( hdcTemp, dxDirDrive*2, dyDirDrive );
    if ( !hbmpDirDrive )
        goto DeleteTempBmp;

    if ( !SelectObject(hdcMemory, hbmpDirDrive) ) {
        vDeleteDirDriveBitmap();
        goto DeleteTempBmp;
    }

    BitBlt( hdcMemory, 0, 0, dxDirDrive, dyDirDrive, hdcTemp, 0, 0, SRCCOPY );
    SelectObject( hdcTemp, hbmpOrig );
    DeleteObject( hbmp );

    if ( !(hbmp = LoadAlterBitmap(IDS_DRVBMP, rgbSolidBlue, rgbHiliteColor)) )
        goto DeleteTempDC;

    hbmpOrig = SelectObject( hdcTemp, hbmp );
    BitBlt( hdcMemory, dxDirDrive, 0, dxDirDrive, dyDirDrive,
	hdcTemp, 0, 0, SRCCOPY );
    SelectObject( hdcTemp, hbmpOrig );

    MySetObjectOwner( hbmpDirDrive );
    bWorked = TRUE;

DeleteTempBmp:
    DeleteObject( hbmp );
DeleteTempDC:
    DeleteDC( hdcTemp );
LoadExit:
    return bWorked;
}


/**************************************************************************/
/***                                                                    ***/
/***	LoadAlterBitmap 						***/
/***									***/
/***	Loads a bitmap given its name and gives all the pixels that are ***/
/***	a certain color a new color.					***/
/***                                                                    ***/
/**************************************************************************/

HBITMAP LoadAlterBitmap(int id, DWORD rgbReplace, DWORD rgbInstead)
{
    LPBITMAPINFOHEADER  qbihInfo;
    HDC                 hdcScreen;
    BOOL                fFound;
    HANDLE              hresLoad;
    HANDLE              hres;
    DWORD FAR *         qlng;
    LPBYTE              qbBits;
    HANDLE              hbmp;

    hresLoad = FindResource( hInst, MAKEINTRESOURCE(id), RT_BITMAP );
    if ( hresLoad == (HANDLE)NULL )
	return (HANDLE)NULL;
    hres = LoadResource( hInst, hresLoad );
    if ( hres == (HANDLE)NULL )
	return (HANDLE)NULL;

    rgbReplace = RgbInvertRgb( rgbReplace );
    rgbInstead = RgbInvertRgb( rgbInstead );
    qbihInfo = (LPBITMAPINFOHEADER)LockResource( hres );
    qlng = (LPLONG)((LPSTR)(qbihInfo) + qbihInfo->biSize);

    fFound = FALSE;
    while ( !fFound ) {
	if (*qlng == rgbReplace) {
            fFound = TRUE;
            *qlng = (LONG) rgbInstead;
	}
        qlng++;
    }
    UnlockResource( hres );

    qbihInfo = (LPBITMAPINFOHEADER)LockResource( hres );

    /* First skip over the header structure */
    qbBits = (LPBYTE)(qbihInfo + 1);

    /* Skip the color table entries, if any */
    qbBits += (1 << (qbihInfo->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    hdcScreen = GetDC( (HANDLE)NULL );
    if ( hdcScreen != (HANDLE)NULL ) {
	hbmp = CreateDIBitmap( hdcScreen, qbihInfo, (LONG)CBM_INIT,
	    qbBits, (LPBITMAPINFO) qbihInfo, DIB_RGB_COLORS );
	ReleaseDC( (HANDLE)NULL, hdcScreen );
    }

    UnlockResource( hres );
    FreeResource( hres );

    return( hbmp );
}


/**************************************************************************/
/***                                                                    ***/
/***	MySetObjectOwner						***/
/***									***/
/***	Call SetObjectOwner in GDI, eliminating "<Object> not released" ***/
/***	error messages when an app terminates.				***/
/***                                                                    ***/
/**************************************************************************/

void MySetObjectOwner( HANDLE hObject )
{
    VOID (FAR PASCAL *lpSetObjOwner)(HANDLE, HANDLE);
    HMODULE hMod;

    if ( wWinVer >= 0x030A ) {
	if ( hMod = GetModuleHandle("GDI") )
	    if ( lpSetObjOwner = GetProcAddress(hMod, MAKEINTRESOURCE(461)) )
	       (lpSetObjOwner)( hObject, hInst );
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	RgbInvertRgb							***/
/***									***/
/***	To reverse the byte order of the RGB value (for file format)	***/
/***	Return new color value (RGB to BGR)				***/
/***									***/
/**************************************************************************/

LONG RgbInvertRgb( LONG rgbOld )
{
    return((LONG) RGB(GetBValue(rgbOld), GetGValue(rgbOld), GetRValue(rgbOld)));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\rate.c ===
/**************************************************************************/
/***									***/
/***	RATE.C	- Cache hit rate charting routines			***/
/***									***/
/***									***/
/***									***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include "smartmon.h"

DWORD PrevHits = 0;	// last cache hit count
DWORD PrevTotal = 0;	// last cache hit+miss total
DWORD BaseHits = 0;
DWORD BaseTotal = 0;
WORD  CurrentRate;	// current hit rate
WORD  AveHitRate;	// averate hit rate
WORD  SpecInterval;	// specified sampling interval
WORD  Interval; 	// actual sampling intervals in seconds
WORD  Frequency;	// sampling frequency in msec
WORD  xDelta;		// width of each bar in histogram
HDC   hdcChart;
HBITMAP hbmpChart;
HBITMAP hbmpOrgChart;
HBITMAP hbmpIconDrv;
BOOL  fCacheIdle = TRUE;
COLORREF rgbHitRate;

HBRUSH hbrBkgnd;
HBRUSH hbrRed;
HPEN hpenFrame;
HBRUSH hbrOrg;
HPEN hpenOrg;

WNDPROC lpOrgWndProc = NULL;
LRESULT FAR PASCAL RBSubclass( HWND, WORD, WPARAM, LPARAM );
void DrawRateBox( HWND, HDC );
void GetRateBoxRect( HWND, LPRECT, BOOL );
void UpdateRateChart( HWND );
void UpdateRateIcon( HWND, HDC );
void DrawShadowedFrame( HDC, LPRECT );
void ResetRateChart( HWND );
BOOL GetHitRate( void );
void ResetRateChartColor( BOOL );

extern BOOL fIconic;
extern RECT rcIconic;
extern int PointsToHeight( int );
extern void MySetObjectOwner( HANDLE );


/**************************************************************************/
/***                                                                    ***/
/***	GetRateBoxRect							***/
/***                                                                    ***/
/**************************************************************************/

void GetRateBoxRect( HWND hCtl, LPRECT lprc, BOOL fChartOnly )
{
    GetWindowRect( hCtl, lprc );

    //
    // Rectangle returned by GetWindowRect is in screen
    // coordinates.  Convert it to zero-based.
    //
    lprc->bottom -= lprc->top;
    lprc->right  -= lprc->left;
    lprc->left	  = 0;
    lprc->top	  = 0;

    //
    // Subtract the frame and shadow.
    //
    if ( fChartOnly ) {
	lprc->top++;
	lprc->left++;
	lprc->right -= 2;
	lprc->bottom -= 2;
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	InitRateBox							***/
/***                                                                    ***/
/**************************************************************************/

void InitRateBox( HWND hDlg )
{
    int i;
    HWND hCtl;
    RECT rc;
    HDC hdcScreen;
    int nPlanes;

    //
    // The hit rate box is a dummy LTEXT control item in the resource
    // template.  Subclass it and turn it into an owner-draw item.
    //
    hCtl = GetDlgItem( hDlg, IDD_CHARTBOX );
    lpOrgWndProc = (WNDPROC)GetClassLong( hCtl, GCL_WNDPROC );
    SetWindowLong( hCtl, GWL_WNDPROC, (LPARAM)(DWORD)RBSubclass );

    //
    // Initialize hit rate
    //
    PrevHits = get_cache_hits();
    PrevTotal = PrevHits + get_cache_misses();
    AveHitRate = (WORD)(PrevHits * 100 / PrevTotal);

    //
    // Set up a shadow bitmap for drawing the chart.
    //
    GetRateBoxRect( hCtl, (LPRECT)&rc, FALSE );
    hdcScreen = GetDC( 0 );
    if ( hdcChart = CreateCompatibleDC( hdcScreen ) ) {
	hbmpChart = CreateBitmap( rc.right-rc.left+1, rc.bottom-rc.top+1,
	    nPlanes = GetDeviceCaps( hdcChart, PLANES ),
	    GetDeviceCaps( hdcChart, BITSPIXEL ), NULL );
	hbmpOrgChart = SelectObject( hdcChart, hbmpChart );
	hbrRed = CreateSolidBrush( RGB(255, 0, 0) );
	UnrealizeObject( hbrRed );
	MySetObjectOwner( hdcChart );
	MySetObjectOwner( hbmpChart );
	MySetObjectOwner( hbrRed );
    }
    ReleaseDC( 0, hdcScreen );

    //
    // Show hit rate in red or white, depending on monitor type
    //
    rgbHitRate = nPlanes > 1 ? RGB(255, 0, 0) : RGB(0, 0, 0);

    ResetRateChartColor( TRUE );
    ResetRateChart( hCtl );
}


void ResetRateChart( HWND hCtl )
{
    int  i,j;
    RECT rc;
    WORD xSpan, xExtra, ySpan;

    GetRateBoxRect( hCtl, (LPRECT)&rc, FALSE );
    xSpan = rc.right - rc.left + 1;
    ySpan = rc.bottom - rc.top + 1;

    //
    // Erase whole box to background color
    //
    PatBlt( hdcChart, 0, 0, xSpan, ySpan, PATCOPY );

    //
    // Draw frame and shadow
    //
    MoveTo( hdcChart, rc.left, rc.top );
    LineTo( hdcChart, rc.right-2, rc.top );
    LineTo( hdcChart, rc.right-2, rc.bottom-2 );
    LineTo( hdcChart, rc.left, rc.bottom-2 );
    LineTo( hdcChart, rc.left, rc.top );
    MoveTo( hdcChart, rc.right-1, 1 );
    LineTo( hdcChart, rc.right-1, rc.bottom-1 );
    LineTo( hdcChart, 1, rc.bottom-1 );
    MoveTo( hdcChart, rc.right, 2 );
    LineTo( hdcChart, rc.right, rc.bottom );
    LineTo( hdcChart, 2, rc.bottom );

    //
    // Because the size of the graph is fixed, the width may not
    // evenly divide by the number of intervals.  This will cause
    // a total repaint to look like it had lost some data.  So we
    // take a short cut here to bump up the actual number of intervals
    // to match the width.
    //
    xDelta = max( 2, xSpan / SpecInterval );
    xExtra = xSpan - (xDelta-1) * SpecInterval;
    if ( xExtra )
	Interval = SpecInterval + (xExtra / xDelta + 1);
    else
	Interval = SpecInterval;
}


/**************************************************************************/
/***                                                                    ***/
/***	UpdateRateChart 						***/
/***                                                                    ***/
/**************************************************************************/

void UpdateRateChart( HWND hCtl )
{
    RECT rc;
    WORD xSpan, ySpan;
    HPEN hpenTmp;

    GetRateBoxRect( hCtl, (LPRECT)&rc, TRUE );
    xSpan = rc.right - rc.left + 1;
    ySpan = rc.bottom - rc.top + 1;

    //
    // Blt repaint area to the right to make room for new drawing.
    //
    BitBlt( hdcChart, xDelta, 0, rc.right - xDelta, rc.bottom,
	    hdcChart, 0, 0, SRCCOPY );

    //
    // Erase vacated area with background color.
    //
    PatBlt( hdcChart, rc.left, rc.top, xDelta, rc.bottom-1, PATCOPY );

    //
    // Draw new rate.  The '101' keeps the bar from reaching the top.
    //
    rc.right = xDelta;	    // +1 removes gap
    rc.top = ySpan - (ySpan * CurrentRate / 101);
    SelectObject( hdcChart, hbrRed );
    PatBlt( hdcChart, rc.left, min(rc.top+1, rc.bottom),
	rc.right-rc.left, max(0, rc.bottom-rc.top-1), PATCOPY );
    SelectObject( hdcChart, hbrBkgnd );
}


/**************************************************************************/
/***                                                                    ***/
/***	DrawRateBox							***/
/***                                                                    ***/
/**************************************************************************/

void DrawRateBox( HWND hCtl, HDC hDC )
{
    RECT rc;

    GetRateBoxRect( hCtl, (LPRECT)&rc, FALSE );

    //
    // Draw the whole chart
    //
    BitBlt( hDC, 0, 0, rc.right - rc.left + 1, rc.bottom - rc.top + 1,
	    hdcChart, 0, 0, SRCCOPY );
}


/**************************************************************************/
/***                                                                    ***/
/***	GetHitRate							***/
/***                                                                    ***/
/**************************************************************************/

BOOL GetHitRate()
{
    DWORD hits, total;

    //
    // Calculate current hit rate
    //
    hits = get_cache_hits();
    total = hits + get_cache_misses();
    if ( total == PrevTotal ) {
	fCacheIdle = TRUE;
	return FALSE;
    } else
	fCacheIdle = FALSE;

    if ( hits == PrevHits ) {
	CurrentRate = 0;
    } else {
	CurrentRate = (hits - PrevHits) * 100 / (total - PrevTotal);
	PrevHits = hits;
    }
    PrevTotal = total;

    //
    // Calculate lifetime average hit rate based on the last reset
    //
    if ( PrevTotal == BaseTotal )
	AveHitRate = 0;
    else
	AveHitRate = (WORD)((PrevHits-BaseHits) * 100 / (PrevTotal-BaseTotal));

    return TRUE;
}


/**************************************************************************/
/***                                                                    ***/
/***	ForceRateBoxRedraw						***/
/***                                                                    ***/
/**************************************************************************/

void ForceRateBoxRedraw( HWND hDlg )
{
    RECT rect;
    HWND hCtl;

    //
    // Update the shadow bitmap
    //
    hCtl = GetDlgItem( hDlg, IDD_CHARTBOX );
    UpdateRateChart( hCtl );

    if ( !fIconic ) {
	GetRateBoxRect( hCtl, (LPRECT)&rect, TRUE );
	InvalidateRect( hCtl, (LPRECT)&rect, FALSE );
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	RBSubclass							***/
/***                                                                    ***/
/**************************************************************************/

LRESULT FAR PASCAL RBSubclass( HWND hCtl, WORD msg, WPARAM wP, LPARAM lP )
{
    HDC hDC;
    RECT rect;
    PAINTSTRUCT ps;

    switch ( msg )
    {
    case WM_PAINT:
	hDC = BeginPaint( hCtl, &ps );
	DrawRateBox( hCtl, hDC );
	EndPaint( hCtl, &ps );
	break;

    default:
	return( CallWindowProc( lpOrgWndProc, hCtl, msg, wP, lP ) );
    }

    return 0L;
}


/**************************************************************************/
/***                                                                    ***/
/***	UpdateRateIcon							***/
/***									***/
/**************************************************************************/

void UpdateRateIcon( HWND hWnd, HDC hDC )
{
    extern WORD CurrentRate;
    extern HFONT hfontStatus;
    extern char szBuffer[];
    extern HDC hdcMemory;

    HFONT hfontOld = NULL;
    HBRUSH hBrush;
    HBITMAP hbmp;
    RECT rc;
    int dyBorder;
    WORD x, y;

    dyBorder = GetSystemMetrics( SM_CYBORDER );
    rc = rcIconic;

    //
    // Draw frame
    //
    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)) ) {
	rc.bottom = dyBorder;
	FillRect( hDC, &rc, hBrush );
	rc.bottom = rcIconic.bottom;

	rc.right = dyBorder;
	FillRect( hDC, &rc, hBrush );
	rc.right = rcIconic.right;

	rc.left = rc.right - dyBorder;
	FillRect( hDC, &rc, hBrush );
	rc.left = rcIconic.left;

	rc.top	= rc.bottom - dyBorder;
	FillRect( hDC, &rc, hBrush );
	rc.top = rcIconic.top;

	DeleteObject( hBrush );
    }

    //
    // Draw the current rate in top half
    //
    if ( hfontStatus )
	hfontOld = SelectObject( hDC, hfontStatus );

    SetBkColor( hDC, GetSysColor(COLOR_BTNFACE) );
    if ( fCacheIdle ) {
	SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
	wsprintf( szBuffer, "%u%%", AveHitRate );
    } else {
	//
	// Use red for color systems, white for mono
	//
	SetTextColor( hDC, rgbHitRate );
	wsprintf( szBuffer, "%u%%", CurrentRate );
    }

    InflateRect( (LPRECT)&rc, -dyBorder, -dyBorder );
    x = rc.left + (rc.right - rc.left - (int)GetTextExtent( hDC,
	(LPSTR)szBuffer, lstrlen(szBuffer) )) / 2;
    y = rc.top + ((rc.bottom-rc.top)/2 - PointsToHeight(STATUSPOINTSIZE))/2;

    ExtTextOut( hDC, x, y, ETO_OPAQUE | ETO_CLIPPED, &rc, szBuffer,
	lstrlen(szBuffer), NULL );

    if ( hfontOld )
	SelectObject( hDC, hfontOld );

    //
    // Draw the drive bitmap in bottom half
    //
    hbmp = SelectObject( hdcMemory, hbmpIconDrv );
    y = (rc.bottom - rc.top) / 2;
    BitBlt( hDC, rc.left + (rc.right - rc.left - 16) / 2,
	    y + (y - 9)/2, 16, 9, hdcMemory, 0, 0, SRCCOPY );
    SelectObject( hdcMemory, hbmp );
}


void DrawIconBackground( HDC hDC )
{
    HBRUSH hBrush;

    //
    // Fill the rectangle with grey background color.
    //
    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)) ) {
	FillRect( hDC, (LPRECT)&rcIconic, hBrush );
	DeleteObject( hBrush );
    }
}


void ResetRateChartColor( BOOL fInit )
{
    if ( !fInit ) {
	SelectObject( hdcChart, hbrOrg );
	DeleteObject( hbrBkgnd );
	SelectObject( hdcChart, hpenOrg );
	DeleteObject( hpenFrame );
    }

    hbrBkgnd = CreateSolidBrush( GetSysColor(COLOR_WINDOW) );
    UnrealizeObject( hbrBkgnd );
    hpenFrame = CreatePen( PS_SOLID, 0, GetSysColor(COLOR_WINDOWFRAME) );
    UnrealizeObject( hpenFrame );

    MySetObjectOwner( hbrBkgnd );
    MySetObjectOwner( hpenFrame );

    hbrOrg = SelectObject( hdcChart, hbrBkgnd );
    hpenOrg = SelectObject( hdcChart, hpenFrame );
}


void CleanupRate()
{
    SelectObject( hdcChart, hbmpOrgChart );
    DeleteObject( hbmpChart );

    SelectObject( hdcChart, hbrBkgnd );
    DeleteObject( hbrBkgnd );

    SelectObject( hdcChart, hbrRed );
    DeleteObject( hbrRed );

    SelectObject( hdcChart, hpenFrame );
    DeleteObject( hpenFrame );

    DeleteDC( hdcChart );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\smartmon.c ===
/**************************************************************************/
/***									***/
/***	SMARTMON.C  - SmartDrv 4.0 monitor application main module	***/
/***									***/
/***									***/
/***									***/
/***									***/
/**************************************************************************/

/**************************************************************************/
/***									***/
/***	Global variable declarations and initializations		***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include "smartmon.h"

HANDLE	hInst;		    // application instance handle
HWND	hWndMain;	    // application's main window
char	szBuffer[BUFLEN];   // buffer for stringtable stuff
char	szTitle[20];	    // from resource
DWORD	DosCacheSize;	    // Cache size (Kbyte) under DOS
DWORD	WinCacheSize;	    // Cache size (Kbyte) under Windows
WORD	wWinVer;	    // Windows version
BOOL	fIconic;	    // flag to indicate if we're iconized
RECT	rcIconic;	    // window size while iconic
BOOL	fUpdateIconBackground;
BOOL	fAlreadyIdle;	    // cache idle during previous cycle
char	szStartLog[20];     // "Start Log" button label
char	szStopLog[20];	    // "Stop Log" button label
BOOL	fLogging;	    // logging status
HICON	hIcoDrag;	    // icon for dragging
HBITMAP hbmpIdle;	    // idle drive bitmap for icon
HBITMAP hbmpBusy;	    // busy drive bitmap for icon
HCURSOR hCurWait;	    // wait cursor
DWORD	LogStartTime;	    // logging start time
DWORD	LogStopTime;	    // logging auto-stop time
BOOL	fUpdateAuto;	    // change autoexec.bat or not
BOOL	fDriveInfoChanged;  // drive cache setting changed
BOOL	fProfileChanged;    // profile modified since start
BOOL	fTopMost;	    // run SmartMon as topmost window
BOOL	fTopMostChanged;    // save topmost info
char	szBatchFile[MAXFILENAMELEN];
HMENU	hSysMenu;

char	*szProSec = "SmartMon";     // profile section in WIN.INI
char	*szInterval = "Interval";   // profile key
char	*szFreq = "Frequency";	    // profile key
char	*szfStop = "AutoStop";	    // profile key
char	*szLogTime = "LogTime";     // profile key
char	*szUpdateDOS = "UpdateBatch";	 // profile key
char	*szLog = "LogFile";	    // profile key
char	*szBatch = "BatchFile";     // profile key
char	*szTopMost = "TopMost";     // profile key

extern	HBITMAP hbmpIconDrv;// either hbmpIdle or hbmpBusy
extern	WORD Frequency;     // sampling frequency
extern	HFONT hfontStatus;  // font used for text of status bar
extern	char szLogFile[];   // log file name
extern	WORD AutoLogTime;
extern	BOOL fAutoStop;
extern	WORD SpecInterval;
extern	DWORD BaseHits;
extern	DWORD BaseTotal;
extern	WORD AveHitRate;

long FAR PASCAL WambiWndProc( HWND, unsigned, WORD, LONG );
BOOL FAR PASCAL OptionsDlgProc( HWND, WORD, WPARAM, LPARAM );
void DoDriveControl( HWND, WORD, WORD );
void UpdateMemorySize( HWND );
void DoHelp( HWND, UINT, DWORD );
void ForceIconRedraw( HWND );
void CheckAutoStop( HWND );
void GetProfileSettings( void );
void SaveProfileSettings( void );
BOOL CheckForStacker( WORD );
void DoTopMost( HWND );

extern void MeasureItem( HANDLE, LPMEASUREITEMSTRUCT );
extern BOOL wNoRedraw;
extern void DrawItem( HWND, WPARAM, LPDRAWITEMSTRUCT, BOOL );
extern void DrawRateBox( HWND, int );
extern void InitRateBox( HWND );
extern void ForceRateBoxRedraw( HWND );
extern void InitStatusBar( HWND );
extern void UpdateStatusBar( HWND, HDC );
extern int  GetDriveIndex( WORD, WORD );
extern void DrawIconBackground( HDC );
extern void UpdateRateIcon( HWND, HDC );
extern BOOL GetHitRate( void );
extern BOOL StartLog( void );
extern void StopLog( void );
extern BOOL WriteLog( void );
extern void UpdateHelpMessage( int );
extern void CleanupRate( void );
extern void ResetRateChart( HWND );
extern void CheckDriveList( HWND );
extern void ResetDriveBox( HWND );
extern void InitDriveBitmap( void );
extern BOOL MungeBatchFile( void );
extern void ResetRateChartColor( BOOL );

/**************************************************************************/
/***                                                                    ***/
/***	WinMain 							***/
/***                                                                    ***/
/**************************************************************************/

int NEAR PASCAL WinMain( hInstance, hPrevInstance, lpszCmdLine, nCmdShow )
HANDLE hInstance;	// handle for this instance
HANDLE hPrevInstance;	// handle for possible previous instances
LPSTR lpszCmdLine;	// long pointer to exec command line
int nCmdShow;		// Show code for main window display
{
    MSG      msg;
    WNDCLASS wndclass;
    FARPROC  lpfnWndProc;

    //
    // Initialize state information.
    //
    hInst = hInstance;
    if ( !WambiInit( hPrevInstance ) )
	return FALSE;

    //
    // Register a window class.
    //
    if(!hPrevInstance) {
        wndclass.style          = NULL;
	wndclass.lpfnWndProc	= DefDlgProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = DLGWINDOWEXTRA;
        wndclass.hInstance      = hInstance;
	wndclass.hIcon		= NULL;
        wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW);
	wndclass.hbrBackground	= GetStockObject(WHITE_BRUSH);
	wndclass.lpszMenuName	= NULL;
	wndclass.lpszClassName	= "Wambi";

	if (!RegisterClass(&wndclass) )
            return FALSE;
    } else {
	return FALSE;	// Allow only one instance.
    }

    //
    // Create and show main dialog window.
    //
    lpfnWndProc = MakeProcInstance( (FARPROC)WambiWndProc, hInst );
    hWndMain = CreateDialog( hInst, "main", 0, lpfnWndProc );
    SetWindowPos( hWndMain, HWND_TOPMOST, 0, 0, 0, 0,
	SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW |
	(fTopMost ? 0 : SWP_NOZORDER) );
    fIconic = nCmdShow == SW_SHOWMINIMIZED;
    ShowWindow( hWndMain, nCmdShow );

    //
    // Main message loop
    //
    while ( GetMessage( &msg, NULL, 0, 0 ) ) {
	if ( !IsDialogMessage( hWndMain, &msg ) ) {
	    TranslateMessage( &msg );
	    DispatchMessage( &msg );
	}
    }

    UnregisterClass( szTitle, hInst );

    return msg.wParam;
}


/**************************************************************************/
/***                                                                    ***/
/***	WambiWndProc							***/
/***                                                                    ***/
/**************************************************************************/

long FAR PASCAL WambiWndProc( hWnd, Message, wParam, lParam )
HWND hWnd;
unsigned Message;
WORD wParam;
LONG lParam;
{
    extern HBRUSH hbrBkgnd;
    extern HBRUSH hbrFrame;
    extern RECT rcStatusLine;	// Bounding rect for status bar.

    HDC hDC;
    PAINTSTRUCT ps;
    FARPROC lpfnOptionWndProc;

    switch (Message)
    {
    case WM_INITDIALOG:
	EnableWindow( GetDlgItem(hWnd, IDD_STOPLOG), FALSE );
	wsprintf( szBuffer, "%u msec", Frequency );
	SetDlgItemText( hWnd, IDD_SAMPFREQ, szBuffer );

	InitDriveBox( hWnd );
	InitRateBox( hWnd );
	InitStatusBar( hWnd );

	//
	// Insert "About" into system menu.  "About SmartMon" would
	// stretch the system menu box too wide.  Also insert
	// "Always on Top".
	//
	hSysMenu = GetSystemMenu( hWnd, FALSE );
	AppendMenu( hSysMenu, MF_SEPARATOR, 0, (LPSTR)NULL );
	AppendMenu( hSysMenu, MF_STRING, IDD_ABOUT,   "&About...");
	AppendMenu( hSysMenu, MF_STRING, IDD_TOPMOST, "Always on &Top" );
	CheckMenuItem( hSysMenu, IDD_TOPMOST,
	    fTopMost ? MF_CHECKED : MF_UNCHECKED );

	SetTimer( hWnd, 0, Frequency, NULL );
	break;

    case WM_TIMER:
	if ( GetHitRate() ) {
	    hbmpIconDrv = hbmpBusy;
	    ForceRateBoxRedraw( hWnd );
	    if ( fLogging ) {
		WriteLog();
		UpdateHelpMessage( IDS_LOGGING );
	    } else
		UpdateHelpMessage( IDS_CACHEACTIVE );
	    if ( fIconic ) {
		InvalidateRect( hWnd, (LPRECT)NULL, FALSE );
	    }
	    fAlreadyIdle = FALSE;
	} else {
	    UpdateHelpMessage( IDS_CACHEIDLE );
	    hbmpIconDrv = hbmpIdle;
	    if ( fIconic )
		if ( !fAlreadyIdle ) {
		    InvalidateRect( hWnd, (LPRECT)NULL, FALSE );
		    fAlreadyIdle = TRUE;
		}
	}

	CheckAutoStop( hWnd );
	break;

    case WM_ACTIVATE:
	//
	// We never know when a network share could be disconnected,
	// or a CD-ROM dismounted.  So be safe, reset all the drives.
	//
	if ( wParam != WA_INACTIVE )
	    ResetDriveBox( hWnd );
	break;

    case WM_MOVE:
	if ( fIconic )
	    fUpdateIconBackground = TRUE;
	break;

    case WM_SIZE:
	if ( (wParam == SIZE_MINIMIZED) ) {
	    if ( !fIconic ) {
		fIconic = fUpdateIconBackground = TRUE;
		SetRect((LPRECT)&rcIconic, 0, 0, LOWORD(lParam), HIWORD(lParam));
	    }
	} else
	    fIconic = FALSE;
	break;

    case WM_PAINT:
	hDC = BeginPaint( hWnd, &ps );

	if ( fIconic ) {
	    if ( fUpdateIconBackground ) {
		fUpdateIconBackground = FALSE;
		DrawIconBackground( hDC );
	    } else
		ValidateRect( hWnd, (LPRECT)NULL );
	    UpdateRateIcon( hWnd, hDC );
	} else {
	    UpdateMemorySize( hWnd );
	    UpdateStatusBar( hWnd, hDC );
	}

	EndPaint( hWnd, &ps );
	return TRUE;

    case WM_MEASUREITEM:
	MeasureItem( hWnd, (LPMEASUREITEMSTRUCT)lParam );
	return TRUE;

    case WM_DRAWITEM:
	DrawItem( hWnd, wParam, (LPDRAWITEMSTRUCT)lParam, FALSE );
	return TRUE;

    case WM_SYSCOMMAND:
	if ( wParam == IDD_ABOUT )
	    ShellAbout( hWnd, szTitle, NULL, hIcoDrag );
	else if ( wParam == IDD_TOPMOST )
	    DoTopMost( hWnd );
	break;

    case WM_KEYDOWN:
	if ( wParam == VK_F1 ) {
	    PostMessage( hWnd, WM_COMMAND, IDD_HELP, 0L );
	    return TRUE;
	}
	break;

    case WM_COMMAND:
	switch( wParam )
	{
	case IDCANCEL:
	    SendDlgItemMessage( hWnd, IDD_DRIVEID, CB_SHOWDROPDOWN, FALSE, 0 );
	    break;

	case IDD_READONLY:
	case IDD_READWRITE:
	case IDD_NOCACHING:
	    DoDriveControl( hWnd, SET, wParam );
	    break;

	case IDD_FLUSH:
	    commit_cache();
	    UpdateHelpMessage( IDS_FLUSHED );
	    break;

	case IDD_RESET:
	    reset_cache();

	    //
	    // Reset lifetime average hit rate baseline
	    //
	    BaseHits = get_cache_hits();
	    BaseTotal = get_cache_misses() + BaseHits;
	    AveHitRate = 0;

	    UpdateHelpMessage( IDS_RESET );
	    break;

	case IDD_DRIVEID:
	    if ( HIWORD(lParam) == CBN_SELCHANGE )
		DoDriveControl( hWnd, GET, 0 );
	    break;

	case IDD_HELP:
	    DoHelp( hWnd, HELP_INDEX, 0L );
	    break;

	case IDD_STARTLOG:
	    if ( StartLog() ) {
		EnableWindow( GetDlgItem(hWnd, IDD_STARTLOG), FALSE );
		EnableWindow( GetDlgItem(hWnd, IDD_STOPLOG), TRUE );
		fLogging = TRUE;
		UpdateHelpMessage( IDS_LOGSTARTED );

		LogStartTime = GetTickCount();
		if ( fAutoStop )
		    LogStopTime = LogStartTime + AutoLogTime * 60000;
	    } else
		MessageBox( hWnd, (LPSTR)"Can not start logging.",
		    (LPSTR)szTitle, MB_ICONINFORMATION );
	    break;

	case IDD_STOPLOG:
	    StopLog();
	    EnableWindow( GetDlgItem(hWnd, IDD_STOPLOG), FALSE );
	    EnableWindow( GetDlgItem(hWnd, IDD_STARTLOG), TRUE );
	    fLogging = FALSE;
	    UpdateHelpMessage( IDS_LOGSTOPPED );
	    break;

	case IDD_OPTION:
	    lpfnOptionWndProc = MakeProcInstance( OptionsDlgProc, hInst );
	    DialogBox( hInst, "options", hWndMain, lpfnOptionWndProc );
	    FreeProcInstance( lpfnOptionWndProc );
	    break;
	}
	return TRUE;

    case WM_CLOSE:
	if ( fLogging )
	    StopLog();

	if ( fTopMostChanged ) {
	    wsprintf( szBuffer, "%u", fTopMost );
	    WriteProfileString( szProSec, szTopMost, szBuffer );
	}

	if ( fDriveInfoChanged && fUpdateAuto ) {
	    if ( !MungeBatchFile() ) {
		LoadString( hInst, IDS_SAVEAUTO, szBuffer, BUFLEN );
		if ( MessageBox( hWnd, (LPSTR)szBuffer, (LPSTR)szTitle,
		    MB_ICONINFORMATION | MB_OKCANCEL ) == IDCANCEL )
		    return TRUE;
	    }
	}

	CleanupRate();
	DestroyIcon( hIcoDrag );
	DeleteObject( hbmpIdle );
	DeleteObject( hbmpBusy );

	if ( hfontStatus )
	    DeleteObject( hfontStatus );

	DoHelp( hWnd, HELP_QUIT, 0L );

	DestroyWindow( hWnd );
	return TRUE;

    case WM_DESTROY:
	PostQuitMessage(0);
	break;

    case WM_SYSCOLORCHANGE:
	ResetRateChartColor( FALSE );
	ResetRateChart( GetDlgItem( hWndMain, IDD_CHARTBOX ) );
	ResetDriveBox( hWnd );
	break;

    case WM_QUERYDRAGICON:
	return hIcoDrag;
    }

    return FALSE;
}


/**************************************************************************/
/***                                                                    ***/
/***	WambiInit							***/
/***                                                                    ***/
/**************************************************************************/

BOOL WambiInit( HANDLE hPrevInstance )
{
    extern char CurDriveList[];
    extern WORD CurDriveCount;

    WORD BlockSize, DosBlocks, WinBlocks;
    char cBootDrv;
    int i, iDrv, iDrvIndex;

    //
    // Load basic string resources.
    //
    LoadString( hInst, IDS_TITLE, szTitle, 20 );
    LoadString( hInst, IDS_STARTLOG, szStartLog, 20 );
    LoadString( hInst, IDS_STOPLOG, szStopLog, 20 );
    LoadString( hInst, IDS_LOGFILE, szLogFile, MAXFILENAMELEN );
    hIcoDrag = LoadIcon( hInst, MAKEINTRESOURCE(1) );
    hbmpIdle = LoadBitmap( hInst, MAKEINTRESOURCE(2) );
    hbmpBusy = LoadBitmap( hInst, MAKEINTRESOURCE(3) );
    hCurWait = LoadCursor( NULL, IDC_WAIT );

    //
    // Allow single instance to run.
    //
    if ( hPrevInstance ) {
	MessageBox( (HWND)NULL, (LPSTR)"SmartMon is already running.",
	    (LPSTR)szTitle, MB_ICONINFORMATION );
	return FALSE;
    }

    //
    // Don't allow app to run if SmartDrive is not installed.
    //
    if ( get_cache_hits() == -1L ) {
	MessageBox( (HWND)NULL, (LPSTR)"SmartDrive is not installed.",
	    (LPSTR)szTitle, MB_ICONINFORMATION );
	return FALSE;
    }

    //
    // Get cache size
    //
    BlockSize = get_cache_info( &DosBlocks, &WinBlocks );
    DosCacheSize = (DWORD)DosBlocks * (DWORD)BlockSize / 1024;
    WinCacheSize = (DWORD)WinBlocks * (DWORD)BlockSize / 1024;

    //
    // Compose default DOS batch filename (for saving drive settings).
    // The default is AUTOEXEC.BAT on the boot drive.  If we can't
    // identify the boot drive, then assume the first hard disk.
    //
    if ( LOBYTE(get_dos_version()) >= 4 )
	cBootDrv = get_boot_drive() - 1 + 'a';
    else {
	CurDriveCount = count_valid_drives( CurDriveList );
	cBootDrv = 'c';
	for ( i = 0; i < CurDriveCount; i++ ) {
	    iDrv = CurDriveList[i+1];
	    iDrvIndex = GetDriveIndex( iDrv, GetDriveType( iDrv ) );
	    if ( iDrvIndex == HARDDRVBMP ) {
		cBootDrv = iDrv + 'a';
		break;
	    }
	}
    }
    wsprintf( szBatchFile, "%c:\\autoexec.bat", cBootDrv );

    //
    // Initialize all random things here
    //
    wWinVer = GetVersion();
    fUpdateIconBackground = FALSE;
    fTopMostChanged = FALSE;
    fLogging = FALSE;
    UpdateHelpMessage( IDS_TITLE );
    hbmpIconDrv = hbmpIdle;
    fProfileChanged = FALSE;
    fAlreadyIdle = FALSE;
    fDriveInfoChanged = FALSE;
    InitDriveBitmap();
    fTopMost = TRUE;

    GetProfileSettings();

    return TRUE;
}


#ifdef OBSOLETE
/**************************************************************************/
/***                                                                    ***/
/***	UpdateStat							***/
/***                                                                    ***/
/***	This routine displays the hit/miss count and ratio is simple	***/
/***	text format.							***/
/***                                                                    ***/
/***	Note that it might be a good idea to activate this code when	***/
/***	InitRateBox fails for some reason (like low memory).		***/
/***                                                                    ***/
/**************************************************************************/

void UpdateStat( HWND hWnd )
{
    DWORD hits, misses, rate;

    //
    // Get cache status
    //
    hits = get_cache_hits();
    misses = get_cache_misses();
    rate = (hits * 100) / (hits + misses);

    //
    // Display cache status
    //
    wsprintf( szBuffer, "%lu", hits );
    SetDlgItemText( hWnd, IDD_HITS, szBuffer );
    wsprintf( szBuffer, "%lu", misses );
    SetDlgItemText( hWnd, IDD_MISSES, szBuffer );
    wsprintf( szBuffer, "%lu%%", rate );
    SetDlgItemText( hWnd, IDD_RATE, szBuffer );
}
#endif


/**************************************************************************/
/***                                                                    ***/
/***	DoDriveControl							***/
/***                                                                    ***/
/***	This routine changes the caching status of each drive as	***/
/***	the user manipulates the corresponding radio buttons.		***/
/***                                                                    ***/
/***	Since the caching status, as well as drive configuration	***/
/***	can be changed outside of SMARTMON, this routine should 	***/
/***	be called to do a GET whenever we get focus back.		***/
/***                                                                    ***/
/**************************************************************************/

void DoDriveControl( HWND hWnd, WORD cmd, WORD id )
{
    extern WORD cCurDriveSel;

    WORD status;
    WORD iCurDrvIndex;
    HWND hCtl;

    hCtl = GetDlgItem( hWnd, IDD_DRIVEID );
    SendMessage( hCtl, CB_GETLBTEXT,
	(WPARAM)(DWORD)SendMessage(hCtl, CB_GETCURSEL,0,0),
	(LPARAM)(LPSTR)szBuffer );
    cCurDriveSel = szBuffer[0] - 'a';

    if ( cmd == GET ) {

	status = cache_a_drive( GET, cCurDriveSel );

	if ( status & NO_READ )
	    id = IDD_NOCACHING;
	else if ( status & NO_WRITE )
	    id = IDD_READONLY;
	else
	    id = IDD_READWRITE;

	//
	// Disable r/o and r/w buttons if drive cannot be cached.
	//
	iCurDrvIndex = GetDriveIndex( cCurDriveSel, GetDriveType( cCurDriveSel ) );
	if ( (iCurDrvIndex == FLOPPYBMP) ||
	     ((iCurDrvIndex == HARDDRVBMP) && !CheckForStacker(cCurDriveSel))) {
	    EnableWindow( GetDlgItem(hWnd, IDD_READONLY), TRUE );
	    EnableWindow( GetDlgItem(hWnd, IDD_READWRITE), TRUE );
	    EnableWindow( GetDlgItem(hWnd, IDD_NOCACHING), TRUE );
	} else {
	    EnableWindow( GetDlgItem(hWnd, IDD_READONLY), FALSE );
	    EnableWindow( GetDlgItem(hWnd, IDD_READWRITE), FALSE );
	    EnableWindow( GetDlgItem(hWnd, IDD_NOCACHING), FALSE );
	}

    } else {	// Set operation

	//
	// Get into a known state, then disable selectively
	//
	cache_a_drive( ENABLE_READ, cCurDriveSel );
	cache_a_drive( ENABLE_WRITE, cCurDriveSel );

	if ( id != IDD_READWRITE ) {
	    cache_a_drive( DISABLE_WRITE, cCurDriveSel );
	    if ( id == IDD_NOCACHING )
		cache_a_drive( DISABLE_READ, cCurDriveSel );
	}

	fDriveInfoChanged = TRUE;
	UpdateHelpMessage( IDS_STATUS );
    }

    CheckRadioButton( hWnd, IDD_READONLY, IDD_NOCACHING, id );
}


/**************************************************************************/
/***                                                                    ***/
/***	UpdateMemorySize						***/
/***                                                                    ***/
/***	This routine displays the cache memory size under DOS and	***/
/***	under Windows.	Currently the size cannot be changed when	***/
/***	Windows is running.						***/
/***                                                                    ***/
/**************************************************************************/

void UpdateMemorySize( HWND hWnd )
{
    wsprintf( szBuffer, "%uK", DosCacheSize );
    SetDlgItemText( hWnd, IDD_DOSSIZE, szBuffer );
    wsprintf( szBuffer, "%uK", WinCacheSize );
    SetDlgItemText( hWnd, IDD_WINSIZE, szBuffer );
}


/**************************************************************************/
/***                                                                    ***/
/***	DoHelp								***/
/***                                                                    ***/
/***	This routine invokes WINHELP if BOOL is true, or dismisses	***/
/***	it if BOOL is false.						***/
/***									***/
/**************************************************************************/

void DoHelp( HWND hWnd, UINT cmd, DWORD data )
{
    if ( LoadString(hInst, IDS_HELPFILE, szBuffer, sizeof(szBuffer)-1) )
	WinHelp( hWnd, (LPSTR)szBuffer, cmd, data );
}


/**************************************************************************/
/***                                                                    ***/
/***	OptionsDlgProc							***/
/***									***/
/**************************************************************************/

BOOL FAR PASCAL OptionsDlgProc( hDlg, msg, wParam, lParam )
HWND hDlg;
WORD msg;
WPARAM wParam;
LPARAM lParam;
{
    OFSTRUCT of;
    int rc;
    WORD val;
    BOOL bRet;
    HWND hCtl;

    switch ( msg )
    {
    case WM_INITDIALOG:
	SetDlgItemInt( hDlg, IDD_MSEC, Frequency, FALSE );
	SetDlgItemInt( hDlg, IDD_INTERVAL, SpecInterval, FALSE );
	SetDlgItemText( hDlg, IDD_LOGFILE, szLogFile );
	CheckDlgButton( hDlg, IDD_AUTOSTOP, fAutoStop );
	SetDlgItemInt( hDlg, IDD_STOPTIME, AutoLogTime, FALSE );
	CheckDlgButton( hDlg, IDD_SAVESET, fUpdateAuto );
	SetDlgItemText( hDlg, IDD_BATCHFILE, szBatchFile );
	break;

    case WM_COMMAND:
	switch( wParam )
	{
	case IDD_HELP:
	    DoHelp( hDlg, HELP_CONTEXT, 1L );
	    break;

	case IDD_AUTOSTOP:
	    CheckDlgButton( hDlg, IDD_AUTOSTOP,
		!IsDlgButtonChecked(hDlg, IDD_AUTOSTOP) );
	    break;

	case IDD_SAVESET:
	    CheckDlgButton( hDlg, IDD_SAVESET,
		!IsDlgButtonChecked(hDlg, IDD_SAVESET) );
	    break;

	case IDOK:

	    //
	    //	Reset sampling frequency
	    //
	    val = GetDlgItemInt( hDlg, IDD_MSEC, (BOOL FAR*)&bRet, FALSE );
	    if ( bRet ) {
		if ( val > MAX_FREQUENCY )
		    val = MAX_FREQUENCY;
		if ( val < MIN_FREQUENCY )
		    val = MIN_FREQUENCY;
		if ( val != Frequency ) {
		    Frequency = val;
		    KillTimer( hWndMain, 0 );
		    SetTimer( hWndMain, 0, Frequency, NULL );
		    wsprintf( szBuffer, "%u msec", Frequency );
		    SetDlgItemText( hWndMain, IDD_SAMPFREQ, szBuffer );
		}
	    }

	    //
	    //	Reset display interval
	    //
	    val = GetDlgItemInt( hDlg, IDD_INTERVAL, (BOOL FAR*)&bRet, FALSE );
	    if ( bRet ) {
		if ( val > MAX_INTERVAL )
		    val = MAX_INTERVAL;
		if ( val < MIN_INTERVAL )
		    val = MIN_INTERVAL;
		if ( val != SpecInterval ) {
		    SpecInterval = val;
		    hCtl = GetDlgItem( hWndMain, IDD_CHARTBOX );
		    ResetRateChart( hCtl );
		    InvalidateRect( hCtl, (LPRECT)NULL, TRUE );
		}
	    }

	    GetDlgItemText( hDlg, IDD_LOGFILE, szLogFile, MAXFILENAMELEN );

	    fAutoStop = IsDlgButtonChecked( hDlg, IDD_AUTOSTOP );
	    val = GetDlgItemInt( hDlg, IDD_STOPTIME, (BOOL FAR *)&bRet, FALSE );
	    if ( bRet )
		AutoLogTime = val;
	    if ( AutoLogTime > MAX_AUTOLOGTIME )
		AutoLogTime = MAX_AUTOLOGTIME;
	    if ( AutoLogTime < MIN_AUTOLOGTIME )
		AutoLogTime = MIN_AUTOLOGTIME;

	    if ( fLogging )
		LogStopTime = LogStartTime + AutoLogTime * 60000;

	    fUpdateAuto = IsDlgButtonChecked( hDlg, IDD_SAVESET );
	    GetDlgItemText( hDlg, IDD_BATCHFILE, szBuffer, BUFLEN );
	    rc = OpenFile( (LPSTR)szBuffer, (OFSTRUCT FAR *)&of, OF_EXIST );
	    SetDlgItemText( hDlg, IDD_BATCHFILE, of.szPathName );
	    OemToAnsi( of.szPathName, szBatchFile );
	    if ( fUpdateAuto &&  (rc == -1) ) {
		MessageBox( (HWND)NULL, (LPSTR)"Batch file does not exist.",
		(LPSTR)szTitle, MB_ICONINFORMATION );
		return TRUE;
	    }

	    SaveProfileSettings();

	    // fall through

	case IDCANCEL:
	    DoHelp( hDlg, HELP_QUIT, 0L );
	    EndDialog( hDlg, 0 );
	    break;
	}
	break;

    default:
	return FALSE;	// message not processed
    }

    return TRUE;    // message processed
}


/**************************************************************************/
/***                                                                    ***/
/***	CheckAutoStop							***/
/***									***/
/***	This routine stops logging to file.  Note that the logging	***/
/***	auto stop time may be altered through the options box after	***/
/***	logging has been started.					***/
/***									***/
/**************************************************************************/

void CheckAutoStop( HWND hWnd )
{
    if ( fLogging && fAutoStop )
	//
	// Note, this logic will fail if tick counter wraps around
	//
	if ( GetTickCount() > LogStopTime )
	    PostMessage( hWnd, WM_COMMAND, IDD_STOPLOG, 0L );
}


/**************************************************************************/
/***                                                                    ***/
/***	GetProfileSettings						***/
/***	SaveProfileSettings						***/
/***									***/
/***	Get and save settings to WIN.INI.				***/
/***									***/
/**************************************************************************/
void GetProfileSettings()
{
    //
    // Retrieve option settings from WIN.INI
    //
    SpecInterval = GetProfileInt( szProSec, szInterval, DEF_INTERVAL );
    Frequency	 = GetProfileInt( szProSec, szFreq, DEF_FREQUENCY );
    fAutoStop	 = GetProfileInt( szProSec, szfStop, DEF_AUTOSTOP );
    AutoLogTime  = GetProfileInt( szProSec, szLogTime, DEF_LOGTIME );
    fUpdateAuto  = GetProfileInt( szProSec, szUpdateDOS, DEF_UPDATEDOS );
    fTopMost	 = GetProfileInt( szProSec, szTopMost, DEF_TOPMOST );

    if ( GetProfileString( szProSec, szLog, szLogFile, szBuffer, BUFLEN ) )
	lstrcpy( szLogFile, szBuffer );
    if ( GetProfileString( szProSec, szBatch, szBatchFile, szBuffer, BUFLEN ) )
	lstrcpy( szBatchFile, szBuffer );
}


void SaveProfileSettings()
{
    //
    // Save option settings to profile
    //
    wsprintf( szBuffer, "%u", SpecInterval );
    WriteProfileString( szProSec, szInterval, szBuffer );
    wsprintf( szBuffer, "%u", Frequency );
    WriteProfileString( szProSec, szFreq, szBuffer );
    wsprintf( szBuffer, "%u", fAutoStop );
    WriteProfileString( szProSec, szfStop, szBuffer );
    wsprintf( szBuffer, "%u", AutoLogTime );
    WriteProfileString( szProSec, szLogTime, szBuffer );
    wsprintf( szBuffer, "%u", fUpdateAuto );
    WriteProfileString( szProSec, szUpdateDOS, szBuffer );
    wsprintf( szBuffer, "%u", fTopMost );
    WriteProfileString( szProSec, szTopMost, szBuffer );
    WriteProfileString( szProSec, szLog, szLogFile );
    WriteProfileString( szProSec, szBatch, szBatchFile );
}


/**************************************************************************/
/***                                                                    ***/
/***	CheckForStacker 						***/
/***									***/
/***	This routine does an absolute disk read (INT 25) of the 	***/
/***	first sector, and checks the disk label to see if it is 	***/
/***	a Stacker volume.  We allocate an 8K buffer to serve as 	***/
/***	the DTA (same as WINFILE), hope it's big enough for all         ***/
/***	disks.								***/
/***									***/
/**************************************************************************/

BOOL CheckForStacker( WORD cDrv )
{
    HANDLE hBuf;
    LPSTR  pBuf;
    BOOL rc;

    //
    // If can't allocate DTA to do int 25, assume not Stacker
    //
    if (! (hBuf = GlobalAlloc( GHND, 8192L )) )
	return FALSE;
    pBuf = GlobalLock( hBuf );

    rc = is_Stacker_drive( cDrv, pBuf );

    GlobalUnlock( hBuf );
    GlobalFree( hBuf );

    return rc;
}


void DoTopMost( HWND hWnd )
{
    fTopMostChanged = TRUE;

    fTopMost = fTopMost ? FALSE : TRUE;
    CheckMenuItem( hSysMenu, IDD_TOPMOST, fTopMost? MF_CHECKED : MF_UNCHECKED );

    if ( !fTopMost ) {
	SetWindowPos( hWnd, HWND_BOTTOM, 0, 0, 0, 0,
	    SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW );
	SetWindowPos( hWnd, HWND_TOP, 0, 0, 0, 0,
	    SWP_NOMOVE | SWP_NOSIZE );
    } else
	SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0,
	    SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\log.c ===
/**************************************************************************/
/***									***/
/***	LOG.C	- Cache hit rate logging routines			***/
/***									***/
/***									***/
/***									***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include <io.h>
#include <stdio.h>
#include "smartmon.h"

char szLogFile[MAXFILENAMELEN];
char *szLogTitle = "   ticks,    total,     hits\r\n";
BOOL fLogAppend = TRUE;
BOOL fAutoStop;
WORD AutoLogTime;	// minutes
int hLogFile;


/**************************************************************************/
/***									***/
/***	StartLog							***/
/***									***/
/**************************************************************************/

BOOL StartLog()
{
    OFSTRUCT of;
    WORD mode;

    mode = OF_WRITE | OF_SHARE_DENY_WRITE;

    //
    // Create file if it doesn't exist or new file is requested
    //
    if ( !fLogAppend ||
	 OpenFile( (LPSTR)szLogFile, (OFSTRUCT FAR *)&of, OF_EXIST ) == -1)
	mode |= OF_CREATE;

    hLogFile = OpenFile( (LPSTR)szLogFile, (OFSTRUCT FAR*)&of, mode );

    if ( hLogFile != -1 ) {
	if ( mode & OF_CREATE )
	    write( hLogFile, szLogTitle, lstrlen(szLogTitle) );
	if ( fLogAppend ) {
	    lseek( hLogFile, 0L, SEEK_END );
	    write( hLogFile, "\r\n", 2 );
	}
	return TRUE;
    }

    return FALSE;
}


/**************************************************************************/
/***									***/
/***	StopLog 							***/
/***									***/
/**************************************************************************/

void StopLog()
{
    if ( hLogFile ) {
	close( hLogFile );
	hLogFile = 0;
    }
}


/**************************************************************************/
/***									***/
/***	WriteLog							***/
/***									***/
/**************************************************************************/

BOOL WriteLog( void )
{
    extern DWORD PrevTotal, PrevHits;
    extern char szBuffer[];

    wsprintf( szBuffer, "%8lu, %8lu, %8lu\r\n",
	GetTickCount(), PrevTotal, PrevHits );
    return write( hLogFile, szBuffer, lstrlen(szBuffer) ) != -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\status.c ===
/**************************************************************************/
/***									***/
/***	STATUS.C    - Status bar update routines			***/
/***									***/
/***	Largely borrowed from CHARMAP.C.				***/
/***									***/
/***									***/
/**************************************************************************/

#include <windows.h>
#include "smartmon.h"

extern HANDLE hInst;
extern char szBuffer[];     // buffer for stringtable stuff
extern WORD AveHitRate;
extern HWND hWndMain;	    // application's main window

void PaintStatusField( HDC, BOOL, BOOL );
int PointsToHeight( int );

RECT rcStatusLine;	    // Bounding rect for status bar.
int dyStatus;		    // Height of status bar.
int dxHelpField;	    // Width of help window.
HFONT hfontStatus;	    // Font used for text of status bar.
int dxHitRateField;	    // Width of HitRate window.
int iHelpMessage = 0;	    // help message resource string id

/**************************************************************************/
/***                                                                    ***/
/***	UpdateStatusBar 						***/
/***                                                                    ***/
/**************************************************************************/

void UpdateStatusBar( HWND hWnd, HDC hDC )
{
    HBRUSH hBrush;
    RECT rcTemp;
    int dyBorder;

    rcTemp = rcStatusLine;

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    //
    // Make the whole thing grey.
    //
    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)) ) {
	FillRect( hDC, &rcTemp, hBrush );
	DeleteObject( hBrush );
    }

    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)) ) {
	// Status line top.
	rcTemp.left   = 8 * dyBorder;
	rcTemp.right  = rcTemp.left + dxHelpField;
	rcTemp.top    = rcStatusLine.top + dyBorder * 2;
	rcTemp.bottom = rcTemp.top + dyBorder;
	FillRect( hDC, &rcTemp, hBrush );

	// HitRate line top.
	rcTemp.right = rcStatusLine.right - 8 * dyBorder;
	rcTemp.left = rcTemp.right - dxHitRateField;
	FillRect( hDC, &rcTemp, hBrush);

	// Status line left side.
	rcTemp = rcStatusLine;
	rcTemp.left = 8 * dyBorder;
	rcTemp.right = rcTemp.left + dyBorder;
	rcTemp.top += dyBorder * 2;
	rcTemp.bottom -= dyBorder * 2;
	FillRect( hDC, &rcTemp, hBrush );

	// HitRate line left side.
	rcTemp.left = rcStatusLine.right - 9 * dyBorder - dxHitRateField;
	rcTemp.right = rcTemp.left + dyBorder;
	FillRect( hDC, &rcTemp, hBrush );

	DeleteObject( hBrush );
    }

    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)) ) {
	// Status line bottom.
	rcTemp.left   = 8 * dyBorder;
	rcTemp.right  = rcTemp.left + dxHelpField;
	rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
	rcTemp.bottom = rcTemp.top + dyBorder;
	FillRect( hDC, &rcTemp, hBrush );

	// HitRate line bottom.
	rcTemp.right = rcStatusLine.right - 8 * dyBorder;
	rcTemp.left = rcTemp.right - dxHitRateField;
	FillRect( hDC, &rcTemp, hBrush );

	// Status line right side.
	rcTemp = rcStatusLine;
	rcTemp.left = 8 * dyBorder + dxHelpField;
	rcTemp.right = rcTemp.left + dyBorder;
	rcTemp.top += dyBorder * 2;
	rcTemp.bottom -= dyBorder * 2;
	FillRect( hDC, &rcTemp, hBrush );

	// HitRate line right side.
	rcTemp.left = rcStatusLine.right - 8 * dyBorder;
	rcTemp.right = rcTemp.left + dyBorder;
	FillRect( hDC, &rcTemp, hBrush );

	DeleteObject( hBrush );
    }

    //
    // Solid black line across top
    //
    if ( hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)) ) {
	rcTemp = rcStatusLine;
	rcTemp.bottom = rcTemp.top;
	rcTemp.top -= dyBorder;
	FillRect( hDC, &rcTemp, hBrush );
	DeleteObject( hBrush );
    }

    PaintStatusField( hDC, TRUE, TRUE );
}


/**************************************************************************/
/***                                                                    ***/
/***	UpdateHelpMessage						***/
/***                                                                    ***/
/**************************************************************************/

void UpdateHelpMessage( int id )
{
    extern BOOL fIconic;
    extern int Frequency;
    static int delay = 0;

    if ( iHelpMessage != id ) {

	//
	// Let the user-initiated messages stay for two seconds.
	// During that time it can be pre-empted by another such
	// message, but other low-priority messages are lost.
	//
	if ( (id == IDS_LOGSTARTED) ||
	     (id == IDS_LOGSTOPPED) ||
	     (id == IDS_STATUS)     ||
	     (id == IDS_FLUSHED)    ||
	     (id == IDS_RESET) ) {
	    delay = 2000 / Frequency;
	} else if ( delay ) {
	    delay--;
	    return;
	}

	iHelpMessage = id;
	if ( !fIconic )
	    InvalidateRect( hWndMain, (LPRECT)&rcStatusLine, FALSE );
    }
}


/**************************************************************************/
/***                                                                    ***/
/***	PaintStatusBar							***/
/***                                                                    ***/
/***	Repaints Help field if fHelp is TRUE, repaints the AveHitRate	***/
/***	field if fRate is TRUE. 					***/
/***                                                                    ***/
/**************************************************************************/

void PaintStatusField( HDC hDC, BOOL fHelp, BOOL fRate )
{
    HFONT hfontOld = NULL;
    RECT rect;
    int dyBorder;

    dyBorder = GetSystemMetrics( SM_CYBORDER );

    if ( hfontStatus )
	hfontOld = SelectObject( hDC, hfontStatus );

    // set the text and background colors
    SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
    SetBkColor( hDC, GetSysColor(COLOR_BTNFACE) );

    LoadString( hInst, iHelpMessage, szBuffer, BUFLEN - 1 );

    //
    // Update the help text field
    //
    if ( fHelp ) {
	// now the help text, with a gray background
	rect.top    = rcStatusLine.top + 3 * dyBorder;
	rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
	rect.left   = 9 * dyBorder;
	rect.right  = rect.left + dxHelpField - 2 * dyBorder;

	ExtTextOut( hDC, rect.left + dyBorder * 5, rect.top,
	    ETO_OPAQUE | ETO_CLIPPED, &rect, szBuffer,
	    lstrlen(szBuffer), NULL);
    }

    //
    // Update the average hit rate number
    //
    if ( fRate ) {
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.right = rcStatusLine.right - 9 * dyBorder;
	rect.left = rect.right - dxHitRateField + 2 * dyBorder;

	wsprintf( szBuffer, "Average Hit Rate: %4u%%", AveHitRate );

	ExtTextOut( hDC, rect.left + dyBorder * 5, rect.top,
	    ETO_OPAQUE | ETO_CLIPPED, &rect, szBuffer,
	    lstrlen(szBuffer), NULL );
    }

    if ( hfontOld )
	SelectObject( hDC, hfontOld );
}


/**************************************************************************/
/***                                                                    ***/
/***	PointsToHeight							***/
/***                                                                    ***/
/**************************************************************************/

int PointsToHeight( int iPoints )
{
    HDC hDC;
    int iHeight;

    hDC = GetDC( HWND_DESKTOP );
    iHeight = MulDiv( iPoints, GetDeviceCaps(hDC, LOGPIXELSY), 72 );
    ReleaseDC( HWND_DESKTOP, hDC );
    return( iHeight );
}


/**************************************************************************/
/***                                                                    ***/
/***	InitStatusBar							***/
/***                                                                    ***/
/**************************************************************************/

void InitStatusBar( HWND hWnd )
{
    RECT rcParent;

    GetClientRect( hWnd, &rcParent );

    // This font will be used to paint the status line.
    hfontStatus = CreateFont(-PointsToHeight(STATUSPOINTSIZE),
	0, 0, 0, 400, 0, 0, 0,
	ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
	DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, "Helv" );

    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);

    // Initialize the status line data.
    dxHelpField = 20 * rcParent.right / 32;
    dxHitRateField = 10 * rcParent.right / 32;
    rcStatusLine = rcParent;
    rcStatusLine.top = rcStatusLine.bottom - dyStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\smartmon.h ===
//
// Miscellaneous constants
//
#define BUFLEN		128
#define STATUSPOINTSIZE   8  // Point size of status bar font.
#define MAXFILENAMELEN	256
#define MAX_FREQUENCY	10000
#define MIN_FREQUENCY	 50
#define MAX_AUTOLOGTIME 480
#define MIN_AUTOLOGTIME   1
#define MAX_INTERVAL	100
#define MIN_INTERVAL	  3

#define DEF_INTERVAL	 30
#define DEF_FREQUENCY	500
#define DEF_AUTOSTOP   TRUE
#define DEF_LOGTIME	120
#define DEF_UPDATEDOS FALSE
#define DEF_TOPMOST    TRUE

//
// String table resource ID
//
#define IDS_TITLE	200
#define IDS_DRVBMP	201
#define IDS_HELPFILE	202
#define IDS_STARTLOG	203
#define IDS_STOPLOG	204
#define IDS_LOGGING	205
#define IDS_LOGSTOPPED	206
#define IDS_LOGSTARTED	207
#define IDS_CACHEACTIVE 208
#define IDS_CACHEIDLE	209
#define IDS_FLUSHED	210
#define IDS_RESET	211
#define IDS_LOGFILE	212
#define IDS_SAVEAUTO	213
#define IDS_STATUS	214

//
// Main dialog control ID
//
#define IDD_HELP	100
#define IDD_READONLY	101
#define IDD_READWRITE	102
#define IDD_NOCACHING	103
#define IDD_HITRATEBOX	104
#define IDD_DOSSIZE	105
#define IDD_WINSIZE	106
#define IDD_FLUSH	107
#define IDD_RESET	108
#define IDD_DRIVEID	109
#define IDD_HITS	110
#define IDD_MISSES	111
#define IDD_RATE	112
#define IDD_CHARTBOX	113
#define IDD_SAMPFREQ	114
#define IDD_OPTION	115
#define IDD_STARTLOG	116
#define IDD_STOPLOG	117
#define IDD_ABOUT	118
#define IDD_TOPMOST	119

//
// Options dialog control ID
//
#define IDD_MSEC	150
#define IDD_LOGFILE	151
#define IDD_AUTOSTOP	152
#define IDD_STOPTIME	153
#define IDD_SAVESET	154
#define IDD_INTERVAL	155
#define IDD_BATCHFILE	156

typedef struct tagDRVINFO {
    BYTE    type;	    // GetDriveType return value
    BYTE    status;	    // caching status
} DRVINFO;

//
// CACHE_A_DRIVE sub-function and return value
//
#define GET		0
#define ENABLE_READ	1
#define DISABLE_READ	2
#define ENABLE_WRITE	3
#define DISABLE_WRITE	4
#define SET		5   // not a real subfunction number

#define NO_READ 	0x0080
#define NO_WRITE	0x0040
#define NO_CACHING	0x00ff

//
// DOS Disk Transfer Area Structure
//
typedef struct tagDOSDTA {
    BYTE    reserved[21];
    BYTE    attrib;
    WORD    time;
    WORD    date;
    DWORD   size;
    char    name[13];
} DOSDTA;

//
// array index values for hbmpDirDrives array
// Note:  Two copies are kept, one for standard background,
// one for hilite.  Relative order is important.
//

#define BMPHIOFFSET 8

#define FLOPPYBMP     3
#define HARDDRVBMP    4
#define CDDRVBMP      5
#define NETDRVBMP     6
#define RAMDRVBMP     7

#define FLOPPYBMPHI   8
#define HARDDRVBMPHI  9
#define CDDRVBMPHI    10
#define NETDRVBMPHI   11
#define RAMDRVBMPHI   12

//
// Internal routine declarations
//
BOOL WambiInit( HANDLE );
void UpdateStat( HWND );
void InitRateBox( HWND );
void InitDriveBox( HWND );

//
// Bambi interface routines
//
extern long get_cache_hits( void );
extern long get_cache_misses( void );
extern int  get_cache_dirty_elements( void );
extern void commit_cache( void );
extern void reset_cache( void );
extern char cache_a_drive( int, int );
extern int  get_cache_info( int *, int * );

//
// Other assembler routines
//
extern void get_volume_label( int, LPSTR );
extern BOOL is_CDROM_drive( int );
extern BOOL is_RAM_drive( int );
extern BOOL is_valid_CD( void );
extern char get_current_drive( void );
extern void set_current_drive( int );
extern int  count_valid_drives( LPSTR );
extern int  is_Stacker_drive( int, LPSTR );
extern BYTE get_boot_drive( void );
extern WORD get_dos_version( void );
extern DWORD get_free_space( int );
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\util.asm ===
include cmacros.inc

sBegin	DATA
stacker_lbl db	    'STACKER '	    ;
oldDTAaddr  dd	    0
myDTA	    db	    21 dup (0)	    ; reserved
	    db	    0		    ; attrib
	    dw	    0		    ; time
	    dw	    0		    ; date
	    dd	    0		    ; file size
volname     db	    13 dup (0)	    ; file name
	    db	    5  dup (0)	    ; buffer
pattern     db	    'A:*.*', 0	    ; search pattern
sEnd	DATA

sBegin	CODE
assumes cs,CODE
assumes ds,DATA

;------------------------------------------------------------------------
;
; get_volume_label
;
;   gets volume label of a drive
;
; Input:
;
;   WORD  drive (0=A, 1=B, ...)
;   LPSTR lpsz	receiving buffer
;
; Output:
;
;   void
;
cProc get_volume_label,<NEAR,PUBLIC>,<ds,es,ax,bx,cx,dx,si,di>
	parmW	drive
	parmD	lpsz
cBegin
	mov	ax,_DATA
	mov	ds,ax

	; replace DTA address with ours

	mov	ah,2fh
	int	21h
	mov	word ptr oldDTAaddr,bx
	mov	word ptr oldDTAaddr+2,es
	mov	ah,1ah
	lea	dx,myDTA
	int	21h

	; get volume label for the given drive

	lea	bx,pattern
	mov	ax,drive
	add	ax,'A'
	mov	byte ptr [bx],al
	mov	dx,bx
	mov	cx,8
	mov	ah,4eh
	int	21h

	; set up destination buffer

	cld
	les	di,lpsz

	jc	no_volume_label

	; copy volume label, insert brackets front and back

	mov	al,'['
	stosb

	lea	si,volname

	mov	cx,8
copy_name:
	lodsb
	cmp	al,'.'
	je	copy_ext
	stosb
	dec	cx
	cmp	al,0
	jnz	copy_name
	dec	di
	jmp	short copy_done

copy_ext:
	mov	al,' '
	rep	stosb
	mov	cx,3
	repnz	movsb

strip_tail:
	dec	di
	mov	al,byte ptr es:[di]
	cmp	al,' '
	je	strip_tail
	cmp	al,9
	je	strip_tail
	cmp	al,0
	je	strip_tail
	inc	di

copy_done:
	mov	al,']'
	stosb

no_volume_label:

	; store null terminator

	xor	ax,ax
	stosb

	; restore DTA address

	mov	ah,1ah
	mov	dx,word ptr oldDTAaddr
	mov	ds,word ptr oldDTAaddr+2
	int	21h
cEnd


;------------------------------------------------------------------------
;
; is_CDROM_drive
;
;   Determines if a drive is a CDROM drive
;
; Input:
;
;   WORD drive (0=A, 1=B, ...)
;
; Output:
;
;   returns non-zero for CDROM drive, 0 otherwise
;

cProc is_CDROM_drive,<NEAR,PUBLIC>,<bx,cx>
	parmW	drive
cBegin
	mov	ax, 1500h	; first test for presence of MSCDEX
	xor	bx, bx
	int	2fh
	mov	ax, bx		; MSCDEX is not there if bx is still zero
	or	ax, ax		; ...so return FALSE from this function
	jz	no_mscdex

	mov	ax, 150bh	; MSCDEX driver check API
	mov	cx, drive	; ...cx is drive index
	int	2fh
no_mscdex:
cEnd


;------------------------------------------------------------------------
;
; is_valid_CD
;
;   Determines if a CDROM drive contains a valid FAT disk.
;   Assumes current drive is a CDROM drive.
;
; Input:
;
;   none
;
; Output:
;
;   returns non-zero for a valid CDROM disk, 0 otherwise
;

cProc is_valid_CD,<NEAR,PUBLIC>,<bx,cx,dx,ds,es>
cBegin
	; replace DTA address with ours

	mov	ah,2fh
	int	21h
	mov	word ptr oldDTAaddr,bx
	mov	word ptr oldDTAaddr+2,es
	mov	ah,1ah
	lea	dx,myDTA
	int	21h

	; get "*.*" search pattern

	lea	dx,pattern
	add	dx,2		; go past "A:"
	mov	cx,8		; look for directory
	mov	ah,4eh
	clc
	int	21h
	mov	cx,1
	jc	ivc_found
	xor	cx,cx
ivc_found:

	; restore DTA address

	mov	ah,1ah
	mov	dx,word ptr oldDTAaddr
	mov	ds,word ptr oldDTAaddr+2
	int	21h

	mov	ax,cx
cEnd


;------------------------------------------------------------------------
;
; is_RAM_drive
;
;   Determines if a drive is a RAM drive
;
; Input:
;
;   WORD drive (0=A, 1=B, ...)
;
; Output:
;
;   returns non-zero for RAM drive, 0 otherwise
;

cProc is_RAM_drive,<NEAR,PUBLIC>,<ds,bx,dx>
	parmW	drive
cBegin
	mov	dx,drive	; set drive id
	inc	dx		; this function expects 1-based drive
	mov	ah,32h
	clc
	int	21h
	jc	not_ram 	; if failed assume it's not a RAM drive
	mov	al,ds:[bx+8]
	cmp	al,1		; only 1 FAT table, assume it's a RAM drive
	je	r_done
not_ram:
	xor	al,al
r_done:
	xor	ah,ah
cEnd

;------------------------------------------------------------------------
;
; is_Stacker_drive
;
;   Determines if a drive is a Stacker drive
;
; Input:
;
;   WORD drive (0=A, 1=B, ...)
;   LPSTR tempDTA
;
; Output:
;
;   returns non-zero for Stacker drive, 0 otherwise
;

ParamBlockStruc   struc
  LO_sector	dw    ?		; Lo word of starting sector
  HI_sector	dw    ?		; Hi word of starting sector
  SecCount  	dw    ?		; Number of sectors to read
  BuffOff	dw    ?		; Offset of Buffer
  BuffSeg	dw    ?		; Segment of Buffer
ParamBlockStruc   ends

cProc is_Stacker_drive,<NEAR,PUBLIC>,<ds,es,bx,cx,dx,di,si>
	parmW	drive
	parmD	tempDTA
	LocalV	ParamBlock, %(size ParamBlockStruc)
cBegin
	mov	ax,drive	; set drive id
	lds	bx,tempDTA
	mov	cx,1
	mov	dx,0
	push	bp		; Save BP
	int	25h
	pop	bx		; Remove flags from stack
	pop	bp		; Restore BP
	jnc	check_label

	; If this has failed, it could be a partition > 32 Meg. So, try
	; again assuming Partition size is > 32 Meg. If this also fails,
	; this is really an error;

	mov	ax,drive
	mov	dx,0

	; Fill the parameter block with proper values
	mov	ParamBlock.LO_sector,dx 	; Starting sector

	; We get only 16 bit starting sector; So, hi word is made zero
	mov	ParamBlock.HI_sector,0

	; The number of sectors to be read	
	mov	dx,1
	mov	ParamBlock.SecCount,dx

	; The address of the buffer to read into
	mov	dx,OFF_tempDTA
	mov	ParamBlock.BuffOff,dx
	mov	dx,SEG_tempDTA
	mov	ParamBlock.BuffSeg,dx

	; Keep the address of ParamBlock in DS:BX
	lea	bx,ParamBlock
	push	ss
	pop	ds
	mov	cx,-1		; > 32Meg partition
	push	bp		; Save BP
	int	25h
	pop	bx		; Remove the flags on stack
	pop	bp		; Restore BP
	jc	not_stacker

check_label:
	mov	cx,4		; See if disk label is right
	mov	ax,_DATA
	mov	es,ax
	lea	di,stacker_lbl
	lds	si,tempDTA
	add	si,3
	repe	cmpsw
	jcxz	found_stacker
	jmp	short not_stacker

found_stacker:
	mov	ax,1
	jmp	short s_done
not_stacker:
	xor	ax,ax
s_done:
cEnd


;------------------------------------------------------------------------
;
; get_current_drive
;

cProc get_current_drive,<NEAR,PUBLIC>
cBegin
	mov	ah,19h
	int	21h
	add	al,'a'		; 0=>a, 1=>b, etc
	sub	ah,ah
cEnd


;------------------------------------------------------------------------
;
; set_current_drive
;

cProc set_current_drive,<NEAR,PUBLIC>
	parmW	drive
cBegin
	mov	dl,drive
	mov	ah,0eh
	int	21h
cEnd


;------------------------------------------------------------------------
;
; get_free_space
;
; Input:
;
;   WORD drive (0=A, 1=B, ...)
;
; Output:
;
;   Returns free disk space in DX:AX
;

cProc get_free_space,<NEAR,PUBLIC>,<bx,cx>
	parmW	drive
cBegin
	mov	dl,drive
	inc	dl	    ; 1 based
	mov	ah,36h
	int	21h
	mul	cx
	mul	bx
cEnd


;------------------------------------------------------------------------
;
; get_boot_drive
;

cProc get_boot_drive,<NEAR,PUBLIC>
cBegin
	mov	ax,3305h	; ax = 3305h --> Get boot drive A=1,B=2, ect.
	int	21h		; Call DOS.
	mov	al,dl		; Return result in AX.
	xor	ah,ah
cEnd


;------------------------------------------------------------------------
;
; get_dos_version
;

cProc get_dos_version,<NEAR,PUBLIC,NODATA>, <si>
cBegin
        mov     ax,3000h
        int     21h
cEnd


;------------------------------------------------------------------------
;
; count_valid_drives
;

cProc count_valid_drives,<NEAR,PUBLIC>,<bx,cx,dx,es,di>
	parmD	drivelist
cBegin
	les	di,drivelist
	xor	cx,cx		; # Found so far

	mov	ah,19h
	int	21h		; Get current drive in AL
	mov	bx,ax		; Save so we can restore it

	cld
	stosb			; Save it as 1st buff entry

	xor	dx,dx		; Start with drive A:
find_loop:
	mov	ah,0eh		; Select the drive
	int	21h		; (AL contains max drive)
	mov	dh,al

	mov	ah,19h
	int	21h
	cmp	dl,al		; Q: Did change work?
	jne	short try_next	;    N: Invalid
				;    Y: Found one more
	inc	cx
	cld
	stosb

try_next:
	inc	dl		; DL = Next drive
	cmp	dl,dh		; Q: Any more drives to check?
	jb	short find_loop ;    Y: Keep looking

	mov	dl,bl		; DL = Original default drive
	mov	ah,0eh		; Select drive
	int	21h

	mov	ax,cx		; Return count
cEnd

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\getsize.c ===
/***************************************************************************/
/*																									*/
/*		Module Name: getsize																	*/
/*																									*/
/* 	Description:																			*/
/*			Obtains BIOS_DATA (bios data size), BIOS_CODE ( bios code size )  */
/*		from ..\bios\msbio.map and DOSDATA (dos data size) from msdos.map 	*/
/*		and compares it with existing values in bdsiz.inc. If the values are */
/* 	update bdsiz.inc with the new values.											*/
/*																									*/
/***************************************************************************/


#include<stdio.h>
#define	MAXLINE	200
#define	MAXWORD	64

main()
{
	FILE	*fp1, *fp2;
	char	buffer[MAXLINE], 
			prev[MAXWORD],
			newdosdata[MAXWORD],
			newbiosdata[MAXWORD],
			newbioscode[MAXWORD],
			olddosdata[MAXWORD],
			oldbiosdata[MAXWORD],
			oldbioscode[MAXWORD];


	int	len, scanres, changed = 0;

	if ( (fp1	= fopen("msdos.map", "r")) == NULL )
		{
			printf("getsize: cannot open msdos.map\n");
			exit(0);
		}

	if ( (fp2 = fopen("..\\bios\\msbio.map", "r")) == NULL )
		{
			printf("getsize: cannot open msbio.map\n");
			exit(0);
		}


	/* Look for line containing string DOSDATA in msdos.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp1);
		scanres = scanline(buffer, prev, "DOSDATA");

	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before DOSDATA (dosdata size) in newdosdata. */
	strcpy(newdosdata, prev);	


	/* Look for line containing string BIOS_DATA in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_DATA");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_DATA (biosdata size) in newbiosdata. */
	strcpy(newbiosdata, prev);


	/* Seek back to beginning of MSBIO.MAP */
	if ( fseek(fp2, 0L, SEEK_SET) )
		printf("getsize: fseek failed on msbio.map\n");

	/* Look for line containing string BIOS_CODE in msbio.map */

	do
	{
		len 	= getline(buffer, MAXLINE, fp2);
		scanres = scanline(buffer, prev, "BIOS_CODE");
	}
	while ( (scanres != 0) && (len !=0) ) ;

	/* Save word before BIOS_CODE (bios code size) in newbioscode. */
	strcpy(newbioscode, prev);

	fclose(fp1);	
	fclose(fp2);

	if ( (fp1 = fopen("..\\inc\\bdsize.inc", "r")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	/* read in existing values of bios code , bios data and dos data  */
	/* size from bdsize.inc. 														*/

	fscanf(fp1, "%s%s%s", oldbiosdata, oldbiosdata, oldbiosdata);
	fscanf(fp1, "%s%s%s", oldbioscode, oldbioscode, oldbioscode);
	fscanf(fp1, "%s%s%s", olddosdata, olddosdata, olddosdata);

	printf("oldbiosdata=%s newbiosdata=%s\n",oldbiosdata, newbiosdata);
	printf("oldbioscode=%s newbioscode=%s\n",oldbioscode, newbioscode);
	printf("olddosdata=%s newdosdata=%s\n",olddosdata, newdosdata);


	/* Check to see if any one of them has changed */

	if ( strcmp(oldbiosdata, newbiosdata) != 0 )
		changed = 1;
	else if 	( strcmp(oldbioscode, newbioscode) != 0 )
		changed = 1;
	else if 	( strcmp(olddosdata, newdosdata) != 0 )
		changed = 1;

	/* if not changed, done. */

	if	(changed == 0)
		exit(0);
	

	/* One of the values has changed update bdsize.inc */

	fclose(fp1);

	if ( (fp1 = fopen("..\\inc\\bdsize.inc", "w")) == NULL )
		{
			printf("getsize: cannot open origin.inc\n");
			exit(0);
		}

	fprintf(fp1, "%s %s %s\n", "BIODATASIZ", "EQU", newbiosdata);
	fprintf(fp1, "%s %s %s\n", "BIOCODESIZ", "EQU", newbioscode);
	fprintf(fp1, "%s %s %s\n", "DOSDATASIZ", "EQU", newdosdata);

	
}

int 	getline(s, lim, fileptr)
char	*s;
int	lim;
FILE	*fileptr;

{

	int	c, i;

	for	(i=0; (i < lim-1) && ((c=fgetc(fileptr)) != EOF) && (c!='\n'); ++i)
			s[i] = c;

	if		(c == '\n')
			s[i++] = c;

	s[i] = '\0';
	return(i);
}

scanline(s, prev, template)
char	*s, *template, *prev ;

{

	char	str[MAXWORD];
	int	i = 0;

	while ( *s == ' ')		
			s++;

	while	( *s != '\n' )
	{
		while( (*s != ' ') && (*s != '\n') && (*s != '\t'))
		{
			str[i++] = *s++;
		}
		str[i] = '\0';

		if ( (*s == ' ') || (*s == '\t') )
			s++;

 /*		printf("%s\n", str); */

		if ( strcmp( str, template) == 0 )
			return(0);

		strcpy(prev, str);

		i = 0;
	}

	return(-1);

}



	
 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\index.c ===
/********************************* INDEX.C *********************************/
/* Copyright (c) 1989 - Microsoft Corp.												*/
/* All rights reserved																		*/
/*																									*/
/* Program to read a message file and create a header file with the offsets*/
/* to each entry in the file.																*/
/*																									*/
/* EXAMPLE:																						*/
/* INDEX  infile_name.ext  outfile_name.ext											*/
/***************************************************************************/

#include    <stdio.h>
#include    <string.h>
#include    <malloc.h>

#define		EOL		0

/***************************************************************************/
int main( int argc, char *argv[] );
int ProcessMessage( char *Buffer );
/***************************************************************************/


/***************************************************************************/
/* Reads a help file and creates a header file with the offsets to each		*/
/* entry in the file as a #define value. The help file must have the			*/
/* following layout.																			*/
/*																									*/
/*   .LABEL_TEXT                                                           */
/*   Body of the text up to 25 lines                                       */
/*   .LABEL2_TEXT                                                          */
/*   Body of the text up to 25 lines                                       */
/*   ......                                                                */
/*   .END                                                                  */
/*																									*/
/* The resulting file which is created has this format, where xxxx is a    */
/* long numeric value.                                                     */
/*                                                                         */
/*	#define	LABEL_TEXT		xxxx															*/
/*	#define	LABEL_LINES		xxxx															*/
/*	#define	LABEL2_TEXT		xxxx															*/
/*	#define	LABEL2_LINES	xxxx															*/
/*	#define  ......_TEXT		xxxx															*/
/* #define	......_LINES	xxxx															*/
/*																									*/
/* A second file is created which contains the text from the message file  */
/* in a form which is assemble-able with the Microsoft MASM 5.1.				*/
/*																									*/
/* Blank lines and line which start with a simicolon are ignored and only	*/
/* the text within quote is used. Quotes are not allowed within the text	*/
/* at this time.																				*/
/*																									*/
/*																									*/
/* EXAMPLE TEXT FILE:																		*/
/*																									*/
/*																									*/
/* ; =============================================================			*/
/*	; =============================================================			*/
/*	; All of these lines are the same length to give a better					*/
/*	; appearance on the screen																*/
/*	;																								*/
/*																									*/
/*	.REMINDER_TEXT																				*/
/*																									*/
/*	"<ENTER>    = Continue the installation"											*/
/*	"<ENTER>    = Accept entry and continue"											*/
/*	"<ESC>      = Return to previous screen"											*/
/*	"<ESC>      = Exit installation program"											*/
/*	"<CTRL>+<C> = Exit installation program"											*/
/*																									*/
/*	.END_TEXT																					*/
/*																									*/
/***************************************************************************/

int main( int argc, char *argv[] )
{
   FILE		*sFile, *hFile, *aFile;		/* Source and header files */
	char		*szBuffer, *szPtr;				/* Work szBuffer and pointer */
	char		*szLastDef;						/* The last define string */
	unsigned Offset = 0;	/* Current offset */
	int		iNumBytes, iNumLines;
	int		Status = 0;


   if ( argc < 3 )
      Status = 8;
   else if ( (sFile = fopen( argv[1], "rb" )) == NULL )
      Status = 1;
   else if ( (hFile = fopen( argv[2], "wb" )) == NULL )
      Status = 2;
	else if ( (aFile = fopen( "MESSAGE.ASM", "wb" )) == NULL )
		Status = 3;
   else if ( (szBuffer = malloc( 200 )) == NULL )
      Status = 4;
	else if ( (szLastDef = malloc( 200 )) == NULL )
		Status = 4;
   else
   {
		fprintf( aFile, "DOSSEG\r\n"  );
		fprintf( aFile, ".MODEL\tSMALL,C\r\n"  );
		fprintf( aFile, "\r\n\r\n.DATA\r\n\r\n" );
		fprintf( aFile, "\tPUBLIC chMessage\r\n" );
		fprintf( aFile, "chMessage\tLABEL BYTE\r\n\r\n" );

		fprintf( hFile, "void\tGetMessage( char **Ptr, unsigned Offset_u );\r\n" );
		fprintf( hFile, "void\tGetMessStr( char *szBuf, unsigned Offset_u, int StrNum );\r\n\r\n" );

		while( !feof( sFile) && Status == 0 )
		{
			while( !feof( sFile) && Status == 0 )
   	   {
				if( *szBuffer == '.' )
				{
											/* Convert newline to EOL */
					*(strchr( szBuffer, '\r')) = '\0';
					strcpy( szLastDef, szBuffer + 1 );	/* Save definition */
					if (fprintf( hFile, "#define\t\t%-25s %#4.4x\r\n",
									 szLastDef, Offset ) == 0 )
						Status = 4;
					break;
				}
				else if ( fgets( szBuffer, 132, sFile ) != szBuffer )
					Status = 4;
			}
			if ( Status == 0 )
			{
				fgets( szBuffer, 132, sFile );
				iNumLines = 0;
			}
			while ( !feof( sFile) && *szBuffer != '.' && Status == 0 )
			{
				if ( (iNumBytes = ProcessMessage( szBuffer )) >= 0 )
				{
					iNumBytes++;
					iNumLines++;
					if ( iNumBytes > 1 )
						szPtr = "db\t\"%s\",0\r\n";
					else
						szPtr = "db\t0\r\n";

					if ( fprintf( aFile, szPtr, szBuffer ) == 0 )
						Status = 4;
					else
						Offset += iNumBytes;
				}
				if ( iNumBytes == -2 )
					Status = -2;
				else
					fgets( szBuffer, 132, sFile ) != szBuffer;
			}
			if ( Status == 0 )
			{ 
				Offset++;
				fprintf( aFile, "db\t-1\r\n" );
				strcpy( strchr( szLastDef, EOL ) - 4, "LINES" );
				fprintf( hFile, "#define\t\t%-25s %#4.4x\r\n", szLastDef,
							++iNumLines );		/* Add 1 line for NULL */
			}
		}
	}
	if ( Status == 0 )
		fprintf( aFile, "\r\nEND\r\n" );

	fcloseall();
	if ( Status != 0 )
		printf( "\nError status = %d\n", Status );
	return( Status );
}


int ProcessMessage( char *szBuffer )
{
	int	iCount;
	char	*pszPtr;

	pszPtr = szBuffer;
	while ( *pszPtr != '\"' && *pszPtr != EOL && *pszPtr != ';' )
		pszPtr++;
	
	if ( *pszPtr == '\"' )
	{
		pszPtr++;
		for( iCount = 0;
			  *pszPtr != '\"';
			  iCount++, szBuffer++, pszPtr++ )
		{
			*szBuffer = *pszPtr;
			if ( *pszPtr == EOL )
			{
				iCount = -2 ;		/* Missing end quote */
				break;
			}
		}
		*szBuffer = EOL;
	}
	else
		iCount = -1;				/* Ingore this line */

	return( iCount );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\assert.h ===
/***
*assert.h - define the assert macro
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the assert(exp) macro.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#undef	assert

#ifdef NDEBUG

#define assert(exp)	((void)0)

#else

void _FAR_ _cdecl _assert(void _FAR_ *, void _FAR_ *, unsigned);
#define assert(exp) \
	( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*	Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file declares the constants, structures, and functions
*	used for accessing and using various BIOS interfaces.
*
****/

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT	0	/* init serial port */
#define _COM_SEND	1	/* send character */
#define _COM_RECEIVE	2	/* receive character */
#define _COM_STATUS	3	/* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7	2	/* 7 bits characters */
#define _COM_CHR8	3	/* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1	0	/* 1 stop bit */
#define _COM_STOP2	4	/* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY	0	/* no parity */
#define _COM_ODDPARITY	8	/* odd parity */
#define _COM_EVENPARITY 24	/* even parity */

/*  baud rate initializers */

#define _COM_110	0	/* 110 baud */
#define _COM_150	32	/* 150 baud */
#define _COM_300	64	/* 300 baud */
#define _COM_600	96	/* 600 baud */
#define _COM_1200	128	/* 1200 baud */
#define _COM_2400	160	/* 2400 baud */
#define _COM_4800	192	/* 4800 baud */
#define _COM_9600	224	/* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET	0	/* reset disk controller */
#define _DISK_STATUS	1	/* get disk status */
#define _DISK_READ	2	/* read disk sectors */
#define _DISK_WRITE	3	/* write disk sectors */
#define _DISK_VERIFY	4	/* verify disk sectors */
#define _DISK_FORMAT	5	/* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED

struct diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void _far *buffer;
    };

#define _DISKINFO_T_DEFINED

#endif


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ		0	/* read next character from keyboard */
#define _KEYBRD_READY		1	/* check for keystroke */
#define _KEYBRD_SHIFTSTATUS	2	/* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ		0x10	/* read next character from keyboard */
#define _NKEYBRD_READY		0x11	/* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS	0x12	/* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE	0	/* write character to printer */
#define _PRINTER_INIT	1	/* intialize printer */
#define _PRINTER_STATUS 2	/* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK	0	/* get current clock count */
#define _TIME_SETCLOCK	1	/* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

/* segment registers */

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#define _REGS_DEFINED

#endif /* _REGS_DEFINED */


/* function prototypes */

unsigned _cdecl _bios_disk(unsigned, struct diskinfo_t *);
unsigned _cdecl _bios_equiplist(void);
unsigned _cdecl _bios_keybrd(unsigned);
unsigned _cdecl _bios_memsize(void);
unsigned _cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_serialcom(unsigned, unsigned, unsigned);
unsigned _cdecl _bios_timeofday(unsigned, long *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);

#endif /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\bios.inc ===
; BIOS Interface Macros	- Version 1.0 -	for Microsoft Macro Assembler 5.0
; (C) Copyright	Microsoft Corporation, 1987.

.XCREF
.XLIST
IF1
; 0Fh
@GetMode	MACRO
		mov	ah,0Fh
		int	10h
		ENDM
; 00h
@SetMode	MACRO	mode
		mov	al,mode
		xor	ah,ah
		int	10h
		ENDM
; 0Bh
@SetColor	MACRO	color
		sub	bh,bh
		mov	bl,color
		mov	ah,0Bh
		int	10h
		ENDM
; 0Bh
@SetPalet	MACRO	color
		mov	bh,1
		mov	bl,color
		mov	ah,0Bh
		int	10h
		ENDM
; 05h
@SetPage	MACRO	page
		mov	al,page
		mov	ah,05h
		int	10h
		ENDM
; 03h
@GetCur		MACRO	page
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		mov	ah,03h
		int	10h
		ENDM
; 02h
@SetCurPos	MACRO	column,row,page
		IFNB	<column>
		mov	dl,column
		ENDIF
		IFNB	<row>
		mov	dh,row
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		mov	ah,02h
		int	10h
		ENDM
; 01h
@SetCurSz	MACRO	first,last
		mov	ch,first
		mov	cl,last
		mov	ah,01h
		int	10h
		ENDM
; 08h
@GetChAtr	MACRO	page
		IFNB	<page>
		mov	bh,page
		ELSE
		sub	bh,bh
		ENDIF
		mov	ah,08h
		int	10h
		ENDM
; 09h
@PutChAtr	MACRO	char,atrib,page,repeat
		IFNB	<char>
		mov	al,char
		ENDIF
		IFNB	<atrib>
		mov	bl,atrib
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		IFNB	<repeat>
		mov	cx,repeat
		ELSE
		mov	cx,1
		ENDIF
		mov	ah,09h
		int	10h
		ENDM
; 0Ah
@PutCh		MACRO	char,atrib,page,repeat
		IFNB	<char>
		mov	al,char
		ENDIF
		IFNB	<atrib>
		mov	bl,atrib
		ENDIF
		IFNB	<page>
		mov	bh,page
		ELSE
		xor	bh,bh
		ENDIF
		IFNB	<repeat>
		mov	cx,repeat
		ELSE
		mov	cx,1
		ENDIF
		mov	ah,0Ah
		int	10h
		ENDM
; 06h and 07h
@Scroll		MACRO	distance,atrib,upcol,uprow,downcol,downrow
		IFDEF	upcol
		mov	cl,upcol
		ENDIF
		IFDEF	uprow
		mov	ch,uprow
		ENDIF
		IFDEF	upcol
		mov	dl,upcol
		ENDIF
		IFDEF	updownrow
		mov	dh,downrow
		ENDIF
		IFDEF	atrib
		mov	bh,atrib
		ELSE
		mov	bh,07h
		ENDIF
		IF	distance LE 0
		mov	ax,0600h + (-(distance)	AND 0FFh)
		ELSE
		mov	ax,0700h + (distance AND 0FFh)
		ENDIF
		int	10h
		ENDM
; 08h, 06h, and	02h
@Cls		MACRO
		@GetChAtr
		mov	bl,bh
		mov	bh,ah
		sub	cx,cx
		mov	dx,184Fh
		mov	ax,0600h
		int	10h
		mov	bh,bl
		sub	dx,dx
		mov	ah,02h
		int	10h
		ENDM
ENDIF
.CREF
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the library
*	functions related to directory handling and creation.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

int _FAR_ _cdecl chdir(const char _FAR_ *);
int _FAR_ _cdecl _chdrive(int);
char _FAR_ * _FAR_ _cdecl getcwd(char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl _getdcwd(int, char _FAR_ *, int);
int _FAR_ _cdecl _getdrive(void);
int _FAR_ _cdecl mkdir(const char _FAR_ *);
int _FAR_ _cdecl rmdir(const char _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	the MS C V2.03 compatible console and port I/O routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

char _FAR_ * _FAR_ _cdecl cgets(char _FAR_ *);
int _FAR_ _cdecl cprintf(const char _FAR_ *, ...);
int _FAR_ _cdecl cputs(const char _FAR_ *);
int _FAR_ _cdecl cscanf(const char _FAR_ *, ...);
int _FAR_ _cdecl getch(void);
int _FAR_ _cdecl getche(void);
int _FAR_ _cdecl inp(unsigned);
unsigned _FAR_ _cdecl inpw(unsigned);
int _FAR_ _cdecl kbhit(void);
int _FAR_ _cdecl outp(unsigned, int);
unsigned _FAR_ _cdecl outpw(unsigned, unsigned);
int _FAR_ _cdecl putch(int);
int _FAR_ _cdecl ungetch(int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\dos.inc ===
; DOS Interface Macros - Version 1.0 - for Microsoft Macro Assembler 5.0
; (C) Copyright Microsoft Corporation, 1987, 1988.

.XCREF
.XLIST
IF1
; Internal
__LdAdr MACRO reg, adr
    IF (.TYPE (adr)) AND 00010000b     ;; Register
        mov     reg, adr
    ELSEIF (.TYPE (adr)) AND 00000100b ;; Constant
        mov     reg, adr
    ELSEIF TYPE (adr) EQ 1             ;; Bytes
        mov    reg, OFFSET adr
    ELSEIF TYPE (adr) EQ 2             ;; Near pointer
        mov    reg, adr
    ELSEIF TYPE (adr) EQ 4             ;; Far pointer
        lds    reg, adr
    ELSE
        .ERR
        %OUT Illegal argument
    ENDIF
ENDM

; Internal
__LdSeg MACRO dest, src
    IFIDNI <src>, <es>                 ;; Segment register
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ss>
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ds>
        mov     ax, src
        mov     dest, ax
    ELSEIFIDNI <src>, <ds>
        mov     ax, src
        mov     dest, ax
    ELSEIF (.TYPE (src)) AND 00000100b ;; Constant
        mov     ax, src
        mov     dest, ax
    ELSE                               ;; Memory or general register 
        mov     dest, src
    ENDIF
ENDM

; 01h, 07h, 08h, 0Ch
@GetKey MACRO echo, cc, clear
    LOCAL   funct, disp
    IFDIF   <echo>, <0>
        IFDIF   <cc>, <0>
            funct   = 01h
        ELSE
            funct   = 07h
            disp    = 02h
        ENDIF
    ELSE
        IFDIF   <cc>, <0>
            funct   = 08h
        ELSE
            funct   = 07h
        ENDIF
    ENDIF
    IFB     <clear>
        mov     ah, funct
    ELSE
        IFIDN   <clear>, <0>
            mov     ah, funct
        ELSE
            mov     ah, 0Ch
            mov     al, funct
        ENDIF
    ENDIF
    int     21h
    IFDEF   disp
        mov     dl, al
        mov     ah, disp
        int     21h
    ENDIF
ENDM

; 0Ah
@GetStr MACRO ofset, terminator, limit, segmnt
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 0Ah
    mov     si, dx
    IFNB    <limit>
        mov     BYTE PTR [si], limit
    ENDIF
    int     21h
    inc     si
    mov     bl, [si]
    sub     bh, bh
    inc     si
    IFNB    <terminator>
        mov     BYTE PTR [bx+si], terminator
    ENDIF
ENDM

; 02h
@DispCh MACRO ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10
    mov     ah, 02h
    IRP     char, <ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10>
        IFB     <char>
            EXITM
        ENDIF
        mov     dl, char
        int     21h
    ENDM
ENDM

; 05h
@PrtCh MACRO ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10
    mov     ah, 05h
    IRP     char, <ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10>
        IFB     <char>
            EXITM
        ENDIF
        mov     dl, char
        int     21h
    ENDM
ENDM

; 09h
@DispStr MACRO ofset, segmnt
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 9
    int     21h
ENDM

; 3Fh
@Read MACRO ofset, bytes, handle, segmnt
    IFNB    <handle>
        mov     bx, handle
    ELSE
        sub     bx, bx
    ENDIF
    mov     cx, bytes
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Fh
    int     21h
ENDM

; 40h
@Write MACRO ofset, bytes, handle, segmnt
    IFNB    <handle>
        mov     bx, handle
    ELSE
        mov     bx, 1
    ENDIF
    mov     cx, bytes
    __LdAdr dx, <ofset>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 40h
    int     21h
ENDM

; 3Ch
@MakFil MACRO path, atrib, segmnt, kind
    IFB     <atrib>
        sub     cx, cx
    ELSE
        mov     cx, atrib
    ENDIF
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    IFIDNI  <kind>, <tmp>
        mov     ah, 5Ah
    ELSEIFIDNI <kind>, <new>
        mov    ah, 5Bh
    ELSE
        mov    ah, 3Ch
    ENDIF
    int     21h
ENDM

; 3Dh
@OpenFil MACRO path, access, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ax, 3D00h + (access AND 0FFh)
    int     21h
ENDM

; 3Eh
@ClosFil MACRO handle
    mov     bx, handle
    mov     ah, 3Eh
    int     21h
ENDM

; 41h
@DelFil MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 41h
    int     21h
ENDM

; 56h
@MoveFil MACRO old, new, segold, segnew
    __LdAdr dx, <old>
    __LdAdr di, <new>
    IFNB    <segold>
        __LdSeg ds, <segold>
    ENDIF
    IFNB    <segnew>
        __LdSeg es, <segnew>
    ENDIF
    mov     ah, 56h
    int     21h
ENDM

; 4Eh
@GetFirst MACRO path, atrib, segmnt
    IFNB    <atrib>
        mov     cx, atrib
    ELSE
        sub     cx, cx
    ENDIF
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 4Eh
    int     21h
ENDM

; 4Fh
@GetNext MACRO
    mov     ah, 4Fh
    int     21h
ENDM

; 2Fh
@GetDTA MACRO
    mov     ah, 2Fh
    int     21h
ENDM

; 1Ah
@SetDTA MACRO buffer, segmnt
    __LdAdr dx, <buffer>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 1Ah
    int     21h
ENDM

; Internal
__LdDub MACRO dub
    IF   TYPE (dub) EQ 2
        sub  cx, cx
        mov  dx, dub
    ELSEIF TYPE (dub) EQ 4
        mov  cx, dub[2]
        mov  dx, dub[0]
    ELSEIF TYPE (dub) EQ 0
        sub     cx, cx
        mov     dx, dub
    ELSE
        .ERR
        %OUT Illegal argument
    ENDIF
ENDM

; 42h
@GetFilSz MACRO handle
    mov     bx, handle
    sub     cx, cx
    sub     dx, dx
    mov     ax, 4202h
    int     21h
    push    dx
    push    ax
    sub     dx, dx
    mov     ax, 4200h
    int     21h
    pop     ax
    pop     dx
ENDM

; 42h
@MovePtrAbs MACRO handle, distance
    IFNB    <distance>
        __LdDub <distance>
    ENDIF
    mov     bx, handle
    mov     ax, 4200h
    int     21h
ENDM

; 42h
@MovePtrRel MACRO handle, distance
    IFNB    <distance>
        __LdDub <distance>
    ENDIF
    mov     bx, handle
    mov     ax, 4201h
    int     21h
ENDM

; 39h
@MkDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 39h
    int     21h
ENDM

; 3Ah
@RmDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Ah
    int     21h
ENDM

; 3Bh
@ChDir MACRO path, segmnt
    __LdAdr dx, <path>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 3Bh
    int     21h
ENDM

; 47h
@GetDir MACRO buffer, drive, segmnt
    IFNB    <drive>
        mov     dl, drive
    ELSE
        sub     dl, dl
    ENDIF
    __LdAdr si, <buffer>
    IFNB    <segmnt>
        __LdSeg ds, <segmnt>
    ENDIF
    mov     ah, 47h
    int     21h
ENDM

; 19h
@GetDrv MACRO
    mov     ah, 19h
    int     21h
ENDM

; 0Eh
@SetDrv MACRO drive
    mov     dl, drive
    mov     ah, 0Eh
    int     21h
ENDM

; 36h
@ChkDrv MACRO drive
    IFNB    <drive>
        mov     dl, drive
    ELSE
        sub     dl, dl
    ENDIF
    mov     ah, 36h
    int     21h
ENDM

; 4Ch
@Exit MACRO return
    IFB     <return>
        mov     ah, 4Ch
    ELSE
        mov     ax, 4C00h + (return AND 0FFh)
    ENDIF
    int     21h
ENDM

; 4Bh
@Exec MACRO path, parms, segpath, segparms, overlay
    __LdAdr dx, <path>
    __LdAdr bx, <parms>
    IFNB    <segpath>
        __LdSeg ds, <segpath>
    ENDIF
    IFNB    <segparms>
        __LdSeg es, <segparms>
    ENDIF
    IFB     <overlay>
        mov     ax, 4B00h
    ELSE
        mov     ax, 4B03h
    ENDIF
    int     21h
ENDM

; 4Dh
@GetRet MACRO
    mov     ah, 4Dh
    int     21h
ENDM

; 31h
@TSR MACRO paragraphs, return
    mov     dx, paragraphs
    IFB     <return>
        mov     ah, 31h
    ELSE
        mov     ax, 3100h + (return AND 0FFh)
    ENDIF
    int     21h
ENDM

; 49h
@FreeBlok MACRO segmnt
    IFNB    <segmnt>
        __LdSeg es, <segmnt>
    ENDIF
    mov     ah, 49h
    int     21h
ENDM

; 48h
@GetBlok MACRO graphs
    LOCAL   tryit
    mov     bx, graphs
    tryit:  mov     ah, 48h
    int     21h
    jc      tryit
ENDM

; 4Ah
@ModBlok MACRO graphs, segmnt
    IFNB    <segmnt>
        __LdSeg es, <segmnt>
    ENDIF
    mov     bx, graphs
    mov     ah, 4Ah
    int     21h
ENDM

; 2Ah
@GetDate MACRO
    mov     ah, 2Ah
    int     21h
ENDM

; 2Bh
@SetDate MACRO month, day, year
    mov     cx, year
    mov     dh, month
    mov     dl, day
    mov     ah, 2Bh
    int     21h
ENDM

; 2Ch
@GetTime MACRO
    mov     ah, 2Ch
    int     21h
ENDM

; 2Dh
@SetTime MACRO hour, minutes, seconds, hundredths
    mov     ch, hour
    mov     cl, minutes
    mov     dh, seconds
    mov     dl, hundredths
    mov     ah, 2Dh
    int     21h
ENDM

; 30h
@GetVer MACRO
    mov     ah, 30h
    int     21h
ENDM

; 35h
@GetInt MACRO   interrupt
    mov     ax, 3500h + (interrupt AND 0FFh)
    int     21h
ENDM

; 25h
@SetInt MACRO interrupt, vector, segmnt
    IF      TYPE (vector) GE 0FFFEh
        mov     dx, OFFSET vector
        mov     ax, SEG vector
        mov     ds, ax
    ELSE
        __LdAdr dx, <vector>
        IFNB    <segmnt>
            __LdSeg ds, <segmnt>
        ENDIF
    ENDIF
    mov     ax, 2500h + (interrupt AND 0FFh)
    int     21h
ENDM

ENDIF ; Pass 1
.CREF
.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines macros for character classification/conversion.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

#ifdef _DLL
extern unsigned char _FAR_ _cdecl _ctype[];
#else
extern unsigned char _near _cdecl _ctype[];
#endif

/* set bit masks for the possible character types */

#define _UPPER		0x1	/* upper case letter */
#define _LOWER		0x2	/* lower case letter */
#define _DIGIT		0x4	/* digit[0-9] */
#define _SPACE		0x8	/* tab, carriage return, newline, */
				/* vertical tab or form feed */
#define _PUNCT		0x10	/* punctuation character */
#define _CONTROL	0x20	/* control character */
#define _BLANK		0x40	/* space char */
#define _HEX		0x80	/* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int _FAR_ _cdecl isalpha(int);
int _FAR_ _cdecl isupper(int);
int _FAR_ _cdecl islower(int);
int _FAR_ _cdecl isdigit(int);
int _FAR_ _cdecl isxdigit(int);
int _FAR_ _cdecl isspace(int);
int _FAR_ _cdecl ispunct(int);
int _FAR_ _cdecl isalnum(int);
int _FAR_ _cdecl isprint(int);
int _FAR_ _cdecl isgraph(int);
int _FAR_ _cdecl iscntrl(int);
int _FAR_ _cdecl toupper(int);
int _FAR_ _cdecl tolower(int);
int _FAR_ _cdecl _tolower(int);
int _FAR_ _cdecl _toupper(int);
int _FAR_ _cdecl isascii(int);
int _FAR_ _cdecl toascii(int);
int _FAR_ _cdecl iscsymf(int);
int _FAR_ _cdecl iscsym(int);
#define _CTYPE_DEFINED
#endif

/* the character classification macro definitions */

#define isalpha(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c)	( (_ctype+1)[_c] & _UPPER )
#define islower(_c)	( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c)	( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)	( (_ctype+1)[_c] & _HEX )
#define isspace(_c)	( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c)	( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c)	( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c)	( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c)	( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c)	( (_ctype+1)[_c] & _CONTROL )
#ifndef NO_EXT_KEYS
#define toupper(_c)	( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c)	( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif
#define _tolower(_c)	( (_c)-'A'+'a' )
#define _toupper(_c)	( (_c)-'a'+'A' )
#define isascii(_c)	( (unsigned)(_c) < 0x80 )
#define toascii(_c)	( (_c) & 0x7f )

/* MS C version 2.0 extended ctype macros */

#define iscsymf(_c)	(isalpha(_c) || ((_c) == '_'))
#define iscsym(_c)	(isalnum(_c) || ((_c) == '_'))
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines the structs and unions used for the direct DOS interface
*	routines; includes macros to access the segment and offset
*	values of far pointers, so that they may be used by the routines; and
*	provides function prototypes for direct DOS interface functions.
*
****/


#ifndef _REGS_DEFINED

/* word registers */

struct WORDREGS {
	unsigned int ax;
	unsigned int bx;
	unsigned int cx;
	unsigned int dx;
	unsigned int si;
	unsigned int di;
	unsigned int cflag;
	};


/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};


/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};


/* segment registers */

struct SREGS {
	unsigned int es;
	unsigned int cs;
	unsigned int ss;
	unsigned int ds;
	};

#define _REGS_DEFINED

#endif


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED

struct DOSERROR {
	int exterror;
	char class;
	char action;
	char locus;
	};

#define _DOSERROR_DEFINED

#endif


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED

struct find_t {
	char reserved[21];
	char attrib;
	unsigned wr_time;
	unsigned wr_date;
	long size;
	char name[13];
	};

#define _FIND_T_DEFINED

#endif


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED

struct dosdate_t {
	unsigned char day;		/* 1-31 */
	unsigned char month;		/* 1-12 */
	unsigned int year;		/* 1980-2099 */
	unsigned char dayofweek;	/* 0-6, 0=Sunday */
	};

struct dostime_t {
	unsigned char hour;	/* 0-23 */
	unsigned char minute;	/* 0-59 */
	unsigned char second;	/* 0-59 */
	unsigned char hsecond;	/* 0-99 */
	};

#define _DATETIME_T_DEFINED

#endif


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct diskfree_t {
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
	};

#define _DISKFREE_T_DEFINED

#endif


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE 	0	/* Ignore the error */
#define _HARDERR_RETRY		1	/* Retry the operation */
#define _HARDERR_ABORT		2	/* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL		3	/* Fail the system call in progress */
					/* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL	0x00	/* Normal file - No read/write restrictions */
#define _A_RDONLY	0x01	/* Read only file */
#define _A_HIDDEN	0x02	/* Hidden file */
#define _A_SYSTEM	0x04	/* System file */
#define _A_VOLID	0x08	/* Volume ID file */
#define _A_SUBDIR	0x10	/* Subdirectory */
#define _A_ARCH 	0x20	/* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))


/* external variable declarations */

extern unsigned int _near _cdecl _osversion;


/* function prototypes */

#ifndef _MT
int _cdecl bdos(int, unsigned int, unsigned int);
void _cdecl _chain_intr(void (_cdecl _interrupt _far *)());
void _cdecl _disable(void);
unsigned _cdecl _dos_allocmem(unsigned, unsigned *);
unsigned _cdecl _dos_close(int);
unsigned _cdecl _dos_creat(const char *, unsigned, int *);
unsigned _cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned _cdecl _dos_findfirst(const char *, unsigned, struct find_t *);
unsigned _cdecl _dos_findnext(struct find_t *);
unsigned _cdecl _dos_freemem(unsigned);
void _cdecl _dos_getdate(struct dosdate_t *);
void _cdecl _dos_getdrive(unsigned *);
unsigned _cdecl _dos_getdiskfree(unsigned, struct diskfree_t *);
unsigned _cdecl _dos_getfileattr(const char *, unsigned *);
unsigned _cdecl _dos_getftime(int, unsigned *, unsigned *);
void _cdecl _dos_gettime(struct dostime_t *);
void (_cdecl _interrupt _far * _cdecl _dos_getvect(unsigned))();
void _cdecl _dos_keep(unsigned, unsigned);
unsigned _cdecl _dos_open(const char *, unsigned, int *);
unsigned _cdecl _dos_read(int, void _far *, unsigned, unsigned *);
unsigned _cdecl _dos_setblock(unsigned, unsigned, unsigned *);
unsigned _cdecl _dos_setdate(struct dosdate_t *);
void _cdecl _dos_setdrive(unsigned, unsigned *);
unsigned _cdecl _dos_setfileattr(const char *, unsigned);
unsigned _cdecl _dos_setftime(int, unsigned, unsigned);
unsigned _cdecl _dos_settime(struct dostime_t *);
void _cdecl _dos_setvect(unsigned, void (_cdecl _interrupt _far *)());
unsigned _cdecl _dos_write(int, const void _far *, unsigned, unsigned *);
int _cdecl dosexterr(struct DOSERROR *);
void _cdecl _enable(void);
void _cdecl _harderr(void (_far *)());
void _cdecl _hardresume(int);
void _cdecl _hardretn(int);
int _cdecl intdos(union REGS *, union REGS *);
int _cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int _cdecl int86(int, union REGS *, union REGS *);
int _cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif /* _MT */

void _cdecl segread(struct SREGS *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the system-wide error numbers (set by
*	system calls).	Conforms to the XENIX standard.  Extended
*	for compatibility with Uniforum standard.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* declare reference to errno */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
#define errno	(*_errno())
#else
extern int _near _cdecl volatile errno;
#endif

/* Error Codes */

#define EZERO		0
#define EPERM		1
#define ENOENT		2
#define ESRCH		3
#define EINTR		4
#define EIO		5
#define ENXIO		6
#define E2BIG		7
#define ENOEXEC 	8
#define EBADF		9
#define ECHILD		10
#define EAGAIN		11
#define ENOMEM		12
#define EACCES		13
#define EFAULT		14
#define ENOTBLK 	15
#define EBUSY		16
#define EEXIST		17
#define EXDEV		18
#define ENODEV		19
#define ENOTDIR 	20
#define EISDIR		21
#define EINVAL		22
#define ENFILE		23
#define EMFILE		24
#define ENOTTY		25
#define ETXTBSY 	26
#define EFBIG		27
#define ENOSPC		28
#define ESPIPE		29
#define EROFS		30
#define EMLINK		31
#define EPIPE		32
#define EDOM		33
#define ERANGE		34
#define EUCLEAN 	35
#define EDEADLOCK	36
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines constants for the file control options used
*	by the open() function.
*	[System V]
*
****/

#define O_RDONLY	0x0000	/* open for reading only */
#define O_WRONLY	0x0001	/* open for writing only */
#define O_RDWR		0x0002	/* open for reading and writing */
#define O_APPEND	0x0008	/* writes done at eof */

#define O_CREAT 	0x0100	/* create and open file */
#define O_TRUNC 	0x0200	/* open and truncate */
#define O_EXCL		0x0400	/* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define O_TEXT		0x4000	/* file mode is text (translated) */
#define O_BINARY	0x8000	/* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define O_RAW	O_BINARY

/* Open handle inherit bit */

#define O_NOINHERIT	0x0080	/* child process doesn't inherit file */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\limits.h ===
/***
*limits.h - implementation dependent values
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains defines for a number of implementation dependent values
*	which are commonly used in C programs.
*	[ANSI]
*
****/

#define CHAR_BIT	  8		/* number of bits in a char */
#define SCHAR_MIN	(-127)		/* minimum signed char value */
#define SCHAR_MAX	  127		/* maximum signed char value */
#define UCHAR_MAX	  0xff		/* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN	SCHAR_MIN	/* mimimum char value */
#define CHAR_MAX	SCHAR_MAX	/* maximum char value */
#else
#define CHAR_MIN	  0
#define CHAR_MAX	UCHAR_MAX
#endif
#define	MB_LEN_MAX	  1		/* max. # bytes in multibyte char */
#define SHRT_MIN	(-32767)	/* minimum (signed) short value */
#define SHRT_MAX	  32767 	/* maximum (signed) short value */
#define USHRT_MAX	  0xffff	/* maximum unsigned short value */
#define INT_MIN 	(-32767)	/* minimum (signed) int value */
#define INT_MAX 	  32767 	/* maximum (signed) int value */
#define UINT_MAX	  0xffff	/* maximum unsigned int value */
#define LONG_MIN	(-2147483647)	/* minimum (signed) long value */
#define LONG_MAX	  2147483647	/* maximum (signed) long value */
#define ULONG_MAX	  0xffffffff	/* maximum unsigned long value */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the low-level
*	file handling and I/O functions.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* function prototypes */

int _FAR_ _cdecl access(const char _FAR_ *, int);
int _FAR_ _cdecl chmod(const char _FAR_ *, int);
int _FAR_ _cdecl chsize(int, long);
int _FAR_ _cdecl close(int);
int _FAR_ _cdecl creat(const char _FAR_ *, int);
int _FAR_ _cdecl dup(int);
int _FAR_ _cdecl dup2(int, int);
int _FAR_ _cdecl eof(int);
long _FAR_ _cdecl filelength(int);
int _FAR_ _cdecl isatty(int);
int _FAR_ _cdecl locking(int, int, long);
long _FAR_ _cdecl lseek(int, long, int);
char _FAR_ * _FAR_ _cdecl mktemp(char _FAR_ *);
int _FAR_ _cdecl open(const char _FAR_ *, int, ...);
int _FAR_ _cdecl _pipe(int _FAR_ *, unsigned int, int);
int _FAR_ _cdecl read(int, void _FAR_ *, unsigned int);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl setmode(int, int);
int _FAR_ _cdecl sopen(const char _FAR_ *, int, int, ...);
long _FAR_ _cdecl tell(int);
int _FAR_ _cdecl umask(int);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl write(int, const void _FAR_ *, unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\float.h ===
/***
*float.h - constants for floating point values
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains defines for a number of implementation dependent
*	values which are commonly used by sophisticated numerical (floating
*	point) programs.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#define DBL_DIG 	15			/* # of decimal digits of precision */
#define DBL_EPSILON	2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG	53			/* # of bits in mantissa */
#define DBL_MAX 	1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP	308			/* max decimal exponent */
#define DBL_MAX_EXP	1024			/* max binary exponent */
#define DBL_MIN 	2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP	(-307)			/* min decimal exponent */
#define DBL_MIN_EXP	(-1021) 		/* min binary exponent */
#define DBL_RADIX	2			/* exponent radix */
#define DBL_ROUNDS	1			/* addition rounding: near */

#define FLT_DIG 	7			/* # of decimal digits of precision */
#define FLT_EPSILON	1.192092896e-07F 	/* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD	0
#define FLT_MANT_DIG	24			/* # of bits in mantissa */
#define FLT_MAX 	3.402823466e+38F 	/* max value */
#define FLT_MAX_10_EXP	38			/* max decimal exponent */
#define FLT_MAX_EXP	128			/* max binary exponent */
#define FLT_MIN 	1.175494351e-38F 	/* min positive value */
#define FLT_MIN_10_EXP	(-37)			/* min decimal exponent */
#define FLT_MIN_EXP	(-125)			/* min binary exponent */
#define FLT_NORMALIZE	0
#define FLT_RADIX	2			/* exponent radix */
#define FLT_ROUNDS	1			/* addition rounding: near */

#define LDBL_DIG	19			/* # of decimal digits of precision */
#define LDBL_EPSILON	5.4210108624275221706e-020  /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG	64			/* # of bits in mantissa */
#define LDBL_MAX	1.189731495357231765e+4932L /* max value */
#define LDBL_MAX_10_EXP 4932			/* max decimal exponent */
#define LDBL_MAX_EXP	16384			/* max binary exponent */
#define LDBL_MIN	3.3621031431120935063e-4932L /* min positive value */
#define LDBL_MIN_10_EXP (-4931) 		/* min decimal exponent */
#define LDBL_MIN_EXP	(-16381)		/* min binary exponent */
#define LDBL_RADIX	2			/* exponent radix */
#define LDBL_ROUNDS	1			/* addition rounding: near */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define MCW_EM		0x003f		/* interrupt Exception Masks */
#define EM_INVALID	0x0001		/*   invalid */
#define EM_DENORMAL	0x0002		/*   denormal */
#define EM_ZERODIVIDE	0x0004		/*   zero divide */
#define EM_OVERFLOW	0x0008		/*   overflow */
#define EM_UNDERFLOW	0x0010		/*   underflow */
#define EM_INEXACT	0x0020		/*   inexact (precision) */

#define MCW_IC		0x1000		/* Infinity Control */
#define IC_AFFINE	0x1000		/*   affine */
#define IC_PROJECTIVE	0x0000		/*   projective */

#define MCW_RC		0x0c00		/* Rounding Control */
#define RC_CHOP 	0x0c00		/*   chop */
#define RC_UP		0x0800		/*   up */
#define RC_DOWN 	0x0400		/*   down */
#define RC_NEAR 	0x0000		/*   near */

#define MCW_PC		0x0300		/* Precision Control */
#define PC_24		0x0000		/*    24 bits */
#define PC_53		0x0200		/*    53 bits */
#define PC_64		0x0300		/*    64 bits */


/* initial Control Word value */

#define CW_DEFAULT ( IC_AFFINE + RC_NEAR + PC_64 + EM_DENORMAL + EM_UNDERFLOW + EM_INEXACT )


/* user Status Word bit definitions */

#define SW_INVALID	0x0001	/* invalid */
#define SW_DENORMAL	0x0002	/* denormal */
#define SW_ZERODIVIDE	0x0004	/* zero divide */
#define SW_OVERFLOW	0x0008	/* overflow */
#define SW_UNDERFLOW	0x0010	/* underflow */
#define SW_INEXACT	0x0020	/* inexact (precision) */


/* invalid subconditions (SW_INVALID also set) */

#define SW_UNEMULATED		0x0040	/* unemulated instruction */
#define SW_SQRTNEG		0x0080	/* square root of a neg number */
#define SW_STACKOVERFLOW	0x0200	/* FP stack overflow */
#define SW_STACKUNDERFLOW	0x0400	/* FP stack underflow */


/*  Floating point error signals and return codes */

#define FPE_INVALID		0x81
#define FPE_DENORMAL		0x82
#define FPE_ZERODIVIDE		0x83
#define FPE_OVERFLOW		0x84
#define FPE_UNDERFLOW		0x85
#define FPE_INEXACT		0x86

#define FPE_UNEMULATED		0x87
#define FPE_SQRTNEG		0x88
#define FPE_STACKOVERFLOW	0x8a
#define FPE_STACKUNDERFLOW	0x8b

#define FPE_EXPLICITGEN 	0x8c	/* raise( SIGFPE ); */

/* function prototypes */

unsigned int _FAR_ _cdecl _clear87(void);
unsigned int _FAR_ _cdecl _control87(unsigned int, unsigned int);
void _FAR_ _cdecl _fpreset(void);
unsigned int _FAR_ _cdecl _status87(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\ext.h ===
/*** ext.h - extension definitions
*
*   Copyright <C> 1988-1990, Microsoft Corporation
*
*
*************************************************************************/

//************************************************************************
//
// Macro Definitions
//
// Common Definitions
//

#include <stddef.h>	// get definition of NULL

#ifndef TRUE
#define TRUE	1
#endif

#ifndef FALSE
#define FALSE	0
#endif

//
// PNULL - NULL PFILE
//
#define PNULL	((PFILE) NULL)
//
// BUFLEN is the maximum line length that can be passed or will be returned
// by the editor. MAX_PATH is the maximum path length supported.
//
#define BUFLEN	    251
#define MAX_PATH    200
//
// EXPORT defines the attributes required for extension functions. _loadds
// is used such that extensions can be compiled /Aw as well as /Au.
//
#define EXPORT		_loadds far
#define EXTERNAL	_loadds far
//
// PWBFUNC defines the return value and characteristics of extension defined
// editing functions.
//
#define PWBFUNC 	flagType pascal _loadds far
//
// RQ_... are various request types supported for Get/Set EditorObject
//
#define RQ_FILE 	0x1000		// GetEditorObject: File request
#define RQ_FILE_HANDLE	0x1000		//	File Handle
#define RQ_FILE_NAME	0x1100		//	ASCIIZ filename
#define RQ_FILE_FLAGS	0x1200		//	flags
#define RQ_FILE_REFCNT	0x1300		//	reference count
#define RQ_FILE_FREEZE	0x1400		//	freeze count
#define RQ_WIN		0x2000		// Window request
#define RQ_WIN_HANDLE	0x2000		//	Window Handle
#define RQ_WIN_CONTENTS 0x2100		//	Window Contents
#define RQ_WIN_CUR	0x2200		//	Current Window
#define RQ_WIN_MAXED	0x2300		//	Zoomed flag
#define RQ_MISC 	0x3000		// Misc requests
#define RQ_SCREENSIZE	0x3100		//	screen size
#define RQ_SEARCHINFO	0x3200		//	search state information
#define RQ_COLOR	0x9000		// Color request
#define RQ_NAME		0xd000		// editor name
#define RQ_TOOLSINI	0xe000		// tools.ini PFILE
#define RQ_CLIP 	0xf000		// clipboard type
//
// toPif is used when placing numeric or boolean switches in the swiDesc
// table to eliminate C 5.X compiler warnings.
//
// For example: { "Switchname", toPIF(switchvar), SWI_BOOLEAN },
//
#define toPIF(x)  (PIF)(long)(void far *)&x
//
// Editor color table indicies. (Colors USERCOLORMIN - USERCOLORMAX are
// unassigned and available for extension use).
//
#define Background	0		// all backgrounds (unused in PWB)
#define Hilite		1		// Hilited items
#define Greyed		2		// greyed items
#define Enabled 	3		// enabled items
#define Disabled	4		// disabled items
#define Alert		5		// for MessageBox alerts
#define DialogBox	6		// background for dialogs
#define PushButton	7		// push button color
#define ButtonDown	8		// pushed button color
#define ListBox 	9		// listbox background
#define Scrollbar	10		// scroll bar Background & arrows
#define Elevator	11		// scroll bar elevator
#define MenuBox 	12		// background for menus
#define Menu		13		// menu bar color
#define MenuSelected	14		// Selected menus
#define MenuHilite	15		// for single character
#define MenuHiliteSel	16		// for single character (under selection)
#define ItemHiliteSel	17		// for single character (under selection)
#define DialogAccel	18		// dialog accelerators
#define DialogAccelBor	19		// dialog accelerator border
#define Shadow		20		// shadows
#define FGCOLOR 	21		// foreground (normal) color
#define HGCOLOR 	22		// highlighted region color
#define INFCOLOR	23		// information color
#define SELCOLOR	24		// selection color
#define WDCOLOR 	25		// window border color
#define STACOLOR	26		// status line color
//			27		// internal: used by PWB
#define USERCOLORMIN	28		// begining of extension colors
#define USERCOLORMAX	35		// end of extension colors
//
// Attributes for ForFile
//
#define FORFILE_RO	1		// read only
#define FORFILE_H	2		// hidden
#define FORFILE_S	4		// system
#define FORFILE_V	8		// volume id
#define FORFILE_D	16		// directory
#define FORFILE_A	32		// archive

#define FORFILE_MOD	(FORFILE_RO|FORFILE_H|FORFILE_S|FORFILE_A) // changeable attributes 
#define FORFILE_ALL	(FORFILE_RO|FORFILE_H|FORFILE_S|FORFILE_V|FORFILE_D|FORFILE_A)
//
// Menu ID's
#define MID_FILE	0x0000
#define MID_NEW 	(MID_FILE + 1)
#define MID_OPEN	(MID_FILE + 2)
#define MID_MERGE	(MID_FILE + 3)
#define MID_NEXT	(MID_FILE + 4)
#define MID_SAVE	(MID_FILE + 5)
#define MID_SAVEAS	(MID_FILE + 6)
#define MID_SAVEALL	(MID_FILE + 7)
#define MID_FCLOSE	(MID_FILE + 8)

#define MID_PRINT	(MID_FILE + 10)
#define MID_SHELL	(MID_FILE + 11)

#define MID_EXIT	(MID_FILE + 13)

#define MID_FILE1	(MID_FILE + 0x80 + 0)
#define MID_FILE2	(MID_FILE + 0x80 + 1)
#define MID_FILE3	(MID_FILE + 0x80 + 2)
#define MID_FILE4	(MID_FILE + 0x80 + 3)
#define MID_FILE5	(MID_FILE + 0x80 + 4)
#define MID_FILE6	(MID_FILE + 0x80 + 5)
#define MID_MORE	(MID_FILE + 0x80 + 6)

#define MID_EDIT	0x0100
#define MID_UNDO	(MID_EDIT + 1)
#define MID_REDO	(MID_EDIT + 2)
#define MID_REPEAT	(MID_EDIT + 3)

#define MID_CUT 	(MID_EDIT + 5)
#define MID_COPY	(MID_EDIT + 6)
#define MID_PASTE	(MID_EDIT + 7)
#define MID_CLEAR	(MID_EDIT + 8)

#define MID_DROPANCHOR	(MID_EDIT + 10)
#define MID_ANCHOR	(MID_EDIT + 11)

#define MID_BOXMODE	(MID_EDIT + 13)
#define MID_READONLY	(MID_EDIT + 14)

#define MID_SETREC	(MID_EDIT + 16)
#define MID_RECORD	(MID_EDIT + 17)
#define MID_EDITMACROS	(MID_EDIT + 18)

#define MID_VIEW	0x0200
#define MID_SPLITH	(MID_VIEW + 1)
#define MID_SPLITV	(MID_VIEW + 2)
#define MID_SIZE	(MID_VIEW + 3)
#define MID_MAXIMIZE	(MID_VIEW + 4)
#define MID_CLOSE	(MID_VIEW + 5)

#define MID_ERRWIN	(MID_VIEW + 7)

#define MID_SEARCH	0x0300
#define MID_FIND	(MID_SEARCH + 1)
#define MID_FINDSEL	(MID_SEARCH + 2)
#define MID_FINDLAST	(MID_SEARCH + 3)
#define MID_REPLACE	(MID_SEARCH + 4)
#define MID_FINDFILE	(MID_SEARCH + 5)

#define MID_NEXTERR	(MID_SEARCH + 7)
#define MID_PREVERR	(MID_SEARCH + 8)
#define MID_SETERR	(MID_SEARCH + 9)

#define MID_GOTOMARK	(MID_SEARCH + 11)
#define MID_DEFMARK	(MID_SEARCH + 12)
#define MID_SETMARK	(MID_SEARCH + 13)

#define MID_MAKE	0x0400
#define MID_COMPILE	(MID_MAKE + 1)
#define MID_BUILD	(MID_MAKE + 2)
#define MID_REBUILD	(MID_MAKE + 3)
#define MID_TARGET	(MID_MAKE + 4)

#define MID_SETLIST	(MID_MAKE + 6)
#define MID_EDITLIST	(MID_MAKE + 7)
#define MID_CLEARLIST	(MID_MAKE + 8)

#define MID_RUN 	0x0500
#define MID_EXECUTE	(MID_RUN + 1)
#define MID_CMDLINE	(MID_RUN + 2)
#define MID_DEBUG	(MID_RUN + 3)

#define MID_RUNAPP	(MID_RUN + 5)
#define MID_CUSTOM	(MID_RUN + 6)

#define MID_USER1	(MID_RUN + 0x80 + 0)
#define MID_USER2	(MID_RUN + 0x80 + 1)
#define MID_USER3	(MID_RUN + 0x80 + 2)
#define MID_USER4	(MID_RUN + 0x80 + 3)
#define MID_USER5	(MID_RUN + 0x80 + 4)
#define MID_USER6	(MID_RUN + 0x80 + 5)

#define MID_OPTIONS	 0x0600
#define MID_ENVIRONMENT  (MID_OPTIONS + 1)
#define MID_ASSIGNKEY	 (MID_OPTIONS + 2)
#define MID_SETSWITCH	 (MID_OPTIONS + 3)

#define MID_BUILDOPTIONS (MID_OPTIONS + 5)

#define MID_EXTENSION	  0x700

//************************************************************************
//
// General type Definitions
//
typedef char flagType;			// Boolean value
typedef int  COL;			// column or position with line
typedef long LINE;			// line number within file
typedef unsigned PFILE; 		// editor file handle
#ifndef EXTINT
typedef unsigned PWND;			// editor window handle
#endif


typedef char buffer[BUFLEN];		// miscellaneous buffer
typedef char linebuf[BUFLEN];		// line buffer
typedef char pathbuf[BUFLEN];		// Pathname buffer


typedef struct {			// file location
    LINE    lin;			// - line number
    COL     col;			// - column
    } fl;

typedef struct {			// screen location
    int     lin;			// - line number
    int     col;			// - column
    } sl;

typedef struct {			// file range
    fl	    flFirst;			// - Lower line, or leftmost col
    fl	    flLast;			// - Higher, or rightmost
    } rn;

typedef struct lineAttr {		// Line color attribute info
    unsigned char attr; 		// - Attribute of piece
    unsigned char len;			// - Bytes in colored piece
    } la;

typedef unsigned char	BYTE;
typedef struct _arc
	{
	BYTE axLeft;
	BYTE ayTop;
	BYTE axRight;
	BYTE ayBottom;
	} ARC;

//************************************************************************
//
// Argument definition structures.
//
// We define a structure for each of the argument types that may be passed
// to an extension function. Then, we define the structure argType which is
// used to pass these arguments around in a union.
//
struct	noargType {			// no argument specified
    LINE    y;				// - cursor line
    COL     x;				// - cursor column
    };

struct textargType {			// text argument specified
    int     cArg;			// - count of <arg>s pressed
    LINE    y;				// - cursor line
    COL     x;				// - cursor column
    char far *pText;			// - ptr to text of arg
    };

struct	nullargType {			// null argument specified
    int     cArg;			// - count of <arg>s pressed
    LINE    y;				// - cursor line
    COL     x;				// - cursor column
    };

struct lineargType {			// line argument specified
    int     cArg;			// - count of <arg>s pressed
    LINE yStart;			// - starting line of range
    LINE yEnd;				// - ending line of range
    };

struct streamargType {			// stream argument specified
    int     cArg;			// - count of <arg>s pressed
    LINE yStart;			// - starting line of region
    COL  xStart;			// - starting column of region
    LINE yEnd;				// - ending line of region
    COL  xEnd;				// - ending column of region
    };

struct boxargType {			// box argument specified
    int     cArg;			// - count of <arg>s pressed
    LINE yTop;				// - top line of box
    LINE yBottom;			// - bottom line of bix
    COL  xLeft; 			// - left column of box
    COL  xRight;			// - right column of box
    };

struct	argType {
    int     argType;
    union   {
	struct	noargType	noarg;
	struct	textargType	textarg;
	struct	nullargType	nullarg;
	struct	lineargType	linearg;
	struct	streamargType	streamarg;
	struct	boxargType	boxarg;
	} arg;
    };
typedef struct argType ARG;

//************************************************************************
//
// Function definition table definitions
//
typedef unsigned CMDDATA;

struct cmdDesc {				// function definition entry
    char far *name;				// - pointer to name of fcn
    flagType (pascal EXTERNAL *func)(CMDDATA,
				     ARG far *,
				     flagType);	// - pointer to function
    CMDDATA  arg;				// - used internally by editor
    unsigned argType;				// - user args allowed
    };
typedef struct cmdDesc far *PCMD;

typedef struct KeyData {		// Key information
    unsigned ascii;			// ASCII code, or .vkey if none
    unsigned scan;			// scan code
    unsigned vkey;			// virtual key code
    unsigned shift;			// Shift state 0 - 3
    PCMD pFunc; 			// command key will invoke
    char name[30];			// full name for key
    } KeyData;

typedef unsigned KeyHandle;

#define NOARG	    0x0001		// no argument specified
#define TEXTARG     0x0002		// text specified
#define NULLARG     0x0004		// arg + no cursor movement
#define NULLEOL     0x0008		// null arg => text from arg->eol
#define NULLEOW     0x0010		// null arg => text from arg->end word
#define LINEARG     0x0020		// range of entire lines
#define STREAMARG   0x0040		// from low-to-high, viewed 1-D
#define BOXARG	    0x0080		// box delimited by arg, cursor

#define NUMARG	    0x0100		// text => delta to y position
#define MARKARG     0x0200		// text => mark at end of arg

#define BOXSTR	    0x0400		// single-line box => text

#define FASTKEY     0x0800		// Fast repeat function
#define MODIFIES    0x1000		// modifies file
#define KEEPMETA    0x2000		// do not eat meta flag
#define WINDOWFUNC  0x4000		// moves window
#define CURSORFUNC  0x8000		// moves cursor

//************************************************************************
//
// Switch definition table defintions
//
typedef flagType (pascal EXTERNAL *PIF)(char far *);

union swiAct {				// switch location or routine
    flagType (pascal EXTERNAL *pFunc)(char far *); // - routine for text
    char far * (pascal EXTERNAL *pFunc2)(char far *);  // - routine for text
    int far *ival;			// - integer value for NUMERIC
    flagType far *fval; 		// - flag value for BOOLEAN
    };

struct swiDesc {			// switch definition entry
    char far *name;			// - pointer to name of switch
    union swiAct act;			// - pointer to value or fcn
    int type;				// - flags defining switch type
    };
typedef struct swiDesc far *PSWI;

#define SWI_BOOLEAN 0			// Boolean switch
#define SWI_NUMERIC 1			// hex or decimal switch
#define SWI_SCREEN  4			// switch affects screen
#define SWI_SPECIAL 5			// textual switch
#define SWI_SPECIAL2 6			// #5, returning an error string
#define RADIX10 (0x0A << 8)		// numeric switch is decimal
#define RADIX16 (0x10 << 8)		// numeric switch is hex

//************************************************************************
//
// Get/Set EditorObject data structures
//
typedef struct {			// define window contents
    PFILE	pFile;			// - handle of file displayed
    ARC 	arcWin; 		// - location of window
    fl		flPos;			// - upper left corner wrt file
    } winContents;

typedef struct {			// search/replace state information
    struct {				// TOOLS.INI switch info
	flagType fUnixRE;		// TRUE => Use UNIX RE's (unixre: switch)
	flagType fSrchCase;		// TRUE => case is significant (case: switch)
	flagType fSrchWrap;		// TRUE => searches wrap (wrap: switch)
	} swit;
    struct {				// state of previous activity
	flagType fSrchAll;		// TRUE => previously searched for all
	flagType fSrchCase;		// TRUE => case was significant
	flagType fSrchDir;		// TRUE => previously searched forward
	flagType fSrchRe;		// TRUE => search previously used RE's
	flagType fSrchWrap;		// TRUE => previously did wrap
	flagType fReplRe;		// TRUE => replace previously used RE's
	buffer	 szSrch;		// search buffer
	buffer	 szReplsrc;		// source string for replace
	buffer	 szReplrpl;		// destination string for replace
	} prev;
    } SearchInfo;

//
// FILE flags values
//
//
// DIRTY	file had been modified, and has not yet been written to disk.
//
// FAKE		file is a pseudo file. It cannot be saved to disk under it's
//		current name, and may also be otherwise treated specially.
//
// REAL		file has been read from disk. If reset, the file needs to be
//		read if any operations are to be performed on it. (May also
//		be set for FAKE files, even though they are not really on
//		disk.)
//
// DOSFILE	file has CR-LF. If not set, lines are terminated by LF only
//		in unix-style. The setting is determined by the file reader
//		having seen CRLF or not. Should default on for all files we
//		create.
//
// TEMP		file is a temp file, and is not saved in the status file.
//		These are the files specified by /t on the command line.
//
// NEW		file has been created by editor. This is set when we create
//		the file (after asking the user), and causes us to avoid
//		trying to back-up a non-existant previous version.
//
// REFRESH	file needs to be refreshed every time it is viewed. This is
//		set for pseudo files which need to be regenerated each time
//		they are viewed, such as <information-file>, the file history
//		list.
//
// READONLY	file may not be edited. For example, this bit is set by the
//		help extension on it's pseudo file to prevent users from
//		editing the contents. All commands with the MODIFIES bit are
//		disabled if a file with this bit is current.
//
// DISKRO	file on disk is read only.
//
// MODE1	Meaning depends on the file
//
// VALMARKS	file has valid marks defined
//
// READING	file is currently being read. This means that the idle time
//		reader may be operating on this file.
//
// MARKSDIRTY	file's marks need to be written
//
// HYBRID	file is FAKE, but gets saved
//
// NORENAME	file should never be renamed
//
#define DIRTY	    0x01
#define FAKE	    0x02
#define REAL	    0x04
#define DOSFILE     0x08
#define TEMP	    0x10
#define NEW	    0x20
#define REFRESH     0x40
#define READONLY    0x80

#define DISKRO	    0x0100
#define MODE1	    0x0200
#define VALMARKS    0x0400
#define READING     0x0800

#define MARKSDIRTY  0x1000
#define HYBRID	    0x2000
#define NORENAME    0x4000


/****************************************************************************
 * PWB100 2404								    *
 *									    *
 * Flags for dealing with instance lists when splitting a window...	    *
 * Use these when calling SplitWnd() to specify how to handle the instance  *
 * lists.								    *
 *									    *
 ****************************************************************************/
#define INF_NODUP	0	// don't duplicate instance list, don't move
#define INF_NODUPMV  	2	// don't duplicate instance list, move it
#define INF_DUP 	4	// duplicate instance list

//************************************************************************
//
// Menu, window and dialog definitions
//
// action constants for ChangeMenu
//
#define MNU_DISABLE	1		// disable (grey) menu item
#define MNU_ENABLE	2		// enable menu item
#define MNU_CHECK	3		// check menu item
#define MNU_UNCHECK	4		// uncheck menu item
#define MNU_RENAME	5		// rename menu item
#define MNU_COMMAND	6		// define menu item command
//
// Message box types.
//
#define MBOX_OK 		1	// <OK>
#define MBOX_YESNOCANCEL	2	// <YES> <NO> <CANCEL>
#define MBOX_RETRYCANCEL	3	// <RETRY> <CANCEL>
#define MBOX_OKCANCEL		4	// <OK> <CANCEL>
#define MBOX_ABORT		5	// <ABORT>
#define MBOX_YESNO		6	// <YES> <NO>
#define MBOX_RETRY		7	// <RETRY>
#define MBOX_TYPE		0x0f	// message type
#define MBOX_BEEP		0x10	// beep when displayed
#define MBOX_CAPTION		0x20	// 1st param is caption
#define MBOX_NOHELP		0x8000	// don't add a help button
//
// Message Box Return types
//
#define MBOX_IDOK		1	// <OK> button
#define MBOX_IDCANCEL		2	// <CANCEL> button
#define MBOX_IDABORT		3	// <ABORT> button
#define MBOX_IDRETRY		4	// <RETRY> button
#define MBOX_IDIGNORE		5	// <IGNORE> button
#define MBOX_IDYES		6	// <YES> button
#define MBOX_IDNO		7	// <NO> button


//************************************************************************
//
// Editor lowlevel function prototypes.
//
// This list defines the routines within the editor which may be called
// by extension functions.
//
int	    pascal  EXPORT  AddAColor		(char far *, char far *);
PFILE	    pascal  EXPORT  AddFile		(char far *);
int	    pascal  EXPORT  AddMenu		(char far *, char far *, char far *, flagType);
int	    pascal  EXPORT  AddMenuItem 	(int, char far *, char far *, char far *, char far *);
flagType    pascal  EXPORT  BadArg		(void);
flagType    pascal  EXPORT  ChangeMenu		(int, int, char far *);
void	    pascal  EXPORT  ClearList		(PCMD);
flagType    pascal  EXPORT  CloseWnd		(PWND);
void	    pascal  EXPORT  CopyBox		(PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
void	    pascal  EXPORT  CopyLine		(PFILE, PFILE, LINE, LINE, LINE);
void	    pascal  EXPORT  CopyStream		(PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
void	    pascal  EXPORT  DelBox		(PFILE, COL, LINE, COL, LINE);
void	    pascal  EXPORT  DelFile		(PFILE);
void	    pascal  EXPORT  DelLine		(PFILE, LINE, LINE);
void	    pascal  EXPORT  DelStream		(PFILE, COL, LINE, COL, LINE);
void	    pascal  EXPORT  Display		(void);
int	    pascal  EXPORT  DoMessage		(char far *);
int	    pascal  EXPORT  DoMessageBox	(char far *, char far *, char far *, int, int);
char far *  pascal  EXPORT  Falloc		(long);
char far *  _cdecl  EXPORT  farstrncpy		(char far *, const char far *, int);
char far *  _cdecl  EXPORT  farstrcpy		(char far *, const char far *);
char far *  _cdecl  EXPORT  farstrcat		(char far *, const char far *);
char far *  _cdecl  EXPORT  farstrstr		(const char far *, const char far *);
int	    _cdecl  EXPORT  farstrlen		(const char far *);
int	    _cdecl  EXPORT  farstrnicmp		(const char far *, const char far *, int);
int	    _cdecl  EXPORT  farstrncmp		(const char far *, const char far *, int);
int	    _cdecl  EXPORT  farstrcmp		(const char far *, const char far *);
char far *  pascal  EXPORT  farstradd		(char far *, const char far *);
char far *  pascal  EXPORT  farstrstrip		(char far *);
unsigned    pascal  EXPORT  atou		(const char far *);
flagType    pascal  EXPORT  fChangeFile 	(flagType, char far *);
void	    pascal  EXPORT  Fdalloc		(char far *);
flagType    pascal  EXPORT  fExecute		(char far *);
LINE	    pascal  EXPORT  FileLength		(PFILE);
PFILE	    pascal  EXPORT  FileNameToHandle	(char far *, char far *);
flagType    pascal  EXPORT  FileRead		(char far *, PFILE);
flagType    pascal  EXPORT  FileWrite		(char far *, PFILE);
PSWI	    pascal  EXPORT  FindSwitch		(char far *);
int	    pascal  EXPORT  ForFile		(char far *,int ,void (pascal EXPORT *)(char far *));
flagType    pascal  EXPORT  GetColor		(LINE, struct lineAttr far *, PFILE);
void	    pascal  EXPORT  GetCursor		(COL far *, LINE far *);
flagType    pascal  EXPORT  GetEditorObject	(unsigned, unsigned, void far *);
int	    pascal  EXPORT  GetLine		(LINE, char far *, PFILE);
char far *  pascal  EXPORT  GetListEntry	(PCMD, int, flagType);
PCMD	    pascal  EXPORT  GetListHandle	(char far *, flagType);
flagType    pascal  EXPORT  GetString		(char far *, char far *, flagType);
char far *  pascal  EXPORT  mgetenv		(char far *);
void	    pascal  EXPORT  MoveCur		(COL, LINE);
char far *  pascal  EXPORT  NameToKeys		(char far *, char far *);
PCMD	    pascal  EXPORT  NameToFunc		(char far *);
flagType    pascal  EXPORT  pFileToBottom	(PFILE);
flagType    pascal  EXPORT  pFileToTop		(PFILE);
void	    pascal  EXPORT  PopUpBox		(PFILE, char far *, int, fl);
void	    pascal  EXPORT  PutColor		(LINE, struct lineAttr far *, PFILE);
void	    pascal  EXPORT  PutLine		(LINE, char far *, PFILE);
long	    pascal  EXPORT  ReadChar		(void);
PCMD	    pascal  EXPORT  ReadCmd		(void);
flagType    pascal  EXPORT  RemoveFile		(PFILE);
flagType    pascal  EXPORT  Replace		(char, COL, LINE, PFILE, flagType);
flagType    pascal  EXPORT  Resize		(PWND, ARC);
char far *  pascal  EXPORT  ScanList		(PCMD, flagType);
int	    pascal  EXPORT  search		(PFILE, flagType, flagType, flagType, flagType, char far *, fl far *);
flagType    pascal  EXPORT  SelectFiles		(PCMD, char far *, char far *, char far *, flagType, int);
void	    pascal  EXPORT  SetColor		(PFILE, LINE, COL, COL, int);
void	    pascal  EXPORT  SetHiLite		(PFILE, rn, int);
flagType    pascal  EXPORT  SetEditorObject	(unsigned, unsigned, void far *);
flagType    pascal  EXPORT  SetKey		(char far *, char far *);
PWND	    pascal  EXPORT  SplitWnd		(PWND, flagType, int, int);
long	    pascal  EXPORT  VMAlloc		(long);
void	    pascal  EXPORT  VMFree		(long);
void	    pascal  EXPORT  fpbToVM		(char far *, long, unsigned);
void	    pascal  EXPORT  VMTofpb		(long, char far *, unsigned);

void	    EXTERNAL WhenLoaded (void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*	Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the localization routines.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* Locale categories */

#define LC_ALL		0
#define LC_COLLATE	1
#define LC_CTYPE	2
#define LC_MONETARY	3
#define LC_NUMERIC	4
#define LC_TIME 	5

#define LC_MIN		LC_ALL
#define LC_MAX		LC_TIME


/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
	};
#define _LCONV_DEFINED
#endif

/* function prototypes */

char _FAR_ * _FAR_ _cdecl setlocale(int, const char _FAR_ *);
struct lconv _FAR_ * _FAR_ _cdecl localeconv(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987 - 1990, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and the
*   structures and manifest constants that are used with them.
*
***************************************************************************/


/* force word packing to avoid possible -Zp override */
#pragma pack(2)

/* user-visible declarations for Quick-C Graphics Library */

#ifndef _VIDEOCONFIG_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};
#define _VIDEOCONFIG_DEFINED
#endif


#ifndef _XYCOORD_DEFINED
/* return value of _setvieworg(), etc. */
struct xycoord {
	short xcoord;
	short ycoord;
};
#define _XYCOORD_DEFINED
#endif


/* structure for text position */
#ifndef _RCCOORD_DEFINED
struct rccoord {
	short row;
	short col;
};
#define _RCCOORD_DEFINED
#endif



/* ERROR HANDLING */
short _far _cdecl _grstatus(void);

/* Error Status Information returned by _grstatus() */

/* successful */
#define	_GROK                        0

/* errors */
#define _GRERROR                    (-1)
#define	_GRMODENOTSUPPORTED	    (-2)
#define	_GRNOTINPROPERMODE          (-3)
#define _GRINVALIDPARAMETER         (-4)
#define	_GRFONTFILENOTFOUND         (-5)
#define	_GRINVALIDFONTFILE          (-6)
#define _GRCORRUPTEDFONTFILE        (-7)
#define _GRINSUFFICIENTMEMORY       (-8)
#define _GRINVALIDIMAGEBUFFER       (-9)

/* warnings */
#define _GRNOOUTPUT                  1
#define _GRCLIPPED                   2
#define _GRPARAMETERALTERED          3


/* SETUP AND CONFIGURATION */

short _far _cdecl _setvideomode(short);
short _far _cdecl _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _MAXRESMODE	(-3)	/* graphics mode with highest resolution */
#define _MAXCOLORMODE	(-2)	/* graphics mode with most colors */
#define _DEFAULTMODE	(-1)	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti) */

short _far _cdecl _setactivepage(short);
short _far _cdecl _setvisualpage(short);
short _far _cdecl _getactivepage(void);
short _far _cdecl _getvisualpage(void);

/* videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */

/* videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct videoconfig _far * _far _cdecl _getvideoconfig(struct videoconfig _far *);



/* COORDINATE SYSTEMS */

struct xycoord _far _cdecl _setvieworg(short, short);
#define _setlogorg _setvieworg		/* obsolescent */

struct xycoord _far _cdecl _getviewcoord(short, short);
#define _getlogcoord _getviewcoord	/* obsolescent */

struct xycoord _far _cdecl _getphyscoord(short, short);

void _far _cdecl _setcliprgn(short, short, short, short);
void _far _cdecl _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for _ellipse, _rectangle, _pie and _polygon */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

/* parameters for _clearscreen */
#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void _far _cdecl _clearscreen(short);

struct xycoord _far _cdecl _moveto(short, short);
struct xycoord _far _cdecl _getcurrentposition(void);

short _far _cdecl _lineto(short, short);
short _far _cdecl _rectangle(short, short, short, short, short);
short _far _cdecl _polygon(short, const struct xycoord _far *, short);
short _far _cdecl _arc(short, short, short, short, short, short, short, short);
short _far _cdecl _ellipse(short, short, short, short, short);
short _far _cdecl _pie(short, short, short, short, short, short, short, short, short);

short _far _cdecl _getarcinfo(struct xycoord _far *, struct xycoord _far *, struct xycoord _far *);

short _far _cdecl _setpixel(short, short);
short _far _cdecl _getpixel(short, short);
short _far _cdecl _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, WRITE MODE, FILL PATTERN */

short _far _cdecl _setcolor(short);
short _far _cdecl _getcolor(void);

void _far _cdecl _setlinestyle(unsigned short);
unsigned short _far _cdecl _getlinestyle(void);

short _far _cdecl _setwritemode(short);
short _far _cdecl _getwritemode(void);

void _far _cdecl _setfillmask(const unsigned char _far *);
unsigned char _far * _far _cdecl _getfillmask(unsigned char _far *);

/* COLOR SELECTION */

long _far _cdecl _setbkcolor(long);
long _far _cdecl _getbkcolor(void);

long _far _cdecl _remappalette(short, long);
short _far _cdecl _remapallpalette(const long _far *);
short _far _cdecl _selectpalette(short);


/* TEXT */
/* parameters for _displaycursor */
#define _GCURSOROFF	0
#define _GCURSORON	1

/* parameters for _wrapon */
#define _GWRAPOFF	0
#define _GWRAPON	1


/* direction parameters for _scrolltextwindow */
#define _GSCROLLUP	1
#define _GSCROLLDOWN	(-1)

/* request maximum number of rows in _settextrows and _setvideomoderows */
#define _MAXTEXTROWS	(-1)

short _far _cdecl _settextrows(short); /* returns # rows set; 0 if error */
void _far _cdecl _settextwindow(short, short, short, short);
void _far _cdecl _gettextwindow(short _far *, short _far *, short _far *, short _far *);
void _far _cdecl _scrolltextwindow(short);
void _far _cdecl _outmem(const unsigned char _far *, short);
void _far _cdecl _outtext(const unsigned char _far *);
short _far _cdecl _wrapon(short);

short _far _cdecl _displaycursor(short);
short _far _cdecl _settextcursor(short);
short _far _cdecl _gettextcursor(void);

struct rccoord _far _cdecl _settextposition(short, short);
struct rccoord _far _cdecl _gettextposition(void);

short _far _cdecl _settextcolor(short);
short _far _cdecl _gettextcolor(void);


/* SCREEN IMAGES */

void _far _cdecl _getimage(short, short, short, short, char _huge *);
void _far _cdecl _putimage(short, short, char _huge *, short);
long _far _cdecl _imagesize(short, short, short, short);

/* "action verbs" for _putimage() and _setwritemode() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4


/* Color values are used with _setbkcolor in graphics modes and also by
   _remappalette and _remapallpalette.  Also known as palette colors.
   Not to be confused with color indices (aka. color attributes).  */

/* universal color values (all color modes): */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _YELLOW		0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* the following is obsolescent and defined only for backward compatibility */
#define _LIGHTYELLOW	_YELLOW

/* mono mode F (_ERESNOCOLOR) color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 (_TEXTMONO) color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* Warning:  these '_xy' entrypoints are undocumented.
   They may or may not be supported in future versions. */
struct xycoord _far _cdecl _moveto_xy(struct xycoord);
short _far _cdecl _lineto_xy(struct xycoord);
short _far _cdecl _rectangle_xy(short,struct xycoord,struct xycoord);
short _far _cdecl _arc_xy(struct xycoord, struct xycoord, struct xycoord, struct xycoord);
short _far _cdecl _ellipse_xy(short, struct xycoord, struct xycoord);
short _far _cdecl _pie_xy(short, struct xycoord, struct xycoord, struct xycoord, struct xycoord);
short _far _cdecl _getpixel_xy(struct xycoord);
short _far _cdecl _setpixel_xy(struct xycoord);
short _far _cdecl _floodfill_xy(struct xycoord, short);
void _far _cdecl _getimage_xy(struct xycoord,struct xycoord, char _huge *);
long _far _cdecl _imagesize_xy(struct xycoord,struct xycoord);
void _far _cdecl _putimage_xy(struct xycoord, char _huge *, short);


/* WINDOW COORDINATE SYSTEM */

#ifndef _WXYCOORD_DEFINED
/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};
#define _WXYCOORD_DEFINED
#endif


/* define real coordinate window - returns non-zero if successful */
short _far _cdecl _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord _far _cdecl _getwindowcoord(short,short);
struct _wxycoord _far _cdecl _getwindowcoord_xy(struct xycoord);

/* convert from window to view coordinates */
struct xycoord _far _cdecl _getviewcoord_w(double,double);
struct xycoord _far _cdecl _getviewcoord_wxy(const struct _wxycoord _far *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord _far _cdecl _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _arc_w(double, double, double, double, double, double, double, double);
short _far _cdecl _arc_wxy(const struct _wxycoord _far *, const struct _wxycoord _far *, const struct _wxycoord _far *, const struct _wxycoord _far *);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _ellipse_w(short, double, double, double, double);
short _far _cdecl _ellipse_wxy(short, const struct _wxycoord _far *, const struct _wxycoord _far *);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _floodfill_w(double, double, short);

/*	returns pixel value at given point; -1 if unsuccessful. */
short _far _cdecl _getpixel_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _lineto_w(double, double);

/*	returns the view coordinates of the previous output
	position as an _xycoord structure. no error return */
struct _wxycoord _far _cdecl _moveto_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _pie_w(short, double, double, double, double, double, double, double, double);
short _far _cdecl _pie_wxy(short, const struct _wxycoord _far *, const struct _wxycoord _far *, const struct _wxycoord _far *, const struct _wxycoord _far *);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _rectangle_w(short, double, double, double, double);
short _far _cdecl _rectangle_wxy(short, const struct _wxycoord _far *, const struct _wxycoord _far *);

/*	returns nonzero if successful; otherwise 0	*/
short _far _cdecl _polygon_w(short, const double _far *, short);
short _far _cdecl _polygon_wxy(short, const struct _wxycoord _far *, short);

/*	returns previous color; -1 if unsuccessful */
short _far _cdecl _setpixel_w(double, double);


/* window coordinate image routines */

/*	no return value */
void _far _cdecl _getimage_w(double, double, double, double, char _huge *);
void _far _cdecl _getimage_wxy(const struct _wxycoord _far *, const struct _wxycoord _far *, char _huge *);

/*	returns the image's storage size in bytes */
long _far _cdecl _imagesize_w(double, double, double, double);
long _far _cdecl _imagesize_wxy(const struct _wxycoord _far *, const struct _wxycoord _far *);

/*	no return value */
void _far _cdecl _putimage_w(double, double ,char _huge * ,short);


/* FONTS */

#ifndef _FONTINFO_DEFINED
/* structure for _getfontinfo() */
struct _fontinfo {
	int	type;		/* b0 set = vector,clear = bit map	*/
	int	ascent;		/* pix dist from top to baseline	*/
	int	pixwidth;	/* character width in pixels, 0=prop	*/
	int	pixheight;	/* character height in pixels		*/
	int	avgwidth;	/* average character width in pixels	*/
	char	filename[81];	/* file name including path		*/
	char	facename[32];	/* font name				*/
};
#define _FONTINFO_DEFINED
#endif


/* font function prototypes */
short	_far _cdecl	_registerfonts( const unsigned char _far *);
void	_far _cdecl	_unregisterfonts( void );
short	_far _cdecl	_setfont( const unsigned char _far * );
short	_far _cdecl	_getfontinfo( struct _fontinfo _far * );
void	_far _cdecl	_outgtext( const unsigned char _far * );
short	_far _cdecl	_getgtextextent( const unsigned char _far * );
struct xycoord _far _cdecl _setgtextvector( short, short );
struct xycoord _far _cdecl _getgtextvector(void);

/* restore default packing */
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\math.h ===
/***
*math.h - definitions and declarations for math library
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains constant definitions and external subroutine
*	declarations for the math subroutine library.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/* definition of exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct exception {
	int type;		/* exception type - see below */
	char _FAR_ *name;	/* name of function where error occured */
	double arg1;		/* first argument to function */
	double arg2;		/* second argument (if any) to function */
	double retval;		/* value to be returned by function */
	} ;
#define _EXCEPTION_DEFINED
#endif


/* definition of a complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct complex {
	double x,y;	/* real and imaginary parts */
	} ;
#define _COMPLEX_DEFINED
#endif


/* Constant definitions for the exception type passed in the exception struct
 */

#define DOMAIN		1	/* argument domain error */
#define SING		2	/* argument singularity */
#define OVERFLOW	3	/* overflow range error */
#define UNDERFLOW	4	/* underflow range error */
#define TLOSS		5	/* total loss of precision */
#define PLOSS		6	/* partial loss of precision */

#define EDOM		33
#define ERANGE		34


/* definitions of HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */

#ifndef _DLL
extern double _near _cdecl HUGE;
#define HUGE_VAL HUGE

#else	/* _DLL */
extern double _FAR_ _cdecl HUGE;
#define HUGE_VAL HUGE

#endif	/* _DLL */


/* function prototypes */

#ifdef	_MT     /* function prototypes for _MT version */
int	_FAR_ _cdecl  abs(int);
double	_FAR_ _pascal acos(double);
double	_FAR_ _pascal asin(double);
double	_FAR_ _pascal atan(double);
double	_FAR_ _pascal atan2(double, double);
double	_FAR_ _pascal atof(const char _FAR_ *);
double	_FAR_ _pascal cabs(struct complex);
double	_FAR_ _pascal ceil(double);
double	_FAR_ _pascal cos(double);
double	_FAR_ _pascal cosh(double);
int	_FAR_ _cdecl  dieeetomsbin(double _FAR_ *, double _FAR_ *);
int	_FAR_ _cdecl  dmsbintoieee(double _FAR_ *, double _FAR_ *);
double	_FAR_ _pascal exp(double);
double	_FAR_ _pascal fabs(double);
int	_FAR_ _cdecl  fieeetomsbin(float _FAR_ *, float _FAR_ *);
double	_FAR_ _pascal floor(double);
double	_FAR_ _pascal fmod(double, double);
int	_FAR_ _cdecl  fmsbintoieee(float _FAR_ *, float _FAR_ *);
double	_FAR_ _pascal frexp(double, int _FAR_ *);
double	_FAR_ _pascal hypot(double, double);
double	_FAR_ _pascal j0(double);
double	_FAR_ _pascal j1(double);
double	_FAR_ _pascal jn(int, double);
long	_FAR_ _cdecl  labs(long);
double	_FAR_ _pascal ldexp(double, int);
double	_FAR_ _pascal log(double);
double	_FAR_ _pascal log10(double);
int	_FAR_ _cdecl  matherr(struct exception _FAR_ *);
double	_FAR_ _pascal modf(double, double _FAR_ *);
double	_FAR_ _pascal pow(double, double);
double	_FAR_ _pascal sin(double);
double	_FAR_ _pascal sinh(double);
double	_FAR_ _pascal sqrt(double);
double	_FAR_ _pascal tan(double);
double	_FAR_ _pascal tanh(double);
double	_FAR_ _pascal y0(double);
double	_FAR_ _pascal y1(double);
double	_FAR_ _pascal yn(int, double);

#else		/* function prototypes for non _MT version */
int	_FAR_ _cdecl abs(int);
double	_FAR_ _cdecl acos(double);
double	_FAR_ _cdecl asin(double);
double	_FAR_ _cdecl atan(double);
double	_FAR_ _cdecl atan2(double, double);
double	_FAR_ _cdecl atof(const char _FAR_ *);
double	_FAR_ _cdecl cabs(struct complex);
double	_FAR_ _cdecl ceil(double);
double	_FAR_ _cdecl cos(double);
double	_FAR_ _cdecl cosh(double);
int	_FAR_ _cdecl dieeetomsbin(double _FAR_ *, double _FAR_ *);
int	_FAR_ _cdecl dmsbintoieee(double _FAR_ *, double _FAR_ *);
double	_FAR_ _cdecl exp(double);
double	_FAR_ _cdecl fabs(double);
int	_FAR_ _cdecl fieeetomsbin(float _FAR_ *, float _FAR_ *);
double	_FAR_ _cdecl floor(double);
double	_FAR_ _cdecl fmod(double, double);
int	_FAR_ _cdecl fmsbintoieee(float _FAR_ *, float _FAR_ *);
double	_FAR_ _cdecl frexp(double, int _FAR_ *);
double	_FAR_ _cdecl hypot(double, double);
double	_FAR_ _cdecl j0(double);
double	_FAR_ _cdecl j1(double);
double	_FAR_ _cdecl jn(int, double);
long	_FAR_ _cdecl labs(long);
double	_FAR_ _cdecl ldexp(double, int);
double	_FAR_ _cdecl log(double);
double	_FAR_ _cdecl log10(double);
int	_FAR_ _cdecl matherr(struct exception _FAR_ *);
double	_FAR_ _cdecl modf(double, double _FAR_ *);
double	_FAR_ _cdecl pow(double, double);
double	_FAR_ _cdecl sin(double);
double	_FAR_ _cdecl sinh(double);
double	_FAR_ _cdecl sqrt(double);
double	_FAR_ _cdecl tan(double);
double	_FAR_ _cdecl tanh(double);
double	_FAR_ _cdecl y0(double);
double	_FAR_ _cdecl y1(double);
double	_FAR_ _cdecl yn(int, double);
#endif


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
struct _exceptionl {
	int type;		/* exception type - see below */
	char _FAR_ *name;	/* name of function where error occured */
	long double arg1;	/* first argument to function */
	long double arg2;	/* second argument (if any) to function */
	long double retval;	/* value to be returned by function */
	} ;
#define _LD_EXCEPTION_DEFINED
#endif


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
struct _complexl {
	long double x,y;    /* real and imaginary parts */
	} ;
#define _LD_COMPLEX_DEFINED
#endif


#ifndef _DLL
extern long double _near _cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE

#else	/* _DLL */
extern long double _FAR_ _cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE

#endif	/* _DLL */

long double  _FAR_ _cdecl acosl(long double);
long double  _FAR_ _cdecl asinl(long double);
long double  _FAR_ _cdecl atanl(long double);
long double  _FAR_ _cdecl atan2l(long double, long double);
long double  _FAR_ _cdecl _atold(const char _FAR_ *);
long double  _FAR_ _cdecl cabsl(struct _complexl);
long double  _FAR_ _cdecl ceill(long double);
long double  _FAR_ _cdecl cosl(long double);
long double  _FAR_ _cdecl coshl(long double);
long double  _FAR_ _cdecl expl(long double);
long double  _FAR_ _cdecl fabsl(long double);
long double  _FAR_ _cdecl floorl(long double);
long double  _FAR_ _cdecl fmodl(long double, long double);
long double  _FAR_ _cdecl frexpl(long double, int _FAR_ *);
long double  _FAR_ _cdecl hypotl(long double, long double);
long double  _FAR_ _cdecl _j0l(long double);
long double  _FAR_ _cdecl _j1l(long double);
long double  _FAR_ _cdecl _jnl(int, long double);
long double  _FAR_ _cdecl ldexpl(long double, int);
long double  _FAR_ _cdecl logl(long double);
long double  _FAR_ _cdecl log10l(long double);
int	     _FAR_ _cdecl _matherrl(struct _exceptionl _FAR_ *);
long double  _FAR_ _cdecl modfl(long double, long double _FAR_ *);
long double  _FAR_ _cdecl powl(long double, long double);
long double  _FAR_ _cdecl sinl(long double);
long double  _FAR_ _cdecl sinhl(long double);
long double  _FAR_ _cdecl sqrtl(long double);
long double  _FAR_ _cdecl tanl(long double);
long double  _FAR_ _cdecl tanhl(long double);
long double  _FAR_ _cdecl _y0l(long double);
long double  _FAR_ _cdecl _y1l(long double);
long double  _FAR_ _cdecl _ynl(int, long double);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Contains the function declarations for memory allocation functions;
*	also defines manifest constants and types used by the heap routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif


/* constants for based heap routines */

#if (_MSC_VER >= 600)
#define _NULLSEG	((_segment)0)
#define _NULLOFF	((void _based(void) *)0xffff)
#endif


/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY	(-1)
#define _HEAPOK 	(-2)
#define _HEAPBADBEGIN	(-3)
#define _HEAPBADNODE	(-4)
#define _HEAPEND	(-5)
#define _HEAPBADPTR	(-6)
#define _FREEENTRY	0
#define _USEDENTRY	1


/* maximum heap request that can ever be honored */

#define _HEAP_MAXREQ	0xFFE8


/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
	int _far * _pentry;
	size_t _size;
	int _useflag;
	} _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif


/* external variable declarations */

#ifdef _DLL
extern unsigned int _FAR_ _cdecl _amblksiz;
#else
extern unsigned int _near _cdecl _amblksiz;
#endif


/* based heap function prototypes */

#if (_MSC_VER >= 600)
void _based(void) * _FAR_ _cdecl _bcalloc(_segment, size_t, size_t);
void _based(void) * _FAR_ _cdecl _bexpand(_segment,
	void _based(void) *, size_t);
void _FAR_ _cdecl _bfree(_segment, void _based(void) *);
int _FAR_ _cdecl _bfreeseg(_segment);
int _FAR_ _cdecl _bheapadd(_segment, void _based(void) *, size_t);
int _FAR_ _cdecl _bheapchk(_segment);
int _FAR_ _cdecl _bheapmin(_segment);
_segment _FAR_ _cdecl _bheapseg(size_t);
int _FAR_ _cdecl _bheapset(_segment, unsigned int);
int _FAR_ _cdecl _bheapwalk(_segment, _HEAPINFO *);
void _based(void) * _FAR_ _cdecl _bmalloc(_segment, size_t);
size_t _FAR_ _cdecl _bmsize(_segment, void _based(void) *);
void _based(void) * _FAR_ _cdecl _brealloc(_segment,
	void _based(void) *, size_t);
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl alloca(size_t);
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
void _FAR_ * _FAR_ _cdecl _expand(void _FAR_ *, size_t);
void _far * _FAR_ _cdecl _fcalloc(size_t, size_t);
void _far * _FAR_ _cdecl _fexpand(void _far *, size_t);
void _FAR_ _cdecl _ffree(void _far *);
int _FAR_ _cdecl _fheapchk(void);
int _FAR_ _cdecl _fheapmin(void);
int _FAR_ _cdecl _fheapset(unsigned int);
int _FAR_ _cdecl _fheapwalk(_HEAPINFO _FAR_ *);
void _far * _FAR_ _cdecl _fmalloc(size_t);
size_t _FAR_ _cdecl _fmsize(void _far *);
void _far * _FAR_ _cdecl _frealloc(void _far *, size_t);
unsigned int _FAR_ _cdecl _freect(size_t);
void _FAR_ _cdecl free(void _FAR_ *);
void _huge * _FAR_ _cdecl halloc(long, size_t);
void _FAR_ _cdecl hfree(void _huge *);
int _FAR_ _cdecl _heapadd(void _far *, size_t);
int _FAR_ _cdecl _heapchk(void);
int _FAR_ _cdecl _heapmin(void);
int _FAR_ _cdecl _heapset(unsigned int);
int _FAR_ _cdecl _heapwalk(_HEAPINFO _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
size_t _FAR_ _cdecl _memavl(void);
size_t _FAR_ _cdecl _memmax(void);
size_t _FAR_ _cdecl _msize(void _FAR_ *);
void _near * _FAR_ _cdecl _ncalloc(size_t, size_t);
void _near * _FAR_ _cdecl _nexpand(void _near *, size_t);
void _FAR_ _cdecl _nfree(void _near *);
int _FAR_ _cdecl _nheapchk(void);
int _FAR_ _cdecl _nheapmin(void);
int _FAR_ _cdecl _nheapset(unsigned int);
int _FAR_ _cdecl _nheapwalk(_HEAPINFO _FAR_ *);
void _near * _FAR_ _cdecl _nmalloc(size_t);
size_t _FAR_ _cdecl _nmsize(void _near *);
void _near * _FAR_ _cdecl _nrealloc(void _near *, size_t);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
size_t _FAR_ _cdecl stackavail(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\mixed.inc ===
; High-Level-Language Interface Macros - Version 2.0
;   for Microsoft Macro Assembler 5.10
; (C) Copyright Microsoft Corporation, 1987.

;   Syntax                   Purpose
;   ------                   -------
;
;   setModel                 Sets model from text equate
;
;   hProc  <name [NEAR|FAR]> [,<USES reglist>] [,arg[:type] [,arg[:type]]]...
;                            Starts a procedure with optional stack arguments
;
;   hLocal var[:type] [,var[:type]]...
;                            Defines local stack variables
;
;   hRet                     Returns from the current procedure
;
;   hEndp                    Ends the current procedure
;
;   ifFP  statement          Assembles statement if far data
;
;   FPoperand                Conditionally provides ES override for data
;
;   pLes  register,address   Conditionally loads data through ES
;
;   pLds  register,address   Conditionally loads data through DS

;if1

; Translate command-line arguments


; Initialize procName

    procName equ <foo>

; Set model passed from command line

setModel macro mod

    ifdef cLang
      .model mod, C
      lang  EQU   <C>
    elseifdef BASIC
      .model mod, Basic
    elseifdef FORTRAN
      .model mod, FORTRAN
    elseifdef Pascal
      .model mod, Pascal
    endif

; FP - supply far pointer ES overide as needed - must be inside for setModel

    if @DataSize
      FP equ <es:>
    else
      FP equ <>
    endif

endm

; FP - supply far pointer ES overide as needed - must be outside for .MODEL

ifdef @DataSize
    if @DataSize
      FP equ <es:>
    else
      FP equ <>
    endif
endif

; Declare high level routine and parameters

hProc macro funName, a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr

    ii instr <funName>,< >
    if ii
      procName subStr <funName>,1,ii
      nearFar subStr <funName>,ii
    else
      procName equ <funName>
      nearFar equ <>
    endif

    argstr equ <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineProc %nearFar, %argstr
endm

defineProc Macro size,args
procName proc size args
endm

; Declare local stack variables

hLocal macro a,b,c,d,e,f,g,h,i,j
;    LOCAL argstr
    argstr EQU <a>
    irp arg,<b,c,d,e,f,g,h,i,j>
      ifnb <arg>
	argstr catstr argstr,<, arg>
      else
        exitm
      endif
    endm
defineLocal %argstr
endm

defineLocal macro args
    &local args
endm

; Generate high level return

hRet macro
    ret
endm

; End a high level procedure

hEndp macro
    procName endp
endm

; Execute instruction if far data

ifFP macro a,b,c,d,e,f,g,h,i,j

    if @DataSize
       a b c d e f g h i j
    endif
endm

; Load 16/32 bit pointers into [ES:] reg

pLes macro reg, address

    if @DataSize

        les reg,address
    else
        mov reg,address

    endif
endm

;Load 16/32 bit pointers into [DS:] reg

pLds macro reg, address

    if @DataSize

        lds reg,address
    else
        mov reg,address

    endif
endm

;endif ; Pass 1 only
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the machine-dependent buffer used by
*	setjmp/longjmp to save and restore the program state, and
*	declarations for those routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define the buffer type for holding the state information */

#define _JBLEN	9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* function prototypes */

int  _FAR_ _cdecl setjmp(jmp_buf);
void _FAR_ _cdecl longjmp(jmp_buf, int);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\pgchart.h ===
/***
*pgchart.h - Declare constants, functions and macros for charting library.
*
*  Copyright (c) 1988-1990, Microsoft Corporation, All rights reserved.
*
*Purpose:
*  This file declares the presentation graphics library functions and
*  the structures and manifest constants that are used with them.
*
***************************************************************************/

/* Force word alignment to avoid possible -Zp override */
#pragma	pack(2)

/* Required for the missing value definition */
#ifndef	FLT_MAX
#define FLT_MAX			3.402823466e+38F	/* max value */
#endif

#define _PG_PALETTELEN		16	/* Number of entries in internal palette */
#define _PG_MAXCHARTTYPE	5	/* Maximum available chart type */
#define _PG_MAXCHARTSTYLE	2	/* Maximum chart style */
#define _PG_TITLELEN		70	/* Maximum title text length */

#define _PG_LEFT		1	/* Positions used for titles and legends */
#define _PG_CENTER		2
#define _PG_RIGHT		3
#define _PG_BOTTOM		4
#define _PG_OVERLAY		5

#define _PG_LINEARAXIS		1	/* Used to specify axis types */
#define _PG_LOGAXIS		2

#define _PG_DECFORMAT		1	/* Used to specify tic mark label format */
#define _PG_EXPFORMAT		2

#define _PG_BARCHART		1	/* Charttype for a bar chart */
#define _PG_COLUMNCHART		2	/* Charttype for a column chart */
#define  _PG_PLAINBARS		1	/* Styles for bar and column charts */
#define  _PG_STACKEDBARS	2

#define _PG_LINECHART		3	/* Charttype for a line chart */
#define _PG_SCATTERCHART	4	/* Charttype for a scatter chart */
#define _PG_POINTANDLINE	1	/* Styles for line and scatter charts */
#define _PG_POINTONLY		2

#define _PG_PIECHART		5	/* Charttype for pie chart */
#define _PG_PERCENT		1	/* Styles for pie charts */
#define _PG_NOPERCENT		2

#define _PG_MISSINGVALUE	(-FLT_MAX)  /* Indicates missing data values */

/* Error codes	*/

/* Numbers greater than 100 will terminate chart routine, others will cause
 * default values to be used
 */
#define	_PG_NOTINITIALIZED	102	/* If library not initialized */
#define	_PG_BADSCREENMODE	103	/* Graphics mode not set before charting */
#define	_PG_BADCHARTSTYLE	04	/* Chart style invalid */
#define	_PG_BADCHARTTYPE	104	/* Chart type invalid */
#define	_PG_BADLEGENDWINDOW	105	/* Invalid legend window specified */
#define	_PG_BADCHARTWINDOW	07	/* x1=x2 or y1=y2 in chart window spec. */
#define	_PG_BADDATAWINDOW	107	/* If chart window is too small */
#define	_PG_NOMEMORY		108	/* Not enough memory for data arrays */
#define	_PG_BADLOGBASE		05	/* Log base <= 0 */
#define	_PG_BADSCALEFACTOR	06	/* Scale factor = 0 */
#define	_PG_TOOSMALLN		109	/* Number of data points <= 0 */
#define	_PG_TOOFEWSERIES	110	/* Number of series <= 0 */

/* Typedefs	*/

/* Typedef for chart title */
#ifndef _TITLETYPE_DEFINED
typedef	struct	{
	char	title[_PG_TITLELEN];	/* Title text */
	short	titlecolor;		/* Internal palette color for title text */
	short	justify;		/* _PG_LEFT, _PG_CENTER, _PG_RIGHT */
} titletype;
#define _TITLETYPE_DEFINED
#endif

/* Typedef for chart axes */
#ifndef _AXISTYPE_DEFINED
typedef	struct	{
	short		grid;		/* TRUE=grid lines drawn; FALSE no lines */
	short		gridstyle;	/* Style number from style pool for grid lines */
	titletype	axistitle;	/* Title definition for axis */
	short		axiscolor;	/* Color for axis */
	short		labeled;	/* TRUE=tic marks and titles drawn */
	short		rangetype;	/* _PG_LINEARAXIS, _PG_LOGAXIS */
	float		logbase;	/* Base used if log axis */
	short		autoscale;	/* TRUE=next 7 values calculated by system */
	float		scalemin;	/* Minimum value of scale */
	float		scalemax;	/* Maximum value of scale */
	float		scalefactor;	/* Scale factor for data on this axis */
	titletype	scaletitle;	/* Title definition for scaling factor */
	float		ticinterval;	/* Distance between tic marks (world coord.) */
	short		ticformat;	/* _PG_EXPFORMAT or _PG_DECFORMAT for tic labels */
	short		ticdecimals;	/* Number of decimals for tic labels (max=9)*/
} axistype;
#define _AXISTYPE_DEFINED
#endif

/* Typedef used for defining chart and data windows */
#ifndef _WINDOWTYPE_DEFINED
typedef	struct	{
	short		x1;		/* Left edge of window in pixels */
	short		y1;		/* Top edge of window in pixels */
	short		x2;		/* Right edge of window in pixels */
	short		y2;		/* Bottom edge of window in pixels */
	short		border;		/* TRUE for border, FALSE otherwise */
	short		background;	/* Internal palette color for window bgnd */
	short		borderstyle;	/* Style bytes for window border */
	short		bordercolor;	/* Internal palette color for window border */
} windowtype;
#define _WINDOWTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _LEGENDTYPE_DEFINED
typedef struct	{
	short		legend;		/* TRUE=draw legend; FALSE=no legend */
	short		place;		/* _PG_RIGHT, _PG_BOTTOM, _PG_OVERLAY */
	short		textcolor;	/* Internal palette color for text */
	short		autosize;	/* TRUE=system calculates size */
	windowtype	legendwindow;	/* Window definition for legend */
} legendtype;
#define _LEGENDTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _CHARTENV_DEFINED
typedef struct	{
	short		charttype;	/* _PG_BAR, _PG_COLUMN, _PG_LINE, _PG_SCATTER, _PG_PIE */
	short		chartstyle;	/* Style for selected chart type */
	windowtype	chartwindow;	/* Window definition for overall chart */
	windowtype	datawindow;	/* Window definition for data part of chart */
	titletype	maintitle;	/* Main chart title */
	titletype	subtitle;	/* Chart sub-title */
	axistype	xaxis;		/* Definition for X-axis */
	axistype	yaxis;		/* Definition for Y-axis */
	legendtype	legend;		/* Definition for legend */
} chartenv;
#define _CHARTENV_DEFINED
#endif

/* Typedef for character bitmap */
#ifndef _CHARMAP_DEFINED
typedef unsigned char charmap[8];
#define _CHARMAP_DEFINED
#endif

/* Typedef for pattern bitmap */
#ifndef _FILLMAP_DEFINED
typedef unsigned char fillmap[8];
#define _FILLMAP_DEFINED
#endif

/* Typedef for palette entry definition */
#ifndef _PALETTEENTRY_DEFINED
typedef struct {
	unsigned short	color;
	unsigned short	style;
	fillmap		fill;
	char		plotchar;
} paletteentry;
#define _PALETTEENTRY_DEFINED
#endif

/* Typedef for palette definition */
#ifndef _PALETTETYPE_DEFINED
typedef paletteentry palettetype[_PG_PALETTELEN];
#define _PALETTETYPE_DEFINED
#endif

/* Typedef for style sets */
#ifndef _STYLESET_DEFINED
typedef unsigned short styleset[_PG_PALETTELEN];
#define _STYLESET_DEFINED
#endif

/* Function prototypes for charting routines	*/

short _far _cdecl _pg_initchart(void);
short _far _cdecl _pg_defaultchart(chartenv _far *, short, short);

short _far _cdecl _pg_chart(chartenv _far *, const char _far * const _far *, const float _far *, short);
short _far _cdecl _pg_chartms(chartenv _far *, const char _far * const _far *, const float _far *, short, short, short, const char _far * const _far *);

short _far _cdecl _pg_chartscatter(chartenv _far *, const float _far *, const float _far *, short);
short _far _cdecl _pg_chartscatterms(chartenv _far *, const float _far *, const float _far *, short, short, short, const char _far * const _far *);

short _far _cdecl _pg_chartpie(chartenv _far *, const char _far * const _far *, const float _far *, const short _far *, short);

/* Function prototypes for support routines	*/

short _far _cdecl _pg_hlabelchart(chartenv _far *, short, short, short, const char _far *);
short _far _cdecl _pg_vlabelchart(chartenv _far *, short, short, short, const char _far *);

short _far _cdecl _pg_analyzechart(chartenv _far *, const char _far * const _far *, const float _far *, short);
short _far _cdecl _pg_analyzechartms(chartenv _far *, const char _far * const _far *, const float _far *, short, short, short, const char _far * const _far *);

short _far _cdecl _pg_analyzescatter(chartenv _far *, const float _far *, const float _far *, short);
short _far _cdecl _pg_analyzescatterms(chartenv _far *, const float _far *, const float _far *, short, short, short, const char _far * const _far *);

short _far _cdecl _pg_analyzepie(chartenv _far *, const char _far * const _far *, const float _far *, const short _far *, short);

short _far _cdecl _pg_getpalette(paletteentry _far *);
short _far _cdecl _pg_setpalette(const paletteentry _far *);
short _far _cdecl _pg_resetpalette(void);

void  _far _cdecl _pg_getstyleset(unsigned short _far *);
void  _far _cdecl _pg_setstyleset(const unsigned short _far *);
void  _far _cdecl _pg_resetstyleset(void);

short _far _cdecl _pg_getchardef(short, unsigned char _far *);
short _far _cdecl _pg_setchardef(short, const unsigned char _far *);

/* Restore default packing */
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for the
*	buffer (memory) manipulation routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);


/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;
                                                                /* ;Internal */
typedef struct _dropfilestruct {				/* ;Internal */
    WORD pFiles;                        /* offset of file list*//* ;Internal */
    POINT pt;                           /* drop point         *//* ;Internal */
    BOOL fNC;                           /* is it on NC area   *//* ;Internal */
} DROPFILESTRUCT, FAR* LPDROPFILESTRUCT;                        /* ;Internal */

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 
int   WINAPI ShellAbout(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);                   /* ;Internal */
HICON WINAPI ExtractAssociatedIcon(HANDLE hInst, LPSTR lpIconPath, WORD FAR* lpiIcon);                /* ;Internal */
HICON WINAPI InternalExtractIcon(HANDLE hInst, LPCSTR lpszExeFileName, WORD nIconIndex, WORD nIcons); /* ;Internal */
DWORD WINAPI DoEnvironmentSubst(LPSTR szString, WORD cbString);                                       /* ;Internal */
BOOL  WINAPI RegisterShellHook(HWND, BOOL);                                                           /* ;Internal */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the file sharing modes for sopen().
*
****/

#define SH_COMPAT	0x00	/* compatibility mode */
#define SH_DENYRW	0x10	/* deny read/write mode */
#define SH_DENYWR	0x20	/* deny write mode */
#define SH_DENYRD	0x30	/* deny read mode */
#define SH_DENYNO	0x40	/* deny none mode */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the declarations for the sorting and
*	searching routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* function prototypes */

void _FAR_ * _FAR_ _cdecl lsearch(const void _FAR_ *, void _FAR_ *,
	unsigned int _FAR_ *, unsigned int, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl lfind(const void _FAR_ *, const void _FAR_ *,
	unsigned int _FAR_ *, unsigned int, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines ANSI-style macros for accessing arguments
*	of functions which take a variable number of arguments.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_start(ap,v) ap = (va_list)&v + sizeof(v)
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\signal.h ===
/***
*signal.h - defines signal values and routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the signal values and declares the signal functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif


#define NSIG 23     /* maximum signal number + 1 */

/* signal types */
/* SIGINT, SIGFPE, SIGILL, SIGSEGV, and SIGABRT are recognized on DOS 3.x */

#define SIGINT		2	/* interrupt - corresponds to DOS 3.x int 23H */
#define SIGILL		4	/* illegal instruction - invalid function image */
#define SIGFPE		8	/* floating point exception */
#define SIGSEGV 	11	/* segment violation */
#define SIGTERM 	15	/* Software termination signal from kill */
#define SIGUSR1 	16	/* User defined signal 1 */
#define SIGUSR2 	17	/* User defined signal 2 */
#define SIGUSR3 	20	/* User defined signal 3 */
#define SIGBREAK	21	/* Ctrl-Break sequence */
#define SIGABRT 	22	/* abnormal termination triggered by abort call */


/* signal action codes */
/* SIG_DFL and SIG_IGN are recognized on DOS 3.x */

#define SIG_DFL (void (_FAR_ _cdecl _LOADDS_ *)())0	 /* default signal action */
#define SIG_IGN (void (_FAR_ _cdecl _LOADDS_ *)())1	 /* ignore */
#define SIG_SGE (void (_FAR_ _cdecl _LOADDS_ *)())3	 /* signal gets error */
#define SIG_ACK (void (_FAR_ _cdecl _LOADDS_ *)())4	 /* error if handler not setup */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (_FAR_ _cdecl _LOADDS_ *)())-1	 /* signal error value */


/* function prototypes */

void (_FAR_ _cdecl _LOADDS_ * _FAR_ _cdecl signal(int,
	void (_FAR_ _cdecl _LOADDS_ *)()))();
#ifndef _MT
int _FAR_ _cdecl raise(int);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains definitions and declarations for some commonly
*	used constants, types, and variables.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define the NULL pointer value and the offsetof() macro */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#define offsetof(s,m)	(size_t)&(((s *)0)->m)


/* declare reference to errno */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
#define errno	(*_errno())
#else
extern int _near _cdecl volatile errno;
#endif


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifdef _MT
/* define pointer to thread id value */

extern int _far *_threadid;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the declarations and definitions for the
*	spawnxx, execxx, and various other process control routines.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int _near _cdecl _p_overlay;
#endif

#define P_WAIT		0
#define P_NOWAIT	1
#ifdef _MT
#define P_OVERLAY	2
#else
#define P_OVERLAY	_p_overlay
#endif
#define OLD_P_OVERLAY	2
#define P_NOWAITO	3
#define P_DETACH	4


/* action codes used with cwait() */

#define WAIT_CHILD 0
#define WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef _MT
int _FAR_ _cdecl _beginthread(void(_cdecl _FAR_ *)(void _FAR_ *),
	void _FAR_ *, unsigned, void _FAR_ *);
void _FAR_ _cdecl _endthread(void);
#endif
void _FAR_ _cdecl abort(void);
void _FAR_ _cdecl _cexit(void);
void _FAR_ _cdecl _c_exit(void);
int _FAR_ _cdecl cwait(int _FAR_ *, int, int);
int _FAR_ _cdecl execl(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execle(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlp(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execlpe(const char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl execv(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execve(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvp(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl execvpe(const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
int _FAR_ _cdecl getpid(void);
int _FAR_ _cdecl spawnl(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnle(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlp(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnlpe(int, const char _FAR_ *, const char _FAR_ *,
	...);
int _FAR_ _cdecl spawnv(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnve(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvp(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl spawnvpe(int, const char _FAR_ *,
	const char _FAR_ * const _FAR_ *, const char _FAR_ * const _FAR_ *);
int _FAR_ _cdecl system(const char _FAR_ *);
int _FAR_ _cdecl wait(int _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the various declarations and definitions
*	for the time routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
	int tm_sec;	/* seconds after the minute - [0,59] */
	int tm_min;	/* minutes after the hour - [0,59] */
	int tm_hour;	/* hours since midnight - [0,23] */
	int tm_mday;	/* day of the month - [1,31] */
	int tm_mon;	/* months since January - [0,11] */
	int tm_year;	/* years since 1900 */
	int tm_wday;	/* days since Sunday - [0,6] */
	int tm_yday;	/* days since January 1 - [0,365] */
	int tm_isdst;	/* daylight savings time flag */
	};
#define _TM_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC	1000

/* clock ticks macro - archaic version */

#define CLK_TCK 	1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

#ifdef _DLL
extern int _FAR_ _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _FAR_ _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char _FAR_ * _FAR_ _cdecl tzname[2]; /* standard/daylight savings time zone names */
#else
extern int _near _cdecl daylight;     /* non-zero if daylight savings time is used */
extern long _near _cdecl timezone;    /* difference in seconds between GMT and local time */
extern char * _near _cdecl tzname[2]; /* standard/daylight savings time zone names */
#endif


/* function prototypes */

#ifdef _MT
double _FAR_ _pascal difftime(time_t, time_t);
#else
double _FAR_ _cdecl difftime(time_t, time_t);
#endif

char _FAR_ * _FAR_ _cdecl asctime(const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl ctime(const time_t _FAR_ *);
clock_t _FAR_ _cdecl clock(void);
struct tm _FAR_ * _FAR_ _cdecl gmtime(const time_t _FAR_ *);
struct tm _FAR_ * _FAR_ _cdecl localtime(const time_t _FAR_ *);
time_t _FAR_ _cdecl mktime(struct tm _FAR_ *);
size_t _FAR_ _cdecl strftime(char _FAR_ *, size_t, const char _FAR_ *,
	const struct tm _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strdate(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strtime(char _FAR_ *);
time_t _FAR_ _cdecl time(time_t _FAR_ *);
void _FAR_ _cdecl tzset(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\version.h ===
#define OFFICIAL   1 
#define FINAL      1 
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *									    *
 *	This file is only modified by the official builder to update the    *
 *	VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h> 
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION 		    "3.1"
#define VER_PRODUCTVERSION_STR      "3.10\0"
#define VER_PRODUCTVERSION          3,10,0,103

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structures, values, macros, and functions
*	used by the level 2 I/O ("standard I/O") routines.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

/* buffered I/O macros */

#define BUFSIZ	512
#ifdef _MT
#define _NFILE	40
#else
#define _NFILE	20
#endif
#define EOF	(-1)

#ifndef _FILE_DEFINED
struct _iobuf {
	char _FAR_ *_ptr;
	int   _cnt;
	char _FAR_ *_base;
	char  _flag;
	char  _file;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of P_tmpdir
 *	+ 1 (in case P_tmpdir does not end in "\\")
 *	+ 6 (for the temp number string)
 *	+ 1 (for the null terminator)
 */

#define  P_tmpdir "\\"
#define  L_tmpnam sizeof(P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 63
#define FOPEN_MAX 20
#define SYS_OPEN 20
#define TMP_MAX 32767


/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
#ifdef _DLL
extern FILE _FAR_ _cdecl _iob[];
#else
extern FILE _near _cdecl _iob[];
#endif
#endif


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif


/* standard file pointers */

#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#define stdaux (&_iob[3])
#define stdprn (&_iob[4])


#define _IOREAD 	0x01
#define _IOWRT		0x02

#define _IOFBF		0x0
#define _IOLBF		0x40
#define _IONBF		0x04

#define _IOMYBUF	0x08
#define _IOEOF		0x10
#define _IOERR		0x20
#define _IOSTRG 	0x40
#define _IORW		0x80


/* function prototypes */

#ifndef _STDIO_DEFINED
int _FAR_ _cdecl _filbuf(FILE _FAR_ *);
int _FAR_ _cdecl _flsbuf(int, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _fsopen(const char _FAR_ *,
	const char _FAR_ *, int);
void _FAR_ _cdecl clearerr(FILE _FAR_ *);
int _FAR_ _cdecl fclose(FILE _FAR_ *);
int _FAR_ _cdecl fcloseall(void);
FILE _FAR_ * _FAR_ _cdecl fdopen(int, const char _FAR_ *);
int _FAR_ _cdecl feof(FILE _FAR_ *);
int _FAR_ _cdecl ferror(FILE _FAR_ *);
int _FAR_ _cdecl fflush(FILE _FAR_ *);
int _FAR_ _cdecl fgetc(FILE _FAR_ *);
int _FAR_ _cdecl fgetchar(void);
int _FAR_ _cdecl fgetpos(FILE _FAR_ *, fpos_t _FAR_ *);
char _FAR_ * _FAR_ _cdecl fgets(char _FAR_ *, int, FILE _FAR_ *);
int _FAR_ _cdecl fileno(FILE _FAR_ *);
int _FAR_ _cdecl flushall(void);
FILE _FAR_ * _FAR_ _cdecl fopen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl fprintf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fputc(int, FILE _FAR_ *);
int _FAR_ _cdecl fputchar(int);
int _FAR_ _cdecl fputs(const char _FAR_ *, FILE _FAR_ *);
size_t _FAR_ _cdecl fread(void _FAR_ *, size_t, size_t, FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl freopen(const char _FAR_ *,
	const char _FAR_ *, FILE _FAR_ *);
int _FAR_ _cdecl fscanf(FILE _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl fsetpos(FILE _FAR_ *, const fpos_t _FAR_ *);
int _FAR_ _cdecl fseek(FILE _FAR_ *, long, int);
long _FAR_ _cdecl ftell(FILE _FAR_ *);
size_t _FAR_ _cdecl fwrite(const void _FAR_ *, size_t, size_t,
	FILE _FAR_ *);
int _FAR_ _cdecl getc(FILE _FAR_ *);
int _FAR_ _cdecl getchar(void);
char _FAR_ * _FAR_ _cdecl gets(char _FAR_ *);
int _FAR_ _cdecl getw(FILE _FAR_ *);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl _pclose(FILE _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl _popen(const char _FAR_ *,
	const char _FAR_ *);
int _FAR_ _cdecl printf(const char _FAR_ *, ...);
int _FAR_ _cdecl putc(int, FILE _FAR_ *);
int _FAR_ _cdecl putchar(int);
int _FAR_ _cdecl puts(const char _FAR_ *);
int _FAR_ _cdecl putw(int, FILE _FAR_ *);
int _FAR_ _cdecl remove(const char _FAR_ *);
int _FAR_ _cdecl rename(const char _FAR_ *, const char _FAR_ *);
void _FAR_ _cdecl rewind(FILE _FAR_ *);
int _FAR_ _cdecl rmtmp(void);
int _FAR_ _cdecl scanf(const char _FAR_ *, ...);
void _FAR_ _cdecl setbuf(FILE _FAR_ *, char _FAR_ *);
int _FAR_ _cdecl setvbuf(FILE _FAR_ *, char _FAR_ *, int, size_t);
int _FAR_ _cdecl sprintf(char _FAR_ *, const char _FAR_ *, ...);
int _FAR_ _cdecl sscanf(const char _FAR_ *, const char _FAR_ *, ...);
char _FAR_ * _FAR_ _cdecl tempnam(char _FAR_ *, char _FAR_ *);
FILE _FAR_ * _FAR_ _cdecl tmpfile(void);
char _FAR_ * _FAR_ _cdecl tmpnam(char _FAR_ *);
int _FAR_ _cdecl ungetc(int, FILE _FAR_ *);
int _FAR_ _cdecl unlink(const char _FAR_ *);
int _FAR_ _cdecl vfprintf(FILE _FAR_ *, const char _FAR_ *, va_list);
int _FAR_ _cdecl vprintf(const char _FAR_ *, va_list);
int _FAR_ _cdecl vsprintf(char _FAR_ *, const char _FAR_ *, va_list);
#define _STDIO_DEFINED
#endif

/* macro definitions */

#define feof(_stream)	  ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define fileno(_stream)   ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)	  (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
	: _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
	? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()	  getc(stdin)
#define putchar(_c)	  putc((_c),stdout)

#ifdef _MT
#undef	getc
#undef	putc
#undef	getchar
#undef	putchar
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
void _FAR_ _cdecl perror(const char _FAR_ *);
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
int _FAR_ _cdecl system(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines XENIX style macros for accessing arguments of a
*	function which takes a variable number of arguments.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

#ifndef _VA_LIST_DEFINED
typedef char _FAR_ *va_list;
#define _VA_LIST_DEFINED
#endif

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ((t _FAR_ *)(ap += sizeof(t)))[-1]
#define va_end(ap) ap = NULL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#define NOCOMM                      /* ;Internal */
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 _far
#define NEAR		    _near
#define PASCAL		    _pascal
#define CDECL		    _cdecl
#define CONST               const                   /* ;Internal */

#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI              _loadds _far _pascal    /* ;Internal */
#define CALLBACK            _loadds _far _pascal    /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API                 WINAPI                  /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;

#define SZ char                         /* ;Internal */

typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

/* Internal error value masks */	    /* ;Internal */
#define ERR_TYPE_MASK		0x0fff	    /* ;Internal */
#define ERR_FLAGS_MASK		0xc000	    /* ;Internal */
					    /* ;Internal */
#define ERR_SIZE_MASK		0x3000
#define ERR_SIZE_SHIFT          12          /* ;Internal */
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000
					    /* ;Internal */
/* Error option flags (set by [kernel] ErrorOptions win.ini variable) *//* ;Internal */
					    /* ;Internal */
#define ERO_PARAM_ERROR_BREAK	0x0001	    /* ;Internal */
#define ERO_BUFFER_FILL 	0x0002	    /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43
#define EW_EXITANDEXECAPP 0x44   /* ;Internal */

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);                 /* ;Internal */

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);                /* ;Internal */
              			                        /* ;Internal */
/* GetAppCompatFlags flag values */			/* ;Internal */
#define GACF_IGNORENODISCARD	0x0001			/* ;Internal */
#define GACF_FORCETEXTBAND	0x0002			/* ;Internal */
#define GACF_ONELANDGRXBAND	0x0004			/* ;Internal */
#define GACF_IGNORETOPMOST      0x0008                  /* ;Internal */
#define GACF_CALLTTDEVICE       0x0010                  /* ;Internal */
#define GACF_MULTIPLEBANDS	0x0020			/* ;Internal */
#define GACF_ALWAYSSENDNCPAINT  0x0040                  /* ;Internal */
#define GACF_EDITSETTEXTMUNGE   0x0080                  /* ;Internal */
#define GACF_MOREEXTRAWNDWORDS  0x0100                  /* ;Internal */
#define GACF_TTIGNORERASTERDUPE 0x0200			/* ;Internal */
#define GACF_HACKWINFLAGS	0x0400			/* ;Internal */
#define GACF_DELAYHWHNDSHAKECHK 0x0800			/* ;Internal */
#define GACF_ENUMHELVNTMSRMN	0x1000			/* ;Internal */
#define GACF_ENUMTTNOTDEVICE	0x2000			/* ;Internal */
#define GACF_SUBTRACTCLIPSIBS   0x4000                  /* ;Internal */
#define GACF_FORCETTGRAPHICS	0x8000			/* ;Internal */
#define GACF_NOHRGN1            0x00010000              /* ;Internal */
#define GACF_NCCALCSIZEONMOVE   0x00020000              /* ;Internal */
#define GACF_SENDMENUDBLCLK     0x00040000              /* ;Internal */
#define GACF_30AVGWIDTH 	0x00080000		/* ;Internal */

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                    /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)	/* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)	/* ;Internal */

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

/* LocalNotify callback */					    /* ;Internal */
#ifdef STRICT							    /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*);   /* ;Internal */
#else								    /* ;Internal */
typedef FARPROC LNOTIFYPROC;					    /* ;Internal */
#endif								    /* ;Internal */
								    /* ;Internal */
#define LNOTIFY_OUTOFMEM    0					    /* ;Internal */
#define LNOTIFY_MOVE	    1					    /* ;Internal */
#define LNOTIFY_DISCARD     2					    /* ;Internal */
								    /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                        /* ;Internal */
								    /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);   /* ;Internal */

#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

/* If any new types are added above this point, */  /* ;Internal */
/* DIFFERENCE must be changed.	The GROUP_*	*/  /* ;Internal */
/* values minus the non-GROUP values must be	*/  /* ;Internal */
/* equal to DIFFERENCE				*/  /* ;Internal */
#define DIFFERENCE	    11			    /* ;Internal */
#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */    /* ;Internal */
#define ORD_LANGDRIVER	  1		     /* ;Internal */

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR	0x8000				/* ;Internal */
							/* ;Internal */
/* Internal SelectBitmap stuff */			/* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/     /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#define COLOR_MAX		  20		/* ;Internal */
#else  /* WINVER >= 0x030a */                   /* ;Internal */
#define COLOR_MAX		  18		/* ;Internal */
#endif  /* WINVER >= 0x030a */
#define COLOR_ENDCOLORS 	  COLOR_MAX	/* ;Internal */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311
#define WM_PALETTEGONNACHANGE	WM_PALETTEISCHANGING	/* ;Internal */
#define WM_CHANGEPALETTE	WM_PALETTECHANGED	/* ;Internal */

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);

#if (WINVER >= 0x030a)                                  /* ;Internal */
/* DC hook callback function */				/* ;Internal */
							/* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
							/* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);   /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);          /* ;Internal */
							/* ;Internal */
/* Callback reason code values */			/* ;Internal */
							/* ;Internal */
#define DCHC_INVALIDVISRGN 0x0001			/* ;Internal */
#define DCHC_DELETEDC	   0x0002			/* ;Internal */
							/* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);          /* ;Internal */
							/* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001			/* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002			/* ;Internal */
#endif  /* WINVER >= 0x030a */                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);

BOOL    WINAPI FastWindowFrame(HDC, const RECT FAR*, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000
#define DT_VALID	    0x1fff  /* ;Internal: Union of all those above */

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);	 /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */ 			    /* ;Internal */
typedef struct tagPELARRAY		    /* ;Internal */
{					    /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;			    /* ;Internal */
} PELARRAY;				    /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                       /* ;Internal */
typedef struct tagWND NEAR* HWND;   /* ;Internal */
#else                               /* ;Internal */
DECLARE_HANDLE(HWND);
#endif                              /* ;Internal */

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_MAX		     42 	/* ;Internal */
#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E
#define WM_FILESYSCHANGE    0x0034		/* ;Internal */

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_TIMEOUTS		    7   /* ;Internal */
#define SPI_KANJIMENU		    8	/* ;Internal */
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_MAX 		    36	 /* ;Internal */

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002
#define SPIF_VALID		    0x0003  /* ;Internal */

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002
#define PM_VALID	0x0003	     /* ;Internal */

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#define QS_VALID	0x007f	    /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MESSAGEBOX 	 1	    /* ;Internal */
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7	    /* ;Internal */
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F

/* Reserved message ranges */			/* ;Internal */
#define WM_KANJIFIRST	    0x0280  /* JAPAN */ /* ;Internal */
#define WM_KANJILAST	    0x029F  /* JAPAN */ /* ;Internal */
#define WM_HANGEULFIRST     0x0280  /* KOREA */ /* ;Internal */
#define WM_HANGEULLAST	    0x029F  /* KOREA */ /* ;Internal */
						/* ;Internal */
						/* ;Internal */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      /* ;Internal */
						/* ;Internal */
						/* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for multi-media                       */     /* ;Internal */
#define WM_MM_RESERVED_FIRST 0x03A0             /* ;Internal */
#define WM_MM_RESERVED_LAST  0x03DF             /* ;Internal */
#define WM_INTERNAL_COALESCE_LAST  0x03b0	/* ;Internal */
						/* ;Internal */
#define WM_INTERNAL_DDE_FIRST 0x03E0            /* ;Internal */
#define WM_INTERNAL_DDE_LAST  0x03EF            /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for CBT                               */     /* ;Internal */
#define WM_CBT_RESERVED_FIRST 0x03F0            /* ;Internal */
#define WM_CBT_RESERVED_LAST  0x03FF            /* ;Internal */

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#define CS_VALID	    0x7fef  /* ;Internal */
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_DRAGOBJECT     0x00000002L		/* ;Internal */
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#define WS_EX_VALID	     0x0000003fL    /* ;Internal */
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW

#define WS_VALID	    0xffff0000L     /* ;Internal */

#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#define WM_SETVISIBLE	    0x0009		/* ;Internal */

#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9
#define SW_MAX		    9	/* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */  /* ;Internal */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */  /* ;Internal */
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_DEFERDRAWING    SWP_DEFERERASE /* Don't do any drawing or erasing */ /* ;Internal */
								      /* ;Internal */
#define SWP_CHANGEMASK	    (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
			    SWP_FRAMECHANGED |			      /* ;Internal */ \
			    SWP_SHOWWINDOW | SWP_HIDEWINDOW |	      /* ;Internal */ \
			    SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
								      /* ;Internal */
#define SWP_NOCHANGE	    (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
			    SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
#define SWP_VALID	    0x27ff  /* ;Internal */

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST        /* ;Internal */

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZEWAIT         0x0004      /* ;Internal */
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024

#define WM_ENTERSIZEMOVE    0x0231		/* ;Internal */
#define WM_EXITSIZEMOVE     0x0232		/* ;Internal */
#define WM_ISACTIVEICON     0x0035		/* ;Internal */
#define WM_UNUSED0036       0x0036		/* ;Internal */
#define WM_TESTING	    0x0040		/* ;Internal */

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5
#define GW_MAX		5	/* ;Internal */

HWND    WINAPI GetNextQueueWindow(HWND, int); /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_NORESETATTRS    0x00000004L /* ;Internal */
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L

#define DCX_EXCLUDEUPDATE   0x00000100L /* ;Internal */
#define DCX_INTERSECTUPDATE 0x00000200L /* ;Internal */

#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_INVALID	    0x00000800L /* ;Internal */
#define DCX_INUSE	    0x00001000L /* ;Internal */
#define DCX_SAVEDRGNINVALID 0x00002000L /* ;Internal */

#define DCX_USESTYLE	    0x00010000L
#define DCX_NEEDFONT	    0x00020000L /* ;Internal */
#define DCX_NODELETERGN     0x00040000L /* ;Internal */
#define DCX_NOCLIPCHILDREN  0x00080000L /* ;Internal */
#define DCX_NORECOMPUTE     0x00100000L /* ;Internal */
#define DCX_VALIDATE        0x00200000L /* ;Internal */

#define DCX_MATCHMASK		(DCX_WINDOW | DCX_CACHE |		  /* ;Internal */ \
				 DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS |	  /* ;Internal */ \
                                 DCX_LOCKWINDOWUPDATE                     /* ;Internal */ \
				)					  /* ;Internal */
#define DCX_VALID           0x000104fbL /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_PAINTICON	    0x0026		/* ;Internal */
#define WM_ICONERASEBKGND   0x0027
#define WM_SYNCPAINT	    0x0088		/* ;Internal */
#define WM_SYNCTASK         0x0089	        /* ;Internal */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800
									/* ;Internal */
#define RDW_REDRAWWINDOW	0x1000	/* Called from RedrawWindow()*/ /* ;Internal */
#define RDW_SUBTRACTSELF	0x2000	/* Subtract self from hrgn   */	/* ;Internal */
									/* ;Internal */
#define RDW_COPYRGN		0x4000	/* Copy the passed-in region */	/* ;Internal */
#define RDW_VALID               0x0fff                                  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004

#define SW_SCROLLWINDOW     0x8000  /* ;Internal */
#define SW_VALID	    0x8007  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400

#define WVR_MINVALID	    WVR_ALIGNTOP	/* ;Internal */
#define WVR_MAXVALID	    WVR_VALIDRECTS	/* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON
#define HTSIZEFIRST	    HTLEFT		/* ;Internal */
#define HTSIZELAST	    HTBOTTOMRIGHT	/* ;Internal */

/****** Drag-and-drop support ***********************************************/

#define WM_DROPOBJECT	    0x022A		/* ;Internal */
#define WM_QUERYDROPOBJECT  0x022B		/* ;Internal */
#define WM_BEGINDRAG	    0x022C		/* ;Internal */
#define WM_DRAGLOOP	    0x022D		/* ;Internal */
#define WM_DRAGSELECT	    0x022E		/* ;Internal */
#define WM_DRAGMOVE	    0x022F		/* ;Internal */
#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107

#define WM_YOMICHAR	    0x0108  /* JAPAN */ /* ;Internal */
#define WM_CONVERTREQUEST   0x010A  /* JAPAN */ /* ;Internal */
#define WM_CONVERTRESULT    0x010B  /* JAPAN */ /* ;Internal */
#define WM_INTERIM	    0x010C  /* KOREA */ /* ;Internal */

/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_KANA 	    0x15    /* JAPAN */ /* ;Internal */
#define VK_KANJI	    0x19    /* JAPAN */ /* ;Internal */
#define VK_HANGEUL	    0x15    /* KOREA */ /* ;Internal */
#define VK_JUNJA	    0x17    /* KOREA */ /* ;Internal */
#define VK_HANJA	    0x19    /* KOREA */ /* ;Internal */
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */

BOOL WINAPI IsTwoByteCharPrefix(char);      /* ;Internal */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113
#define WM_SYSTIMER	    0x0118		/* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000

#define MF_VALID	    0x4fff  /* ;Internal */
#define MF_CHANGE_VALID     0x5fff  /* ;Internal */

#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#define TPM_VALID	0x000f	/* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120
#define WM_ENTERMENULOOP    0x0211		/* ;Internal */
#define WM_EXITMENULOOP     0x0212		/* ;Internal */
#define WM_NEXTMENU         0x0213		/* ;Internal */

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8
#define SB_MSGCMD_MAX	    8	    /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3
#define SB_MAX		    3	    /* ;Internal */

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#define ESB_MAX             0x0003              /* ;Internal */
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH    /* ;Internal */
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000

#define MB_TYPEMASK	    0x000F	/* ;Internal */
#define MB_ICONMASK	    0x00F0	/* ;Internal */
#define MB_DEFMASK	    0x0F00	/* ;Internal */
#define MB_MODEMASK	    0x3000	/* ;Internal */
#define MB_MISCMASK	    0xC000	/* ;Internal */
#define MB_VALID	    0xb377	/* ;Internal */


#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE

/* SC_HOTKEY support messages */ /* ;Internal */
#define WM_SETHOTKEY	0x0032   /* ;Internal */
#define WM_GETHOTKEY	0x0033   /* ;Internal */

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028
#define WM_ALTTABACTIVE     0x0029		/* ;Internal */

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6
#define CTLCOLOR_MAX        8       /* ;Internal */

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_USERITEM	    0x0000000AL    /* ;Internal */
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#define STM_MSGMAX          (WM_USER+2)    /* ;Internal */
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX	    0x0000000AL  /* ;Internal */
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_SCROLL	        (WM_USER+5)     /* ;Internal */
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_GETTHUMB	        (WM_USER+14)    /* ;Internal */
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_MSGMAX	        (WM_USER+35)	/* ;Internal */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_ADDFILE	       (WM_USER+23)	/* ;Internal */
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETANCHORINDEX      (WM_USER+29)	/* ;Internal */
#define LB_GETANCHORINDEX      (WM_USER+30)	/* ;Internal */
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */
#define LBCB_CARETON           (WM_USER+36)     /* ;Internal */
#define LBCB_CARETOFF          (WM_USER+37)     /* ;Internal */
#define LB_MSGMAX	       (WM_USER+38)	/* ;Internal */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_LBTRACKPOINT     0x0131		/* ;Internal */

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

#define LBD_UPPERCASE   0x8001     /* ;Internal */
#define LBD_SIZE        0x8002     /* ;Internal */
#define LBD_DATE        0x8004     /* ;Internal */
#define LBD_TIME        0x8008     /* ;Internal */
#define LBD_ATTRIBUTE   0x8010     /* ;Internal */
#define LBD_FULLDETAILS 0x801E     /* ;Internal */
#define LBD_SENDDETAILS 0x8020     /* ;Internal */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000
#define DDL_VALID	    0xe03f	/* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX		 (WM_USER+25)	    /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

#define WH_MIN		    (-1)			    /* ;Internal */
#define WH_MAX		    10				    /* ;Internal */
#define WH_MINHOOK	    WH_MIN			    /* ;Internal */
#define WH_MAXHOOK	    WH_MAX			    /* ;Internal */
#define WH_CHOOKS	    (WH_MAXHOOK - WH_MINHOOK + 1)   /* ;Internal */

/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe
#define EV_VALID	    0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002
#define GND_VALID		0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef NOWINDOWSX          /* ;Internal */
#ifndef RC_INVOKED          /* ;Internal */
#include "windowsx.h"       /* ;Internal */
#ifndef STRICT              /* ;Internal */
#undef  SelectFont          /* ;Internal */
#endif  /* STRICT */        /* ;Internal */
#endif  /* RC_INVOKED */    /* ;Internal */
#endif  /* NOWINDOWSX */    /* ;Internal */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\sys\locking.h ===
/***
*sys\locking.h - flags for locking() function
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the flags for the locking() function.
*	[System V]
*
****/

#define LK_UNLCK	0	/* unlock the file region */
#define LK_LOCK 	1	/* lock the file region */
#define LK_NBLCK	2	/* non-blocking lock */
#define LK_RLCK 	3	/* lock for writing */
#define LK_NBRLCK	4	/* non-blocking lock for writing */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))            /* ;Internal */
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))                        /* ;Internal */

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))
#define ListBox_AddFile(hwndCtl, lpszFilename)      ((int)(DWORD)SendMessage((hwndCtl), LB_ADDFILE, 0, (LPARAM)(LPCSTR)(lpszFilename)))    /* ;Internal */

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\dir.h ===
/* dir.h - structure of a directory entry */

struct dirType {
    char	name[8];		/* 00  packed FCB filename	     */
    char	ext[3]; 		/* 08  packed FCB extention	     */
    char	attr;			/* 0B  attribute		     */
    char	pad[10];		/* 0C  reserved space		     */
    unsigned	time;			/* 16  time of last modification     */
    unsigned	date;			/* 18  date of last modification     */
    unsigned	clusFirst;		/* 1A  first cluster on disk	     */
    long	size;			/* 1C  file size		     */
};


/* the following is what gets returned on FCB search calls */

struct srchdirType {
    char	drv;			/* 00  drive			     */
    char	name[8];		/* 01  packed FCB filename	     */
    char	ext[3]; 		/* 09  packed FCB extention	     */
    char	attr;			/* 0C  attribute		     */
    char	pad[10];		/* 0D  reserved space		     */
    unsigned	time;			/* 17  time of last modification     */
    unsigned	date;			/* 19  date of last modification     */
    unsigned	clusFirst;		/* 1B  first cluster on disk	     */
    long	size;			/* 1D  file size		     */
};


struct esrchdirType {
    char	eflg;			/* 00  must be 0xFF for extended     */
    char	pad1[5];		/* 01  padding			     */
    char	sattr;			/* 06  search attribute 	     */
    char	drv;			/* 07  drive			     */
    char	name[8];		/* 08  packed FCB filename	     */
    char	ext[3]; 		/* 10  packed FCB extention	     */
    char	attr;			/* 13  attribute		     */
    char	pad[10];		/* 14  reserved space		     */
    unsigned	time;			/* 1E  time of last modification     */
    unsigned	date;			/* 20  date of last modification     */
    unsigned	clusFirst;		/* 22  first cluster on disk	     */
    long	size;			/* 24  file size		     */
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\fcb.h ===
/* fcb.h - structure of a 1.0 fcb */

struct EFCBType {
    char	eflg;			/* 00  must be 0xFF for extended FCB */
    char	pad[5]; 		/* 01  padding			     */
    char	attr;			/* 06  enabling attribute	     */
    char	drv;			/* 07  drive code		     */
    char	nam[8]; 		/* 08  file name		     */
    char	ext[3]; 		/* 10  file name extension	     */
    int 	cb;			/* 13  current block number	     */
    int 	lrs;			/* 15  logical record size	     */
    long	lfs;			/* 17  logical file size	     */
    unsigned	dat;			/* 1B  create/change date	     */
    unsigned	tim;			/* 1D  create/change time	     */
    char	sys[8]; 		/* 1F  reserved 		     */
    unsigned char cr;			/* 27  current record number	     */
    long	rec;			/* 28  random record number	     */
};

struct FCB {
    char	drv;			/* 00  drive code		     */
    char	nam[8]; 		/* 01  file name		     */
    char	ext[3]; 		/* 09  file name extension	     */
    int 	cb;			/* 0C  current block number	     */
    int 	lrs;			/* 0E  logical record size	     */
    long	lfs;			/* 10  logical file size	     */
    unsigned	dat;			/* 14  create/change date	     */
    unsigned	tim;			/* 16  create/change time	     */
    char	sys[8]; 		/* 18  reserved 		     */
    unsigned char cr;			/* 20  current record number	     */
    long	rec;			/* 21  random record number	     */
};

#define FCBSIZ sizeof(struct FCB)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\parse.h ===
/* parse.h - support tops-20 comnd jsys on MSDOS */

#include <setjmp.h>

/* flags in pair.flags. Not examined by tbLook				     */
#define PINVIS	0x4000			/* invisible in HELP, but recognized */
#define PABBREV 0x2000			/* abbreviation. Value is pointer    */

/* parse support */
extern struct tbPairType *valParse;
extern jmp_buf ParseAC;
extern jmp_buf PromptAC;
extern char bufField[MAXLINELEN];

#define SETPROMPT(p,b) setjmp(PromptAC);initParse(b,p);setjmp(ParseAC)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\sys\timeb.h ===
/***
*sys\timeb.h - definition/declarations for ftime()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file define the ftime() function and the types it uses.
*	[System V]
*
*******************************************************************************/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* structure returned by ftime system call */

#ifndef _TIMEB_DEFINED
struct timeb {
	time_t time;
	unsigned short millitm;
	short timezone;
	short dstflag;
	};
#define _TIMEB_DEFINED
#endif


/* function prototypes */

void _FAR_ _cdecl ftime(struct timeb _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines types used in defining values returned by system
*	level calls for file status and time information.
*	[System V]
*
****/

#ifndef _INO_T_DEFINED
typedef unsigned short ino_t;		/* i-node number (not used on DOS) */
#define _INO_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef short dev_t;			/* device code */
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long off_t;			/* file offset value */
#define _OFF_T_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\times.h ===
/* times.h - format of time stamp */

#define STAMP	    "%2d:%02d:%02d %2d %3s %4d"
#define STAMPLEN    20
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structure used by the stat() and fstat()
*	routines.
*	[System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define structure for returning status information */

#ifndef _STAT_DEFINED
struct stat {
	dev_t st_dev;
	ino_t st_ino;
	unsigned short st_mode;
	short st_nlink;
	short st_uid;
	short st_gid;
	dev_t st_rdev;
	off_t st_size;
	time_t st_atime;
	time_t st_mtime;
	time_t st_ctime;
	};
#define _STAT_DEFINED
#endif

#define S_IFMT		0170000 	/* file type mask */
#define S_IFDIR 	0040000 	/* directory */
#define S_IFCHR 	0020000 	/* character special */
#define S_IFREG 	0100000 	/* regular */
#define S_IREAD 	0000400 	/* read permission, owner */
#define S_IWRITE	0000200 	/* write permission, owner */
#define S_IEXEC 	0000100 	/* execute/search permission, owner */


/* function prototypes */

int _FAR_ _cdecl fstat(int, struct stat _FAR_ *);
int _FAR_ _cdecl stat(char _FAR_ *, struct stat _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\include\sys\utime.h ===
/***
*sys\utime.h - definitions/declarations for utime()
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file defines the structure used by the utime routine to set
*	new file access and modification times.  NOTE - MS-DOS
*	does not recognize access time, so this field will
*	always be ignored and the modification time field will be
*	used to set the new time.
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by utime() function */

#ifndef _UTIMBUF_DEFINED
struct utimbuf {
	time_t actime;		/* access time */
	time_t modtime; 	/* modification time */
	};
#define _UTIMBUF_DEFINED
#endif


/* function prototypes */

int _FAR_ _cdecl utime(char _FAR_ *, struct utimbuf _FAR_ *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\ttypes.h ===
/* ttypes.h - type definitions for tools library */
/*
*  HISTORY:
*   29-May-87   danl    remove strcmpi
*                       int strcmpi (char *, char *);
*/

#include <stdio.h>

#undef max
#undef min

/* assembly routines */
flagType int25 (char, char far *, unsigned int, unsigned int);
flagType int26 (char, char far *, unsigned int, unsigned int);
// flagType kbhit ();  // already defined by C6
int getch (void);
void cursor (int, int);
void Move (void far *, void far *, unsigned int);
void Fill (char far *, char, unsigned int);
char *strbscan (char *, char *);
char *strbskip (char *, char *);
char *strncrlfend (char *, int);
flagType strpre (char *, char *);
long getlpos (void);
void getlinit ( char far *, int, int);
int getl (char *, int);
int   max (int, int);
int   min (int, int);
long lmax (long, long);
long lmin (long, long);


/* c routines */
#define lower(x)    (strlwr(x))
#define upper(x)    (strupr(x))
#define MakeStr(x)  (strdup(x))
#define strend(x)   ((x)+strlen(x))

flagType delnode (char *);
char  *error(void);
long fexpunge(char  *,FILE *);
char  *fcopy(char *,char *);
int fgetl(char	*,int ,FILE  *);
int fputl(char	*,int ,FILE  *);
int ffirst(char *,int ,struct findType * );
int fnext(struct findType * );
void findclose(struct findType * );
char forsemi(char  *,flagType ( *)(char *, unsigned **), ... );
long freespac(int );
long sizeround(long ,int );
#if defined(OS2)
struct spawnInfo * rspawnl(char  *,char  *,char  *, ... );
struct spawnInfo * rspawnv(char  *,char  *,char  *,char  *[0]);
char * fastcopy (unsigned short hfSrcParm, unsigned short hfDstParm);
#else
int rspawnl(char  *,char  *,char  *, ... );
int rspawnv(char  *,char  *,char  *,char  *[0]);
#endif
void mapenv (char *src, char *dst);
char  *ismark(char  *);
FILE  *swopen(char  *,char  *);
int swclose(FILE  *);
int swread(char  *,int ,FILE  *);
flagType swgoto (FILE *, char *);
char *swmatch (FILE *, char *);
int swparse(char *, char **, char **, char **, char **);
char  *swfind(char  *,FILE *,char  *);
char *getenvini(char  *,char  *);
char fPathChr(char );
char fSwitChr(char );
char fPFind(char  *,unsigned int * *);
char findpath(char  *,char  *,char );
FILE  *pathopen(char  *,char  *,char  *);
int forfile(char  *,int ,void (*)(char *, struct findType *, ...), ... );
int EnFile (char *, int, void (*)(char *, struct findType *, ...), ... );
int rootpath(char  *,char  *);
int sti(char  *,int );
int ntoi(char  *,int );
int strcmps(const char  *,const char  *);
int strcmpis(const char  *,const char  *);
int upd(char  *,char  *,char  *);
int drive(char	*,char	*);
int extention(char  *,char  *);
int filename(char  *,char  *);
int filenamx(char  *,char  *);
int fileext(char *, char *);
int path(char  *,char  *);
int curdir(unsigned char *,char );
int getattr(char *);
int fdelete(char  *);
char *fmove(char  *, char *);
char *fappend(char  *, int);
long ctime2l(char *);
struct tm *ctime2tm(char *);
long date2l(int, int, int, int, int, int);
VECTOR *VectorAlloc(int);
flagType fAppendVector(VECTOR **, void *);
int pipe( int [] );
int pgetl( char *, int, int );
enum exeKind exeType ( char * );
char *strExeType( enum exeKind );
flagType fMatch (char *, char *);

char * (*tools_alloc) (unsigned int);

int Connect (char *path, char *con, char *sub);
flagType fDisconnect (int drive);
char *pathcat (char *pDst, char *pSrc);
int setattr (char *pname, int attr);

/*  swchng.c */
flagType swchng (char *strSwFile, char *strTag, char *strLHS, char *strRHS, flagType fNoUndel);
flagType swchange (char *strSwFile, char *strTag, char *strLHS, char *strRHS,
    flagType fNoUndel, flagType *fError);

/*  heapdump.c */
int	heapdump ( FILE *fp, int iFormat );

/*  heapchk.c */
int	heapinfo (void);


/*  pname.c */
char *pname (char *);
unsigned short IsMixedCaseSupported (char *);

/* msexec.c */
int do_exec (char *xfn, char *pars, int spwn, unsigned needed, char **envp);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\adddrv.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  ADDDRV.C
 *	ADDDRV command main function.
 *
 *	ADDDRV command discription
 *		d>ADDDRV di_file_name
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *			Update to alph version.
 *----------------------------------------------------------------------
 *	MSKK02	July 20, 1987	akitok
 *		Add Hardware interrapt disable/enable.
 *		Change command code 20 check sequence.
 *----------------------------------------------------------------------
 *	MSKK03	Sep  1, 1987	akitok
 *		Program miss! Change operator at device_init().
 *		Problem at Ctrl-Z to CR/LF conversion.
 *----------------------------------------------------------------------
 *	MSKK04	Feb 2, 1988	akitok
 *		Add function _setenvp().
 *			for runtime start-up error2009.
 *----------------------------------------------------------------------
 *	MSKK10	Feb 10, 1989	yukini
 *		for DOS version 4.0
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 *	MSKK21	Jan 08, 1991	RokaH
 *		support Swapper check
 *----------------------------------------------------------------------
 */


#include "common.h"
#include "mesext.h"

#include "addsub.h"

/*------------------------------------------------<MSKK02>--*/
#ifndef BUGFIX
#define	BUGFIX
#endif
/*----------------------------------------------------------*/




LPSYSINFO	sysinfo = 0;
LPSAVEINFO	saveinfo = 0;
BUF		confbuf = { 0 };
int		devhi;
int		devhisz;
int		devhicount = 0;
long		dhsize;

/* Prototypes for ADDDRV.C */

void	fatal(int);
void	get_conf(STR);
int	do_device(BUF *);
int	load_file(STR);
void	device_init(LPDEV, LPSTR, DWORD *, WORD *);
void	device_dd(LPDEV);
LPSFT	search_sft(LPDEV);
void	search_eof(BUF *);
int	skip_control(BUF *);
void	_setenvp(void);

int	main(int argc, char *argv[]);


main(argc, argv)
int argc;
char *argv[];
{
	char c;
	BUF *p;
	union REGS r;
	unsigned short n;
	char i;
	char far *s;

	sysloadmsg(&r,&r);					/* MSKK10 */
	if (r.x.cflag & 1) {					/* MSKK10 */
		sysdispmsg(&r,&r);				/* MSKK10 */
		exit(1);					/* MSKK10 */
	}							/* MSKK10 */

	if (argc == 2 && argv[1][0] == '/' && argv[1][1] == '?')	/* MSKK20 */
	{
		Display_msg(AdddrvHelp, fileno(stdout), 0, 0, 0);
		exit(1);
	}
	else if (argc > 2)
	{
		Display_msg(ToomanyParm, fileno(stderr), 0, 0, 0);
		exit(1);
	}

	if (check_swapper())			/* MSKK21 */
	{
		Display_msg(SwapperExist, fileno(stderr), 0, 0, 0);
		exit(1);
	}


	/* must do at first time */
	get_dosvar();				/* get dos var pointer */

	keyoff();				/* key input disable	*/
	set_sig_trap(SIGINT);			/* int23h set		*/
	set_sig_trap(SIGHDERR);			/* int24h set		*/

	/* fprintf( stderr, "%s", Copyright ); */	/* copyright message	*/ /* MSKK10 */
	/*
	Display_msg( Copyright, fileno(stderr), 0,0,0 );
	*/

	/* if (ver_check( version()) == FALSE ) */		/* MSKK10 */
		/* panic( Badversion ); */			/* MSKK10 */
	if (search_info() != 0)			/* search saveinfo */
		panic( Dialready );
	if (argc < 2)				/* check filename */
		panic( Noconf );

	get_conf(argv[1]);			/* read config file */

	dos_maxalloc();				/* alloc rest of memory */
	dos_maxallochi();			/* alloc UMB */	/* MSKK20 */

	if( sig_stat(SIGINT) != 0 )
		panic( Ctrlc );

	saving();				/* save environment */
	saveinfo->umbseg = himemorg;		/* MSKK20 */

	p = &confbuf;

	while((c = bufgetc(p)) != -1)	/* get command alias char */
	{
		if ( c == 'D' || c == 'U' )	/* device = , devicehigh = */ /*MSKK20 */
		{
			devhi = (c == 'U' ? TRUE : FALSE);	/* MSKK20 */
			devhisz = FALSE;			/* MSKK20 */
			if (do_device(p) == -1)	/* do install */
				fatal( Devfalure );
		}
		else if (c == '9')		/* devicehigh size = */	/* MSKK20 */
		{
			devhi = TRUE;
			devhisz = TRUE;
			n = p->cnt;
			dhsize = 0;
			while (((i = bufgetc(p)) != -1) && (i >= '0' && i <= '9') || (i >= 'A' && i <= 'F'))
			{
				dhsize *= 0x10;
				dhsize += (i - (i > '9' ? 'A' - 10 : '0'));
			}
			if (i != '\0' || (n - p->cnt - 1 > 5 ))
			{
				Display_msg( Unknown, fileno(stderr), 0,0,0 );	/* MSKK20 */
				Display_msg(Crlfmsg,fileno(stdout),0,0,0);
			}
			else
			{
				while (((i = bufgetc(p)) != -1) && iswhite(i))
					;
				bufungetc(p,i);
				s = p->ptr;
				while (!iswhite(*s) && *s != '\n' && *s != '\r' && *s != '\0')
					s++;
				*s = '\0';
				if (do_device(p) == -1)	/* do install */
					fatal( Devfalure );
			}
		}
		else if ( c != '0')		/* if not REM */	/* MSKK20 */
		{
			Display_msg( Unknown, fileno(stderr), 0,0,0 );	/* MSKK20 */
			Display_msg(Crlfmsg,fileno(stdout),0,0,0);
		}
			/* fatal( Unknown ); */

		while(bufgetc(p) != '\n' )	/* skip this command */
			;
	}

	checkkey();				/* check keybord status	*/
						/* and int23h enable	*/
	if (sig_stat(SIGINT) != 0)			/* check ctrl-c */
		fatal( Ctrlc );

	if (saveinfo->devcount == 0)		/* check how many devices */
		fatal( Nodev );

	if (dos_realloc() == 0)			/* shrink memory */
		fatal( Cannotmodify );

	if (dos_reallochi() == 0)			/* shrink memory */ /* MSKK20 */
		fatal( Cannotmodify );

	if (devhicount == 0)			/* MSKK20 */
		saveinfo->umbseg = 0;

	/* close all stdio */
	fclose(stdin); fclose(stdout); fclose(stderr);
	fclose(stdaux); fclose(stdprn);

	reset23();
	reset24();				/* restore int24h	*/
	keyon();				/* key input enable	*/
	return	0;				/* exit program without error */	/* MSKK10 */
}


/*
 * It must be called before exit() after saving() when error.
 * Because must be restoring.
 */
void
fatal(mes)
int mes;							/* MSKK10 */
{
	restoring();				/* restore saving data */
	panic(mes);
}


/*
 * Read configuration file into a memory(high)
 * And little modification file.
 * If error, exit to panic
 */
void
get_conf(filename)
STR filename;
{

	HANDLE h;
	long l;
	LPSTR d, tmp;
	register char c;
	register BUF *p;

	p = &confbuf;

	if ((h = open(filename, O_RDONLY)) == -1) /* open file */
		panic( Cannotopen );
	if( sig_stat(SIGHDERR))
		panic( Harderr );

	if ((l = filelength(h)) == -1L)		/* get file size */
		panic( Cannotget );
	if( sig_stat(SIGHDERR))
		panic( Harderr );

	if (l >= (long)0xFFFF)			/* check file size */
		panic( Toobig );

	p->cnt = (WORD)l;			/* convert to WORD */
/*------------------------------------------------<MSKK03>--*/
#ifdef	BUGFIX
	FP_SEG(p->ptr) = dos_alloc(TO_PARA((p->cnt+1)), ALLOC_HIGH); /* get buf */
#else
	FP_SEG(p->ptr) = dos_alloc(TO_PARA(p->cnt), ALLOC_HIGH); /* get buf */
#endif
/*----------------------------------------------------------*/
	FP_OFF(p->ptr) = 0;

	if (lpread(h, p->ptr, p->cnt) != p->cnt) /* read config file */
		panic( Cannotread );
	close(h);				/* close file */
	if( sig_stat(SIGHDERR))
		panic( Harderr );

	search_eof(p);				/* check ctrl-Z */

	lpstrnupr(p->ptr, p->cnt);		/* uppercase */

	conv_dbspace(p->ptr, p->cnt);		/* convert bouble byte space */ /* MSKK20 */

	tmp = d = p->ptr;
	while (p->cnt != 0) {
		if (skip_control(p) == -1)	/* skip leading control */
			break;

		*d++ = checkcom(p->ptr);	/* alias command */

		if (*(d-1) == '0')	/* REM */	/* MSKK20*/
		{
			while ((c = bufgetc(p)) != -1 && !isdelim(c))
				;			/* skip command */
		}
		else
		{
			while ((c = bufgetc(p)) != -1 && c != '=')
				;
		}
		
		/* c has first delimiter */
		for (; c != -1 && isdelim(c); c = bufgetc(p))
			;			/* skip right to '=' */
		/* c has first undelimiter */
		for (; c != -1; c = bufgetc(p)) { /* copy fisrt parameter */
			if ((unsigned char)c > ' ') {
				*d++ = c;	/* copy it */
			} else {	/* got delimiter of first parm */
				if (c == '\n') { /* check end */
					*d++ = c; 
				} else {	/* copy rest parameters */
					*d++ = '\0'; /* put null for delimit */
					while ((c = bufgetc(p)) != -1) {
						if ((*d++ = c) == '\n')
							break;
					}
				}
				break;
			}
		}
	}
	p->ptr = tmp;				/* restore buffer pointer */
	p->cnt = d - tmp;			/* recalc buffer size */

}


/*
 * Device driver INSTALL
 * Load driver and initialize driver.
 * And update and save the environment(SFT, sysinfo).
 * If completed, return 0.
 * If error, return -1.
 */
do_device(p)
BUF *p;
{
	LPDEV newdev, next;
	DWORD breakaddr;
	WORD dd_flag;
	LPSFT sft;
	char filename[100], *DevName, *dp;
	LPDEVINFO devi;

	lpstrcpy((LPSTR)filename, p->ptr);	/* get closer */

	if ((FP_SEG(newdev) = load_file(filename)) == -1) /* load driver */
		return(-1);
	FP_OFF(newdev) = 0;

	for (;;) {

		if (!(newdev->attr & ISCHAR))	/* check character device */ /* MSKK10 */
			return(-1);

		/* init device driver */
		device_init(newdev, p->ptr, &breakaddr, &dd_flag);

		intdisable();			/* interrapt disable.	*/
						/* MSKK02		*/
		if (newdev->attr & ISCIN)	/* check console */
			sysinfo->con = newdev;	/* update console link */
		else if (newdev->attr & ISCLOCK) /* check clock */
			sysinfo->clock = newdev; /* update clock link */
		intenable();			/* interrapt enable	*/
						/* MSKK02		*/

		if (saveinfo->devcount >= MAXDEVINFO) /* check table entry */
			return(-1);
		devi = (LPDEVINFO)&(saveinfo->devinfo[saveinfo->devcount]);
		devi->newdev = newdev;		/* save driver address */
		devi->dd_flag = dd_flag;	/* save dd support flag */

		/* update SFT link */
		intdisable();			/* interrapt disable.	*/
						/* MSKK02		*/
		if ((sft = (LPSFT)search_sft(newdev)) != 0) {
			/* got same device */
			devi->sft = sft;	/* save this sft */
			devi->olddev = sft->devptr; /* save original driver */
			sft->devptr = newdev;	/* update sft link */
			sft->firclus = FP_OFF(newdev); /* update sft link */
		} else
			devi->sft = 0;		/* indicate no change sft */
		intenable();			/* interrapt enable	*/
						/* MSKK02		*/
		saveinfo->devcount++;		/* done saving */
		if (devhi)			/* MSKK20 */
			devhicount++;
		next = newdev->next;
		newdev->next = sysinfo->dev;
		sysinfo->dev = newdev;
		if (FP_OFF(next) == -1)
			break;
		FP_OFF(newdev) = FP_OFF(next);
	}

	/* allocation for this driver */
	dp = DevName = filename;				/* MSKK10 */
	while (*dp) {						/* MSKK10 */
		if (IsDBCSLeadByte(*dp)) {			/* MSKK10 */ /*MSKK20 */
			dp++;					/* MSKK10 */
			continue;				/* MSKK10 */
		}						/* MSKK10 */
		if (*dp == ':' || *dp == '\\')			/* MSKK10 */
			DevName = dp + 1;			/* MSKK10 */
		dp++;						/* MSKK10 */
	}							/* MSKK10 */
	dp = DevName;						/* MSKK10 */
	while(*dp) {						/* MSKK10 */
		if (*dp == '.') {				/* MSKK10 */
			*dp = '\0';				/* MSKK10 */
			break;					/* MSKK10 */
		}						/* MSKK10 */
		dp++;						/* MSKK10 */
	}							/* MSKK10 */

	if (devhi)						/* MSKK20 */
		my_allochi(FP_SEG(breakaddr)+TO_PARA(FP_OFF(breakaddr))-FP_SEG(newdev),'D',DevName);	/* MSKK20 */
	else
		my_alloc(FP_SEG(breakaddr)+TO_PARA(FP_OFF(breakaddr))-FP_SEG(newdev),'D',DevName);	/* MSKK10 */
	return(0);
}


/*
 * Load device driver
 * Return value is segment(para) value where loaded.
 * If error, return -1.
 */
load_file(filename)
STR filename;
{
	int h;
	long size;
	union REGS rg;
	struct SREGS sreg;
	WORD parm[2];
	WORD base;

	if ((h = open(filename, O_RDONLY)) == -1) /* open terget file */
			return(-1);
	if( sig_stat(SIGHDERR))
		return(-1);

	size = filelength(h);			/* get file size */
	close(h);				/* close terget */
	if( sig_stat(SIGHDERR))
		return(-1);

	if (devhi)				/* MSKK20 */
	{
		if ( (devhisz && (TO_PARA(dhsize) + 1 > himemsize)) ||
			((TO_PARA(size)+1) > himemsize) )
		{
			devhi = FALSE;
			base = membase;
			if ((TO_PARA(size)+1) > memsize)
				return(-1);
		}
		else
			base = himembase;
	}
	else
	{
		base = membase;
		if ((TO_PARA(size)+1) > memsize)		/* check memory size */	/* MSKK10 */
			return(-1);
	}

	parm[0] = parm[1] = base + 1;		/* load base & reloc factor */	/* MSKK10 */ /* MSKK20 */
	sreg.es = LP_HIGH(parm);		/* parm for overlay */
	rg.x.bx = LP_LOW(parm);
	sreg.ds = LP_HIGH(filename);		/* filename */
	rg.x.dx = LP_LOW(filename);
	rg.x.ax = 0x4B03;			/* load overlay */
	intdosx(&rg, &rg, &sreg);
	if (rg.x.cflag)				/* check errro */
		return(-1);
	return(base + 1);					/* MSKK10 */ /* MSKK20 */
}


/*
 * Device driver call by INIT function.
 * Note that size and flag are return value pointer.
 * Return breakaddr of driver.
 * And return DEINSTALL function support or not.
 */
void
device_init(dev, parm, breakaddr, flag)
LPDEV dev;
LPSTR parm;
DWORD *breakaddr;
WORD *flag;
{
	REQ req;
	CALLDEV call;

	req.len = 22;				/* request length */
	req.code = 0;				/* command INIT */

/*------------------------------------------------<MSKK02>--*/
#ifndef	BUGFIX

	(long)req.bpb_array = (long)DDSIGN;

#endif
/*----------------------------------------------------------*/
	(LPSTR)req.bpb_array = parm;		/* parameter pointer */
	FP_SEG(call.strategy) = FP_SEG(dev);	/* strategy entry address */
	FP_OFF(call.strategy) = dev->strategy;
	FP_SEG(call.Interrupt) = FP_SEG(dev);	/* interrupt entry address */
	FP_OFF(call.Interrupt) = dev->Interrupt;
	FP_SEG(call.packet) = LP_HIGH(&req);	/* request address */
	FP_OFF(call.packet) = LP_LOW(&req);
	bio(&call);				/* call device driver */
	/* set return value */
	*breakaddr = req.break_addr;		/* break address */

/*------------------------------------------------<MSKK02,MSKK03>--*/
#ifdef	BUGFIX

	*flag = ((long)req.bpb_array == ~(long)parm); /* dd support check */

#else

	*flag = ((long)req.bpb_array == !(long)parm); /* dd support check */
/*						<MSKK02> */
/*	*flag = ((long)req.bpb_array == !(long)DDSIGN); *//* dd support check */

#endif
/*----------------------------------------------------------*/
}


/*
 * Device driver call by DEINSTALL function.
 */
void
device_dd(dev)
LPDEV dev;
{
	REQ req;
	CALLDEV call;

	req.len = 22;				/* request length */
	req.code = 20;				/* command DD */
	FP_SEG(call.strategy) = FP_SEG(dev);	/* strategy entry */
	FP_OFF(call.strategy) = dev->strategy;
	FP_SEG(call.Interrupt) = FP_SEG(dev);	/* interrupt entry */
	FP_OFF(call.Interrupt) = dev->Interrupt;
	FP_SEG(call.packet) = LP_HIGH(&req);	/* request address */
	FP_OFF(call.packet) = LP_LOW(&req);
	bio(&call);				/* call device driver */
}


/*
 * Search sft entry same as device name
 * Return value is SFT address(DWORD)
 * If not found, return 0.
 */
LPSFT
search_sft(dev)
LPDEV dev;
{
	LPSF sf;
	LPSFT sft;
	int i;

	for(sf = sysinfo->sft; ; sf = sf->link) {
		for (i = 0,sft = (LPSFT)&sf->table; i < sf->count; i++,sft++) {
			if (sft->ref_count == 0) /* check refference count */
				continue;
			if (lpstrncmp((LPSTR)dev->name, (LPSTR)sft->name, 8) == 0)
				return(sft);	/* find it */
		}
		if (LP_LOW(sf->link) == -1)	/* check end of sft */
			break;
	}
	return(0);				/* not found */
}


void	search_eof(p)
register BUF *p;
{
	char far *s;
	register WORD count;

	for (s = p->ptr, count = 0; count < p->cnt; count++, s++) {
		if (*s == 0x1A) {
			s[0] = '\r';
			s[1] = '\n';
			p->cnt = count + 2;
			break;
		}
	}
}


skip_control(p)
register BUF *p;
{
	register char c;

	while ((c = bufgetc(p)) != -1) {
		if ((unsigned char)c > ' ') {
			bufungetc(p, c);
			return(c);
		}
	}
	return(-1);
}


/*------------------------------------------------<MSKK04>--*/
#if	defined(BUGFIX)				/* <MSKK04>	*/
void	_setenvp()
{						/* runtime dummy 
						/* function	*/
}
#endif						/* <MSKK04>	*/
/*----------------------------------------------------------*/

/*------------------------------------------------<ADDDRV.C end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\addsub.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	panic(int);
void	get_dosvar(void);
int	fm_strategy(int);
int	umblink(int);
int	dos_alloc(WORD, int);
void	dos_free(WORD);
int	dos_realloc(void);
int	dos_reallochi(void);
void	dos_maxalloc(void);
void	dos_maxallochi(void);
int	my_alloc(WORD, char, char*);
int	my_allochi(WORD, char, char*);
char	checkcom(LPSTR);
char	bufgetc(BUF *);
void	bufungetc(BUF *, char);
int	lpread(HANDLE, LPSTR, unsigned short);
int	checkkey(void);
void	Display_msg(int, int, int, int *, char);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\exe.h ===
/* exe.h - structure of an exe file header */
/* Include some new .exe file info from \link\newexe.h */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words (OLD) */
#define ERES1WDS        0x0004          /* No. of reserved words in e_res */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      8               /* Eight bytes reserved (now) */
#define NECRC           8               /* Offset into new header of NE_CRC */
#define NEDEFSTUBMSG	0x4E	    /* Offset into file of default stub msg */

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_IPHI(x)      (x).ne_iphi
#define NE_SPHI(x)      (x).ne_sphi
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     xxxxx                            Unused
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               x                      Unused
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEIERR          0x2000          /* Errors in image */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */


struct exeType {
    char	signature[2];		/* zibo's signature                  */
    unsigned	cbPage; 		/* bytes in image mod 512	     */
    unsigned	cPage;			/* size of file in 512 byte pages    */
    unsigned	cReloc; 		/* number of relocation items	     */
    unsigned	cParDir;		/* number of paragraphs before image */
    unsigned	cMinAlloc;		/* minimum number of paragrapsh      */
    unsigned	cMaxAlloc;		/* maximum number of paragrapsh      */
    unsigned	sStack; 		/* segment of stack in image	     */
    unsigned	oStack; 		/* offset of stack in image	     */
    unsigned	chksum; 		/* checksum of file		     */
    unsigned	oEntry; 		/* offset of entry point	     */
    unsigned	sEntry; 		/* segment of entry point	     */
    unsigned	oReloc; 		/* offset in file of reloc table     */
    unsigned	iOverlay;		/* overlay number		     */
};

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERES1WDS];/* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_iphi;        /* High word of initial IP */
    unsigned short      ne_sphi;        /* High word of initial SP */
    char                ne_res[NERESBYTES];
                                        /* Pad structure to 64 bytes */
  };


enum exeKind {
    IOERROR,				/* Error, file cannot be accessed    */
    NOTANEXE,				/* Error, file is not an .EXE file   */
    OLDEXE,				/* "oldstyle" DOS 3.XX .exe	     */
    NEWEXE,				/* "new" .exe, OS is unknown	     */
    WINDOWS,				/* Windows executable		     */
    DOS4,				/* DOS 4.XX .EXE		     */
    DOS286,				/* 286DOS .EXE			     */
    EXEBOUND,				/* 286DOS .EXE, bound		     */
    DYNALINK				/* Dynamlink link module	     */
};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\toolsvr\inc\tools.h ===
/*
 *  tools.h - Header file for accessing TOOLS.LIB routines
 *  includes stdio.h and ctype.h
 *
 *   4/14/86  daniel lipkie  added U_* flags for upd return values
 *
 *	31-Jul-1986 mz	Add Connect definitions
 *	02-Dec-1986 bw	Added DOS5 FindFirst buffer definition & A_ALL constant
 *	21-Jan-1987 bw	Add DWORD define
 *			Add PIPE_READ / PIPE_WRITE values
 *			Add new rspawn return typedef
 *	27-Jan-1987 bw	Make DOS 3 findType available to DOS 5
 *	18-Aug-1987 bw	change .max to .vmax to make C 5.x happy
 *	08-Mar-1988 bw	Copy WORD() and DWORD() to MAKE*()
 *	10-Mar-1988 mz	Add LOADDS/EXPORT definitions
 *	12-May-1988 mz	Add VECTOR typedef
 *	19-Aug-1988 mz	Conditionally define TRUE/FALSE
 *
 */

#if !defined (TRUE)
#define TRUE	-1
#endif

#if !defined (FALSE)
#define FALSE	0
#endif

#define     PSEPSTR "\\"
#define     PSEPCHR '\\'

typedef char flagType;
typedef long ptrType;

#define SETFLAG(l,f)	((l) |= (f))
#define TESTFLAG(v,f)	(((v)&(f))!=0)
#define RSETFLAG(l,f)	((l) &= ~(f))

#define SHIFT(c,v)	{c--; v++;}

#define LOW(w)		((int)(w)&0xFF)
#define HIGH(w) 	LOW((int)(w)>>8)
#define WORD(h,l)	((LOW((h))<<8)|LOW((l)))
#define DLOW(l) 	((long)(l)&0xFFFF)
#define DHIGH(l)	DLOW((long)(l)>>16)
#define DWORD(h,l)	((DLOW(h)<<16|DLOW(l)))
#define POINTER(seg,off) ((((long)(seg))<<4)+ (long)(off))
#define MAKEWORD(h,l)	((LOW((h))<<8)|LOW((l)))
#define MAKEDWORD(h,l)	((DLOW(h)<<16|DLOW(l)))

#define FNADDR(f)	(f)

#define SELECT		if(FALSE){
#define CASE(x) 	}else if((x)){
#define OTHERWISE	}else{
#define ENDSELECT	}

#define MAXARG	    128 		/* obsolete and begin deleted */
#define MAXLINELEN  1024		/* longest line of input */
#define MAXPATHLEN  260 		/* longest filename acceptable */


#if defined(OS2)

#define PIPE_READ   0
#define PIPE_WRITE  1


/*
 *  This is the value returned by rspawnl.  The PID field will always hold
 *  the process ID of the background process.  The in* fields will hold the
 *  handles of the pipe attached to the new processes stdin, and the out*
 *  fields correspond to stdout.  If input/output from/to a pipe has not been
 *  requested, the fields will be -1.  The fields are ordered read-write
 *  to allow a call pipe(&val.inReadHndl) or pipe(&val.outreadHndl).
*/
struct spawnInfo {
    unsigned PID;
    int inReadHndl;
    int inWriteHndl;
    int outReadHndl;
    int outWriteHndl;
};


/* buffer description for findfirst and findnext
   When DOS 3 and DOS 5 version have the same field name, the field contains
   the same information
   DOS 5 version includes the directory handle
*/

struct findType {
    unsigned	     type ;		/* type of object being searched    */
    unsigned   dir_handle ;		/* Dir search handle for FindNext   */
    unsigned  create_date ;		/* File date of creation	    */
    unsigned  create_time ;		/* File time of creation	    */
    unsigned  access_date ;		/* File date of last access	    */
    unsigned  access_time ;		/* File time of last access	    */
    unsigned	     date ;		/* File date of last write	    */
    unsigned	     time ;		/* File time of last write	    */
    long	   length ;		/* File end of data		    */
    long	    alloc ;		/* File allocation		    */
    unsigned	     attr ;		/* File attribute		    */
    unsigned char nam_len ;		/* Length of ASCIIZ name string     */
    char name[MAXPATHLEN] ;		/* ASCIIZ name string		    */
};

#define FT_DONE     0xFF		/* closed handle */
#define FT_FILE     0x00		/* enumerating files */
#define FT_SERV     0x01		/* enumerating servers */
#define FT_SHAR     0x02		/* enumerating shares */
#define FT_MASK     0xFF		/* mask for type */

#define FT_MIX	    0x8000		/* mixed case supported flag */

struct DOS3findType {
    char reserved[21];			/* reserved for start up	     */
    char attr;				/* attribute found		     */
    unsigned time;			/* time of last modify		     */
    unsigned date;			/* date of last modify		     */
    long length;			/* file size			     */
    char name[13];			/* asciz file name		     */
};

#else

struct findType {
    char reserved[21];			/* reserved for start up	     */
    char attr;				/* attribute found		     */
    unsigned time;			/* time of last modify		     */
    unsigned date;			/* date of last modify		     */
    long length;			/* file size			     */
    char name[13];			/* asciz file name		     */
};

#endif

typedef struct findType FIND;
typedef FIND near * NPFIND;


/* attributes */
#define A_RO	1			/* read only			     */
#define A_H	2			/* hidden			     */
#define A_S	4			/* system			     */
#define A_V	8			/* volume id			     */
#define A_D	16			/* directory			     */
#define A_A	32			/* archive			     */

#define A_MOD	(A_RO+A_H+A_S+A_A)	/* changeable attributes	     */
#define A_ALL	(A_RO|A_H|A_S|A_V|A_D|A_A)

#define HASATTR(a,v)	TESTFLAG(a,v)	/* true if a has attribute v	     */

extern char XLTab[], XUTab[];

struct vectorType {
    int vmax;				/* max the vector can hold	     */
    int count;				/* count of elements in vector	     */
    void *elem[1];			/* elements in vector		     */
};

typedef struct vectorType VECTOR;

#include "parse.h"
#include "exe.h"
#include "fcb.h"
#include "dir.h"
#include "times.h"
#include "ttypes.h"

/* return flags for upd */
#define U_DRIVE 0x8
#define U_PATH	0x4
#define U_NAME	0x2
#define U_EXT	0x1

/*  Connect definitions */

#define REALDRIVE	0x8000
#define ISTMPDRIVE(x)	(((x)&REALDRIVE)==0)
#define TOKTODRV(x)	((x)&~REALDRIVE)

/*  Heap Checking return codes */

#define HEAPOK           0
#define HEAPBADBEGIN    -1
#define HEAPBADNODE     -2

/* internal module prototypes here, not for api */
frenameNO(char *, char *);

/* msspawn.c: return codes */

#define RC_PREPERR   0x0100
#define RC_NOFILE    0x0200
#define RC_EXECERR   0x0300
#define RC_ENVERR    0x0400
#define RC_SWAPERR   0x0500

/* msspawn.c: Swap method and option flags */

#define USE_EMS      0x01
#define USE_XMS      0x02
#define USE_FILE     0x04
#define EMS_FIRST    0x00
#define XMS_FIRST    0x10
#define HIDE_FILE    0x40
#define NO_PREALLOC  0x100
#define CHECK_NET    0x200

#define USE_ALL      (USE_EMS | USE_XMS | USE_FILE)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\addsub.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  ADDSUB.C
 *	ADDDRV command sub function.
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *			Update to alph version.
 *----------------------------------------------------------------------
 *	MSKK02	Sep 1, 1987	akitok
 *			Delete "panic:" messages.
 *----------------------------------------------------------------------
 *	MSKK10	Feb 10,1989	yukini
 *			for DOS Version 4.0 & MEM program
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 */


#include "common.h"
#include "mesext.h"

#include "addsub.h"

/*------------------------------------------------<MSKK02>--*/
#ifndef BUGFIX
#define	BUGFIX
#endif
/*----------------------------------------------------------*/


CONFTAB comtab[] = {
	{ 'D', "DEVICE" },
	{ '9', "DEVICEHIGH SIZE" },
	{ 'U', "DEVICEHIGH" },
	{ '0', "REM" },
	{ 'Z', 0 }

//	{ 'B', "BUFFERS" },
//	{ 'C', "BREAK" },
//	{ 'F', "FILES" },
//	{ 'X', "FCBS" },
//	{ 'L', "LASTDRIVE" },
//	{ 'M', "MULTITRACK" },
//	{ 'P', "DRIVPARM" },
//	{ 'Q', "COUNTRY" },
//	{ 'S', "SHELL" },
//	{ 'I', "INSTALL" },
//	{ 'Y', "COMMENT" },
//	{ '1', "SWITCHES" },
//	{ 'H', "DOS" },
};


WORD memorg = 0;
WORD membase = 0;
WORD memsize = 0;

WORD himemorg = 0;				/* MSKK20 */
WORD himembase = 0;				/* MSKK20 */
WORD himemsize = 0;				/* MSKK20 */






void	panic(mes)						/* MSKK10 */
int mes;
{

#if	0						/* MSKK10 */
/*------------------------------------------------<MSKK02>--*/
#ifdef	BUGFIX
	printf( "\007%s\r\n", mes);
#else
	printf( "\007%s%s\r\n", Panicmes, mes);
#endif
/*----------------------------------------------------------*/
#endif

	Display_msg(mes,fileno(stdout),0,0,0);			/* MSKK10 */
	Display_msg(Crlfmsg,fileno(stdout),0,0,0);		/* MSKK10 */
	reset24();			/* restore int24h	*/
	reset23();			/* restore int23h	*/
	keyon();			/* key input enable	*/
	exit(1);
}


void	get_dosvar()
{
	union REGS rg;
	struct SREGS sreg;

	rg.h.ah = 0x52;				/* get DOS variable pointer */
	intdosx(&rg, &rg, &sreg);
	FP_SEG(sysinfo) = sreg.es;
	FP_OFF(sysinfo) = rg.x.bx;
}


fm_strategy(func)
int func;
{
	union REGS rg;
	WORD org;

	rg.x.ax = 0x5800;			/* get memory strategy */
	intdos(&rg, &rg);
	org = rg.x.ax;

	rg.x.bx = func;				/* strategy function */
	rg.x.ax = 0x5801;			/* set memory strategy */
	intdos(&rg, &rg);
	return(org);				/* return original */
}

umblink(func)					/* MSKK20 */
int	func;
{
	union REGS rg;
	WORD org;

	rg.x.ax = 0x5802;			/* get UMB link status */
	intdos(&rg, &rg);
	org = rg.x.ax & 0x00ff;

	rg.x.bx = func;
	rg.x.ax = 0x5803;			/* set UMB link */
	intdos(&rg, &rg);
	return(org);				/* return original */
}


dos_alloc(size, strat)
WORD size;
int strat;
{
	union REGS rg;
	WORD mem;

	mem = fm_strategy(strat);		/* set memory strategy */

	rg.x.bx = size;
	rg.h.ah = 0x48;				/* alloc mem */
	intdos(&rg, &rg);
	if (rg.x.cflag)
		panic( Cannotalloc );

	fm_strategy(mem);			/* restore strategy */
	return(rg.x.ax);
}


void	dos_free(mem)
WORD mem;
{
	union REGS rg;
	struct SREGS sreg;

	sreg.es = mem;
	rg.h.ah = 0x49;				/* free memory */
	intdosx(&rg, &rg, &sreg);
	if (rg.x.cflag)
		panic( Cannotfree );
}


dos_realloc()
{
	union REGS rg;
	struct SREGS sreg;

	sreg.es = memorg;			/* base */
	rg.x.bx = membase - memorg;		/* size */
	rg.h.ah = 0x4A;				/* modify memory */
	intdosx(&rg, &rg, &sreg);
	if (rg.x.cflag)
		return( 0 );			/* error	*/
	/* set memory owner itself */
	/* MSKK10 
	((ARENA far *)TO_LP(memorg-1,0))->owner = memorg;
	*/
	((ARENA far *)TO_LP(memorg-1,0))->owner = 9;		/* MSKK10 */

	/* MSKK10 start */
	rg.h.ah = 0x62;
	intdos(&rg, &rg);
	movedata(rg.x.bx - 1,0x0008,memorg - 1,0x0008,8);
	/* MSKK10 end */
	return( -1 );				/* good	*/
}

dos_reallochi()					/* MSKK20 */
{
	union REGS rg;
	struct SREGS sreg;

	if (himemorg == 0)
		return (-1);
	if (himembase - himemorg == 0)
	{
		dos_free(himemorg);
		return (-1);
	}
	sreg.es = himemorg;			/* base */
	rg.x.bx = himembase - himemorg;		/* size */
	rg.h.ah = 0x4A;				/* modify memory */
	intdosx(&rg, &rg, &sreg);
	if (rg.x.cflag)
		return( 0 );			/* error	*/
	/* set memory owner itself */
	/* MSKK10 
	((ARENA far *)TO_LP(himemorg-1,0))->owner = himemorg;
	*/
	((ARENA far *)TO_LP(himemorg-1,0))->owner = 9;		/* MSKK10 */

	return( -1 );				/* good	*/
}


void	dos_maxalloc()
{
	union REGS rg;
	WORD mem;

	mem = fm_strategy(ALLOC_FIT);		/* set strategy for best */
	rg.x.bx = 0xFFFF;			/* for maximam */
	rg.h.ah = 0x48;				/* alloc memory */
	intdos(&rg, &rg);			/* error at first time */
	rg.h.ah = 0x48;				/* alloc memory */
	intdos(&rg, &rg);
	if (rg.x.cflag)
		panic( Allocmax );
	fm_strategy(mem);			/* restore strategy */
	memsize = rg.x.bx;			/* get size */
	memorg = membase = rg.x.ax;		/* get base */

	/* MSKK10 start */
	rg.h.ah = 0x62;
	intdos(&rg, &rg);
	movedata(rg.x.bx - 1,0x0008,memorg - 1,0x0008,8);
	/* MSKK10 end */
}

void	dos_maxallochi()				/* MSKK20 */
{
	union REGS rg;
	WORD mem;
	WORD umb;

	mem = fm_strategy(ALLOC_FIT | HIGH_FIRST);	/* set strategy for best */
	umb = umblink(LINK_UMB);

	rg.x.bx = 0xFFFF;			/* for maximam */
	rg.h.ah = 0x48;				/* alloc memory */
	intdos(&rg, &rg);			/* error at first time */
	rg.h.ah = 0x48;				/* alloc memory */
	intdos(&rg, &rg);

	himemsize = rg.x.bx;			/* get size */
	himemorg = himembase = rg.x.ax;		/* get base */

	if (rg.x.cflag || !checkumb(himemorg))
	{
		dos_free(himemorg);
		himemorg = himembase = 0;
		himemsize = 0;
	}
	fm_strategy(mem);			/* restore strategy */
	umblink(umb);
}

/*
 * Memory allocation by myself
 *
 * entry memory size is 16bytes paragraph
 * return base value is base segment
 */
my_alloc(size,type,name)						/* MSKK10 */
WORD size;
char type;
char *name;
{
	ARENA far  *ap;
	WORD base;

	if ((size +1) > memsize)		/* ckeck size */	/* MSKK10 */
		return(-1);
	base = membase;				/* return value */
	membase += size + 1;			/* update base */
	memsize -= size + 1;			/* update size */
	ap = (ARENA far *)TO_LP(base,0);
	ap->sign = type;						/* MSKK10 */
	ap->owner = base + 1;						/* MSKK10 */
	ap->size = size;						/* MSKK10 */
	if (name)							/* MSKK10 */
		lpstrncpy((char far *)ap->ArenaName,(char far *)name,8);/* MSKK10 */
	else								/* MSKK10 */
		ap->ArenaName[0] = '\0';				/* MSKK10 */
	return(base + 1);						/* MSKK10 */
}

my_allochi(size,type,name)						/* MSKK20 */
WORD size;
char type;
char *name;
{
	ARENA far  *ap;
	WORD base;

	if ((size +1) > himemsize)		/* ckeck size */
		return(-1);
	base = himembase;				/* return value */
	himembase += size + 1;			/* update base */
	himemsize -= size + 1;			/* update size */
	ap = (ARENA far *)TO_LP(base,0);
	ap->sign = type;
	ap->owner = base + 1;
	ap->size = size;
	if (name)
		lpstrncpy((char far *)ap->ArenaName,(char far *)name,8);
	else
		ap->ArenaName[0] = '\0';
	return(base + 1);
}


char
checkcom(s)
LPSTR s;
{
	register CONFTAB *p;

	for (p = comtab; p->comstr != 0; p++) {
		if(lpstrncmp(s, (LPSTR)p->comstr, strlen(p->comstr)) == 0 &&
		    isdelim(*(s+strlen(p->comstr))))		/* MSKK20 */
			break;
	}
	return(p->ind);
}


char
bufgetc(p)
BUF *p;
{
	if (p->cnt == 0)
		return(-1);
	(p->cnt)--;
	return((unsigned)*p->ptr++);
}


void	bufungetc(p, c)
BUF *p;
char c;
{
	(p->cnt)++;
	*(--(p->ptr)) = c;
}


lpread(handle, buffer, count)
HANDLE handle;
LPSTR buffer;
unsigned short count;
{
	union REGS rg;
	struct SREGS sreg;

	sreg.ds = FP_SEG(buffer);		/* set buffer pointer */
	rg.x.dx = FP_OFF(buffer);
	rg.x.cx = count;
	rg.x.bx = handle;
	rg.h.ah	= 0x3F;				/* read */
	intdosx(&rg, &rg, &sreg);
	return(rg.x.ax);
}


/**********************************************************************
 *
 *  int checkkey()
 *	check keybord status
 *
 *	input	:
 *		  none
 *
 *	output	:
 *		  int checkkey() == 0  no characters in type-ahead buffer.
 *				 != 0  characters in type-ahead byffer.
 *
 *	If CTRL-C is in the buffer, it issues INT23h.
 *
 **********************************************************************
 */


checkkey()
{
	union	REGS	irg;


	irg.h.ah = 0x0B;
	intdos( &irg, &irg );
	return((int) irg.h.al );
}

/* courtesy of ATTRIB.c */

/*DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD*/
/*                                                                           */
/*    Subroutine Name: Display_msg                                           */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Display the requested message to a given output device              */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Number of the message to be displayed (see ADDDRV.SKL)         */
/*        (2) Output device handle                                           */
/*        (3) Number of substitution parameters (%1,%2)                      */
/*        (4) Offset of sublist control block                                */
/*        (5) Message Class, 0=no input, 1=input via INT 21 AH=1             */
/*                                                                           */
/*    Output:                                                                */
/*        The message is written to the given output device.  If input       */
/*        was requested, the character code of the key pressed is returned   */
/*        in outregs.x.ax.                                                   */
/*                                                                           */
/*    Normal exit: Message written to handle                                 */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              Sysdispmsg (module _msgret.sal)                              */
/*                                                                           */
/*DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD*/

void	Display_msg(msgnum,msghan,msgparms,msgsub,msginput)
   int   msgnum;
   int   msghan;
   int   msgparms;
   int   *msgsub;
   char  msginput;
{
	union	REGS	inregs, outregs;

   inregs.x.ax = msgnum;
   inregs.x.bx = msghan;
   inregs.x.cx = msgparms;
   inregs.h.dh = 0xff;
   inregs.h.dl = msginput;
   inregs.x.si = (WORD)msgsub;
   sysdispmsg(&inregs,&outregs);

   /* check for error printing message */
   if (outregs.x.cflag & 1) {
      outregs.x.bx = fileno(stderr); 
      outregs.x.si = 0;
      outregs.x.cx = 0;
      outregs.h.dh = 1; /* exterr_msg_class */
      outregs.h.dl = 0; /* no input */
      sysdispmsg(&outregs,&outregs);
      }
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\bin2txt.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 * Binary file convert text to stdout
 *	(it is insted of hd)
 *
 *	Created by yoshim	May 27, 1987
 */

#include <stdio.h>
#ifdef MSDOS
#include <fcntl.h>
#include <io.h>
#endif

main(argc, argv)
int argc;
char *argv[];
{
	FILE *f;
	int c;
	int i;

	if (argc < 2) {
		printf("usage: bin2txt filename\n");
		exit(1);
	}

	if ((f = fopen(argv[1], "r")) == NULL) {
		printf("bin2txt: cannot open %s\n", argv[1]);
		exit(2);
	}

#ifdef MSDOS
	setmode(fileno(f), O_BINARY);
#endif

	i = 0;
	while((c = getc(f)) != EOF) {
		if (i == 0)
			printf("\t");
		printf("0x%02X,", c);
		if ((i = ++i % 8) == 0)
			printf("\n");
	}
	fclose(f);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\bio.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

typedef struct {
	DWORD	packet, strategy, Interrupt;
} CALLDEV;

typedef struct {
	BYTE len;
	BYTE unitcode;
	BYTE code;
	WORD status;
	BYTE reserve[8];
	BYTE unitcount;
	DWORD break_addr;
	DWORD bpb_array;
	BYTE device_number;
} REQ, far * LPREQ;

#define	REQ_ERROR	0x8000
#define	REQ_BUSY	0x0200
#define	REQ_DONE	0x0100

void	bio(CALLDEV *);
int	checkumb(WORD);
int	check_swapper(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\bio.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

include	cmacros.inc

	assumes	cs, code

calldev		struc
	pack	dd	?
	strat	dd	?
	ent	dd	?
calldev		ends

sBegin	code

cProc	bio, <PUBLIC>, <bp,ds,es>
	parmDP	cdev
cBegin
	mov	bp, cdev
	mov	ds, word ptr [bp.strat+2]
	les	bx, [bp.pack]
	call	[bp.strat]
	call	[bp.ent]
cEnd

cProc	checkumb, <PUBLIC>, <es>
	parmDP	mem
cBegin
	mov	ah,62h			; get psp address
	int	21h
	mov	es,bx
	mov	bx,es:[0002]		; get end of dos memory
	mov	ax,1
	cmp	mem,bx
	ja	@f			; if mem is on umb
	mov	ax,0
@@:
cEnd

cProc	check_swapper, <PUBLIC>, <di, es>
cBegin
	xor	bx,bx
	mov	di,bx
	mov	es,bx
	mov	ax,4b02h		; check if swapper exist
	int	2fh
	jc	cs_none			; if swapper not exist
	mov	ax,es
	or	ax,di
	jnz	cs_exist		; if swapper exist
cs_none:
	mov	ax,0
	jmp	short cs_end
cs_exist:
	mov	ax,1
cs_end:
cEnd

sEnd	code

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\deldrv.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  DELDRV.C
 *	DELDRV command main function.
 *
 *	DELDRV command discription
 *		d>DELDRV
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *			Update to alph version.
 *----------------------------------------------------------------------
 *	MSKK10	Feb 21, 1989	yukini
 *			for DOS Version 4.0
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 *	MSKK21	Jan 08, 1991	RokaH
 *		support Swapper check
 *----------------------------------------------------------------------
 */

#include "common.h"
#include "mesext.h"


int	main(int argc, char *argv[]);
void	panic(int);
void	dos_free(WORD);
void	device_dd(LPDEV);
void	my_alloc(WORD, char, char *);
void	Display_msg(int, int, int, int *, char);


LPSYSINFO sysinfo = 0;
LPSAVEINFO saveinfo = 0;





main(argc, argv)
int argc;
char *argv[];
{
	union REGS rg;
	struct SREGS sreg;


	/* load messages */					/* MSKK10 */
	sysloadmsg(&rg,&rg);					/* MSKK10 */
	if (rg.x.cflag & 1) {					/* MSKK10 */
		sysdispmsg(&rg,&rg);				/* MSKK10 */
		exit(1);					/* MSKK10 */
	}							/* MSKK10 */


	if (argc == 2 && argv[1][0] == '/' && argv[1][1] == '?')	/* MSKK20 */
	{
		Display_msg(DeldrvHelp, fileno(stdout), 0, 0, 0);
		exit(1);
	}
	else if (argc > 1)
	{
		Display_msg(ToomanyParm, fileno(stderr), 0, 0, 0);
		exit(1);
	}

	if (check_swapper())			/* MSKK21 */
	{
		Display_msg(SwapperExist, fileno(stderr), 0, 0, 0);
		exit(1);
	}

	keyoff();				/* key input disable	*/

	rg.h.ah = 0x52;				/* get dos var */
	intdosx(&rg, &rg, &sreg);
	FP_SEG(sysinfo) = sreg.es;
	FP_OFF(sysinfo) = rg.x.bx;

#if	0								/* MSKK10 */
									/* MSKK10 */
	if (ver_check( version()) == FALSE )				/* MSKK10 */
		panic( Badversion );					/* MSKK10 */
#endif									/* MSKK10 */

	if ((saveinfo = search_info()) == 0)
		panic( Ddissued );

	restoring();

	fclose(stdin); fclose(stdout); fclose(stderr);
	fclose(stdaux); fclose(stdprn);

	keyon();				/* key input enable	*/
}


/************************************************************************
 *
 *  panic()
 *
 *	display error message.
 *	keybord enable.
 *	exit program.
 *
 *	input	:
 *		  message number to display
 *
 *	output	:
 *		  none.
 *
 ************************************************************************
 */


void	panic( mes )
int	mes;
{
	union REGS	r;

	/* printf( "\007%s\r\n", mes ); */				/* MSKK10 */
	Display_msg(mes,fileno(stdout),0,0,0);
	Display_msg(Crlfmsg,fileno(stdout),0,0,0);
	keyon();			/* key input enable	*/
	exit(1);
}




void
dos_free(mem)
WORD mem;
{
	union REGS rg;
	struct SREGS sreg;

	sreg.es = mem;
	rg.h.ah = 0x49;			/* free memory */
	intdosx(&rg, &rg, &sreg);
}

void
device_dd(dev)
LPDEV dev;
{
	REQ req;
	CALLDEV call;

	req.len = 22;				/* request length */
	req.code = 20;				/* command DD */
	FP_SEG(call.strategy) = FP_SEG(dev);	/* strategy entry */
	FP_OFF(call.strategy) = dev->strategy;
	FP_SEG(call.Interrupt) = FP_SEG(dev);	/* interrupt entry */
	FP_OFF(call.Interrupt) = dev->Interrupt;
	FP_SEG(call.packet) = LP_HIGH(&req);	/* request address */
	FP_OFF(call.packet) = LP_LOW(&req);
	bio(&call);				/* call device driver */
}


/***********************************************************************
 *
 *  my_alloc()
 *	dummy function.
 ***********************************************************************
 */


void	my_alloc( dumy, type , name )
WORD	dumy;
char	type, *name;
{
}

/* courtesy of ATTRIB.c */

/*DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD*/
/*                                                                           */
/*    Subroutine Name: Display_msg                                           */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Display the requested message to a given output device              */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Number of the message to be displayed (see ADDDRV.SKL)         */
/*        (2) Output device handle                                           */
/*        (3) Number of substitution parameters (%1,%2)                      */
/*        (4) Offset of sublist control block                                */
/*        (5) Message Class, 0=no input, 1=input via INT 21 AH=1             */
/*                                                                           */
/*    Output:                                                                */
/*        The message is written to the given output device.  If input       */
/*        was requested, the character code of the key pressed is returned   */
/*        in outregs.x.ax.                                                   */
/*                                                                           */
/*    Normal exit: Message written to handle                                 */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              Sysdispmsg (module _msgret.sal)                              */
/*                                                                           */
/*DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD*/

void	Display_msg(msgnum,msghan,msgparms,msgsub,msginput)
   int   msgnum;
   int   msghan;
   int   msgparms;
   int   *msgsub;
   char  msginput;
{
	union	REGS	inregs, outregs;

   inregs.x.ax = msgnum;
   inregs.x.bx = msghan;
   inregs.x.cx = msgparms;
   inregs.h.dh = 0xff;
   inregs.h.dl = msginput;
   inregs.x.si = (WORD)msgsub;
   sysdispmsg(&inregs,&outregs);

   /* check for error printing message */
   if (outregs.x.cflag & 1) {
      outregs.x.bx = fileno(stderr);
      outregs.x.si = 0;
      outregs.x.cx = 0;
      outregs.h.dh = 1; /* exterr_msg_class */
      outregs.h.dl = 0; /* no input */
      sysdispmsg(&outregs,&outregs);
      }
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\hardint.asm ===
title	HARDWARE INTERRAPT DISABLE/ENABLE
name	hardint
page	53, 132

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***********************************************************************
;	HARDINT.ASM
;
;		Hardware interrapt disable and enable function.
;
;		_intdisable
;			hardware interrapt disable.
;
;		_intenable
;			hardware interrapt enable.
;
;-----------------------------------------------------------------------
;	Modification history
;-----------------------------------------------------------------------
;	MSKK00	July 20, 1987	akitok
;		Make out.
;-----------------------------------------------------------------------


	.xlist
include	cmacros.inc
	.list




sBegin	code
	assumes	cs,code


;***********************************************************************
;	void intdisable(void);
;		disable hardware interrapt.
;
;		input	:
;			  none.
;
;		output	:
;			  none.
;
;***********************************************************************


cProc	intdisable, <PUBLIC>

cBegin
	cli			; interrapt disable.
cEnd


;***********************************************************************
;	void intenable(void);
;		enable hardware interrapt.
;
;		input	:
;			  none.
;
;		output	:
;			  none.
;
;***********************************************************************


cProc	intenable, <PUBLIC>

cBegin
	sti			; interrapt enable.
cEnd


sEnd	code

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\hardint.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	intdisable(void);
void	intenable(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\common.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  COMMON.H
 *	ADDDRV/DELDRV command common header file.
 *
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *			Update from alph version.
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 */

#include <version.h>

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <string.h>

#include "typedef.h"
#include "struct.h"
#include "lpointer.h"
#include "didd.h"
#include "signal.h"


/* Prototypes */

#include "bio.h"
#include "syncsigl.h"
#include "lpstring.h"
#include "oem2.h"
#include "hardint.h"
#include "keys.h"
#include "portliba.h"
#include "_msgret.h"


extern LPSYSINFO sysinfo;

extern WORD memorg;
extern WORD membase;
extern WORD memsize;

extern WORD himemorg;
extern WORD himembase;
extern WORD himemsize;

/* memory strategy of allocate */
#define	ALLOC_LOW	0x0000
#define	ALLOC_FIT	0x0001
#define	ALLOC_HIGH	0x0002

#define	HIGH_FIRST	0x0080			/* MSKK20 */
#define LINK_UMB	1			/* MSKK20 */

#define	FALSE		0
#define	TRUE		! FALSE


#define	isdelim(c)	((c)==' '||(c)=='\t'||(c)=='=')
#define iswhite(c)	((c)==' '||(c)=='\t')

/*--------------------------------------<COMMON.H end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\didd.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*******************************************************************
 *
 *	DIDD.H
 *		Sign key word.
 *------------------------------------------------------------------
 *	Modification history
 *------------------------------------------------------------------
 *	MSKK01	July 21, 1987	akitok
 *		No use DDSIGN.
 *		Change command code 20 check sequence.
 *------------------------------------------------------------------
 */


#define	INFOSIGN	"DI1.00:870510YM"
/*#define	DDSIGN		0x796B694D	*/

/*--------------------------------------<DIDD.H end >--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\exehigh.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 * EXE file High-loding program
 *
 *	Created by yoshim	May 27, 1987
 */

#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#ifdef MSDOS
#define	OPENMODE	(O_RDWR|O_BINARY)
#else
#define	OPENMODE	(O_RDWR)
#endif

typedef unsigned short WORD;
typedef struct {
	WORD	wSignature;
	WORD	cbLastp;
	WORD	cpnRes;
	WORD	irleMax;
	WORD	cparDirectory;
	WORD	cparMinAlloc;
	WORD	cparMaxAlloc;
	WORD	saStack;
	WORD	raStackInit;
	WORD	wchksum;
	WORD	raStart;
	WORD	saStart;
	WORD	rbrgrle;
	WORD	iovMax;
	WORD	doslev;
} RUNTYPE;

RUNTYPE header;
char copybuf[256];
char init[] = {
#include <init.i>
};

main(argc, argv)
int argc;
char *argv[];
{
	int src, dst;
	long min;
	long module;
	long rest;
	short packbuf;


	printf("Microsoft (R) EXE File High-Loading Utility  Version 0.01\n");
	printf("Copyright (C) Microsoft KK 1987.  All rights reserved.\n\n");

	if (argc < 3) {
		fprintf(stderr, "usage: exehigh <infile> <outfile>\n");
		exit(1);
	}

	if ((src = open(argv[1], OPENMODE)) == -1) {
		fprintf(stderr, "Cannot open %s\n", argv[1]);
		exit(2);
	}

	lseek(src, 0L, 0);
	read(src, (char *)&header, sizeof(RUNTYPE));
	if (header.wSignature != 0x5A4D) {
		close(src);
		fprintf(stderr, "%s is not an .EXE\n", argv[1]);
		exit(3);
	}

	module = (((long)header.cparDirectory)<<4);
	lseek(src, module + (((long)header.saStart)<<4) + header.raStart -2, 0);
	read(src, (char *)&packbuf, sizeof(short));
	if (packbuf == 0x4252) {
		close(src);
		fprintf(stderr, "%s is packed\n", argv[1]);
		exit(4);
	}

	if (header.cparMinAlloc == 0 && header.cparMaxAlloc == 0) {
		close(src);
		fprintf(stderr, "%s is high\n", argv[1]);
		exit(5);
	}

	dst = open(argv[2], O_CREAT|O_TRUNC|OPENMODE, S_IREAD|S_IWRITE);
	if (dst == -1) {
		fprintf(stderr, "Cannot create %s\n", argv[2]);
		close(src);
		exit(6);
	}

	*(WORD *)&init[0] = header.raStackInit;
	*(WORD *)&init[2] = header.saStack;
	*(WORD *)&init[4] = header.raStart;
	*(WORD *)&init[6] = header.saStart;
	*(WORD *)&init[8] = (((unsigned)sizeof(init))>>4);

	exe_copy(src, dst, module, filelength(src) - module);
	exe_rel(dst, (long)header.rbrgrle, header.irleMax, module);
	close(src);

	min = (((long)header.cparMinAlloc)<<4);

	header.raStackInit = 0x80;
	header.saStack = 0;
	header.raStart = 0x80;
	header.saStart = 0;
	rest = min + header.cbLastp + sizeof(init);
	header.cpnRes += rest / 512;
	header.cbLastp = rest % 512;
	header.cparMinAlloc = 0;
	header.cparMaxAlloc = 0;

	/* write new header */
	lseek(dst, 0L, 0);
	write(dst, (char *) &header, sizeof(RUNTYPE));

	/* add dummy page */
	add_rest(dst, min);
	close(dst);
}

add_rest(h, len)
int h;
long len;
{
	int count;

	for (count = 0; count < sizeof(copybuf); count++)
		copybuf[count] = 0;

	lseek(h, 0L, 2);

	while (len > 0) {
		count = (len > sizeof(copybuf))? sizeof(copybuf): len;
		len -= count;
		write(h, copybuf, count);
	}
}

exe_copy(src, dst, header, module)
int src, dst;
long header, module;
{
	lseek(src, 0L, 0);
	lseek(dst, 0L, 0);
	copy(src, dst, header);
	write(dst, init, sizeof(init));
	copy(src, dst, module);
}

copy(src, dst, len)
int src, dst;
long len;
{
	int count;

	while (len > 0) {
		count = (len > sizeof(copybuf))? sizeof(copybuf): len;
		len -= count;
		read(src, copybuf, count);
		write(dst, copybuf, count);
	}
}

exe_rel(h, pos, count, module)
int h;
long pos;
unsigned short count;
long module;
{
	WORD relbuf[2];
	long targ;

	while(count-- != 0) {
		lseek(h, pos, 0);
		read(h, (char *)relbuf, 4);
		relbuf[1] += (((unsigned)sizeof(init))>>4);
		lseek(h, pos, 0);
		write(h, (char *)relbuf, 4);
		pos += 4;

		targ = module + (((unsigned long)relbuf[1])<<4) + relbuf[0];
		lseek(h, targ, 0);
		read(h, (char *)relbuf, 2);
		relbuf[0] += (((unsigned)sizeof(init))>>4);
		lseek(h, targ, 0);
		write(h, (char *)relbuf, 2);
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\keys.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.model	small, c
	include version.inc
	.code

;/***********************************************************************
; *
; *  void keyoff()
; *	 key input disable.
; *
; *	 input	 :
; *		   none.
; *
; *	 output  :
; *		   none.
; *
; *	 call	 :
; *
; ***********************************************************************
; */
keyoff	proc

IF	IBMVER
	pushf
	cli
	xor	cx,cx
@@:
	in	al,64h
	test	al,2
	loopnz	@B			; Wait K/B ready
	mov	al,0adh 		; KEY-DISABLE command
	out	64h,al
	popf
ELSE
%OUT	keyoff() should be created by OEM
ENDIF
	ret
keyoff	endp

;/***********************************************************************
; *
; *  void keyon()
; *	 key input enable.
; *
; *	 input	 :
; *		   none.
; *
; *	 output  :
; *		   none.
; *
; *	 call	 :
; *
; ***********************************************************************
; */
keyon	proc

IF	IBMVER
	pushf
	cli
	xor	cx,cx
@@:
	in	al,64h
	test	al,2
	loopnz	@B			; Wait K/B ready
	mov	al,0aeh 		; KEY-ENABLE command
	out	64h,al
	popf
ELSE
%OUT	keyon() should be created by OEM
ENDIF
	ret
keyon	endp

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\init.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
; Initialize routine for EXE high-loading
;
;	Created by yoshim	May 27, 1987
;

;	for DOS 4.01 by yukini	Feb 20, 1989

PDB_BLOCK_LEN	equ	02h
PDB_PARENT_PID	equ	16h
PDP_ENVIRON	equ	2Ch


prog		group	code, data

code		segment byte public 'code'
code		ends
data		segment para public 'data'
data		ends

code		segment byte public 'code'
	assume	cs:code, ds:nothing, es:nothing, ss:nothing

iSP		dw	0
iSS		dw	0
iIP		dw	0
iCS		dw	0
rel		dw	0

stack		db	(128-10) dup(0)

		; cs points code segment
		; ds and es point psp segment

		mov	ax, cs			; get my code segment
		mov	bx, cs:[rel]
		sub	bx, 16
		add	ax, bx			; psp area(256 bytes)
		mov	ds, ax			; set new psp to DS
	
		mov	si, word ptr es:[PDB_BLOCK_LEN] ; set memory size
		mov	dx, ds			; set new psp
		mov	ah, 055h		; dup psp
		int	21h

		mov	ax, word ptr es:[PDB_PARENT_PID] ; copy parent pid
		mov	word ptr ds:[PDB_PARENT_PID], ax

		mov	bx, es			; go back old psp
		mov	ah, 50h			; set psp
		int	21h

		mov	cx, 4
close_loop:	mov	bx, cx
		mov	ah, 3Eh			; close
		int	21h
		loop	close_loop

		mov	bx, ds			; go to new psp
		mov	ah, 50h			; set psp
		int	21h

		mov	bx, ds			; bx = newpsp - oldpsp - 1
		mov	ax, es
		sub	bx, ax
		dec	bx
		mov	ah, 04Ah		; modify memory
		int	21h	

		push	es
		mov	ax, ds
		mov	es, ax
		mov	bx, 0FFFFh
		mov	ah, 04Ah		; modify memory. but, error!
		int	21h			; return possible size in BX
		mov	ah, 04Ah		; modify memory
		int	21h
		pop	es
; ------------------------------------------------<MSKK01>----------------------
		push	ds			;
		push	es			;

		mov	ax,es			;
		dec	ax			; points OLD PSP mem arena block
		mov	bx,ds			;
		dec	bx			; points NEW PSP mem arena block
		mov	si,8			;
		mov	di,si			;
		mov	cx,8			; transfer arena name to new one
		cld				;
		mov	ds,ax			;
		mov	es,bx			;
		rep	movsb			;
		pop	es			;
		pop	ds			;
; ------------------------------------------------<MSKK01>----------------------

		; free old psp
		; es already point old psp
		mov	ah, 049H		; free memory
		int	21h

		mov	ax, es:[PDP_ENVIRON]
		dec	ax
		mov	es, ax
		mov	es:[1], ds
	
		mov	ax, cs
		add	ax, cs:[rel]		; relocation factor to AX
;
;
; At this point, we are done loading, and it is time to pass
; control to the the expanded program.  Thus, we must set SS:SP
; appropriately, make ES and DS point at the PSP, and jump to
; the proper location.
;
		mov	di, cs:[iSP]		; Get initial SP value
		mov	si, cs:[iSS]		; Get initial SS value
		add	si, ax			; Relocate
		add	cs:[iCS], ax		; Relocate initial CS
		sub	ax, 10H			; Subtract PSP increment
		mov	ds, ax			; DS points to PSP
		mov	es, ax			; ES points to PSP
		mov	bx, offset prog:iIP	; Get offset of jump vector
		cli				; Disable interrupts
		mov	ss, si			; Initialize SS
		mov	sp, di			; Initialize SP
		sti				; Enable interrupts
		jmp	dword ptr cs:[bx]	; Jump to starting point

code		ends

data		segment
newmem		db	16 dup(0)
newpsp		db	256 dup(0)
data		ends
end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\lpstring.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

int	lpstrlen(LPSTR);
void	lpstrnupr(LPSTR, unsigned short);

int	lpstrncmp(LPSTR, LPSTR, unsigned short);
void	lpstrcpy(LPSTR, LPSTR);

void	lpstrncpy(LPSTR, LPSTR, int);				/* MSKK10 */

void	conv_dbspace(LPSTR, unsigned short);
int	wordlen(LPSTR);
int	IsDBCSLeadByte(unsigned char);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\mesext.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  MESEXT.h
 *	ADDDRV/DELDRV command external define at message data.
 *
 *----------------------------------------------------------------------
 *  Modification History
 *	MSKK00	June 1, 1987	akia
 *		Make out this module.
 *----------------------------------------------------------------------
 *	MSKK01	Sep 1, 1987	akitok
 *		Delete "panic:" messages.
 *----------------------------------------------------------------------
 *	MSKK02	Feb 21, 1989	yukini
 *		for DOS Version 4.0
 *----------------------------------------------------------------------
 *	MSKK20	Sep 28, 1990	RokaH
 *		Add help messages
 *----------------------------------------------------------------------
 *	MSKK21	Jan 08, 1991	RokaH
 *		Add Swapper message
 *----------------------------------------------------------------------
 */


/* MSKK02 *********************************************************************
extern	char	Copyright[],	Noconf[],	Dialready[];
extern	char	Devfalure[],	Unkown[],	Ctrlc[];
extern	char	Nodev[],	Cannotopen[],	Cannotget[];
extern	char	Toobig[],	Cannotread[],	Cannotalloc[];
extern	char	Cannotfree[],	Cannotmodify[],	Allocmax[];
*/
/*------------------------------------------------<MSKK01>--
 *extern	char	Ddissued[],	Harderr[],	Panicmes[];
 *----------------------------------------------------------
 */
/* MSKK02
extern	char	Ddissued[],	Harderr[];
extern	char	Badversion[];
******************************************************************************/


/*
	Message number for message retriever
*/
#define	Copyright	11
#define	Noconf		12
#define	Dialready	13
#define Devfalure	14
#define	Unknown		15
#define	Ctrlc		16
#define	Nodev		17
#define	Cannotopen	18
#define	Cannotget	19
#define	Toobig		20
#define	Cannotread	21
#define	Harderr		22
#define	Cannotalloc	23
#define	Cannotfree	24
#define	Cannotmodify	25
#define	Allocmax	26
#define	Ddissued	27
#define	Crlfmsg		28

#define ToomanyParm	29

#define AdddrvHelp	30		/* MSKK20 */
#define DeldrvHelp	31		/* MSKK20 */

#define SwapperExist	32		/* MSKK21 */

/*--------------------------------------<MESEXT.H end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\keys.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


void	keyoff(void);
void	keyon(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\lpointer.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#define	LP_HIGH(lp) ((WORD)(((unsigned long)(char far *)(lp)) >>16))
#define	LP_LOW(lp) ((WORD)(((unsigned long)(char far *)(lp)) & 0xFFFF))

#define	TO_LP(s,o) ((((DWORD)(s))<<16)|((DWORD)(o)))

#define	TO_PARA(x) (((unsigned)(x)+15)>>4)


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\oem.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  OEM.H
 *	ADDRV/DELDRV command OEM depende function header file.
 *
 *	name	      | explanation
 *  ------------------+----------------------------------------------
 *	OEM           | if def : OEM add restoring( DD ) disposition.
 *		      | if ndef: Nothing add disposition.
 *  ------------------+----------------------------------------------
 *	FIXADDR	      |	if def : Use for DI information pointer 
 *		      |			at OEM fix address.
 *		      | if ndef: Use for DI information area
 *		      |			at dinamic address.
 *  ------------------+----------------------------------------------
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK00	June 1, 1987	akik
 *			Make out first version.
 *----------------------------------------------------------------------
 */


/*	#define	FIXADDR	*/
/*	#define	OEM	*/


#ifdef	FIXADDR
				/* DI information area pointer	*/
#define	FIXSEG	0x0000		/* segment	*/
#define	FIXOFF	0x0000		/* offset	*/

#endif				/* #ifdef FIXADDR	*/

/*--------------------------------------<OEM.H end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\lpstring.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

#include "common.h"

lpstrlen(lp)
LPSTR lp;
{
	unsigned short n;

	for (n = 0; *lp++; n++)
		;
	return(n);
}

lpstrncmp(lp, lp2, n)
LPSTR lp, lp2;
unsigned short n;
{
	register char c, c2;

	while (n-- > 0) {
		c = *lp++;
		c2 = *lp2++;
		if (c < c2)
			return(-1);
		else if (c > c2)
			return(1);
	}
	return(0);
}

void
lpstrnupr(s, count)
LPSTR s;
register unsigned short count;
{
	register BYTE c;

	while(count > 0) {
		c = *s;
		if (IsDBCSLeadByte(c)) {			/* MSKK20 */
			s++, count--;
		} else if (c >= 'a' && c <= 'z') {
			*s -= 0x20;
		}
		s++, count--;
	}
}

void
lpstrcpy(lp, lp2)
LPSTR lp, lp2;
{
	while (*lp++ = *lp2++)
		;
}

void							/* MSKK10 */
lpstrncpy(lp, lp2, count)				/* MSKK10 */
LPSTR	lp, lp2;					/* MSKK10 */
int	count;						/* MSKK10 */
{							/* MSKK10 */
	while (count--) {				/* MSKK10 */
							/* MSKK10 */
		if ((*lp++ = *lp2++) == '\0')		/* MSKK10 */
			break;				/* MSKK10 */
							/* MSKK10 */
	}						/* MSKK10 */
}							/* MSKK10 */

void	conv_dbspace(s, count)				/* MSKK20 */
LPSTR s;
register unsigned short count;
{
	register BYTE c;

	while(count > 0) {
		c = *s;
		if (IsDBCSLeadByte(c)) {
			if (*s == DB_SP_HI && *(s+1) == DB_SP_LO)	/* if DBCS space */
			{
				*s = ' ';
				*(s+1) = ' ';
			}
			s++, count--;
		}
		s++, count--;
	}
}

wordlen(lp)						/* MSKK20 */
LPSTR lp;
{
	unsigned short n;
	unsigned char c;

	for (n = 0; c = *lp++; n++)
	{
		if (c == 0x0a || c == 0x0d || isdelim(c))
			return (n);
	}
	return(n);
}

/*
	Test if the character is DBCS lead byte

	input:	c = character to test
	output:	TRUE if leadbyte
*/

int	IsDBCSLeadByte(c)		/* MSKK20 */
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;

	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;

	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;		/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\oem.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  OEM.C
 *	ADDDRV/DELDRV command OEM depende function file.
 *
 *	function      | explanation
 *  ------------------+----------------------------------------------
 *	saving()      |	ifdef FIXADDR : The DI information area pointer
 *		      |			store to OEM fix address.
 *		      | ifndef FIXADDR: nothing to do.
 *  ------------------+----------------------------------------------
 *	restoring()   | ifdef OEM     : OEM add restoring( DD ) disposition.
 *		      | ifdef FIXADDR : The DI information area pointer
 *		      |                 clear to 0.
 *		      | ifndef FIXADDR: nothing to do.
 *  ------------------+----------------------------------------------
 *	search_info() | ifdef FIXADDR : Get from OEM fix address
 *		      |			 at DI information area pointer.
 *                    | ifndef FIXADDR: Search DI information area.
 *  ------------------+----------------------------------------------
 *	keyoff()      | key input disable.
 *  ------------------+----------------------------------------------
 *	keyon()       | key input enable.
 *  ------------------+----------------------------------------------
 *	ver_check()   | Check DOS version.
 *
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *		Update to alph version.
 *----------------------------------------------------------------------
 *	MSKK02	July 20, 1987	akitok
 *		Add Hardware interrapt disable/enable.
 *----------------------------------------------------------------------
 *	MSKK10	Feb 21, 1989	yukini
 *		For DOS Version 4.0
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 */


#include "common.h"
#include "oem.h"		/* OEM depend header	*/

#define	LowVersion	310	/* DOS low version	*/
#define	HighVersion	321	/* DOS high version	*/


extern	void	device_dd(LPDEV);
extern	int	my_alloc(WORD, char, char*);
extern	void	dos_free(WORD);

extern LPSAVEINFO saveinfo;
extern LPSYSINFO  sysinfo;


/***********************************************************************
 *
 *  void saving()
 * 	Save environment for the after.
 *
 *	input	:
 *		  LPSYSINFO sysinfo
 *
 *	output	:
 *		  LPSAVEINF saveinfo
 *
 *	call	:
 *		  my_alloc()	addsub.c
 *		  lpstrcpy()	lpstring.c
 *
 ***********************************************************************
  */


void
saving()
{
	FP_SEG(saveinfo) = my_alloc(TO_PARA(sizeof(SAVEINFO)),'?',"INFO"); /* get info area */
	FP_OFF(saveinfo) = 0;
	lpstrcpy((LPSTR)saveinfo->sign, (LPSTR)INFOSIGN);	/* fill sign */

	intdisable();				/* interrapt disable.	*/
						/* MSKK02		*/
	saveinfo->dev = sysinfo->dev;		/* save device link */
	saveinfo->con = sysinfo->con;		/* save console link */
	saveinfo->clock = sysinfo->clock;	/* save clock link */
	saveinfo->vector = *((VECTOR far *)0);	/* save vector */
	intenable();				/* interrapt enable	*/
						/* MSKK02		*/

	saveinfo->devcount = 0;


/*+---------------------------------------------------------------------+*/
/*|									|*/
/*| Store DI information address.					|*/

#ifdef FIXADDR

	*(LPSAVEINFO far *)(TO_LP(FIXSEG, FIXOFF)) = saveinfo;

#endif /* FIXADDR */

/*|									|*/
/*+---------------------------------------------------------------------+*/
}


/***********************************************************************
 *
 *  void restoring()
 *	Restore all environment to the before.
 *
 *	input	:
 *		  LPSAVEINF saveinfo
 *
 *	output	:
 *		  LPSYSINFO sysinfo
 *			  System variavle area.
 *
 *	call	:
 *		  device_dd()		adddrv.c     deldrv.c
 *		  dos_free()		addsub.c     drldrv.c
 *		  lpstrncmp()		lpstring.c
 *
 ***********************************************************************
 */


void
restoring()
{
	int i, n;
	LPDEVINFO devi;
	LPSTR lp;


	intdisable();				/* interrapt disable.	*/
						/* MSKK02		*/
	sysinfo->dev = saveinfo->dev;		/* restore device link */
	sysinfo->con = saveinfo->con;		/* resotre console link */
	sysinfo->clock = saveinfo->clock;	/* resotre clock link */
	intenable();				/* interrapt enable	*/
						/* MSKK02		*/
	for (i = saveinfo->devcount; i > 0; i--) { /* restore sft link */
		devi = (LPDEVINFO)&(saveinfo->devinfo[i-1]);
		if (devi->dd_flag != 0)		/* check dd support */
			device_dd(devi->newdev); /* do deinstall */
		if (devi->sft != 0) {		/* check sft changed */
			intdisable();		/* interrapt disable.	*/
						/* MSKK02		*/
			devi->sft->devptr = devi->olddev; /* restore sft */
			devi->sft->firclus = LP_LOW(devi->olddev);
			intenable();		/* interrapt enable	*/
						/* MSKK02		*/
		}


/*+---------------------------------------------------------------------+*/
/*|									|*/
/*| OEM original DD disposition.					|*/

#ifdef OEM

#endif /* OEM */

/*|									|*/
/*+---------------------------------------------------------------------+*/

	}
	intdisable();				/* interrapt disable.	*/
						/* MSKK02		*/
	*((VECTOR far *)0) = saveinfo->vector;	/* resotre vector */
	intenable();				/* interrapt enable	*/
						/* MSKK02		*/
	if (saveinfo->umbseg != 0)		/* MSKK20 */
		dos_free(saveinfo->umbseg);

	del_info(FP_SEG(saveinfo) - 1);		/* MSKK20 */
	dos_free(FP_SEG(saveinfo) - 1);		/* free info & driver memory */	/* MSKK10 */


/*+---------------------------------------------------------------------+*/
/*|									|*/
/*| OEM fix address initialize.						|*/

#ifdef FIXADDR

	*(LPSAVEINFO far *)(TO_LP(FIXSEG, FIXOFF)) = 0;

#endif /* FIXADDR */

/*|									|*/
/*+---------------------------------------------------------------------+*/
}


/***********************************************************************
 *
 *  LPSAVEINFO search_info()
 *	Search DIDD information area.
 *	Return value is segment para of info area.
 *	If not found, return 0.
 *
 *	input	:
 *		  LPSYSINFO sysinfo
 *
 *	output	:
 *		  serch_inf() == 0	Not install device driver.
 *			      != 0	DI information area address.
 *
 *	call	:
 *		  device_dd()
 *
 ***********************************************************************
 */


/*+---------------------------------------------------------------------+*/
/*|									|*/
/*| Use OEM fix address.						|*/

#ifdef FIXADDR

LPSAVEINFO
search_info()
{
	return(*(LPSAVEINFO far *)TO_LP(FIXSEG, FIXOFF));
}

/*|									|*/
/*+---------------------------------------------------------------------+*/

#else /* nodef FIXADDR */

/*+---------------------------------------------------------------------+*/
/*|									|*/
/*| Search dynamic address.						|*/

LPSAVEINFO
search_info()
{
	ARENA far *p;
	int	i;

	FP_SEG(p) = *(WORD far *)((LPSTR)sysinfo - 2);
	FP_OFF(p) = 0;
	for (; p->sign == 'Z'|| p->sign == 'M';
	     FP_SEG(p) = FP_SEG(p) + p->size + 1)
	{
		i = lpstrncmp((LPSTR)p+32, (LPSTR)INFOSIGN, 16);	/* MSKK10 */
		if ( i == 0 )
			return((LPSAVEINFO)TO_LP(FP_SEG(p)+2,0)); /* find it */	/* MSKK10 */
	}
	return((LPSAVEINFO)0);			/* not found */
}

#endif /* FIXADDR */

#if 0								/* MSKK10 */

/*|									|*/
/*+---------------------------------------------------------------------+*/


/***********************************************************************
 *
 *  void keyoff()
 *	key input disable.
 *
 *	input	:
 *		  none.
 *
 *	output	:
 *		  none.
 *
 *	call	:
 *
 ***********************************************************************
 */


void keyoff()
{

/*-----------------------------------------------------------------------*/
/*|	OEM key disable routine.					|*/
/*|									|*/
/*-----------------------------------------------------------------------*/

}


/***********************************************************************
 *
 *  void keyon()
 *	key input enable.
 *
 *	input	:
 *		  none.
 *
 *	output	:
 *		  none.
 *
 *	call	:
 *
 ***********************************************************************
 */


void keyon()
{

/*-----------------------------------------------------------------------*/
/*|	OEM key enable routine.						|*/
/*|									|*/
/*-----------------------------------------------------------------------*/

}
#endif							/* MSKK10 */

#if	0						/* MSKK10 */
/***********************************************************************
 *
 *  int ver_check()
 *	Check dos version.
 *
 *	input	:
 *		  int	verno		DOS version.
 *
 *	output	:
 *		  int ver_check() == 0	incorrect DOS version.
 *				  != 0	OK!
 *
 *	call	:
 *
 ***********************************************************************
 */


ver_check( verno )
int	verno;
{
/*
	if ( verno < LowVersion	|| verno > HighVersion )
		return (int) FALSE;
	else
		return (int) TRUE;
*/
	return (verno == 400) ? TRUE : FALSE;
}
#endif

void	del_info(mem)
WORD mem;
{
	unsigned long far	*p;

	/* destroy adddrv information, in case of fragumentation   MSKK10 */
	p = (unsigned long far *)((unsigned long)(mem+1)<< 16);	/* MSKK10 */
	*p++ = 0L;						/* MSKK10 */
	*p++ = 0L;						/* MSKK10 */
	*p++ = 0L;						/* MSKK10 */
	*p++ = 0L;						/* MSKK10 */
}


/*--------------------------------------<OEM.C end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\portliba.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	ctrlc(void);
void	CritErr(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\oem2.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	saving(void);
void	restoring(void);
LPSAVEINFO search_info(void);
/* void    keyoff(void); */					/* MSKK10 */
/* void    keyon(void); */					/* MSKK10 */
/* int	ver_check( int ); */					/* MSKK10 */
void	del_info(int);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\signal.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

int     (*signal())();

#define NSIG    17      /* (one greater than) number of signals */

/*      Signal numbers */
#define SIGINT  1               /* ^C or user defined key */
#define SIGKB0  1               /* ^C or user defined key */
#define SIGKB1  2               /* alternate key intercept */
#define SIGKB2  3               /* alternate key intercept */
#define SIGMUF  4               /* special key intercept for MUF */
#define SIGDIVZ 5               /* divide by zero trap */
#define SIGOVFL 6               /* INTO instruction */
#define SIGHDERR 7              /* INT 24 type things */
#define SIGTERM 8               /* program termination */
#define SIGPIPE 9               /* broken pipe */
#define SIGUSR1 13              /* reserved for user definition */
#define SIGUSR2 14              /* reserved for user definition */

/*      Signal actions */
#define SIG_DFL (int (*)())0    /* terminate process on receipt */
#define SIG_IGN (int (*)())1    /* ignore */
#define SIG_GET 2               /* signal is accepted */
#define SIG_ERR 3               /* sender gets error */
#define SIG_ACK 4               /* acknowledge received signal */


#ifndef SIGKILL
#define SIGKILL 0
#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\struct.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *----------------------------------------------------------------------
 *  Modification history
 *----------------------------------------------------------------------
 *	MSKK20	Aug 25, 1990	RokaH
 *		support DEVICEHIGH
 *----------------------------------------------------------------------
 */

typedef struct {	/* process data block */
	WORD int20;		/* int 20h system terminate */
	BYTE block[3];		/* size of execution block */
	BYTE cpm[5];		/* ancient call to system */
	DWORD exit;		/* pointer to exit routine */
	DWORD ctrlc;		/* pointer to ^C routine */
	DWORD fatal;		/* pointer to fatal error routine */
	WORD parent;		/* PID of parent */
	BYTE jfn_tab[20];	/* indicate into system table */
	WORD environ;		/* segment of evironment */
	DWORD stack;		/* stack of self during system calls */
	WORD jfn_len;		/* number of handles allowed */
	DWORD jfn_pointer;	/* pointer to JFN table */
	DWORD next;		/* pointer to nested PDB's */
} PDB, far * LPPDB;

typedef struct {	/* memory control block */
	BYTE sign;		/* 'M' for valid item, 'Z' for last item */
	WORD owner;		/* owner of arena item */
	WORD size;		/* size in para of item */
	BYTE Reserved[3];						/* MSKK10 */
	BYTE ArenaName[8];	/* Name of memory arena			   MSKK10 */
} ARENA;

typedef struct {	/* command line */
	BYTE count;		/* number of character in buffer */
	char buf[127];		/* buffer area */
} COMLINE;

typedef struct {	/* config command table */
	char ind;		/* alias character of command */
	char *comstr;		/* command string */
} CONFTAB;

typedef struct {	/* buffer control */
	char far *ptr;		/* point to current position of buffer */
	unsigned short cnt;	/* number of character in buffer */
} BUF;

typedef struct _dev { /* device header */
	struct _dev far *next;	/* pointer to next device */
	WORD	attr;		/* device attribute */
	WORD	strategy;	/* starategy entry point */
	WORD	Interrupt;	/* interrupt entry point */
	BYTE	name[8];	/* device name or number of device */
} far * LPDEV;

#define	ISCIN	0x0001		/* if on, standard input device */
#define	ISCLOCK	0x0008		/* if on, clock device */
#define	ISCHAR	0x8000		/* if on, character device. else block */

typedef struct _sft {
	WORD	ref_count;	/* number of processes sharing entry */
	WORD	mode;		/* more of access or high bit on if FCB */
	BYTE	attr;		/* attribute of file */
	WORD	flags;		/* Bits 8-15
				 * Bit 15 = 1 if remote file
				 *        = 0 if local file or device
				 * Bit 14 = 1 if date/time is not to be
				 *   set from clock at CLOSE.
				 *   Set by FILETIMES and FCB_CLOSE.
				 *   Reset by other reseters of the dirty bit
				 *   (WRITE)
				 * Bit 13 = Pipe bit (reserved)
				 *
				 * Bits 0-7 (old FCB_devid bits)
				 * If remote file or local file, bit
				 * 6=0 if dirty Device ID number, bits
				 * 0-5 if local file.
				 * bit 7=0 for local file, bit 7
				 *      =1 for local I/O device
				 * If local I/O device, bit 6=0 if EOF (input)
				 *		Bit 5=1 if Raw mode
				 *		Bit 0=1 if console input device
				 *		Bit 1=1 if console output device
				 *		Bit 2=1 if null device
				 *		Bit 3=1 if clock device */
	LPDEV	devptr;		/* Points to DPB if local file, points
				 * to device header if local device,
				 * points to net device header if remote */
	WORD	firclus;	/* First cluster of file (bit 15 = 0) */
	WORD	time;		/* Time associated with file */
	WORD	date;		/* Date associated with file */
	DWORD	size;		/* Size associated with file */
	DWORD	position;	/* Read/Write pointer or LRU count for FCBs */
	WORD	cluspos;	/* Position of last cluster accessed */
	WORD	lstclus;	/* Last cluster accessed */
	WORD	dirsec;		/* Sector number of directory sector
				 * for this file */
	BYTE	dirpos;		/* Offset of this entry in the above */
	BYTE	name[11];	/* 11 character name that is in the
				 * directory entry.
				 * This is used by close to detect file deleted
				 * and disk changed errors. */
	struct _sft far * chain;		/* link to next SF */
	WORD	uid;
	WORD	pid;
	WORD	mft;
} SFT, far * LPSFT;

typedef struct _sf {
	struct _sf far *link;
	WORD	count;		/* number of entries */
	SFT	table;		/* beginning of array of the following */
} SF, far * LPSF;

typedef struct {	/* MSDOS system infomation block */
	DWORD	dpb;		/* DPB chain */
	LPSF	sft;		/* SFT chain */
	LPDEV	clock;		/* CLOCK device */
	LPDEV	con;		/* CON device */
	WORD	maxsec;		/* max sector size */
	DWORD	buf;		/* BUFFER chain */
	DWORD	cds;		/* CDS list */
	DWORD	fcb;		/* FCB chain */
	WORD	keep;		/* keep count */
	BYTE	numio;		/* number of block devices */
	BYTE	ncds;		/* number of CDS */
	LPDEV	dev;	/* DEVICE list */
} SYSINFO, far *LPSYSINFO;

typedef struct {	/* vector array area */
	DWORD vec[256];		/* interrupt vectors */
} VECTOR;

typedef struct {	/* device link info */
	LPDEV	newdev;		/* new device driver */
	LPSFT	sft;		/* changed sft. if 0 no change */
	LPDEV	olddev;		/* original device */
	int	dd_flag;	/* if 0 dd_func not support */
} DEVINFO, far * LPDEVINFO;

#define	MAXDEVINFO	10

typedef struct {	/* DIDD infomation block */
	char sign[16];		/* signature */
	VECTOR vector;		/* interrupt vectors */
	LPDEV dev;		/* device link */
	LPDEV con;		/* console link */
	LPDEV clock;		/* clock link */
	int devcount;		/* how many device installed */
	DEVINFO	devinfo[MAXDEVINFO];	/* sft info table */
	WORD umbseg;		/* umb segment block address */ /* MSKK20*/
	char msreserve[32];	/* reserve area for MS */
	char oemreserve[128];	/* reserve area for OEM */
} SAVEINFO, far * LPSAVEINFO;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\typedef.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

typedef unsigned char *STR;

typedef char far *LPCHR;
typedef unsigned char far *LPSTR;

typedef short HANDLE;

typedef unsigned short SEG;
typedef unsigned short OFF;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\portliba.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
; Portliba  --  routines to support transport of lattice C to Cmerge
;
; Copyright (c) Microsoft Corporation, 1984
;
; This file contains:
;       ctlc                    - M000 Control-C handler
;       CritErr                 - DOS Critical Error (int 24) handler
;

;***    Modification History
;
;       M000    04/02/85        gregti
;
;     - Added routine ctlc that gets installed as a DOS int 23 handler.
;       See program header for details.
;
;       M001    04/04/85        gregti
;
;     - Fixed getcurdir to prepend the current drive, colon and root
;       path character to buffer before curdir call.  Also involved
;       change to msdos.inc
;-----------------------------------------------------------------------
;	MSKK01	June 1, 1987	akik
;		Modify to ADDDRV command
;-----------------------------------------------------------------------



                .xlist
include         cmacros.inc
                .list

                extrn   _on_sig:near            ; M000
                extrn   _old24:far

                public  _ctlc, _CritErr         ; M000
                public  ctlc, CritErr
;               public  _old24

                assumes cs, code
                assumes ds, data
                assumes ss, data

sbegin          code


;***  ctlc - Int 23 handler
;
; This routine calls actual signal handler routine in file SYNCSIGL.C
; and does IRET when that routine returns.
;
; return: Nothing
;
; calls: _on_sig in file SYNCSIGL.C
;
;
; void ctlc()
;
; Notes:
;       This routine does not use the cmacros.inc stuff because of the need
;       to do an IRET and save and restore the world.
;
ctlc    label   near
assume ds:nothing,es:nothing    ; Its an interrupt handler

_ctlc   proc    NEAR

                push    bp              ; Imitate cmacros
                mov     bp,sp
                push    ax              ; Save everything we can think of
                push    bx
                push    cx
                push    dx
                push    di
                push    si
                push    ds
                push    es
                push    ss
                mov     ax,01           ; Array index for _ON_SIG
                push    ax              ; _ON_SIG expects two args on stack
                push    ax
                call    _on_sig         ; Call actual handler
                pop     ax              ; Clear the two args
                pop     ax
                pop     ss              ; Restore everything we saved
                pop     es
                pop     ds
                pop     si
                pop     di
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                mov     sp,bp           ; Dup the cmacros stuff
                pop     bp
                iret                    ; Get back to DOS
_ctlc   endp

;***  CritErr - Int 24 handler
;
; This routine calls actual signal handler routine in file SYNCSIGL.C
; and does IRET when that routine returns.
;
; return: Nothing
;
; calls:
;        _on_sig in file SYNCSIGL.C
;        _old24  The MSDOS INT24 handler.
;
;
; void CritErr()
;
; Notes:
;       This routine does not use the cmacros.inc stuff because of the need
;       to do an IRET and save and restore the world.
;
;       It is written to be heavily application and system dependant:
;       It assumes that FAIL is never returned by the MSDOS INT24 handler
;       It assumes IGNORE and ABORT are equivilant and signals the APP on
;       either.
;

_CritErr   proc    NEAR
CritErr    label   near

                mov     ax,07           ; SIGHDERR for ON_SIG
                push    ax              ; _ON_SIG expects two args on stack
                push    ax
                call    _on_sig         ; Call actual handler
                pop     ax              ; Clear the two args
                pop     ax
;
		pop	ax
		pop	ax
		pop	ax
;
                pop     ax              ; Restore everything
                pop     bx
                pop     cx
                pop     dx
                pop     si
                pop     di
                pop     bp
                pop     ds
                pop     es
                iret                    ; Get back to DOS
_CritErr   endp

send            code


sbegin          data
send            data

                end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\syncsigl.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/***********************************************************************
 *
 *  SINCSIGL.C
 *
 *   public:
 *	set_sig_trap
 *	sig_stat
 *
 *  private:
 *	on_sig
 *	sig_flags
 *
 *  NOTE:
 *	After a signal invokes the handler, on_sig, the function sig_stat must
 *	be called to reenable that signal.  If this is not done soon, and many
 *	such signals occur, signals may be lost or overflow may occur.
 *	(This arrangement avoids loss of signals due to race conditions, but
 *	 is dependent on the os being able to handle an unlimited number of
 *	 signals of a given type.)
 *
 *  WARNING:
 *	    THIS MODULE MUST BE COMPILED WITH STACKPROBES DISABLED.
 *	    Since it contains Interrupt handlers that can be called from
 *	    within DOS (INT 24 time), __chkstk may not have consistent
 *	    information to work with.
 ***********************************************************************
 */
/***	Modification History
 *
 *	84/09/26  bryanwi	Original code
 *	84/12/06  bryanwi	Changed to handle signals with arguments, in
 *				accordance with new C signal interface.
 *				This adds a new argument to on_sig, which
 *				ignores it.
 *
 *	M000	04/02/85	gregti
 *
 *    - Added code to conditionally set up proper signal handling based
 *	on DOS version in use, ie. CTRL-C handling for pre 4.0 and signals
 *	for 4.0 and later.
 *
 *	M001	04/10/85	gregti
 *
 *    - Added definitions needed by above for get/set int vector and for
 *	the value of the int23 vector itself.
 *
 *	M002	06/06/86	alecb
 *
 *    - Fixed bug which resulted in possible corruption of the preserved int 24
 *	24 vector leading to a system crash if a floppy error occured during
 *	a restore operation.
 *----------------------------------------------------------------------
 *	MSKK01	June 1, 1987	akik
 *		Modify to ADDDRV command.
 *----------------------------------------------------------------------
 */

#include	"common.h"
#include	"types.h"

int (far *old23)();		/* M000 - Stores old int23 handler addr    */
int (far *old24)();		/* M002 - Stores old int24 handler addr    */

/* static array sig_flags is shared by the three functions in this file */
static int sig_flags[NSIG];



/*** set_sig_trap  --  set up synchronous signal trap
 *
 * Set_sig_trap inititalizes the static status variable for the indicated signal
 * to indicate that no such signal has yet occurred, and then calls signal to
 * establish on_sig as the handler for that signal.
 *
 * entry: sigtype  --  type of signal to set up for (See signal.h)
 *
 * externals: sig_flags
 *
 * effects: initializes sig_flags[sigtype], establishes on_sig as the handler
 *
 */
void set_sig_trap(sigtype)
	int	sigtype;
{
	void	on_sig();

	sig_flags[sigtype] = FALSE;

      /* Initialize Control C and INT 24 local handling. */
	switch (sigtype)
	{
	    case SIGINT:
		    setup23();
		break;

	    case SIGHDERR:
		    setup24();
		break;
	    default:;
	}
}



/*** on_sig  --  synchronous signal handler
 *
 * On_sig sets sig_flags[sigtype].
 *
 * entry: sigtype  --  type of signal which was raised
 *	  sigarg   --  argument associated with the signal
 *
 * externals: sig_flags
 *
 * effects: sets sig_flags[sigtype]
 *
 */
void on_sig(sigtype, sigarg)
	int	sigtype;
	int	sigarg;
{
	sig_flags[sigtype] = TRUE;
}



/*** sig_stat  --  report whether or not a given signal has occured
 *
 * Sig_stat checks sig_flags[sigtype] to see if that particular signal has
 * occured, if so, it returns true, otherwise false.  In either case
 * sig_flags[sigtype] will be reset.  After all this is done, on_sig will
 * be reestablished as the signal handler.
 *
 * entry: sigtype  --  type of signal to check on
 *
 * return: true if signal type sigtype has occurred, otherwise false
 *
 * externals: sig_flags
 *
 * effects: resets sig_flags[sigtype], reestablishes on_sig as handler
 *	    if the signal has been raised.
 *
 * warning: set_sig_trap MUST be called before this routine, or the results
 *	    sig_stat returns will be meaningless.  This constraint applies to
 *	    each kind of signal INDIVIDUALLY.
 *
 */
int sig_stat(sigtype)
	int	sigtype;
{
	int	tflag;

	tflag = sig_flags[sigtype];
	sig_flags[sigtype] = FALSE;
	return(tflag);
}



/* Setup23
 *
 *	    Setup23 installs the INT 23 handler ctlc.
 *
 *  INPUTS
 *	    None
 *
 *  RETURNS
 *	    None
 *
 *  SIDE EFFECTS
 *	    Int 23 vector set
 */
void	setup23()
{
	union REGS ir ;
	struct SREGS sr ;
	extern void ctlc() ;
	void (*pctlc)() = ctlc ;
	unsigned long pc = pctlc ;

	ir.h.ah = GETINT ;		/* 0x35 Get int vector		   */
	ir.h.al = INT23 ;		/* 0x23 Control-C interrupt	   */
	intdosx(&ir,&ir,&sr) ;

	FP_SEG(old23) = sr.es ; 	/* Old int23 handler ptr (seg)	   */
	FP_OFF(old23) = ir.x.bx ;	/* Old int23 handler ptr (off)	   */

	ir.h.ah = SETINT ;		/* 0x25 Set int vector		   */
	ir.h.al = INT23 ;		/* 0x23 Control-C interrupt	   */
	segread(&sr) ;			/* Get segment of ctlc()	   */
	sr.ds = sr.cs ; 		/* Load segment of ctlc()	   */
	ir.x.dx = FP_OFF(pc) ;		/* Load offset of ctlc()	   */
	intdosx(&ir,&ir,&sr) ;
}



/* reset23
 *
 *	    reset23 un-installs the INT 23 handler ctlc.
 *
 *  INPUTS
 *	    None
 *
 *  RETURNS
 *	    None
 *
 *  SIDE EFFECTS
 *	    Int 23 vector reset
 */

void	reset23()				/* M000 - Reset CTRL-C handler	   */
{
	union REGS ir ;
	struct SREGS sr ;

	ir.h.ah = SETINT ;		/* 0x25 Set int vector		   */
	ir.h.al = INT23 ;		/* 0x23 Control-C interrupt	   */
	sr.ds = FP_SEG(old23) ;
	ir.x.dx = FP_OFF(old23) ;
	intdosx(&ir,&ir,&sr) ;
}

/* Setup24
 *
 *	    Setup24 installs the INT 24 handler CritErr.
 *
 *  INPUTS
 *	    None
 *
 *  RETURNS
 *	    None
 *
 *  SIDE EFFECTS
 *	    Int 24 vector set
 */

void	setup24()
{
	union REGS ir ;
	struct SREGS sr ;
	extern void CritErr();
	void (*pCritErr)() = CritErr;
	unsigned long pCritHandler  = pCritErr;

	ir.h.ah = GETINT ;		/* 0x35 Get int vector		   */
	ir.h.al = INT24 ;		/* 0x23 Control-C interrupt	   */
	intdosx(&ir,&ir,&sr) ;

	FP_SEG(old24) = sr.es ; 	/* Old int23 handler ptr (seg)	   */
	FP_OFF(old24) = ir.x.bx ;	/* Old int23 handler ptr (off)	   */

	ir.h.ah = SETINT ;		/* 0x25 Set int vector		   */
	ir.h.al = INT24 ;		/* 0x23 Control-C interrupt	   */
	segread(&sr) ;			/* Get segment of CritErr()	   */
	sr.ds = sr.cs ; 		/* Load segment of CritErr()	   */
	ir.x.dx = FP_OFF(pCritHandler) ;/* Load offset of CirtErr()	   */
	intdosx(&ir,&ir,&sr) ;
}

/* reset24
 *
 *	    reset24 un-installs the INT 24 handler CritErr.
 *
 *  INPUTS
 *	    None
 *
 *  RETURNS
 *	    None
 *
 *  SIDE EFFECTS
 *	    Int 24 vector reset
 */
void	reset24()				/* M000 - Reset CTRL-C handler	   */
{
	union REGS ir ;
	struct SREGS sr ;

	ir.h.ah = SETINT ;		/* 0x25 Set int vector		   */
	ir.h.al = INT24 ;		/* 0x23 Control-C interrupt	   */
	sr.ds = FP_SEG(old24) ;
	ir.x.dx = FP_OFF(old24) ;
	intdosx(&ir,&ir,&sr) ;
}

/*--------------------------------------<SYNCSIGL.C end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\syncsigl.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	set_sig_trap(int);
void	on_sig(int, int);
int	sig_stat(int);
void	setup23(void);
void	reset23(void);
void	setup24(void);
void	reset24(void);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\types.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/*
 *   types.h - basic types for all zibo stuff
 *
 *	Modify to ADDDRV command.
 *	June 2, 1987	akik
 *
 */


#define NULL    0


#define GETINT  0x35            /* M001 - Get int vector                   */
#define SETINT  0x25            /* M001 - Set int vector                   */
#define INT23   0x23            /* M001 - Control-C interrupt              */
#define INT24   0x24

/*--------------------------------------<TYPES.H end>--*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\_msgret.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

void	sysloadmsg(union REGS *, union REGS *);
void	sysgetmsg(union REGS *, union REGS *);
void	sysdispmsg(union REGS *, union REGS *);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\adddrv\_msgret.asm ===
page	60,132								 ;AN000;
name	_msgret 							 ;AN000;
title	C	to Message Retriever					 ;AN000;

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	MODULE: 	_msgret 					 ;AN000;
;									 ;AN000;
;	PURPOSE:	Supplies an interface between C programs and	 ;AN000;
;			the DOS message retriever			 ;AN000;
;									 ;AN000;
;	CALLING FORMAT: 						 ;AN000;
;			sysloadmsg(&inregs,&outregs);			 ;AN000;
;			sysgetmsg(&inregs,&outregs);			 ;AN000;
;			sysdispmsg(&inregs,&outregs);			 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	DATE:		5-21-87 					 ;AN000;
;	Modified:	6/18/87 					 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;

	include version.inc
	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;
;									 ;AN000;
	MSG_UTILNAME <ADDDRV>		;IDENTIFY THE COMPONENT 	 ;AN000;
;									 ;AN000;
	.8087								 ;AN000;
_TEXT	SEGMENT BYTE PUBLIC 'CODE'					 ;AN000;
_TEXT	ENDS								 ;AN000;
_DATA	SEGMENT WORD PUBLIC 'DATA'					 ;AN000;
_DATA	ENDS								 ;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'					 ;AN000;
CONST	ENDS								 ;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'					 ;AN000;
_BSS	ENDS								 ;AN000;
DGROUP	GROUP	CONST, _BSS, _DATA					 ;AN000;
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP		 ;AN000;
;									 ;AN000;
	public	_sysloadmsg						 ;AN000;
	public	_sysgetmsg						 ;AN000;
	public	_sysdispmsg						 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
_DATA	segment 							 ;AN000;
.XLIST									 ;AN000;
.XCREF									 ;AN000;
;	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER ;AN000;
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER ;AN000;
.LIST									 ;AN000;
.CREF									 ;AN000;
_DATA	ends								 ;AN000;
;									 ;AN000;
;									 ;AN000;
_TEXT	segment 							 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
					;DEFAULT=CHECK DOS VERSION	 ;AN000;
					;DEFAULT=NEARmsg		 ;AN000;
					;DEFAULT=INPUTmsg		 ;AN000;
					;DEFAULT=NUMmsg 		 ;AN000;
					;DEFAULT=NO TIMEmsg		 ;AN000;
					;DEFAULT=NO DATEmsg		 ;AN000;
.XLIST									 ;AN000;
.XCREF									 ;AN000;
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg,FARmsg,TIMEmsg,DATEmsg> ;AN000;
	MSG_SERVICES <ADDDRV.CLA,ADDDRV.CLB,ADDDRV.CL1,ADDDRV.CL2> ;MSG TEXT ;AN000;
.LIST									 ;AN000;
.CREF									 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
_sysloadmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysloadmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysloadmsg endp							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_sysgetmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysgetmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysgetmsg endp 							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_sysdispmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysdispmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysdispmsg endp							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_TEXT	ends				; end code segment		 ;AN000;

	include msgdcl.inc

	end								 ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\append\appendm.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;      @@04 07/30/86 Fix second APPEND hang		 PTM P0000053
;      @@05 08/13/86 Fix bad parm message		PTM P0000125
;      @@10 08/28/86 Change message for @@05		PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G. PTM P0000479
cseg	segment public para 'CODE'
	assume	cs:cseg

	public	bad_append_msg			;@@11
	public	path_error_msg			;@@11
	public	parm_error_msg			;@@11
	public	path_parm_error_msg		;@@11
	public	no_append_msg			;@@11
	public	append_assign_msg		;@@11
	public	append_tv_msg			;@@11
	public	bad_DOS_msg			;@@11
	public	second_append_msg		;@@11

	public	len_bad_append_msg		;@@11
	public	len_path_error_msg		;@@11
	public	len_parm_error_msg		;@@11
	public	len_path_parm_error_msg 	;@@11
	public	len_no_append_msg		;@@11
	public	len_append_assign_msg		;@@11
	public	len_append_tv_msg		;@@11
	public	len_bad_DOS_msg 		;@@11
	public	len_second_append_msg		;@@11

cr	equ	13
lf	equ	10

include appendm.inc

cseg		ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\assign\assgmain.asm ===
PAGE	90,132			  ;
        TITLE   ASSGMAIN.asm - ASSIGN  MAIN PROGRAM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: ASSGMAIN.asm
;
; DESCRIPTIVE NAME: Reassigns drive specifications.
;
;FUNCTION: This program reassigns the specified drives to a new drive
;	   identifier.
;
; ENTRY POINT: ENTRY_POINT
;
; INPUT:
;
;   ASSIGN [DRIVE] [DELIMITER] [DRIVE] [SW]
;    where DRIVE = optional colon
;    where DELIMITER = +;=TAB LF SPACE
;    where SW = /STATUS or /STA
;
;    where:
;	 /STATUS - reports back to the user
;		   the currently changed
;		   drive assignments and the
;		   new assignment drive
;
;    Note:
;	  If a drive value has not been
;	  ASSIGN will report back nothing.
;
;    UTILITY FUNCTION:
;    Instructs DOS to route disk I/O
;    for one drive into disk I/O to another
;    drive.	 eg.
;		   a=c sets a: to c:
;
; EXIT-NORMAL:	Assigned drives or reassigned drives
;
; EXIT-ERROR:	Any one of the possible parse errors
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.asm)
;	       SYSLOADMSG
;	       SYSDISPMSG
;
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT  ASSPARM,NUL;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;        ASSIGN.asm
;
; REVISION HISTORY: AN000 - Version 4.00: PARSER, System Message Handler,
;					  Status report
;
; COPYRIGHT: "Microsoft DOS ASSIGN Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft"
;	     "Licensed Material - Program Property of Microsoft"
;
;
;	AN000	->		New Code
;
;	AN001	-> PTM P3954	Release the environmental vector and close
;				all handles.
;
;	AN002	-> PTM P3918	Parse error messages must conform to spec.
;				All parse error messages should display
;				the offending parameters.
;
;
;****************** END OF SPECIFICATIONS *****************************

;*********************************************
;*					     *
;*  UTILITY NAME:	ASSIGN.COM	     *
;*					     *
;*  SOURCE FILE NAME:   ASSIGN.asm           *
;*					     *
;*  STATUS:		ASSIGN utility	     *
;*			PC-DOS Version 3.40  *
;*					     *
;*  SYNTAX (Command line)		     *
;*					     *
;*  ASSIGN [DRIVE] [DELIMITER] [DRIVE] [SW]  *
;*   where DRIVE = optional colon	     *
;*   where DELIMITER = +;=TAB LF SPACE	     *
;*   where SW = /STATUS or /STA 	     *
;*					     *
;*   where:				     *
;*	 /STATUS - reports back to the user  *
;*		   the currently changed     *
;*		   drive assignments and the *
;*		   new assignment drive      *
;*   Note:				     *
;*	  If a drive value has not been      *
;*	  ASSIGN will report back nothing.   *
;*					     *
;*   UTILITY FUNCTION:			     *
;*   Instructs DOS to route disk I/O	     *
;*   for one drive into disk I/O to another  *
;*   drive.	 eg.			     *
;*		   a=c sets a: to c:	     *
;*********************************************

page
DEBUG	=	0

.xlist
	INCLUDE SYSMSG.INC		;AN000;
	INCLUDE SYSVAR.INC
	INCLUDE CURDIR.INC
	INCLUDE MULT.INC
	INCLUDE PDB.INC
	INCLUDE INT2A.INC

MSG_UTILNAME <ASSIGN>

.list

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	BREAK	<MACRO DEFINITIONS>
BREAK	MACRO	subtitle
.XLIST
	SUBTTL	subtitle
.LIST
	PAGE
	ENDM
.xcref	break
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
CallOperRange macro low,high,routine	;;NS-macro to call subroutines
?call	=	low			;;NS-in the given call range
					;;NS-starting call value = low #
rept	(high-low)+1			;;NS-calculate the entry point
	CallOper ?call,routine		;;NS-into the table then execute
	?call	= ?call + 1		;;NS-increment call value to next
endm
	endm
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
CallOper macro	call,routine		;;NS-macro that calls a single
					;;NS-subroutine that is used in
					;;NS-the above macro loop CallOperange
	ORG	(SysTab-ASSIGN_BASE)+(call*2) ;;NS-Calculate entry point into
	DW	OFFSET CODE:routine	;;NS-code where SysTab is the
	ENDM				;;NS-entry point to the tables
					;;NS-ASSIGN_BASE is at 0:0000
					;;NS-the (call*2) is calculated
					;;NS-to take into account two bytes
					;;NS-and final OFFSET statement points
					;;NS-code to be executed at the given
					;;NS-label
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;	$SALUT	(0,36,40,48)
MyINT21 macro				;;NS-macro used to save
	pushf				;;NS-the flags to maintain
	call	system			;;NS-DOS environment
	endm
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
SaveReg MACRO	reglist 		;; push those registers
IRP	reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH	reg
ENDM
ENDM
.xcref	SaveReg
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
RestoreReg MACRO reglist		;; pop those registers
IRP	reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP	reg
ENDM
ENDM
.xcref	RestoreReg

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
page
	BREAK	<DOS FUNCTIONS, AND OTHER EQUATES>
;	$SALUT	(0,23,28,41)
;		DOS FUNCTIONS USED
;			  (DEC) 	(HEX)
NO_ERROR equ	0			;return code zero from the parser
					;********** CNS *****************
;Std_Con_String_Output EQU 9		 ;  9
PSP_Env 		equ	2ch	;Environmental vector segment in PSP	;an001; dms;
Get_PSP 		equ	62h	; DOS function call to get PSP address	;an001; dms;
Handle_Close		equ	3eh	;close handle				;an001; dms;

Set_Default_Drive	EQU	14	;  E
Get_Default_Drive	EQU	25	; 19
Set_Interrupt_Vector	EQU	37	; 25
Get_Version		EQU	48	; 30
Keep_Process		EQU	49	; 31
Get_Interrupt_Vector	EQU	53	; 35
Get_Drive_Freespace	EQU	54	; 36
Exit			EQU	76	; 4C
Dealloc 		EQU	73	; 49
Get_In_Vars		EQU	82	; 52
Get_Set_Media_ID	equ	69h	; 69h

IOCTL_READ_BLOCK EQU 4404H		;READ FROM BLOCK DEVICE
IOCTL_WRITE_BLOCK EQU 4405H		;WRITE TO A BLOCK DEVICE
IOCTL_BLOCK_CHANGE EQU 4408H		;BLOCK DEVICE CHANGEABLE
IOCTL_BLOCK_REMOTE EQU 4409H		;BLOCK DEVICE REMOTE

;		VECTORS REFERENCED
PGM_TERM EQU	20H
DOS_CALL EQU	21H
CTL_BREAK EQU	23H
CRIT_ERR EQU	24H
ABS_DISK_READ EQU 25H
ABS_DISK_WRITE EQU 26H
stay	equ	27h			;NS  stay interrupt value
int_IBM EQU	2AH			;critical section maintenance
MULTIPLEXOR EQU 2FH			;MULTIPLEXOR INTERRUPT VECTOR NUMBER

;		CONSTANTS USED ACROSS THE MULTIPLEXOR INTERFACE
MPLEX_ID EQU	06H			;ID OF ASSIGN IN MPLEX CHAIN
MPLEX_R_U_THERE EQU 0			;MPLEX FUNCTION: ARE YOU THERE?
MPLEX_GET_SEG EQU 1			;MPLEX FUNCTION: GET SEG OF INSTALLED ASSIGN
MPLEX_INSTALLED EQU 0FFH		;"I AM HERE" RETURN VALUE

;		OTHER EQUATES
cr	equ	0dh			;CARRIAGE RETURN
LF	EQU	0AH			;LINE FEED
f_Interrupt EQU 0000001000000000B	;NS - mask used for interrupt
					;NS  value
	BREAK	<ENTRY POINT FOR CODE, EXTRNS>
;	$SALUT	(4,15,21,41)

code	segment para   public		;NS code all in one segment
assume	cs:code
					;   one segment

page

ASSIGN_BASE:				;NS- starting point of loaded file
	org	100h

ENTRY_POINT:
	jmp	INITIALIZATION		;JUMP TO INITIALIZATION
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	BREAK	<TABLES AND LOCAL WORKAREAS>
drives	db	1,2,3,4,5,6,7,8,9	;drive values used in comparison
	db	10,11,12,13,14,15,16,17,18,19 ;against default or found drive
	db	20,21,22,23,24,25,26
default_drive db ?
drive_save db	?			; saved drive byte
drive_address dw ?			; location (from DS) of drive byte
drive_save2 db	?			; second saved drive byte
;******************************************************************************
;******************************************************************************

system	dd	?
int25_vec dd	?			;NS - Hooks for the Int 2f handler preparation
int26_vec dd	?			;NS - Hooks for the Int 2f handler preparation
int2F_vec dd	?			;NS - Area to be hooked in and remain resident
user_ret dd	?			;     ???????????????????????????????????????
saveIntF dw	?			;     ???????????????????????????????????????
I21_Func db	?			; Save area for INT21 function requested -->RW


;	$SALUT	(4,9,23,41)
	EVEN
SysTab	label	word			;NS-Beginning of the call,subroutine table
	CallOper 00h,DoReset
	CallOperRange 01h,0Ch,DoNothing ; done ????????????????????????
	CallOper 0Dh,DoReset		; done ????????????????????????
	CallOper 0Eh,DoSetDefault
	CallOperRange 0Fh,17h,DoFCB	; done ????????????????????????
	CallOper 18h,DoReset		; done ????????????????????????
	CallOper 19h,DoGetDefault	;     ????????????????????????
	CallOperRange 1Ah,1Bh,DoReset	; done ????????????????????????
	CallOper 1Ch,DoDL		; done ????????????????????????
	CallOperRange 1Dh,20h,DoReset	; done ????????????????????????
	CallOperRange 21h,24h,DoFCB	; done ????????????????????????
	CallOperRange 25h,26h,DoReset	; done ????????????????????????
	CallOperRange 27h,28h,DoFCB	; done ????????????????????????
	CallOperRange 29h,31h,DoReset	; done ????????????????????????
	CallOper 32h,DoDL		; done ????????????????????????
	CallOperRange 33h,35h,DoReset	; done ????????????????????????
	CallOper 36h,DoDL		; done ????????????????????????
	CallOperRange 37h,38h,DoReset	; done ????????????????????????
	CallOperRange 39h,3Dh,DoAscii	; done ????????????????????????
	CallOperRange 3Eh,40h,DoReset	; done ????????????????????????
	CallOper 41h,DoAscii		; done ????????????????????????
	CallOper 42h,DoReset		; done ????????????????????????
	CallOper 43h,DoAscii		; done ????????????????????????
	CallOper 44h,DoIOCTL		; done ????????????????????????
	CallOperRange 45h,46h,DoReset	; done ????????????????????????
	CallOper 47h,DoDL		; done ????????????????????????
	CallOperRange 48h,4Ah,DoReset	; done ????????????????????????
	CallOper 4Bh,DoExec		; done ????????????????????????
	CallOperRange 4Ch,4Dh,DoReset	; done ????????????????????????
	CallOper 4Eh,DoAscii		; done ????????????????????????
	CallOperRange 4Fh,55h,DoReset	; done ????????????????????????
	CallOper 56h,DoRename		; done ????????????????????????
	CallOperRange 57h,59h,DoReset	; done ????????????????????????
	CallOperRange 5Ah,5Bh,DoAscii	; done ????????????????????????
	CallOperRange 5Ch,5Fh,DoReset	; done ????????????????????????
	CallOper 60h,DoTranslate	; done ????????????????????????
	CallOperRange 61h,63h,DoReset	; done ????????????????????????
	CallOperRange 64h,69h,DoSetGetMedia ;done ????????????????????????
	CallOperRange 6ah,6bh,DoNothing ;done ????????????????????????
	CallOper 6ch,DoAscii_DS_SI	;done ?????????????????????????
					; ????????????????????????
page
;	$SALUT	(4,5,11,36)
MAXCLL	EQU	6CH			; High bound of table

	org	(systab-ASSIGN_BASE) + (2 * (MAXCLL + 1)) ;NS - Beginning of code starts at
					;NS - Beginning of table + 128 bytes
	BREAK	<ASSIGN INTERRUPT HANDLER>
ASSIGN_HANDLER:
	mov	SaveIntf,f_interrupt	;NS- Move in the mask into a saved area
	SaveReg <AX,BX> 		;NS- ??????????????????????????????????
	cmp	ah,MAXCLL		; Do a high bound check on the call
					;  so we don't index past the end of
	ja	DoNothing		;  the table on a bogus call

	mov	al,ah			;NS-  Call must be in the 0 - 63h range
	cbw				;NS-  zero out the high byte now
					;NS-  AX has 0 & call number
	shl	ax,1			;NS-  Double the value in AX
	mov	bx,ax			;NS-  Move the value into BX to
	jmp	systab[bx]		;NS-  access the call number & subroutine
					;NS-  bx bytes into the tbl
;***********************************************************************************

EnterAssign:				;NS- make sure system intact by doing
	call	LeaveAllAssign		;NS- error recovery check

	push	ax			;NS- before making code
	mov	ax,8000h + critAssign	;NS- non- reentrant if unable
	INT	INT_IBM 		;(2AH) NS- to screen out successfully

	POP	AX			;NS- LeaveAllAssign will be executed
	RET				;return NS- and the critical section will be reset
;************************************************************************************
LeaveAssign:				;NS- restore re-entrancy to
	push	ax			;NS- the code after & only
	mov	ax,8100h + critAssign	;NS- after this call has been
	INT	INT_IBM 		;(2AH) NS- made or the error recovery

	POP	AX			;NS- call has been made
	RET				;return NS-

;************************************************************************************
LeaveAllAssign: 			;NS- Error recovery call
	push	ax			;NS- to restore the Assigns
	mov	ax,8908h		;NS- critical section
	int	INT_IBM 		;(2AH) NS- if ASSIGN has encountered

	pop	ax			;NS- a problem on entrance or departure
	RET				;return NS-
;************************************************************************************
;
; Reset the exclusion flag		;NS- Reset to Assign
;					;NS- critical section state
DoReset:				;NS-
	call	LeaveAllAssign		;NS-
					;NS-
;****************************************************************************************
;
; The system call needed no special processing.  Go do it directly.
;
DoNothing:				;NS-System registers and flags still
	RestoreReg <bx,ax>		;NS-intact it has not been clobbered
	jmp	system			;NS-by ASSIGN code

page
;************************************************************************************
;
; Munge the drive byte in an FCB pointed to by DS:DX.
; "MUNGE" ? (Webster will turn over in his gravy...)
;
DoFCB:
	mov	bx,dx			; indexable pointer
	mov	al,[bx] 		; get drive
	cmp	al,0ffh 		; extended fcb?
	jnz	DoMapDrive		; no

	add	bx,7			; yes, advance past it
	mov	al,[bx] 		; get read drive byte
DoMapDrive:
	or	al,al			; default drive?
;	$IF	Z			;YES
	JNZ $$IF1
	    mov     al,default_drive	; get default drive
;
; DS:BX points to the drive byte being munged.	AL is the old value.  Save
; it away.
;
;	$ENDIF				;AC000;
$$IF1:
					;SaveFCB:
	call	EnterAssign		; NS-Enter Assign's critical section

	mov	drive_save,al		; NS-save the drive assignment
	call	mapdrv1 		; NS-now let's map it to the

	mov	[bx],al 		; NS-numeric drive associated in
					; NS-in drive range 1 to 26
;******************************************************************************
; The FCB has been converted.  Now let's POP off the user's info and do the
; system call. Note that we are no longer reentrant!
;
	mov	drive_address,bx	; NS- location of drive value
	RestoreReg <BX,AX>		; get back original registers
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI 		; NS- Clear out old interrupts
					; NS- before an IRET is issued
					; NS- update the current
	call	system			; flags saved => this is a system call

	pushf				; NS- re-adjust the stack
	call	RestInt 		; NS- and setup the environment

	SaveReg <ax,bx> 		; NS- with drive and the drive address
	mov	bx,drive_address	; NS- before leaving the Assign critical
	mov	al,drive_save		; NS- section
	mov	[bx],al
	RestoreReg <bx,ax>
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign

	iret				; back to user

page
;************************************************************************************
;
; Munge the user's ASCIZ string at DS:DX.
;
DoAscii:
	mov	bx,dx			; point to area
	cmp	byte ptr [bx+1],':'	; drive letter present?
	jnz	DoNothing		; nope, ignore this
;
; There is a drive leter present.  Grab it and convert it
;
	mov	al,[bx] 		; get drive letter
	call	EnterAssign		; NS- Re-enter ASSIGN crit section

	mov	drive_save,al		; remember previous contents
	call	maplet			; convert to real drive letter

	mov	[bx],al 		; place in new drive letter
	mov	drive_address,bx
	RestoreReg <BX,AX>		; get back original registers
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI 		; clean up stack

	call	system			; flags saved => this is a system call

	pushf				; save all drive info
	call	RestInt 		; NS- clean up environment before

	SaveReg <ax,bx> 		; NS- returning to the user's environment
	mov	bx,drive_address	; NS- to ask on the next ASSIGN entrance
	mov	al,drive_save
	mov	[bx],al
	RestoreReg <bx,ax>
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign		; NS-  exit ASSIGN crit. section

	iret				; back to user


;************************************************************************************
;
; Munge the user's ASCIZ string at DS:SI.
;
DoAscii_DS_SI:
	mov	bx,si			; point to area
	cmp	byte ptr [bx+1],':'	; drive letter present?
;	$if	ne			; drive letter not present
	JE $$IF3
		jmp	DoNothing	; nope, ignore this
;	$endif				;
$$IF3:
;
; There is a drive leter present.  Grab it and convert it
;
	mov	al,[bx] 		; get drive letter
	call	EnterAssign		; NS- Re-enter ASSIGN crit section

	mov	drive_save,al		; remember previous contents
	call	maplet			; convert to real drive letter

	mov	[bx],al 		; place in new drive letter
	mov	drive_address,bx
	RestoreReg <BX,AX>		; get back original registers
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI 		; clean up stack

	call	system			; flags saved => this is a system call

	pushf				; save all drive info
	call	RestInt 		; NS- clean up environment before

	SaveReg <ax,bx> 		; NS- returning to the user's environment
	mov	bx,drive_address	; NS- to ask on the next ASSIGN entrance
	mov	al,drive_save
	mov	[bx],al
	RestoreReg <bx,ax>
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign		; NS-  exit ASSIGN crit. section

	iret				; back to user

page
;************************************************************************************

;
; DoDL - the drive to map is in DL.
;
DoDL:
	or	dl,dl			; NS- check for drive mapping
;	$IF	Z			;AC000;;USE DEFAULT DRIVE
	JNZ $$IF5

DNJ1:
	    jmp     DoNothing		; NS- default drive was requested
					; NS- thus no mapping needed
;	$ENDIF				;AC000;
$$IF5:
	mov	al,dl			; NS- not default case so no need doctor
	call	EnterAssign		; NS- so enter ASSIGN crit. section again

	mov	drive_save,al		; preserve old drive
	call	mapdrv1

	mov	dl,al			; drive is mapped
	RestoreReg <BX,AX>		; get back registers
	mov	I21_Func,ah		; Save requested function call -->RW
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI

	call	system			; flags saved => this is a system call

	pushf				;
	call	RestInt

	cmp	I21_Func,GET_DRIVE_FREESPACE ;(36h) If call returns info in DX, -->RW
					; NS- DL in both cases Func 36
					; NS- Func 1Ch are both used for
					; NS- drive input  we don't want to
					; NS- the old drives so they should not
					; restored as the old value - use ASSIGN's
	je	Dont_Restore_DL 	;AC000;;THEN DO CHANGE IT

	cmp	I21_Func,1ch		; If call returns info in DX, -->RW
					;(NOTE 1CH IS NOT DEFINED IN SYSCALL.INC. EK)
	je	Dont_Restore_DL 	;AC000;;THEN DO CHANGE IT

	mov	dl,drive_save		; restore his dl
					;DONT_RESTORE_DL:
Dont_Restore_DL:

	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign

	iret				; back to user
;************************************************************************************

; Map the IOCTL drives in BX		; NS- this section handles
					; NS- INT21 calls to get drive info
DoIOCTL:
	RestoreReg <BX,AX>
	SaveReg <AX,BX>
	cmp	ax,IOCTL_READ_BLOCK	;(4404h) IOCTL read string from block dev
	jz	DoMapBX 		;AC000;
					;    jz    DoMapBX
	cmp	ax,IOCTL_WRITE_BLOCK	;(4405h) IOCTL write string from block dev
	jz	DoMapBX 		;AC000;
					;    jz    DoMapBX
	cmp	ax,IOCTL_BLOCK_CHANGE	;(4408h) IOCTL is removable
	jz	DoMapBX 		;AC000;
					;    jz    DoMapBX
	cmp	ax,IOCTL_BLOCK_REMOTE	;(4409h) IOCTL block dev redir (network)
	jnz	DNJ2			;AC000;;NORMAL CALL
					;DoMapBX:
DoMapBX:

	or	bx,bx			; NS- drive letter associated in BL
	jz	DNJ2

	mov	al,bl			; not the default case
	call	EnterAssign

	mov	drive_save,al		; remember drive
	call	mapdrv1 		; NS- time to map drive to new assoc.

	mov	bl,al			; drive is mapped
	RestoreReg <AX,AX>		; get back registers (throw away BX)
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI

	call	system			; flags saved => this is a system call

	pushf
	call	RestInt

	mov	bl,drive_save		; restore his dl
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign

	iret				; back to user

DNJ2:

	jmp	DoNothing

DoSetGetMedia:
	RestoreReg <BX,AX>				;an000; dms;restore regs
	SaveReg <AX,BX> 				;an000; dms;save regs
	cmp	ah,Get_Set_Media_ID			;an000; dms;trap on get/set media id
;	$if	z					;an000; dms;found
	JNZ $$IF7
		or	bl,bl				;an000; dms;drive letter entered
;		$if	nz				;an000; dms;yes
		JZ $$IF8
			mov	al,bl			; not the default case
			call	EnterAssign

			mov	drive_save,al		; remember drive
			call	mapdrv1 		; NS- time to map drive to new assoc.

			mov	bl,al			; drive is mapped
			RestoreReg <AX,AX>		; get back registers (throw away BX)
			pop	word ptr user_ret	; restore his IP
			pop	word ptr user_ret+2	; restore his CS
			call	GotoCLI

			call	system			; flags saved => this is a system call

			pushf
			call	RestInt

			mov	bl,drive_save		; restore his dl
			push	word ptr user_ret+2	; push back user's cs
			push	word ptr user_ret	; push back user's ip
			Call	LeaveAssign
;		$else					;an000; dms;not valid function 69h
		JMP SHORT $$EN8
$$IF8:
			jmp	DoNothing		;an000; dms;pass to interrupt
;		$endif					;an000; dms;
$$EN8:
;	$else						;an000; dms;
	JMP SHORT $$EN7
$$IF7:
		jmp	DoNothing			;an000; dms;pass to interrupt
;	$endif						;an000; dms;
$$EN7:

	iret				; back to user
page
;************************************************************************************
;
; Map the drive letter and forget about it.  EXEC never returns.
;
DoExec:
	RestoreReg <BX,AX>
	SaveReg <AX,BX>
	or	al,al
;	$IF	Z			;AC000;;IS LOAD GO, NOT USE NORMAL STUFF
	JNZ $$IF13

	    mov     bx,dx		; point to area
DoOnce:
	    cmp     byte ptr [bx+1],':' ; drive letter present?
;	    $IF     Z			;AC000;;YES
	    JNZ $$IF14
;
; There is a drive leter present.  Grab it and convert it
;
		mov	al,[bx] 	; get drive letter
		call	maplet		; convert to real drive letter

		mov	[bx],al 	; place in new drive letter
;	    $ENDIF			;AC000;
$$IF14:
DNJ3:
	    jmp     DoNothing		; restore and go on!

;	$ENDIF
$$IF13:
					;DAJ:
	jmp	DoAscii

;************************************************************************************
;
; Map the drive letter at DS:SI.  We need to un-map it at the end.
;
DoTranslate:
	mov	bx,SI			; point to area
	cmp	byte ptr [bx+1],':'	; drive letter present?
	jnz	DNJ3			; nope, ignore this
;
; There is a drive leter present.  Grab it and convert it
;
	mov	al,[bx] 		; get drive letter
	call	EnterAssign

	mov	drive_save,al		; remember previous contents
	call	maplet			; convert to real drive letter

	mov	[bx],al 		; place in new drive letter
	mov	drive_address,bx
	RestoreReg <BX,AX>		; get back original registers
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI

	call	system			; flags saved => this is a system call

	pushf
	call	RestInt

	SaveReg <ax,bx>
	mov	bx,drive_address
	mov	al,drive_save
	mov	[bx],al
	RestoreReg <bx,ax>
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign

	iret				; back to user

page
;************************************************************************************
;
; Munge the user's ASCIZ string at DS:DX and es:di
;
DoRename:
	mov	bx,dx			; point to area
	mov	ax,[bx]
	call	EnterAssign

	mov	drive_save,al
	mov	drive_address,bx
	cmp	ah,':'			; drive letter present?
;	$IF	Z			;AC000;
	JNZ $$IF17

	    call    maplet		; convert to real drive letter

	    mov     [bx],al		; place in new drive letter
;	$ENDIF				;AC000;
$$IF17:
					;DoES:
	mov	ax,es:[di]		;NS- Get the 2nd drive from the command linepSOP
	mov	drive_save2,al		;NS- Save possible drive
	cmp	ah,':'			;NS- exclude if no colon present
;	$IF	Z			;AC000;
	JNZ $$IF19

	    call    maplet		;NS- go convert letter to actual drive #

	    mov     es:[di],al		;NS- new drive value
;	$ENDIF				;AC000;
$$IF19:
					;DoIt:
	RestoreReg <BX,AX>		; get back original registers
	pop	word ptr user_ret	; restore his IP
	pop	word ptr user_ret+2	; restore his CS
	call	GotoCLI

	call	system			; flags saved => this is a system call

	pushf
	call	RestInt

	SaveReg <ax,bx>
	mov	al,drive_save2		; NS- get the second drive update
	mov	es:[di],al		; NS- on the command line
	mov	bx,drive_address	;
	mov	al,drive_save		;
	mov	[bx],al 		;
	RestoreReg <bx,ax>		;
	push	word ptr user_ret+2	; push back user's cs
	push	word ptr user_ret	; push back user's ip
	Call	LeaveAssign

	iret				; back to user

;************************************************************************************
;
; DoGetDefault - return our idea of the current drive...
;
DoGetDefault:
	call	Assign_Check

;	$IF	Z			;AC000;
	JNZ $$IF21
					;DNJ4:
	    jmp     DoNothing

;	$ENDIF				;AC000;
$$IF21:
	RestoreReg <BX,AX>
	mov	al,default_drive
	dec	al
	iret

page
;************************************************************************************
;
; DoSetDefault - try to set to the mapped current drive.  If we can do it,
; then OK, else oops!
;
DoSetDefault:
	RestoreReg <BX,AX>
	mov	al,dl			; get new drive
	inc	al			; convert it to 1-based
	call	EnterAssign

	mov	drive_save,al		; remember what we're doing
	call	mapdrv1 		; convert drive

	dec	al			; convert back to 0-based
	mov	dl,al			; stick back in correct register
	mov	drive_save2,al		; remember more of what we're doing
	MyInt21 			; try the set

	push	ax			; save return info from set
	mov	ah,Get_Default_Drive	;(29h)
	MyInt21

	mov	dl,drive_save
	dec	dl			; Restore users original value
	cmp	al,drive_save2		; Did the set work?
;	$IF	Z			;AC000;;YES!
	JNZ $$IF23

	    mov     al,drive_save
	    mov     default_drive,al	; Set ours too, it's valid!
;	$ENDIF				;AC000;
$$IF23:
					;BadDrive:
	pop	ax			; Set return info
	call	LeaveAssign

	iret

;************************************************************************************
;
; Maintain the CLI state upon the next IRET.  Flags for the IRET are on the
; stack just under the return address.	This means saving the current state
; of the int flag and then turning off the saved version.
;
GotoCLI:
	push	ax
	push	bp
	mov	bp,sp
;	      bp  ax  ret  f
	mov	ax,[bp + 2 + 2 + 2]
	and	SaveIntf,ax		; save those interrupts
	and	word ptr [bp + 2 + 2 + 2],not f_interrupt
	pop	bp
	pop	ax
	ret
;
;************************************************************************************
; Restore he saved interrupt flag for the user.  His flags are on the stack
; just above the RET.
;
RestInt:
	push	ax
	push	bp
	mov	bp,sp
	mov	ax,SaveIntf
;	   bp  ax  ret	f
	or	[bp + 2 + 2 + 2],ax
	pop	bp
	pop	ax
	ret

;************************************************************************************
mapdrv0:				;a = 0 , b = 1
	inc	al
;	$IF	NZ			;AC000;
	JZ $$IF25

	    call    mapdrv1

;	$ENDIF				;AC000;
$$IF25:
					;Wrap0:
	dec	al
	ret

;************************************************************************************
mapdrv1:
	cmp	al,26
;	$IF	NA			;AC000;
	JA $$IF27

	    cmp     al,0		; check for default
;	    $IF     Z			;AC000;
	    JNZ $$IF28

		mov	al,default_drive
		mov	drive_save,al
;	    $ENDIF			;AC000;
$$IF28:

	    push    bx			;a = 1, b = 2
	    push    cx
	    mov     ch,ah
	    cbw
	    mov     bx,offset drives-1
	    add     bx,ax
	    mov     al,cs:[bx]
	    mov     ah,ch
	    pop     cx
	    pop     bx
;	$ENDIF				;AC000;
$$IF27:
	ret

;************************************************************************************
maplet:
	cmp	al,'A'
	jb	LetDone

	cmp	al,'Z'
	jbe	DoMapLet

	cmp	al,'a'
	jb	LetDone

	cmp	al,'z'
	ja	LetDone

DoMapLet:
	or	al,20h
	sub	al,"a"-1
	call	mapdrv1

	add	al,40h
LetDone:
	ret

page
;************************************************************************************
int25:
	call	mapdrv0

	jmp	int25_vec

int26:
	call	mapdrv0

	jmp	int26_vec

int2F:
	CMP	AH,mplex_id		;(06h) is this our multiplex?
;	$IF	NE			;AC000;;NO
	JE $$IF31

	    jmp     int2F_vec		; No, Chain to next guy

;	$ENDIF				;AC000;
$$IF31:
					;MINE:
	CMP	AL,mplex_get_seg	;(01h)
					;0 AND 1 ARE THE ONLY ALLOWED FUNCTIONS
;	$IF	NA			;AC000;;IF NOT SOME OTHER NUMBER,
	JA $$IF33
;	    $IF     E			;AC000;;IF FUNCTION REQUEST IS 01
	    JNE $$IF34
					;RETURN THE SEGID IN ES
		PUSH	CS
		POP	ES		; Call 1 gets our segment in ES
;	    $ENDIF			;AC000;
$$IF34:
					;QUER:
	    MOV     AL,MPLEX_INSTALLED	;(0FFh)  I AM here
;	$ENDIF
$$IF33:
					;RESERVED_RET:
	IRET

;************************************************************************************
assign_check:
	push	si
	push	ax
	push	cx
	xor	ax,ax
	mov	si,ax
	mov	cx,26
;	$SEARCH 			;AC000;
$$DO37:
					;scn:
	    mov     al,drives[si]
	    INC     SI
	    cmp     ax,si
;	$EXITIF NZ,NUL			;AC000;
	JNZ $$SR37

;	$ENDLOOP LOOP			;AC000;
	LOOP $$DO37

	    xor     ax,ax		; reset z flag
;	$ENDSRCH			;AC000;
$$SR37:
					;scndone:
	pop	cx
	pop	ax
	pop	si
	ret

prog_size =	($-ASSIGN_BASE+15)/16

page
;************************************************************************************
;			TRANSIENT CODE
;************************************************************************************
;*********************************************
;*					     *
;* Subroutine name: Initialization	     *
;*					     *
;* Purpose: Process the command line.	     *
;*	 If there are no errors update	     *
;*	 the drive table according to	     *
;*	 the drive assignments, terminate    *
;*	 and stay resident. If status switch *
;*	 set and the drive values have been  *
;*	 altered display drive is set to     *
;*	 2nd drive.			     *
;*					     *
;* Input: Command line (described in header) *
;*					     *
;* Output: Table will be updated and resident*
;*	   code will be hooked in.	     *
;*					     *
;* Normal Exit: Valid drives, sufficient     *
;*		memory. 		     *
;* Error Conditions:			     *
;*		Incorrect DOS Version	     *
;*		Invalid Parameter	     *
;*		Invalid switch		     *
;*Externals:				     *
;*	    PROCESS_PATH		     *
;*	    REPORT_STATUS		     *
;*	    EXIT_PROG			     *
;*					     *
;*********************************************
;    *****************************************
;    *		 INITIALIZATION 	     *
;    *****************************************
;    *					     *
;    *	CALL SYSLOADMSG 		     *
;    *	Do DOS Versinon Check		     *
;    *	CALL SYSDISPMSG 		     *
;    *	IF <> X.X then			     *
;    *	   Display message		     *
;    *	   Message number 1		     *
;    *	   (001 - Incorrect DOS Version)     *
;    *	   exit 			     *
;    *	.ENDIF				     *
;    *	   Continue			     *
;    *					     *
;    *	   Establish address of the	     *
;    *	   PDB environment		     *
;    *	   (Process Data Block )	     *
;    *	   .IF NO SPACE free de-allocate (49)*
;    *	       memory  at the environment    *
;    *	       address			     *
;    *	   .ENDIF			     *
;    *****************************************
;*******************************************************************************


	BREAK	<INITIALIZATION - NOT STAY RESIDENT>

	EXTRN	SYSPARSE:NEAR			;AN000;

ODDX			equ	01H		;AN000;
EVENX			equ	00H		;AN000;
PAD_CHAR		equ	' '		;AN000;
SEMICOLON		equ	';'		;AN000;
SPACE			equ	' '		;AN000;
EQUAL			equ	'='		;AN000;
PLUS			equ	'+'		;AN000;
good_parse_finish	equ	0ffffh		;an000;
;******************************************************************************
STATUS_ONLY	db	0			;AN000;
STRING_CTR	db	0			;AN000;
STATUS_FLAG	db	0			;AN000;
OPTIONS_FLAG	db	0			; non-0 if options wanted
ERR_CODE	db	0			;AN000;
POS_FLAG	db	'n'			;AN000;
PARMS_AVAIL	db	'n'			;AN000;
PAR_RETC	dw	0			;AN000; used for the return code
DRV_X		db	0			;AN000; from the parser
save_dr_tbl_ptr dw	?			;an000;drive table pointer
curr_es_seg	dw	?
Parm_Ptr1	dw	?			;an002;ptr to parse parm
Parm_Ptr2	dw	?			;an002;ptr to parse parm

inv		dd	?
STring		dd	?			;AN000;string holder


INCLUDE ASSGPARM.INC				;AN000;
INCLUDE ASSGMSG.INC				;AN000;


assume	cs:code, ds:code, ss:code, es:code

INITIALIZATION:

	push	ax				;an000; save ax
	mov	ax,ds				;an000; get the current ds
	mov	SEG_1,ax			;an000; set sublist table
	mov	SEG_2,ax			;an000; set sublist table
	pop	ax				;an000; restore ax

	call	SYSLOADMSG			;AN000; ;does DOS version check
;	$IF	C				;AN000;
	JNC $$IF41
						;remainder of info given
	    call    SYSDISPMSG			;AN000; ;by the msg retriever
							;message and exit

	    call    EXIT_PROG			;AC000; ;(4CH) Terminate function

;	$ENDIF
$$IF41:


page
;************************************* CNS ************************************
;    *****************************************
;    *		 INITIALIZATION 	     *
;    *****************************************
;    *					     *
;    *	Make internal DOS function call (52h)*
;    *	to process the data block	     *
;    *	information after mem is available   *
;    ******************************************
;************************************* CNS ************************************
					;OKDOS:
	mov	ax,ds:[pdb_environ]	;get your Process Data Block Address
	or	ax,ax			;check to see if space available
;	$IF	NZ			;AC000;
	JZ $$IF43
					;    jz    nofree
	    push    es			; save code segment value
	    mov     es,ax		; de-allocate memory
	    mov     ah,dealloc		;(49H)
	    int     DOS_CALL

	    pop     es			;restore code segment value

;	$ENDIF				;ACx00;
$$IF43:
					;nofree:

	push	es			;an000; save es
	mov	ah,Get_In_Vars		;(52H)
	int	DOS_CALL

	mov	Word ptr inv,bx
	mov	Word ptr inv+2,es
	pop	es			;an000; restore es

;******************************************************************************
;
;    *****************************************
;    *	    Establish addressability	     *
;    *	    to command line parms (DS:SI)    *
;    *	    Establish addressability to PARM *
;    *	    control block	  (ES:DI)    *
;    *					     *
;    *****************************************
;*******************************************************************************
					;parser es & ds now points at the command line
	cld				;clear the directional flag
					;decrement mode - maintanis pointer without
					;advancement

	mov	di,offset ASS_PARMS	;AC000; ;set index to the location of your PARAMETER
					;PARSER control block
	mov	si,81h			;AC000; ;set index to the beginning of the commandline
					;at 81h to the first 128 bytes
page
;******************************************************************************
;*	     PROCESS PATH
;******************************************************************************
;*********************************************
;*					     *
;*  Subroutine : Process_path		     *
;*  Function   : Process command line.	     *
;*		 Repeat searching for drive  *
;*		 spec. If valid update	     *
;*		 drive table.		     *
;*					     *
;*   Normal exit: End of line		     *
;*		  Parse error		     *
;*					     *
;*   Abort exit:  Invalid drive 	     *
;*					     *
;*********************************************
;    *****************************************
;    *					     *
;    *	WHILE PAR_RETC	eq NO_ERROR (0)      *
;    *	   CALL SYSPARSE		     *
;    *	   Case:			     *
;    *	    .IF (POSITIONAL)		     *
;    *	     Result is positional & Ctr even *
;    *	     INC CTR			     *
;    *	     CHECK_STRING		     *
;    *	      .IF the string is valid	     *
;    *		 valid drive		     *
;    *		 calculate table drv posit.  *
;    *		 based on the ascii value    *
;    *	       .ELSE			     *
;    *					     *
;    *		 PARSE ERROR		     *
;    *	       .ENDIF			     *
;    *	      Result is positional & CTR odd *
;    *	      save the ascii_value	     *
;    *	      Check the String		     *
;    *	      .IF the string is valid	     *
;    *		 valid drive		     *
;    *		 update the drive table      *
;    *	       .ELSE			     *
;    *					     *
;    *		 PARSE ERROR		     *
;    *	       .ENDIF			     *
;    *	     .ENDIF			     *
;    *	     INC CTR			     *
;    *****************************************

;******************************************************************************
	xor	cx,cx			;an000;  set cx to 0 for parse
	xor	dx,dx			;an000; set dx to 0 for parse

	mov	Parm_Ptr1,si		;an002; dms;ptr to 1st. parm
	mov	Parm_Ptr2,si		;an002; dms;ptr to 1st. parm
	call	SYSPARSE		;AN000; dms;priming parse
	mov	par_retc,ax		;AN000; dms;set flag

;	$DO
$$DO45:
	    CMP     ax,no_error 	;AN000;Is compare the return
;	$LEAVE	NE			;AN000;code 0 no error keep
	JNE $$EN45
					;AN000;parsing
	    call    CHK_PARSER		;AN000;

	    mov     Parm_Ptr2,si	;an002; dms;ptr to 1st. parm
	    call    SYSPARSE		;AN000;go parse the command line
	    mov     par_retc,ax 	;AN000; dms;set flag
					;AN000;restore the parm return code

;	$ENDDO				;AN000;
	JMP SHORT $$DO45
$$EN45:

; See if the user gave us /?
; If so, display the available options
; and exit.
;
; I gave this precedence over checking for parser errors,
; since the user may not have (yet) any idea of what the
; command syntax is supposed to be.
;
; Also, note that there is no message displaying function
; inside of ASSIGN, except for PARSE_ERR - which always
; uses the same message.  So the message displaying part
; of this block could be subroutine-ized.
;
; 4/17/90 - c-PaulB

	cmp	OPTIONS_FLAG, 0		; /? entered?
	je	OptionsDone		;  skip if not
	  call	DISPLAY_OPTIONS		; else display message
	  mov	ax, 0			; no error returned
	  call	EXIT_PROG		; let user try again
OptionsDone:

	cmp	ax,good_parse_finish	;an000; dms;see if a parse error
;	$if	ne			;an000; dms;if a parse error
	JE $$IF48
		push	ax		;an002; dms save ax
		mov	ax,Parm_Ptr2	;an002; dms;get original parm ptr
		mov	Parm_Ptr1,ax	;an002; dms;place in variable
		pop	ax		;an002; dms;restore ax
		call	PARSE_ERR	;an000; dms;display error & exit
;	$endif				;an000; dms;
$$IF48:

	cmp	PARMS_AVAIL,'y' 	;AN000;
;	$IF	E			;AN000; If there are parms available
	JNE $$IF50
	    cmp     ax,0		;AN000; see if the return code was no error
;	    $IF     G			;AN000; if greater than 0
	    JNG $$IF51
		mov	ax,parse10
		call	PARSE_ERR	;AN000; you got a parser error
					;AN000; so report & exit
;	    $ENDIF			;AN000; you also get an error
$$IF51:

	    xor     ax,ax		;AN000;
	    mov     al,String_ctr	;AN000;
	    mov     bx,0002h
	    div     bl			;AN000;

	    cmp     ah,EVENX
;	    $IF     NE			;AN000; if the drives did not pair off
	    JE $$IF53
		mov	ax,parse10
		call	PARSE_ERR
;	    $ENDIF			;AN000;
$$IF53:

	    cmp     POS_FLAG,'n'	;AN000;has a drive been specified
;	    $IF     E,AND		;AN000;and has a switch also been
	    JNE $$IF55
	    cmp     STATUS_FLAG,1	;AN000;specified if so hook in code
;	    $IF     E			;AN000;and then report status
	    JNE $$IF55
		mov	STATUS_ONLY,1	;AN000;set flag specifing user input full
;	    $ENDIF			;AN000;command line
$$IF55:
					;AN000; hook in the code
;	$ENDIF				;AN000;
$$IF50:

page

	cmp	STATUS_ONLY,0		;AN000;
;	$IF	E			;AN000;
	JNE $$IF58

		call	Get_Vectors	;get current vectors			;an001; dms;
		call	Set_Vectors	;set new vectors			;an001; dms;

;	$ELSE				;AN000;END of HOOK-IN
	JMP SHORT $$EN58
$$IF58:

	    call    REPORT_STATUS	;AN000;
	    call    EXIT_PROG		;AN000;

;	$ENDIF
$$EN58:
page
;*********************************** CNS ***************************************
	RELOAD_CURDIR PROC    NEAR

;*****************************************************************************
;
; We have an interesting problem here.	What if the user is assigning away
; his current drive?  Here's the solution:
;
;   o	We get the current drive here.
;   o	We reload the mapping table.
;   o	We set the current drive.
;
	MOV	AH,Get_Default_Drive	;(19H)
	INT	DOS_CALL

	PUSH	AX			; save away the table

	MOV	AX,(MPLEX_ID SHL 8)+MPLEX_GET_SEG ;(0601H) Get the SEG of the installed ASSIGN
	INT	MULTIPLEXOR		;(2FH)	in ES

	mov	si,offset drives	;move in the new drive table
	mov	di,si
	mov	cx,26			; move a-z
	CLI
	rep	movsb			;
	STI

	POP	DX			; restore the old current drive
	MOV	AH,Set_Default_Drive	;(0EH)
	INT	DOS_CALL

	call	EXIT_PROG		;go_home:

	INT	PGM_TERM		;(20H) Exit SHOULD not return, but be safe

	ret

	RELOAD_CURDIR ENDP
;*********************************** CNS ***************************************
;Input: Parser control block
;Output: Result Parser control block
;Register usage: AX,BX,CX,DX,ES,DS,SI,DI
;
;
;*********************************** CNS ***************************************

	CHK_PARSER PROC    NEAR

	xor	cx,cx				;an000; clear out cx
	xor	ax,ax				;AN000; clear out ax
	mov	al,String_ctr			;AN000; grab current assign ctr
	mov	bx,0002h			;an000; set bx to 2
	div	bl				;AN000; divide so we get rem.
	cmp	RES_TYPE,2			;an000; check for 1st drive
;	$IF	E,AND				;AN000; drive letter?
	JNE $$IF61
	cmp	ah,EVENX			;AN000; and no remainder?
;	$IF	E				;AN000;
	JNE $$IF61
	    inc     STRING_CTR			;AN000; increment counter
	    mov     PARMS_AVAIL,'y'		;AN000; signal parms entered
	    push    ax				;AN000; save ax
	    mov     al,res_itag 		;AN000; grab parm entered
	    mov     drv_x,al			;AN000; save it for later use
	    call    drvchk			;AC000; check for valid drive
	    cbw 				;AC000; convert drive byte found to a word
	    mov     bx,offset drives-1		;AC000; get the drive table
	    add     bx,ax			;AC000; get the drive address
	    mov     save_dr_tbl_ptr,bx		;an000; save the drive table pointer
	    pop     ax				;an000; restore ax
;	$ENDIF					;AN000;
$$IF61:

	cmp	RES_TYPE,2			;AN000; check for 2nd drive
;	$IF	E,AND				;AN000; drive entered?
	JNE $$IF63
	cmp	ah,EVENX			;AN000; and not first?
;	$IF	NE				;AN000;
	JE $$IF63
	    inc     STRING_CTR			;AN000; increment counter
	    mov     PARMS_AVAIL,'y'		;AN000; signal parms entered
	    push    ax				;AN000; save ax
	    mov     al,res_itag 		;AN000; grab parm entered
	    mov     drv_x,al			;AN000; save it for later use
	    call    drvchk			;AC000; if so see if it was valid
	    mov     bx,save_dr_tbl_ptr		;an000; set bx to drive table
	    mov     [bx],al			;AC000; if valid update the table
	    mov     POS_FLAG,'y'		;AN000; yes you have valid positionals
	    pop     ax				;an000; restore ax
	    mov     Parm_Ptr1,si		;an002; dms;ptr to 1st. parm
;	$ENDIF					;AN000;
$$IF63:

; Check for /switches

	PUBLIC	CheckSwitches
CheckSwitches:
	cmp	RES_SYN,0			;AN000; See if a switch was specified
;	$IF	NE				;AN000; If so,
	JE $$IF65

	; Check for /STATUS or /STA

	    cmp     [RES_SYN], offset SW_Syn1	; is it /STATUS?
	    je      SwitchStatus		; jump if so
	    cmp     [RES_SYN], offset SW_Syn2	; is it /STA?
	    je	    SwitchStatus
	    cmp     [RES_SYN], offset SW_Syn3	; is it /S?
	    jne	    SwitchStatusDone		; jump if not
SwitchStatus:
	    mov     STATUS_flag,1		;AN000; set the status flag on
	    mov     PARMS_AVAIL,'y'		;AN000; and report that a valid parameter
	    mov     byte ptr SW_Syn1,20h	;an000; remove switch from list
	    mov     byte ptr SW_Syn2,20h	;an000; remove switch from list
	    mov     byte ptr SW_Syn3,20h
	    mov     Parm_Ptr1,si		;an002; dms;ptr to 1st. parm
	    jmp     short $$IF65		; jump out of switches
SwitchStatusDone:

	; Check for /?

	    cmp     [RES_SYN], offset SW2_Syn	; is it /?
	    jne	    SwitchOptionsDone		; jump if not
	    mov     OPTIONS_flag,1		;  else set flag for later
	    jmp     short $$IF65		; jump out of switches
SwitchOptionsDone:

;	$ENDIF					;AN000; was on the command line
$$IF65:

	ret					;AN000;


	CHK_PARSER ENDP


;**************************************************************************
;
;Purpose: Display the options help message
;Input	: No value passed
;Registers affected: BX,CX,DX,AX
;
;Output : Message line(s) displayed.  No value returned.
;
;**************************************************************************

	PUBLIC	DISPLAY_OPTIONS
DISPLAY_OPTIONS PROC NEAR

	mov	ax, MSG_OPTIONS_FIRST	; message #
	mov	bx, stdout		; where to send it
	mov	cx, 0			; # of replaceable parms
	mov	si, 0			; offset of sublist
	mov	di, 0			; ptr to buffer for user input
	mov	dl, no_input		; no user input to mes. ret.
	mov	dh, utility_msg_class	; utility messages only
DO_LOOP:
	call	SYSDISPMSG		; go to message retriever
	cmp	ax, MSG_OPTIONS_LAST	; last message?
	je	DO_DONE			;  done if so
	inc	ax			; else, get next one
	jmp	short DO_LOOP		;  and go do it
DO_DONE:
	ret

DISPLAY_OPTIONS ENDP


page
;*********************************** CNS ***************************************
;
; check drive validity
;
drvchk:

	sub	al,"A"			; NS- error checking
;	$IF	NB			;AN000; ;if alphabetic,
	JB $$IF67

	    push    es
	    push    bx
	    push    ax

	    les     bx,inv
	    cmp     al,es:[bx].sysi_ncds	;AN000; ;NS- check in case current directory
;	    $IF     NAE 			;AN000; ;NS- has been altered
	    JAE $$IF68


		les	bx,es:[bx].sysi_cds
		push	bx
		mov	bl,size curdir_list
		mul	bl
		pop	bx
		add	bx,ax
		test	es:[bx].curdir_flags,curdir_inuse
;		$IF	NZ			;AC000;
		JZ $$IF69

		    pop     ax
		    pop     bx
		    pop     es
		    inc     al

		    ret

;		$ENDIF				;AC000; curdir in use?
$$IF69:
;	    $ENDIF				;AC000; curdir been altered?
$$IF68:
;	$ENDIF					;AC000; alphabetic?
$$IF67:

	mov	ax,parse10			;AN000; Invalid parameter
	call	PARSE_ERR			;an000; display the error & end

;*******************************  CNS *******************************************
;Purpose: Print the mapping status of the drive table.
;Input	: Drive table
;Registers affected: BX,CX,DX,AX
;
;Output : Display of all drive values stored not equal to their sequential
;	  storage address
;
;*******************************  CNS *******************************************
REPORT_STATUS PROC NEAR

	push	es				;an000; save es
	push	es				;an000; swap es with
	pop	ax				;an000;     ax
	mov	curr_es_seg,ax			;an000; save es in curr_es_seg

	mov	ax,0601h			;an000; our int 2fh
	int	2fh				;an000; returns segment of drive vector
	assume	es:nothing			;an000; tell the linker

	mov	cl,01				;AN000; ;initialize the counter
						;AN000; advance to next drive
	mov	bx,offset drives		;AN000; load drive table
;	$DO
$$DO73:
	    cmp     cl,26			;AN000; see if we scanned all drives

;	$LEAVE	A				;AN000; exit loop if we have
	JA $$EN73

	    cmp     cl,es:[bx]			;AN000; ;compare the table value
							;to the table contents
;	    $IF     NE				;AN000;
	    JE $$IF75
		push	bx			;an000; save bx - we stomp it
		push	cx			;an000; save cx - we stomp it
		mov	al,es:[bx]		;AN000; get the table contents to convert
		push	es			;an000; save es for print
		mov	bx,curr_es_seg		;an000; get the current segment
		mov	es,bx			;an000; get the segment into es
		assume	es:code 		;an000; tell linker it is code

		add	cl,40H			;AN000; convert to ascii representation
		add	al,40h			;an000; convert to ascii
		mov	OLD_DRV,cl		;AN000; place in parms for printing
		mov	NEW_DRV,al		;AN000;     by message retriever

		mov	ax,0002h		;an000; message #2
		mov	bx,stdout		;an000; print to standard out
		mov	cx,0002h		;an000; two replaceable parms
		mov	si,offset sublist1	;an000; offset of sublist
		mov	di,0000h		;an000; no buffer for user input
		mov	dl,no_input		;AN000; no user input to mes. ret.
		mov	dh,utility_msg_class	;an000; utility messages only

		call	SYSDISPMSG		;AN000; ;go to message retriever
		pop	es			;an000; restore es
		assume	es:nothing		;an000; tell the linker
		pop	cx			;an000; restore cx
		pop	bx			;an000; restore bx

;	    $ENDIF				;AN000;
$$IF75:

	    inc     bx				;an000; next drive in vector
	    inc     cl				;AN000; next letter to address

;	$ENDDO					;AN000;
	JMP SHORT $$DO73
$$EN73:
	pop	es				;an000; restore es
	assume	es:code 			;an000; tell the linker

	ret					;AN000;

REPORT_STATUS ENDP
page
;*******************************  CNS *******************************************
; Purpose: Exit program
; Input  : Error code AL
; Output : Error code AL
;
;*******************************  CNS *******************************************
EXIT_PROG PROC	NEAR



	mov	ah,EXIT 		;AC000;(4ch) RETURN TO DOS WITH ERRORLEVEL
	int	DOS_CALL		;AC000;


	ret				;AC000;

EXIT_PROG ENDP
;*******************************  CNS *******************************************

;=========================================================================
; PARSE_ERR		: This routine prints out the applicable parse
;			  error that is returned in AX by SYSPARSE.
;
;	Inputs		: AX - Parse error number to be printed
;	Outputs 	: Applicable parse error
;=========================================================================


PARSE_ERR	proc	near		;an000; dms;report an error

	push	ax			;an000;save ax
	mov	byte ptr ds:[si],0	;an002;null terminate string
	mov	dx,Parm_Ptr1		;an002;move ptr to sublist
	mov	Parse_Sub_Off,dx	;an002;
	mov	Parse_Sub_Seg,ds	;an002;

	mov	bx,STDERR		;an000;print to standard out
	mov	cx,1			;an002;1 replaceable parm
	mov	si,offset Parse_Sublist ;an002;sublist for replaceable parm
	mov	dl,NO_INPUT		;AN000;no input to message retriever
	mov	dh,PARSE_ERR_CLASS	;AN000;display parse errors
	call	SYSDISPMSG		;AN000;display error

	pop	ax			;AN000;restore errcode
	call	EXIT_PROG		;AN000;exit ASSIGN due to error


PARSE_ERR	endp			;an000; dms;

Release_Environment	proc	near						;an001; dms;

	push	ax			;save regs				;an001; dms;
	push	bx			;					;an001; dms;
	push	es			;					;an001; dms;
	mov	ah,Get_PSP		; get the PSP segment			;an001; dms;
	int	21h			; invoke INT 21h			;an001; dms;
	mov	es,bx			; BX contains PSP segment - put in ES	;an001; dms;
	mov	bx,word ptr es:[PSP_Env]; get segment of environmental vector	;an001; dms;
	mov	es,bx			; place segment in ES for Free Memory	;an001; dms;
	mov	ah,Dealloc		; Free Allocated Memory 		;an001; dms;
	int	21h			; invoke INT 21h			;an001; dms;
	pop	es			; restore regs				;an001; dms;
	pop	bx			;					;an001; dms;
	pop	ax			;					;an001; dms;

	ret				; return to caller			;an001; dms;

Release_Environment	endp

Close_Handles		proc	near	;close handles 0-4			;an001; dms;

	push	bx			;save regs				;an001; dms;
	mov	bx,4			;close all standard files		;an001; dms;

Close_Handle_Loop:

	mov	ah,Handle_Close 	;close file handle			;an001; dms;
	int	21h			;					;an001; dms;
	dec	bx			;next handle				;an001; dms;
	jns	Close_Handle_Loop	;continue				;an001; dms;

	pop	bx			;restore regs				;an001; dms;
	ret				;					;an001; dms;

Close_Handles		endp		;					;an001; dms;

Get_Vectors		proc	near	;get original vectors			;an001; dms;

	    mov     ax,(GET_INTERRUPT_VECTOR SHL 8)+ABS_DISK_READ ;(3525h) get the int 25 vector
	    int     DOS_CALL

	    mov     word ptr [int25_vec],bx
	    mov     word ptr [int25_vec+2],es

	    mov     ax,(GET_INTERRUPT_VECTOR SHL 8)+ABS_DISK_WRITE ;(3526H) get the int 26 vector
	    int     DOS_CALL

	    mov     word ptr [int26_vec],bx
	    mov     word ptr [int26_vec+2],es

	    mov     ax,(GET_INTERRUPT_VECTOR SHL 8)+MULTIPLEXOR ;(352FH) get the int 2F vector
	    int     DOS_CALL

	    mov     word ptr [int2F_vec],bx
	    mov     word ptr [int2F_vec+2],es

	    mov     ax,(Get_Interrupt_Vector SHL 8)+DOS_CALL ;(3521H)
	    int     DOS_CALL

	    mov     word ptr cs:[system],bx
	    mov     word ptr cs:[system+2],es

	    MOV     AX,(MPLEX_ID SHL 8)+MPLEX_R_U_THERE ;(0600H) See if we are in system already
	    INT     MULTIPLEXOR 	;(2FH)

	    OR	    AL,AL
;	    $IF     NZ			;AC000; NOT INSTALLED
	    JZ $$IF78

		call	RELOAD_CURDIR	;AC000;

;	    $ENDIF
$$IF78:

	ret				;					;an001; dms;

Get_Vectors		endp		;					;an001; dms;


Set_Vectors		proc	near	;set to new vectors			;an001; dms;

	    mov     ah,Get_Default_Drive ;(19H)
	    int     DOS_CALL

	    inc     al
	    mov     [default_drive],al	;NS- add one to the value to get the
	    call    mapdrv1		;NS- actual drive value before mapping

	    dec     al			;NS- dec one to setup for select function
	    mov     dl,al		;select its replacement
	    mov     ah,Set_Default_Drive ;(0EH)
	    int     DOS_CALL
					;NS- Set up hooks
	    mov     dx,offset int25	;set int 25 vector
	    mov     ax,(SET_INTERRUPT_VECTOR SHL 8) + ABS_DISK_READ ;(2525H)
	    int     DOS_CALL
					;NS- setup new seg
	    mov     dx,offset int26	;set int 26 vector
	    mov     ax,(SET_INTERRUPT_VECTOR SHL 8) + ABS_DISK_WRITE ;(2526H)
	    int     DOS_CALL
					;NS- Hook in resident portion
	    mov     dx,offset int2F	;set int 2F vector
	    mov     ax,(SET_INTERRUPT_VECTOR SHL 8) + MULTIPLEXOR ;(252FH)
	    int     DOS_CALL

	    mov     dx,offset ASSIGN_HANDLER ;set the system int vector
	    mov     ax,(SET_INTERRUPT_VECTOR SHL 8) + DOS_CALL ;(2521H)
	    int     DOS_CALL

	    call    Close_Handles	;close handles 0-4			;an001; dms;
	    call    Release_Environment ;release the environmental vector	;an001; dms;

	    mov     dx,prog_size	;end but stay resident
	    mov     ah,KEEP_PROCESS	;(31h) NS- ASSIGN loaded in mem
	    int     DOS_CALL

	ret				;					;an001; dms;

Set_Vectors		endp		;					;an001; dms;



.xlist
MSG_SERVICES <MSGDATA>
msg_services <NEARmsg>
msg_services <LOADmsg>
msg_services <DISPLAYmsg,CHARmsg>
msg_services <assign.cla,assign.cl1>
msg_services <assign.cl2>
.list

include msgdcl.inc

code	ends
	end	ENTRY_POINT

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\append\append.asm ===
page	60,120
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
.sall
title	APPEND
include sysmsg.inc
include version.inc
msg_utilname<APPEND>
;-----------------------------------------------------------------------------
;
;      Title:	       APPEND
;
;      Author:	       G. G. A. 		     Network version
;		       B. A. F.`		     DOS changes
;
;      Syntax:	       From the DOS command line:
;
;		       APPEND [d:]path[[;[d:]path]...]
;			     - Used to specify the directories to be
;			       searched after the working directory.
;
;		       APPEND ;
;			     - Used to release all appended directories.
;
;		       APPEND
;			     - Used to show appended directories.
;
;		       First time only:
;
;		       APPEND  [[d:]path |  | /X | /E | /X /E]
;			     - [d:]path Normal support and Set path
;			     -		Normal support
;			     - /X	Extended support, SEARCH, FIND and EXEC
;			     - /E	Use DOS Environment for path(s)
;
;      Revision History:
;      @@01 07/11/86 Fix hang in TopView start			    PTM P00000??
;      @@02 07/28/86 Fix APPEND size problem			    PTM P0000045
;      @@03 07/29/86 Fix APPEND status with /E problem		    PTM P00000??
;      @@04 07/30/86 Fix second APPEND hang			    PTM P0000053
;      @@05 08/13/86 Fix parameter error			    PTM P0000125
;      @@06 08/20/86 Fix APPEND xxx fails in TopView		    PTM P0000217
;      @@07 08/21/86 Resurrect APPEND version message		    PTM P0000252
;      @@08 08/21/86 APPEND=path first time hangs		    PTM P0000254
;      @@09 08/22/86 APPEND gets wrong path under nested COMMAND    PTM P0000276
;      @@10 08/28/86 Change message for @@05			    PTM P0000291
;      @@11 09/10/86 Support message profile and make
;		     msg length variable.	R.G.		    PTM P0000479
;      @@12 09/25/86 Allow second external append call. (RG)	    PTM P0000515
;      @@13 09/30/86 APPEND gets wrong path under nested COMMAND    PTM P0000600
;		     Again. Fix in COMMAND now, so remove @@09 changes
;      @@14 10/01/86 Lower case drive in path files		    PTM P0000600
;      @@15 10/06/86 Include "," and "=" in skip leading of
;		     argument area parsing.			    PTM P0000677
;      @@16 10/06/86 Fix not using full APPEND path		    PTM P0000794
;      @@17 12/03/86 When searching for "APPEND=" string in
;		     environment, make sure delimiter precedes.(RG) PTM P0000893
;
;-------------------------------------------------------------------
;
;      AN000	     3.30 changes, GGA 6/87 new code.			P000
;      AN001	     Support DRIVE and PATH modes			D043
;      AN002	     Add truename function				P1276
;      AN003	     Add extended handle open function			D250
;      AN005
;      AN006	     Add DBCS support
;      AN007	     Release Environmental Vector space 		P2666
;      AN008	     Allow equal symbol with append - APPEND=A:/1;	P2901
;      AN009	     Release Environmental Vector on only the		P3333
;		     first invocation of APPEND
;      AN010	     display invalid parm from command line		P3908
;
;
;-----------------------------------------------------------------------------
;Date	       Rev     Comments
;-----------------------------------------------------------------------------
;06-02-86      0.0     Begin conversion to PC/DOS version
;06-20-86      0.0     End conversion to PC/DOS version
;
page

cseg		segment public para 'CODE'
		assume	cs:cseg
		assume	ds:nothing,es:nothing

;-----------------------------------------------------------------------------
;	Equates
;-----------------------------------------------------------------------------

.xlist
;include fsi.lib
NETSYSUTIL   EQU  0C2H			; SYSTEM UTILITIES
NETENQ	     EQU  07H			; ENQ RESOURCE
NETDEQ	     EQU  08H			; DEQ RESOURCE
;include task.lib
TCBR_APPEND	EQU	   001H 	; APPEND ACTIVE
;include DOS.lib
DOSSERVER    EQU  5DH			; SERVER OPERATION
DOSSETERROR  EQU  0AH			; SET EXTENDED ERROR
;include server.lib
DPL		STRUC
DPL_AX		DW	0		;AX REG
DPL_BX		DW	0		;BX REG
DPL_CX		DW	0		;CX REG
DPL_DX		DW	0		;DX REG
DPL_SI		DW	0		;SI REG
DPL_DI		DW	0		;DI REG
DPL_DS		DW	0		;DS REG
DPL_ES		DW	0		;ES REG
DPL_XID 	DW	0		;RESERVED
DPL_UID 	DW	0		;SERVER USER ID
DPL_PID 	DW	0		;REDIRECTOR PROCESS ID
DPL		ENDS
include sysmac.lib
include versiona.inc
include appendp.inc			; parseing stuff for append			 ;AN004;
.list
;		extrn	end_address:near	; end of stay resident stuff

;		extrn	bad_append_msg:byte	; messages
;		extrn	path_error_msg:byte
;		extrn	parm_error_msg:byte
;		extrn	path_parm_error_msg:byte
;		extrn	no_append_msg:byte		; @@05
;		extrn	append_assign_msg:byte
;		extrn	append_TV_msg:byte		; @@01
;		extrn	bad_DOS_msg:byte
;		extrn	second_APPEND_msg:byte		; @@04

;		extrn	len_bad_append_msg:word 	;@@11
;		extrn	len_path_error_msg:word 	;@@11
;		extrn	len_parm_error_msg:word 	;@@11
;		extrn	len_path_parm_error_msg:word	;@@11
;		extrn	len_no_append_msg:word		;@@11
;		extrn	len_append_assign_msg:word	;@@11
;		extrn	len_append_TV_msg:word		;@@11
;		extrn	len_bad_DOS_msg:word		;@@11
;		extrn	len_second_APPEND_msg:word	;@@11

;	Environmental Vector

PSP_Env 	equ	2ch		;Environmental vector segment in PSP	;an007; dms;

;	Interrupts

DOS_function	equ	21h		; DOS function call interrupt
int_function	equ	2fh		; DOS internal function interrupt, used
					; to verify APPEND presence
termpgm 	equ	20h						; @@05
resident	equ	27h

;	Function calls

get_vector	equ	3521h		; DOS function call to get INT 21 vector
set_vector	equ	2521h		; DOS function call to set INT 21 vector
get_intfcn	equ	352fh		; DOS function call to get INT 2f vector
set_intfcn	equ	252fh		; DOS function call to set INT 2f vector
get_version	equ	30h		; DOS function call to get DOS version number
get_DTA 	equ	2fh		; DOS function get DTA
set_DTA 	equ	1ah		; DOS function set DTA
get_crit_err	equ	3524h		; DOS function call to get INT 24 vector
set_crit_err	equ	2524h		; DOS function call to set INT 24 vector
get_PSP 	equ	62h		; DOS function call to get PSP address
Free_Alloc_Mem	equ	49h		; DOS function call to free alloc. mem. ;an007; dms;

print_string	equ	09h		; DOS function call to get print a string
ctrl_break	equ	33h		; DOS function call to get/set ctrl-break

awrite		equ	40h		; write function
get_dir 	equ	47h		; get current dir
change_dir	equ	3bh		; change dir
get_disk	equ	19h		; get current disk
change_disk	equ	0eh		; change disk
term_stay	equ	31h		; terminate a process and stay resident
term_proc	equ	4ch		; terminate a process

redir_flag	equ	0000000000001000B ; redir flag for net installation check

;	DOS INT 2f function for APPEND presence

append_2f	equ	0b7h		; int 2f function code for append
applic_2f	equ	0aeh		; int 2f function code for applications
COMMAND_2f	equ	-1		; int 2f subfunction code for COMMAND call
append_inst	equ	0ffh		; flag means append is there

;	INT 2f sub-function codes						;AN000;

are_you_there	equ	0		; function code for presence check
old_dir_ptr	equ	1		; means APPEND 1.0 is trying to run
get_app_version equ	2		; fun code for get ver request
tv_vector	equ	3		; fun code for set TV vector
dir_ptr 	equ	4		; function code to return dirlist ptr
get_state	equ	6		; function code to return append ;AN001;
					; state 			 ;AN001;
set_state	equ	7		; function code to set append	 ;AN001;
					; state 			 ;AN001;

DOS_version	equ	10h		; function call to get DOS version
true_name	equ	11h		; one-shot truename fcn for ASCIIZ ops ;AN002;

;	DOS INT 21 function calls that APPEND traps

FCB_opn 	equ	0fh
file_sz 	equ	23h
handle_opn	equ	3dh
dat_tim 	equ	57h
FCB_sch1	equ	11h
handle_fnd1	equ	4eh
exec_proc	equ	4bh
ext_handle_opn	equ	6ch								  ;AN003;

break	macro			; this is a dummy break macro so PDB.INC
	endm			; won't blow up in the build

;	define some things for PDB (PSP)						  ;AN002;
											  ;AN002;
include pdb.inc 									  ;AN002;
											  ;AN002;
true_name_flag		equ	01h	; flag for true name function			  ;AN002;
eo_create		equ	00f0h	; mask to check extended opens for create	  ;AN003;

;	Error codes that don't mean stop looking

FCB_failed		equ	0ffh	; FCB open failed
FCB_file_not_found	equ	2	; file not found on FCB open
handle_file_not_found	equ	2	; file not found on handle open
handle_path_not_found	equ	3	; path not found on handle open
FCB_no_more_files	equ	18	; no more matching files
handle_no_more_files	equ	18	; no more matching files

;	Equates for TOPVIEW barrier
TV_TRUE equ	-1			; this was changed from TRUE	 ;AN000;
					; because 3.30 parser uses TRUE  ;AN000;
false	equ	0			;

;	Message equates

tab_char equ	9
cr	equ	13
lf	equ	10
beep	equ	7
STDOUT	equ	0001h			; standard output file
STDERR	equ	0002h			; standard error file
null	equ	0

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     316

page

;-----------------------------------------------------------------------------
;	Resident data area
;-----------------------------------------------------------------------------

version_loc:				; version number
	db	major_version,minor_version
;	 dw	 message_list		 ; pointer to message table

		even
vector_offset	dw	0		; save pointer to old int 21 here
vector_segment	dw	0
crit_vector_offset  dw	0		; save pointer to old int 24 here
crit_vector_segment dw	0
intfcn_offset	dw	0		; save pointer to old int 2f here
intfcn_segment	dw	0
dirlst_offset	dw	0		; save pointer to dir list here
dirlst_segment	dw	0
tv_vec_off	dw	0		; save TV vector here
tv_vec_seg	dw	0

pars_off	dd	cseg: SysParse	; save pointer to parser here
;pars_off	 dw	 offset SysParse ; save pointer to parser here
;pars_seg	 dw	 0

app_dirs_seg	dw	0		; save ES here during FCB

FCB_ptr 	dd	0		; save pointer to FCB here
handle_ptr	dd	0		; save pointer to ASCIIZ string here

stack_offset	dw	0
stack_segment	dw	0		; Calling process stack

incoming_AX	dw	0		; AX saved at entry to interrupt handler
incoming_CX	dw	0		; CX saved at entry to interrupt handler
; must be together
incoming_BX	dw	0		; BX saved at entry to interrupt handler
incoming_ES	dw	0		; ES saved at entry to interrupt handler
; must be together
ax_after_21	dw	0		; AX saved after call to real INT 21
; temp_DS_save	  dw	  0		  ; DS saved during stack ops
temp_CS_save	dw	0		; CS saved during stack ops (set_return_flags)
temp_IP_save	dw	0		; IP saved during stack ops (set_return_flags)
FCB_drive_id	db	0		; save the drive id for FCB opens here

;------------------------
;	DBCS stuff here 								 ;AN006;
											 ;AN006;
DBCSEV_OFF	DW	0		; OFFSET OF DBCS EV				 ;AN006;
DBCSEV_SEG	DW	0		; SEGMENT OF DBCS EV				 ;AN006;
											 ;AN006;
;DEFAULT DBCS ENVIRONMENTAL VECTOR							 ;AN006;
EVEV	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
	DB	00H,00H 								 ;AN006;
											 ;AN006;
dbcs_fb 	dw	0		; offset of DBCS first byte chars found
;------------------------

initial_pass	dw	0		; flag used to indicate inital APPEND		 ;AN007;

incoming_DX	dw	0		; used for saves for extended open		  ;AN003;
incoming_SI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DI	dw	0		; used for saves for extended open		  ;AN003;
incoming_DS	dw	0		; used for saves for extended open		  ;AN003;
true_name_count dw	0		; used to save number of chars in true_name dir   ;AN003;

int_save_ip	dw	0		; save registers here during critical
int_save_cs	dw	0		; error handler stack ops

work_disk	db	"?:\"		; user's working disk
work_dir	db	64 dup(" ")	; user's working dir
app_disk	db	"?:\"		; user's working disk
app_dir 	db	64 dup(" ")	; user's append disk's working dir
ctrl_break_state db	0		; save the old ctrl-break state here

end_search	db	0		; end search flag
try_dir 	db	128 dup (0)	; try this dir
fname		db	15 dup (0)	; 8.3 filename stripped from original
					; ASCIIZ string
app_dirs_ptr	dw	0		; pointer to appended dir to try

set_name	db	"SET     "	; SET command
; must be together
setappend_name	db	"SET "		; SET command
append_id	db	"APPEND="	; display from here for user
; must be together
app_dirs	db	";"
		db	128 dup (0)	; area for storing appended dirs
		db	0		; just to insure that the last dir is null terminated
semicolon	db	";",0		; null list

;	Flags / barriers added for TopView

tv_flag 	db	0		; flag to indicate re-entr from TopView

parse_flag	db	0		; flag used by APPEND parsing

FCB_ext_err	db	0		; flag used to indicate that FCB
					; open failed and ext err was done
crit_err_flag	db	0		; flag used to indicate that a critical
					; error happened
ext_err_flag	db	0		; flag used to indicate that ext err
					; must be set 0 = don't set, 1 = do set
in_middle	db	0		; flag used to tell if we made it to
					; middle of string before finding a space
equal_found	db	0		; multiple = check
;crit_sect_flag  db	 0		 ; critical section flag

stack_area	dw	99 dup(0)	; stack area for append
append_stack	dw	0

net_config	dw	0		; flag word for what (if any) network
					; config we are running under
					; as long as this word is zero, a clear determination
					; has not been made about the configuration

		even
ext_err_dpl	DPL	<>		; reserve a DPL for get/set extended error code


save_ext_err	DPL	<>		; reserve a DPL for first extended
					; error code

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	mode_flags	This status word is used to control the various  ;AN001;
;			APPEND functions and modes.			 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
mode_flags	dw	Path_mode + Drive_mode + Enabled		 ;AN001;
					; mode control flags		 ;AN001;
					; initially - path, drive and	 ;AN001;
					; enabled			 ;AN001;

;	equates for mode_flags follow:					 ;AN001;

X_mode		equ	8000h		; in /X mode
E_mode		equ	4000h		; in /E mode
Path_mode	equ	2000h		; PATH in string OK		 ;AN001;
Drive_mode	equ	1000h		; DRIVE in string OK		 ;AN001;
Enabled 	equ	0001h		; APPEND enabled		 ;AN001;

;-------------------------------------------------------------------

cmd_name@	dd	?		; internal name string

expected_error	dw	?		; error to do append scan
expected_ext_error dw	?		; error to do append scan

cmd_env 	dw	?		; pointer to COMMANDs environment
cmd_buf 	dw	?		; CMDBUF offset (in SS)

incoming_DTA	dd	?		; user's DTA (on EXEC)
exec_DTA	db	21+1+2+2+2+2+13 dup(0)	; find DTA for exec emulation

old_syntax	db	0		; using network syntax

res_append	db	0		; resident append call		  ; @@05

abort_sp	dw	?		; sp to restore on errors	  ; @@05

crlf	label	byte
	db	CR,LF
crlf_len equ	 $ - crlf

;*******************************************************************		;an010;bgb
; parser message display area							;an010;bgb
;*******************************************************************		;an010;bgb
inv_parm    db	0bh	;length 						;an010;bgb
	    db	0	;reserved						;an010;bgb
si_off	    dw	0	;put offset of command line here			;an010;bgb
si_seg	    dw	0	;put segment of command line here			;an010;bgb
	    db	0	;use percent zero					;an010;bgb
	    db	Left_Align+Char_Field_ASCIIZ ;type of data			;an010;bgb
	    db	128			;max width				;an010;bgb
	    db	1			;min width				;an010;bgb
	    db	' '			;pad char				;an010;bgb

;-------------------------------------------------------------------
;
;	resident message area
;
;-------------------------------------------------------------------

MSG_SERVICES <MSGDATA>
MSG_SERVICES <DISPLAYmsg,CHARmsg>						;an010;bgb
MSG_SERVICES <APPEND.CLA,APPEND.CL1,APPEND.CTL>

.xlist
;-----------------------------------------------------------------------------
;	macros
;-----------------------------------------------------------------------------

;-----------------------------
;	save and restore register macros
save_regs macro
	push	bx
	push	cx
	push	dx

	push	di
	push	si
	push	ds
	push	es
	endm

restore_regs macro
	pop	es
	pop	ds
	pop	si
	pop	di

	pop	dx
	pop	cx
	pop	bx
	endm

;-----------------------------
;	this macro is used instead of the normal POPF instruction to help
;	prevent a 286 bug from occurring
popff	macro
	local	myret
	jmp	$+3
myret	label	near
	iret
	push	cs
	call	myret
	endm

;-----------------------------						  ; @@12
;	check character 						  ; @@12
;									  ; @@12
chkchar macro	char							  ; @@12
	lodsb								  ; @@12
	and	al,0dfh 						  ; @@12
	cmp	al,char 						  ; @@12
	jne	ccn_ret 						  ; @@12
	endm								  ; @@12
.list

page
;-----------------------------------------------------------------------------
;	resident routine - control transferred here on INT 21
;	check to see if this call has a function code we are interested in
;-----------------------------------------------------------------------------


tv_entry:
	pushf								  ; @@01
	jmp	SHORT  check_fcb_open						  ; @@01

interrupt_hook:
resident_routine:
	pushf				; save the user's flags (old stack)

	cmp	tv_flag,TV_TRUE 	; see if in TV			 ;AN000;
	je	use_old 		; yes, old_vect

check_fcb_open: 							  ; @@01

;-------------------------------------------------------------------	 ;AN001;
;	first, check to see if APPEND disabled, if so, skip everything	 ;AN001;
;	and go to real INT 21 handler					 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
	test	mode_flags,Enabled	; APPEND disabled?		 ;AN001;
	jz	real_jump		; yes, skip all other checks	 ;AN001;

	cmp	ah,FCB_opn		; FCB open?
	jump	E,FCB_open		; yes, do the APPEND

	cmp	ah,handle_opn		; handle open?
	jump	E,handle_open		; yes, do the APPEND

	cmp	ah,ext_handle_opn	; extended handle open? 			  ;AN003;
	jump	E,ext_handle_open	; yes, do the APPEND				  ;AN003;
											  ;AN003;
	cmp	ah,file_sz		; file size?
	je	FCB_open		; yes, do the APPEND


	test	mode_flags,X_mode	; /X mode not selected
	jz	real_jump

	call	IsItFCB_FindFirst?
	je	FCB_search1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,FCB_sch1		 ; search?
;	 jump	 E,FCB_search1		 ; yes, do the APPEND
;--------------------------------------------------------------------------

	call	IsItHandle_FindFirst?
	jump	E, handle_find1

;------ following two lines replaced by the above to lines of code Bug #121
;	 cmp	 ah,handle_fnd1 	 ; find?
;	 jump	 E,handle_find1 	 ; yes, do the APPEND
;--------------------------------------------------------------------------

	cmp	tv_flag,TV_TRUE 	; cant do in TopView		 ;AN000;
	je	skip_exec
	cmp	ax,exec_proc*256+0	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND
skip_exec:
	cmp	ax,exec_proc*256+3	; EXEC?
	jump	E,exec_pgm		; yes, do the APPEND

	page
;-----------------------------------------------------------------------------
;	By here, we know that the call was not one we are interested in,
;	pass through to old INT 21.
;	Since this is done with a jmp, control will pass back to original caller
;	after DOS is finished.
;-----------------------------------------------------------------------------

real_jump:
	cmp	tv_flag,TV_TRUE 	; see if called by TV		 ;AN000;
	jne	use_old 		; yes, use old vect

	popff				; restore user's flags
	jmp	dword ptr tv_vec_off	; pass through to TV

use_old:
	popff				; restore user's flags (old stack)
	jmp	dword ptr Vector_Offset ; jump to old INT 21

page
;-----------------------------------------------------------------------------
; New functions added to resolve Bug #121
; IsItFCB_FindFirst?
; IsItHandle_FindFirst?
;-----------------------------------------------------------------------------
VOL_LABEL	equ	08h
IsItFCB_FindFirst?	proc	near
		cmp	ah, FCB_sch1		; search?
		jne	not_FCB_FindFirst
		push	bx
		mov	bx, dx			; ds:bx == ptr to FCB
		cmp	byte ptr [bx], 0ffh	; extended FCB ?
		jne	FCB_FindFirst
		test	byte ptr [bx+6], VOL_LABEL	; search for label ?
		pop	bx
		ret
FCB_FindFirst:
		pop	bx			; restore BX (bug #1027)
		cmp	al, al
not_FCB_FindFirst:
		ret
IsItFCB_FindFirst?	endp
;
;----------------- This routine can be made in line MOHAN
;
IsItHandle_FindFirst?	proc	near
		cmp	ah, handle_fnd1 	; handle find ?
		jne	not_Handle_FindFirst
		test	cl, VOL_LABEL
not_Handle_FindFirst:
		ret
IsItHandle_FindFirst?	endp
;
page
;-----------------------------------------------------------------------------
;	FCB_search1 - this routine handles FCB search first calls
;-----------------------------------------------------------------------------

FCB_search1:
	mov	expected_ext_error,fcb_no_more_files
	jmp	short FCB_openx1

;-----------------------------------------------------------------------------
;	FCB_open - this routine handles FCB open calls
;-----------------------------------------------------------------------------

FCB_open:
	mov	expected_ext_error,fcb_file_not_found
FCB_openx1:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr FCB_ptr+0,dx	; save FCB pointer
	mov	word ptr FCB_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation
	cmp	al,FCB_failed		; open failed ?
	je	check_error		; yes, lets check extended error
	jmp	set_return_flags	; no, fix the stack, then ret to caller

check_error:
	call	get_ext_err_code	; get the extended error code
	mov	FCB_ext_err,1		; set FCB ext error
	call	save_first_ext_err	; save first extended error code
	mov	ax,ext_err_dpl.DPL_AX	; get error in ax
	cmp	ax,expected_ext_error	; file not found?
	je	FCB_openx2		; yes, lets look around for file
	lea	dx,save_ext_err 	;
	call	set_ext_err_code	; set the extended error code
	jmp	set_return_flags	; no, fix the stack, then return

FCB_openx2:

;	set up APPEND's stack

	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers

	push	cs			; establish addressability
	pop	ds

	call	ctrl_break_set		; set ctrl-break handler
	call	crit_err_set		; set crit err handler

	mov	ext_err_flag,1		; flag for setting critical error

;	fix FCB drive spec

	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec
	cmp	ah,-1			; extended FCB?
	jne	not_ext_FCB1
	add	bx,1+5+1		; point to real drive letter
	mov	ah,ES:byte ptr [bx]	; get FCB drive spec

not_ext_FCB1:
	mov	FCB_drive_id,ah 	; save it for later
	mov	ES:byte ptr [bx],0	; zero the drive field out to
					; use default drive

	mov	ah,get_disk		; get disk
	call	int_21			; call DOS INT 21 handler

	add	al,"A"			; make it a character
	mov	work_disk,al		; save it

	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,work_dir		; save area
	call	int_21			; call DOS INT 21 handler

	call	address_path		; get address of path
	cmp	es: byte ptr [di],";"	; is the append list null?
	jump	E,null_list		; exit append
	mov	app_dirs_seg,es 	; save app dirs segment
	mov	si,di			; source

try_another1:
	lea	di,try_dir		; destination
	call	get_app_dir		; copy dir to try into try_dir
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir1:
	mov	app_disk,0		; zero for current dir
	cmp	try_dir+1,":"		; see if we have a drive
	jne	no_drive		; char should be a colon

;	yes, there was a drive specified, must do the change disk function call

	mov	ah,change_disk		; change disk
	mov	dl,try_dir		; get the char representation of the drive
	mov	app_disk,dl		; save it away for later use
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler
;	jc	check_end_dir_list	; there was an error, see if there is
					; another to try

	cmp	crit_err_flag,0 	; did we experience a critical error
	jne	set_err_code		; yes, fake a file_not_found

no_drive:
	mov	ah,get_dir		; get directory
	xor	dx,dx			; default drive
	lea	si,app_dir		; save area
	call	int_21			; call DOS INT 21 handler

;	check to see if there was a critical error

	cmp	crit_err_flag,0 	; did we experience a critical error
	je	cd_worked		; no, the cd worked
	jmp	short set_err_code

save_regs_and_set:
	pushf				; save everything again
	save_regs
	push	cs			; re-establish addressability
	pop	ds			; ds = cs

set_err_code:
	xor	ah,ah			; make ax look like open failed
	mov	al,FCB_failed
	mov	ax_after_21,ax		; save it away so we can restore it below

	jmp	no_more_to_try

cd_worked:
	lea	dx,try_dir		; point dx to dir to try
	mov	ah,change_dir		; change dir to appended directory
	call	int_21			; call DOS INT 21 handler

;	try the open in this dir

	restore_regs			; make regs look like when user
	mov	ax,incoming_AX		; called us

	call	int_21			; call DOS INT 21 handler
	mov	ax_after_21,ax		; save AX
	cmp	crit_err_flag,0 	; did we get critical error?
	jne	save_regs_and_set	; yes, fake a file_not_found
	cmp	al,FCB_failed	   ; did open work?
	jne	open_ok
	call	get_ext_err_code	; get the extended error code

open_ok:
	pushf				; save everything again
	save_regs

	push	cs			; re-establish addressability
	pop	ds			; ds = cs

;	restore user's working disk and restore the dir on the appended drive

	mov	ah,change_disk		; change disk back to our original
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,app_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

;	this is for ..\dirname ptr

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

	mov	ax,ax_after_21		; restore AX
	cmp	al,FCB_failed		; did open work?
	jne	FCB_open_worked
	mov	ax,ext_err_dpl.DPL_AX
	cmp	ax,expected_ext_error
	jne	no_more_to_try		; not file not found

check_end_dir_list:
	mov	es,app_dirs_seg 	; restore es
	mov	si,app_dirs_ptr
	cmp	si,null 		; should we try again?
	je	no_more_to_try		; no
	jmp	try_another1		; yes

FCB_open_worked:
	mov	byte ptr ext_err_flag,0 ; the open worked, no need to set ext err code
	jmp	short set_disk

no_more_to_try:
;	restore user's working disk and dir

;	The following code up to label "null_list" which
;	restores the user's drive and path was moved in front
;	of the code to restore the drive spec in FCB.
;
	mov	ah,change_disk		; change disk
	mov	dl,work_disk
	call	cap_dl
	sub	dl,"A"			; convert from char to drive spec
	call	int_21			; call DOS INT 21 handler

	mov	ah,change_dir		; change dir
	lea	dx,work_disk		; save area (this time include drive)
	call	int_21			; call DOS INT 21 handler

null_list:
	mov	ah,FCB_drive_id 	; get FCB drive spec
;	cmp	ah,0			; did they ask for default drive?
;	je	fix_drive_spec		; yes, leave it alone
	jmp	short fix_drive_spec

set_disk:				; set drive number in FCB
	mov	ah,work_disk		; no, give them the found drive spec
	sub	ah,"A"-1		; convert from char to drive spec

;	ah has proper drive spec to put into FCB, do it

fix_drive_spec:
	les	bx,dword ptr FCB_ptr	; ES:BX points to FCB
	cmp	ES:byte ptr[bx],-1	; extended FCB
	jne	not_ext_FCB2		; put in the proper drive spec
	add	bx,1+5+1		; point to real drive letter

not_ext_FCB2:
	mov	ES:byte ptr [bx],ah


	call	ctrl_break_restore
	call	crit_err_restore

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err		; no, finish up
	lea	dx,ext_err_dpl
	cmp	FCB_ext_err,0
	je	handle_ext_err
	lea	dx,save_ext_err

handle_ext_err:
	call	set_ext_err_code	; yes, go set the ext error info

;	all done with append, clean things back up for the user

no_ext_err:
	restore_regs			; restore registers

	jmp	reset_stack		; fix stack, ret to caller
page

;-----------------------------------------------------------------------------
;	handle_find - APPEND handle find function
;-----------------------------------------------------------------------------

handle_find1:
	mov	incoming_CX,cx		; save user's CX
	mov	expected_error,handle_no_more_files
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------
;	exec_pgm - APPEND exec program function
;-----------------------------------------------------------------------------

exec_pgm:
	mov	incoming_BX,bx		; save user's ES:BX
	mov	incoming_ES,es
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_no_more_files
	jmp	short handle_openx

;-----------------------------------------------------------------------------		  ;AN003;
;	ext_handle_open - APPEND extended handle open function					       ;AN003;
;-----------------------------------------------------------------------------		  ;AN003;
ext_handle_open:									  ;AN003;
	test	dx,eo_create		; does this call specify create?		  ;AN003;
	jz	no_eo_create		; no, we can continue				  ;AN003;
											  ;AN003;
	jmp	real_jump		; yes, do nothing but pass on to real		  ;AN003;
					; INT 21 handler				  ;AN003;
											  ;AN003;
;	getting here means the caller did not specify the create option 		  ;AN003;
											  ;AN003;
no_eo_create:										  ;AN003;
											  ;AN003;
	mov	incoming_BX,bx		; save user's registers                           ;AN003;
	mov	incoming_CX,cx		; extended open sure does use a lot		  ;AN003;
	mov	incoming_DX,dx		; of registers					  ;AN003;
	mov	incoming_SI,si								  ;AN003;
	mov	incoming_DI,di								  ;AN003;
	mov	incoming_ES,es								  ;AN003;
	mov	incoming_DS,ds								  ;AN003;
											  ;AN003;
	mov	expected_error,handle_file_not_found					  ;AN003;
	jmp	short handle_openx	; for now ...					  ;AN003;
											  ;AN003;
;-----------------------------------------------------------------------------
;	handle_open - APPEND handle open function
;-----------------------------------------------------------------------------

handle_open:
	mov	expected_error,handle_file_not_found
;	mov	expected_ext_error,handle_file_not_found

handle_openx:
	call	check_config		; check the config flags
	call	crit_sect_set		; set critical section flag

	call	tv_barrier		; no op on exec

	mov	incoming_AX,ax		; save user's AX
	mov	word ptr handle_ptr+0,dx	 ; save path pointer
	mov	word ptr handle_ptr+2,ds

	popff				; restore user's flags
	call	int_21			; try the open

	cli
	mov	AX_after_21,ax		; save AX as it came back from INT
	pushf				; save flags from operation

;	find out if we had an error, and if so was it the one we were
;	looking for

	jc	what_happened		; yes, lets find out what happened
	mov	incoming_AX,-1		; insure no exec done later
	jmp	set_return_flags	; no, fix the stack, then ret to caller
					; this means that the real call worked,
					; APPEND does not need to do anything

what_happened:
;	cmp	ax,handle_path_not_found  ; normal errors
;	je	handle_search		; yes, look for the file
	cmp	ax,expected_error	; was the error file not found?
	je	handle_search		; yes, look for the file
	jmp	set_return_flags	; no, fix the stack, then ret to caller


handle_search:
	call	get_ext_err_code	; get the extended error code information

;	set up APPEND's stack
	popff				; get rid of the flags from the
					; real operation
;	mov	temp_DS_save,ds 	; Save DS reg
	mov	stack_segment,ss	; Save it
	mov	stack_offset,sp 	; Save it
	mov	ax,cs			; Get current segment
	mov	ss,ax			; and point stack seg here
	lea	sp,append_stack 	; set up new stack

	save_regs			; save registers
	pushf				;
	push	cs			; establish addressability
	pop	ds

	call	crit_err_set

	call	ctrl_break_set

;	all done with the prep stuff, let's get down to business

;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;
;	before doing anything else, check DRIVE and PATH modes		 ;AN001;
;									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;									 ;AN001;

	pushf				; save flags			 ;AN001;
	push	ax			; save AX			 ;AN001;
									 ;AN001;
	cmp	incoming_AX,exec_proc*256 ; is this call an exec?
	je	drive_and_path_ok


;-------------------------------------------------------------------
;	Set up ES:SI to point to incoming string
;-------------------------------------------------------------------

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo13 								  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip3		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo13:										   ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip3:
;-------------------------------------------------------------------

	test	mode_flags,Drive_mode	; Drive_mode enabled?
	jnz	check_path_mode 	; yes, go check path mode

	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	check_path_mode 	; no, go check path mode

;-------------------------------------------------------------------
;	getting here means that Drive_mode is disabled and that a drive letter
;	was found.  This means we give up on this APPEND operation

	jmp	SHORT drive_or_path_conflict


check_path_mode:
	test	mode_flags,Path_mode	; Path_mode enabled?
	jnz	drive_and_path_ok	; yes, go do the APPEND function

	call	check_for_path		; no, find out if there is a path
					; specified

	cmp	ax,0			; was there a path?
	jne	drive_or_path_conflict	; no, go do the APPEND function


	call	check_for_drive 	; no, find out if there is a drive
					; specified
	cmp	ax,0			; was there a drive letter?
	je	drive_and_path_ok	; no, everything is OK
					; yes, fall through and exit w/error

;-------------------------------------------------------------------	 ;AN001;
;	getting here means that Drive_mode is disabled and that a drive  ;AN001;
;	letter was found.  This means we give up on this APPEND operatio ;AN001; n

drive_or_path_conflict:

	pop	ax			; clean up stack
	popff

;	restore_regs			; restore some regs				  ;AN002;
;	pop	ax

	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get flags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2


drive_and_path_ok:							 ;AN001;
	pop	ax			; restore AX			 ;AN001;
	popff				; restore flags 		 ;AN001;
									 ;AN001;
;-------------------------------------------------------------------	 ;AN001;
;	end of code to check DRIVE and PATH modes			 ;AN001;
;-------------------------------------------------------------------	 ;AN001;

	cmp	incoming_AX,ext_handle_opn*256+0 ;is this call an ext open?		  ;AN003;
	jne	no_eo1									  ;AN003;
	mov	si,incoming_SI		; DS:SI points to original name for ex open	  ;AN003;
	mov	es,incoming_DS		; but this code wants ES:SI to point to it	 ;AN003;
	lea	di,fname		; DS:DI points to fname area			  ;AN003;
	jmp	SHORT eo_skip1		; skip the old stuff				  ;AN003;
											  ;AN003;
no_eo1: 										  ;AN003;
	les	si,dword ptr handle_ptr ; ES:SI points to original handle
	lea	di,fname		; DS:DI points to fname area
eo_skip1:										  ;AN003;
	call	get_fname		; strip just the 8.3 filename from
					; the original ASCIIZ string
	call	address_path		; address the path
	cmp	es: byte ptr [di],";"	; is append list null ?
	jump	E,no_more_to_try2	; exit append
	popff				;
	mov	si,di			; pointer to list of appended directories
	pushf				; push flags onto stack just for the
					; popff below

try_another2:
	popff
	lea	di,try_dir		; buffer to be filled with dir name
					; to try
	push	cx			; save CX
	call	get_app_dir		; this routine will return with a dir
					; to try in try_dir
	mov	true_name_count,cx	; save number of chars for later us		  ;AN003;
	pop	cx
	mov	app_dirs_ptr,si 	; save updated pointer


;-----------------------------
try_app_dir2:

	call	append_fname		; glue the filename onto the end of the dir to try


;	we now have an ASCIIZ string that includes the original 8.3 filename
;	and one of the appended dir paths

	mov	ax,incoming_AX
	mov	cx,incoming_CX
	lea	dx,try_dir		; point to new ASCIIZ string

	cmp	incoming_AX,ext_handle_opn*256+0     ; extended open?			  ;AN003;
	jne	not_eo1 								  ;AN003;
											  ;AN003;
;	this is an extended open call							  ;AN003;
											  ;AN003;
	save_regs									  ;AN003;
											  ;AN003;
	mov	si,dx			; ext open wants DS:SI -> filename		  ;AN003;
	push	cs									  ;AN003;
	pop	ds									  ;AN003;
											  ;AN003;
	mov	ax,incoming_AX		; function code 				  ;AN003;
	mov	bx,incoming_BX		; mode word					  ;AN003;
	mov	cx,incoming_CX		; attributes					  ;AN003;
	mov	dx,incoming_DX		; flags 					  ;AN003;
	mov	es,incoming_ES		; ES:DI parm_list pointer			  ;AN003;
	mov	di,incoming_DI								  ;AN003;
											  ;AN003;
	call	int_21			; try the extended open 			  ;AN003;
											  ;AN003;
	restore_regs									  ;AN003;
	pushf				; save flags					  ;AN003;
;	mov	es,incoming_ES		; restore es as it was				  ;AN003;
	jmp	SHORT not_exec2		; go find out what happened			  ;AN003;
											  ;AN003;
											  ;AN003;
not_eo1:										  ;AN003;
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec1

;	this is an exec call								  ;AN003;

	push	es
	push	bx
	mov	ah,get_DTA
	call	int_21
	mov	word ptr incoming_DTA+0,bx	; save callers DTA
	mov	word ptr incoming_DTA+2,es
	pop	bx
	pop	es
	push	ds
	push	dx
	mov	ah,set_DTA
	lea	dx,exec_DTA		; set for fake exec search
	push	cs
	pop	ds
	call	int_21
	pop	dx
	pop	ds
	mov	ah,handle_fnd1		; precess search by finds
	mov	expected_error,handle_no_more_files

not_exec1:

	push	es			; save append's ES
	push	bx			; save append's BX
	mov	es,incoming_ES		; must restore ES before doing the call ; fix for P37, GGA 9/10/87
	mov	bx,incoming_BX		; must resatore user's ES:BX

	call	int_21			; try the open

	pop	bx			; restore append's BX
	pop	es			; restore append's es
	pushf				; save flags
	cmp	incoming_AX,exec_proc*256+0	; exec pgm call
	jne	not_exec2
	push	ds
	push	dx
	push	ax
	mov	ah,set_DTA
	mov	dx,word ptr incoming_DTA+0	; restore callers DTA
	mov	ds,word ptr incoming_DTA+2
	call	int_21
	pop	ax
	pop	dx
	pop	ds
not_exec2:
	popff
	pushf
	jnc	found_it_remote 	; all done

	cmp	crit_err_flag,0 	; process critical errors
	jne	check_crit_err

	cmp	ax,handle_path_not_found  ; normal errors
	je	should_we_look_more

	cmp	ax,expected_error	; was the error we found file not found?
	je	should_we_look_more	; yes, look some more
	jmp	no_more_to_try2 	; no, any other error, we pack it in

should_we_look_more:
	mov	si,app_dirs_ptr 	; yes, see if we should look more
	cmp	si,null 		; should we try again?
	je	no_more_to_tryx
	jmp	try_another2		; yes
no_more_to_tryx:
	jmp	no_more_to_try2

check_crit_err:
	mov	ext_err_flag,1		; we need to set extended error info
	mov	ax,expected_error	; make ax look like we got file not found
	mov	ax_after_21,ax		; save it away so we can restore it below
	popff				; get clags from stack
	stc				; set the carry flag
	pushf				; put 'em back

	jmp	no_more_to_try2

found_it_remote:			; come here only if the file was found in
					; an appended directory
	mov	ax_after_21,ax		; save AX


;											  ;AN002;
;	Find out if this process has the true_name flag set in thier PSP.		  ;AN002;
;	At this point, DS:DX points to the true name of the found file			  ;AN002;
;											  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	save_regs
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	no_true_name		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
	mov	di,word ptr handle_ptr+0	; get user's buffer pointer ES:DI         ;AN002;
	mov	es,word ptr handle_ptr+2						  ;AN002;

;	find out if this is a handle find or an open or an exec

	cmp	incoming_AX,exec_proc*256+0   ; exec?
	je	no_true_name		; yes, do nothing with true name
											  ;AN002;
	cmp	incoming_AX,handle_fnd1*256+0	; handle find?
	jne	not_hf			; no, go do the easy stuff
											  ;AN002;
;	function we are doing is a handle find, must get part of true_name
;	string from append path, part from DTA.  Messy!

	lea	si,try_dir		; buffer that has last APPEND path tried

	mov	cx,true_name_count	; get number of chars in true_name dir		  ;AN002;

copy_true_name_loop2:
	mov	ah,ds:[si]		; get byte of append dir path			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	inc	si			; in this loop, the null is not copied		  ;AN002;
	inc	di									  ;AN002;
	loop	copy_true_name_loop2							  ;AN002;

;	put in the "\"

	mov	ah,"\"			; get a \
	mov	es:[di],ah		; copy it
	inc	di			; increment pointer

;	we have copied the first part of the string, now get the real filename
;	from the DTA

	push	es
	push	bx

	mov	ah,get_DTA
	call	int_21
	push	es
	pop	ds
	mov	si,bx

	pop	bx
	pop	es

copy_true_name_loop3:
	mov	ah,ds:[si+30]	     ; get byte of actual filename		       ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si			; in this loop the null is copied		  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop3							  ;AN002;

not_hf:
	mov	si,dx			; make DS:SI point to true name

copy_true_name_loop:									  ;AN002;
	mov	ah,ds:[si]		; get byte of true name 			  ;AN002;
	mov	es:[di],ah		; copy it to user's buffer                        ;AN002;
	cmp	ah,null 		; is it a null? 				  ;AN002;
	je	true_name_copied	; yes, all done 				  ;AN002;
	inc	si									  ;AN002;
	inc	di									  ;AN002;
	jmp	copy_true_name_loop							  ;AN002;
											  ;AN002;
true_name_copied:									  ;AN002;
											  ;AN002;
no_true_name:										  ;AN002;
	restore_regs			; restore some regs				  ;AN002;
	pop	ax
											  ;AN002;
											  ;AN002;
no_more_to_try2:

	call	ctrl_break_restore	; restore normal control break address
	call	crit_err_restore	; restore normal critical error  address

;	find out if there is a need to set the extended error code

	cmp	ext_err_flag,0		; do we need to set the extended error code?
	je	no_ext_err2		; no, finish up
	lea	dx,ext_err_dpl
	call	set_ext_err_code	; yes, go set the ext error info

;	reset flags, and pack it in

no_ext_err2:
	popff
	restore_regs			; restore registers
	pushf				; put the real flags on the stack

	jmp	reset_stack		; fix stack, ret to caller

page
;-------------------------------------------------------------------
;
;	support routines for drive and path mode checking
;
;
;-------------------------------------------------------------------


check_for_drive:			; input:  ES:SI -> original string
					; output: AX = 0  no drive present
					; output: AX = -1 drive present

	xor	ax,ax			; assume no drive letter present

	cmp	es: byte ptr [si+1],':' ; is the second char a ":"?
	jne	exit_check_for_drive	; no, skip setting the flag

	mov	ax,-1			; yes, set the flag

exit_check_for_drive:

	ret

;-------------------------------------------------------------------

check_for_path: 			; input:  ES:SI -> original string
					; output: AX = 0  no path present
					; output: AX = -1 path present

	push	si			; save pointer

	xor	ax,ax			; assume no path present


;	walk the string and look for "/", or "\".  Any of these mean that a
;	path is present

walk_handle_string:

	push	ax									 ;AN006;
	mov	al,es: byte ptr [si]	; is this a dbcs char?				 ;AN006;
	call	Chk_DBCS								 ;AN006;
	pop	ax									 ;AN006;
											 ;AN006;
	jnc	no_dbcs1		; no, keep looking				 ;AN006;

	add	si,2			; yes, skip it and the next char		 ;AN006;
	jmp	walk_handle_string	; the next char could be a "\", but		 ;AN006;
					; would not mean a path was found		 ;AN006;
											 ;AN006;
no_dbcs1:										 ;AN006;
	cmp	es: byte ptr [si],"\"	; is the char a "\"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],"/"	; is the char a "/"?
	je	found_path		; yes, set flag and return
	cmp	es: byte ptr [si],0	; is the char a null
	je	exit_check_for_path	; yes, got to the end of the
					; handle string

	inc	si			; point to next char
	jmp	walk_handle_string	; and look again

found_path:
	mov	ax,-1			; yes, set the flag

exit_check_for_path:
	pop	si			; restore si
	ret

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 2f handler
;-----------------------------------------------------------------------------

intfcn_hook:
	cmp	ah,append_2f		; is this function call for append?
;;;;;;	je	do_appends						  ; @@12
	jne	ih_10							  ; @@12
	jmp	do_appends						  ; @@12
ih_10:									  ; @@12
	cmp	ah,applic_2f		; is this function call for applications
	je	do_applic
	jmp	pass_it_on

do_applic:
	cmp	dx,-1			; not COMMAND call
	jump	NE,pass_it_on
	cmp	al,0			; match name request
	jne	ck01

	mov	cmd_buf,bx		; save CMDBUF offset
	call	check_cmd_name
	jne	no_internal1
	mov	al,append_inst		; inidicate I want this command
no_internal1:
	iret

ck01:
	cmp	al,1			; match name request
	jne	ck02

;	save pointer to parser

	mov	word ptr pars_off+0,di	; ES:DI points to COMMAND.COM's parser
	mov	word ptr pars_off+2,es	; save it for later

	mov	cmd_env,bx		; save env pointer address
	call	check_cmd_name
	jne	no_internal2
	call	COMMAND_begin		; process internal command
no_internal2:
	iret

ck02:
;	cmp	al,2			; set COMMAND active	    ; @@13; @@09
;	jne	ck03						    ; @@13; @@09
;	mov	cmd_active,1					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck03:								    ; @@13; @@09
;	cmp	al,3			; set COMMAND in active     ; @@13; @@09
;	jne	ck04						    ; @@13; @@09
;	mov	cmd_active,0					    ; @@13; @@09
;	iret							    ; @@13; @@09
ck04:								    ; @@13; @@09
	jmp	pass_it_on

;*******************************************************************************
;   The following old code is commented out.				    @@12
;*******************************************************************************
;check_cmd_name:			 ; see if internal APPEND
;	push	es
;	push	cs
;	pop	es
;	push	di
;	push	cx
;	push	si
;	cmp	ds:byte ptr[si],6	; length must match
;	jne	skip_comp
;	comp	append_id,6,[si+1]	; see if APPEND is command
;skip_comp:
;	pop	si
;	pop	cx
;	pop	di
;	pop	es
;	ret
;*********************************************************************
check_cmd_name: 			; See if APPEND 		    @@12
	push	ax			;				    @@12
	push	si			;				    @@12
	push	cx			;				    @@12
	push	di			;				    @@12
	push	es			;				    @@12
	mov	si,cmd_buf		; DS:SI -> cmd buf ended with cr    @@12
	add	si,2			; 1st 2 bytes garbage		    @@12
					;				    @@12
ccn_skip_leading:			;				    @@12
	lodsb				; skip leading stuff		    @@12

	call	Chk_DBCS		; find out if this is DBCS			 ;AN006;
	jnc	no_dbcs2		; no, keep looking				 ;AN006;
	lodsb				; yes, skip it and the next byte		 ;AN006;
	jmp	ccn_skip_leading	; the second byte will be skipper when		 ;AN006;
					; we go back through				 ;AN006;

no_dbcs2:										 ;AN006;
	cmp	al," "			;	blank			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,tab_char		;	tab			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,","			;	comma			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"="			;	equal			    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,";"			;	semi-colon		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,"\"			;	back slash		    @@12
	je	ccn_skip_leading	;				    @@12
	cmp	al,cr			; bad ret for early terminate	    @@12
	jne	ccn_02			;				    @@12
	cmp	al,0			;   reset z for no match	    @@12
	jmp	SHORT ccn_ret 		;				    @@12
ccn_02: 				;				    @@12
	mov	di,si			; di -> beginning of possible	    @@12
	dec	di			;	"APPEND " string	    @@12
	lodsb				;				    @@12
	cmp	al,":"			;				    @@12
	jne	ccn_cont		;				    @@12
	mov	di,si			;				    @@12
	lodsb				;				    @@12
ccn_cont:				;				    @@12
	call	Chk_DBCS								 ;AN006;
	jnc	no_dbcs3		; no, carry on					 ;AN006;
	add	si,2			; yes, skip it and the next byte		 ;AN006;
	jmp	SHORT ccn_20									 ;AN006;
											 ;AN006;
no_dbcs3:										 ;AN006;
	cmp	al,"\"			; move di up upon "\"		    @@12
	jne	ccn_20			;				    @@12
	mov	di,si			;				    @@12
ccn_10: 				;				    @@12
	lodsb				;				    @@12
	jmp	ccn_cont		;				    @@12
ccn_20: 				;				    @@12
	cmp	al," "			; look for separator		    @@12
	je	ccn_30			; if found, then have command	    @@12
	cmp	al,"="			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,cr			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,tab_char		;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,","			;				    @@12
	je	ccn_30			;				    @@12
	cmp	al,";"			;				    @@12
	jne	ccn_10			;				    @@12

ccn_30: 				;				    @@12
	sub	si,di			;				    @@12
	cmp	si,7			;				    @@12
	jne	ccn_ret 		; no match			    @@12
					;				    @@12
	mov	si,di			;				    @@12
	chkchar "A"			; look for "APPEND" string	    @@12
	chkchar "P"			;				    @@12
	chkchar "P"			;				    @@12
	chkchar "E"			;				    @@12
	chkchar "N"			;				    @@12
	chkchar "D"			;				    @@12
					; exit with z set for match	    @@12
ccn_ret:				;				    @@12
	pop	es			;				    @@12
	pop	di			;				    @@12
	pop	cx			;				    @@12
	pop	si			;				    @@12
	pop	ax			;				    @@12
	ret				;				    @@12

page
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	do_appends							 ;AN000;
;									 ;AN000;
;	This is the INT 2F handler for the APPEND			 ;AN000;
;			  subfunction					 ;AN000;
;									 ;AN000;
;	New functions added for 3.30:					 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Get /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B706						 ;AN000;
;									 ;AN000;
;	Output: BX = 0000	/X not active				 ;AN000;
;		   = 0001	/X active				 ;AN000;
;									 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	Set /X status							 ;AN000;
;									 ;AN000;
;	Input:	AX = B707						 ;AN000;
;									 ;AN000;
;		BX = 0000	turn /X off				 ;AN000;
;		BX = 0001	turn /X on (active)			 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;
do_appends:
	cmp	al,are_you_there	; is the function request for presence?
	jne	ck1

	mov	al,-1			; set flag to indicate we are here
	iret				; return to user

ck1:
	cmp	al,dir_ptr		; is the function request for pointer?
	jne	ck2

	les	di,dword ptr dirlst_offset     ; return dirlist pointer to caller
	iret

ck2:
	cmp	al,get_app_version	; is the function request for version?
	jne	ck3			; no, check for next function

	mov	ax,-1			; yes, set NOT NETWORK version
	iret

ck3:
	cmp	al,tv_vector		; is the function request for TV vector?
	jne	ck4			; no, check for old dir ptr

	mov	tv_vec_seg,es		; yes, save the TV vector
	mov	tv_vec_off,di

	push	cs			; set ES:DI to tv ent pnt
	pop	es			;
	lea	di,tv_entry

	xor	byte ptr tv_flag,TV_TRUE ; set flag			  ;AN000;
	iret

ck4:					;
	cmp	al,old_dir_ptr		; is it the old dir ptr
	jne	ck5			; no, pass it on

	push	ds
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

	pop	ds
	mov	al,1
	call	terminate		; exit to DOS			  ; @@05

ck5:					;
	cmp	al,DOS_version		; is it the new version check
	jne	ck6			; no, pass it on

	mov	ax,mode_flags		; set mode bits
	xor	bx,bx			; destroy registers
	xor	cx,cx
	mov	dl,byte ptr version_loc   ; major version num
	mov	dh,byte ptr version_loc+1 ; minor version num
	iret

ck6:									 ;AN000;
	cmp	al,get_state		; is it get state call? 	 ;AN001;
	jne	ck7			; no, look some more		 ;AN000;
									 ;AN000;
	mov	bx,mode_flags		; get mode bits 		 ;AN000;
	iret				; return to user		 ;AN000;
									 ;AN000;
ck7:									 ;AN000;
	cmp	al,set_state		; is it set state  call?	 ;AN001;
	jne	ck8			; no, look some more		 ;AN000;
									 ;AN000;
	mov	mode_flags,bx		; save the new state		 ;AN001;
	iret								 ;AN000;
									 ;AN000;
ck8:									 ;AN000;

	cmp	al,true_name		; is it the set true name function?		  ;AN002;
	jne	ck9			; no, look some more				  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
											  ;AN002;
;	get the PSP and then get the APPEND flags byte

	mov	ah,get_PSP		; function code to get PSP address		  ;AN002;
	call	int_21			; get the PSP address				  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
;	is the flag already set?

	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is it set?					  ;AN002;
	jnz	no_set_true_name	; yes, do nothing				  ;AN002;
											  ;AN002;
;	set the true_name flag

set_true_name:										  ;AN002;
	add	ax,true_name_flag	; set true name flag				  ;AN002;
	mov	es:[di],ax		; save in PSP					  ;AN002;
											  ;AN002;
no_set_true_name:
	pop	di			; restore some regs				  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	iret				; return					  ;AN002;
											  ;AN002;
ck9:											  ;AN002;

;-------------------------------------------------------------------
;	fill in additional 2F functions here
;-------------------------------------------------------------------

pass_it_on:				; the function call (ah) was not for append
	jmp	dword ptr intfcn_Offset ; jump to old INT 2f

page
;-----------------------------------------------------------------------------
;	Entry point for interrupt 24 handler
;-----------------------------------------------------------------------------

crit_err_handler:

	mov	crit_err_flag,0ffh	; set critical error flag
	mov	al,3			; fail int 21h
	iret

page
;-----------------------------------------------------------------------------
;	miscellaneous routines
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;	tv_barrier
;-----------------------------------------------------------------------------

tv_barrier:

	cmp	tv_flag,TV_TRUE 	; in Topview			 ;AN000;
	jne	no_barrier

	push	ax
	mov	ax,2002h		; wait on DOS barrier
	int	2Ah
	pop	ax
no_barrier:
	ret

;-----------------------------
;	check_config - this routine is called by both the FCB and handle open
;	code.  I checks the net_config flag to see if it is zero, if so it
;	does an installation check. If it is non-zero, nothing is done.

check_config:

	push	ax			; save a few registers
	push	bx

;	examine the config flag to see if we already know what config we have

	cmp	net_config,0
	jne	do_not_look		; we know config already

;	the flag word has not been set before,	go find out what config we have

	mov	ax,0b800h		; installation code function code
	int	2fh			; do the installation check

	mov	net_config,bx		; save flag word for later

do_not_look:
	pop	bx			;restore regs and leave
	pop	ax
	ret

;*( Chk_DBCS ) *************************************************************
;*									   *
;*  Function: Check if a specified byte is in ranges of the DBCS lead bytes*
;*  Attention: If your code is resident, comment out the lines marked	   *
;*	       ;** .							   *
;*									   *
;*  Input:								   *
;*	   AL	 = Code to be examined					   *
;*									   *
;*									   *
;*  Output:								   *
;*	   If CF is on then a lead byte of DBCS 			   *
;*									   *
;* Register:								   *
;*	   FL is used for the output, others are unchanged.		   *
;*									   *
;***************************************************************************
Chk_DBCS	PROC
	PUSH	DS
	PUSH	SI
;	CMP	CS:DBCSEV_SEG,0 	; ALREADY SET ? ;**
;	JNE	DBCS00					;**
	MOV	SI,OFFSET EVEV		; SET DEFAULT OFFSET  ;**
	PUSH	CS					      ;**
	POP	DS			; SET DEFAULT SEGMENT ;**
     PUSH    AX
	MOV	AX,6300H		; GET DBCS EV CALL
	INT	21H
	MOV	CS:DBCSEV_OFF,SI			      ;**
	MOV	CS:DBCSEV_SEG,DS			      ;**
     POP     AX
DBCS00:
	MOV	SI,CS:DBCSEV_OFF			      ;**
	MOV	DS,CS:DBCSEV_SEG			      ;**
DBCS_LOOP:
	CMP	WORD PTR [SI],0
	JE	NON_DBCS
	CMP	AL,[SI]
	JB	DBCS01
	CMP	AL,[SI+1]
	JA	DBCS01
	STC
	JMP	SHORT DBCS_EXIT
DBCS01:
	ADD	SI,2
	JMP	DBCS_LOOP
NON_DBCS:
	CLC
DBCS_EXIT:
	POP	SI
	POP	DS
	RET
Chk_DBCS	ENDP


;-----------------------------
;	append_fname - glues the fname onto the end of the dir to try

append_fname:
	push	es
	push	ds
	pop	es
	lea	di,try_dir		; destination, sort of (dir name)
	lea	si,fname		; source (filename)

;	find the end of the dir name

	mov	dbcs_fb,-1		; set flag for no dbcs first byte chars 	 ;AN006;

walk_dir_name:
	mov	al,byte ptr [di]	; get a char from dir name
	cmp	al,null 		; are we at the end?
	je	end_of_dir		; yes, add on the fname

	call	Chk_DBCS		; char is in al 				 ;AN006;
	jnc	no_dbcs4		; no, keep looking				 ;AN006;
	mov	dbcs_fb,di		; save offset					 ;AN006;
	inc	di			; skip second byte

no_dbcs4:
	inc	di			; no, keep stepping
	jmp	walk_dir_name

;	now it is time to append the filename

end_of_dir:
	mov	al,byte ptr [di-1]	; get last char of dir name
	cmp	al,"\"			; is it a dir seperator?
	jne	check_next_dir_sep	; no, check the next dir sep char		 ;AN006;
											 ;AN006;
	sub	di,2			; yes, must find out if real dir sep		 ;AN006;
					; or DBCS second byte				 ;AN006;
	cmp	dbcs_fb,di		; is the char before our dir sep a DBCS 	 ;AN006;
					; first byte?					 ;AN006;
	jne	no_dbcs4a		; no, must check for the next dir sep		 ;AN006;
					; yes, this means we must put in a dir sep	 ;AN006;
	add	di,2			; restore di					 ;AN006;
	jmp	SHORT put_in_dir_sep	; put int the dir sep char			 ;AN006;
											 ;AN006;
no_dbcs4a:										 ;AN006;
	add	di,1			; restore di, then check next dir sep		 ;AN006;

check_next_dir_sep:
	cmp	al,"/"			; is it the other dir seperator?
	je	add_fname		; yes, no need to add one
put_in_dir_sep: 									 ;AN006;
	mov	al,"\"			; get dir seperator
	stosb				; add to end of dir

add_fname:
	lodsb				; get a char from fname
	stosb				; copy the char
	cmp	al,null 		; are we at the and of the filename?
	je	eo_name 		; yes, all done!
	jmp	add_fname







eo_name:
	pop	es
	ret


;-----------------------------
;	get_fname strips out the 8.3 filename from the original ASCIIZ string
;
;	INPUT:	ES:SI points to original string
;		DS:DI points to area for filename

get_fname:

	mov	bx,si			; save the pointer
	mov	dbcs_fb,-1		; set the dbcs flag off 			 ;AN006;

gfn1:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	cmp	ah,null 		; is it a null?
	je	got_the_end		; yes, we found the end

	call	chk_dbcs		; is this char a DBCS first byte?		 ;AN006;
	jnc	no_dbcs5		; no, carry on
	mov	dbcs_fb,si		; yes, save pointer
	inc	si			; skip second byte

no_dbcs5:
	inc	si			; no, point to next char
	jmp	gfn1			; loop till end found

got_the_end:
	mov	ah,ES:byte ptr [si]	; get a char
	cmp	ah,"/"			; did we find a /
	je	went_too_far		; yes, we found the start
	cmp	ah,"\"			; did we find a \
	je	found_bslash		; yes, we found the start			 ;AN006;
	cmp	ah,":"			; did we find a :
	je	went_too_far		; yes, we found the start
	cmp	si,bx			; are we back to the original start?
	je	got_the_beg		; yes, we found the start of the fname
	dec	si			; step back a char, then look some more
	jmp	got_the_end

found_bslash:				; found a backslash, must figure out if 	 ;AN006;
					; is second byte of DBCS			 ;AN006;
	dec	si			; point to next char				 ;AN006;
	cmp	si,dbcs_fb		; do they match?
	jne	no_dbcs5a		; no, fix up si and carry on			 ;AN006;
	dec	si			; skip dbcs byte and loop some more		 ;AN006;
	jmp	got_the_end								 ;AN006;

no_dbcs5a:										 ;AN006;
	inc	si			; went too far by one extra			 ;AN006;
											 ;AN006;
went_too_far:
	inc	si			; went one char too far back

;	ES:SI now points to the beginning of the filename

got_the_beg:
	mov	ah,ES:byte ptr [si]	; get a char from the source
	mov	byte ptr [di],ah	; copy to dest
	cmp	ah,null 		; did we just copy the end?
	je	done_with_fname 	; yes, all done
	inc	si			; no, get the next char
	inc	di
	cmp	di,offset app_dirs_ptr	; make sure we dont try to copy past the
	je	done_with_fname 	; area
	jmp	got_the_beg

done_with_fname:
	ret

;-----------------------------
;	this code executed to return to caller after APPEND's stack has been
;	initialized

reset_stack:

;	reset the stack 								  ;AN002;

	popff				; restore flags from real open
	mov	ss,Stack_Segment	; Get original stack segment
	mov	sp,Stack_Offset 	; Get original stack pointer
	pushf				; put the flags on the old stack


;-----------------------------
;	before jumping to this routine, SS:SP must point to the caller's stack,
;	and the flags from the real INT 21 operation must have been pushed

set_return_flags:

;	must be sure to clear the true_name flag before leaving 			  ;AN002;
											  ;AN002;
	push	ax			; save some regs				  ;AN002;
	push	bx									  ;AN002;
	push	es									  ;AN002;
	push	di									  ;AN002;
											  ;AN002;
	mov	ah,get_PSP		; function code for get PSP operation		  ;AN002;
	call	int_21			; get the PSP, segment returned in BX		  ;AN002;
	mov	es,bx			; need to use it as a segment			  ;AN002;
	mov	di,PDB_Append		; get pointer to APPEND flag in PDB		  ;AN002;
											  ;AN002;
	mov	ax,es:[di]		; get APPEND flag into AX			  ;AN002;
	test	ax,true_name_flag	; is true name flag armed?			  ;AN002;
	jz	reset_stack2		; no, don't copy true name                        ;AN002;
											  ;AN002;
	sub	ax,true_name_flag	; clear true name flag				  ;AN002;
	mov	es:[di],ax		; save it in PSP				  ;AN002;
											  ;AN002;
											  ;AN002;
reset_stack2:										  ;AN002;
											  ;AN002;
	pop	di			; restore					  ;AN002;
	pop	es									  ;AN002;
	pop	bx									  ;AN002;
	pop	ax									  ;AN002;
											  ;AN002;
	cmp	tv_flag,TV_TRUE 					 ;AN000;
	jne	tv_flag_not_set

	mov	ax,2003h		; clear open barrier
	int	2Ah


;	pop down to the old flags on the user's stack

tv_flag_not_set:

	cmp	incoming_AX,exec_proc*256+0	; need to do exec
	jne	not_exec3
	popff				; discard bad flags
	mov	ax,incoming_AX		; set exec parms

	push	ds			; save DS, this must be done					;an005;
					; to pervent DS from being trashed on return to caller		;an005;

	push	cs
	pop	ds
	lea	dx,try_dir
	mov	bx,incoming_BX
	mov	es,incoming_ES
	call	int_21			; issue the exec

	pop	ds			; restore DS							; an005;

	pushf

not_exec3:
	popff				; get flags from real int 21 (old stack)
	pop	temp_IP_save		; save IP, CS
	pop	temp_CS_save
	lahf				; save flags in AH
	popff				; pop old flags off stack
	sahf				; replace old with new

;	push the new flags onto the stack, then fix CS and IP on stack

	pushf				; push new flags onto stack
	push	temp_CS_save		; restore IP, CS
	push	temp_IP_save
	mov	ax,AX_after_21		; Set AX as it was after open

	call	crit_sect_reset 	; clear the critical section flag
	iret				; return to the calling routine


;-----------------------------
;	This routine is used to extract an appended dir from the dir list
;	On entry, DS:DI points to an area for the appended dir
;	and ES:SI points to the source string

get_app_dir:

	xor	cx,cx			; keep a count of chars in cx			  ;AN003;
copy_dir:
	mov	ah,es:byte ptr [si]	; get the char, and copy it into dest
	cmp	ah,null 		; find a null?
	je	no_more_dirs		; yes, inform caller that this is the last one

	cmp	ah,";"			; check to see if we are at the end of a dir
	je	update_pointer		; yes,

	mov	byte ptr [di],ah	; if not null or semi-colon, then copy it
	inc	si			; increment both pointers
	inc	di
	inc	cx			; count of chars				  ;AN003;
	jmp	copy_dir		; do it some more

update_pointer:
	inc	si			; point to next char
	mov	ah,es:byte ptr [si]	; get char			  ; @@16
	cmp	ah,null 		; did we reach the end of the dir list?
	je	no_more_dirs		;

	cmp	ah,";"			; is is a semi-colon
	je	update_pointer
	jmp	SHORT  all_done


no_more_dirs:
	xor	si,si			; set end search flag

all_done:
	mov	byte ptr [di],null	; null terminate destination
	ret				; return to caller

;-----------------------------
;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

ctrl_break_set:

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21			; call DOS INT 21 handler

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21			; call DOS INT 21 handler
	ret


;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_restore:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21			; call DOS INT 21 handler
	ret

;-----------------------------
;	restore ctrl-break checking flag to the way it was
ctrl_break_rest:
	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	mov	dl,ctrl_break_state	; get the way is was before we messed with it
	call	int_21
	ret

;-----------------------------
;
crit_err_set:
	mov	crit_err_flag,0 	; clear the critical error flag

	mov	ax,get_crit_err 	; Get INT 24h vector
	call	int_21			; call DOS INT 21 handler

	mov	crit_vector_offset,bx	; Save it
	mov	ax,es			; es hase segment for resident code
	mov	crit_vector_segment,ax

	lea	dx,crit_err_handler	; DS:DX = New INT 21h vector
	mov	ax,set_crit_err 	; function code for setting critical error vector
	call	int_21			; call DOS INT 21 handler
	ret				; go back to the caller


;-----------------------------
;
crit_err_restore:
	push	ds			; save ds for this function
	mov	ax,set_crit_err 	; function code for setting critical error vector
	mov	dx,crit_vector_offset	; get old int 24 offset
	mov	ds,crit_vector_segment	; get old int 24 segment
	call	int_21			; call INT 21
	pop	ds
	ret

;-----------------------------
;	crit_sect_set - issues an enque request to the server to protect
;	against reentry.  This request is issued only if the network is started,
;	and then, only for RCV, MSG, and SRV configurations
crit_sect_set:
	push	ax
	push	bx
	push	di
	push	es

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	dont_set_crit_sect	; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	dont_set_crit_sect	; yes, skip it
					; otherwise, issue the request

;	the config flag was not zero or redir, so set crit section

	mov	ah,NETSYSUTIL
	mov	al,NETENQ
	mov	bx,TCBR_APPEND
	int	2Ah

dont_set_crit_sect:			; because of the config we don't want
	pop	es			; to set critical section
	pop	di
	pop	bx
	pop	ax
	ret

;-----------------------------
;
crit_sect_reset:
	push	ax
	push	bx

	mov	ax,net_config		; check the server config flag
	cmp	ax,0			; is it zero?
	je	not_set 		; yes, skip it

	cmp	ax,redir_flag		; is it a redir?
	je	not_set 		; yes, skip it

	mov	ah,NETSYSUTIL		; turn critical section off
	mov	al,NETDEQ
	mov	bx,TCBR_APPEND
	int	2Ah

not_set:
	pop	bx
	pop	ax
	ret


;-----------------------------
;	save_first_ext_err - this routine is used to save the extended
;		error info after the first FCB open.
save_first_ext_err:

	push	ax

	mov	ax,ext_err_dpl.DPL_AX		; copy all registers
	mov	save_ext_err.DPL_AX,ax
	mov	ax,ext_err_dpl.DPL_BX
	mov	save_ext_err.DPL_BX,ax
	mov	ax,ext_err_dpl.DPL_CX
	mov	save_ext_err.DPL_CX,ax
	mov	ax,ext_err_dpl.DPL_DX
	mov	save_ext_err.DPL_DX,ax
	mov	ax,ext_err_dpl.DPL_SI
	mov	save_ext_err.DPL_SI,ax
	mov	ax,ext_err_dpl.DPL_DI
	mov	save_ext_err.DPL_DI,ax
	mov	ax,ext_err_dpl.DPL_DS
	mov	save_ext_err.DPL_DS,ax
	mov	ax,ext_err_dpl.DPL_ES
	mov	save_ext_err.DPL_ES,ax

	pop	ax
	ret

;-----------------------------
;	get_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search

get_ext_err_code:
	push	ax			; save register that are changed by this
	push	bx			; DOS function
	push	cx
	push	di
	push	si
	push	es
	push	ds

;	get the extended error information

	mov	ah,59h			; function code for get extended error
	xor	bx,bx			; version number
	call	int_21			; get the extended error

;	save it away in a DPL for set_ext_error_code
;	all fields in the DPL will be filled in except the last three,
;	which will be left at zero

	mov	ext_err_dpl.DPL_AX,ax
	mov	ext_err_dpl.DPL_BX,bx
	mov	ext_err_dpl.DPL_CX,cx
	mov	ext_err_dpl.DPL_DX,dx
	mov	ext_err_dpl.DPL_SI,si
	mov	ext_err_dpl.DPL_DI,di
	mov	ext_err_dpl.DPL_DS,ds
	mov	ext_err_dpl.DPL_ES,es


;	restore regs and return

	pop	ds
	pop	es			; restore registers
	pop	si
	pop	di
	pop	cx
	pop	bx
	pop	ax
	ret

;-----------------------------
;	set_ext_err_code - this routine is used to get the extended error
;		info for the error that cause append to start its search
;		CS:DX points to return list
set_ext_err_code:
	push	ax			; save register that are changed by this
	push	ds			; DOS function

;	get the extended error information

	mov	ah,DOSSERVER		; function code for DOSSERVER call
	mov	al,DOSSETERROR		; sub-function code for set extended error
	push	cs
	pop	ds
	call	int_21			; set the extended error

;	restore regs and return

	pop	ds			; restore registers
	pop	ax
	ret
page
;-----------------------------
;	This routine is used to initiate DOS calls from within the APPEND interrupt
;	handlers.  An INT instruction can not be used because it would cause APPEND
;	to be re-entered.
;
;	SS, SP saved incase call is EXEC which blows them away
int_21: 				;
	cmp	tv_flag,TV_TRUE 	; see if being re-entered	 ;AN000;
	jne	use_old_vec		; yes, pass through to DOS

	pushf				; to comp for iret pops
	call	dword ptr tv_vec_off	; Call INT 21h
	ret				;

use_old_vec:
	cmp	vector_segment,0	; not installed yet
	je	use_int

	pushf				;  to comp for iret pops
	call	dword ptr vector_offset ; Call INT 21h
	ret				;

use_int:
	int	DOS_function
	ret
page
;-----------------------------
;	This routine is used to locate the current APPEND path string
;	result to ES:DI

address_path:
address_status: 							  ; @@13
	test	mode_flags,E_mode
	jnz	get_env_mode

address_pathx:
	mov	ax,append_2f*256+dir_ptr	; get from buffer
	int	int_function
	clc
	ret

get_env_mode:					; get from environment
;	cmp	cmd_active,0			; different logic   ; @@13; @@09
;	jne	use_cmd_env			; if in COMMAND     ; @@13; @@09
	push	bx
	mov	ah,get_PSP
	call	int_21				; get the PSP
	mov	es,bx
	mov	bx,002ch			; address environment
	mov	ax,es:word ptr[bx]
	mov	es,ax
	pop	bx
	cmp	ax,0				; PSP pointer is set
	je	address_pathx						  ; @@13
use_cmd_env:								  ; @@13
;	cmp	cmd_env,0			; have not set my pointer yet
;	je	address_pathx						  ; @@13
;	mov	es,cmd_env						  ; @@13
env_mode1:
	mov	di,0				; start at start
	cmp	es:byte ptr[di],0		; no environment
	je	no_appendeq
find_append:
	cmp	es:word ptr[di],0		; at environment end
	je	no_appendeq
	push	di
	push	si
	push	cx
	push	ds
	push	cs
	pop	ds
	comp	,6+1,append_id			; string = "APPEND="
	pop	ds
	pop	cx
	pop	si
	pop	di
	je	at_appendeq
	inc	di
	jmp	find_append
at_appendeq:					; must insure this is	    @@17
	cmp	di,0				; genuine "APPEND=" string  @@17
	je	at_appendeq_genuine		; if start of environ ok    @@17
	dec	di				; else check that 0	    @@17
	cmp	es:byte ptr[di],0		;      precedes string	    @@17
	je	at_appendeq_10			; jmp if ok		    @@17
	add	di,8				; else cont.search after    @@17
	jmp	find_append			;      "="		    @@17
at_appendeq_10: 				;			    @@17
	inc	di				;			    @@17
at_appendeq_genuine:				;			    @@17
	add	di,6+1				; skip APPEND=
	cmp	es:byte ptr[di],0		; null value
	je	no_appendeq			; treat as not found
	cmp	es:byte ptr[di]," "
	je	no_appendeq
	cmp	es:byte ptr[di],";"
	je	no_appendeq
	clc					; set ok
	ret

no_appendeq:					; not found, use default
	lea	di,semicolon			; null list
	push	cs
	pop	es
	stc					; set error
	ret

;-----------------------------						  ; @@03
;	This routine is used to locate the current APPEND path string	  ; @@03
;	result to ES:DI.  Used by APPEND status.			  ; @@03

;address_status:						    ; @@13; @@03
;	test	mode_flags,E_mode				    ; @@13; @@03
;	jump	Z,address_pathx 				    ; @@13; @@03
;	jmp	use_cmd_env					    ; @@13; @@03

cap_dl: 					; convert dl to uppercase
	cmp	dl,"a"			; find out if we have a lower case; @@14
	jb	cap_dlx 		; char				  ; @@14
	cmp	dl,"z"							  ; @@14
	ja	cap_dlx 						  ; @@14
	sub	dl,"a"-"A"		; convert char to upper case	  ; @@14
cap_dlx:
	ret

;	end_address:				; this is the end of the TSR stuff		 ;AN002;

page
;-----------------------------------------------------------------------------
;	Main routine. Used to determine if APPEND has been loaded
;	before. If not, load resident portion of APPEND. Then handle setting
;	or displaying appended directory list.
;-----------------------------------------------------------------------------

main_begin:				; DOS entry point

	mov	ax,seg mystack		; set up stack
	mov	ss,ax
	lea	sp,mystack

	cld

	mov	res_append,0		; set external copy		  ; @@05

	push	cs			; make DS point to CS
	pop	ds

	push	cs			; make ES point to CS
	pop	es


;	find out if append has been loaded				  ; @@04
									  ; @@04
	mov	ah,append_2f		; int 2f function code for append ; @@04
	mov	al,are_you_there	; function code to ask if append  ; @@04
					; has been loaded		  ; @@04
	int	int_function						  ; @@04
									  ; @@04
	cmp	al,append_inst		; is append there?		  ; @@04
	jne	not_there_yet		; no				  ; @@04

	mov	dx,0			; set for network version	  ; @@07
	mov	ah,append_2f		; int 2F function code for append ; @@07
	mov	al,DOS_version		; function code for get version   ; @@07
	int	int_function						  ; @@07
	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
	jne	bad_append_ver		; no, cough up an error messsage  ; @@07


	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,9			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_second_APPEND_msg; length of string		 ;AN000;   ; @@04
;	lea	dx,second_APPEND_msg	; second load message		 ;AN000;   ; @@04
;	call	print_STDERR		; display error message 	 ;AN000;   ; @@04
;	lea	dx,crlf 		; carriage return, line feed	  ; @@04
;	mov	cx,crlf_len		; length of string		  ; @@04
;	call	print_STDERR						  ; @@04
									  ; @@04
	mov	al,0fch 		; second load			  ; @@05
	call	terminate		; exit to DOS			  ; @@05

bad_append_ver: 			; append version mismatch	  ; @@07
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,1			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;
;	mov	cx,len_bad_append_msg					 ;AN000;   ; @@07
;	lea	dx,bad_append_msg	; bad app message		 ;AN000;   ; @@07
;	call	print_STDERR						 ;AN000;   ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
	mov	ax,0feh 		; bad APPEND version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

not_there_yet:								  ; @@04

	mov	cs:initial_pass,-1	; set a flag for initial pass			 ;AN007;
	call	do_command		; do actual APPEND

	mov	bx,4			; close all standard files
do_closes:
	mov	ah,3eh			; close file handle
	call	int_21
	dec	bx
	jns	do_closes

	call	set_vectors		; set append vectors on success   ; @@05

	call	Release_Environment	; release the environmental vector space	;an007; dms;

	lea	dx,end_address+15	; normal end
	mov	cl,4			; calc end address in paragraphs
	shr	dx,cl
	mov	ah,get_PSP		; calc space from PSP to my code  ; @@02
	call	int_21							  ; @@02
	mov	ax,cs							  ; @@02
	sub	ax,bx							  ; @@02
	add	dx,ax			; calc length to keep		  ; @@02
	mov	al,0			; exit with no error
	mov	ah,term_stay
	call	int_21

page

COMMAND_begin:				; COMMAND entry point
	save_regs
	mov	word ptr cmd_name@+0,si  ; save internal command buffer @
	mov	word ptr cmd_name@+2,ds
	cld

	mov	abort_sp,sp		; save sp for aborts		  ; @@05
	mov	res_append,1		; set resident copy		  ; @@05
	call	do_command		; do actual APPEND
abort_exit:				; exit to abort append		  ; @@05
	mov	sp,abort_sp						  ; @@05

	push	es
	push	di
	les	di,cmd_name@
	mov	es:byte ptr[di],0	; set no command now
	pop	di
	pop	es

	cmp	ax,0			; error
	jne	no_E_mode_via
	test	mode_flags,E_mode	; no /E processing
	jz	no_E_mode_via

	mov	ax,append_2f*256+dir_ptr; int 2f function code for append
	int	int_function
	push	es
	pop	ds
	mov	si,di

;	mov	ah,get_PSP		; set new command
;	call	int_21
	mov	bx,ss
	mov	es,bx
	mov	bx,cmd_buf		; command line iput buffer
	inc	bx			; skip max length
	mov	es:byte ptr[bx],3+1+6+1
	mov	di,bx			; address command line buffer
	inc	di			; skip current length
	push	ds
	push	si
	push	cs
	pop	ds
	move	,3+1+6+1,setappend_name ; set in "SET APPEND="
	pop	si
	pop	ds
	cmp	ds:byte ptr[si],";"	; null list is special case
	jne	copy_path
append_blank:
	mov	al," "
	stosb
	inc	es:byte ptr[bx]
	jmp	short copy_path_done
no_E_mode_via:
	jmp	short no_E_mode
copy_path:
	mov	dl, byte ptr es:[bx-1]	; get max len of command buffer
	sub	dl, 3+1+6+1		; take care of 'SET APPEND='
;
;------ now find the strlen of path string pointed by ds:si
;
;	REPLACE WITH BETTER CODE LATER --- mohan
;
	push	si			; save ptr to paths
	xor	cx, cx
count_next_char:
	lodsb
	or	al, al
	jz	check_len
	inc	cx
	jmp	count_next_char
null_path:
	pop	si
	jmp	append_blank
check_len:
	pop	si
;
;------ check whether the length is ok
;
	cmp	cl, dl			; len < maxlen ?
	jb	copy_it
	push	si
	add	si, cx			; point to end of path str
next_char:
	jcxz	null_path		; null str ?
	dec	cl
	dec	si
	cmp	byte ptr ds:[si], ';'
	jne	next_char
	cmp	cl, dl			; found ';' but is len ok?
	jae	next_char
	pop	si
	add	byte ptr es:[bx], cl
copy_it:
	rep	movsb
;
;------ The code in this box replaced by code below copy_path:------------
;	 lodsb								;
;	 cmp	 al,0							;
;	 je	 copy_path_done 					;
;	 stosb								;
;	 inc	 es:byte ptr[bx]					;
;	 jmp	 copy_path						;
;--------------------------------------------------------------------------
copy_path_done:
	mov	es:byte ptr[di],cr	; set end delimiter

	les	di,cmd_name@
	mov	al,3			; SET length
	stosb
	push	cs							  ; @@06
	pop	ds							  ; @@06
	move	,8,set_name		; set up "SET" command

	mov	ax,0			; set to do SET
no_E_mode:

	restore_regs
	ret

page

do_command:				; APPEND process

;	set ctrl-break check off
;	first, save the old state so we can restore it later,
;	then turn ctrl-break checking off

	mov	ah,ctrl_break		; function code for ctrl-break check
	xor	al,al			; 0 = get current state
	call	int_21

	mov	ctrl_break_state,dl	; save the old ctrl-break state

	mov	ah,ctrl_break		; function code for ctrl-break check
	mov	al,01			; set current state
	xor	dl,dl			; 0 = off
	call	int_21

;	find out if append has been loaded

	mov	ah,append_2f		; int 2f function code for append
	mov	al,are_you_there	; function code to ask if append
					; has been loaded
	int	int_function

	cmp	al,append_inst		; is append there?
	jne	not_already_there	; yes, don't try to put it
	jmp	already_there		; yes, don't try to put it
					; there again

;	get DOS version and decide if it is in the allowed range for
;	APPEND

not_already_there:
	mov	ah,get_version		; lets find out if we should do it
	call	int_21			; try the open
	cmp	ax,expected_version	; compare with DOS version
	jne	bad_DOS

	jmp	SHORT check_assign	; valid range
					; lets see if assign has been loaded

;	Break it to the user that he's trying to do an APPEND with
;	the wrong DOS version

bad_DOS:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,8			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_bad_DOS_msg	; length of string		 ;AN000;
;	lea	dx,bad_DOS_msg		; bad DOS message		 ;AN000;
;	call	print_STDERR		; display error message 	 ;AN000;

	call	ctrl_break_rest
	mov	al,0ffh 		; bad DOS version		  ; @@05
	call	terminate		; exit to DOS			  ; @@05

check_assign:
	mov	ax,0600h
	int	2fh
	or	al,al
	jnz	assign_there
	jmp	SHORT check_TopView	; ASSIGN has not been loaded,	  ; @@01

;	ASSIGN has been loaded before APPEND, bad news!

assign_there:
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,6			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	mov	cx,len_append_assign_msg; length of string
;	lea	dx,append_assign_msg
;	call	print_STDERR		; display error message
	jmp	SHORT conflict_exit						  ; @@01
									  ; @@01
check_Topview:								  ; @@01
	mov	bx,0			; incase not there		  ; @@01
if	not MSVER			; MSKK02 07/14/89
	mov	ax,10h*256+34		; TopView version check 	  ; @@01
	int	15h							  ; @@01
endif
	cmp	bx,0							  ; @@01
	jnz	TopView_there						  ; @@01
	jmp	replace_vector		; TopView has not been loaded,	  ; @@01
									  ; @@01
;	TopView has been loaded before APPEND, bad news!		  ; @@01
									  ; @@01
TopView_there:								  ; @@01
;	mov	cx,len_append_TV_msg	; length of string		  ; @@01
;	lea	dx,append_TV_msg					  ; @@01
;	call	print_STDERR		; display error message 	  ; @@01
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,7			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

									  ; @@01
conflict_exit:								  ; @@01
	call	ctrl_break_rest
	mov	al,0fdh 						  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	get pointer to dir list, on return ES:DI points to buffer

already_there:

;	This code has been moved to main_begin				  ; @@07
;									  ; @@07
;	make sure the right version of APPEND has been loaded		  ; @@07
;

;	mov	dx,0			; set for network version	  ; @@07
;	mov	ah,append_2f		; int 2F function code for append ; @@07
;	mov	al,DOS_version		; function code for get version   ; @@07
;	int	int_function						  ; @@07
;	cmp	dx,word ptr version_loc ; does the version match?	  ; @@07
;	jump	NE,bad_append_ver	; no, cough up an error messsage  ; @@07

process_args:				; process all arguments

;-------------------------------------------------------------------
	mov	si,0081h		; DS:SI points to argument area
	mov	cs:byte ptr e_switch+9,0	; turn /E switch off

process_argsx:				; process all arguments
;


;	make sure that the /PATH and /X switches are re-enabled, and
;	various flags are cleared

	xor	cx,cx			; ordinal value, must start as 0
	xor	dx,dx			; these regs must be 0 for call to Scan_For_Equal

	mov	ah,"/"
	mov	cs:byte ptr x_switch+9,ah		; re-enable /X switch
	mov	cs:byte ptr path_switch+9,ah		; re-enable /PATH switch
	mov	cs:byte ptr x_result.$P_Type,cl 	; clear flag
	mov	cs:byte ptr path_result.$P_Type,cl	; clear flag
	mov	cs:byte ptr dirs_result.$P_Type,cl	; clear flag
	mov	cs:parse_flag,cl			; clear parse flag

;	set up things to call PARSER

	push	cs			; make sure ES points to segment where
	pop	es			; parm block info is
	lea	di,cs:p_block2		; ES:DI points to parm block, for secondary parsing

;
;	Note CX and DX, cleared above, must stay cleared for this call

	call	Scan_For_Equal		; yes - let's see if we have "=" symbol ;an008; dms;
					; parse past it if we do

get_pars_info:
	call	dword ptr pars_off	; call to COMMAND.COM's parser

	or	ax,ax			; end of line?	-1 if yes
	jns	not_end_of_line 	; no, carry on
	jmp	end_of_line_reached	; yes, go figure out what we got

not_end_of_line:

	or	ax,ax			; no, find out if there an error
	je	not_parse_error 	; no, carry on
	jmp	parse_error		; yes, go display the error message

;	got here without any errors, set the proper bits in mode_flags

not_parse_error:
	mov	cs: parse_flag,0ffh	; set parse flag

check_e:
	cmp	e_result.$P_Type,3	; was there a /E in this pass?
	jne	check_? 		; no, look for an ?

	mov	byte ptr e_switch+9,0	; turn this off so we don't allow another
	mov	e_result.$P_Type,0	; clear this so we don't get fooled later

	or	mode_flags,E_mode	; set E mode on

	jmp	get_pars_info		; go get another argument


check_?:
	cmp	qu_result.$P_Type,3
	jne	check_x
	mov	qu_result.$P_Type,0	; clear this so we don't get fooled later
	call	sysloadmsg				
						
	mov	ax,MSG_OPTIONS_FIRST
p_n:	cmp	ax,MSG_OPTIONS_LAST
	jg 	end_?
	mov	bx,STDOUT		; no handle	
	xor	cx,cx			; sub count	
	xor	dl,dl			; no input	
	mov	dh,-1			; message class 
	call	sysdispmsg				
	inc	ax                      ; sysdispmsg does NOT trash ax
	jmp	short  p_n

end_?:	xor	ax,ax                   ; return normal exit code
	call	ctrl_break_rest
	call    terminate	

check_x:
	cmp	x_result.$P_Type,3	; was there a /X on this pass? list index
	je	set_x			; yes, and it was /X w/o ON or OFF

	cmp	x_result.$P_Type,2	; was there a /X on this pass? list index
	jne	check_path

	mov	byte ptr x_switch+9,0	; turn this off so we don't allow  another
	mov	x_result.$P_Type,0	; clear this so we don't get fooled later

	cmp	x_result.$P_Item_Tag,1	; was /X or /X:ON specified?
	je	set_x			; yes, set X mode on
	and	mode_flags,NOT x_mode	; no, clear it
	jmp	get_pars_info

set_x:
	or	mode_flags,x_mode
	jmp	get_pars_info

check_path:
	cmp	path_result.$P_Type,2	; was there a /path on this pass? list index
	jne	check_dirs

	xor	ah,ah			; turn this off so we don't allow
	mov	byte ptr path_switch+9,ah	 ; another
	mov	path_result.$P_Type,0	; clear this so we don't get fooled later


	cmp	path_result.$P_Item_Tag,1	; was /PATH:ON specified?
	je	set_path			; yes, set PATH mode
	and	mode_flags,NOT path_mode	; no, clear it
	jmp	get_pars_info

set_path:
	or	mode_flags,path_mode	; set PATH mode on
	jmp	get_pars_info

;	find out if dirs specified

check_dirs:
	cmp	dirs_result.$P_Type,3	; was a simple string returned?
	je	check_dirs2		; yes, carry on
	jmp	get_pars_info		; no, all done for now

;	set up stuff to do the dirs copy

check_dirs2:
	push	es
	push	ds
	push	si
	push	di

	lds	si,dword ptr dirs_result.$P_Picked_Val	  ; get pointer to dirs string
	mov	dirs_result.$P_Type,0	; clear this so we don't get fooled later

	mov	di,0			; set incase int 2f not installed ; @@08
	mov	es,di							  ; @@08
	mov	ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
	int	int_function						  ; @@08
	mov	ax,es			; see if active yet		  ; @@08
	or	ax,di							  ; @@08
	jnz	copy_dirs_loop		; ok, do the copy		  ; @@08
	push	cs			; not active, set myself	  ; @@08
	pop	es							  ; @@08
	lea	di,app_dirs						  ; @@08

copy_dirs_loop:
	movs	es: byte ptr[di],ds:[si]; copy char

	cmp	byte ptr ds:[si-1],0	; is char a null
	je	done_copy_dirs

	jmp	copy_dirs_loop

done_copy_dirs:

	pop	di
	pop	si
	pop	ds
	pop	es

	jmp	get_pars_info		; no error yet, loop till done

end_of_line_reached:
	mov	old_syntax,0		; process old format operands

	cmp	cs:initial_pass,-1	; is this the first APPEND			 ;AN006;
	je	first_one		; yes, clear flag and exit			 ;AN006;

	cmp	cs:parse_flag,0 	; if this flag is off, means null command line
					; was nothing on the command line
	je	display_dirs		; go display the dirs

first_one:										 ;AN006;
	mov	cs:initial_pass,0	; clear first pass flag 			 ;AN006;

done_for_now:
normal_exit:
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,0			; set string
	ret				; exit to COMMAND


parse_error:
	push	ax			;save parser error code 		;an010;bgb
	call	sysloadmsg						 ;AN000;
	pop	ax			;restore parser error coed		;an010;bgb
	call	do_parse_err							;an010;bgb
	jmp	SHORT bad_parmx		; display message and get out

;-------------------------------------------------------------------

;	 mov	 si,0081h		 ; point si to argument area
;	 mov	 bx,ss
;	 mov	 ds,bx
;
;process_argsx: 			 ; process all arguments
;	 mov	 di,0			 ; set incase int 2f not installed ; @@08
;	 mov	 es,di							   ; @@08
;	 mov	 ax,append_2f*256+dir_ptr  ; es:di -> internal result area ; @@08
;	 int	 int_function						   ; @@08
;	 mov	 ax,es			 ; see if active yet		   ; @@08
;	 or	 ax,di							   ; @@08
;	 jnz	 have_ptr						   ; @@08
;	 push	 cs			 ; not active, set myself	   ; @@08
;	 pop	 es							   ; @@08
;	 lea	 di,app_dirs						   ; @@08
;have_ptr:								   ; @@08
;
;;	 step through the DOS command line argument area, and copy the new dir
;;	 list to the proper place in APPEND. This requires some parsing for
;;	 spaces, tabs chars, equal signs, as well as conversion to upper case
;
;	 cmp	 byte ptr[si],"="	 ; APPEND=path is OK syntax
;	 jne	 skip_leading
;	 inc	 si
;skip_leading:				 ; skip leading spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_leading
;	 cmp	 al,tab_char
;	 je	 skip_leading
;	 cmp	 al,"," 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,"=" 						   ; @@15
;	 je	 skip_leading						   ; @@15
;	 cmp	 al,cr			 ; did we have command line arguments?
;	 jump	 E,display_dirs 	 ; no, display the dirs currently appended
;	 cmp	 al,"/" 		 ; is it a parm starter?	   ; @@05
;	 jump	 E,bad_path_parm	 ; yes, it's an error              ; @@05
;	 dec	 si
;
;copy_args:
;	 lodsb				 ; get char from command line area
;	 cmp	 al,cr			 ; are we at the end?
;	 jump	 E,found_end		 ; yes, display the currently appended dirs
;	 cmp	 al," " 		 ; is it a space?
;	 je	 found_space		 ; yes, at end
;	 cmp	 al,tab_char		 ; is it a tab?
;	 je	 found_space		 ; yes, treat it like a space
;	 cmp	 al,"/" 		 ; is it a parm starter?
;	 je	 bad_path_parm		 ; yes, it's an error              ; @@05
;	 cmp	 al,"a" 		 ; find out if we have a lower case char
;	 jb	 copy_char						   ; @@14
;	 cmp	 al,"z"
;	 ja	 copy_char						   ; @@14
;	 sub	 al,"a"-"A"		 ; convert char to upper case	   ; @@14
;
;copy_char:
;	 mov	 in_middle,-1		 ; say that we made it to the middle
;	 stosb				 ; no, copy char into resident storage area
;	 jmp	 copy_args		 ; do it some more
;
;found_space:
;	 cmp	 in_middle,0		 ; set the space flag then go through
;	 jump	 E,copy_args		 ; loop some more
;
;found_end:
;	 cmp	 in_middle,0		 ; if I found the end of string but not
;	 jump	 E,display_dirs 	 ; in the middle, go display some dirs
;
;	 mov	 es:byte ptr [di],0	 ; null terminate the string
;	 mov	 in_middle,0
;	 cmp	 al,cr
;	 je	 past_trailing
;
;skip_trailing: 			 ; skip end spaces
;	 lodsb
;	 cmp	 al," "
;	 je	 skip_trailing
;	 cmp	 al,tab_char
;	 je	 skip_trailing
;	 cmp	 al,"/" 		 ; path and parm not together	   ; @@05
;	 je	 bad_path_parm						   ; @@05
;	 cmp	 al,cr			 ; only white space allowed at end
;	 jne	 bad_path
;past_trailing:
;
;	 cmp	 old_syntax,0		 ; go back to normal mode
;	 je	 normal_exit
;	 jmp	 exit_append2
;normal_exit:
;	 call	 ctrl_break_rest	 ; reset control break checking
;	 mov	 ax,0			 ; set string
;	 ret				 ; exit to COMMAND

bad_path:				; bad paath operand
;	mov	cx,len_path_error_msg	; length of string
;	lea	dx,path_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
;gga	call	sysdispmsg						 ;AN000;

	jmp	short bad_parmx

bad_path_parm:				; bad parameter 		  ; @@05
;	mov	cx,len_path_parm_error_msg   ; length of string 	  ; @@05
;	lea	dx,path_parm_error_msg					  ; @@05
	call	sysloadmsg						 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	jmp	short bad_parmx 					  ; @@05
bad_parm:				; bad parameter
;	mov	cx,len_parm_error_msg	; length of string
;	lea	dx,parm_error_msg
	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,3			; message number		 ;AN000;
	mov	bx,STDERR		; standard error		 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;

bad_parmx:				; bad parameter
	push	ds
	push	cs
	pop	ds
;	call	print_STDERR		; display error message
	lea	si,inv_parm		; point to msg parm			;an010;bgb
	call	sysdispmsg						 ;AN000;
	pop	ds
	call	ctrl_break_rest
	mov	al,1							  ; @@05
	call	terminate		; exit to DOS			  ; @@05

;	This code has been moved to main_begin				  ; @@07
;bad_append_ver:			; append version mismatch	  ; @@07
;	push	ds							  ; @@07
;	push	cs							  ; @@07
;	pop	ds							  ; @@07
;	mov	cx,len_bad_append_msg					  ; @@07
;	lea	dx,bad_append_msg	; bad app message		  ; @@07
;	call	print_STDERR						  ; @@07
;	lea	dx,crlf 		; carriage return, line feed	  ; @@07
;	mov	cx,crlf_len		; length of string		  ; @@07
;	call	print_STDERR						  ; @@07
;	pop	ds							  ; @@07
;	call	ctrl_break_rest 					  ; @@07
;	mov	ax,0feh 		; bad APPEND version		  ; @@05
;	call	terminate		; exit to DOS			  ; @@05

;	Display currently appended directories

display_dirs:
	call	address_status		; get working path		  ; @@03
	push	ds
	push	es
	pop	ds

	cmp	es:byte ptr[di],";"	; no append now
	je	no_dirs_appended

;	count the chars in the dir list, cx will hold the count

	mov	si,di
	sub	si,6+1			; move pointer to APPEND
	mov	dx,si			; save pointer to string
	xor	cx,cx

scanit:
	lodsb				; get character
	cmp	al,null 		; are we at end?
	je	print_it		; yes, print it
	inc	cx			; look at the next character
	jmp	scanit			; loop till we find the end

print_it:
	call	print_STDOUT		; display appended dirs
	push	cs
	pop	ds
	lea	dx,crlf 		; carriage return, line feed
	mov	cx,crlf_len		; length of string
	call	print_STDOUT
	pop	ds

exit_append:
	cmp	old_syntax,0		; process old format operands
	je	exit_append2
	mov	si,0081h		; set up rescan
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx
	jmp	process_argsx

exit_append2:
	mov	old_syntax,0		; after first time this must be off
	call	ctrl_break_rest 	; reset control break checking
	mov	ax,-1			; no action
	ret				; exit to COMMAND

no_dirs_appended:
	push	cs
	pop	ds

	call	sysloadmsg						 ;AN000;
									 ;AN000;
	mov	ax,5			; message number		 ;AN000;
	mov	bx,STDERR		; handle			 ;AN000;
	xor	cx,cx			; sub count			 ;AN000;
	xor	dl,dl			; no input			 ;AN000;
	mov	dh,-1			; message class 		 ;AN000;
	call	sysdispmsg						 ;AN000;

;	lea	dx,no_append_msg	; no dirs message		 ;AN000;
;	mov	cx,len_no_append_msg	; length of string		 ;AN000;
;	call	print_STDOUT						 ;AN000;
	pop	ds
	jmp	exit_append2		; APPEND = = fix		    ;GGA

page
;-------------------------------------------------------------------
;	Getting here means that APPEND has not been loaded yet.  Get the
;	old vector, save it, and point the vector to the new routine.
;-------------------------------------------------------------------

replace_vector:

	push	ds
	mov	si,0081h		; point si to argument area
	mov	ah,get_PSP
	call	int_21
	mov	ds,bx

;	Process /X and /E parameters

skip_leading2:				; skip leading spaces
;	lodsb
;	cmp	al," "
;	je	skip_leading2
;	cmp	al,tab_char
;	je	skip_leading2
;	cmp	al,cr			; at end
;	jump	E,parms_done
;	cmp	al,"/"
;	jne	set_old_syntax

found_slash:
;	lodsb
;	cmp	al,"e"
;	je	slash_E
;	cmp	al,"E"
;	je	slash_E
;	cmp	al,"x"
;	je	slash_X
;	cmp	al,"X"
;	je	slash_X
bad_parmy:
;	pop	ds
;	jmp	bad_parm
bad_path_parmy:
;	pop	ds
;	jmp	bad_path_parm

slash_X:
;	test	mode_flags,X_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,X_mode
;	jmp	short slashx

slash_E:
;	test	mode_flags,E_mode	; no duplicates allowed
;	jnz	bad_parmy
;	or	mode_flags,E_mode
slashx:
;	jmp	skip_leading2		; loop some more
set_old_syntax:
;;	test	mode_flags,0		; no /? switches on old mode
;;	jne	bad_path_parmy
	mov	old_syntax,1
parms_done:
	pop	ds
	jmp	exit_append
page

set_vectors:				; set append hooks		  ; @@05
	push	es

;	Get INT 2f vector. Save to call older 2f handlers

	mov	ax,get_intfcn		; Get INT 2fh vector
	call	int_21
	mov	intfcn_offset,bx	; Save it
	mov	intfcn_segment,es

;	get int 21 vector

	mov	ax,get_vector		; Get INT 21h vector
	call	int_21
	mov	vector_offset,bx	; Save it
	mov	vector_segment,es
	pop	es

	push	ds							  ; @@08
	push	cs							  ; @@08
	pop	ds							  ; @@08
	lea	dx,intfcn_hook		; DS:DX = New INT 2fh vector
	mov	ax,set_intfcn		; Hook the interrupt
	call	int_21

	lea	dx,interrupt_hook	; DS:DX = New INT 21h vector
	mov	ax,set_vector		; Hook the interrupt
	call	int_21

	mov	dirlst_segment,cs	; save the address of the dirlist
	lea	dx,app_dirs
	mov	dirlst_offset,dx
	pop	ds							  ; @@08

	ret								  ; @@05

terminate:				; terminate to dos or return	  ; @@05
	cmp	res_append,0						  ; @@05
	jne	is_res							  ; @@05
	call	Release_Environment	; release environmental vector		;ac009; dms;
	mov	ah,term_proc		; return to DOS on first time	  ; @@05
	call	int_21							  ; @@05
is_res: 								  ; @@05
	mov	ax,-1			; set abort requested		  ; @@05
	jmp	abort_exit		; must go back to COMMAND	  ; @@05


print_STDOUT:
	mov	bx,STDOUT		; Standard output device handle
	mov	ah,awrite		; function code for write
	call	int_21
	ret

print_STDERR:
	mov	bx,STDERR		; Standard output device handle
	mov	ah,awrite
	call	int_21
	ret

Release_Environment:								;an007; dms;

	push	ax			;save regs				;an007; dms;
	push	bx			;					;an007; dms;
	push	es			;					;an007; dms;
	mov	ah,Get_PSP		; get the PSP segment			;an007; dms;
	call	int_21			; invoke INT 21h			;an007; dms;
	mov	es,bx			; BX contains PSP segment - put in ES	;an007; dms;
	mov	bx,word ptr es:[PSP_Env]; get segment of environmental vector	;an007; dms;
	mov	es,bx			; place segment in ES for Free Memory	;an007; dms;
	mov	ah,Free_Alloc_Mem	; Free Allocated Memory 		;an007; dms;
	int	21h			; invoke INT 21h			;an007; dms;
	pop	es			; restore regs				;an007; dms;
	pop	bx			;					;an007; dms;
	pop	ax			;					;an007; dms;

	ret				; return to caller			;an007; dms;

;=========================================================================
; Scan_For_Equal	: This routine scans the command line from the
;			  beginning until it encounters anything other
;			  than the equal, tab, or space characters.
;			  Register SI is sent back to the caller pointing
;			  to the character that does not meet the match
;			  criteria.
;
;	Inputs	: DS:SI - pointer to next parm
;
;	Outputs : SI	- adjusted to byte not matching the following:
;			  "="
;			  " "
;			  TAB
;
;	Author	: David M. Sewell
;	Date	: 1/27/88
;	Version : DOS 3.4
;=========================================================================

Scan_For_Equal:

	push	ax				; save regs			;an008; dms;
	push	cx				;				;an008; dms;

	xor	cx,cx				; clear cx			;an008; dms;
	mov	cl,byte ptr ds:[80h]		; get length of command line	;an008; dms;

Scan_For_Equal_Loop:

	cmp	cx,0				; at end?			;an008; dms;
	jbe	Scan_For_Equal_Exit		; exit loop			;an008; dms;
	mov	al,byte ptr ds:[si]		; get 1st. character		;an008; dms;
	call	Chk_DBCS			; DBCS lead byte?		;an008; dms;
	jnc	Scan_For_Equal_No_DBCS		; no				;an008; dms;
		cmp	byte ptr ds:[si],DB_SP_HI   ; blank lead byte		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;
		cmp	byte ptr ds:[si+1],DB_SP_LO ; DBCS blank		    ;an008; dms;
		jne	Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

		add	si,2			; yes - DBCS lead byte		;an008; dms;
		sub	dx,2			; decrease counter		;an008; dms;
		jmp	Scan_For_Equal_Loop

Scan_For_Equal_No_DBCS:

	cmp	al,"="				; = found?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,20h				; space?			;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	cmp	al,09h				; tab?				;an008; dms;
	je	Scan_For_Equal_Next		; next character		;an008; dms;
	jmp	SHORT Scan_For_Equal_Exit	; exit with adjusted SI 	;an008; dms;

Scan_For_Equal_Next:

	inc	si				; adjust ptr			;an008; dms;
	dec	cx				; decrease counter		;an008; dms;
	jmp	Scan_For_Equal_Loop		; continue loop 		;an008; dms;

Scan_For_Equal_Exit:

	pop	cx				;				;an008; dms;
	pop	ax				;				;an008; dms;

	ret					; return to caller		;an008; dms;



;=========================================================================	;an010;bgb
; do_parse_err		: This routine sets up for the display of a parse	;an010;bgb
;			  error, and displays the offending parameter.		;an010;bgb
;										;an010;bgb
;	Inputs	: DS:SI - points just past offending parm in command line	;an010;bgb
;										;an010;bgb
;	Outputs : si_off- parm for msg ret.					;an010;bgb
;		  si_seg- parm for msg ret.					;an010;bgb
;		  command line - hex zero at end of offending parm		;an010;bgb
;										;an010;bgb
;	Date	: 3/29/88							;an010;bgb
;	Version : DOS 4.0 (wow!)						;an010;bgb
;=========================================================================	;an010;bgb
do_parse_err	PROC								;an010;bgb
;;;;;;;;mov	ax,3 ;removed- parser handles this				;an010;bgb
	mov	bx,STDERR		; handle				;an010;bgb
;;;;;;;;xor	cx,cx			; sub count				;an010;bgb
	mov	cx,1			;display invalid parm			;an010;bgb
	xor	dl,dl			; no input				;an010;bgb
	mov	dh,02			; message class of parse error		;an010;bgb
;;;;;;;;mov	cs:si_off,81h		   ;initialize pointer			;an010;bgb
										;an010;bgb
	   dec	  si			;point to last byte of invalid parm	;an010;bgb
public decsi									;an010;bgb
decsi:	   cmp	   byte ptr [si],' '	;are we pointing to a space?		;an010;bgb
;	   $IF	   E,OR 		;if so, we dont want to do that 	;an010;bgb
	   JE $$LL1
	   cmp	   byte ptr [si],0dh	;are we pointing to CR? 		;an010;bgb
;	   $IF	   E			;if so, we dont want to do that 	;an010;bgb
	   JNE $$IF1
$$LL1:
	       dec   si 		;find the last byte of parm		;an010;bgb
	       jmp   decsi							;an010;bgb
;	   $ENDIF								;an010;bgb
$$IF1:
	   mov	   byte ptr [si+1],00	  ;zero terminate display string	;an010;bgb
nextsi: 									;an010;bgb
public nextsi									;an010;bgb
	   dec	   si			;look at previous char			;an010;bgb
	   cmp	   byte ptr [si],' '	;find parm separator			;an010;bgb
	   jnz	   nextsi		;loop until begin of parm found 	;an010;bgb
										;an010;bgb
	mov	cs:si_off,si		;mov si into display parms		;an010;bgb
	mov	cs:si_seg,ds		   ;initialize pointer			;an010;bgb
	ret					; return to caller		;an010;bgb
do_parse_err	ENDP								;an010;bgb


;-------------------------------------------------------------------
;
;-------------------------------------------------------------------

MSG_SERVICES <LOADmsg>
MSG_SERVICES <APPEND.CLB,APPEND.CL2,APPEND.CTL>

end_address:				; this is the end of the TSR stuff		 ;AN004;

include parse.asm			; include the parser code
include msgdcl.inc

cseg	ends
sseg	segment para stack 'STACK'
	assume	ss:sseg
	dw	512 dup(0)
mystack dw	0
sseg	ends



	end	main_begin

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\assign\assgparm.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

 ASS_PARMS	label  dword
      dw	ASS_PARMSX
      db	1   ;list of extra delimiters
      db	3   ;0 length
      db	";+="

 ASS_PARMSX	label  byte
      db	0,1

;Min 0 - no drive or switch specified
;Max 1 - maximal allowance of drive letters
;repeats

      dw	ASS_POS1  ;positional ctl ptr
      db	2	  ;# of switches
      dw	ASS_SW1   ;switch ptr
      dw	ASS_SW2   ;switch ptr

 ASS_POS1	 label	word
       dw	 2010h	  ;Simple string,
			   ;ignore colon, &
			   ;repeat
			   ;allowed
       dw	 0002h	   ;Cap result by
			   ; character table
       dw	 Result_Val   ;tbl
       dw	 Res_CTLVAL ;value list
       db	 0	   ;no switch or
			   ;keyword synonyms
       db	 0	   ;alternative keyword

 ASS_SW1	label  word
		dw	  0	    ;20010h    ;Simple string,
				    ;ignore colon & repeat
				    ;allowed
		dw	  0002h     ;Cap result by
				    ;character table
		dw	  Result_Valsw ;tbl
		dw	  0	       ; ;value list
		db	  3	       ;switch or
				       ;keyword synonyms
 SW_Syn1	db	  "/STATUS",0  ;alternate keyword
 SW_Syn2	db	  "/STA",0     ;alternate keyword
 SW_Syn3	db	  "/S",0

; Parameter Control Block for the Switch /?
; 4/17/90 c-PaulB

 ASS_SW2	label  word
		dw	  0		; MatchMask 
		dw	  0		; FuncMask
		dw	  Result_Valsw	; ptr to results
		dw	  0		; ptr to values
		db	  1		; # of switch synonyms
 SW2_Syn	db	  "/?",0	; switch string

 Res_CTLVAL	label  word
      db	3	 ;List of simple strings
      db	0	 ;not in range defn.
      db	0	 ;not in numeric defn.
      db	26	 ;# of strings defined
      db	"A"        ;item tag
			 ;value returned
      dw	DRVA_PTR ;string ptr
      db	"B"        ;item tag
			 ;value returned
      dw	DRVB_PTR ;string ptr
      db	"C"        ;item tag
			 ;value returned
      dw	DRVC_PTR ;string ptr
      db	"D"        ;item tag
			 ;value returned
      dw	DRVD_PTR ;string ptr
      db	"E"        ;item tag
			 ;value returned
      dw	DRVE_PTR ;string ptr
      db	"F"        ;item tag
			 ;value returned
      dw	DRVF_PTR ;string ptr
      db	"G"        ;item tag
			 ;value returned
      dw	DRVG_PTR ;string ptr
      db	"H"        ;item tag
			 ;value returned
      dw	DRVH_PTR ;string ptr
      db	"I"        ;item tag
			 ;value returned
      dw	DRVI_PTR ;string ptr
      db	"J"        ;item tag
			 ;value returned
      dw	DRVJ_PTR ;string ptr
      db	"K"        ;item tag
			 ;value returned
      dw	DRVK_PTR ;string ptr
      db	"L"        ;item tag
			 ;value returned
      dw	DRVL_PTR ;string ptr
      db	"M"        ;item tag
			 ;value returned
      dw	DRVM_PTR ;string ptr
      db	"N"        ;item tag
			 ;value returned
      dw	DRVN_PTR ;string ptr
      db	"O"        ;item tag
			 ;value returned
      dw	DRVO_PTR ;string ptr
      db	"P"        ;item tag
			 ;value returned
      dw	DRVP_PTR ;string ptr
      db	"Q"        ;item tag
			 ;value returned
      dw	DRVQ_PTR ;string ptr
      db	"R"        ;item tag
			 ;value returned
      dw	DRVR_PTR ;string ptr
      db	"S"        ;item tag
			 ;value returned
      dw	DRVS_PTR ;string ptr
      db	"T"        ;item tag
			 ;value returned
      dw	DRVT_PTR ;string ptr
      db	"U"        ;item tag
			 ;value returned
      dw	DRVU_PTR ;string ptr
      db	"V"        ;item tag
			 ;value returned
      dw	DRVV_PTR ;string ptr
      db	"W"        ;item tag
			 ;value returned
      dw	DRVW_PTR ;string ptr
      db	"X"        ;item tag
			 ;value returned
      dw	DRVX_PTR ;string ptr
      db	"Y"        ;item tag
			 ;value returned
      dw	DRVY_PTR ;string ptr
      db	"Z"        ;item tag
			 ;value returned
      dw	DRVZ_PTR ;string ptr

 DRVA_PTR      LABEL	  word
      db       "A",0

 DRVB_PTR      LABEL	  word
      db       "B",0

 DRVC_PTR      LABEL	  word
      db       "C",0

 DRVD_PTR      LABEL	  word
      db       "D",0

 DRVE_PTR      LABEL	  word
      db       "E",0

 DRVF_PTR      LABEL	  word
      db       "F",0

 DRVG_PTR      LABEL	  word
      db       "G",0

 DRVH_PTR      LABEL	  word
      db       "H",0

 DRVI_PTR      LABEL	  word
      db       "I",0

 DRVJ_PTR      LABEL	  word
      db       "J",0

 DRVK_PTR      LABEL	  word
      db       "K",0

 DRVL_PTR      LABEL	  word
      db       "L",0

 DRVM_PTR      LABEL	  word
      db       "M",0

 DRVN_PTR      LABEL	  word
      db       "N",0

 DRVO_PTR      LABEL	  word
      db       "O",0

 DRVP_PTR      LABEL	  word
      db       "P",0

 DRVQ_PTR      LABEL	  word
      db       "Q",0

 DRVR_PTR      LABEL	  word
      db       "R",0

 DRVS_PTR      LABEL	  word
      db       "S",0

 DRVT_PTR      LABEL	  word
      db       "T",0

 DRVU_PTR      LABEL	  word
      db       "U",0

 DRVV_PTR      LABEL	  word
      db       "V",0

 DRVW_PTR      LABEL	  word
      db       "W",0

 DRVX_PTR      LABEL	  word
      db       "X",0

 DRVY_PTR      LABEL	  word
      db       "Y",0

 DRVZ_PTR      LABEL	  word
      db       "Z",0

 RESULT_VAL	label	word
 RESULT_VALSW	label	word

   RES_TYPE  db        0       ;Result_type
   RES_ITAG  db        0       ;Matched
				  ;item tag
   RES_SYN   dw        0       ;synonym
			       ;returned
   RES_SOFF  dw        0       ;drive type
			       ;or beginning
			       ;of string
			       ;may be string
   RES_SEG   dw        0       ;string offset
			    ;if type specified


;=========================================================================
;	Sublist Definition Area
;=========================================================================

Parse_Sublist	label	word

		db	Sublist_Length	;sublist length 			;an002; dms;
		db	Reserved	;reserved for future growth		;an002; dms;
Parse_Sub_Off	dw	?		;offset of replaceable parm		;an002; dms;
Parse_Sub_Seg	dw	?		;segment of replaceable parm		;an002; dms;
		db	0		;replaceable parm 0			;an002; dms;
		db	Left_Align+Char_Field_ASCIIZ ;				;an002; dms;
		db	40		;max width				;an002; dms;
		db	1		;min width				;an002; dms;
		db	20h		;blank fill				;an002; dms;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\append\appendp.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

INCSW	EQU	0			;INCLUDE PSDATA.INC			;AN000;
FARSW	EQU	1			;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;SUPPRESS DATE CHECKING 		;AN000;
TIMESW	EQU	0			;SUPPRESS TIME CHECKING 		;AN000;
FILESW	EQU	0			;SUPPRESS CHECKING FILE SPECIFICATION	;AN000;
CAPSW	EQU	0			;SUPPRESS FILE TABLE CAPS		;AN000;
CMPXSW	EQU	1			;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT ;AN000;
NUMSW	EQU	1			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT		;AN000;
SWSW	EQU	1			;DO SUPPORT SWITCHES			;AN000;
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1 ;AN000;
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2 ;AN000;
VAL3SW	EQU	1			;DO SUPPORT VALUE DEFINITION 3

include psdata.inc
;***********************************************************************

;-------------------------------------------------------------------
;
;	parser stuff for APPEND
;
;-------------------------------------------------------------------



p_block1  $P_PARMS_Blk <offset px_block1, 0, 0>    ; parm block
p_block2  $P_PARMS_Blk <offset px_block2, 0, 0>    ; parm block

;------------------------
;	extended parameter block for APPEND first load

px_block1:
	db	0		; min number positional operands
	db	0		; max number positional operands
;	dw	0		; offset into control block for positionals

	db	4		; APPEND has two switches /E, /X, /PATH, /?
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords
	dw	0		; offset of keyword control block

;------------------------
;	extended parameter block for 2nd, 3rd, ... APPEND invocations

px_block2:
	db	0		; min number positional operands
	db	1		; max number positional operands
	dw	offset dirs_control	; pointer to dirs control block

;	db	2		; APPEND after first load has two switches /X, /PATH
	db	4		; APPEND has two switches /E, /X, /PATH
	dw	offset e_switch 	; control block for /E switch
	dw	offset x_switch 	; control block for /X switch
	dw	offset qu_switch        ; " " for /? switch
	dw	offset path_switch	; control block for /PATH switch

	db	0		; max number of keywords

;------------------------
dirs_control:
	dw	$P_Simple_S+$P_Optional   ; complex, optional string
	dw	$P_CAP_File		; cap by file table
	dw	offset dirs_result	; dirs result buffer
	dw	offset dirs_values	; pointer to null value list
	db	0			; no synonyms

dirs_values:
	db	0			; null value list for dirs



;------------------------
x_switch:
	dw	$P_Simple_s+$P_Optional       ; /X, /X:ON, /X:OFF simple, optional string
	dw	$P_CAP_Char		; cap by char table
	dw	offset x_result 	; pointer to result block
	dw	offset x_values 	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/X",0                  ; only /X is valid

x_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /X:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /X:ON  = 1
	dw	offset on_string
;------------------------

e_switch:
	dw	0			; /E
	dw	$P_CAP_Char		; cap by char table
	dw	offset e_result 	; pointer to result block
	dw	offset e_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/E",0                   ; only /E is valid

e_values:
	db	0			; null value list for /E


;------------------------

qu_switch:
	dw      1                       ; optional
	dw	0
	dw	offset qu_result 	; pointer to result block
	dw	offset qu_values 	; pointer to values block, none
	db	1			; number of switches and synonyms
	db	"/?",0                   ; only /? is valid

qu_values:
	db	0			; null value list for /E



path_switch:
	dw	$P_Simple_s		; /PATH:ON, /PATH:OFF simple string
	dw	$P_CAP_Char		; cap by char table
	dw	offset path_result	; pointer to result block
	dw	offset path_values	; pointer to values block
	db	1			; number of switches and synonyms
	db	"/PATH",0                ; only /PATH is valid


path_values:
	db	3			; string values
	db	0			; zeroes here for ranges and
	db	0			; values
	db	2			; 2 possible string values
	db	0			; /PATH:OFF = 0
	dw	offset off_string	; pointer to "OFF"
	db	1			; /PATH:ON  = 1
	dw	offset on_string


;------------------------

off_string:
	db	"OFF",0                 ; off string

on_string:
	db	"ON",0                  ; on string


;------------------------

x_result	$P_Result_Blk <>	; /X result block
e_result	$P_Result_Blk <>	; /E result block
qu_result       $P_Result_Blk <>        ; /? result block
path_result	$P_Result_Blk <>	; /PATH result block
dirs_result	$P_Result_Blk <>	; dirs result block



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\assign\assgparm.asm ===
PAGE	,132			;
        TITLE   ASSPARM.ASM - ASSIGN  SYSTEM COMMAND LINE PARSER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: ASSGPARM.asm
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of ASSIGN.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .EXE.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;            INCLUDE PARSE.asm statement
;
;	DS - also points to the segment containing the INCLUDE
;            PARSE.asm statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.asm)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the ASMUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT  ASSPARM,NUL;
;
;	 To assemble these modules, the sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;        ASSIGN.asm
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "Microsoft DOS ASSIGN Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft Corp"
;	     "Licensed Material - Program Property of Microsoft "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1
            ;%out    COMPONENT=ASSIGN, MODULE=ASSPARM.asm...
	ENDIF
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER> ;			;AN000;
CODE	SEGMENT PARA PUBLIC		;					;AN000;
	ASSUME	CS:CODE,DS:CODE,ES:CODE,SS:CODE ;				;AN000;

	PUBLIC	SYSPARSE		;SUBROUTINE ENTRY POINT 		;AN000;

CAPSW	EQU	1			;SUPPORT FILENAME TBL CAPS
FARSW	EQU	0			;PARSER CALL NEAR
FILESW	EQU	0			;CHECK FOR FILESPEC
DATESW	EQU	0			;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;SUPPRESS TIME CHECKING
CMPXSW	EQU	0			;SUPPRESS CHECKING COMPLEX LIST
NUMSW	EQU	0			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	1			;SUPPORT OF VALUE DEFINITION 3
DRVSW	EQU	0			;SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT

	IF1				;					;AN000;
            ;%out    COMPONENT=ASSIGN, SUBCOMPONENT=PARSE, MODULE=PARSE.ASM...
            ;%out    COMPONENT=ASSIGN, SUBCOMPONENT=PARSE, MODULE=PSDATA.INC...
	ENDIF				;					;AN000;

					;PARSE WORK AREA & EQUATES

.xlist
	INCLUDE VERSION.INC
	INCLUDE PARSE.ASM
.list

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\assign\assgmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
BADDOS equ 1
STAT   equ 2

; Message Numbers

MSG_OPTIONS_FIRST	equ	300	; first line of message
MSG_OPTIONS_LAST	equ	305	;  and last


PARSE01 equ 01
PARSE02 equ 02
PARSE03 equ 03
PARSE04 equ 04
PARSE05 equ 05
PARSE06 equ 06
PARSE07 equ 07
PARSE08 equ 08
PARSE09 equ 09
PARSE10 equ 10

OLD_DRV   db 0,0
NEW_DRV   db 0,0

FLAG1  equ LEFT_ALIGN+CHAR_FIELD_ASCIIZ

;******************************************************************************
;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS       EQU   1		   ;ONE VARIABLE FIELD IN MESSAGE
TWO_SUBS       EQU   2		   ;TWO VARIABLE FIELDS IN MESSAGE
THREE_SUBS     EQU   3		   ;THREE VARIABLE FIELDS IN MESSAGE
CLASS_1        EQU   EXT_ERR_CLASS ;CLASS 1 (DOS EXTENDED ERRORS)
CLASS_2        EQU   PARSE_ERR_CLASS ;CLASS 2 (PARSE ERRORS)
CLASS_A        EQU   UTILITY_MSG_CLASS ;CLASS A TYPE MESSAGE

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC	  STRUC
MSG_NUM 	  DW	0	   ;MESSAGE NUMBER (TO AX)
MSG_HAND	  DW	0	    ;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	  DW	0	   ;POINTER TO SUBLIST (TO SI)
MSG_COUNT	  DW	0	   ;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	  DB	0	   ;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	  ENDS
;		VALUES FOR THE SUBLIST CONTROL BLOCK
PC_ID_0        EQU   0		   ;ID OF " - " TRAILER TO MESSAGE
PC_ID_1        EQU   1		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_2        EQU   2		   ;ID OF PERCENT VARIABLE FIELD
PC_ID_3        EQU   3		   ;ID OF PERCENT VARIABLE FIELD
MAX_0	       EQU   0		   ;MAXIMUM WIDTH OF STRING FIELD (0=NO LIMIT)
MIN_1	       EQU   1		   ;MINIMUM WIDTH OF STRING FIELD
;Message SUB-LIST
 SUBLIST1 LABEL   DWORD  ;PARM LIST
      ;(Original %1: set to %2:)
      DB  11	     ;PARMLIST size
      DB  0	     ;reserved
      DW  OLD_DRV    ;; ptr to data
SEG_1 DW  ?
      DB  1	     ;; n of %n
      DB  FLAG1      ;; data type
      DB  max_0      ;;max width
      DB  min_1      ;;min width
      DB  PAD_CHAR   ;;char defined to be space

DRV_LETS  LABEL WORD
;Message SUB-LIST2
 SUBLIST2 LABEL   DWORD  ;PARM LIST
      ;(File not found - 'PATH_SPEC')
      DB  11	     ;PARMLIST size
      DB  0	     ;reserved
      DW  NEW_DRV    ;; ptr to data - offset
SEG_2 DW  ?	     ;; ptr to data
      DB  2	     ;; n of %n
      DB  FLAG1      ;; data type
      DB  max_0      ;;max width
      DB  min_1      ;;min width
      DB  PAD_CHAR   ;;char defined to be space

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\attrib.c ===
/* 0 */
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/**/
/*                                                                           */
/*    Utility Name:     ATTRIB.EXE                                           */
/*                                                                           */
/*    Source File Name: ATTRIB.C                                             */
/*                                                                           */
/*    Utility Function:                                                      */
/*                                                                           */
/*       Allows you to set or reset the Archive bit, the Read-Only bit,      */
/*       the System bit, the Hidden bit, and the Extended Attributes.        */
/*       Also allows you to display the current setting of those             */
/*       attributes.                                                         */
/*                                                                           */
/*    Status:           ATTRIB Utility, DOS Version 4.0                      */
/*                                                                           */
/*    Entry Point: inmain(line)                                              */
/*                                                                           */
/*    Input:       line = DOS command line parameters                        */
/*                                                                           */
/*    Exit-normal: attribute set, or attribute printed to output device      */
/*                                                                           */
/*    Exit-error:  error message written to standard error device            */
/*                                                                           */
/*    Internal References:                                                   */
/*                                                                           */
/*      Routines:                                                            */
/*                                                                           */
/*    External References:                                                   */
/*                                                                           */
/*       Routines:                                                           */
/*              parse()          module=_parse.sal                           */
/*              sysloadmsg()     module=_msgret.sal                          */
/*              sysdispmsg()     module=_msgret.sal                          */
/*              getpspbyte()     module=new_c.sal                            */
/*              putpspbyte()     module=new_c.sal                            */
/*              segread()        module=dos.h(C library)                     */
/*              intdosx()        module=dos.h(C library)                     */
/*              intdos()         module=dos.h(C library)                     */
/*                                                                           */
/*    Notes:                                                                 */
/*    Syntax (Command Line)                                                  */
/*                                                                           */
/*  Old version:                                                             */
/*  ATTRIB [+R|-R] [+A|-A] [d:][path]filename[.ext] [[id]|[id=value]] [/S]   */
/*  New version:                                                             */
/*  ATTRIB {+,-}{R,S,A,H} [d:] same as before...                             */
/*                                                                           */
/*            where:                                                         */
/*                                                                           */
/*                 +R = Make file ReadOnly by setting READONLY bit           */
/*                 -R = Reset READONLY bit                                   */
/*                 +A = Set ARCHIVE bit                                      */
/*                 -A = Reset ARCHIVE bit                                    */
/*                 +S = Make file a system file                              */
/*                 -S = Reset SYSTEM bit                                     */
/*                 +H = Make file hidden                                     */
/*                 -H = Reset HIDDEN bit                                     */
/*                                                                           */
/*                 id = Set or display the extended attribute named by id.   */
/*                      Only one id processed per invocation. id can be *.   */
/*                                                                           */
/*                 /S = Process subdirectories also                          */
/*                                                                           */
/*    Copyright 1988 Microsoft Corporation				     */
/*                                                                           */
/*    Revision History:                                                      */
/*                                                                           */
/*               Modified 6/22/87   v. 4.0			             */
/*               Rewritten 9/28/87   v. 4.0 		      - AN000	     */
/*                        - fixed check for "." & ".."        - AN001        */
/*               PTM 3195 - changed Extended attribute MSGs   - AN002        */
/*               PTM 3588 - Do C exit not DOS exit.           - AN003        */
/*               PTM 3783 - Fix for hang problem.             - AN004        */
/*               Lea F. Oct 89 - Allow +-S, +-H options                      */
/*                                                                           */
/*   NOTE:                                                                   */
/*     When extended attributes are added back in, make sure you change the  */
/*     attrib.skl file back to the original DOS 4.0 ext. attr. error msgs.   */
/*                                                                           */
/*     Also, this C program requires a special lib when linking to take care */
/*     of the fact that the c lib saves the DOS environment on the heap and  */
/*     if the environment is > 32k, STACK OVERFLOW will occur.               */
/**/

/****************************************************************************
M001 : Undid the M000 modification. And implemented set attributes for
		 Subdirectory entries only when they are explicitly specified and
		 thru wild card specifications
****************************************************************************/

#include <stdio.h>                                                     /*;AN000;*/
#include <io.h>                                                        /*;AN000;*/
#include <dos.h>                                                       /*;AN000;*/
#include <string.h>                                                    /*;AN000;*/
#include <process.h>
#include "parse.h"                                                     /*;AN000;*/
#include "msgret.h"                                                    /*;AN000;*/
#include "attrib.h"                                                    /*;AN000;*/
#include "proto.h"

/**/
/* Beginning of code (variables declared in attrib.h)                        */
/**/

/*
 * inmain() - This routine receives control from an assembler routine and from
 *            here, main is called. This routine first parses the command line
 *            and then does the appropriate action.
 */
WORD inmain(line)                                                           /*;AN000;*/
   char *line;                                                         /*;AN000;*/
{                                                                      /*;AN000;*/
   return (main(line));                                                         /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     main()                                           */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Parse the command line, makes a full path-filename, does the       */
/*        appropriate function                                               */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD main(line)                                                        /*;AN000;*/
   char *line;                                                         /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/

   WORD Parse_it();         /* forward declaration */                  /*;AN000;*/
   WORD Make_fspec();       /*   "         "       */                  /*;AN000;*/
   WORD Do_dir();           /*   "         "       */                  /*;AN000;*/
   void Error_exit();       /*   "         "       */                  /*;AN000;*/
   void Parse_err();        /*   "         "       */                  /*;AN000;*/

   /* initialize control variables */
   status = NOERROR;                                                   /*;AN000;*/
   descending = FALSE;                                                 /*;AN000;*/
   set_reg_attr = FALSE;                                               /*;AN000;*/
   pmask = mmask = 0x0;                                                /*;AN000;*/
   file[0] = '\0';                                                     /*;AN000;*/
   error_file_name[0] = '\0';                                          /*;AN000;*/

   /* load messages */
   sysloadmsg(&inregs,&outregs);                                       /*;AN000;*/
   if (outregs.x.cflag & CARRY) {                                      /*;AN000;*/
      sysdispmsg(&outregs,&outregs);                                   /*;AN000;*/
      exit(11);                                                       /*;AN000;*/
      }

   Check_appendx();        /* check APPEND /X status */                /*;AN000;*/
   
   Get_DBCS_vector();      /* get double byte table */                 /*;AN000;*/

   /* parse command line */
   status = Parse_it(line);                                            /*;AN000;*/
   if (status != NOERROR) {                                            /*;AN000;*/
      Parse_err(status);                                               /*;AN000;*/
      }                                                                /*;AN000;*/


   /* Initialize any variables need for next phase of program */
   segread(&segregs);     /* init segment registers for DOS calls */   /*;AN000;*/

   /* make full filespec (drive + full path + filename) */
   strcpy(error_file_name,fspec);                                      /*;AN000;*/
   status = Make_fspec(fspec);                                         /*;AN000;*/
   if (status == NOERROR) {                                            /*;AN000;*/

      /* now do the work! */
      did_attrib_ok = FALSE;  /* needed if file not found and no */    /*;AN000;*/
                              /* error detected in Attrib().     */
		if (descending)
			WildCard = TRUE ;		/* descending is equivalent to Wild Card */

      status = Do_dir(fspec,file);                                     /*;AN000;*/
      if (status == NOERROR && did_attrib_ok == FALSE)                 /*;AN000;*/
         status = FILENOTFOUND;                                        /*;AN000;*/
      }                                                                /*;AN000;*/

   /* determine if there was an error after attempt to do attrib function */
   /* NOTE: for ext. attr. calls, add 200 to the return code to get the   */
   /* ----  error code for this switch.                                   */
   switch(status) { /* Extended error codes */                         /*;AN000;*/
      case 0:                                                          /*;AN000;*/
             break;                                                    /*;AN000;*/
      case 2:       /* File not found */                               /*;AN000;*/
             Error_exit(ERR_EXTENDED,2,ONEPARM);                       /*;AN000;*/
             break;                                                    /*;AN000;*/
      case 3:       /* Path not found */                               /*;AN000;*/
             Error_exit(ERR_EXTENDED,3,ONEPARM);                       /*;AN000;*/
             break;                                                    /*;AN000;*/
      case 5:       /* Access Denied */                                /*;AN000;*/
             Error_exit(ERR_EXTENDED,5,ONEPARM);                       /*;AN000;*/
             break;                                                    /*;AN000;*/
      case 15:      /* Invalid drive specification */                  /*;AN000;*/
             Error_exit(ERR_EXTENDED,15,ONEPARM);                      /*;AN000;*/
             break;                                                    /*;AN000;*/
      default:      /* Access Denied */                                /*;AN000;*/
             Error_exit(ERR_EXTENDED,5,ONEPARM);                       /*;AN000;*/
             break;                                                    /*;AN000;*/
      }                                                                /*;AN000;*/
   Reset_appendx();                                                    /*;AN000;*/

return(status);

}  /* end of inmain */                                                 /*;AN000;*/


/**/
/*                                                                           */
/*    Subroutine Name: Display_msg                                           */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Display the requested message to a given output device              */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Number of the message to be displayed (see ATTRIB.SKL)         */
/*        (2) Output device handle                                           */
/*        (3) Number of substitution parameters (%1,%2)                      */
/*        (4) Offset of sublist control block                                */
/*        (5) Message Class, 0=no input, 1=input via INT 21 AH=1             */
/*                                                                           */
/*    Output:                                                                */
/*        The message is written to the given output device.  If input       */
/*        was requested, the character code of the key pressed is returned   */
/*        in outregs.x.ax.                                                   */
/*                                                                           */
/*    Normal exit: Message written to handle                                 */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              Sysdispmsg (module _msgret.sal)                              */
/*                                                                           */
/**/

void Display_msg(msgnum,msghan,msgparms,msgsub,msginput)               /*;AN000;*/
   int   msgnum;                                                       /*;AN000;*/
   int   msghan;                                                       /*;AN000;*/
   int   msgparms;                                                     /*;AN000;*/
   int   *msgsub;                                                      /*;AN000;*/
   char  msginput;                                                     /*;AN000;*/
{
   inregs.x.ax = msgnum;                                               /*;AN000;*/
   inregs.x.bx = msghan;                                               /*;AN000;*/
   inregs.x.cx = msgparms;                                             /*;AN000;*/
   inregs.h.dh = utility_msg_class;                                    /*;AN000;*/
   inregs.h.dl = msginput;                                             /*;AN000;*/
   inregs.x.si = (WORD)msgsub;                                         /*;AN000;*/
   sysdispmsg(&inregs,&outregs);                                       /*;AN000;*/

   /* check for error printing message */
   if (outregs.x.cflag & CARRY) {                                      /*;AN000;*/
      outregs.x.bx = (WORD) STDERR;                                    /*;AN000;*/
      outregs.x.si = NOSUBPTR;                                         /*;AN000;*/
      outregs.x.cx = NOSUBCNT;                                         /*;AN000;*/
      outregs.h.dl = exterr_msg_class;                                 /*;AN000;*/
      sysdispmsg(&outregs,&outregs);                                   /*;AN000;*/
      }                                                                /*;AN000;*/
}


/**/
/*                                                                           */
/*     Subroutine Name:     Get_far_str()                                    */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        copies a filename from source to the target. The source is offset  */
/*        from the code segment instead of the data segment.                 */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: target = source                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Get_far_str(target,source,length)                                 /*;AN000;*/
   char *target;                                                       /*;AN000;*/
   DWORD *source;               /* segment = cs register */            /*;AN000;*/
   WORD  length;                                                       /*;AN000;*/
{                                                                      /*;AN000;*/
   char far *fptr;                                                     /*;AN000;*/
   WORD i;                                                             /*;AN000;*/

   if (length == 0) {                                                  /*;AN000;*/

      /* copy string in data segment */
      for (fptr = (char far *) *((DWORD *)source);(char)*fptr != NUL;) /*;AN000;*/
         *target++ = (char) *fptr++;                                   /*;AN000;*/
      *target = *fptr;  /*EOS character */                             /*;AN000;*/
      }                                                                /*;AN000;*/
   else {

      /* copy string in data segment */
      for (fptr = (char far *) *((DWORD *)source),i=0;i < length;i++)  /*;AN000;*/
         *target++ = (char) *fptr++;                                   /*;AN000;*/
      *target = 0x0;    /*EOS character */                             /*;AN000;*/
      }
   strcpy(fix_es_reg,NUL); /* fix for es reg. after using far ptr */   /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Dexit(s)                                          */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Does a DOS terminate.                                              */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: target = source                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Dexit(s)                                                          /*;AN000;*/
   WORD  s;                                                            /*;AN000;*/
{                                                                      /*;AN000;*/
   Reset_appendx();             /* Reset APPEND /X status */           /*;AN000;*/
   exit(s);
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Dallocate()                                      */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Does a DOS allocate of length (in paragraphs).                     */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: target = source                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD *Dallocate(s)                                                     /*;AN000;*/
   WORD s;       /* length in bytes */                                 /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD length;  /*length in paragraphs */                             /*;AN000;*/

   length = (s / 16 + 1);                                              /*;AN000;*/
   inregs.x.bx = length;                                               /*;AN000;*/
   inregs.x.ax = 0x4800;                                               /*;AN000;*/
   intdos(&inregs,&outregs);                                           /*;AN000;*/
   if (outregs.x.cflag & CARRY) {                                      /*;AN000;*/
      Error_exit(ERR_EXTENDED,8,NOSUBCNT);                             /*;AN000;*/
      }                                                                /*;AN000;*/
   return((WORD *)outregs.x.ax);                                       /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Dfree()                                          */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Does a DOS de-allocate.                                            */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: target = source                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Dfree(segment)                                                    /*;AN000;*/
   WORD segment;                                                       /*;AN000;*/
{                                                                      /*;AN000;*/
   segregs.es = segment;                                               /*;AN000;*/
   inregs.x.ax = 0x4900;                                               /*;AN000;*/
   intdosx(&inregs,&outregs,&segregs);                                 /*;AN000;*/
   if (outregs.x.cflag & CARRY) {                                      /*;AN000;*/
      Error_exit(ERR_EXTENDED,8,NOSUBCNT);                             /*;AN000;*/
      }                                                                /*;AN000;*/
   strcpy(fix_es_reg,NUL); /* fix for es reg. after using far ptr */   /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Copy_far_ptr()                                   */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Copies a far ptr declared in any form to a real far ptr variable.  */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: status = NOERROR                                          */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Copy_far_ptr(p1_addr, p2_addr)                                    /*;AN000;*/
   DWORD *p1_addr;                                                     /*;AN000;*/
   WORD  *p2_addr;                                                     /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD  *dptr, *tptr;                                                 /*;AN000;*/

   dptr = (WORD *)p2_addr;                                             /*;AN000;*/
   tptr = (WORD *)p1_addr;                                             /*;AN000;*/

   *tptr++ = *dptr++;                                                  /*;AN000;*/
   *tptr = *dptr;                                                      /*;AN000;*/
   strcpy(fix_es_reg,NUL);       /* fix ES register */                 /*;AN000;*/
}                                                                      /*;AN000;*/

/**/
/*                                                                           */
/*     Subroutine Name:     Parse_it()                                       */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Parses the command line and returns error status.                  */
/*                                                                           */
/*    Input:  line                                                           */
/*                                                                           */
/*    Output: various control variables are set                              */
/*                                                                           */
/*    Normal exit: status = NOERROR                                          */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Parse_it(line)                                                    /*;AN000;*/
   char *line;                                                         /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD  i;                                                            /*;AN000;*/
   WORD  status;                                                       /*;AN000;*/
   WORD  no_value;                                                     /*;AN000;*/
   WORD  got_fn;         /* got filename - required parameter */       /*;AN000;*/
   WORD  pa,                                                           /*;AN000;*/
         ma,                                                           /*;AN000;*/
         pr,                                                           /*;AN000;*/
         mr,                                                           /*;AN000;*/
	 ps,							       /*;AN005;*/
	 ms,							       /*;AN005;*/
	 ph,							       /*;AN005;*/
	 mh;							       /*;AN005;*/
   char *ptr;
   BYTE  p_mask[8],
         m_mask[8];                                                    /*;AN000;*/

   /* do setup for parser */
   for (i=0; i<8; i++) {                                               /*;AN000;*/
      p_mask[i] = m_mask[i] = 0;                                       /*;AN000;*/
      }                                                                /*;AN000;*/
   do_reg_attr = TRUE;                                                 /*;AN000;*/
   set_reg_attr = FALSE;                                               /*;AN000;*/
   no_value = TRUE;            /* no value found for keyword */        /*;AN000;*/
   got_fn = FALSE;             /* no filename yet */                   /*;AN000;*/

   inregs.x.si = (WORD)line;      /* Make DS:SI point to source */     /*;AN000;*/
   inregs.x.cx = 0;               /* Operand ordinal */                /*;AN000;*/
   inregs.x.di = (WORD)&p_p1;     /* Address of parm list */           /*;AN000;*/
   status = p_no_error;           /* Init no error condition */        /*;AN000;*/

   /* loop until error or end_of_line */
   while (status == p_no_error) {                                      /*;AN000;*/
      parse(&inregs,&outregs);                                         /*;AN000;*/
      status = outregs.x.ax;       /* get error status */              /*;AN000;*/

      /* check for errors, continue if none */
      if (status == p_no_error) {                                      /*;AN000;*/

         /* check if first positional */
         if (outregs.x.dx == (WORD)&pos1_buff) {                       /*;AN000;*/
            if (*(char *)pos1_buff.p_result_buff[0] == '+')  {         /*;AN000;*/
               p_mask[0] |= pos1_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            else {                                                     /*;AN000;*/
               m_mask[0] |= pos1_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            set_reg_attr = TRUE;                                       /*;AN000;*/
            do_reg_attr = FALSE;                                       /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check if second positional */
         if (outregs.x.dx == (WORD)&pos2_buff) {                       /*;AN000;*/
            if (*(char *)pos2_buff.p_result_buff[0] == '+') {          /*;AN000;*/
               p_mask[1] |= pos2_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            else {                                                     /*;AN000;*/
               m_mask[1] |= pos2_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            set_reg_attr = TRUE;                                       /*;AN000;*/
            do_reg_attr = FALSE;                                       /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check if third positional - added Oct 1989, by leaf */
         if (outregs.x.dx == (WORD)&pos3_buff) {
            if (*(char *)pos3_buff.p_result_buff[0] == '+')  {
               p_mask[2] |= pos3_buff.p_item_tag;
               }
            else {
               m_mask[2] |= pos3_buff.p_item_tag;
               }
            set_reg_attr = TRUE;
            do_reg_attr = FALSE;
            }

         /* check if fourth positional - added Oct 1989 */
	 if (outregs.x.dx == (WORD)&pos4_buff) {
            if (*(char *)pos4_buff.p_result_buff[0] == '+') {
               p_mask[3] |= pos4_buff.p_item_tag;
               }
            else {
               m_mask[3] |= pos4_buff.p_item_tag;
               }
            set_reg_attr = TRUE;
            do_reg_attr = FALSE;
            }

         /* check if fifth positional */
         if (outregs.x.dx == (WORD)&pos5_buff) {                       /*;AN000;*/

            /* copy filename from far string to data segment string */
            Get_far_str(fspec,(DWORD *)pos5_buff.p_result_buff,0);     /*;AN000;*/
            got_fn = TRUE;                                             /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check if sixth positional */
         if (outregs.x.dx == (WORD)&pos6_buff) {                       /*;AN000;*/
            if (*(char *)pos6_buff.p_result_buff[0] == '+')  {         /*;AN000;*/
               p_mask[4] |= pos6_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            else {                                                     /*;AN000;*/
               m_mask[4] |= pos6_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            set_reg_attr = TRUE;                                       /*;AN000;*/
            do_reg_attr = FALSE;                                       /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check if seventh positional */
         if (outregs.x.dx == (WORD)&pos7_buff) {                       /*;AN000;*/
            if (*(char *)pos7_buff.p_result_buff[0] == '+') {          /*;AN000;*/
               p_mask[5] |= pos7_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            else {                                                     /*;AN000;*/
               m_mask[5] |= pos7_buff.p_item_tag;                      /*;AN000;*/
               }                                                       /*;AN000;*/
            set_reg_attr = TRUE;                                       /*;AN000;*/
            do_reg_attr = FALSE;                                       /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check if eighth positional - added Oct 1989 */
         if (outregs.x.dx == (WORD)&pos8_buff) {
            if (*(char *)pos8_buff.p_result_buff[0] == '+') {
               p_mask[6] |= pos8_buff.p_item_tag;
               }
            else {
               m_mask[6] |= pos8_buff.p_item_tag;
               }
            set_reg_attr = TRUE;
            do_reg_attr = FALSE;
            }

         /* check if ninth positional - added Oct 1989 */
         if (outregs.x.dx == (WORD)&pos9_buff) {
            if (*(char *)pos9_buff.p_result_buff[0] == '+') {
               p_mask[7] |= pos9_buff.p_item_tag;
               }
            else {
               m_mask[7] |= pos9_buff.p_item_tag;
               }
            set_reg_attr = TRUE;
            do_reg_attr = FALSE;
            }


         /* check for '/S' switch */
         if (outregs.x.dx == (WORD)&sw_buff) {                         /*;AN000;*/

            /* check if duplicate switch */
            if (descending == TRUE) {                                  /*;AN000;*/
                status = p_syntax;                                     /*;AN000;*/
                }                                                      /*;AN000;*/
            descending = TRUE;                                         /*;AN000;*/
            }                                                          /*;AN000;*/

         /* check for '/?' switch */
         if (outregs.x.dx == (WORD)&sw2_buff)
			{
				for (i = MSG_OPTIONS_FIRST; i <= MSG_OPTIONS_LAST; i++)
            	Display_msg(i, STDOUT, NOSUBPTR, NOSUBCNT, NOINPUT);          
				Dexit(0);
         }    


         }     /* if no error */                                       /*;AN000;*/

      /* error, check if this is first positional, if so try again */
      /* using the second positional because they are optional    */
      else if (inregs.x.cx == 0 || inregs.x.cx == 1 ||                 /*;AN000;*/
               inregs.x.cx == 2 || inregs.x.cx == 3 || inregs.x.cx == 4 ||
               inregs.x.cx == 5 || inregs.x.cx == 6 ||
               inregs.x.cx == 7 || inregs.x.cx == 8) {                 /*;AN000;*/
         inregs.x.cx++;    /* try next positional */                   /*;AN000;*/

           /* Check for a filename beginning with '+' because parser will drop */
         /* the plus sign anyways, and we need to flag it as an error        */
         for(ptr=(char *)inregs.x.si; *ptr == ' '; ptr++)              /*;AN000;*/
            /* NULL statement */ ;                                     /*;AN000;*/
         if ((*ptr == '+') || (*ptr == '-'))                           /*;AN000;*/
            status = p_syntax;                                         /*;AN000;*/
         else                                                          /*;AN000;*/
            status = p_no_error;                                       /*;AN000;*/
         strcpy(fix_es_reg,NUL);                                       /*;AN000;*/

         continue;  /* go back up to while loop */                     /*;AN000;*/
         }                                                             /*;AN000;*/

      if (status == p_no_error) {                                      /*;AN000;*/
         inregs.x.cx = outregs.x.cx;       /* update CX for parser */  /*;AN000;*/
         inregs.x.si = outregs.x.si;       /* update SI for parser */  /*;AN000;*/
         }                                                             /*;AN000;*/
      }   /* while loop */                                             /*;AN000;*/

   /* check error status and if at end of line */
   if (status == p_rc_eol) {                                           /*;AN000;*/
      status = p_no_error;                                             /*;AN000;*/
      }                                                                /*;AN000;*/

   /* Check for filename on command line */
   if (!got_fn && status == p_no_error) {                              /*;AN000;*/
       strcpy(fspec, "*.*");
      }                                                                /*;AN000;*/

   /* Check for drive designation */
   if ( (status == p_no_error) && (fspec[1] == ':') && (fspec[2] == '\0') )
       strcat(fspec, "*.*");

   /* Check for keyword and equal sign but no value */
   if (!no_value) {                                                    /*;AN000;*/
      status = p_syntax;                                               /*;AN000;*/
      }                                                                /*;AN000;*/

   /* check for duplicate +R +R (or S,H,A) or -R -R (S,H,A) */	       /*;AN005;*/
     for (pr=0,mr=0,pa=0,ma=0,ps=0,ms=0,ph=0,mh=0,i=0; i<4; i++) {     /*;AN005;*/
      if (p_mask[i] & READONLY)                                        /*;AN000;*/	
	 pr++;							       /*;AN000;*/
      if (m_mask[i] & READONLY) 				       /*;AN005;*/
         mr++;                                                         /*;AN000;*/
      if (p_mask[i] & ARCHIVE)                                         /*;AN000;*/
         pa++;                                                         /*;AN000;*/
      if (m_mask[i] & ARCHIVE)                                         /*;AN000;*/
         ma++;                                                         /*;AN000;*/
      if (p_mask[i] & SYSTEM)					       /*;AN005;*/
	 ps++;							       /*;AN005;*/
      if (m_mask[i] & SYSTEM)					       /*;AN005;*/
	 ms++;							       /*;AN005;*/
      if (p_mask[i] & HIDDEN)					       /*;AN005;*/
	 ph++;							       /*;AN005;*/
      if (m_mask[i] & HIDDEN)					       /*AN005;*/
	 mh++;							       /*AN005;*/
      }                                                                /*;AN000;*/
     if ((pr > 1) || (mr > 1) || (pa > 1) || (ma > 1) || (ps > 1)  
         || (ms > 1) || (ph > 1) || (mh > 1))  {	
      status = p_syntax;                                               /*;AN000;*/
      }                                                                /*;AN000;*/
   else {                                                              /*;AN000;*/
      for (pmask=0,mmask=0,i=0; i<8; i++) {                            /*;AN000;*/
         pmask |= p_mask[i];                  /* combine masks */      /*;AN000;*/
         mmask |= m_mask[i];                                           /*;AN000;*/
         }                                                             /*;AN000;*/
  	}      							   /*;AN000;*/

   /* check for duplicate -R +R or -A +A (S,H) */
   if ((pmask & mmask & READONLY) || (pmask & mmask & SYSTEM)
       || (pmask & mmask & HIDDEN) ||
       (pmask & mmask & ARCHIVE)) {				       /*;AN000;*/
      status = p_syntax;                                               /*;AN000;*/
      }                                                                /*;AN000;*/
   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Make_fspec()                                     */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Makes a full path-filename from the filename & current directory   */
/*        information.                                                       */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Make_fspec(fspec)                                                 /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD Check_DBCS();       /* forward declaration */                  /*;AN000;*/

   char path[256];                                                     /*;AN000;*/
   WORD status;                                                        /*;AN000;*/
   WORD i,j;                                                           /*;AN000;*/

   status = NOERROR;                                                   /*;AN000;*/

   strcpy(path,fspec);                                                 /*;AN000;*/

   /* Check if user did not enter a drive letter */
   if (fspec[1] != ':') {                                              /*;AN000;*/
      inregs.x.ax = 0x1900;         /* Get current drive */            /*;AN000;*/
      intdos(&inregs,&outregs);                                        /*;AN000;*/
      fspec[0] = (char)('A' + (outregs.x.ax & 0xff));                  /*;AN000;*/
      fspec[1] = ':';                                                  /*;AN000;*/
      fspec[2] = NUL;                                                  /*;AN000;*/
      strcat(fspec,path);                                              /*;AN000;*/
      }                                                                /*;AN000;*/

   /* Check if user didn't enter a path in filename */
   if (!Check_DBCS(fspec,2,'\\')) {                                    /*;AN000;*/
      strcpy(path,&fspec[2]);                                          /*;AN000;*/
      fspec[2] = '\\';                                                 /*;AN000;*/
      inregs.x.ax = 0x4700;            /* Get current directory */     /*;AN000;*/
      inregs.x.si = (WORD)(&fspec[3]);                                 /*;AN000;*/
      inregs.h.dl = fspec[0] - 'A' +1;                                 /*;AN000;*/
      intdos(&inregs,&outregs);                                        /*;AN000;*/
      status = outregs.x.ax;                                           /*;AN000;*/

      if (!(outregs.x.cflag & CARRY)) {                                /*;AN000;*/
         status = NOERROR;                                             /*;AN000;*/
         if (!Check_DBCS(fspec,strlen(fspec)-1,'\\'))                  /*;AN000;*/
            strcat(fspec,"\\");                                        /*;AN000;*/
         strcat(fspec,path);                                           /*;AN000;*/
         }                                                             /*;AN000;*/
      }                                                                /*;AN000;*/

   /* seperate the file specification into path and filename */
   for (i=strlen(fspec);(i>=0) && (!Check_DBCS(fspec,i,'\\')); i--)    /*;AN000;*/
      /* null statement */ ;                                           /*;AN000;*/
   i++;                                                                /*;AN000;*/
   j = 0;                                                              /*;AN000;*/
   while (fspec[i+j] != '\0') {                                        /*;AN000;*/
      file[j] = fspec[i+j];                                            /*;AN000;*/
      fspec[i+j] = '\0';                                               /*;AN000;*/
      j++;                                                             /*;AN000;*/
      }                                                                /*;AN000;*/
   file[j] = '\0';                                                     /*;AN000;*/

   /* Check for filenames of: . (current dir) .. (parent dir) */
   if (strcmp(file,".") == 0)                                          /*;AN001;*/
      strcpy(file,"*.*");                                              /*;AN001;*/
   else if (strcmp(file,"..") == 0) {                                  /*;AN001;*/
      strcat(fspec,"..\\");                                            /*;AN001;*/
      strcpy(file,"*.*");                                              /*;AN001;*/
      }

	for (i=0; file[i]; i++) {
		if ( (file[i]=='?') || (file[i]=='*') ) {
			WildCard = TRUE ;
			break ;
		}
	}

   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Dta_save()                                       */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*                  saves an area in the PSP, but who knows.                 */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Dta_save(t,l)
   char   *t;
   unsigned l;
{
   unsigned i;

   for (i = 0; i < l; i++) *(t+i) = getpspbyte(0x80+i)
      /* null statement */  ;
 }


/**/
/*                                                                           */
/*     Subroutine Name:     Dta_restore()                                    */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*              Restores the data that was saved in Dta_save().              */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: target = source                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Dta_restore(t,l)
   char     *t;
   unsigned l;
{
   unsigned i;

   for (i = 0; i < l; i++) putpspbyte(0x80+i,*(t+i))
      /* null statement */  ;
}


/**/
/*                                                                           */
/*     Subroutine Name:     Find_first()                                     */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Find_first(s,f,a,r)
   char  *s;
   char  *f;
   WORD  *a;
   WORD  *r;
{
   WORD  status;
   WORD  i;

   *f = '\0';

   inregs.x.ax = 0x4e00;             /* DOS find first */
   inregs.x.cx = (*a & 0x00ff );
   inregs.x.dx = (WORD)s;
   intdos(&inregs,&outregs);
   status = outregs.x.ax;

   /* Check for no errors */
   if (!(outregs.x.cflag & CARRY)) {
      for (i = 0; i < 14; i++)
          *f++ = getpspbyte(0x80+30+i);
      *r = getpspbyte(0x80+21);  
      status = NOERROR;
      }
   return(status);
}


/**/
/*                                                                           */
/*     Subroutine Name:     Find_next()                                      */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Find_next(f,r)
   char  *f;
   WORD  *r;
{
   WORD  status;
   WORD  i;
   char  *t;

   t = f;
   *f = '\0';

   inregs.x.ax = 0x4f00;          /* DOS find next */
   intdos(&inregs,&outregs);
   status = outregs.x.ax;

   if (!(outregs.x.cflag & CARRY)) {
      for (i = 0; i < 14; i++)
          *f++ = getpspbyte(0x80+30+i);
      *r = getpspbyte(0x80+21); 
      status = NOERROR;
      }
   return(status);
}


/**/
/*                                                                           */
/*     Subroutine Name:     Get_reg_attrib()                                 */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Does a DOS get attribute byte.                                   */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: return = 0                                                */
/*                                                                           */
/*    Error exit: return = error code                                        */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Get_reg_attrib(fspec,attr_byte)                                   /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
   BYTE *attr_byte;                                                    /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/

   inregs.x.ax = (WORD)0x4300;                                         /*;AN000;*/
   inregs.x.dx = (WORD)fspec;                                          /*;AN000;*/
   intdos(&inregs,&outregs);                                           /*;AN000;*/
   status = outregs.x.ax;                                              /*;AN000;*/

   /* Check for error */                                               /*;AN000;*/
   if (!(outregs.x.cflag & CARRY)) {                                   /*;AN000;*/
      *attr_byte = (BYTE)outregs.h.cl;                                 /*;AN000;*/
      status = NOERROR;                                                /*;AN000;*/
      }                                                                /*;AN000;*/
   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Ext_open()                                       */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Does a DOS extended open of a filename and returns a file handle.*/
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: handle = file handle, return = 0                          */
/*                                                                           */
/*    Error exit: handle = ?; return = error code                            */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Ext_open(fspec,handle)                                            /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
   WORD *handle;                                                       /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/

   inregs.x.ax = (WORD)0x6c00;                                         /*;AN000;*/
   inregs.x.bx = (WORD)0x80;                                           /*;AN000;*/
   inregs.x.cx = (WORD)0x0;                                            /*;AN000;*/
   inregs.x.dx = (WORD)0x0101;                                         /*;AN000;*/
   inregs.x.si = (WORD)fspec;                                          /*;AN000;*/
   inregs.x.di = (WORD)&plist;                                         /*;AN000;*//*;AN000;*/
   intdos(&inregs,&outregs);                                           /*;AN000;*/
   status = outregs.x.ax;                                              /*;AN000;*/

   /* Check for error */                                               /*;AN000;*/
   if (!(outregs.x.cflag & CARRY)) {                                   /*;AN000;*/
      *handle = outregs.x.ax;                                          /*;AN000;*/
      status = NOERROR;                                                /*;AN000;*/
      }                                                                /*;AN000;*/
   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Set_reg_attrib()                                 */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Sets the attribute byte of a file (not extended attributes).     */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Set_reg_attrib(fspec,attr_byte)                                   /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
   BYTE attr_byte;                                                     /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/

   /* set attribute byte (archive & read-only bits) */
   inregs.x.ax = 0x4301;          /* do DOS chmod call  */             /*;AN000;*/
   inregs.x.dx = (WORD)fspec;                                          /*;AN000;*/
   inregs.h.ch = 0x0;                                                  /*;AN000;*/
   inregs.h.cl = (BYTE)attr_byte;                                      /*;AN000;*/
   intdos(&inregs,&outregs);                                           /*;AN000;*/
   status = outregs.x.ax;                                              /*;AN000;*/
                                                                       /*;AN000;*/
   /* Check for error */
   if (!(outregs.x.cflag & CARRY))
      status = NOERROR;                                                /*;AN000;*/
   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     CheckYN()                                        */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Check for a valid Yes/No answer.                                 */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD CheckYN(fspec)                                                    /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD answer;                                                        /*;AN000;*/
   WORD key;                                                           /*;AN000;*/

   while (TRUE) {                                                      /*;AN000;*/
      msg_str2.sub_value_seg = segregs.ds;                             /*;AN000;*/
      msg_str2.sub_value = (WORD)fspec;                                /*;AN000;*/
      Display_msg(11,STDOUT,ONEPARM,(int *)&msg_str2,INPUT);           /*;AN000;*/
      key = outregs.x.ax;          /* get key from AX */               /*;AN000;*/
      inregs.x.dx = key;           /* put key in DX */                 /*;AN000;*/
      inregs.x.ax = 0x6523;        /* check Y/N */                     /*;AN000;*/
      intdos(&inregs,&outregs);                                        /*;AN000;*/
      answer = outregs.x.ax;                                           /*;AN000;*/
      Display_msg(14,STDOUT,NOSUBPTR,NOSUBCNT,NOINPUT);                /*;AN000;*/

      if (answer == YES || answer == NO)                               /*;AN000;*/
         break;                                                        /*;AN000;*/
      }                                                                /*;AN000;*/
   return(answer);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*    Subroutine Name: Convert_date                                          */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Convert date word returned by DOS to the form required by the       */
/*       message retriever.                                                  */
/*                                                                           */
/*       DOS returns:   yyyyyyym mmmddddd                                    */
/*                                                                           */
/*                      y = 0-119 (1980-2099)                                */
/*                      m = 1-12                                             */
/*                      d = 1-31                                             */
/*                                                                           */
/*       Message retriever requires:  yyyyyyyy yyyyyyyy mmmmmmmm dddddddd    */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Date word in form given by DOS                                 */
/*        (2) Address of first word to place result (yyyyyyyy yyyyyyyy)      */
/*        (3) Address of second word to place result (mmmmmmmm dddddddd)     */
/*                                                                           */
/*    Output:                                                                */
/*        Double word result updated with date in form required by           */
/*        message retriever.                                                 */
/*                                                                           */
/*    Normal exit: Result word updated                                       */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Convert_date(dosdate,msgdate1,msgdate2)
   WORD dosdate;
   WORD *msgdate1;
   WORD *msgdate2;
{
   WORD     day,month,year;

   year = dosdate;
   year = ((year >> 1) & 0x7f00) + 80*256;   /* DOS year + 80 */
   year = (year >> 8) & 0x007f;                                        /*;AN000;*/
   day = dosdate;
   day = (day << 8) & 0x1f00;
   month = dosdate;
   month = (month >> 5) & 0x000f;
   *msgdate1 = year;
   *msgdate2 = month | day;
}


/**/
/*                                                                           */
/*    Subroutine Name: Convert_time                                          */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Convert time word returned by DOS to the form required by the       */
/*       message retriever.                                                  */
/*                                                                           */
/*       DOS returns:   hhhhhmmm mmmsssss                                    */
/*                                                                           */
/*                      h = hours (0-23)                                     */
/*                      m = minutes (0-59)                                   */
/*                      s = seconds/2                                        */
/*                                                                           */
/*       Message retriever requires:  hhhhhhhh mmmmmmmm ssssssss hhhhhhhh    */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Time word in form given by DOS                                 */
/*        (2) Address of first word to place result (hhhhhhhh hhhhhhhh)      */
/*        (3) Address of second word to place result (ssssssss 00000000)     */
/*                                                                           */
/*    Output:                                                                */
/*        Double word result updated with time in form required by           */
/*        message retriever.                                                 */
/*                                                                           */
/*    Normal exit: Result word updated                                       */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Convert_time(dostime,msgtime1,msgtime2)
   WORD dostime;
   WORD *msgtime1;
   WORD *msgtime2;
{
   WORD     hours,minutes,seconds;

   hours = dostime;
   hours = hours >> 11 & 0x001f;
   seconds = dostime;
   seconds = seconds & 0x001f * 2;   /* seconds * 2 */
   minutes = dostime;
   minutes = minutes << 3 & 0x3f00;
   *msgtime1 = hours | minutes;
   *msgtime2 = seconds;
}


/**/
/*                                                                           */
/*     Subroutine Name:     Regular_attrib()                                 */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Handles all function for archive, read-only, system                */
/*        and hidden bit.                                                    */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Regular_attrib(fspec)                                             /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/
   WORD i;                                                             /*;AN000;*/
   char string[16];                                                    /*;AN000;*/

   /* get attributes */
   if ((status = Get_reg_attrib(fspec,&attr)) != NOERROR) {            /*;AN000;*/
      return(status);                                                  /*;AN000;*/
      }                                                                /*;AN000;*/
    

   /* Check whether to display values or set new ones */
   if (set_reg_attr) {                                                 /*;AN000;*/
   	/* turn off subdirectory bit, else we will be trying to set it */
    	attr = attr & (~SUBDIR) ;
      if( (attr & HIDDEN) && !(pmask & HIDDEN) && !(mmask & HIDDEN) )  {
         msg_str2.sub_value_seg = segregs.ds;                             
         msg_str2.sub_value = (WORD)fspec;                             
         Display_msg(217,STDOUT,ONEPARM,(int *)&msg_str2,NOINPUT);
       } 
      else
        if( (attr & SYSTEM) && !(pmask & SYSTEM) && !(mmask & SYSTEM) )  {
           msg_str2.sub_value_seg = segregs.ds;              
           msg_str2.sub_value = (WORD)fspec;               
           Display_msg(216,STDOUT,ONEPARM,(int *)&msg_str2,NOINPUT);  
         }
        else  {
            attr = (attr & (~mmask)) | pmask;                                /*;AN000;*/
            status = Set_reg_attrib(fspec,attr);                             /*;AN000;*/
           }
      }                                                                /*;AN000;*/
   else {                                                              /*;AN000;*/
      for (i = 0; i < 8; i++)                                          /*;AN000;*/
         if ((attr & bits[i]) != 0 )                                   /*;AN000;*/
	    string[i] = as[i];					       /*;AN000;*/
         else                                                          /*;AN000;*/
            string[i] = ' ';                                           /*;AN000;*/
      for (i=8; i < 16; i++)                                           /*;AN000;*/
         string[i] = ' ';                                              /*;AN000;*/
      string[16] = '\0';                                               /*;AN000;*/

      msg_str.sub_value_seg = segregs.ds;                              /*;AN000;*/
      msg_str.sub_value = (WORD)string;                                /*;AN000;*/
      msg_str1.sub_value_seg = segregs.ds;                             /*;AN000;*/
      msg_str1.sub_value = (WORD)fspec;                                /*;AN000;*/
      Display_msg(9,STDOUT,TWOPARM,(int *)&msg_str,NOINPUT);           /*;AN000;*/
      }                                                                /*;AN000;*/

   did_attrib_ok = TRUE;                                               /*;AN000;*/
   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Special_attrib()                                 */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Handles all function for special attributes. For example, "DATE" */
/*          is a special attribute because it is not an extended attribute,  */
/*          but ATTRIB does support its function.                            */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Special_attrib(handle,fspec,id)                                   /*;AN000;*/
   WORD handle;                                                        /*;AN000;*/
   char *fspec;                                                        /*;AN000;*/
   WORD id;                                                            /*;AN000;*/
{                                                                      /*;AN000;*/
   WORD status;                                                        /*;AN000;*/
   DWORD filesize;                                                     /*;AN000;*/
   long size;                                                          /*;AN000;*/
   long filelength();                                                  /*;AN000;*/

   msg_str1.sub_value_seg = segregs.ds;                                /*;AN000;*/
   msg_str1.sub_value = (WORD)fspec;                                   /*;AN000;*/

   /* determine which info to get by using ID */
   if (id == A_FILESIZE) {       /* get filesize */                    /*;AN000;*/

      /* get file size, if error return error code */
      if ((size = filelength(handle)) == (long)-1) {                   /*;AN000;*/
         return(FILENOTFOUND);                                         /*;AN000;*/
         }                                                             /*;AN000;*/
      filesize = (DWORD)size;                                          /*;AN000;*/
      msg_dword.sub_value = (WORD)&filesize;                           /*;AN000;*/
      msg_dword.sub_value_seg = (WORD)segregs.ds;                      /*;AN000;*/
      Display_msg(9,STDOUT,TWOPARM,(int *)&msg_dword,NOINPUT);         /*;AN000;*/
      }                                                                /*;AN000;*/

   else if (id == A_DATE) {                                            /*;AN000;*/
      inregs.x.ax = 0x5700;      /* get date */                        /*;AN000;*/
      inregs.x.bx = handle;                                            /*;AN000;*/
      intdos(&inregs,&outregs);                                        /*;AN000;*/
      status = outregs.x.ax;                                           /*;AN000;*/
      if (outregs.x.cflag & CARRY)                                     /*;AN000;*/
         return(status);                                               /*;AN000;*/

      Convert_date(outregs.x.dx,&msg_date.sub_value,&msg_date.sub_value_seg); /*;AN000;*/
      Display_msg(9,STDOUT,TWOPARM,(int *)&msg_date,NOINPUT);          /*;AN000;*/
      }                                                                /*;AN000;*/

   else if (id == A_TIME) {                                            /*;AN000;*/
      inregs.x.ax = 0x5700;      /* get time */                        /*;AN000;*/
      inregs.x.bx = handle;                                            /*;AN000;*/
      intdos(&inregs,&outregs);                                        /*;AN000;*/
      status = outregs.x.ax;                                           /*;AN000;*/
      if (outregs.x.cflag & CARRY)                                     /*;AN000;*/
         return(status);                                               /*;AN000;*/

      Convert_time(outregs.x.cx,&msg_time.sub_value,&msg_time.sub_value_seg); /*;AN000;*/
      Display_msg(9,STDOUT,TWOPARM,(int *)&msg_time,NOINPUT);          /*;AN000;*/
      }                                                                /*;AN000;*/

   did_attrib_ok = TRUE;                                               /*;AN000;*/
   return(NOERROR);                                                    /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Attrib()                                         */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*          Determine what functions the user wants and then gets the        */
/*          extended attributes and regular attributes and then checks       */
/*          the attributes against what the user wanted and either do it or  */
/*          return error.                                                    */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Attrib(path,file)                                                 /*;AN000;*/
   char *path,                                                         /*;AN000;*/
        *file;                                                         /*;AN000;*/
{                                                                      /*;AN000;*/
   char fspec[128];                                                    /*;AN000;*/
   WORD status;                                                        /*;AN000;*/

   strcpy(fspec,path);     /* make full filename */                    /*;AN000;*/
   strcat(fspec,file);                                                 /*;AN000;*/

   /* Check if setting archive bit or readonly bit */
   if (set_reg_attr || do_reg_attr) {                                  /*;AN000;*/
      if ((status = Regular_attrib(fspec)) != NOERROR) {               /*;AN000;*/
         return(status);                                               /*;AN000;*/
         }                                                             /*;AN000;*/
      }                                                               /*;AN000;*/

   return(status);                                                     /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Do_dir()                                         */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Given the full path-filename, determine if descending option is    */
/*        set and then recursively (if option set) find all files in this    */
/*        directory and all files in any subdirectories (if option set).     */
/*        For each directory call Attrib()  which will process a file.       */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

WORD Do_dir(path,file)
   char *path,
        *file;
{
   char     dta_area[128];
   char     subdirectory[256];
   char     next[32];
   WORD     status;
   WORD     search_attrib = ALL3;
   WORD     file_attrib;

   next[0] = '\0';                                                     /*;AN000;*/
   Dta_save(dta_area,128);
   status = NOERROR;                                                   /*;AN000;*/

   /* first, but only if descending, scan for subdirectories */
   if (descending) {
      strcpy(subdirectory,path);
      strcat(subdirectory,"*.*");

      status = Find_first(subdirectory,next,&search_attrib, &file_attrib);

      while (status == NOERROR) {
         if ( (next[0] != '.') && (file_attrib & SUBDIR) ) {
             strcpy(subdirectory,path);
             strcat(subdirectory,next);
             strcat(subdirectory,"\\");
             status = Do_dir(subdirectory,file);
             }

         if (status == NOERROR) {
            strcpy(subdirectory,path);
            strcat(subdirectory,"*.*");

            status = Find_next(next,&file_attrib);
            }
         }     /* while */
      }     /* if descending */

   if (status == NOMOREFILES)
      status = NOERROR;

   /* now, search this directory for files that match */
   if (status == NOERROR) {
      strcpy(subdirectory,path);
      strcat(subdirectory,file);

      status = Find_first(subdirectory,next,&search_attrib, &file_attrib);
      while(status == NOERROR) {

         /* Check that this file is not a '.' or '..' directory file */
			/* If a wild card is specified we don't set attr for SUBDIRs */

         if ( (next[0] != '.') &&
              !(((file_attrib & SUBDIR) && WildCard)) ) {
            status = Attrib(path,next);
         }

         if (status == NOERROR) {
              status = Find_next(next,&file_attrib);
            }
         }      /* while */
       }
   if (status == NOMOREFILES)
      status = NOERROR;

   if (status != NOERROR) {                                           /*;AN000;*/
      }

   Dta_restore(dta_area,128);
   return(status);
}


/**/
/*                                                                           */
/*     Subroutine Name:     Check_appendx()                                  */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Check APPEND /X status.  If it is not active,                      */
/*        do nothing. If it is active, then turn it off                      */
/*        and set flag indicating that fact.                                 */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: append_active_flg                                              */
/*                                                                           */
/*    Normal exit: flag set if /X active                                     */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Check_appendx()                                                   /*;AN000;*/
{                                                                      /*;AN000;*/
   void interrupt far ctl_break_handler();                             /*;AN000;*/
   extern crit_err_handler();                                          /*;AN000;*/
   WORD *ptr;                                                          /*;AN000;*/

   inregs.x.ax = 0xb700;         /* Is appendx installed ? */          /*;AN000;*/
   int86(0x2f,&inregs,&outregs);                                       /*;AN000;*/
   if (outregs.h.al) {                                                 /*;AN000;*/
      inregs.x.ax = 0xb702;           /* Get version */                /*;AN000;*/
      int86(0x2f,&inregs,&outregs);                                    /*;AN000;*/
      if (outregs.x.ax == 0xffff) {                                    /*;AN000;*/
         inregs.x.ax = 0xb706;        /* Get /X status */              /*;AN000;*/
         int86(0x2f,&inregs,&outregs);                                 /*;AN000;*/
         append_x_status = outregs.x.bx;  /* save status to restore */ /*;AN000;*/

         /* turn off append /x */
         inregs.x.ax = 0xb707;        /* Set /X status */              /*;AN000;*/
         inregs.x.bx = append_x_status & INACTIVE;                     /*;AN000;*/
         int86(0x2f,&inregs,&outregs);                                 /*;AN000;*/
         }                                                             /*;AN000;*/
      }                                                                /*;AN000;*/

   /* get critical error handler vector for later */
   inregs.x.ax = 0x3524;       /* get critical error vector */         /*;AN000;*/
   intdosx(&inregs,&outregs,&segregs);                                 /*;AN000;*/
   ptr = (WORD *)&old_int24_off;                                       /*;AN000;*/
   *ptr++ = (WORD)outregs.x.bx;                                        /*;AN000;*/
   *ptr = (WORD)segregs.es;                                            /*;AN000;*/

   /* set crtl-c & critical error handler vector */
   segread(&segregs);
   inregs.x.ax = 0x2523;        /* crtl-c - int 23 */                  /*;AN000;*/
   inregs.x.dx = (WORD) ctl_break_handler;                               /*;AN000;*/
   segregs.ds = (WORD) segregs.cs;                                     /*;AN000;*/
   intdosx(&inregs,&outregs,&segregs);                                 /*;AN000;*/

   inregs.x.ax = 0x2524;        /* critical err - int 24 */            /*;AN000;*/
   inregs.x.dx = (WORD) crit_err_handler;                              /*;AN000;*/
   segregs.ds = (WORD) segregs.cs;                                     /*;AN000;*/
   intdosx(&inregs,&outregs,&segregs);                                 /*;AN000;*/
   strcpy(fix_es_reg,NUL);      /* restore ES register */              /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Reset_appendx()                                  */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Reset APPEND /X status.  If it is not active,                      */
/*        do nothing. If it is active, then turn it on                       */
/*        and set flag indicating that fact.                                 */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: append_active_flg                                              */
/*                                                                           */
/*    Normal exit: flag set if /X active                                     */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/

void Reset_appendx()                                                   /*;AN000;*/
{                                                                      /*;AN000;*/
   if (append_x_status != 0)  {                                        /*;AN000;*/
      inregs.x.ax = 0xb707;                                            /*;AN000;*/
      inregs.x.bx = append_x_status;                                   /*;AN000;*/
      int86(0x2f,&inregs,&outregs);                                    /*;AN000;*/
      }                                                                /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Check_DBCS()                                     */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Given an array and a position in the array, check if the character */
/*        is a non-DBCS character.                                           */
/*                                                                           */
/*    Input:  array, character position, character                           */
/*                                                                           */
/*    Output: TRUE - if array[position-1] != DBCS character  AND             */
/*                      array[position] == character.                        */
/*            FALSE - otherwise                                              */
/*    Normal exit: none                                                      */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/
WORD Check_DBCS(array,position,character)                              /*;AN000;*/
   char *array;                                                        /*;AN000;*/
   WORD position;                                                      /*;AN000;*/
   char character;                                                     /*;AN000;*/
{                                                                      /*;AN000;*/
   BYTE far *ptr;                                                      /*;AN000;*/
   WORD i;                                                             /*;AN000;*/
   char c;                                                             /*;AN000;*/
   char darray[128];        /* DBCS array, put "D" in every position*/ /*;AN000;*/
                            /* that corresponds to the first byte   */
                            /* of a DBCS character.                 */
   for (i=0;i<128;i++)                                                 /*;AN000;*/
      darray[i] = ' ';                                                 /*;AN000;*/

   /* Check each character, starting with the first in string, for DBCS */
   /* characters and mark each with a "D" in the corresponding darray.  */
   for (i=0;i<position;i++) {                                          /*;AN000;*/
      c = array[i];                                                    /*;AN000;*/

      /* look thru DBCS table to determine if character is first byte */
      /* of a double byte character                                   */
      for (ptr=DBCS_ptr; (WORD)*(WORD far *)ptr != 0; ptr += 2) {      /*;AN000;*/

         /* check if byte is within range values of DOS DBCS table */
         if (c >= *ptr && c <= *(ptr+1)) {                             /*;AN000;*/
            darray[i] = 'D';                                           /*;AN000;*/
            i++;           /* skip over second byte of DBCS */         /*;AN000;*/
            break;
            }
         }                                                             /*;AN000;*/
      }                                                                /*;AN000;*/

   /* if character is not DBCS then check to see if it is == to character */
   if (darray[position-1] != 'D' && character == array[position]) {    /*;AN000;*/
      return (TRUE);                                                   /*;AN000;*/
      }                                                                /*;AN000;*/
   else                                                                /*;AN000;*/
      return (FALSE);                                                  /*;AN000;*/
}                                                                      /*;AN000;*/


/**/
/*                                                                           */
/*     Subroutine Name:     Get_DBCS_vector()                                */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Gets the double-byte table vector.                                 */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit: none                                                      */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/
void Get_DBCS_vector()                                                 /*;AN000;*/
{                                                                      /*;AN000;*/
    WORD *ptr;                                                         /*;AN000;*/
    WORD *buffer;                                                      /*;AN000;*/
    DWORD far *addr_ptr;                                               /*;AN000;*/

    /* allocate a buffer for DBCS table vector */
    buffer = Dallocate(5);      /* at least 5 bytes big */             /*;AN000;*/

    inregs.x.ax = 0x6507;      /* get extended country info */         /*;AN000;*/
    inregs.x.bx = -1;             /* use active code page */           /*;AN000;*/
    inregs.x.cx = 5;              /* 5 bytes of return data */         /*;AN000;*/
    inregs.x.dx = -1;             /* use default country */            /*;AN000;*/
    inregs.x.di = 0;              /* buffer offset */                  /*;AN000;*/
    segregs.es = (WORD)buffer;    /* buffer segment */                 /*;AN000;*/
    intdosx(&inregs,&outregs,&segregs);                                /*;AN000;*/
    strcpy(fix_es_reg,NUL);                                            /*;AN000;*/

    outregs.x.di++;            /* skip over id byte */                 /*;AN000;*/

    /* make a far ptr from ES:[DI] */
    addr_ptr = 0;                                                      /*;AN000;*/
    ptr = (WORD *)&addr_ptr;                                           /*;AN000;*/
    *ptr = (WORD)outregs.x.di;   /* get offset */                      /*;AN000;*/
    ptr++;                                                             /*;AN000;*/
    *ptr = (WORD)segregs.es;     /* get segment */                     /*;AN000;*/
    DBCS_ptr = (BYTE far *)*addr_ptr;                                  /*;AN000;*/
    DBCS_ptr += 2;               /* skip over table length */          /*;AN000;*/

    /* DBCS_ptr points to DBCS table */                                /*;AN000;*/
    strcpy(fix_es_reg,NUL);                                            /*;AN000;*/
}                                                                      /*;AN000;*/



/**/
/*                                                                           */
/*     Subroutine Name:     Error_exit()                                     */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        displays an extended error message with - filename                 */
/*                                                                           */
/*    Input:  error_file_name[] must contain name of file, if needed for     */
/*            message output.                                                */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/
void Error_exit(msg_class,ext_err_num,subcnt)                          /*;AN000;*/
                                                                       /*;AN000;*/
   int msg_class;                                                      /*;AN000;*/
   int ext_err_num;                                                    /*;AN000;*/
   int subcnt;                                                         /*;AN000;*/
{                                                                      /*;AN000;*/
   segread(&segregs);                                                  /*;AN000;*/
   msg_error.sub_value_seg = segregs.ds;                               /*;AN000;*/
   msg_error.sub_value = (WORD)error_file_name;                        /*;AN000;*/
   inregs.x.ax = (WORD)ext_err_num;                                    /*;AN000;*/
   inregs.x.bx = STDERR;                                               /*;AN000;*/
   inregs.x.cx = subcnt;                                               /*;AN000;*/
   inregs.h.dh = (BYTE)msg_class;                                      /*;AN000;*/
   inregs.h.dl = NOINPUT;                                              /*;AN000;*/
   inregs.x.si = (WORD)&msg_error;                                     /*;AN000;*/
   sysdispmsg(&inregs,&outregs);                                       /*;AN000;*/

   /* check for error printing message */
   if (outregs.x.cflag & CARRY) {                                      /*;AN000;*/
      outregs.x.bx = (WORD) STDERR;                                    /*;AN000;*/
      outregs.x.si = NOSUBPTR;                                         /*;AN000;*/
      outregs.x.cx = NOSUBCNT;                                         /*;AN000;*/
      outregs.h.dl = exterr_msg_class;                                 /*;AN000;*/
      sysdispmsg(&outregs,&outregs);                                   /*;AN000;*/
      }                                                                /*;AN000;*/

   Dexit(1);
}                                                                      /*;AN000;*/



/**/
/*                                                                           */
/*     Subroutine Name:     Parse_err()                                      */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        displays an parser   error message with - filename                 */
/*                                                                           */
/*    Input:  error_file_name[] must contain name of file, if needed for     */
/*            message output.                                                */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/
void Parse_err(error_num)                                              /*;AN000;*/

   WORD error_num;                                                     /*;AN000;*/
{                                                                      /*;AN000;*/
   char *cptr;                                                         /*;AN000;*/
   char *sptr;                                                         /*;AN000;*/

   /* take out leading spaces, point to beginning of parameter */
   for (sptr = (char *)inregs.x.si; ( (sptr < (char *)outregs.x.si) && (*sptr == BLANK) ); sptr++)  /*;AN000;*/
      /* null statement */ ;                                           /*;AN000;*/

   /* find end of this parameter in command line and put end-of-string there */
   for (cptr = sptr; ((int)cptr) < outregs.x.si && *cptr != BLANK; cptr++)    /*;AN000;*/
      /* null statement */ ;                                           /*;AN000;*/
   *cptr = NUL;                                                        /*;AN000;*/
   strcpy(error_file_name,sptr);                                       /*;AN000;*/

   /* check for messages with no parameter */
   if (error_num == p_op_missing)                                      /*;AN000;*/
      Error_exit(ERR_PARSE,error_num,NOSUBCNT);                        /*;AN000;*/
   else                                                                /*;AN000;*/
      Error_exit(ERR_PARSE,error_num,ONEPARM);                         /*;AN000;*/
}                                                                      /*;AN000;*/




/**/
/*                                                                           */
/*     Subroutine Name:     ctl_break_handler                                  */
/*                                                                           */
/*     Subroutine Function:                                                  */
/*        Crtl-break interrupt handler.                                      */
/*                                                                           */
/*    Input:  none                                                           */
/*                                                                           */
/*    Output: none                                                           */
/*                                                                           */
/*    Normal exit:                                                           */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              None                                                         */
/*                                                                           */
/**/
void interrupt far ctl_break_handler()
{
   Dexit(3);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\attrib.h ===
/*  Module ATTRIB.H  */
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

/**/
/* All defines for attrib.c                                                */
/**/

#define FALSE      0                    /*;AN000;*/
#define TRUE       !FALSE               /*;AN000;*/

#ifndef BYTE
#define BYTE       unsigned char        /*;AN000;*/
#define WORD       unsigned short       /*;AN000;*/
#define DWORD      unsigned long        /*;AN000;*/
#endif

#define CARRY      0x0001               /*;AN000;   carry flag */

#define YES        1                    /*;AN000;   Yes return from int 21h Y/N check */
#define NO         0                    /*;AN000;   NO return from int 21h Y/N check */

#define NUL        0x0                  /*;AN000;*/
#define BLANK      0x20                 /*;AN000;*/
#define TAB        0x09                 /*;AN000;*/
#define CR         0x0d                 /*;AN000;*/
#define LF         0x0a                 /*;AN000;*/

/* Error_exit() parameter values */
#define ERR_EXTENDED 1                  /*;AN000;*/
#define ERR_PARSE    2                  /*;AN000;*/


/* standard file handles */
#define STDIN           0x00            /*;AN000; Standard Input device handle */
#define STDOUT          0x01            /*;AN000; Standard Output device handle */
#define STDERR          0x02            /*;AN000; Standard Error Output device handle */
#define STDAUX          0x03            /*;AN000; Standard Auxiliary device handle */
#define STDPRN          0x04            /*;AN000; Standard Printer device handle */

/* attribute byte defines */
#define AFILE      0x00                 /*;AN000;*/
#define READONLY   0x01                 /*;AN000;*/
#define HIDDEN     0x02                 /*;AN000;*/
#define SYSTEM     0x04                 /*;AN000;*/
#define LABEL      0x08                 /*;AN000;*/
#define SUBDIR     0x10                 /*;AN000;*/
#define ARCHIVE    0x20                 /*;AN000;*/
#define ALL3       HIDDEN | SYSTEM | SUBDIR     /* used by Find_first etc */
#define ARONLY	   READONLY | ARCHIVE 

/* message retriever interface defines */
#define NOSUBPTR   0                    /*;AN000;  no sublist pointer         */
#define NOSUBCNT   0                    /*;AN000;  0 substitution count       */
#define ONEPARM    1                    /*;AN000;  1 substitution count       */
#define TWOPARM    2                    /*;AN000;  2 substitution count       */
#define NOINPUT    0                    /*;AN000;  no user input              */
#define INPUT      1                    /*;AN000;  ask user for Y/N input     */

#define	MSG_OPTIONS_FIRST	300			/* first msg number */
#define MSG_OPTIONS_LAST        308                     /*  & last msg number */


/* misc. defines */
#define A_FILESIZE  1                   /* id of special attribute: filesize */
#define A_DATE      2                   /* id of special attribute: date */
#define A_TIME      3                   /* id of special attribute: time */

#define MAX_ATTR_SIZE 160               /*;AN000;  max ext attribute buffer size */
#define MAX_KEYWORD 128                 /*;AN000;  max size of extended attribute keyword */
#define MAX_SPL     3                   /*;AN000;  max number of special attributes */

#define ATTR_SIZE   7                   /*;AN000;  size in bytes of attr struct */
#define NAME_SIZE   4                   /*;AN000;  size in bytes of name struct */

#define NOERROR      0                  /*;AN000;*/
#define NOMOREFILES 18                  /*;AN000;*/
#define FILENOTFOUND 2                  /*;AN000;*/

#define GET_DATE     1                  /*;AN000;*/
#define GET_TIME     2                  /*;AN000;*/

#define INACTIVE     0x7fff             /*;AN000;*/
/**/
/* All structures defined for attrib.c                                     */
/**/

struct p_null {                        /*;AN000;  a null value list for parser */
    unsigned char null;                /*;AN000;*/
    };                                 /*;AN000;*/

struct query_list {                    /*;AN000;  Generic attribute overlay structure  */
    WORD    ql_num;
    BYTE    ql_type;                   /*;AN000;   EA type          */
    WORD    ql_flags;                  /*;AN000;   EA flags         */
    BYTE    ql_name_len;               /*;AN000;   name length      */
    char    ql_name[MAX_KEYWORD];      /*;AN000;   name             */
    };                                 /*;AN000;*/

struct name_list {                     /*;AN000;  Generic attribute overlay structure  */
    BYTE    nl_type;                   /*;AN000;   EA type          */
    WORD    nl_flags;                  /*;AN000;   EA flags         */
    BYTE    nl_name_len;               /*;AN000;   name length      */
    char    nl_name[MAX_KEYWORD];      /*;AN000;   name             */
    };                                 /*;AN000;*/

struct attr_list {                     /*;AN000;  Generic attribute overlay structure  */
    BYTE    at_type;                   /*;AN000;   EA type          */
    WORD    at_flags;                  /*;AN000;   EA flags         */
    BYTE    at_rc;                     /*;AN000;   EA return code   */
    BYTE    at_name_len;               /*;AN000;   name length      */
    WORD    at_value_len;              /*;AN000;   value length     */
    char    at_name[MAX_KEYWORD];      /*;AN000;   name             */
    };                                 /*;AN000;*/

struct parm_list {                     /*;AN000;  Parm list for extended open DOS call */
    DWORD    pm_list;                  /*;AN000;   extended attr. list */
    WORD     pm_num_parms;             /*;AN000;   number of parameters */
    BYTE     pm_id;                    /*;AN000;   id                  */
    WORD     pm_iomode;                /*;AN000;   iomode              */
    };                                 /*;AN000;*/

struct spl_list {                      /*;AN000;*/
    char     name[MAX_KEYWORD];        /*;AN000;*/
    WORD     id;                       /*;AN000;*/
    };                                 /*;AN000;*/

struct bin_struct {                    /*;AN000;*/
    BYTE     length;                   /*;AN000;*/
    DWORD    dword;                    /*;AN000;*/
    };                                 /*;AN000;*/

union eav_union {                      /*;AN000;*/
    WORD     ea_undef;                 /*;AN000;*/
    BYTE     ea_logical;               /*;AN000;*/
    struct bin_struct ea_bin;          /*;AN000;*/
    char     ea_ascii[129];            /*;AN000;*/
    DWORD    ea_time;                  /*;AN000;*/
    DWORD    ea_date;                  /*;AN000;*/
    };                                 /*;AN000;*/
/**/
/* All global variables for attrib.c                                       */
/**/
struct spl_list specials[MAX_SPL] = {  /*;AN000;*/
   "FILESIZE", A_FILESIZE,             /*;AN000;*/
   "DATE",     A_DATE,                 /*;AN000;*/
   "TIME",     A_TIME };               /*;AN000;*/


/* parser structure variables */
union eav_union ext_attr_value;        /*;AN000; result value union */

/************ OLD VERSION  ************/
;struct p_result_blk  pos1_buff;        /*;AN000; result buffer for -+A,-+R   */
;struct p_result_blk  pos2_buff;        /*;AN000; result buffer for -+A,-+R   */
;struct p_result_blk  pos3_buff;        /*;AN000; result buffer for filespec  */
;struct p_result_blk  pos4_buff;        /*;AN000; result buffer for -+A,-+R   */
;struct p_result_blk  pos5_buff;        /*;AN000; result buffer for -+A,-+R   */
;struct p_result_blk  pos6_buff;        /*;AN000; result buffer for id        */
;struct p_result_blk  pos6b_buff;       /*;AN000; result buffer for id        */
;struct p_result_blk  sw_buff;          /*;AN000; result buffer for /S        */
/************ END OLD ****************/

struct p_result_blk   pos1_buff;        /* result buffer for (+,-)(A,S,H,R) */
struct p_result_blk   pos2_buff;        /* same */
struct p_result_blk   pos3_buff;        /* same */
struct p_result_blk   pos4_buff;        /* same */
struct p_result_blk   pos5_buff;        /* result buffer for filespec */
struct p_result_blk   pos6_buff;        /* result buffer for (+,-)(A,S,H,R) */
struct p_result_blk   pos7_buff;        /* same */
struct p_result_blk   pos8_buff;        /* same */
struct p_result_blk   pos9_buff;        /* same */
struct p_result_blk   pos10_buff;       /* result buffer for id */
struct p_result_blk   pos10b_buff;      /* same */
struct p_result_blk   sw_buff;          /* result buffer for /S */
struct p_result_blk   sw2_buff;  /* LEAF */


char  nullword[]  = "     ";           /*;AN000; used when no word attribute */
char  nulldword[] = "          ";      /*;AN000; used when no double word attribute */
char  nulldate[]  = "        ";        /*;AN000; used when no date attribute */
char  nulltime[]  = "         ";       /*;AN000; used when no time attribute */

char  plusa[]  = "+A";                 /*;AN000; strings for match */
char  minusa[] = "-A";                 /*;AN000;*/
char  plusr[]  = "+R";                 /*;AN000;*/
char  minusr[] = "-R";                 /*;AN000;*/
char  pluss[]  = "+S";                 /* added October 1989, leaf */
char  minuss[] = "-S";                 /* Oct 1989, leaf */
char  plush[]  = "+H";                 /* ditto */
char  minush[] = "-H";                 /* ditto */

struct p_null noval =                  /*;AN000; structure for no value list */
     { 0 };                            /*;AN000;*/

struct ps_valist_blk vals1 =           /*;AN000; +A-A+R-R value list         */
     { p_nval_string,                  /*;AN000;  string value list type     */
       0,                              /*;AN000;  number of ranges           */
       0,                              /*;AN000;  number of numbers          */
       8,                     /*;AN000;  number of strings          */
       0x20,                           /*;AN000;  item tag                   */
       (WORD)plusa,                    /*;AN000;  address of string          */
       0x20,                           /*;AN000;  item tag                   */
       (WORD)minusa,                   /*;AN000;  address of string          */
       0x01,                           /*;AN000;  item tag                   */
       (WORD)plusr,                    /*;AN000;  address of string          */
       0x01,                           /*;AN000;  item tag                   */
       (WORD)minusr,                   /*;AN000;  address of string          */
       0x04,                           /* added Oct 1989 - item tag          */
       (WORD)pluss,                    /* added Oct - address of string */
       0x04,                           /* added Oct - item tag          */
       (WORD)minuss,                   /* added Oct - address of string */
       0x02,                           /* added Oct - item tag */
       (WORD)plush,                    /* added Oct - address of string */
       0x02,                           /* added Oct - item tag */
       (WORD)minush };                 /* added Oct - address of string */

struct p_control_blk p_con1 =          /* describes (+,-)(A,S,H,R)           */
     { 0x2001,                         /*;AN000;  Simple string,optional     */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos1_buff,               /*;AN000;*/
       (WORD)&vals1,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con2 =          /*;AN000; describes +-A or +-R (2nd occurrance) */
     { 0x2001,                         /*;AN000;  Simple string,optional     */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos2_buff,               /*;AN000;*/
       (WORD)&vals1,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con3 =          /* same as 1, 2 */
     { 0x2001,
       0x0002,
       (WORD)&pos3_buff,
       (WORD)&vals1,
       0,
       0 };

struct p_control_blk p_con4 =          /* same as 1, 2, 3 */
     { 0x2001,
       0x0002,
       (WORD)&pos4_buff,
       (WORD)&vals1,
       0,
       0 };

struct p_control_blk p_con5 =          /*;AN000; describes filespec          */
     { 0x0201, 
       0x0001,                         /*;AN000;  Cap result by file table   */
       (WORD)&pos5_buff,               /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con6 =          /*;AN000; describes +-A or +-R        */
     { 0x2001,                         /*;AN000;  Simple string,optional     */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos6_buff,               /*;AN000;*/
       (WORD)&vals1,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con7 =          /*;AN000; describes +-A or +-R (2nd occurrance) */
     { 0x2001,                         /*;AN000;  Simple string,optional     */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos7_buff,               /*;AN000;*/
       (WORD)&vals1,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con8 =          /* same as 1, 2, 3, 4, 6, 7 */
     { 0x2001,
       0x0002,
       (WORD)&pos8_buff,
       (WORD)&vals1,
       0,
       0 };

struct p_control_blk p_con9 =          /* same as 1, 2, 3, 4, 6, 7, 8 */
     { 0x2001,
       0x0002,
       (WORD)&pos9_buff,
       (WORD)&vals1,
       0,
       0 };

struct p_control_blk p_con10 =          /*;AN000; describes id                */
     { 0x2001,                         /*;AN000;  Simple string,optional     */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos10_buff,               /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con10a =         /*;AN000; describes id     */
     { 0x2000,                         /*;AN000;  Simple string   */
       0x0002,                         /*;AN000;  Cap result by char table   */
       (WORD)&pos10_buff,               /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_con10b =         /*;AN000; describes id     */
     { 0xe481,                         /*;AN000;  Quoted string   */
       0x0002,                         /*;AN000;*/
       (WORD)&pos10b_buff,              /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_control_blk p_swi1 =          /*;AN000; Switch control block */
     { 0x0001,                         /*;AN000;  Optional (switch) */
       0x0002,                         /*;AN000;  Cap result by char table */
       (WORD)&sw_buff,                 /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       1,                              /*;AN000;  one switch allowed */
       "/S" };                         /*;AN000;  /S */

struct p_control_blk p_swi2 =          /*;AN000; Switch control block */
     { 0x0001,                         /*;AN000;  Optional (switch) */
       0x0000,                         /*;AN000;  Cap result by char table */
       (WORD)&sw2_buff,                 /*;AN000;*/
       (WORD)&noval,                   /*;AN000;*/
       1,                              /*;AN000;  one switch allowed */
       "/?" };     /*LEAF*/                    /*;AN000;  /S */

struct p_parmsx p_px1 =                /*;AN000; Parser Control definition for Parm Block 1 */
     { 0,                            /* NO arguments required */
       10,                              /*;AN000;*/
       &p_con1,                        /*;AN000;*/
       &p_con2,                        /*;AN000;*/
       &p_con3,                        /*;AN000;*/   
       &p_con4,                        /*;AN000;*/
       &p_con5,                        /*;AN000;*/
       &p_con6,                        /*;AN000;*/
       &p_con7,     
       &p_con8,
       &p_con9,
       &p_con10,
       2,                              /*;AN000;  switches */
       &p_swi1,                        /*;AN000;*/
       &p_swi2,
       0,                              /*;AN000;  keywords*/
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_parms  p_p1 =                 /*;AN000; Parms block for line */
     { &p_px1,                         /*;AN000; Address of extended parm list */
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_parmsx p_px2 =                /*;AN000; Parser Control definition for Parm Block 1 */
     { 1,                              /*;AN000;  positionals */
       2,                              /*;AN000;*/
       &p_con10a,                       /*;AN000;*/
       &p_con10b,                       /*;AN000;*/
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0,                              /* added Oct 1989 */
       0, 
       0, 
       0,
       2,                              /*;AN000;  switches */
       &p_swi1,                        /*;AN000;*/
       &p_swi2,
       0,                              /*;AN000;  keywords*/
       0,                              /*;AN000;*/
       0,                              /*;AN000;*/
       0 };                            /*;AN000;*/

struct p_parms  p_p2 =                 /*;AN000; Parms block for line */
     { &p_px2,                         /*;AN000; Address of extended parm list */
       1,                              /*;AN000;*/
       1,                              /*;AN000;*/
       "=" };                          /*;AN000;*/

/* extended open structure variables */
struct parm_list plist =               /*;AN000;  Extended open parm list */
     { -1,                             /*;AN000;   ptr to attr. list    */
       1,                              /*;AN000;   number of parms      */
       10,                    /*;AN000;   id                   */
       2 };                            /*;AN000;   iomode               */

/* messgages */
struct m_sublist msg_num =             /*;AN000; describes substitutions   */
     { 72,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_unsbin2d | sf_right,         /*;AN000;  unsigned binary to decimal*/
       9,                              /*;AN000;                           */
       9,                              /*;AN000;                           */
       0 };                            /*;AN000;                           */
struct m_sublist msg_str2 =            /*;AN000; describes substitutions   */
     { 60,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_left | sf_char | sf_asciiz,  /*;AN000;  string                   */
       0,                              /*;AN000;  null string              */
       0,                              /*;AN000;                           */
       (BYTE)" " };                    /*;AN000;                           */
struct m_sublist msg_dword =           /*;AN000; describes substitutions   */
     { 48,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_unsbin2d | sf_dword | sf_right, /*;AN000;  unsigned binary to decimal*/
       10,                             /*;AN000;                           */
       9,                              /*;AN000;                           */
       0 };                            /*;AN000;                           */
struct m_sublist msg_date =            /*;AN000; describes substitutions   */
     { 36,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_date | sf_mdy2,              /*;AN000;  unsigned binary to decimal*/
       9,                              /*;AN000;                           */
       9,                              /*;AN000;                           */
       0 };                            /*;AN000;                           */
struct m_sublist msg_time =            /*;AN000; describes substitutions   */
     { 24,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_time12 | sf_hhmm | sf_right, /*;AN000;  unsigned binary to decimal*/
       9,                              /*;AN000;  NN-NN-NNa (9 characters) */
       9,                              /*;AN000;                           */
       0 };                            /*;AN000;                           */
struct m_sublist msg_str =             /*;AN000; describes substitutions   */
     { 12,                             /*;AN000;   for parm one of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       1,                              /*;AN000;                           */
       sf_left | sf_char | sf_asciiz,  /*;AN000;  string                   */
       9,                              /*;AN000;  null string              */
       9,                              /*;AN000;                           */
       (BYTE)" " };                    /*;AN000;                           */
struct m_sublist msg_str1 =            /*;AN000; describes substitutions   */
     { 12,                             /*;AN000;   for parm two of message */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       2,                              /*;AN000;                           */
       sf_left | sf_char | sf_asciiz,  /*;AN000;  string                   */
       0,                              /*;AN000;  null string              */
       0,                              /*;AN000;                           */
       (BYTE)" " };                    /*;AN000;                           */
struct m_sublist msg_error =           /*;AN000; describes substitutions   */
     { 12,                             /*;AN000;   for extended error messages*/
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       0,                              /*;AN000;                           */
       sf_left | sf_char | sf_asciiz,  /*;AN000;  string                   */
       0,                              /*;AN000;  null string              */
       0,                              /*;AN000;                           */
       (BYTE)" " };                    /*;AN000;                           */

/* misc. variables */
union REGS       inregs,               /*;AN000;  Registers */
                 outregs;              /*;AN000;*/
struct SREGS     segregs;              /*;AN000;  Segment registers */

DWORD            old_int24_off;        /*;AN000;*/

WORD             descending;           /*;AN000;*/
WORD             append_x_status;      /*;AN000;*/
WORD             did_attrib_ok;        /*;AN000;*/
WORD             set_reg_attr,         /*;AN000;*/
                 set_ext_attr;         /*;AN000;*/
WORD             do_reg_attr,          /*;AN000;*/
                 do_ext_attr;          /*;AN000;*/

BYTE  far       *DBCS_ptr;             /*;AN000;*/
BYTE             ext_attr_value_type;  /*;AN000;*/
BYTE             attr;                 /*;AN000;*/
BYTE             bits[8] = { 0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01 }; /*;AN000;*/
BYTE             pmask,                /*;AN000;*/
                 mmask;                /*;AN000;*/

char             as[8] = { ' ',' ','A',' ',' ','S','H','R' };           /*;AN000;*/
char             fix_es_reg[1];        /*;AN000;*/
char             ext_attr[MAX_KEYWORD];        /*;AN000;*/
char             error_file_name[256]; /*;AN005;*/
char             fspec[256];           /*;AN000;*/
char             file[256];            /*;AN000;*/
char				  WildCard=0 ; /* Indicates whether wild card was specified */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\attriba.asm ===
page    ,132
	title	New_C.C - DOS entry to the KWC's 'C' programs
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	This module has been modified extensively for my personal
;	use.
;
; name		XCMAIN -- initiate execution of C program
;
; description	This is the main module for a C program on the
;		DOS implementation.  It initializes the segment
;		registers, sets up the stack, and calls the C main
;		function _main with a pointer to the remainder of
;		the command line.
;
;		Also defined in this module is the exit entry point
;		XCEXIT.
;
SETBLOCK   EQU	 4AH			;MODIFY ALLOCATED MEMORY BLOCKS
					;ES = SEGMENT OF THE BLOCK
					;BX = NEW REQUESTED BLOCK SIZE
					;    IN PARAGRAPHS
					;OUTPUT: BX=MAX SIZE POSSIBLE IF CY SET
					;AX = ERROR CODE IF CY SET

RET_CD_EXIT EQU  4CH			;EXIT TO DOS, PASSING RETURN CODE
					;AL=RETURN CODE

RET_EXIT   equ	 4ch			;AN000; ;terminate
ABORT	   equ	 2			;AN000; ;if >=, retry
XABORT	   equ	 1			;AN000; ;errorlevel return in al


	   extrn _inmain:near		;AC000;
	   extrn _Reset_appendx:near	;AN000;
	   extrn _old_int24_off:dword	;AN000;


psp	   segment at 0 		;<--emk
psp_ret    dw	 ?			;int 20h
psp_memsz  dw	 ?			;memory size
	   org	 2ch
psp_env    dw	 ?			;segid of environment
	   org	 80h
psp_parlen db	 ?			;length of DOS command line parms
psp_par    db	 127 dup(?)		;DOS command line parms
psp	   ends
	   page

;
; The following segment serves only to force "pgroup" lower in
; memory.
;

base	   segment PARA PUBLIC 'DATA'

	   db	 00dh,00ah
	   db	 "----------\x0d\x0a"
	   db	 " DOS ATTRIB function \x0d\x0a"
	   db	 "--------------------\x0d\x0a"
	   db	 00dh,00ah,01ah

base	   ends


;
; The data segment defines locations which contain the offsets
; of the base and top of the stack.
;

_data	   segment PARA public 'DATA'

	   irp	 name,<_top,_base,_cs,_ss,_psp,_env,_rax,_rbx,_rcx,_rdx,_rds,_rsi,_rbp,_res,_rdi>
	   public name
name	   dw	 0
	   endm

_data	   ends

;
; The stack segment is included to prevent the warning from the
; linker, and also to define the base (lowest address) of the stack.
;

stack	   segment PARA stack 'stack'

SBase	   dw	 128 dup (?)

stack	   ends

null	   segment para public 'BEGDATA'
null	   ends
const	   segment word public 'CONST'
const	   ends
_bss	   segment word public 'BSS'
	extrn _end:near
_bss	   ends
pgroup	   group base,_text
dgroup	   group null, _data, const, _bss, stack

	   page

;
; The main program must set up the initial segment registers
; and the stack pointer, and set up a far return to the DOS
; exit point at ES:0.  The command line bytes from the program
; segment prefix are moved onto the stack, and a pointer to
; them supplied to the C main module _main (which calls main).
;

_text	   segment PARA public 'CODE'

	   public XCMAIN

	   assume cs:pgroup
	   assume ds:psp		;<--emk
	   assume es:psp		;<--emk
	   assume ss:stack		;<--emk

XCMAIN	   proc  far

	   mov	 ax,dgroup
	   mov	 ds,ax			;initialize ds and ss
	   assume ds:dgroup

;	    mov   bx,psp_memsz		 ;total memory size (paragraphs)
;	    sub   bx,ax
;	    test  bx,0f000h
;	    $IF   Z			 ;branch if more than or equal 64K bytes
;		mov   cl,4
;		shl   bx,cl		 ;highest available byte
;	    $ELSE
;		mov   bx,0fff0h
;	    $ENDIF


	   cli				; disable interrupts while changing stack <---kwc
	   mov	 ss,ax			; set ss <---kwc
;; the original code requested enough space to allow attrib.c to do an "EXEC"
;; which had the effect of disallowing attrib from running in under 75K mem.
;; the attrib.c code never, in fact, did any exec's and so i am modifying it
;; to simply request 4K  (256 paragraphs) which is enough for subsequent
;; memory allocation calls.	FEB 1990, Lea F
;; Make that 8K since /s ran out of stack space sometimes.  May 1990

	   MOV	 sp, offset DGroup:_end + 18384
;	   mov	 sp,bx			; set stack pointer <---kwc
	   sti				;enable interrupts
	   assume ss:DGroup		;<--emk

	   mov	 _ss,ss
	   mov	 _cs,cs
	   mov	 _top,bx		;save top of stack

	   mov	 ax,offset DGroup:SBase
	   mov	 _base,ax		;store ptr to bottom of stack

; COMMENTS WITH TWO SEMICOLONS means the comments themselves have
; also been commented out, i.e. are no longer valid, but left in as
; an explanation of previous methodology
;; code added here to allow allocates and exec's in the c code
;;  we will have to calculate the size of the code that has been loaded

	   mov	 bx,sp			; bx = length of the stack
	   shr	 bx,1
	   shr	 bx,1
	   shr	 bx,1
	   shr	 bx,1			; bx = number of paragraphs in stack,
	   add	 bx,1			;   (fudge factor!)<--emk ,was 10
	   mov	 ax,ss
	   add	 bx,ax			; bx = paragraph a little past the stack
	   mov	 ax,es			; ax = paragraph of the psp
	   sub	 bx,ax			; bx = number of paragraphs in code

	   mov	 ah,setblock
	   int	 021h

; end of added code!

	   mov	 _psp,es		; save pointer to psp for setblock <---kwc
	   mov	 cl,psp_parlen		;get number of bytes <--emk
	   xor	 ch,ch			;cx = number of bytes of parms!
	   mov	 si,offset psp_par	;point to DOS command line parms <--emk

; more modified code, picking up argv[0] from the environment!

	   mov	 ds,psp_env		;set ds to segid of environment from es:psp
	   assume ds:nothing

	   mov	 _env,ds		;remember where environment is

	   mov	 si,0			;clear index to step thru env
;The env has a set of keyword=operand, each one ending with a single null byte.
;At the end of the last one is a double null.  We are looking for the end of
;all these keywords, by looking for the double null.
;	   $DO	 COMPLEX
	   JMP SHORT $$SD1
$$DO1:
	       inc   si 		;bump index to look at next byte in env
;	   $STRTDO
$$SD1:
	       cmp   word ptr [si],0	;is this a double null delimiter?
;	   $ENDDO E			;ifdouble null found, exit
	   JNE $$DO1
;At end of env is the double null and a word counter
	   add	 si,4			;step over this double null delimiter
					; and the following word counter
	   push  si			;save pointer to next field in env
;This is the invocation statement, including the path name, even if not specified
;but supplied by PATH.

;continue stepping thru env looking for one more null byte, which indicates
;the end of the invocation command.
;	   $DO
$$DO4:
	       lodsb			;get a byte from env to al
	       cmp   al,0		;is this a null byte?
;	   $ENDDO E			;quit if null is found
	   JNE $$DO4

	   mov	 bx,si			; bx -> asciiz zero
	   pop	 si			; si -> first byte of agrv[0], the invocation command
	   sub	 bx,si			; bx = length of argv[0]
	   mov	 dx,bx			; (save for the copy later)
	   dec	 dx
	   add	 bx,cx			; add in the length of the rest of the parms
	   inc	 bx			; add one for the asciiz zero!
	   and	 bx,0fffeh		;force even number of bytes
	   add	 bx,2			;adjust for possible rounding error
	   sub	 sp,bx			;allocate space on stack
	   mov	 di,sp			; (es:di) -> where we will put the stuff
	   push  es
	   mov	 ax,ss
	   mov	 es,ax
	   xchg  cx,dx			; length of argv[0] to copy, save length of parms
	   rep	 movsb			; (ds:si) already point to argv[0]
	   pop	 es
	   mov	 ss:byte ptr [di],' '	;store trailing blank!
	   inc	 di
	   mov	 _rdi,di		;AN000; save start of command parms
	   xchg  cx,dx			; restore length of parms
;	   $IF	 NCXZ			;if some bytes to move,
	   JCXZ $$IF6

	       mov   si,offset psp_par	;point to DOS command line parms in psp
;	       $DO
$$DO7:
		   mov	 al,es:[si]	;move bytes to stack
		   mov	 ss:[di],al
		   inc	 si
		   inc	 di
;	       $ENDDO LOOP
	       LOOP $$DO7
;	   $ENDIF			;bytes to move?
$$IF6:
	   xor	 ax,ax
	   mov	 ss:[di],al		;store null byte
	   mov	 ax,ss
	   mov	 ds,ax			;es, ds, and ss are all equal
	   assume ds:DGroup

	   mov	 es,ax			;es, ds, and ss are all equal
	   assume es:DGroup

	   mov	 ax,_rdi		;AN000; restore offset of parms on stack
	   push  ax			;ptr to command line

	   call  _inmain		;AC000; call C main

	   mov	 ah,ret_cd_exit 	;return to DOS
	   int	 21h			;errorlevel ret code in al

XCMAIN	   endp

	   page

;
; name		XCEXIT -- terminate execution of C program
;
; description	This function terminates execution of the current
;		program by returning to DOS.  The error code
;		argument normally supplied to XCEXIT is ignored
;		in this implementation.
;
;	input - al = binary return code for dos/ERRORLEVEL
;

	   assume cs:PGroup
	   assume ds:DGroup
	   assume es:DGroup
	   assume ss:DGroup

	   public xcexit
XCEXIT	   proc  far

	   mov	 ah,ret_cd_exit 	;				<--- kwc
	   int	 021h			;				<--- kwc

XCEXIT	   endp

;--------------------------------------------------------------------------

	   PAGE

CENTER	   MACRO NAMELIST
	   PUSH  BP			; SAVE CURRENT BP
	   MOV	 BP,SP			; POINT AT STACK WITH BP
WORKOFS    =	 0
	   IRP	 ANAME,<NAMELIST>	; FOR EACH WORKING VARIABLE
	   IFNB  <&ANAME>
WORKOFS        =     WORKOFS-2		;  WE WILL ALLOCATE ONE
	       DOEQU &ANAME,%WORKOFS	;   WORD ON THE STACK THAT
	   ENDIF
	   ENDM 			;    IS UNDER SS,BP
	   ADD	 SP,WORKOFS
	   ENDM

DOEQU	   MACRO NAME,VALUE
&NAME	   EQU	 &VALUE
	   ENDM

CEXIT	   MACRO VALUE
	   MOV	 SP,BP
	   POP	 BP
	   RET
	   ENDM

	   PAGE

; INPUT PARAMATERS PASSED ON STACK

PARMS	   STRUC

OLD_BP	   DW	 ?			; SAVED BP
RETADD	   DW	 ?			; RETURN ADDRESS
PARM_1	   DW	 ?
PARM_2	   DW	 ?
PARM_3	   DW	 ?
PARM_4	   DW	 ?
PARM_5	   DW	 ?
PARM_6	   DW	 ?
PARM_7	   DW	 ?
PARM_8	   DW	 ?

PARMS	   ENDS

SAVE_SS    DW	 0
SAVE_SP    DW	 0

	   PAGE

;************************************************************************
;									;
; Subroutine Name:							;
;	getpspbyte							;
;									;
; Subroutine Function:							;
;	 get a byte from PSP						;		      ;
;									;
; Input:								;
;	SS:[BP]+PARM1 = offset in PSP					;
;									;
; Output:								;
;	AL =  byte from PSP:offset					;
;									;
; C calling convention: 						;
;	char = getpspbyte(offset);					;
;									;
;************************************************************************

MOFFSET    EQU	 PARM_1 		;AN000;

	   ASSUME CS:PGROUP		;AN000;
	   ASSUME DS:DGROUP		;AN000;
	   ASSUME ES:DGROUP		;AN000;
	   ASSUME SS:DGROUP		;AN000;

	   PUBLIC _GETPSPBYTE		;AN000;
_GETPSPBYTE PROC NEAR			;AN000;

	   CENTER			;AN000;

	   PUSH  DS			;AN000;

	   MOV	 DS,_PSP		;AN000; get save PSP segment
	   MOV	 SI,[BP].MOFFSET	;AN000; get offset into PSP
	   LODSB			;AN000; get PSP byte
	   MOV	 AH,0			;AN000; zero high byte

	   POP	 DS			;AN000;

	   CEXIT			;AN000;

_GETPSPBYTE ENDP


;************************************************************************
;									;
; Subroutine Name:							;
;	putpspbyte							;
;									;
; Subroutine Function:							;
;	 put a byte into PSP						;		      ;
;									;
; Input:								;
;	SS:[BP]+MVALUE = byte in AL					;
;	SS:[BP]+MOFFSET = offset in PSP 				;
;									;
; Output:								;
;	none								;
;									;
; C calling convention: 						;
;	putpspbyte(offset,char);					;
;									;
;************************************************************************


MVALUE	   EQU	 PARM_2 		;AN000;
MOFFSET    EQU	 PARM_1 		;AN000;

	   ASSUME CS:PGROUP		;AN000;
	   ASSUME DS:DGROUP		;AN000;
	   ASSUME ES:DGROUP		;AN000;
	   ASSUME SS:DGROUP		;AN000;

	   PUBLIC _PUTPSPBYTE		;AN000;
_PUTPSPBYTE PROC NEAR			;AN000;

	   CENTER			;AN000;

	   PUSH  ES			;AN000;

	   MOV	 AX,[BP].MVALUE 	;AN000; get byte to store in PSP
	   MOV	 ES,_PSP		;AN000; get saved PSP segment
	   MOV	 DI,[BP].MOFFSET	;AN000; get offset in PSP
	   STOSB			;AN000; store the byte

	   POP	 ES			;AN000;

	   CEXIT			;AN000;

_PUTPSPBYTE ENDP


;-------------------------------------------------------------------
;
;	MODULE: 	crit_err_handler()
;
;	PURPOSE:	Supplies assembler exit routines for
;			critical error situations
;
;	CALLING FORMAT:
;			crit_err_handler;
;-------------------------------------------------------------------
	   public _crit_err_handler				       ;AN000;
	   public vector					       ;AN000;
vector	   dd	 0						       ;AN000;
;								       ;AN000;
_crit_err_handler proc near					       ;AN000;
	   pushf						       ;AN000;
	   push  ax			; save registers	       ;AN000;
	   push  ds						       ;AN000;
	   mov	 ax,dgroup		;get C data segment	       ;AN000;
	   mov	 ds,ax						       ;AN000;
	   mov	 ax,word ptr ds:_old_int24_off ;get int24 offset       ;AN000;
	   mov	 word ptr cs:vector,ax				       ;AN000;
	   mov	 ax,word ptr ds:_old_int24_off+2 ;get int24 segment    ;AN000;
	   mov	 word ptr cs:vector+2,ax			       ;AN000;
	   pop	 ds			;restore registers	       ;AN000;
	   pop	 ax						       ;AN000;
;								       ;AN000;
	   call  dword ptr cs:vector	; invoke DOS err hndlr	       ;AN000;
	   cmp	 al,ABORT		; what was the user's response ;AN000;
	   jnge  retry			;			       ;AN000;
;								       ;AN000;
	   mov	 ax,dgroup		;get C data segment	       ;AN000;
	   mov	 ds,ax						       ;AN000;
	   mov	 es,ax						       ;AN000;
	   call  _Reset_appendx 	; restore user's orig append/x ;AN000;
;								       ;AN000;
	   mov	 ax,(RET_EXIT shl 8)+XABORT ; return to DOS w/criterr error ;AN000;
	   int	 21h			;			       ;AN000;
retry:								       ;AN000;
	   iret 						       ;AN000;
;								       ;AN000;
_crit_err_handler endp						       ;AN000;
_text	   ends 						       ;AN000;
	   end	 XCMAIN 					       ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\parse.h ===
/*  */
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the parser from a C program.                                          |
|                                                                       |
|                                                                       |
| Date:         5-21-87                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define BYTE       unsigned char                                                     /*;AN000;*/
#define WORD       unsigned short                                                    /*;AN000;*/
#define DWORD      unsigned long                                                     /*;AN000;*/

#define p_len_parms             4               /* length of p_parms  */             /*;AN000;*/
#define p_i_use_default         0               /* no extra stuff specified */       /*;AN000;*/
#define p_i_have_delim          1               /* extra delimiter specified  */     /*;AN000;*/
#define p_i_have_eol            2               /* extra EOL specified */            /*;AN000;*/

struct p_parms                                                                       /*;AN000;*/
        {                                                                            /*;AN000;*/
        struct p_parmsx *p_parmsx_address;      /* address of p_parmsx */            /*;AN000;*/
        BYTE            p_num_extra;            /* number of extra stuff */          /*;AN000;*/
        BYTE            p_len_extra_delim;      /* length of extra delimiter */      /*;AN000;*/
        char            p_extra_delim[30];      /* extra delimiters */               /*;AN000;*/
        };                                                                           /*;AN000;*/

struct p_parmsx                                                                      /*;AN000;*/
        {                                                                            /*;AN000;*/
        BYTE            p_minp;                 /* Minimum positional number */      /*;AN000;*/
        BYTE            p_maxp;                 /* Maximum positional number  */     /*;AN000;*/
        struct p_control_blk *p_control1;       /* Address of the 1st CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control2;       /* Address of the 2nd CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control3;       /* Address of the 3nd CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control4;       /* Address of the 4th CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control5;       /* Address of the 3nd CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control6;       /* Address of the 4th CONTROL block */ /*;AN000;*/
        struct p_control_blk *p_control7;       /* Added Oct 1989 */
        struct p_control_blk *p_control8;       /* ditto */
        struct p_control_blk *p_control9;       /* ditto */
        struct p_control_blk *p_control10;      /* ditto */
        BYTE            p_maxs;                                                      /*;AN000;*/
        struct p_control_blk *p_switch;                                              /*;AN000;*/
        struct p_control_blk *p_switch2;
        BYTE            p_maxk;                                                      /*;AN000;*/
        struct p_control_blk *p_keyword1;                                            /*;AN000;*/
        struct p_control_blk *p_keyword2;                                            /*;AN000;*/
        struct p_control_blk *p_keyword3;                                            /*;AN000;*/
        };                                                                           /*;AN000;*/

struct p_control_blk                                                                 /*;AN000;*/
        {                                                                            /*;AN000;*/
        WORD    p_match_flag;           /* Controls type matched */                  /*;AN000;*/
        WORD    p_function_flag;        /* Function should be taken */               /*;AN000;*/
        WORD    p_result_buf;           /* Result buffer address */                  /*;AN000;*/
        WORD    p_value_list;           /* Value list address */                     /*;AN000;*/
        BYTE    p_nid;                  /* # of keyword/SW synonyms */               /*;AN000;*/
        char    p_keyorsw[20];          /* keyword or sw */                          /*;AN000;*/
        };                                                                           /*;AN000;*/

/* Match_Flags */                                                                    /*;AN000;*/
#define p_num_val               0x8000          /* Numeric Value */                  /*;AN000;*/
#define p_snum_val              0x4000          /* Signed numeric value */           /*;AN000;*/
#define p_simple_s              0x2000          /* Simple string */                  /*;AN000;*/
#define p_date_s                0x1000          /* Date string */                    /*;AN000;*/
#define p_time_s                0x0800          /* Time string */                    /*;AN000;*/
#define p_cmpx_s                0x0400          /* Complex string */                 /*;AN000;*/
#define p_file_spc              0x0200          /* File Spec */                      /*;AN000;*/
#define p_drv_only              0x0100          /* Drive Only */                     /*;AN000;*/
#define p_qu_string             0x0080          /* Quoted string */                  /*;AN000;*/
#define p_ig_colon              0x0010          /* Ignore colon at end in match */   /*;AN000;*/
#define p_repeat                0x0002          /* Repeat allowed */                 /*;AN000;*/
#define p_optional              0x0001          /* Optional */                       /*;AN000;*/

/*----------------------------------------------------------------------+
|                                                                       |
|  Function flags                                                       |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_cap_file              0x0001          /* CAP result by file table */       /*;AN000;*/
#define p_cap_char              0x0002          /* CAP result by character table */  /*;AN000;*/
#define p_rm_colon              0x0010          /* Remove ":" at the end */          /*;AN000;*/

#define p_nval_none             0               /* no value list ID */               /*;AN000;*/
#define p_nval_range            1               /* range list ID */                  /*;AN000;*/
#define p_nval_value            2               /* value list ID */                  /*;AN000;*/
#define p_nval_string           3               /* string list ID */                 /*;AN000;*/
#define p_len_range             9               /* Length of a range choice(two DD plus one DB) */  /*;AN000;*/
#define p_len_value             5               /* Length of a value choice(one DD plus one DB) */  /*;AN000;*/
#define p_len_string            3               /* Length of a string choice(one DW plus one DB) */ /*;AN000;*/

/*----------------------------------------------------------------------+
|                                                                       |
|  Result block structure                                               |
|                                                                       |
+----------------------------------------------------------------------*/

struct p_result_blk                                                                  /*;AN000;*/
        {                                                                            /*;AN000;*/
        BYTE  p_type;                 /* Type returned */                            /*;AN000;*/
        BYTE  p_item_tag;             /* Matched item tag */                         /*;AN000;*/
        WORD  p_synonym_ptr;          /* pointer to Synonym list returned */         /*;AN000;*/
        WORD  p_result_buff[2];       /* result value */                             /*;AN000;*/
        };                                                                           /*;AN000;*/

/*----------------------------------------------------------------------+
|                                                                       |
|  type                                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_eol                   0               /* End of line */                    /*;AN000;*/
#define p_number                1               /* Number */                         /*;AN000;*/
#define p_list_idx              2               /* List Index */                     /*;AN000;*/
#define p_string                3               /* String */                         /*;AN000;*/
#define p_complex               4               /* Complex */                        /*;AN000;*/
#define p_file_spec             5               /* File Spec */                      /*;AN000;*/
#define p_drive                 6               /* Drive */                          /*;AN000;*/
#define p_date_f                7               /* Date */                           /*;AN000;*/
#define p_time_f                8               /* Time */                           /*;AN000;*/
#define p_quoted_string         9               /* Quoted String */                  /*;AN000;*/

#define p_no_tag                0x0FF           /* No ITEM_TAG found */              /*;AN000;*/

/*----------------------------------------------------------------------+
|                                                                       |
|  following return code will be returned in the AX register.           |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_no_error              0               /* No error */                       /*;AN000;*/
#define p_too_many              1               /* Too many operands */              /*;AN000;*/
#define p_op_missing            2               /* Required operand missing */       /*;AN000;*/
#define p_not_in_sw             3               /* Not in switch list provided */    /*;AN000;*/
#define p_not_in_key            4               /* Not in keyword list provided */   /*;AN000;*/
#define p_out_of_range          6               /* Out of range specified */         /*;AN000;*/
#define p_not_in_val            7               /* Not in value list provided */     /*;AN000;*/
#define p_not_in_str            8               /* Not in string list provided */    /*;AN000;*/
#define p_syntax                9               /* Syntax error */                   /*;AN000;*/
#define p_rc_eol                0x0ffff         /* End of command line */            /*;AN000;*/

/*----------------------------------------------------------------------+
|                                                                       |
|  String Value List Block Structure                                    |
|                                                                       |
+----------------------------------------------------------------------*/

struct ps_valist_blk                                                                 /*;AN000;*/
        {                                                                            /*;AN000;*/
        BYTE   ps_val;                /* Value type */                               /*;AN000;*/
        BYTE   ps_nrng;               /* Number of ranges  */                        /*;AN000;*/
        BYTE   ps_nnval;              /* Number of numbers */                        /*;AN000;*/
        BYTE   ps_nstrval;            /* Number of strings */                        /*;AN000;*/
        BYTE   ps_item_tag1;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings1;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag2;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings2;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag3;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings3;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag4;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings4;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag5;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings5;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag6;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings6;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag7;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings7;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag8;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings8;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag9;             /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings9;           /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag10;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings10;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag11;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings11;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag12;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings12;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag13;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings13;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag14;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings14;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag15;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings15;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag16;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings16;          /* Address of strings */                       /*;AN000;*/
        BYTE   ps_item_tag17;            /* Matched item tag */                      /*;AN000;*/
        WORD   ps_strings17;          /* Address of strings */                       /*;AN000;*/
        };                                                                           /*;AN000;*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\_msgret.asm ===
page	60,132								 ;AN000;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
name	_msgret 							 ;AN000;
title	C	to Message Retriever					 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	MODULE: 	_msgret 					 ;AN000;
;									 ;AN000;
;	PURPOSE:	Supplies an interface between C programs and	 ;AN000;
;			the DOS message retriever			 ;AN000;
;									 ;AN000;
;	CALLING FORMAT: 						 ;AN000;
;			sysloadmsg(&inregs,&outregs);			 ;AN000;
;			sysgetmsg(&inregs,&outregs);			 ;AN000;
;			sysdispmsg(&inregs,&outregs);			 ;AN000;
;									 ;AN000;
;									 ;AN000;
;	DATE:		5-21-87 					 ;AN000;
;	Modified:	6/18/87 					 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;
;									 ;AN000;
	MSG_UTILNAME <ATTRIB>		;IDENTIFY THE COMPONENT 	 ;AN000;
;									 ;AN000;
	.8087								 ;AN000;
_TEXT	SEGMENT BYTE PUBLIC 'CODE'					 ;AN000;
_TEXT	ENDS								 ;AN000;
_DATA	SEGMENT WORD PUBLIC 'DATA'					 ;AN000;
_DATA	ENDS								 ;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'					 ;AN000;
CONST	ENDS								 ;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'					 ;AN000;
_BSS	ENDS								 ;AN000;
DGROUP	GROUP	CONST, _BSS, _DATA					 ;AN000;
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP		 ;AN000;
;									 ;AN000;
	public	_sysloadmsg						 ;AN000;
	public	_sysgetmsg						 ;AN000;
	public	_sysdispmsg						 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
_DATA	segment 							 ;AN000;
.XLIST									 ;AN000;
.XCREF									 ;AN000;
;	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER ;AN000;
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER ;AN000;
.LIST									 ;AN000;
.CREF									 ;AN000;
_DATA	ends								 ;AN000;
;									 ;AN000;
;									 ;AN000;
_TEXT	segment 							 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
					;DEFAULT=CHECK DOS VERSION	 ;AN000;
					;DEFAULT=NEARmsg		 ;AN000;
					;DEFAULT=INPUTmsg		 ;AN000;
					;DEFAULT=NUMmsg 		 ;AN000;
					;DEFAULT=NO TIMEmsg		 ;AN000;
					;DEFAULT=NO DATEmsg		 ;AN000;
;	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg,FARmsg,TIMEmsg,DATEmsg> ;AN000;
;	MSG_SERVICES <ATTRIB.CLA,ATTRIB.CLB,ATTRIB.CL1,ATTRIB.CL2> ;MSG TEXT  ;AN000;
.XLIST									 ;AN000;
.XCREF									 ;AN000;
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg,FARmsg,TIMEmsg,DATEmsg> ;AN000;
	MSG_SERVICES <ATTRIB.CLA,ATTRIB.CLB,ATTRIB.CL1,ATTRIB.CL2> ;MSG TEXT ;AN000;
.LIST									 ;AN000;
.CREF									 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
_sysloadmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysloadmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysloadmsg endp							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_sysgetmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysgetmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysgetmsg endp 							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_sysdispmsg proc near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysdispmsg		; call the message retriever	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_sysdispmsg endp							 ;AN000;
;									 ;AN000;
;									 ;AN000;
_TEXT	ends				; end code segment		 ;AN000;

	include msgdcl.inc

	end								 ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\msgret.h ===
/*  */
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*----------------------------------------------------------------------+
|									|
| This file contains the structures and defines that are needed to use	|
| the message retriever from a C program.				|
|									|
|									|
| Date: 	6-19-87 						|
|									|
+----------------------------------------------------------------------*/


#define utility_msg_class 0xff /*;AN000; Utility message type		     */
#define exterr_msg_class  0x01 /*;AN000;*/


/* Sublist Flag Values						       */

/* Alignment Indicator						       */
#define sf_left 	0x00	  /*;AN000; left align		       */
#define sf_right	0x80	  /*;AN000; right align 	       */

/* Field Type							       */
#define sf_char 	0x00	  /*;AN000; character		       */
#define sf_unsbin2d	0x01	  /*;AN000; unsigned binary to decimal */
#define sf_sbin 	0x02	  /*;AN000; signed binary to decimal   */
#define sf_unsbin2h	0x03	  /*;AN000; unsigned binary to hex     */
#define sf_date 	0x04	  /*;AN000; date		       */
#define sf_time12	0x05	  /*;AN000; time 12-hour	       */
#define sf_time24	0x06	  /*;AN000; time 24-hour	       */


/* Data Variable Size						       */

#define sf_ch		0x00	  /*;AN000; single character	       */
#define sf_asciiz	0x10	  /*;AN000; asciiz string	       */
#define sf_byte 	0x10	  /*;AN000; byte		       */
#define sf_word 	0x20	  /*;AN000; word		       */
#define sf_dword	0x30	  /*;AN000; double word 	       */

#define sf_mdy2 	0x20	  /*;AN000; month,day,year (2 digits)  */
#define sf_mdy4 	0x30	  /*;AN000; month,day,year (4 digits)  */

#define sf_hhmm 	0x00	  /*;AN000; hh:mm		       */
#define sf_hhmmss	0x10	  /*;AN000; hh:mm:ss		       */
#define sf_hhmmsshh	0x20	  /*;AN000; hh:mm:ss:hh 	       */


struct m_sublist		    /*;AN000;				 */
       {			    /*;AN000;				 */
       BYTE   sub_size; 	    /*;AN000;				 */
       BYTE   sub_res;		    /*;AN000;				 */
       WORD   sub_value;	    /*;AN000;				 */
       WORD   sub_value_seg;	    /*;AN000;				 */
       BYTE   sub_id;		    /*;AN000;				 */
       BYTE   sub_flags;	    /*;AN000;				 */
       BYTE   sub_max_width;	    /*;AN000;				 */
       BYTE   sub_min_width;	    /*;AN000;				 */
       BYTE   sub_pad_char;	    /*;AN000;				 */
       };			    /*;AN000;				 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\proto.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
WORD inmain(char *line);                               //M002 Change return type
WORD main(char *line);                                 //M002
void Display_msg(int msgnum,int msghan,int msgparms,int *msgsub,char msginput);
void Get_far_str(char *target,unsigned long *source,unsigned short length);
unsigned short *Dallocate(unsigned short s);
void Copy_far_ptr(unsigned long *p1_addr,unsigned short *p2_addr);
unsigned short Parse_it(char *line);
unsigned short Make_fspec(char *fspec);
void Dta_save(char *t,unsigned int l);
void Dta_restore(char *t,unsigned int l);
unsigned short Find_first(char *s,char *f,unsigned short *a,unsigned short *r);
unsigned short Find_next(char *f,unsigned short *r);
unsigned short Get_reg_attrib(char *fspec,unsigned char *attr_byte);
unsigned short Ext_open(char *fspec,unsigned short *handle);
unsigned short Set_reg_attrib(char *fspec,unsigned char attr_byte);
unsigned short CheckYN(char *fspec);
void Convert_date(unsigned short dosdate,unsigned short *msgdate1,unsigned short *msgdate2);
void Convert_time(unsigned short dostime,unsigned short *msgtime1,unsigned short *msgtime2);
unsigned short Regular_attrib(char *fspec);
unsigned short Special_attrib(unsigned short handle,char *fspec,unsigned short id);
unsigned short Attrib(char *path,char *file);
unsigned short Do_dir(char *path,char *file);
void Check_appendx(void );
void Reset_appendx(void );
unsigned short Check_DBCS(char *array,unsigned short position,char character);
void Get_DBCS_vector(void );
void Error_exit(int msg_class,int ext_err_num,int subcnt);
void Parse_err(unsigned short error_num);
void far _interrupt ctl_break_handler(void );
void sysloadmsg(union REGS *inregs, union REGS *outregs);
void sysdispmsg(union REGS *inregs, union REGS *outregs);
void Dexit(WORD s);
void Dfree(WORD segment);
void putpspbyte(unsigned, char);
char getpspbyte(unsigned);
void parse(union REGS *inregs, union REGS *outregs);
int crit_err_handler();                                          

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\attrib\_parse.asm ===
page	60,132								 ;AN000;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
name	_parse								 ;AN000;
title	C	to PARSER interface					 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	MODULE: 	_parse						 ;AN000;
;									 ;AN000;
;	PURPOSE:	Supplies an interface between C programs and	 ;AN000;
;			the DOS parser					 ;AN000;
;									 ;AN000;
;	CALLING FORMAT: 						 ;AN000;
;			parse(&inregs,&outregs);			 ;AN000;
;									 ;AN000;
;	DATE:		5-21-87 					 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
;	extrn	sysparse:far						 ;AN000;
;									 ;AN000;
	public	_parse							 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
FarSW	equ	0			; make sysparse be a NEAR proc	 ;AN000;
TimeSW	equ	0			; Check time format		 ;AN000;
FileSW	equ	1			; Check file specification	 ;AN000;
CAPSW	equ	1			; Perform CAPS if specified	 ;AN000;
CmpxSW	equ	0			; Check complex list		 ;AN000;
NumSW	equ	1			; Check numeric value		 ;AN000;
KeySW	equ	1			; Support keywords		 ;AN000;
SwSW	equ	1			; Support switches		 ;AN000;
Val1SW	equ	1			; Support value definition 1	 ;AN000;
Val2SW	equ	1			; Support value definition 2	 ;AN000;
Val3SW	equ	1			; Support value definition 3	 ;AN000;
DrvSW	equ	0			; Support drive only format	 ;AN000;
QusSW	equ	1			; Support quoted string format	 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'	;AN000;
BASESW	=	1			;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	=	0			;PSDATA.INC IS ALREADY INCLUDED
	INCLUDE VERSION.INC
	INCLUDE PSDATA.INC		;PARSER'S WORK SPACE
_DATA	ends				;AN000;

_TEXT	segment byte public 'CODE'	;AN000;

	ASSUME	CS: PGROUP		;AN000;
	ASSUME	DS: DGROUP		;AN000;
;-------------------------------------------------------------------	 ;AN000;
.xlist									 ;AN000;
include parse.asm			; include the parser		 ;AN000;
.list									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
_parse	proc	near							 ;AN000;
	push	bp			; save user's base pointer       ;AN000;
	mov	bp,sp			; set bp to current sp		 ;AN000;
	push	di			; save some registers		 ;AN000;
	push	si							 ;AN000;
;									 ;AN000;
;	copy C inregs into proper registers				 ;AN000;
;									 ;AN000;
	mov	di,[bp+4]		; fix di (arg 0)		 ;AN000;
;									 ;AN000;
	mov	ax,[di+0ah]		; load di			 ;AN000;
	push	ax			; the di value from inregs is now on stack ;AN000;
;									 ;AN000;
	mov	ax,[di+00]		; get inregs.x.ax		 ;AN000;
	mov	bx,[di+02]		; get inregs.x.bx		 ;AN000;
	mov	cx,[di+04]		; get inregs.x.cx		 ;AN000;
	mov	dx,[di+06]		; get inregs.x.dx		 ;AN000;
	mov	si,[di+08]		; get inregs.x.si		 ;AN000;
	pop	di			; get inregs.x.di from stack	 ;AN000;
;									 ;AN000;
	push	bp			; save base pointer		 ;AN000;
;									 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
	call	sysparse		; call the parser		 ;AN000;
;-------------------------------------------------------------------	 ;AN000;
;									 ;AN000;
	pop	bp			; restore base pointer		 ;AN000;
	push	di			; the di value from call is now on stack ;AN000;
	mov	di,[bp+6]		; fix di (arg 1)		 ;AN000;
;									 ;AN000;
	mov	[di+00],ax		; load outregs.x.ax		 ;AN000;
	mov	[di+02],bx		; load outregs.x.bx		 ;AN000;
	mov	[di+04],cx		; load outregs.x.cx		 ;AN000;
	mov	[di+06],dx		; load outregs.x.dx		 ;AN000;
	mov	[di+08],si		; load outregs.x.si		 ;AN000;
;									 ;AN000;
	lahf				; get flags into ax		 ;AN000;
	mov	al,ah			; move into low byte		 ;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag		 ;AN000;
;									 ;AN000;
	pop	ax			; get di from stack		 ;AN000;
	mov	[di+0ah],ax		; load outregs.x.di		 ;AN000;
;									 ;AN000;
	pop	si			; restore registers		 ;AN000;
	pop	di							 ;AN000;
	mov	sp,bp			; restore sp			 ;AN000;
	pop	bp			; restore user's bp              ;AN000;
	ret								 ;AN000;
_parse	endp								 ;AN000;
_TEXT	ends				; end code segment		 ;AN000;
	end								 ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\backup\_msgret.asm ===
page	60,132
name	_msgret
title	C	to Message Retriever
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.30 message retriever
;
;	CALLING FORMAT:
;			sysloadmsg(&inregs,&outregs);
;			sysdispmsg(&inregs,&outregs);
;			sysgetmsg(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <BACKUP>		;IDENTIFY THE COMPONENT 		;AN000;

	.8087
_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP


	public	_sysloadmsg
	public	_sysdispmsg
	public	_update_logfile

;-------------------------------------------------------------------
;-------------------------------------------------------------------

_DATA	segment
.XLIST
.XCREF
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	     ;AN000;

.LIST
.CREF
_DATA	ends


_TEXT	segment

;-------------------------------------------------------------------
					;DEFAULT=CHECK DOS VERSION
					;DEFAULT=NEARmsg
					;DEFAULT=INPUTmsg
					;DEFAULT=NUMmsg
					;DEFAULT=NO TIMEmsg
					;DEFAULT=NO DATEmsg
.XLIST
.XCREF
	MSG_SERVICES <LOADmsg,DISPLAYmsg,GETmsg,INPUTmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,FARmsg> ;AN000;
	MSG_SERVICES <BACKUP.CTL,BACKUP.CLA,BACKUP.CL1,BACKUP.CL2> ;AN000;
.LIST
.CREF
;-------------------------------------------------------------------

_sysloadmsg proc near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------
	call	sysloadmsg		; call the message retriever
;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_sysloadmsg endp


;============================================================================
;============================================================================
;============================================================================


_update_logfile proc near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

	mov	di,[bp+4]		; fix di (arg 0)
;-------------------------------------------------------------------
	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer
;-------------------------------------------------------------------
	mov	dh,-1			; Message class, Utility message
	mov	cs:handle,bx		;AN000;9 Save logfile handle
	mov	cs:len,cx		;AN000;9  Save write length
	push	ds			;AN000;9
	pop	cs:save_ds		;AN000;9
	call	sysgetmsg		; call the message retriever
;-------------------------------------------------------------------
	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di
	mov	cs:offst,si		;AN000;9

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp

	mov	ah,040h 		;AN000;9 Write the message to logfile
	mov	bx,cs:handle		;AN000;9
	mov	cx,cs:len		;AN000;9
	mov	dx,cs:offst		;AN000;9
	int	021h			;AN000;9
	push	cs:save_ds		;AN000;9
	pop	ds			;AN000;9
	ret

	handle	dw	?		;AN000;9
	len	dw	?		;AN000;9
	offst	dw	?		;AN000;9
	save_ds dw	?		;AN000;9
_update_logfile endp

;============================================================================
;============================================================================
;============================================================================


_sysdispmsg proc near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)
;-------------------------------------------------------------------
	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer
;-------------------------------------------------------------------
	call	sysdispmsg		; call the message retriever
;-------------------------------------------------------------------
	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di
;-------------------------------------------------------------------
	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_sysdispmsg endp

;============================================================================
;============================================================================
;============================================================================

;============================================================================
;============================================================================
;============================================================================

include msgdcl.inc


_TEXT	ends				; end code segment
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\backup\backup.h ===
/*************************************************************************/
/*                                                                       */
/*  FILE:    Backup.H                                                    */
/*                                                                       */
/*  PURPOSE: For the BACKUP utility, this file has the required          */
/*           BACKUP defines, message numbers, structures,                */
/*           and subroutine declarations.                                */
/*                                                                       */
/*  LABEL:   Microsoft Confidential                                      */
/*           Copyright (c) Microsoft Corporation 1991                    */
/*           All Rights Reserved.                                        */
/*                                                                       */
/*************************************************************************/


/*
 *  Utility #DEFINES...
 */
#define DHLENGTH 139         /* length, in bytes, of a Disk Header */
#define DBLENGTH  70         /* length, in bytes, of a Directory Block */
#define FHLENGTH  34         /* length, in bytes, of a File Header */

#define BYTE  unsigned char
#define WORD  unsigned short
#define DWORD unsigned long

#define NOERROR 0
#define FILE_NOT_FOUND 2                         /* M009 */
#define NUL 0

#define YES 1                                    /* M011 */
#define NO  0                                    /* M011 */

#define FALSE 0
#define TRUE  !FALSE

#define BACKSLASH 0x5c

/* bit mask, ANDed with current attribute to turn off readonly bit */
#define READONLYOFF 254

/* File Attributes */
#define READONLY    0x01
#define HIDDEN      0x02
#define SYSTEM      0x04
#define VOLLABEL    0x08
#define SUBDIR      0x10
#define ARCHIVE     0x20
#define DEVICEATT   0x40

/* Sharing Modes */
#define DENYALL     0x10
#define DENYWRITE   0x20
#define DENYREAD    0x30
#define DENYNONE    0x40

/* Access Modes */
#define READACCESS  0x00
#define WRITEACCESS 0x01
#define READWRITE   0x02
#define NO_INHERIT  0x80          /* inheritance bit */
#define NO_CP_CHECK 0x100

#define SYNCHRONOUS    0x4000     /* OS/2 File Write-Through */
#define NOTSYNCHRONOUS 0x0000     /* OS/2 File Write-Through */
#define OPENDASD       0x8000     /* OS/2 Open a DASD device */
#define OPEN_IT        0x01
#define CREATE_IT      0x12


/* predefined handles */
#define STDIN  0x00
#define STDOUT 0x01
#define STDERR 0x02

/* LSEEK move methods */
#define BOFILE	0
#define CURRPOS 1
#define EOFILE	2

/* CHMOD functions */
#define GET 0
#define SET 1

/* Parser Match Flags */
#define SSTRING     0x2000
#define DATESTRING  0x1000
#define TIMESTRING  0x0800
#define FILESPEC    0x0200
#define DRIVELETTER 0x0100
#define OPTIONAL    0x0001

/* Parser Function Flags */
#define CAP_FILETABLE 0x0001
#define CAP_CHARTABLE 0x0002

#define LABELLEN 11

#define SETLOGICALDRIVE 0x440F


/* Append Functions */
#define INSTALL_CHECK  0xB700
#define NOT_INSTALLED  0
#define GET_APPEND_VER 0xB702
#define NET_APPEND     1
#define DOS_APPEND     2
#define GET_STATE      0xB706
#define SET_STATE      0xB707

#define APPEND_X_BIT   0x8000



#define ACTIONHOOK 2
#define CTRLC      1
#define CTRLBREAK  4

#define EOL           -1
#define QUOTED_STRING 9
#define RET_DATE      7
#define RET_TIME      8

#define CPSW_ACTIVE     1
#define CPSW_NOTACTIVE  0
#define GET_CPSW        0x3303

#define CARRY 0x0001



/*
 *  Utility-specific Definitions.
 */
#define ROOTDIR   0
#define BACKUPDIR 1

#define PUT_SEG(fp,seg)  (*((unsigned *)&(fp)+1)) = (unsigned) seg
#define PUT_OFF(fp,off)  (*((unsigned *)&(fp))) = (unsigned) off

#define MAXMSGLEN            160
#define PATHLEN               64
#define MAX_RETRY_OPEN_COUNT   5

/* Errorlevels */
#define RETCODE_NO_ERROR       0
#define RETCODE_NO_FILES       1
#define RETCODE_SHARE_ERROR    2
#define RETCODE_CTL_BREAK      3
#define RETCODE_ERROR          4
#define RETCODE_NEG_PROMPT     5


/*************************************************************************/
/*                 NOTE FROM PARSER SUBROUTINE !!!!!                     */
/*************************************************************************/
/* The SECONDS bits in the DOS Directory are in 2-second increments.     */
/* Therefore, div by 2,	take the integer portion and use in search.      */
/* Note that files can be backed up that were modified 1 second before   */
/* the time that a user enters, which is better than not backing up a    */
/* file that was modified at exactly that time.                          */
/*************************************************************************/


/*-----------------------*/
/*    BACKUP messages    */
/*-----------------------*/

/*
 *  Be sure to add a case statement with your
 *  message's #define to display_message in
 *  backup.c
 */
#define BAD_DOS_VER            1
#define INSUFF_MEMORY          2

#define INV_DRIVE              6
#define INV_DATE               7
#define INV_TIME               8

#define INVPARM               10
#define INV_PATH              11
#define NO_SOURCE             12
#define NO_TARGET             13
#define SRC_AND_TGT_SAME      14
#define ERR_EXEC_FORMAT       15
#define CANT_FIND_FORMAT      16
#define CANT_OPEN_LOGFILE     17
#define LOGGING               18
#define NOTLASTMSG            19
#define ERASEMSG              20
#define FERASEMSG             21
#define BUDISKMSG             22
#define SEQUENCEMSG           23
#define NONEFNDMSG            24
#define INSERTSOURCE          25
#define INSERTTARGET          26
#define CONFLICTMSG           27
#define LASTDISKMSG           28
#define INVTARGET             29
#define LASTNOTBACKUP         30
#define FDISKFULLMSG          31
#define LOGFILE_TARGET_FULL   32
#define PRESS_ANY_KEY         33
#define CRLF                  34
#define CANT_FORMAT_HARDFILE  35
#define SRCISTGT              40
#define TGTISSRC              41
#define DISK_UNFORMAT         42                 /* M011 */
#define NO_FORMAT_FND         43                 /* M011 */
#define INSERT_FORMAT         44                 /* M011 */
#define CONTINUE_NEW_DISK     45                 /* M011 */

#define	MSG_OPTIONS_FIRST    300
#define MSG_OPTIONS_LAST     310

/*
 *  Message Classes 
 */
#define EXTENDED    1
#define PARSEERROR  2
#define UTIL_MSG   -1

#define NOWAIT    0
#define WAIT      0xC8
#define YESNOWAIT 0xC1                           /* M011 */


/*
 *  CONTROL BLOCK FOR EACH BACKUP DISKETTE.
 *
 *  This structure will make up the first dh_dhlength bytes
 *  of the control.xxx file on the backup target.
 *  It identifies the disk as being a backup, and includes
 *  diskette sequence number and a flag indicating if this
 *  is the last target.
 */
#define LAST_TARGET     0xFF
#define NOT_LAST_TARGET 0x00

struct Disk_Header
{
    BYTE  DH_Length;              /* length, in bytes, of disk header */
    BYTE  DH_Identifier[8];       /* identifies disk as a backup */
    BYTE  DH_Sequence;            /* backup diskette seq num (1-255) */
    BYTE  DH_reserved [128];      /* save area for nothing */
    BYTE  DH_LastDisk;            /* indicates if this is last target */
                                  /*   0xFF if last target, 0 otherwise */
};


/*
 *  DIRECTORY BLOCK.
 *
 *  This structure is written to the control.xxx file at least once
 *  for each subdirectory, including the root, backed up. It contains
 *  the path to that directory, the number of files from that
 *  directory that are backed up on current target, and the offset
 *  of the next directory block on that diskette, if one exists.
 *  If there are no other directory blocks, it equals 0xffffffff.
 */
#define LAST_DB 0xFFFFFFFF

struct Dir_Block
{
    BYTE  DB_Length;         /* length, in bytes, of dir block */
    BYTE  DB_Path[63];       /* path of this directory, drive letter omitted */
    WORD  DB_NumEntries;     /* number of filenames currently in list */
    DWORD DB_NextDB;         /* offset of next dir block */
                             /*   0xffffffff if no more on current target */
};


/*
 *  CONTROL BLOCK FOR EACH BACKED UP FILE.
 *
 *  This structure will be repeated after the directory block once.
 *  For each file backed up from that directory, it contains the
 *  filename, directory information, and other necessary information.
 */
#define NOTLASTPART 0
#define LASTPART    1

#define NOTSUCCESSFUL 0
#define SUCCESSFUL    2

#define EXT_ATTR 4

struct File_Header
{
    BYTE  FH_Length;         /* length, in bytes, of file header */
    BYTE  FH_FName[12];      /* ascii file name (from directory) */
    BYTE  FH_Flags;          /* bit 0=1 if last part of file */
                             /* bit 1=1 if it is backed up successfully */
                             /* bit 2=1 if Extended Attributes are backed up */
    DWORD FH_FLength;        /* total length of the file (from directory) */
    WORD  FH_FSequence;      /* sequence #, for files that span */
    DWORD FH_BeginOffset;    /* offset in BACKUP.xxx where this segment begins */
    DWORD FH_PartSize;       /* length of part of file on current target */
    WORD  FH_Attribute;      /* file attribute (from directory) */
    WORD  FH_FTime;          /* time file was last modified (from directory) */
    WORD  FH_FDate;          /* date file was last modified (from directory) */
};


/*
 *  This is the structure that is used in the linked list of       
 *  directories that need to be processed (if /s option specified).
 */
struct node
{
    struct node *np;
    char        path[PATHLEN+15];
};


/*
 *  This is the structure that is used by the dos function
 *  "return country information".
 */
struct ctry_info_blk
{
    WORD  country_code;
    WORD  code_page;
    WORD  date_format;
#define USA  0
#define EUR  1
#define JAP  2
    BYTE  currency_symbol[5];
    WORD  thousands_separator;
    WORD  decimal_Separator;
    WORD  date_separator;
    WORD  time_separator;
    BYTE  currency_format;
    BYTE  num_sig_dec_dig_in_currency;
    BYTE  time_format;
    DWORD case_map_call;
    WORD  data_list_separator;
    WORD  reserved[5];
};


/*
 *  Substitution List for Message Retriever.
 *
 *  This structure is used by the DOS Message Handler service routines.
 */
#define SUBLIST_SIZE 11

#define LEFT_ALIGN        0x0
#define RIGHT_ALIGN       0x80

#define CHAR_FIELD_CHAR   0x0
#define CHAR_FIELD_ASCIIZ 0x10

/* unsigned binary to decimal character */
#define UNSGN_BIN_BYTE	  0x11
#define UNSGN_BIN_WORD	  0x21
#define UNSGN_BIN_DWORD   0x31

/* Message substitution list structure */
struct subst_list
{
    BYTE     sl_size1;       /* size of list */
    BYTE     zero1;          /* reserved */
    char far *value1;        /* time, date, or ptr to data item */
    BYTE     one;            /* n of %n */
    BYTE     flags1;         /* data type flags */
    BYTE     max_width1;     /* maximum FIELD width */
    BYTE     min_width1;     /* minimum FIELD width */
    BYTE     pad_char1;      /* character for pad FIELD */

    BYTE     sl_size2;       /* size of list */
    BYTE     zero2;          /* reserved */
    char far *value2;        /* time, date, or ptr to data item */
    BYTE     two;            /* n of %n */
    BYTE     flags2;         /* data Type flags */
    BYTE     max_width2;     /* maximum FIELD width */
    BYTE     min_width2;     /* minimum FIELD width */
    BYTE     pad_char2;      /* character for pad FIELD */
};


/*
 *  EXTENDED OPEN parameter list.
 */
#define EXTATTBUFLEN 4086

struct parm_list
{
    DWORD ext_attr_addr;
    WORD  num_additional;
    BYTE  id_io_mode;
    WORD  io_mode;
};


/*
 *  Subroutine Declarations and Extern Declarations.
 */
int cdecl sprintf(char *, char *, ...);
int cdecl printf(char *, ...);

void   alloc_buffer(void);
void   alloc_first_node(void);
struct node * alloc_node(unsigned int);
void   check_appendX(void);
void   alloc_seg(void);
void   build_ext(int);
void   change_levels(void);
void   check_date(WORD, BYTE, BYTE);
void   check_DOS_version(void);
void   check_drive_validity(int, char * []);
void   check_asj(void);
void   check_for_device_names(char * []);
void   check_last_target(void);
void   check_options_help(int, char *[]);
void   check_path_validity(char * []);
void   check_time(BYTE,BYTE,BYTE,BYTE);
void   clean_up_and_exit(void);
void   close_file(WORD);
void   close_out_current_target(void);
void   control_break_handler(void);
int    create_target(void);                      /* M009 */
void   datetime(void);
void   delete(char *);
int    delete_files(char);                       /* M009 */
long   disk_free_space(void);
void   display_it(int, WORD, int, BYTE, BYTE);
void   display_msg(int);
void   display_options_exit(void);
void   do_backup(void);
void   do_copy(void);
void   do_dos_error(WORD);
void   error_exit(int);
WORD   exist(char *);
WORD   extended_open(WORD, WORD, char far *, WORD);
void   file_sharing_error(void);
char   far * far_ptr(WORD, WORD);
void   findclose(WORD);
void   find_all_subdirs(void);
void   find_first(char *, WORD *, struct FileFindBuf *, WORD);
void   find_first_file(void);
void   find_format(int);
void   find_next(WORD, struct FileFindBuf *);
void   find_next_file(void);
void   find_the_first(void);
void   find_the_next(void);
int    format_target(void);
void   check_unformatted(void);
void   free_seg(unsigned);
WORD   get_attribute(char *);
void   get_current_dir(WORD, char *);
WORD   get_current_drive(void);
void   get_country_info(void);
void   get_diskette(void);
void   get_drive_types(void);
void   get_first_target(void);
void   get_hardfile(void);
void   get_next_target(void);
int    get_path(char *, int);
int    GetYesNo(void);                           /* M011 */
WORD   handle_open(char *, WORD);
WORD   handle_read(WORD, WORD, char far *);
WORD   handle_write(WORD, WORD, char far *);
void   init(void);
void   insert_node(char *);
WORD   ioctl(WORD);
void   label_target_drive(void);
DWORD  lseek(WORD, BYTE, DWORD);
int    main(int, char * []);
void   mark_as_last_target(void);
void   mark_as_not_last_target(void);
void   mark_files_read_only(void);
void   open_logfile(void);
void   open_source_file(void);
int    open_target(void);                        /* M009 */
void   parser(int,char * []);
void   parse_error(WORD, WORD);
void   parse_init(void);
void   process_switch(void);
void   put_disk_header(void);
void   put_new_db(void);
void   put_new_fh(void);
void   remove_last_backslash_from_BDS(void);
void   remove_node(void);
void   replace_volume_label(char *);
void   reset_archive_bit(char *);
void   restore_default_directories(void);
void   save_current_dirs(void);
void   see_if_it_should_be_backed_up(void);
void   set_attribute(char *, WORD);
void   set_vectors(void);
void   set_default_dir(void);
void   set_default_drive(WORD);
void   setsignal(WORD, WORD);
void   show_path(void);
char   *strcat(char *, const char *);
size_t strlen(const char *);
char   *strcpy(char *, const char *);
char   *strncpy(char *, const char *, unsigned int);
int    strncmp(const char *, const char *, unsigned int);
int    strcmp(const char *, const char *);
void   terminate(void);
void   update_db_entries(WORD);
void   update_fh_entries(void);
WORD   write_till_target_full(WORD, WORD);
void   write_to_control_file(char far *, WORD);
void   write_to_target(WORD);
void   xlat(char *, char *);

#ifdef DBCS
int    IsDBCSLeadByte(unsigned char);
int    CheckDBCSTailByte(unsigned char *, unsigned char *);
#endif


extern void sysloadmsg(union REGS *, union REGS *);
extern void update_logfile(union REGS *, union REGS *);
extern void sysdispmsg(union REGS *, union REGS *);
extern void parse(union REGS *, union REGS *);
extern void far pascal set_int24_vector(unsigned);



/*
 *  From COMSUB.H
 */

/* convert character to uppercase */
extern int com_toupper( unsigned char );    /* char to be converted */

/* search the first occurrence of a character in a string */
extern char *com_strchr( unsigned char *,   /* source string */
                         unsigned char );   /* character to be searched */

/* search the last character occurrence in a string */
extern unsigned char *com_strrchr( unsigned char *,   /* source string */
                                   unsigned char );   /* target string */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\backup\backpars.h ===
/*************************************************************************/
/*                                                                       */
/*  FILE:    Backpars.H                                                  */
/*                                                                       */
/*  PURPOSE: Defines the structures for the DOS PARSE service            */
/*           routines.                                                   */
/*                                                                       */
/*  LABEL:   Microsoft Confidential                                      */
/*           Copyright (c) Microsoft Corporation 1991                    */
/*           All Rights Reserved.                                        */
/*                                                                       */
/*************************************************************************/


/*
 *  Structure to define additional command line delimiters.
 */
struct p_parms
{
    WORD  parmsx_ptr;             /* pointer to parms structure */           
    BYTE  p_num_extra;            /* 1 says that a delimiter list follows */ 
    BYTE  p_len_extra_delim;      /* number of additional delimiters */      
    BYTE  p_extra_delim[2];       /* additional delimiters */                
};

/*
 *  Structure to define backup syntax requirements.
 */
struct p_parmsx
{
     BYTE  p_minpos;              /* there are 2 required positional parms */
     BYTE  p_maxpos;              /* there are 2 required positional parms */
     WORD  pos1_ptr;              /* pointer to source filespec def area */
     WORD  pos2_ptr;              /* pointer to target drive def area */
     BYTE  num_sw;                /* there are 7 switches (/S, /F, /M, /A, /L:, /T:, /D:) */
     WORD  sw1_ptr;               /* pointer to first switch definition area */
     WORD  sw2_ptr;               /* pointer to second switch definition area */
     WORD  sw3_ptr;               /* pointer to third switch definition area */
     WORD  sw4_ptr;               /* pointer to fourth switch definition area */
     WORD  sw5_ptr;               /* pointer to fifth switch definition area */
     WORD  sw6_ptr;               /* pointer to sixth switch definition area */
     WORD  sw7_ptr;               /* pointer to seventh switch definition area */
     WORD  num_keywords;          /* number of keywords in backup syntax */
};

/*
 *  Structure to define positional parms.
 */
struct p_pos_blk
{
    WORD  match_flag;             /* controls type matched */
    WORD  function_flag;          /* function should be taken */
    WORD  result_buf;             /* result buffer address */
    WORD  value_list;             /* value list address */
    BYTE  nid;                    /* # of keyword/SW synonyms (0) */
};

/*
 *  Structure to define switches.
 */
struct p_sw_blk
{
    WORD  p_match_flag;           /* controls type matched */
    WORD  p_function_flag;        /* function should be taken */
    WORD  p_result_buf;           /* result buffer address */
    WORD  p_value_list;           /* value list address */
    BYTE  p_nid;                  /* # of switches */
    BYTE  switch1[3];             /* save area for switch */
    BYTE  switch2[3];             /* save area for switch */
    BYTE  switch3[3];             /* save area for switch */
    BYTE  switch4[3];             /* save area for switch */
};

/*
 *  Structure to define switches.
 */
struct p_sw7_blk
{
    WORD  p_match_flag;           /* controls type matched */
    WORD  p_function_flag;        /* function should be taken */
    WORD  p_result_buf;           /* result buffer address */
    WORD  p_value_list;           /* value list address */
    BYTE  p_nid;                  /* # of switches */
    BYTE  switch7[3];             /* save area for switch */
};


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 *  Return buffer for time.
 */
struct timebuff
{
    BYTE  t_type;                 /* type returned */  
    BYTE  t_item_tag;             /* space for item tag */
    WORD  t_synonym_ptr;          /* pointer to Synonym list returned */
    BYTE  hours;
    BYTE  minutes;
    BYTE  seconds;
    BYTE  hundreds;
};

/*
 *  Return buffer for date.
 */
struct datebuff
{
    BYTE  d_type;                 /* type returned */  
    BYTE  d_item_tag;             /* space for item tag */
    WORD  d_synonym_ptr;          /* pointer to Synonym list returned */
    WORD  year;
    BYTE  month;
    BYTE  day;
};

/*
 *  Return buffer for positional parameters.
 */
struct p_result_blk
{
    BYTE  p_type;                 /* type returned */
    BYTE  p_item_tag;             /* matched item tag */
    WORD  p_synonym_ptr;          /* pointer to Synonym list returned */
    DWORD p_string_ptr;           /* pointer to string */
};

/*
 *  Return buffer for switch information. 
 */
struct	switchbuff
{
    BYTE  sw_type;                /* type returned */
    BYTE  sw_item_tag;            /* matched item tag */
    WORD  sw_synonym_ptr;         /* pointer to synonym */
    DWORD sw_string_ptr;          /* pointer to string */
};


/*
 *  Value list for /F: parameter.
 */
struct val_list_struct
{
    BYTE  nval;
    BYTE  num_ranges;
    BYTE  num_choices;
    BYTE  num_strings;
    BYTE  item_tag01;
    WORD  val01;
    BYTE  item_tag02;
    WORD  val02;
    BYTE  item_tag03;
    WORD  val03;
    BYTE  item_tag04;
    WORD  val04;     
    BYTE  item_tag05;
    WORD  val05;     
    BYTE  item_tag06;
    WORD  val06;     
    BYTE  item_tag07;
    WORD  val07;     
    BYTE  item_tag08;
    WORD  val08;     
    BYTE  item_tag09;
    WORD  val09;     
    BYTE  item_tag10;
    WORD  val10;     
    BYTE  item_tag11;
    WORD  val11;     
    BYTE  item_tag12;
    WORD  val12;     
    BYTE  item_tag13;
    WORD  val13;     
    BYTE  item_tag14;
    WORD  val14;     
    BYTE  item_tag15;
    WORD  val15;     
    BYTE  item_tag16;
    WORD  val16;     
    BYTE  item_tag17;
    WORD  val17;     
    BYTE  item_tag18;
    WORD  val18;     
    BYTE  item_tag19;
    WORD  val19;     
    BYTE  item_tag20;
    WORD  val20;     
    BYTE  item_tag21;
    WORD  val21;     
    BYTE  item_tag22;
    WORD  val22;     
    BYTE  item_tag23;
    WORD  val23;     
    BYTE  item_tag24;
    WORD  val24;     
    BYTE  item_tag25;
    WORD  val25;     
    BYTE  item_tag26;
    WORD  val26;     
    BYTE  item_tag27;
    WORD  val27;     
    BYTE  item_tag28;             /* M007 Start */
    WORD  val28;
    BYTE  item_tag29;
    WORD  val29;
    BYTE  item_tag30;
    WORD  val30;
    BYTE  item_tag31;
    WORD  val31;
    BYTE  item_tag32;
    WORD  val32;
    BYTE  item_tag33;
    WORD  val33;                  /* M007 End */
};

/*
 *  Value table for /F: parameter. 
 */
struct val_table_struct
{
    BYTE  val01[7];
    BYTE  val02[7];
    BYTE  val03[7];
    BYTE  val04[7];
    BYTE  val05[7];
    BYTE  val06[7];
    BYTE  val07[7];
    BYTE  val08[7];
    BYTE  val09[7];
    BYTE  val10[7];
    BYTE  val11[7];
    BYTE  val12[7];
    BYTE  val13[7];
    BYTE  val14[7];
    BYTE  val15[7];
    BYTE  val16[7];
    BYTE  val17[7];
    BYTE  val18[7];
    BYTE  val19[7];
    BYTE  val20[7];
    BYTE  val21[7];
    BYTE  val22[7];
    BYTE  val23[7];
    BYTE  val24[7];
    BYTE  val25[7];
    BYTE  val26[7];
    BYTE  val27[7];
    BYTE  val28[7];               /* M007 Start */
    BYTE  val29[7];
    BYTE  val30[7];
    BYTE  val31[7];
    BYTE  val32[7];
    BYTE  val33[7];               /* M007 End */
};


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\backup\_parse.asm ===
page	60,132
name	_parse
title	C	to PARSER interface
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.30 parser
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;       Revision History
;       M006    2/4/91  MD      Removed spurious IBMCOPYRIGHT flag
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse

	include version.inc

;-------------------------------------------------------------------
FarSW	equ	0			; make sysparse be a NEAR proc
TimeSW	equ	1			; Check time format
FileSW	equ	1			; Check file specification
CAPSW	equ	1			; Perform CAPS if specified
CmpxSW	equ	0			; Check complex list
NumSW	equ	0			; Check numeric value
KeySW	equ	0			; Support keywords
SwSW	equ	1			; Support switches
Val1SW	equ	0			; Support value definition 1
Val2SW	equ	0			; Support value definition 2
Val3SW	equ	1			; Support value definition 3 ;M006
DrvSW	equ	1			; Support drive only format
QusSW	equ	0			; Support quoted string format
IncSW	equ	0			; Dont include PSDATA, I just did it
BaseSW	equ	1			; DS points to data
;-------------------------------------------------------------------

DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'
include psdata.inc
_DATA	ends

_TEXT	segment byte public 'CODE'

	ASSUME	CS: PGROUP
	ASSUME	DS: DGROUP

;-------------------------------------------------------------------
.xlist
include parse.asm			; include the parser
.list
;-------------------------------------------------------------------

_parse	proc	near

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer
;-------------------------------------------------------------------
	call	sysparse		; call the parser
;-------------------------------------------------------------------
	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6]		; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

_parse	endp

_TEXT	ends				; end code segment
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkdisk.asm ===
TITLE	CHKDISK  - procedures that read or write to the disk
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
page	,132					;

	.xlist
	include chkseg.inc							;an005;bgb
	INCLUDE CHKCHNG.INC
	INCLUDE DOSSYM.INC
	INCLUDE CHKEQU.INC
	INCLUDE CHKMACRO.INC
	include pathmac.inc


CONST	SEGMENT PUBLIC PARA  'DATA'
	EXTRN	FIXMES_ARG:word
	EXTRN	BADW_ARG:word
	EXTRN	badrw_num:word,BADRW_STR:WORD,HAVFIX:byte
	EXTRN	DIRTYFAT:byte,DOFIX:byte,SECONDPASS:byte
	EXTRN	HECODE:byte,USERDIR:byte,FRAGMENT:byte
	EXTRN	ORPHEXT:byte,ALLDRV:byte,FIXMFLG:byte,DIRCHAR:byte
	EXTRN	EOFVAL:word,BADVAL:word
	extrn	fTrunc:BYTE
CONST	ENDS

DATA	SEGMENT PUBLIC PARA 'DATA'
	EXTRN	THISDPB:dword,NUL_ARG:byte
	EXTRN	NAMBUF:byte,SRFCBPT:word,FATMAP:word
	EXTRN	USERDEV:byte,HARDCH:dword,CONTCH:dword
	EXTRN	ExitStatus:Byte,Read_Write_Relative:Byte
	extrn	bytes_per_sector:word						;an005;bgb
	extrn	sec_count:word, paras_per_64k:word, secs_per_64k:word		 ;an005;bgb
	extrn	fattbl_seg:word, paras_per_fat:word		       ;an005;bgb
DATA	ENDS

CODE	SEGMENT PUBLIC PARA 'CODE'
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
	EXTRN	FCB_TO_ASCZ:NEAR
	EXTRN	EPRINT:NEAR
	EXTRN	PROMPTYN:NEAR,DIRPROC:NEAR
	EXTRN	DOCRLF:NEAR,UNPACK:NEAR,PACK:NEAR
	EXTRN	CHECKNOFMES:NEAR
public read_disk, Read_once, write_disk, Write_once				;an005;bgb
public ReadFt, seg_adj, calc_sp64k						;an005;bgb
	.list


	pathlabl chkdisk
;=========================================================================	;an005;bgb
; READ_DISK	:	This routine reads the logical sector count requested.	;an005;bgb
;			It will read a maximum of 64k in one read.  If more	;an005;bgb
;			than 64k exists it will continue looping until		;an005;bgb
;			all sectors have been read.				;an005;bgb
;										;an005;bgb
;	Inputs	:	AL - Drive letter					;an005;bgb
;			ES:BX - Segment:offset of transfer address		;an005;bgb
;			CX - Sector count					;an005;bgb
;			DX - 1st  sector					;an005;bgb
;										;an005;bgb
;	Outputs :	Logical sectors read					;an005;bgb
; LOGIC 									;an005;bgb
; ***** 									;an005;bgb
;    adjust es:bx to es:00							;an005;bgb
;    calcluate sectors-per-64k (how many sectors are there that can fit within a 64k segment?)
;    DO while there are more sectors to read than sectors-per-64k		;an005;bgb
;	set sector-count to sectors-per-64k					;an005;bgb
;	perform the disk read							;an005;bgb
;	bump the seg addr to the new addr					;an005;bgb
;	dec  the number of sectors to read by sectors-per-64k			;an005;bgb
;	bump the starting sector number by the sectors-per-64k			;an005;bgb
;    ENDDO									;an005;bgb
;    perform a disk read for less than sectors-per-64k				;an005;bgb
;=========================================================================	;an005;bgb
procedure	read_disk							;an005;bgb
	savereg <ax,bx,cx,dx,es>						;an005;bgb
	call	seg_adj 			;an000;calc new seg:off 	;an005;bgb
	call	calc_sp64k			;an000;secs/64k 		;an005;bgb
;	$DO				; do while more than 64k		;an005;bgb
$$DO1:
	    cmp     cx,secs_per_64k	    ;an000;exceed 64k			;an005;bgb
;	$LEAVE	LE			    ;an000;yes				;an005;bgb
	JLE $$EN1
	    mov     sec_count,cx	;an000;save cx				;an005;bgb
	    mov     cx,secs_per_64k	;an000;get maximum read 		;an005;bgb
	    call    read_once		;an000;read it				;an005;bgb
;	$LEAVE	C								;an005;bgb
	JC $$EN1
	    mov     cx,es							;an005;bgb
	    add     cx,paras_per_64k	; adjust transfer area			;an005;bgb
	    mov     es,cx							;an005;bgb
	    mov     cx,sec_count	; restore sector count			;an005;bgb
	    sub     cx,secs_per_64k	;an000;get sectors remaining		;an005;bgb
	    add     dx,secs_per_64k	;an000;adjust starting sector		;an005;bgb
;	$ENDDO									;an005;bgb
	JMP SHORT $$DO1
$$EN1:
	call	read_once	    ;an000;read it				;an005;bgb
	restorereg <es,dx,cx,bx,ax>						;an005;bgb
	ret									;an005;bgb
read_disk	endp								 ;an005;bgb
										;an005;bgb
										;an005;bgb
;*****************************************************************************	;an005;bgb
;Routine name: Read_once							;an005;bgb
;*****************************************************************************	;an005;bgb
;										;an005;bgb
;description: Read in data using Generic IOCtl					;an005;bgb
;										;an005;bgb
;Called Procedures: None							;an005;bgb
;										;an005;bgb
;										;an005;bgb
;Change History: Created	5/13/87 	MT				;an005;bgb
;										;an005;bgb
;Input: AL = Drive number (0=A) 						;an005;bgb
;	es:BX = Transfer address						;an005;bgb
;	CX = Number of sectors							;an005;bgb
;	Read_Write_Relative.Start_Sector_High = Number of sectors high		;an005;bgb
;	DX = logical sector number low						;an005;bgb
;										;an005;bgb
;Output: CY if error								;an005;bgb
;	 AH = INT 25h error code						;an005;bgb
;										;an005;bgb
;Psuedocode									;an005;bgb
;----------									;an005;bgb
;	Save registers								;an005;bgb
;	Setup structure for function call					;an005;bgb
;	Read the disk (AX=440Dh, CL = 6Fh)					;an005;bgb
;	Restore registers							;an005;bgb
;	ret									;an005;bgb
;*****************************************************************************	;an005;bgb
Procedure Read_once				;				;an005;bgb
	savereg  <ax,bx,cx,dx,si,di,bp,es,ds>	;Change it to Read relative sect;an005;bgb
	mov	Read_Write_Relative.Buffer_Offset,bx ;Get transfer buffer add	 ;an005;bgb
	mov	bx,es				;				;AN005;bgb
	mov	Read_Write_Relative.Buffer_Segment,bx ;Get segment		;an005;bgb
	mov	Read_Write_Relative.Number_Sectors,cx ;Number of sec to read	;an005;bgb
	mov	Read_Write_Relative.Start_Sector_Low,dx ;Start sector		;an005;bgb
	mov	bx,offset Read_Write_Relative	;				;an005;bgb
	mov	cx,0FFFFh			;Read relative sector		;an005;bgb
	INT	25h				;Do the read			;an005;bgb
	pop dx					;Throw away flags on stack	;an005;bgb
	restorereg <ds,es,bp,di,si,dx,cx,bx,ax> 				;an005;bgb
	return									;an005;bgb
 Read_once endp 								;an005;bgb
										;an005;bgb
										;an005;bgb
;=========================================================================	;an005;bgb
; WRITE-DISK	:	This routine reads the logical sector count requested.	;an005;bgb
;			It will read a maximum of 64k in one read.  If more	;an005;bgb
;			than 64k exists it will continue looping until		;an005;bgb
;			all sectors have been read.				;an005;bgb
;										;an005;bgb
;	Inputs	:	AL - Drive letter					;an005;bgb
;			ES:BX - Segment:offset of transfer address		;an005;bgb
;			CX - Sector count					;an005;bgb
;			DX - 1st  sector					;an005;bgb
;										;an005;bgb
;	Outputs :	Logical sectors read					;an005;bgb
; LOGIC 									;an005;bgb
; ***** 									;an005;bgb
;    adjust es:bx to es:00							;an005;bgb
;    calcluate sectors-per-64k (how many sectors are there that can fit within a 64k segment?)
;    DO while there are more sectors to read than sectors-per-64k		;an005;bgb
;	set sector-count to sectors-per-64k					;an005;bgb
;	perform the disk read							;an005;bgb
;	bump the seg addr to the new addr					;an005;bgb
;	dec  the number of sectors to read by sectors-per-64k			;an005;bgb
;	bump the starting sector number by the sectors-per-64k			;an005;bgb
;    ENDDO									;an005;bgb
;    perform a disk read for less than sectors-per-64k				;an005;bgb
;=========================================================================	;an005;bgb
procedure      write_disk							;an005;bgb
	savereg <ax,bx,cx,dx,es>						;an013;bgb
	call	seg_adj 		;an000;calc new seg:off 		;an005;bgb
;	$DO				; do while more than 64k		;an005;bgb
$$DO5:
	    cmp     cx,secs_per_64k	;an000;exceed 64k			;an005;bgb
;	$LEAVE	LE			;an000;yes				;an005;bgb
	JLE $$EN5
	    mov     sec_count,cx	;an000;save cx				;an005;bgb
	    mov     cx,secs_per_64k	;an000;get maximum read 		;an005;bgb
	    call   write_once		;an000;read it				;an005;bgb
;	$LEAVE	C								;an005;bgb
	JC $$EN5
	    mov     cx,es							;an005;bgb
	    add     cx,paras_per_64k	; adjust transfer area			;an005;bgb
	    mov     es,cx							;an005;bgb
	    mov     cx,sec_count	; restore sector count			;an005;bgb
	    sub     cx,secs_per_64k	;an000;get sectors remaining		;an005;bgb
	    add     dx,secs_per_64k	;an000;adjust starting sector		;an005;bgb
;	$ENDDO									;an005;bgb
	JMP SHORT $$DO5
$$EN5:
	call	write_once		;an000;read it				;an005;bgb
	restorereg <es,dx,cx,bx,ax>						;an013;bgb
	ret									;an005;bgb
write_disk	endp								;an005;bgb
										;an005;bgb
;*****************************************************************************	;an005;bgb
;Routine name: Write_once							;an005;bgb
;*****************************************************************************	;an005;bgb
;										;an005;bgb
;description: Write Data using int 26						;an005;bgb
;										;an005;bgb
;Called Procedures: None							;an005;bgb
;										;an005;bgb
;										;an005;bgb
;Change History: Created	5/13/87 	MT				;an005;bgb
;										;an005;bgb
;Input: AL = Drive number (0=A) 						;an005;bgb
;	DS:BX = Transfer address						;an005;bgb
;	CX = Number of sectors							;an005;bgb
;	Read_Write_Relative.Start_Sector_High = already set up			;an048;bgb
;	DX = logical sector number low						;an005;bgb
;										;an005;bgb
;Output: CY if error								;an005;bgb
;	 AH = INT 26h error code						;an005;bgb
;										;an005;bgb
;Psuedocode									;an005;bgb
;----------									;an005;bgb
;	Save registers								;an005;bgb
;	Setup structure for function call					;an005;bgb
;	Write to disk (AX=440Dh, CL = 4Fh)					;an005;bgb
;	Restore registers							;an005;bgb
;	ret									;an005;bgb
;*****************************************************************************	;an005;bgb
Procedure Write_once				 ;				;an005;bgb
    savereg <ax,bx,cx,dx,di,si,bp,es,ds>	 ;This is setup for INT 26h right;AN005;bgb
    mov  Read_Write_Relative.Buffer_Offset,bx	 ;Get transfer buffer add	;AN005;bgb
    mov  bx,es					 ;				;AN005;bgb
    mov  Read_Write_Relative.Buffer_Segment,bx	 ;Get segment			;AN005;bgb
    mov  Read_Write_Relative.Number_Sectors,cx	 ;Number of sec to write	;AN005;bgb
    mov  Read_Write_Relative.Start_Sector_Low,dx ;Start sector			;AN005;bgb
    mov  cx,0FFFFh				 ;Write relative sector 	;AN005;bgb
    lea  bx,read_write_relative 		 ;				;an005;bgb
    INT  026h					 ;Do the write			;AN005;bgb
    pop  dx					 ;flags is returned on the stack;AN005;bgb
    restorereg <ds,es,bp,si,di,dx,cx,bx,ax>	 ;				;AN005;bgb
	ret					 ;				;AN005;bgb
Write_once endp 				 ;				;AN005;bgb
										;an005;bgb
;=========================================================================	;an005;bgb
; SEG_ADJ	:	This routine adjusts the segment:offset to prevent	;an005;bgb
;			address wrap.						;an005;bgb
;										;an005;bgb
;	Inputs	:	bx - Offset to adjust segment with			;an005;bgb
;			es - Segment to be adjusted				;an005;bgb
;										;an005;bgb
;	Outputs :	bx - New offset 					;an005;bgb
;			es - Adjusted segment					;an005;bgb
;=========================================================================	;an005;bgb
procedure	seg_adj 							;an005;bgb
	savereg <ax,cx,dx>							;an005;bgb
	mov	ax,bx				;an000;get offset		;an005;bgb
	mov	bx,0010h			;divide by 16			;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				;an000;get para count	    ;an022;bgb
	mov	bx,es				;an000;get seg			;an005;bgb
	add	bx,ax				;an000;adjust for paras 	;an005;bgb
	mov	es,bx				;an000;save new seg		;an005;bgb
	mov	bx,dx				;an000;new offset		;an005;bgb
	restorereg <dx,cx,ax>							;an005;bgb
	ret									;an005;bgb
seg_adj 	endp								;an005;bgb
										;an005;bgb
										;an005;bgb
;=========================================================================	;an005;bgb
; CALC_SP64K	:	This routine calculates how many sectors, for this	;an005;bgb
;			particular media, will fit into 64k.			;an005;bgb
;										;an005;bgb
;	Inputs	:	DPB_SECTOR_SIZE - bytes/sector				;an005;bgb
;										;an005;bgb
;	Outputs :	SECS_PER_64K	- Sectors / 64k 			;an005;bgb
;			PARAS_PER_64K	- paragraphs per 64k			;an005;bgb
;=========================================================================	;an005;bgb
procedure	calc_sp64k							;an005;bgb
	savereg <ax,bx,cx,dx>							;an005;bgb
	mov	ax,0ffffh			;an000;64k			;an005;bgb
	mov	bx,bytes_per_sector		;an000;get bytes/sector 	;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				;an000;sector count	    ;an022;bgb;bgb
	mov	secs_per_64k,ax 		;an000;save sector count	;an005;bgb
	mov	ax,bytes_per_sector		;an000;get bytes/sector 	;an005;bgb
	mov	bx,010h 			; divide by paras		;an005;bgb
	xor	dx,dx				;an000;clear dx 		;an005;bgb
	div	bx				; paras per sector	    ;an022;bgb;bgb
	mul	secs_per_64k			; times sectors 		;an005;bgb
	mov	paras_per_64k,ax		; = paras per 64k		;an005;bgb
	restorereg <dx,cx,bx,ax>		;an000;restore dx		;an005;bgb
	ret					;an000; 			;an005;bgb
calc_sp64k	endp				;an000; 			;an005;bgb
										;an005;bgb
										;an005;bgb
	Break	<ReadFT - read in the entire fat>				;an005;bgb
;****************************************************************************** ;an005;bgb
;   ReadFt - attempt to read in the fat.  If there are errors, step to		;an005;bgb
;   successive fats until no more.						;an005;bgb
;										;an005;bgb
;   Inputs:	none.								;an005;bgb
;   Outputs:	Fats are read until one succeeds.				;an005;bgb
;		Carry set indicates no Fat could be read.			;an005;bgb
;   Registers modified: all							;an005;bgb
; LOGIC 									;an005;bgb
; ***** 									;an005;bgb
;  DO for each of the fats on the disk: 					;an005;bgb
;     read - all the sectors in the fat 					;an005;bgb
;     increase the starting sector by the number of sectors in each fat 	;an005;bgb
;										;an005;bgb
; LARGE FAT SUPPORT - the big change here is in read disk.  since the fat must	;an005;bgb
;     be within the first 32M, then the starting sector number of 65535 is ok,	;an005;bgb
;     as is a larger number of sectors to read/write.				;an005;bgb
;****************************************************************************** ;an005;bgb
Procedure ReadFt,NEAR								;an005;bgb
    clc 				;Clear CY so we will loop		    ;an005;bgb
    mov     Read_Write_Relative.Start_Sector_High,0 ;			;an005;bgb
    call    Read_Disk			;	Read_Disk ();		    ;AC0;an005;bgb
;   $IF     C
    JNC $$IF9
	add	dx,cx			;	fatstart += fatsize		;an005;bgb
	call	Read_Disk		;	Read_Disk ();		    ;AC0;an005;bgb
;   $ENDIF
$$IF9:
bad_read: ret									;an005;bgb
EndProc ReadFt									;an005;bgb


	pathlabl chkdisk
CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkdata.inc ===
;==================================================================
; CHKDATA.INC
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; CHANGE HISTORY:
; M003   NSM	1/30/91		 Add a new var for TOP_OF_MEM
;==================================================================

CONST	SEGMENT PUBLIC PARA 'DATA'
	EXTRN	STACKMES:byte
	EXTRN	BADVER:byte, BADDRV_ARG:word, INVPATH_ARG:word
	EXTRN	FILE_ARG:word
	EXTRN	BADCD_ARG:word, BADSUBDIR:byte
	EXTRN	no_mem_arg:word 						;an030;bgb
	EXTRN	BADRDMES:byte
	EXTRN	BADDRVM:byte
	EXTRN	BADIDBYT:byte
	EXTRN	OPNERR_ARG:word, NOEXT_ARG:word, EXTENT_ARG:word
	EXTRN	IDMES_ARG:WORD
	EXTRN	ORPH_ARG:WORD
	EXTRN	FILE_ARG1:WORD, FILE_ARG2:WORD
	EXTRN	badrw_num:word, BADRW_STR:WORD, BLOCK_NUM:WORD
	EXTRN	FATAL_ARG1:WORD, FATAL_ARG2:WORD
	EXTRN	FATmsg2:word							;an024;bgb
	EXTRN	BADSW_ARG:WORD, DSKSPC:WORD				     ;an049;bgb
	EXTRN	HIDMES:WORD, DIRMES:WORD, FILEMES:WORD, ORPHMES2:WORD
	EXTRN	ORPHMES3:WORD, BADSPC:WORD, FRESPC:WORD
	EXTRN	FREMEM:WORD, REPORT_ARG:WORD, CRLF_ARG:WORD
	EXTRN	RARG1:WORD, RARG3:WORD, ORPHCNT:WORD
	EXTRN	NO_NET_ARG:byte, SubstErr:BYTE
	EXTRN	ExitStatus:Byte,Badr_Arg:Byte					;an000;bgb
	EXTRN	Sublist_msg_Idmes:word						;an000;bgb
	extrn	msgserialnumber:byte						;an000;bgb
	extrn	psp_segment:word						;an000;bgb;an034;bgb
										;an000;bgb
	PUBLIC	SWITCHAR
	PUBLIC	TCHAR
	PUBLIC	HECODE
	PUBLIC	conbuf
	PUBLIC	DOTMES
	PUBLIC	NOISY
	PUBLIC	DOTENT
	PUBLIC	HAVFIX
	PUBLIC	DOFIX
	PUBLIC	DIRBUF
	PUBLIC	PARSTR, DDOTENT, NUL, ERRSUB, SECONDPASS, ALLFILE
	PUBLIC	ORPHFCB, ORPHEXT, HIDCNT, HIDSIZ, FILCNT, FILSIZ, DIRCNT
	PUBLIC	DIRSIZ, DIRTYFAT, CROSSCNT, BADSIZ, ORPHSIZ, LCLUS
	PUBLIC	USERDIR, FRAGMENT, ALLDRV, FIXMFLG, DIRCHAR
	PUBLIC	BIGFAT, EOFVAL, BADVAL,CHAIN_END
	PUBLIC	fTrunc,Volnam
	PUBLIC	temp_dd 						   ;an049;bgb

DIRBUF	LABEL	BYTE			;Entry buffer for searches
VOLID	DB	-1,0,0,0,0,0,8		;Volume ID FCB
VOLNAM	DB	0,"???????????"
	DB	25 DUP(0)

ALLFILE DB	-1			;Extended FCB indicator
	DB	0,0,0,0,0		;reserved bytes
	DB	1EH	;attribute byte 0001-1110 hidden, system, label, subdir
ALLDRV	DB	0			;default drive
	DB	"???????????"           ;any file name
	DB	25 DUP (?)

ORPHFCB DB	0,"FILE0000"
ORPHEXT DB	"CHK"
	DB	25 DUP (?)

fcb_copy db	32 dup (?)

;Non-message data

pFileName   DW	?			; pointer
SWITCHAR DB	"/"
ROOTSTR LABEL	BYTE	;use this to change dir to the root
DIRCHAR DB	"\"
NUL	DB	0
PARSTR	DB	"..",0
DOTMES	DB	".",0
DOTENT	DB	".          "
DDOTENT DB	"..         "
HECODE	DB	?
FIXMFLG DB	0			;Flag for printing fixmes
ERRSUB	DW	0			;Flag for bad subdir error
FRAGMENT DB	0			;Flag for extent processing
DIR_FIX  DB	0			;Flag for changing dir back to users'
DIRTYFAT DB	0			;Dirty flag for FAT
;
;note - all these fields that count allocation units can remain the same,
;	because the total au's are always less than 64k (1 word).
; looks like the number of files and directories should change, though.
DIRCNT	dd	0			;# directories				;an049;bgb
DIRSIZ	dw	0			;# alloc units in dirs			;an049;bgb
FILCNT	dd	0			;# reg files
FILSIZ	dw	0			;# alloc units in reg files
HIDCNT	dd	0			;# hidden files
HIDSIZ	dw	0			;# alloc units in hid files
BADSIZ	dw	0			;# alloc units in bad sectors
ORPHSIZ dw	0			;# alloc units in orphan files
LCLUS	dw	0			;# alloc units in lost clusters
DISPFLG DB	0			;used by number routines
CROSSCNT dd	0			;# crosslinked files (first pass)
;end of display fields
;
temp_dd    dd	0		    ;temporary double word field for orphcnt;an049;bgb
SECONDPASS DB	0			;Pass flag
HAVFIX	DB	0			;non zero if any fixes
DOFIX	DB	0			;flag for F switch
NOISY	DB	0			;flag for V switch
BIGFAT	DB	0			;0=12 bit FAT, NZ=16bit FAT
EOFVAL	DW	0FF8H			;0FF8 for 12 bit FAT,0FFF8 for 16 bit
CHAIN_END DW	0FFFH			;0FFF for 12 bit FAT,0FFFF for 16 bit	;AN000;
BADVAL	DW	0FF7H			;0FF7 for 12 bit FAT,0FFF7 for 16 bit

mon_name db	3 dup (?),0
TCHAR	DB	'a'
USERDIR DB	"\",0                   ;Users current dir for drive
	DB	(DIRSTRLEN-1) DUP (?)
CONBUF	DB	15,0			;Input buffer
	DB	15 DUP (?)

fTrunc	DB	FALSE			; TRUE => couldn't chdir, no freeing.

badread db	"   File allocation table bad",0
CONST	ENDS








DATA	SEGMENT PUBLIC PARA 'DATA'
	PUBLIC	THISDPB,DOTSNOGOOD,NUL_ARG,STACKLIM,ZEROTRUNC
	PUBLIC	NAMBUF,SRFCBPT,fatmap,ISCROSS,MCLUS,CSIZE,SSIZE
	PUBLIC	DSIZE,ARG1,ARG_BUF,ERRCNT,USERDEV,SECBUF
	PUBLIC	HARDCH,CONTCH,PATH_NAME,TMP_SPC,mem_size,top_of_mem
	public	Read_Write_Relative,Transrc, fatcnt, fattbl_seg,max_free
	public	firstfat, fatsiz, secs_per_64k, paras_per_fat, sec_count	;an000;bgb
	public	firstsec							;an047;bgb
	public	dirsec								;an047;bgb
     public    root_entries						       ;an047;bgb
	public	paras_per_64k, save_drive					;an000;bgb
	public	sernum								;an000;bgb;an024;bgb
ifdef	fsexec									;an038;bgb
	public	exec_path							;an038;bgb;an000;bgb;an027;bgb
	public	exec_block							;an038;bgb;an000;bgb;an027;bgb
	public	path_string							;an038;bgb;an000;bgb;an027;bgb
endif	
	public	DBCS_VECTOR							;an055;bgb
	public	DBCS_VECTOR_off 						;an055;bgb
	public	DBCS_VECTOR_seg 						;an055;bgb

DBCS_VECTOR DB 0
DBCS_VECTOR_off dw 0
DBCS_VECTOR_seg dw 0

ifdef	fsexec									;an038;bgb
Exec_Block Exec_Block_Parms <>							;an038;bgb;an027;bgb
EXEC_Path db	66 dup(0)							;an038;bgb;an027;bgb
;These next two should stay togather						;an027;bgb
; ---------------------------------------					;an027;bgb
Path_String db	"PATH="                         ;                               ;an027;bgb
Len_Path_String equ $ - Path_String		;				;an027;bgb;AN000;
;----------------------------------------					;an027;bgb
endif										;an038;bgb
										;an038;bgb;an027;bgb
										;an027;bgb
;These should stay togather							;an027;bgb
; ---------------------------------------					;an027;bgb
						;				;an027;bgb
Search_Chkdsk db "KSDKHC"                       ;                               ;an027;bgb
Len_Search_Chkdsk equ $ - Search_Chkdsk 	;				;an027;bgb
Search_Chkdsk_End equ $-1							;an027;bgb
						;				;an027;bgb
;----------------------------------------					;an027;bgb
save_drive	db	0   ;determines whether drive specified is valid
firstfat	dw	0   ;sector number of fat     ;an005;bgb
firstsec	dw	0   ;sector number of data area 			;an047;bgb
dirsec		dw	0   ;sector number of dir  area 			;an047;bgb
root_entries   dw   0	;number of entries in root dir				;an047;bgb
fattbl_seg	dw	0   ;segment of the fat-table ;an005;bgb
sec_count	dw	0  ;sectors / 64k
secs_per_64k	dw	0			   ;an005;bgb
paras_per_64k	dw	0			   ;an005;bgb
fatsiz		dw	0			   ;an005;bgb
paras_per_fat	dw	0			   ;an005;bgb
fatcnt		db	2			;number of fats on disk 		;an005;bgb
HARDCH	dd	?			;Pointer to real INT 24 handler
CONTCH	DD	?			;Pointer to real INT 23 handler
THISDPB DD	?			;Pointer to drive DPB
USERDEV DB	?			;Users current device
CSIZE	DB	?			;Sectors per cluster 1-256
SSIZE	DW	?			;bytes per sector 1-64k
DSIZE	DW	?			;# alloc units on disk
MCLUS	DW	?			;DSIZE + 1
NAMBUF	DB	14 DUP (?)		;Buffer
DOTSNOGOOD DB	?			;. or .. error flag
ZEROTRUNC DB	?			;Trimming flag
ISCROSS DB	?			;Crosslink flag
OLDCLUS DW	?
SRFCBPT DW	?
fatmap	DW	?			;segment of fatmap table
SECBUF	DW	?			;Offset of sector buffer (in ram)
ERRCNT	DB	?			;Used by FATread and write
PATH_NAME DB	128 DUP(0)
FNAME_LEN DW	128
NUL_ARG DB	?
ARG1	DW	?
ARG2	DW	?
ARG3	DW	?


;
; The following is used as a PRINTF buffer and also as the source/destination
; for a name trans
;
ARG_BUF DB	256 DUP (?)
TMP_SPC DB	128 DUP (?)
mon	dw	?
day	dw	?
year	dw	?
mem_size  dw	?
top_of_mem	dw	?	; M003
max_free	dw	0	; M003
				; 0 => loaded in conv. mem

;;;TRANSRC DB	   "A:CON",0,0                     ; Device so we don't hit the drive
TRANSRC DB	"A:\",0,0                     ; Device so we don't hit the drive
Read_Write_Relative	Relative_Sector_Buffer <>  ;				;AN000;

STACKLIM DW	?			;Stack growth limit
INTERNATVARS	internat_block <>
		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)


;	      Structure for Get_Media_Id					;an024;bgb
SerNumBuf	   Label Byte	   ;AN000;S GENERIC_IOCTL buffer		;an024;bgb
		   dw	0	   ;AN000;S Info level (set on input)		;an024;bgb
SerNum		   dd	0	   ;AN000;S Serial #				;an024;bgb
		   db	11 DUP(' ') ;AN000;S Volume label                       ;an024;bgb
		   db	8 DUP(' ') ;AN000;S File system type                    ;an024;bgb
DATA	ENDS

										;an000;bgb
										;an000;bgb
lastseg SEGMENT PUBLIC PARA 'LAST_S'                                              ;an000;bgb
 public fattbl									;an000;bgb
fattbl	db	0   ;this is the last thing in the pgm				;an000;bgb;an005;bgb
lastseg ends	    ;this is where the fat is put in ram			;an000;bgb

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\backup\backup.c ===
/**************************************************************************/
/*                                                                        */
/*  UTILITY NAME:      Backup                                             */
/*                                                                        */
/*  SOURCE FILE NAME:  Backup.C                                           */
/*                                                                        */
/*  STATUS:    BACKUP utility, DOS Version 4.00                           */
/*             Written using the C programming language.                  */
/*                                                                        */
/*  LABEL:     Microsoft Confidential                                     */
/*             Copyright (c) Microsoft Corporation 1991                   */
/*             All Rights Reserved.                                       */
/*                                                                        */
/**************************************************************************/
/*                                                                        */
/*  COMPILER/LINKER INVOCATION:                                           */
/*                                                                        */
/*     cc /AS /Os /Zep /W3 /DLINT_ARGS /UDEBUG backup.c;                  */
/*     link backup,,,mapper+comsubs                                       */
/*                                                                        */
/*     Note: You MUST(!) use the PACKED option (/Zp) to make sure data    */
/*           structures are not aligned !!!                               */
/*                                                                        */
/*  FUNCTION:                                                             */
/*     BACKUP will back up files from one disk(ette) to another. Accepts  */
/*     global characters, other parameters are defined to allow a more    */
/*     restrictive BACKUP procedure.  Compacts data into one large file   */
/*     and a control file containing directory information. Allows        */
/*     FORMATTING target diskette, intelligent error recovery, and proper */
/*     handling of file sharing and sharing errors. Optionally creates a  */
/*     log file for tracking purposes.  Sets errorlevels on termination   */
/*     to indicate result.                                                */
/*                                                                        */
/*  RESTRICTIONS:                                                         */
/*     The BACKUP Utility program will be version checked to run ONLY on  */
/*     DOS version 4.00.  BACKUP performs a file by file backup using the */
/*     DOS file system, ie. it is not an image type backup.               */
/*                                                                        */
/*  SYNTAX:                                                               */
/*     BACKUP [d:][path] filename [.ext]] d: [/S] [/F[:size]]             */
/*     [/L[:fn]] [/M] [/A] [T:hh:mm:ss] [/D:mm-dd-yy]                     */
/*                                                                        */
/*     [/F[:size]] undocumented                                           */
/*                                                                        */
/*  SOURCE HISTORY:                                                       */
/*	New for DOS 3.3 and OS/2                                          */
/*                                                                        */
/**************************************************************************/


#include <process.h>              /* "C" supplied include files */
#include <malloc.h>
#include <direct.h>
#include <string.h>
#include <dos.h>
#include <stdlib.h>
#include <conio.h>
#include <doscalls.h>             /* OS/2 include file */
#include "backup.h"               /* BACKUP structures, defines, ...*/
#include "backpars.h"             /* defines and structs for DOS Parser */
#include <version.h>              /* symbols to determine compatibility */


/*
 *  DATA STRUCTURES
 */
WORD rc;                          /* return code from DOS calls */

unsigned selector;                /* like a segment address */
                                  
struct node *curr_node;           /* pointer to "node" structure for the */
                                  /* directory currently being processed */
                                  
struct node *last_child;          /* pointer to "node" structure for the */
                                  /* last directory discovered in the */
                                  /* directory currently being processed */
                                  
struct subst_list sublist;        /* message substitution list */
                                  
struct p_parms parms;             /* parser data structure */
struct p_parmsx parmsx;           /* parser data structure */
struct p_pos_blk pos1;            /* parser data structure */
struct p_pos_blk pos2;            /* parser data structure */
struct p_sw_blk sw1;              /* parser data structure */
struct p_sw_blk sw2;              /* parser data structure */
struct p_sw_blk sw3;              /* parser data structure */
struct p_sw_blk sw4;              /* parser data structure */
struct p_sw_blk sw5;              /* parser data structure */
struct p_sw_blk sw6;              
struct p_sw7_blk sw7;             /* for /? */

struct p_result_blk pos_buff;     /* parser data structure */
struct switchbuff sw_buff;        /* parser data structure */
struct timebuff	time_buff;        /* parser data structure */
struct datebuff	date_buff;        /* parser data structure */
struct val_list_struct value_list;
struct val_table_struct value_table;
char curr_parm[128];              /* current parameter being parsed */

DWORD noval = 0;                  /* value list for PARSER */

struct FileFindBuf dta;           /* return area for Find First/Next */
struct FileFindBuf *dta_addr;     /* pointer to above */
union REGS inregs, outregs;       /* register set */


/*
 *  DATA AREAS
 */
WORD dirhandle;                   /* dirhandle field, for FindFirst, FindNext */
BYTE dirhandles_open = FALSE;     /* flag indicating at least 1 open dirhandle */

WORD def_drive;                   /* storage for default drive (1=A,2=B,...) */
BYTE src_drive_letter;            /* aSCII drive letter, source drive */
BYTE tgt_drive_letter;            /* aSCII drive letter, target drive */
BYTE src_def_dir[PATHLEN+20];     /* default dir on source, drive letter omitted */

BYTE src_drive_path_fn[PATHLEN+20];  /* d:\path\fn - fully qualified spec */
BYTE src_drive_path[PATHLEN+20];  /* d:\path - fully qualified drive and path */
BYTE src_fn[PATHLEN];             /* file spec - *.* if no filespec entered */
BYTE ext[3];                      /* filename extension */

WORD files_backed_up = 0;         /* ctr - # files backed up on current target */
BYTE diskettes_complete = 0;      /* # diskettes already filled and complete */
DWORD curr_db_begin_offset;       /* offset in control file of current Directory Block */
DWORD curr_fh_begin_offset;       /* offset in control file of current File Header */
WORD handle_source  = 0xffff;     /* handle for source file */
WORD handle_target  = 0xffff;     /* handle for target file */
WORD handle_control = 0xffff;     /* handle for control file */
WORD handle_logfile = 0xffff;     /* handle for log file */
DWORD part_size;                  /* # bytes from file on disk (files that span) */
DWORD cumul_part_size;            /* # bytes from all disks for particular file */

BYTE logfile_path[PATHLEN+20];    /* d:\path\filename - drive, path, and name */
BYTE format_path[PATHLEN+20];     /* full path to FORMAT.COM */
BYTE format_size[128];            /* if user enters "/F:size" this will be "size" */

char user_response[2];            /* user response of yes/no question - M011 */


/*
 *  PROGRAM CONTROL FLAGS
 */
BYTE do_subdirs = FALSE;          /* user parameters, /S */
BYTE do_add = FALSE;              /* user parameters, /A */
BYTE do_modified = FALSE;         /* user parameters, /M */
BYTE do_format_parms = FALSE;     /* user parameters, /F */
BYTE do_logfile = FALSE;          /* user parameters, /L */
BYTE do_time = FALSE;             /* user parameters, /T */
BYTE do_date = FALSE;             /* user parameters, /D */

BYTE buffers_allocated = FALSE;   /* if file buffers were allocated */
BYTE curr_dir_set = FALSE;        /* if current directory on source was changed */
BYTE def_drive_set = FALSE;       /* if default drive was changed */

BYTE control_opened = FALSE;      /* if file opened or not */
BYTE logfile_opened = FALSE;      /* if logfile file is opened */
BYTE source_opened = FALSE;       /* if file opened or not */
BYTE target_opened = FALSE;       /* if file opened or not */

BYTE doing_first_target = TRUE;   /* if first target is being processed */
BYTE backup_started = FALSE;      /* if backup started - useful for cleanups */

BYTE source_removable;            /* if source drive is removable */
BYTE target_removable;            /* if target drive is removable */

BYTE file_spans_target;           /* if first target is being processed */
BYTE disk_full = FALSE;           /* if the disk is full */
BYTE logfile_on_target = FALSE;   /* if user wants logfile on target drive */
BYTE got_path_validity = FALSE;   /* if input path not verified */
BYTE checking_target = FALSE;     /* if checking target disk to see if formatted */
BYTE deleting_files = FALSE;      /* if deleting files from target */ /* M009 */

BYTE new_directory = TRUE;        /* if file to be backed up is in different dir */
BYTE found_a_file = FALSE;        /* if a file was found to be backed up */
BYTE back_it_up = FALSE;          /* if file found and conforms to specified params */
BYTE ext_attrib_buff[3];          /* buffer for extended attributes */
struct parm_list ea_parmlist;     /* parameter list for extended open */


/*
 *  APPEND STUFF
 */
BYTE append_indicator = 0xff;     /* if support for APPEND /X is active */
WORD original_append_func;        /* APPEND functions on program entry, */
                                  /*   restored on program exit */


/*
 *  OTHER STUFF
 */
BYTE span_seq_num;                /* which part of a spanning file is on current target */

WORD data_file_alloc_size = 0xffff;  /* # paragraphs to allocate for data file */

DWORD data_file_tot_len = 0;      /* data file current length */
DWORD ctl_file_tot_len = 0;       /* control file current length on disk */

WORD ctry_date_fmt;
BYTE ctry_time_fmt;
WORD ctry_date_sep;
WORD ctry_time_sep;

WORD user_specified_time = 0;     /* time entered in response to /T */
WORD user_specified_date = 0;     /* date entered in response to /T */

BYTE return_code = RETCODE_NO_ERROR;  /* save area for DOS ErrorLevel */

BYTE need_to_swap_again = FALSE;  /* exchange disks before spawning FORMAT */

char *device_names[] = { "LPT1",
			 "LPT2",
			 "PRN",
			 "CON",
			 "NUL",
			 "AUX",
			 "LPT1:",
			 "LPT2:",
			 "PRN:",
			 "CON:",
			 "NUL:",
			 "AUX:" };
#define NOOFSTD_DEVICES	12             /* look above for standard device names */



/*********************************************************************/
/* Routine:  main                                                    */
/*                                                                   */
/* Function: Backs up files from source to target drive.             */
/*********************************************************************/

int main(int argc, char *argv[])
{
  /* initialize data structures, check DOS version, preload messages */
  init();
  
  /* look for /? - will exit if found */
  check_options_help(argc, argv);

  def_drive = get_current_drive();     /* save default drive number */
  check_drive_validity(argc, argv);    /* validate input drive(s) */
  get_drive_types();                   /* see if source and target removable */
  get_country_info();                  /* get country dependent info */
  parser(argc, argv);                  /* parse input line, init switches & flags */
  check_path_validity(argv);           /* validate source file spec */

  /* save default directories on def drive, source and target */
  save_current_dirs();

  alloc_buffer();                      /* allocate IO buffer */
  check_appendX();                     /* APPEND /X status, turn off if active */
  set_vectors();                       /* set vectors for Int 23h and 24h */

  /* do the BACKUP */
  do_backup();

  return (0);
}


/*********************************************************************/
/* Routine:   init                                                   */
/*                                                                   */
/* Function:  Preloads messages, checks the DOS version, and         */
/*            initializes the data structures.                       */
/*********************************************************************/

void init()
{
/*
 *  Preload messages and check DOS version.
 */
  sysloadmsg(&inregs,&outregs);

  if (outregs.x.cflag & CARRY)         /* if there was an error */
  {
    sysdispmsg(&outregs, &outregs);    /* display error message */
    return_code = RETCODE_ERROR;       /* set the return code */
    terminate();                       /* terminate */
  }

/*
 *  Setup message subst list for message retriever.
 */
  sublist.sl_size1 = SUBLIST_SIZE;
  sublist.sl_size2 = SUBLIST_SIZE;
  sublist.one = 1;		 
  sublist.two = 2;		 
  sublist.zero1 = 0;		 
  sublist.zero2 = 0;		 

  ext_attrib_buff[0] = 0; 	 
  ext_attrib_buff[1] = 0; 	 

  date_buff.month = 0;		 
  date_buff.day	= 0;		 
  date_buff.year = 0;	 

  time_buff.hours = 0;	 
  time_buff.minutes = 0;	 
  time_buff.seconds = 0;	 
  time_buff.hundreds = 0;	 

  dta_addr = (struct FileFindBuf *)&dta;  /* get address of FindFile buffer */
}


/*********************************************************************/
/* Routine:   check_options_help                                     */
/*                                                                   */
/* Function:  Check the command line for /?.  The parser cannot      */
/*            be relied on for this, because main() first calls      */
/*            check_drive_validity, which will error out if two      */
/*            valid drive letters are not found in argv[].           */
/*                                                                   */
/*            If /? is found, call display_options_exit(), which     */
/*            will display the options help message, and then        */
/*            terminate the program.                                 */
/*********************************************************************/

void check_options_help(int argc, char *argv[])
{
  /*
   *  Check every argument (except the first, which
   *  is "backup", looking for "/?".  If found,
   *  call off to display_options_exit().
   */
  for (argc--, argv++; argc; argc--, argv++)
  {
    if (argv[0][0] == '/' && argv[0][1] == '?' && argv[0][2] == '\0')
      display_options_exit();
  }
}


/*********************************************************************/
/* Routine:   parser                                                 */
/*                                                                   */
/* Function:  Parse the command line.                                */
/*********************************************************************/

void parser(int argc, char *argv[])
{
  char cmd_line[128];
  char not_finished = TRUE;
  int x;

  parse_init();                        /* initialize parser data structures */

  /* copy command line parameters to local area */
  cmd_line[0] = NUL;
  for (x = 1; x <= argc; x++)
  {
   strcat(cmd_line, argv[x]);
   if (x != argc)
     strcat(cmd_line, " ");
  }
  strcat(cmd_line, "\r");

  inregs.x.si = (WORD)&cmd_line[0];    /* ds:si points to cmd line */

  while (not_finished)                 /* for all strings in command line */
  {
    inregs.x.dx = 0;                   /* reserved */
    inregs.x.di = (WORD)&parms;        /* es:di -> address of parm list */
    parse(&inregs, &outregs);          /* call DOS SYSPARSE service routines */

    x = 0;                             /* save parsed parameter */
    for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
    {
      curr_parm[x] = *(char *)inregs.x.si;
      x++;
    }
    curr_parm[x] = NUL;

    inregs = outregs;                  /* reset registers */
    if (outregs.x.ax != (WORD)NOERROR)
    {
      if (outregs.x.ax != (WORD)EOL)
        parse_error(outregs.x.ax, outregs.x.dx);
      not_finished = FALSE;
    }

    if (not_finished)                  /* if there was not an error */
    {
      if (outregs.x.dx == (WORD)&sw_buff)
        process_switch();              /* it's a switch */

      if (outregs.x.dx == (WORD)&time_buff)
      {                                /* it's a TIME parameter */
        if (do_time)
          parse_error(outregs.x.ax, outregs.x.dx);

        check_time(time_buff.hours, time_buff.minutes, time_buff.seconds,
                   time_buff.hundreds);

        /* See "NOTE FROM PARSER SUBROUTINE" in backup.h */
        time_buff.seconds = time_buff.seconds / 2;

        /* TIME bit format hhhhhmmmmmmxxxxx */
        user_specified_time = (time_buff.hours * 0x800) +
                              (time_buff.minutes * 32) + time_buff.seconds;
      }

      if (outregs.x.dx == (WORD)&date_buff)
      {
        if (do_date)
          parse_error(outregs.x.ax, outregs.x.dx);

        check_date(date_buff.year, date_buff.month, date_buff.day);

        /* DATE bit format yyyyyyymmmmddddd */
        user_specified_date = ((date_buff.year - 1980) * 512) +
                              (date_buff.month * 32) + (date_buff.day);
      }
    }
  }
  check_for_device_names(argv);
}


/*********************************************************************/
/* Routine:   parse_error                                            */
/*                                                                   */
/* Function:  There was a parse error.  Display appropriate          */
/*            error message and terminate.                           */
/*********************************************************************/

void parse_error(WORD ax, WORD dx)
{
  sublist.value1 = &curr_parm[0];
  sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
  sublist.pad_char1 = ' ';
  sublist.one = 0;
  sublist.max_width1 = (BYTE)strlen(curr_parm);
  sublist.min_width1 = sublist.max_width1;

  if (dx == (WORD)&time_buff)
    display_it(INV_TIME, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
  else
  {
    if (dx == (WORD)&date_buff)
      display_it(INV_DATE, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
    else
      display_it (ax, STDERR, 1, NOWAIT, (BYTE)PARSEERROR);
  }
  return_code = RETCODE_ERROR;
  clean_up_and_exit();
}


/*********************************************************************/
/* Routine:   check_date                                             */
/*                                                                   */
/* Function:  A date parameter was entered. Validate it.             */
/*********************************************************************/

void check_date(WORD year, BYTE month, BYTE day)	
{
  if (year > 2099 || year < 1980)
    error_exit(INV_DATE);

  if (month > 12 || month < 1)
    error_exit(INV_DATE);

  if (day > 31 || day  < 1)
    error_exit(INV_DATE);

  /* Verify day not greater then 30 if Apr, Jun, Sep, Nov */
  if ((day > 30) && (month == 4 || month == 6 || month == 9 || month == 11))
    error_exit(INV_DATE);

  if (month == 2)                      /* deal with February */
  {
    if (day >  29)                     /* if Feb 30 or above */
      error_exit(INV_DATE);            /*   then Bad Date */

    if ((year % 4) != 0)               /* if not a leap year */
      if (day >	28)                    /*   if Feb 29 or above */
        error_exit(INV_DATE);          /*     then Bad Date */
  }

  do_date = TRUE;
}


/*********************************************************************/
/* Routine:   check_time                                             */
/*                                                                   */
/* Function:  A time parameter was entered. Validate it.             */
/*********************************************************************/

void check_time(BYTE hours, BYTE minutes, BYTE seconds, BYTE hundreds)
{
  if (hours > 23 || hours < 0)
    error_exit(INV_TIME);

  if (minutes >= 60 || minutes < 0)
    error_exit(INV_TIME);

  if (seconds >= 60 || seconds < 0)
    error_exit(INV_TIME);

  if (hundreds > 99 || hundreds < 0)
    error_exit(INV_TIME);

  do_time = TRUE;
}


/*********************************************************************/
/* Routine:   parse_init                                             */
/*                                                                   */
/* Function:  Initialize the parser data structures.                 */
/*********************************************************************/

void parse_init()
{
  /* Initialize PARMS data structure */
  parms.parmsx_ptr = (WORD)&parmsx;
  parms.p_num_extra = 1;
  parms.p_len_extra_delim = 1;
  parms.p_extra_delim[0] = ';';
  parms.p_extra_delim[1] = NUL;

  /* Initialize PARMSX data structure */
  parmsx.p_minpos = 2;
  parmsx.p_maxpos = 2;
  parmsx.pos1_ptr = (WORD)&pos1;
  parmsx.pos2_ptr = (WORD)&pos2;
  parmsx.num_sw  = 7;
  parmsx.sw1_ptr = (WORD)&sw1;
  parmsx.sw2_ptr = (WORD)&sw2;
  parmsx.sw3_ptr = (WORD)&sw3;
  parmsx.sw4_ptr = (WORD)&sw4;
  parmsx.sw5_ptr = (WORD)&sw5;
  parmsx.sw6_ptr = (WORD)&sw6;
  parmsx.sw7_ptr = (WORD)&sw7;
  parmsx.num_keywords = 0;

  /* Initialize POS1 data structure */
  pos1.match_flag = FILESPEC;
  pos1.function_flag = 0;
  pos1.result_buf = (WORD)&pos_buff;
  pos1.value_list = (WORD)&noval;
  pos1.nid = 0;

  /* Initialize POS2 data structure */
  pos2.match_flag = DRIVELETTER;
  pos2.function_flag = 0;
  pos2.result_buf = (WORD)&pos_buff;
  pos2.value_list = (WORD)&noval;
  pos2.nid = 0;

  /* Initialize SW1 data structure */
  sw1.p_match_flag = 0;
  sw1.p_function_flag = 0;
  sw1.p_result_buf = (WORD)&sw_buff;
  sw1.p_value_list = (WORD)&noval;
  sw1.p_nid = 4;
  strcpy(sw1.switch1, "/S");
  strcpy(sw1.switch2, "/M");
  strcpy(sw1.switch3, "/A");

  /* Initialize SW2 data structure */
  sw2.p_match_flag = DATESTRING;
  sw2.p_function_flag = 0;
  sw2.p_result_buf = (WORD)&date_buff;
  sw2.p_value_list = (WORD)&noval;
  sw2.p_nid = 1;
  strcpy(sw2.switch1, "/D");

  /* Initialize SW3 data structure */
  sw3.p_match_flag = TIMESTRING;
  sw3.p_function_flag = 0;
  sw3.p_result_buf = (WORD)&time_buff;
  sw3.p_value_list = (WORD)&noval;
  sw3.p_nid = 1;
  strcpy(sw3.switch1, "/T");

  /* Initialize SW4 data structure */
  sw4.p_match_flag = SSTRING + OPTIONAL;
  sw4.p_function_flag = CAP_FILETABLE;
  sw4.p_result_buf = (WORD)&sw_buff;
  sw4.p_value_list = (WORD)&noval;
  sw4.p_nid = 1;
  strcpy(sw4.switch1, "/L");

  /* Initialize SW5 data structure */
  sw5.p_match_flag = SSTRING + OPTIONAL;
  sw5.p_function_flag = CAP_CHARTABLE;
  sw5.p_result_buf = (WORD)&sw_buff;
  sw5.p_value_list = (WORD)&value_list;
  sw5.p_nid = 1;
  strcpy(sw5.switch1, "/F");

  /* Initialize SW6 data structure */
  sw6.p_match_flag = 0;
  sw6.p_function_flag = 0;
  sw6.p_result_buf = (WORD)&sw_buff;	
  sw6.p_value_list = (WORD)&noval;
  sw6.p_nid = 1;		
  strcpy(sw6.switch1, "/HD");          /* high density floppies */

  /* Initialize SW7 data structure */
  sw7.p_match_flag = 0;
  sw7.p_function_flag = 0;
  sw7.p_result_buf = (WORD)&sw_buff;
  sw7.p_value_list = (WORD)&noval;
  sw7.p_nid = 1;
  strcpy(sw7.switch7, "/?");           /* /? options help */

  /* Initialize value list data structure */
  value_list.nval = 3;
  value_list.num_ranges = 0;
  value_list.num_choices = 0;
  value_list.num_strings = 33;                             /* M007 */
  value_list.val01 = (WORD)&value_table.val01[0];
  value_list.val02 = (WORD)&value_table.val02[0];
  value_list.val03 = (WORD)&value_table.val03[0];
  value_list.val04 = (WORD)&value_table.val04[0];
  value_list.val05 = (WORD)&value_table.val05[0];
  value_list.val06 = (WORD)&value_table.val06[0];
  value_list.val07 = (WORD)&value_table.val07[0];
  value_list.val08 = (WORD)&value_table.val08[0];
  value_list.val09 = (WORD)&value_table.val09[0];
  value_list.val10 = (WORD)&value_table.val10[0];
  value_list.val11 = (WORD)&value_table.val11[0];
  value_list.val12 = (WORD)&value_table.val12[0];
  value_list.val13 = (WORD)&value_table.val13[0];
  value_list.val14 = (WORD)&value_table.val14[0];
  value_list.val15 = (WORD)&value_table.val15[0];
  value_list.val16 = (WORD)&value_table.val16[0];
  value_list.val17 = (WORD)&value_table.val17[0];
  value_list.val18 = (WORD)&value_table.val18[0];
  value_list.val19 = (WORD)&value_table.val19[0];
  value_list.val20 = (WORD)&value_table.val20[0];
  value_list.val21 = (WORD)&value_table.val21[0];
  value_list.val22 = (WORD)&value_table.val22[0];
  value_list.val23 = (WORD)&value_table.val23[0];
  value_list.val24 = (WORD)&value_table.val24[0];
  value_list.val25 = (WORD)&value_table.val25[0];
  value_list.val26 = (WORD)&value_table.val26[0];
  value_list.val27 = (WORD)&value_table.val27[0];
  value_list.val28 = (WORD)&value_table.val28[0];          /* M007 Start */
  value_list.val29 = (WORD)&value_table.val29[0];
  value_list.val30 = (WORD)&value_table.val30[0];
  value_list.val31 = (WORD)&value_table.val31[0];
  value_list.val32 = (WORD)&value_table.val32[0];
  value_list.val33 = (WORD)&value_table.val33[0];          /* M007 End */

  /* Initialize FORMAT value table */
  strcpy(value_table.val01, "160");    
  strcpy(value_table.val02, "160K");   
  strcpy(value_table.val03, "160KB");  
  strcpy(value_table.val04, "180");    
  strcpy(value_table.val05, "180K");   
  strcpy(value_table.val06, "180KB");  
  strcpy(value_table.val07, "320");    
  strcpy(value_table.val08, "320K");   
  strcpy(value_table.val09, "320KB");  
  strcpy(value_table.val10, "360");    
  strcpy(value_table.val11, "360K");   
  strcpy(value_table.val12, "360KB");  
  strcpy(value_table.val13, "720");    
  strcpy(value_table.val14, "720K");   
  strcpy(value_table.val15, "720KB");  
  strcpy(value_table.val16, "1200");   
  strcpy(value_table.val17, "1200K");  
  strcpy(value_table.val18, "1200KB"); 
  strcpy(value_table.val19, "1.2");    
  strcpy(value_table.val20, "1.2M");
  strcpy(value_table.val21, "1.2MB");
  strcpy(value_table.val22, "1440");
  strcpy(value_table.val23, "1440K");
  strcpy(value_table.val24, "1440KB");
  strcpy(value_table.val25, "1.44");
  strcpy(value_table.val26, "1.44M");
  strcpy(value_table.val27, "1.44MB");
  strcpy(value_table.val28, "2880");                       /* M007 Start */
  strcpy(value_table.val29, "2880K");
  strcpy(value_table.val30, "2880KB");
  strcpy(value_table.val31, "2.88");
  strcpy(value_table.val32, "2.88M");
  strcpy(value_table.val33, "2.88MB");                     /* M007 End */
}


/*********************************************************************/
/* Routine:   find_format                                            */
/*                                                                   */
/* Function:  Search for the FORMAT utility.	If found, then       */
/*            build a full path to it from the root. If not          */
/*            found, tell the user and terminate.                    */
/*********************************************************************/

#define MAX_ENV_PATH	130

void find_format(int check_current)
{
  BYTE found_it = FALSE;
  BYTE no_more = FALSE;
  int findex, pindex;
  BYTE done = FALSE;
  char path[MAX_ENV_PATH];
  int path_len;                        /* length returned by get_path */

/*
 *  First try current directory.
 */
  if (check_current)
  {
    format_path[0] = '.';
    format_path[1] = NUL;

    /* Build full path */
    xlat(format_path, format_path);

    /* If at root, remove trailing backslash */
    if (strlen(format_path) == 3 && format_path[1] == ':')
      format_path[2] = NUL;

    strcat(format_path, "\\FORMAT.COM");

    /* Now look for it */
    if ( exist(format_path) )
    {
      found_it = TRUE;
      return;
    }
  }

  if (!((path_len = get_path(path, MAX_ENV_PATH)) == -1 || 
	path_len == 0 || path[0] == NUL))
  {
    pindex = 0;
    while (!found_it && path[pindex] != NUL)
    {
      for (findex = 0; path[pindex] != NUL && path[pindex] != ';'; pindex++)
      {
        format_path[findex] = path[pindex];
        findex++;
      }

      if (path[pindex]==';')
        pindex++;

      format_path[findex] = NUL;
      xlat(format_path, format_path);
      if (strlen(format_path) == 3 && format_path[1] == ':')
        format_path[2] = NUL;
      strcat(format_path, "\\FORMAT.COM");
      if ( exist(format_path) )
        found_it = TRUE;
    }
  }

  if (!found_it)
  {
    /*
     *  If FORMAT is not available in the current dir, in the PATH, then
     *  get it from Drive A . (loop here to get a floppy with FORMAT in it)
     */
    do
    {
      display_msg(CRLF);                         /* M011 */
      if (!do_format_parms)
        display_msg(DISK_UNFORMAT);              /* M011 */
      display_msg(NO_FORMAT_FND);                /* M011 */
      if (GetYesNo() == YES)                     /* M011 */
      {
        display_msg(CRLF);                       /* M011 */
        display_msg(INSERT_FORMAT);              /* M011 */
	need_to_swap_again = TRUE;
	strcpy(format_path, "A:\\FORMAT.COM");
	if (exist(format_path))
          found_it = TRUE;
      }
      else
      {
        display_msg(CRLF);                       /* M011 */
        error_exit(CANT_FIND_FORMAT);
      }
    } while (!found_it);
  }
}


/*********************************************************************/
/* Routine:   get_path                                               */
/*                                                                   */
/* Function:  Finds the environment pointer in the PSP, and          */
/*            searches the envirnment for a PATH statement.          */
/*            If found, copies it to the buffer address passed in.   */
/*                                                                   */
/*    Entry:  pointer to buffer, buffer length                       */
/*    Exit:   length of string, -1 if exceeded buffer length         */
/*********************************************************************/

int get_path(char *p, int length)
{
  char *env_ptr;
  int  path_len;

  env_ptr = getenv("PATH");

  /* check for length error */
  if ((path_len = strlen(env_ptr)) >= length)
    path_len = -1;
  else                            /* copy only if no length error */
    strcpy(p, env_ptr);

  return (path_len);
}


/*********************************************************************/
/* Routine:   xlat                                                   */
/*                                                                   */
/* Function:  Performs name translate function.  Calls DOS function  */
/*            call 60h to build full path from root using the "src"  */
/*            passed in, places resultant path at "tgt".             */
/*********************************************************************/

void xlat(char *tgt, char *src)					   
{
  union	REGS xregs;

  xregs.x.ax = 0x6000;                 /* Name Xlat */
  xregs.x.bx = 0;                      /* Drive */
  xregs.x.si = (WORD)src;              /* Source */
  xregs.x.di = (WORD)tgt;              /* Target */
  intdos(&xregs, &xregs);              /* Blammo! */
}


/*********************************************************************/
/* Routine:   check_drive_validity                                   */
/*                                                                   */
/* Function:  Verify that at least the target drive letter is        */
/*            is entered. Verify that they are valid drives.         */
/*********************************************************************/

void check_drive_validity(int argc, char *argv[])
{
  char *charptr;
  int i, j;
  char *t;
  BYTE specified_drive;

  if (argc < 2)
    error_exit(NO_SOURCE);

  /* First make sure drives (if any) precede options in argv */
  for (i = 1; ( (i < (argc - 1)) && (i <= 2)); i++)
  {
    for (j = i + 1; j < argc; j++)
    {
      if ( (*(argv[i]) == '/') && (*(argv[j]) != '/') )
      {
	charptr = argv[i];
	argv[i] = argv[j];
	argv[j] = charptr;
      }
    }
  }

  /*
   *  Verify the source.
   */
  *argv[1] = (BYTE)com_toupper(*argv[1]);
  t = argv[1];
  t++;
  if (*t == ':')                  /* check specified source drive */
  {
    if (*argv[1] < 'A')
      error_exit(INV_DRIVE);
    if (*argv[1] > 'Z')
      error_exit(INV_DRIVE);
    src_drive_letter = *argv[1];
  }                               /* use default drive for source */
  else
    src_drive_letter = (BYTE)def_drive + 'A' - 1;

  /*
   *  Verify the target.
   */
  if (argc < 3)
    error_exit(NO_TARGET);

  *argv[2] = (BYTE)com_toupper(*argv[2]);

  if (*argv[2] < 'A')
    error_exit(INV_DRIVE);
  if (*argv[2] > 'Z')
    error_exit(INV_DRIVE);

  /* Verify drive letter followed by ":" */
  t = argv[2];
  t++;
  if (*t != ':')
    error_exit(NO_TARGET);

  /* Make sure drive letters are different */
  if (src_drive_letter == *argv[2])
    error_exit(SRC_AND_TGT_SAME);

  /* Is source a valid drive? */
  specified_drive = src_drive_letter - 'A' + 1;
  set_default_drive(specified_drive);
  if (get_current_drive() != specified_drive)
    error_exit(INV_DRIVE);

  /* Is target a valid drive? */
  specified_drive = *argv[2] - 'A' + 1;
  set_default_drive(specified_drive);
  if (get_current_drive() != specified_drive)
    error_exit(INV_DRIVE);

  set_default_drive(def_drive);   /* reset default drive to original one */
  def_drive_set = FALSE;

  tgt_drive_letter = *argv[2];
}


/*********************************************************************/
/* Routine:   check_for_device_names                                 */
/*                                                                   */
/* Function:  Make sure the user is not trying to restore a reserved */
/*            device name.  Reserved device names are stored in an   */
/*            array called "device_names".                           */
/*********************************************************************/

void check_for_device_names(char *argv[])
{
  union REGS qregs;
  char target[128];
  char *t, *temp_ptr;
  int pathlen, i;

#define CAPITALIZE_STRING 0x6521

  /*
   *  Capitalize the given string for comparing against standard set of
   *  reserved device names.
   */
  qregs.x.ax = CAPITALIZE_STRING;
  qregs.x.dx = (WORD)argv[1];
  pathlen = strlen(argv[1]);
  qregs.x.cx = pathlen;
  intdos(&qregs, &qregs);	
  strcpy(target, argv[1]);

  /*
   *  None of the reserved device names are more than 5 characters;
   *  if (length of src file name <= 5 characters ) {
   *    compare the src file name as such against the std set of res.dev.names
   *  else {             // file name is more than 5 characters
   *    Find the last '\\' in the path name;
   *    if (no BACKSLASH) this CANNOT be a device name; (since name is >5 ch)
   *    if (comp after '\\' is more than 5 chars)
   *      then also it cannot be a device name
   *    else            /* upto 5 chars only in the last comp of name
   *      compare the last comp (after BACKSLASH) to std set of dev names
   */
  if (pathlen <= 5)
    t = &target[0];
  else
  {
    temp_ptr = com_strrchr(target, BACKSLASH);   /* DBCS ?? */
    if (temp_ptr == NUL)
      return;
    if ((target + pathlen - temp_ptr) > 6)
      return;
    else
      t = temp_ptr + 1;
  }

  for (i = 0; i < NOOFSTD_DEVICES; i++)
  {
    if (!strcmp(t, device_names[i]))
    {	
      /* supply args for the INVALID PARAM error below */
      sublist.value1 = (char far *)t;
      sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
      sublist.one = 0;
      sublist.max_width1 = (BYTE)strlen(t);
      sublist.min_width1 = sublist.max_width1;

      display_it (INVPARM, STDERR, 1, NOWAIT, (BYTE)PARSEERROR); 
      return_code = RETCODE_ERROR;
      clean_up_and_exit();              /* does not return */
    }
  }
}


/*********************************************************************/
/* Routine:   check_path_validity                                    */
/*                                                                   */
/* Function:  Verify that the path entered by the user exists.       */
/*            Build a full path from the root, place it in           */
/*            src_drive_path.  Extract filespec and place it         */
/*            in user_filespec.                                      */
/*********************************************************************/

void check_path_validity(char *argv[])
{
  WORD dhandle;
  char globals = FALSE;
  int x;
  char *foo, *foo2;
  union	REGS qregs;

  strcpy(src_drive_path_fn, argv[1]);  /* copy argv[1] to string area */

  for (x = 0; x < strlen(src_drive_path_fn); x++)
  {
    if (src_drive_path_fn[x] == BACKSLASH)
      if (src_drive_path_fn[x+1] == BACKSLASH)
#ifdef DBCS
        if (!CheckDBCSTailByte(src_drive_path_fn, &src_drive_path_fn[x]))
#endif
        error_exit(INV_PATH);
  }

  if (strlen(src_drive_path_fn) == 1)
  {
    if (*src_drive_path_fn == '.')            
      strcpy(src_drive_path_fn, "*.*");
  }

  if (strlen(src_drive_path_fn) == 2)  /* if only drive entered, make it d:*.* */
  {
    if (src_drive_path_fn[1] == ':')
      strcat(src_drive_path_fn, "*.*");
  }

  if (src_drive_path_fn[strlen(src_drive_path_fn)-1] == BACKSLASH)
  {
#ifdef DBCS
    if (!CheckDBCSTailByte(src_drive_path_fn,
                           &src_drive_path_fn[strlen(src_drive_path_fn)-1]))
#endif
    strcat(src_drive_path_fn, "*.*");
  }

  xlat(src_drive_path_fn, src_drive_path_fn);

  /* Handle UNC format  ( \\srv\name\path\path\file ) (Remote drive) */
  if (src_drive_path_fn[0] == BACKSLASH)
  {
    if (src_drive_path_fn[1] == BACKSLASH)
    {
      foo = strchr(src_drive_path_fn+3, BACKSLASH);
      if (foo == NUL)
        error_exit(INV_PATH);

      foo2 = foo + 1;
      foo = strchr(foo2, BACKSLASH);
      if (foo == NUL)
        error_exit(INV_PATH);

      sprintf(src_drive_path_fn, "%c:%s", src_drive_letter, foo);
    }
  }

  /* See if there are global characters specified */
  if (com_strchr(src_drive_path_fn, '?') != NUL)
    globals = TRUE;
  else
    if (com_strchr(src_drive_path_fn, '*') != NUL)
      globals = TRUE;

  if (src_drive_path_fn[3] == BACKSLASH)     /*	don't let user enter d:\\ */
  {
    if (src_drive_path_fn[2] == BACKSLASH)
#ifdef DBCS
      if (!CheckDBCSTailByte(src_drive_path_fn, &src_drive_path_fn[2]))
#endif
      error_exit(INV_PATH);
  }

  if (source_removable)                /* if backing up from a diskette */
    display_msg(INSERTSOURCE);         /* ask user for disk, wait for input */

  /*
   *  If single drive system, this eliminates double prompting
   *  for user to "Insert diskette for drive %1".
   */
  qregs.x.ax = SETLOGICALDRIVE;
  qregs.h.bl = src_drive_letter - 'A' + 1;
  intdos(&qregs, &qregs);

  /* Check for Invalid Path and figure out if it is a file or directory */
  find_first(&src_drive_path_fn[0], &dhandle, dta_addr,
             (SUBDIR + SYSTEM + HIDDEN));

  if (rc != NOERROR)                   /* if there was an error */
  {
    if (rc == 3)                       /*   if it was Path Not Found */
      error_exit(INV_PATH);            /*     Terminate */
    /*
     *  M008 -
     *  Do NOT quit out of the backup for any other error code.  Since
     *  this routine does NOT check for the /s option, quitting out
     *  here is premature if the "filename" does not exist in the
     *  current directory.  If the file does not exist in any of the
     *  subdirectories either, this error will be caught later on in 
     *  the do_backup routine (after it calls the routine find_first_file).
     */
  }
  else
    findclose(dhandle);

  /* 
   *  Look for installed device names.  These names are also not allowed
   *  as BACKUP source file names.
   */
  if (dta.attributes & DEVICEATT)      /* is this a device ? */
  {
    /* set the sublist vars for INVPARM message properly */
    sublist.value1 = (char far *)&src_drive_path_fn[0];  
    sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;    
    sublist.one = 0;				      
    sublist.max_width1 = (BYTE)strlen(src_drive_path_fn);
    sublist.min_width1 = sublist.max_width1;	     
    error_exit(INVPARM);	/* if device, quit backup */
  }

  if ((dta.attributes & SUBDIR) == SUBDIR)  /* if subdirectory name, */
  {
    if (dta.file_name[0] != '.')            /* add to the end of it "\*.*" */
    {
      if (!globals)                         /* only if no global chars */
        strcat(src_drive_path_fn, "\\*.*");
    }
  }

  /*
   *  Build src_drive_FN.
   */
  strcpy(src_drive_path, src_drive_path_fn);

  /* Remove last BACKSLASH to get the pathname */
  foo = com_strrchr(src_drive_path, BACKSLASH);

  if (foo != NUL)
  {
    if ((foo - src_drive_path) > 2)
      *foo = NUL;
    else
    {                             /* foo must = 2 */
      foo++;
      *foo = NUL;
    }
  }

  /*
   *  Build src_fn.
   */
  foo = com_strrchr(src_drive_path_fn, BACKSLASH);
  if (foo == NUL)
    foo = &src_drive_path_fn[2];
  else
    foo++;                        /* skip over last non-DBCS char */
  strcpy(src_fn, foo);

  got_path_validity = TRUE;
}


/*********************************************************************/
/* Routine:   alloc_buffers                                          */
/*                                                                   */
/* Function:  Attempt to allocate a (64k-1) buffer. If               */
/*            fails, decrement buff size by 512 and keep             */
/*            trying. If can't get at least a 2k buffer,             */
/*            give up.                                               */
/*********************************************************************/

void alloc_buffer()
{
  alloc_seg();

  while ((rc != NOERROR) && (data_file_alloc_size > 2048))
  {
    data_file_alloc_size = data_file_alloc_size - 512;
    alloc_seg();
  }

  if (rc == NOERROR  &&  data_file_alloc_size > 2048)
    buffers_allocated = TRUE;
  else
    error_exit(INSUFF_MEMORY);
}


/*********************************************************************/
/* Routine:   process_switch                                         */
/*                                                                   */
/* Function:  Identify the parameter and set program control         */
/*            flags as appropriate.                                  */
/*********************************************************************/

void process_switch()
{
  char far *y;
  int i = 0;
  char temp_str[PATHLEN+20];

  /*
   *  If there's a /? switch,
   *  display the options help and exit.
   */
  if (sw_buff.sw_synonym_ptr == (WORD)&sw7.switch7[0])
    display_options_exit();

  if (sw_buff.sw_synonym_ptr == (WORD)&sw1.switch1[0])     /* /S */
    do_subdirs = TRUE;

  if (sw_buff.sw_synonym_ptr == (WORD)&sw5.switch1[0])    /* /F */
  {
    if (!target_removable)
      error_exit(CANT_FORMAT_HARDFILE);

    do_format_parms = TRUE;
    format_size[0] = ' ';            /* can't do strcpy during parse */
    format_size[1] = '/';
    format_size[2] = 'F';
    format_size[3] = ':';
    format_size[4] = NUL;

    i = 4;                           /* copy size */
    for (y = (char *)sw_buff.sw_string_ptr; *y != NUL; y++)
    {
      format_size[i] = (BYTE)*y;
      i++;
    }

    /* Handle case where user only enters /F */
    if (format_size[4] == NUL	|| format_size[4] < '0' || format_size[4] > '9')
      format_size[0] = NUL;
  }

  if (sw_buff.sw_synonym_ptr == (WORD)&sw1.switch2[0])   /* /M */
    do_modified = TRUE;

  if (sw_buff.sw_synonym_ptr == (WORD)&sw1.switch3[0])   /* /A */
    do_add = TRUE;

  if (sw_buff.sw_synonym_ptr == (WORD)&sw4.switch1[0])   /* /L */
  {
    do_logfile = TRUE;
    i = 0;                           /* copy filespec */
    for (y = (char far *)sw_buff.sw_string_ptr; *y != NUL; y++)
    {
      temp_str[i] = (BYTE)*y;
      i++;
    }
    temp_str[i] = NUL;

    if (strlen(temp_str) == 0)       /* use default logfile? */
      sprintf(temp_str, "%c:\\BACKUP.LOG", src_drive_letter);

    xlat(logfile_path, temp_str);

    if ((BYTE)logfile_path[0] == tgt_drive_letter)
      logfile_on_target = TRUE;
  }
}


/*********************************************************************/
/* Routine:   save_current_dirs                                      */
/*                                                                   */
/* Function:  Save the current directory on default drive.           */
/*            Later when we terminate we must restore it.            */
/*********************************************************************/

void save_current_dirs()
{
  src_def_dir[0] = BACKSLASH;
  get_current_dir(src_drive_letter -'A' + 1, &src_def_dir[1]);
}


/*********************************************************************/
/* Routine:   open_logfile                                           */
/*                                                                   */
/* Function:  User specified the /L parameter for a BACKUP           */
/*            log file. First try to open it. If it doesn't          */
/*            exist then create it.                                  */
/*********************************************************************/

void open_logfile()
{
  handle_logfile = extended_open(OPEN_IT, 0, (char far *)logfile_path,
                                 (WORD)(DENYWRITE+WRITEACCESS));
  if (rc == NOERROR)
    lseek(handle_logfile, EOFILE, (DWORD)0);
  else                                 /* create the file */
     handle_logfile = extended_open(CREATE_IT, (WORD)ARCHIVE,
                                    (char far *)logfile_path,
                                    (WORD)(WRITEACCESS));

  if (rc != NOERROR)                   /* terminate if can't open logfile */
    error_exit(CANT_OPEN_LOGFILE);

  display_msg(LOGGING);                /* tell user where we are logging */
  datetime();                          /* put date and time of BACKUP in logfile */

  logfile_opened = TRUE;               /* logfile is open */
}


/*********************************************************************/
/* Routine:   set_vectors                                            */
/*                                                                   */
/* Function:  Hook control break and critical vector to              */
/*            allow BACKUP to gracefully terminate.                  */
/*********************************************************************/

void set_vectors()
{
  #define  NULL 0

  setsignal(ACTIONHOOK, CTRLC);        /* handle CTRL_C */
  setsignal(ACTIONHOOK, CTRLBREAK);    /* handle CTRL_BREAK */
  (void)set_int24_vector(NULL);        /* set critical error vector (int 24h) */
}


/*********************************************************************/
/* Routine:   check_appendX                                          */
/*                                                                   */
/* Function:  Check APPEND /X status.  If it is not active,          */
/*            do nothing. If it is active, then turn it off          */
/*            and set flag indicating that we must reset it later.   */
/*********************************************************************/

void check_appendX()
{
  union REGS gregs;                    /* register set */

  gregs.x.ax = INSTALL_CHECK;          /* get installed state */
  int86(0x2f, &gregs, &gregs);

  /*
   *  1) See if append is active
   *  2) If so, figure out if DOS or PCNET version
   */
  if (gregs.h.al == 0)                 /* zero if not installed */
    append_indicator = NOT_INSTALLED;
  else                                 /* see which APPEND it is */
  {
    gregs.x.ax = GET_APPEND_VER;
    int86(0x2f, &gregs, &gregs);

    if (gregs.h.al == (BYTE)-1)        /* -1 if DOS version */
      append_indicator = DOS_APPEND;
    else
      append_indicator = NET_APPEND;
  }

  /*
   *  If it is the DOS append
   *    1) Get the current append functions (returned in BX)
   *    2) Reset append with /X support off
   */
  if (append_indicator == DOS_APPEND)
  {
    gregs.x.ax = GET_STATE;            /* get active APPEND functions */
    int86(0x2f, &gregs, &gregs);
    original_append_func = gregs.x.bx;

    gregs.x.ax = SET_STATE;
    gregs.x.bx = gregs.x.bx & (!APPEND_X_BIT);
    int86(0x2f, &gregs, &gregs);
  }
}


/*********************************************************************/
/* Routine:   get_drive_types                                        */
/*                                                                   */
/* Function:  For the source and target drives, figure out           */
/*            if they are removable or not.                          */
/*********************************************************************/

void get_drive_types()
{
  #define REMOVABLE 0

  WORD drivehandle;
  char drive_spec[3];

  /*
   *  Check Source drive.
   */
  drive_spec[0] = src_drive_letter;
  drive_spec[1] = ':';
  drive_spec[2] = NUL;

  /* Device open, source drive */
  drivehandle = handle_open(drive_spec, OPENDASD + DENYNONE);

  /* Now see if it is removable */
  if (ioctl(drivehandle) == REMOVABLE)
    source_removable = TRUE;
  else
    source_removable = FALSE;

  close_file(drivehandle);

  /*
   *  Check Target drive.
   */
  drive_spec[0] = tgt_drive_letter;
  drive_spec[1] = ':';
  drive_spec[2] = NUL;

  drivehandle = handle_open(drive_spec, OPENDASD + DENYNONE);

  if (ioctl(drivehandle) == REMOVABLE)
    target_removable = TRUE;
  else
    target_removable = FALSE;

  close_file(drivehandle);
}


/*********************************************************************/
/* Routine:   do_backup                                              */
/*                                                                   */
/* Function:  BACKUP all files that should be backed up.             */
/*********************************************************************/

void do_backup()
{
  set_default_dir();              /* set default dir to where source files are */

  find_first_file();              /* find first file to be backed up */
  if (back_it_up)                 /* if found one.... */
  {
    get_first_target();           /* get first disk (or last if /A specified) */
    check_asj();                  /* now safe to check assignd, subst */
    do
    {
      open_source_file();         /* open the file we found */
      if (source_opened)          /* if succeessful open of source */
        do_copy();                /* copy to target, handle files that span disks. */
      find_next_file();           /* search for another file */
    } while (back_it_up);         /* while there are files to back up */
    display_msg(CRLF);
  }
  else                            /* no files found */
  {
    display_msg(NONEFNDMSG);
    return_code = RETCODE_NO_FILES;    /* no files to be backed up */
  }

  clean_up_and_exit();
}


/*********************************************************************/
/* Routine:   find_first_file                                        */
/*                                                                   */
/* Function:  Find the first file conforming to user entered spec.   */
/*            If necessary, look on other directory levels also.     */
/*********************************************************************/

void find_first_file()
{
  char loop_done = FALSE;

  back_it_up = FALSE;             /* have not found a file yet ! */
  find_the_first();               /* sets the "found_a_file" flag */

  if (found_a_file)               /* if found a file */
  {
    do
    {
      if (found_a_file)           /* if you got one, then */
        see_if_it_should_be_backed_up();  /* check against entered params */

      if (!back_it_up)            /* if it shouldn't be processed... */
        find_the_next();          /* find another (sets "found_a_file" flag) */
      else
        loop_done = TRUE;         /* otherwise done */

      if (!found_a_file)          /* Don't remove this ! */
        loop_done = TRUE;         /* This has gotta stay ! */
    } while (!loop_done);
  }
}


/*********************************************************************/
/* Routine:   find_next_file                                         */
/*                                                                   */
/* Function:  Find the next file conforming to user entered spec.    */
/*********************************************************************/

void find_next_file()
{
  char loop_done = FALSE;

  back_it_up = FALSE;
  do
  {
    find_the_next();
    if (found_a_file)
    {
      see_if_it_should_be_backed_up();
      if (back_it_up)
        loop_done = TRUE;
    }
    else
      loop_done = TRUE;
  } while (!loop_done);
}


/*********************************************************************/
/* Routine:   find_the_first                                         */
/*                                                                   */
/* Function:  Find the first file conforming to user entered spec.   */
/*            Searches in current directory, if one not found then   */
/*            goes to the next level and repeats.                    */
/*********************************************************************/

void find_the_first()
{
  char loop_done = FALSE;
  char file_spec[PATHLEN];

  found_a_file = FALSE;
  sprintf(file_spec, "%c:%s", src_drive_letter, src_fn);

  do
  {
    /* Find file conforming to user-entered file spec */
    find_first(&file_spec[0], &dirhandle, dta_addr, (SYSTEM + HIDDEN));
    if (rc == NOERROR)
    {                             /* if no error */
      found_a_file = TRUE;        /* then we found a file */
      loop_done = TRUE;           /* and we are done here */
    }
    else                          /* if there was an error */
    {
      if (do_subdirs)             /* and if user said /S  */
      {
  	change_levels();          /* change DIR (sets "new_directory") */
  	if (!new_directory)       /* if there aren't any */
  	  loop_done = TRUE;       /* then were done */
      }
      else
        loop_done = TRUE;
    }
  } while (!loop_done);
}


/*********************************************************************/
/* Routine:   find_the_next                                          */
/*                                                                   */
/* Function:  Find the next file conforming to user entered spec.    */
/*********************************************************************/

void find_the_next()
{
  char loop_done = FALSE;

  found_a_file = FALSE;

  find_next(dirhandle, dta_addr);
  if (rc == NOERROR)
  {
    found_a_file = TRUE;
    loop_done = TRUE;
  }
  else
  {
    do
    {
      if (do_subdirs)
      {
        change_levels();               /* change DIR to next dir level */
  	if (!new_directory)            /* if we were successful */
  	  loop_done = TRUE;            /* then indicate that fact */
  	else                           /* otherwise */
  	{
  	  find_the_first();            /* look for first file at this level */
  	  loop_done = TRUE;
  	}
      }
      else
        loop_done = TRUE;
    } while (!loop_done);
  }
}


/*********************************************************************/
/* Routine:   change_levels                                          */
/*                                                                   */
/* Function:  Change directory to next one in the linked list        */
/*            of directories to be processed.                        */
/*********************************************************************/

void change_levels()
{
  new_directory = FALSE;
  remove_node();
}


/*********************************************************************/
/* Routine:   alloc_node                                             */
/*                                                                   */
/* Function:  Allocates a node for the linked list of subdirectories */
/*            to be processed.                                       */
/*********************************************************************/

struct node * alloc_node(unsigned int path_len)
{
  struct node *pointer;
  unsigned int malloc_size;

  malloc_size = (unsigned int) (sizeof(struct node far *) + path_len + 2);

#if defined(DEBUG)
  printf("\nMALLOCING NODE, SIZE=%04Xh...", malloc_size);
#endif

  pointer = (struct node *)malloc(malloc_size);

#if defined(DEBUG)
  if (pointer != NUL)
    printf("SUCCESSFUL, PTR=%u", (unsigned)pointer);
  else
    printf("ERROR, PTR=%u", (unsigned)pointer);
#endif

  if (pointer == NUL)
    error_exit(INSUFF_MEMORY);
  else
    return (pointer);
}


/*********************************************************************/
/* Routine:   alloc_first_node                                       */
/*                                                                   */
/* Function:  Allocate the first node in the linked list.            */
/*********************************************************************/

void alloc_first_node()
{
#if defined(DEBUG)
  printf("\nINSERTING FIRST NODE=%s", src_drive_path);
#endif

  curr_node = alloc_node(strlen(src_drive_path + 1));
  last_child = curr_node;
  strcpy(curr_node->path, src_drive_path);
  curr_node->np = NUL;
}


/*********************************************************************/
/* Routine:   insert_node                                            */
/*                                                                   */
/* Function:  Insert next node in the linked list of subdirectories  */
/*            to be processed.                                       */
/*********************************************************************/

void insert_node(char *path_addr)
{
  struct node *temp;              /* temporary pointer to a node */
  struct node *newnode;           /* same thing */

#if defined(DEBUG)
  printf("\nINSERTING NODE=%s", *path_addr);
#endif

  temp = last_child->np;
  newnode = alloc_node(strlen(path_addr));
  last_child->np = newnode;
  newnode->np = temp;
  strcpy(newnode->path, path_addr);
  last_child = newnode;
}


/*********************************************************************/
/* Routine:   remove_node                                            */
/*                                                                   */
/* Function:  CHDIR to the next level to be processed.               */
/*            Release the node for that directory.                   */
/*********************************************************************/

void remove_node()
{
  struct node *temp;

  temp = curr_node;
  last_child = curr_node->np;
  if (curr_node->np != NUL)
  {
    rc = chdir(last_child->path);
    if (rc == NOERROR)
    {
      new_directory = TRUE;
      strcpy(src_drive_path, last_child->path);

#if defined(DEBUG)
      printf("\nFREE NODE %u", (unsigned)curr_node);
#endif

      free((char *)curr_node);
      curr_node = last_child;

      if (do_subdirs)                  /* place all subdirs in linked list */
        find_all_subdirs();
    }
  }
}


/*********************************************************************/
/* Routine:   find_all_subdirs                                       */
/*                                                                   */
/* Function:  User entered "/S" parameter. Search for all            */
/*            subdirectory entries at this level. Place              */
/*            them all in the linked list of directories to          */
/*            be processed.                                          */
/*********************************************************************/

void find_all_subdirs()
{
  WORD dhandle;
  char global[6];
  char full_path[PATHLEN+20];
  struct FileFindBuf tempdta;

  sprintf(global, "%c:*.*", src_drive_letter);

  /* Find all subdirectory entries in current directory. */
  find_first(&global[0], &dhandle, &tempdta, (SUBDIR + SYSTEM + HIDDEN));
  while (rc == NOERROR)
  {
    if ((tempdta.attributes & SUBDIR) == SUBDIR) /* if it's a subdirectory */
    {
      if (tempdta.file_name[0] != '.')           /* but not "." or ".." */
      {

#ifdef DBCS
        if (src_drive_path[strlen(src_drive_path) - 1] != BACKSLASH ||
            CheckDBCSTailByte(src_drive_path,
                              &src_drive_path[strlen(src_drive_path)-1]))
#else
        if (src_drive_path[strlen(src_drive_path) - 1] != BACKSLASH)
#endif

          sprintf(full_path, "%s\\%s", src_drive_path, tempdta.file_name);
        else
          sprintf(full_path, "%s%s",  src_drive_path, tempdta.file_name);

        insert_node((char *)full_path);     /* save it in the linked list */
      }
    }
    find_next(dhandle, &tempdta);
  }
}


/*********************************************************************/
/* Routine:   get_first_target                                       */
/*                                                                   */
/* Function:  We are ready for the target disk. If it is a           */
/*            diskette, ask user to put one in. Remember             */
/*            to correctly handle /A if user wants it.               */
/*********************************************************************/

void get_first_target()
{
  if (target_removable)
    get_diskette();
  else
    get_hardfile();

  if (do_logfile)
    open_logfile();               /* open or create logfile */

  if (!do_add)
    put_disk_header();
}


/*********************************************************************/
/* Routine:   get_next_target                                        */
/*                                                                   */
/* Function:  We are ready for the next target diskette.             */
/*            Ask user to insert it.  Format if required.            */
/*            Create files, reset variables.                         */
/*********************************************************************/

void get_next_target()
{
  doing_first_target = FALSE;
  files_backed_up = 0;
  display_msg(CRLF);

  get_diskette();                 /* get it */

  disk_full = FALSE;

  if (do_logfile)
  {
    if (logfile_on_target)        /* and if logfile on the target drive */
      open_logfile();             /* open or create it */
  }

  if (file_spans_target)
    show_path();             /* show full path from root to stdout and logfile */

  put_disk_header();
  put_new_fh();
}


/*********************************************************************/
/* Routine:   see_if_it_should_be_backed_up                          */
/*                                                                   */
/* Function:  We found a file, its directory information is          */
/*            at the DTA structure. Don't backup a subdirectory      */
/*            or volume label. If /M specified, only backup files    */
/*            with archive bit set. Don't BACKUP 0 length files.     */
/*            If /D: and/or /T: specified, only backup appropriate   */
/*            files.                                                 */
/*********************************************************************/

void see_if_it_should_be_backed_up()
{
  BYTE temp[PATHLEN+20];

  back_it_up = TRUE;

  if ((dta.attributes & SUBDIR) == SUBDIR)  /* is it a directory name ? */
    back_it_up = FALSE;                     /* don't want to back it up */

  if ((dta.attributes & VOLLABEL) == VOLLABEL) /* is it a volumelabel ? */
    back_it_up = FALSE;                        /* don't want to back it up */

  if (do_modified)                          /* check ARCHIVE bit */
  {
    if ((dta.attributes & ARCHIVE) != ARCHIVE)
      back_it_up = FALSE;
  }

  if (do_time)                              /* check TIME parameter */
  {
    if (do_date)
    {
      /*
       *  If date entered, only files modified after specified time
       *  AND ONTHE DATE ENTERED will be prodessed.  Files dated
       *  after that will ignore time parameter.
       */
      if (dta.write_date == user_specified_date)
  	if (dta.write_time < user_specified_time)
  	  back_it_up = FALSE;
    }
    else
    {
      /*
       *  If user entered time with NO DATE PARM, then
       *  files modified on or after specified time will
       *  be processed, regardless of date.
       */
      if (dta.write_time < user_specified_time)
        back_it_up = FALSE;
    }
  }

  if (do_date)                              /* check DATE parameter */
  {
    if (dta.write_date < user_specified_date)
      back_it_up = FALSE;
  }

#define SAME 0

  /*
   *  If we are processing the root directory and we are looking
   *  at any of these files, then do not back them up.
   */
  if (strcmp(src_drive_path + 2, "\\") == SAME)
  {
    if (strcmp(dta.file_name,"IBMBIO.COM")  == SAME ||
        strcmp(dta.file_name,"IBMDOS.COM")  == SAME ||
        strcmp(dta.file_name,"IO.SYS")      == SAME ||
        strcmp(dta.file_name,"MSDOS.SYS")   == SAME ||
        strcmp(dta.file_name,"COMMAND.COM") == SAME ||
        strcmp(dta.file_name,"CMD.EXE")     == SAME)
      back_it_up = FALSE;
  }
  
  if (do_logfile)
  {
    strcpy(temp, src_drive_path);

    if (strlen(temp) == 3)
      temp[2] = NUL;

    sprintf(temp, "%s\\%s", temp, dta.file_name);

    if (strcmp(logfile_path, temp) == SAME)
      back_it_up = FALSE;
  }
}


/*********************************************************************/
/* Routine:   get_diskette                                           */
/*                                                                   */
/* Function:  Get the diskette from user. If unformatted             */
/*            and user entered /F, then try to FORMAT it.            */
/*            Create target files on root of diskette.               */
/*********************************************************************/

void get_diskette()
{
  union REGS qregs;

  /* repeat until either create succeeds or user chooses to quit */
  while (TRUE)                           /* M009 */
  {
    /* repeat until either deletion succeeds or user chooses to quit */
    while (TRUE)                         /* M009 */
    {
      /* repeat until either format succeeds or user chooses to quit */
      while (TRUE)                       /* M005 */
      {
        if (!do_add)
        {
          display_msg(INSERTTARGET);
          display_msg(ERASEMSG);
        }
        else
        {
          if (doing_first_target)
            display_msg(LASTDISKMSG);
          else
          {
            display_msg(INSERTTARGET);
            display_msg(ERASEMSG);
          }
        }
    
        /*
         *  If single drive system, eliminates double prompting
         *  for user to "Insert diskette for drive %1".
         */
        qregs.x.ax = SETLOGICALDRIVE;
        qregs.h.bl = tgt_drive_letter - 'A' + 1;
        intdos(&qregs, &qregs);
    
        if (target_removable)
        {
          if (format_target())                   /* M005 Start */
          {
            /* error formatting - see if user wants to continue */
            display_msg(CONTINUE_NEW_DISK);      /* M011 */
            if (GetYesNo() == YES)               /* M011 */
            {
              /* user wants to continue */
              display_msg(CRLF);                 /* M011 */
              continue;                     /* try again */
            }
            else
            {
              /* user wants to quit */
              display_msg(CRLF);                 /* M011 */
              return_code = RETCODE_ERROR;
              clean_up_and_exit();       /* does not return */
            }
          }
          else
            break;                       /* format okay, so break */
        }
      }                                          /* M005 End */
    
      backup_started = TRUE;
    
      if (do_add)                        /* if adding files */
      {
        if (doing_first_target)          /* and if its the first target */
          check_last_target();           /* verify that its a valid one */
      }
    
      display_msg(BUDISKMSG);
      display_msg(SEQUENCEMSG);

      /* delete all files in target drive root */
      if (delete_files(ROOTDIR))                 /* M009 Start */
      {
        /* error deleting files - see if user wants to continue */
        display_msg(CONTINUE_NEW_DISK);          /* M011 */
        if (GetYesNo() == YES)                   /* M011 */
        {
          /* user wants to continue */
          display_msg(CRLF);                     /* M011 */
          continue;                      /* try again */
        }
        else
        {
          /* user wants to quit */
          display_msg(CRLF);                     /* M011 */
          return_code = RETCODE_ERROR;
          clean_up_and_exit();           /* does not return */
        }
      }
      else
        break;                           /* delete okay, so break */
    }

    /* create target files */
    if (create_target())
    {
      /* error creating files - see if user wants to continue */
      display_msg(CONTINUE_NEW_DISK);            /* M011 */
      if (GetYesNo() == YES)                     /* M011 */
      {
        /* user wants to continue */
        display_msg(CRLF);                       /* M011 */
        continue;                        /* try again */
      }
      else
      {
        /* user wants to quit */
        display_msg(CRLF);                       /* M011 */
        return_code = RETCODE_ERROR;
        clean_up_and_exit();             /* does not return */
      }
    }
    else
      break;                             /* create okay, so break */
  }                                              /* M009 End */
}


/*********************************************************************/
/* Routine:   get_hardfile                                           */
/*                                                                   */
/* Function:  Target is a hardfile. FORMATTING hardfile is           */
/*            not allowed by BACKUP.  Create target files            */
/*            in BACKUP directory of disk.                           */
/*********************************************************************/

void get_hardfile()
{
  char dirname[15];

  sprintf(dirname, "%c:\\BACKUP\\*.*", tgt_drive_letter);
  if ( exist(&dirname[0]) )
  {
    if (!do_add)
      display_msg(FERASEMSG);
    backup_started = TRUE;
    delete_files(BACKUPDIR);      /* delete \BACKUP\*.* of target drive if not do_add */
  }
  else
  {
    sprintf(dirname, "%c:\\BACKUP", tgt_drive_letter);
    mkdir(dirname);
  }

  display_msg(BUDISKMSG);
  if (create_target())                           /* M009 */
    error_exit(INVTARGET);                       /* M009 */
}


/*********************************************************************/
/* Routine:   check_last_target                                      */
/*                                                                   */
/* Function:  User entered /A parameter. Make sure that              */
/*            we are not adding to a BACKUP diskette created         */
/*            with the disgusting old BACKUP format.                 */
/*            Make sure there is a BACKUP.xxx and CONTROL.xxx        */
/*            file out there.  Make sure it was the last target      */
/*            and get the sequence number.                           */
/*********************************************************************/

void check_last_target()
{
  WORD dhandle;
  WORD bytes_read;
  BYTE flag;
  char path[25];
  struct FileFindBuf tempdta;

  if (target_removable)           /* make sure no old BACKUP on here */
    sprintf(path, "%c:\\BACKUPID.@@@", tgt_drive_letter);
  else
    sprintf(path, "%c:\\BACKUP\\BACKUPID.@@@", tgt_drive_letter);

  if ( exist(path) )
    error_exit(INVTARGET);

  if (target_removable)           /* build path to control file */
    sprintf(path, "%c:\\CONTROL.*", tgt_drive_letter);
  else
    sprintf(path, "%c:\\BACKUP\CONTROL.*", tgt_drive_letter);

  /* Find the control file */
  find_first(&path[0], &dhandle, &tempdta, (SYSTEM + HIDDEN));
  if (rc != NOERROR)              /* if got one, then close dirhandle */
    error_exit(NOTLASTMSG);       /* otherwise, terminate */
  findclose(dhandle);

  /* Add drive letter to control file name */
  sprintf(path, "%c:%s", tgt_drive_letter, tempdta.file_name);

  /* Open the control file */
  handle_control = extended_open(OPEN_IT, 0, (char far *)path,
                                 (WORD)(DENYWRITE + READACCESS));
  if (rc != NOERROR)              /* if can't open it, strange error */
    error_exit(NOTLASTMSG);

  /* Get diskette sequence number */
  lseek(handle_control, BOFILE, (DWORD)9);
  bytes_read = handle_read(handle_control, 1, (char far *)&diskettes_complete);
  diskettes_complete--;           /* this disk is no longer "complete" */

  /* Seek to DH_LastDisk and read that byte */
  lseek(handle_control, BOFILE, (DWORD)138);
  bytes_read = handle_read(handle_control, 1, (char far *)&flag);

  if (flag != LAST_TARGET)        /* if it wasn't last target, terminate */
    error_exit(NOTLASTMSG);

  close_file(handle_control);     /* close the control file */
  control_opened = FALSE;         /* and say it isn't open */
}


/*********************************************************************/
/* Routine:   format_target                                          */
/*                                                                   */
/* Function:  See if the target is formatted. If not, try            */
/*            to format it.                                          */
/*********************************************************************/

int format_target()
{
  char format_parms[35];

  if (do_add)                          /* if the /A was specified */
    if (doing_first_target)            /* if it's first BACKUP.XXX diskette */
      return (NOERROR);                /* return to calling procedure */

  /*
   *  See if diskette is unformatted
   */
  rc = NOERROR;
  check_unformatted();	               /* check disk, set rc accordingly */
  
  /* If hard error, then FORMAT the target */
  if (rc != NOERROR)
  {
    if (def_drive == (tgt_drive_letter - 'A' + 1))
      find_format(FALSE);              /* dont search unformatted disk */
    else
      find_format(TRUE);
    rc = 0xFFFF;                       /* f_f will have reset it to 0 */
    display_msg(CRLF);

    sprintf(format_parms, "%c:", tgt_drive_letter);

    if (do_format_parms)
    {
      if (format_size[0] != NUL)
        strcat(format_parms, format_size);
    }
    if (need_to_swap_again)
      strcat(format_parms, " /V:BACKUP");	
    else
      strcat(format_parms, " /BACKUP /V:BACKUP");   /* use secret switch */

    checking_target = TRUE;            /* set flag to indicate format */
    rc = (spawnlp(P_WAIT, format_path, "FORMAT", format_parms, NUL));  
    if (rc != NOERROR)
    {
      /*
       *  If FORMAT returns error it could only be one of the following:
       *      i)   User aborted format (ctrl-c)
       *      ii)  User gave negative response to prompt, "Proceed with
       *           format?"
       *      iii) User entered wrong /F: entry
       *  We take care of case 1 by looking for ctrl_break and aborting
       *    the backup.
       *  We take care of all other error conditions from format by
       *    displaying an error message and returning.
       */

      if (rc == RETCODE_CTL_BREAK)     /* user hit ctl-break during format */
        control_break_handler ();      /* call the control break routine */
      else
      {						   
        display_msg(ERR_EXEC_FORMAT);  /* "Error executing FORMAT" */
        display_msg(INVTARGET);        /* "Target cannot be used for backup" */
        return (rc);                   /* M005 */
      }
    }
    checking_target = FALSE;           /* all done formatting */
    display_msg (CRLF);                /* display carrige ret */
    return (NOERROR);                  /* return to calling proc */
  }
  return (NOERROR);                    /* M005 */
}


/*********************************************************************/
/* Routine:   check_unformatted                                      */
/*                                                                   */
/* Function:  Check if the target disk is unformatted.               */
/*                                                                   */
/*    Helper routine for format_target                               */
/*    No entry parameters.                                           */
/*    No return values, but global rc is set to NOERROR if target    */
/*      is formatted.                                                */
/*********************************************************************/

#define HOOK	0
#define UNHOOK	1

void check_unformatted()
{
  WORD temp_rc;                   /* saver for global return code */

  do_dos_error(HOOK);             /* replace hard error handler */
  rc = NOERROR;                   /* reset return code */

  /* If this generates a hard error, then format target */
  checking_target = TRUE;
  disk_free_space();
  checking_target = FALSE;

  temp_rc = rc;
  do_dos_error(UNHOOK);           /* unhook hard error handler */
  rc = temp_rc;
}


/*********************************************************************/
/* Routine:   set_default_dir                                        */
/*                                                                   */
/* Function:  Sets the default directory.                            */
/*********************************************************************/

void set_default_dir()
{
  /*
   *  If there IS a backslash and if length is greater than 3, 
   *  then change dir to there.
   */
  if (com_strchr(src_drive_path, BACKSLASH) != NUL)
  {
    if (strlen(src_drive_path) >= 3)
    {
      rc = chdir(src_drive_path);
      if (rc == NOERROR)
      {
        src_drive_path[2] = BACKSLASH;
        get_current_dir(src_drive_letter - 'A' + 1, &src_drive_path[3]);
      }
      else
        error_exit(INV_PATH);
    }
  }
  curr_dir_set = TRUE;

  if (do_subdirs)                 /* if processing subdirectories too, */
  {
    alloc_first_node();           /* put current level in linked list */
    find_all_subdirs();           /* get all directory entries in that level */
  }
}


/*********************************************************************/
/* Routine:   label_target_drive                                     */
/*                                                                   */
/* Function:  Create volume label BACKUP.xxx on target               */
/*            diskette drive.                                        */
/*********************************************************************/

void label_target_drive()
{
  char fsbuf[20];

  build_ext(diskettes_complete + 1);

  sprintf(fsbuf, "%c:BACKUP.%s", tgt_drive_letter, ext);

  replace_volume_label(&fsbuf[0]);
}


/*********************************************************************/
/* Routine:   build_ext                                              */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void build_ext(int num)
{
  if (num < 10)
    sprintf(ext, "00%u", num);
  else
  {
    if (num < 100)
      sprintf(ext, "0%u", num);
    else
      sprintf(ext, "%u", num);
  }
}


/*********************************************************************/
/* Routine:   create_target                                          */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

int create_target()                              /* M009 */
{
  char path[25];

  if (do_add)
  {
    if (doing_first_target)
    {
      if (open_target())                         /* M009 Start */
        return (INVTARGET);
      else
        return (NOERROR);                        /* M009 End */
    }
  }

  build_ext(diskettes_complete + 1);

  if (target_removable)
    sprintf(path, "%c:\\BACKUP.%s", tgt_drive_letter, ext);
  else
    sprintf(path, "%c:\\BACKUP\\BACKUP.%s", tgt_drive_letter, ext);

  handle_target = extended_open(CREATE_IT, (WORD)ARCHIVE, (char far *)path,
                                (WORD)(READWRITE));
  if (rc == NOERROR)
    target_opened = TRUE;
  else
    return (INVTARGET);                          /* M009 */

  if (target_removable)
    sprintf(path, "%c:\\CONTROL.%s", tgt_drive_letter, ext);
  else
    sprintf(path, "%c:\\BACKUP\\CONTROL.%s", tgt_drive_letter, ext);

  handle_control = extended_open(CREATE_IT, (WORD)ARCHIVE, (char far *)path,
                                 (WORD)(READWRITE));
  if (rc == NOERROR)
    control_opened = TRUE;
  else
    return (INVTARGET);                          /* M009 */

  data_file_tot_len = (DWORD)0;
  ctl_file_tot_len = (DWORD)0;

  return (NOERROR);                              /* M009 */
}


/*********************************************************************/
/* Routine:   open_target                                            */
/*                                                                   */
/* Function:  Opens the target.  This is only done if /A was         */
/*            specified and it is the first target.                  */
/*********************************************************************/

int open_target()                                /* M009 */
{
  char path[PATHLEN+20];

  /* Open BACKUP.xxx File */
  build_ext(diskettes_complete + 1);

  if (target_removable)
    sprintf(path, "%c:\\BACKUP.%s", tgt_drive_letter, ext);
  else
    sprintf(path, "%c:\\BACKUP\\BACKUP.%s", tgt_drive_letter, ext);

  /* Turn off readonly bit on BACKUP.xxx */
  set_attribute(path, (WORD)(get_attribute(path) & (WORD)READONLYOFF));
  /* Open it */
  handle_target = extended_open(OPEN_IT, 0, (char far *)path,
                                (WORD)(DENYALL + READWRITE));
  if (rc == NOERROR)
    target_opened = TRUE;
  else
    return (INVTARGET);                          /* M009 */
    
  /* Open CONTROL.xxx File */
  if (target_removable)
    sprintf(path, "%c:\\CONTROL.%s", tgt_drive_letter, ext);
  else
    sprintf(path, "%c:\\BACKUP\\CONTROL.%s", tgt_drive_letter, ext);

  set_attribute(path, (WORD)(get_attribute(path) & (WORD)READONLYOFF));
  handle_control = extended_open(OPEN_IT, 0, (char far *)path,
                                 (WORD)(DENYALL + READWRITE));
  if (rc == NOERROR)
    control_opened = TRUE;
  else
    return (INVTARGET);                          /* M009 */

  data_file_tot_len = (DWORD)lseek(handle_target, EOFILE, (DWORD)0);
  ctl_file_tot_len = (DWORD)lseek(handle_control, EOFILE, (DWORD)0);

  return (NOERROR);                              /* M009 */
}


/*********************************************************************/
/* Routine:   delete_files                                           */
/*                                                                   */
/* Function:  Delete all files in the root directory of target       */
/*            diskette, or in the BACKUP directory of the target     */
/*            hardfile.  If error occurs deleting file, try to       */
/*            reset the attribute to 0 and try it again.             */
/*********************************************************************/

int delete_files(char dirlevel)                  /* M009 */
{
  BYTE delete_path[25];
  struct FileFindBuf tempdta;
  struct FileFindBuf *tempdta_addr;
  WORD dhandle;
  BYTE delete_it;

  /*
   *  Don't delete files if we are adding files to an existing
   *  BACKUP and this is the first target.
   */
  if (do_add)
  {
    if (doing_first_target)
      return (NOERROR);                          /* M009 */
  }

  tempdta_addr = (struct FileFindBuf *)&tempdta;

  if (dirlevel == ROOTDIR)
    sprintf(delete_path, "%c:\\*.*", tgt_drive_letter);
  else
    sprintf(delete_path, "%c:\\BACKUP\\*.*", tgt_drive_letter);

  /* Find a file to delete */
  find_first((char *)&delete_path[0], &dhandle, tempdta_addr, (SYSTEM + HIDDEN));
  while (rc == NOERROR)
  {
    delete_it = TRUE;
    if (dirlevel == ROOTDIR)
      sprintf(delete_path, "%c:\\%s", tgt_drive_letter, tempdta.file_name);
    else
      sprintf(delete_path, "%c:\\BACKUP\\%s", tgt_drive_letter, tempdta.file_name);

    if (logfile_on_target)
    {
      if (strcmp(delete_path, logfile_path) == SAME)
        delete_it = FALSE;
    }

    if (delete_it == TRUE)
    {
      deleting_files = TRUE;                     /* M009 */
      delete(delete_path);
      /* fatal error if rc is file_not_found - cannot write to disk */
      if (rc == FILE_NOT_FOUND)                  /* M009 */
        return (rc);                             /* M009 */
      if (rc != NOERROR)
      {
        set_attribute(delete_path, (WORD)0);
        delete(delete_path);
        /* fatal error here, cannot write to disk */
        if (rc != NOERROR)                       /* M009 */
          return (rc);                           /* M009 */
      }
      deleting_files = FALSE;                    /* M009 */
    }
    find_next(dhandle, tempdta_addr);
  }
  return (NOERROR);                              /* M009 */
}


/*********************************************************************/
/* Routine:   exist                                                  */
/*                                                                   */
/* Function:  Does a FIND FIRST of the filespec passed at PATH_ADDR. */
/*            If so, returns TRUE, otherwise returns FALSE.          */
/*********************************************************************/

WORD exist(char *path_addr)
{
  WORD dhandle;
  WORD temprc;
  struct FileFindBuf tempdta;

  find_first(path_addr, &dhandle, &tempdta, (SUBDIR + SYSTEM + HIDDEN));
  temprc = rc;
  if (rc == NOERROR)
    findclose(dhandle);

  if (temprc != NOERROR)
    return (FALSE);
  else
    return (TRUE);
}


/*********************************************************************/
/* Routine:   open_source_file                                       */
/*                                                                   */
/* Function:  Try to open the source file at the DTA structure.      */
/*            If after MAX_RETRY_OPEN_COUNT attempts you cannot      */
/*            open it, then display an appropriate message and       */
/*            continue. If it was opened, then get the files         */
/*            extended attributes.                                   */
/*********************************************************************/

void open_source_file()
{
  int num_attempts = 0;
  char done = FALSE;
  char file_to_be_backup[20];

  source_opened = FALSE;          /* source is not opened yet */
  file_spans_target = FALSE;      /* file does not span diskettes */
  span_seq_num = 1;               /* first disk containing part of this file */
  show_path();                    /* show full path from root to stdout/logfile */
  sprintf(file_to_be_backup, "%c:%s", src_drive_letter, dta.file_name);

  do
  {                               /* attempt open */
    handle_source = extended_open(OPEN_IT, 0, (char far *)file_to_be_backup,
                                  (WORD)(DENYWRITE + READACCESS));
    if (rc != NOERROR)            /* check for error */
    {                             /* handle share errors */
      num_attempts++;             /* increment number of attempts */
      if (num_attempts == MAX_RETRY_OPEN_COUNT)
      {                           /* compare with max number */
        file_sharing_error();     /* share error opening the file */
        done = TRUE;
      }
    }
    else
    {
      source_opened = TRUE;       /* set flag indicating file is open */
      done = TRUE;                /* done in this loop */
      put_new_fh();               /* write file header to control file */
    }
  } while (!done);
}


/*********************************************************************/
/* Routine:   file_sharing_error                                     */
/*                                                                   */
/* Function:  Handle the file sharing error that just occurred.      */
/*                                                                   */
/*********************************************************************/

void file_sharing_error()
{
  union	REGS reg;

  display_msg(CRLF);
  display_msg(CONFLICTMSG);            /* say "Last file not backed" */
  return_code = RETCODE_SHARE_ERROR;   /* set errorlevel */

  if (do_logfile)
  {
    reg.x.ax = LASTNOTBACKUP;
    reg.x.bx = handle_logfile;
#define MSG_LEN 33
    reg.x.cx = (WORD)MSG_LEN;
    update_logfile(&reg, &reg);        /* in source file _msgret.sal */
  }
}


/*********************************************************************/
/* Routine:   far_ptr                                                */
/*                                                                   */
/* Function:  Gets the far pointer address from a segment:offset.    */
/*********************************************************************/

char far *far_ptr(WORD seg, WORD off)
{
  char far *p;

  PUT_SEG(p, seg);
  PUT_OFF(p, off);
  return (p);
}


/*********************************************************************/
/* Routine:   do_copy                                                */
/*                                                                   */
/* Function:  Copy the source file to the BACKUP.xxx file            */
/*            If there are extended attributes, write them           */
/*            to the BACKUP.xxx file.                                */
/*********************************************************************/

void do_copy()
{
  WORD bytes_read;
  WORD bytes_to_read = data_file_alloc_size;     /* read size = buffer size */
  char done = FALSE;
  char file_to_be_backup[20];

  part_size = (DWORD)0;
  cumul_part_size = (DWORD)0;

  if (source_opened)
  {
    do
    {
      bytes_read = handle_read(handle_source, bytes_to_read, far_ptr(selector, 0));
      if (bytes_read == 0)
        done = TRUE;
      else
  	write_to_target(bytes_read);

      if (bytes_read < bytes_to_read)
        done = TRUE;
    } while (!done);

    close_file(handle_source);         /* close the source file handle */
    source_opened = FALSE;             /* source is not open */
    sprintf(file_to_be_backup, "%c:%s", src_drive_letter, dta.file_name);
    reset_archive_bit(file_to_be_backup); /* reset archive bit on source file */
    files_backed_up++;                 /* increment number of files backed up */
  }
}


/*********************************************************************/
/* Routine:   show_path                                              */
/*                                                                   */
/* Function:  Display to stdout the full path from root.             */
/*            If we are logging, put full path there too.            */
/*********************************************************************/

void show_path()
{
  char done_path[PATHLEN + 20];
  char logfile_entry[PATHLEN + 22];
  WORD written = 0;

#ifdef DBCS
  if (src_drive_path[strlen(src_drive_path) - 1] != BACKSLASH ||
      CheckDBCSTailByte(src_drive_path,&src_drive_path[strlen(src_drive_path) - 1]))
#else
  if (src_drive_path[strlen(src_drive_path) - 1] != BACKSLASH)
#endif

    sprintf(done_path, "%s\\%s", src_drive_path, dta.file_name);
  else
    sprintf(done_path, "%s%s", src_drive_path, dta.file_name);

  /* Display logfile path on screen */
  done_path[0] = 0xd;
  done_path[1] = 0xa;
  handle_write(STDOUT, strlen(done_path), (char far *)&done_path[0]);

  if (do_logfile)
  {
    build_ext(diskettes_complete + 1);
    sprintf(logfile_entry, "\15\12%s  %s", ext, &done_path[2]);
    written = handle_write(handle_logfile, strlen(logfile_entry),
                           (char far *)&logfile_entry[0]);
    if ( written != strlen(logfile_entry) || (rc != NOERROR) )
    {
      display_msg(LOGFILE_TARGET_FULL);
      do_logfile = FALSE;
    }
  }
}


/*********************************************************************/
/* Routine:   reset_archive_bit                                      */
/*                                                                   */
/* Function:  Sets the attribute of the source file to what          */
/*            it was before, except the archive bit is reset.        */
/*********************************************************************/

void reset_archive_bit(char *path_addr)
#define ARCHIVE_MASK 223
{
  WORD attrib;

  attrib = get_attribute(path_addr);
  attrib = attrib & (WORD)ARCHIVE_MASK;
  set_attribute(path_addr, attrib);
}


/*********************************************************************/
/* Routine:   write_to_target                                        */
/*                                                                   */
/* Function:  Write a specified # of bytes to                        */
/*            target. Handle disk full conditions                    */
/*            and everything else.                                   */
/*********************************************************************/

void write_to_target(WORD bytes_to_write)
{
  WORD bytes_written;
  WORD written;

  bytes_written = handle_write(handle_target, bytes_to_write, far_ptr(selector, 0));
  written = bytes_written;

  if (bytes_written == bytes_to_write)      /* if we wrote it all... */
  {
    part_size += (DWORD)written;            /* update size of this part */
    cumul_part_size += (DWORD)written;      /* update size of this part */
    data_file_tot_len += (DWORD)written;    /* update length of BACKUP.xxx file */
  }
  else
  {
    /* fill up current target */
    written = write_till_target_full(bytes_to_write,0);
    bytes_written += written;               /* update # bytes written */
    part_size += (DWORD)written;            /* update size of this part */
    cumul_part_size += (DWORD)written;      /* update size of this part */
    data_file_tot_len += (DWORD)written;    /* update length of BACKUP.xxx file */
    close_out_current_target();             /* update CONTROL.xxx, close files */
    get_next_target();                      /* get next disk from user */

    /* write rest of buffer */
    written = handle_write(handle_target, bytes_to_write - bytes_written,
                           far_ptr(selector, bytes_written));
    bytes_written += written;               /* update # bytes written */
    part_size = (DWORD)written;             /* update size of this part */
    cumul_part_size += (DWORD)written;      /* update size of this part */
    data_file_tot_len += (DWORD)written;    /* update length of BACKUP.xxx */
  }
}


/*********************************************************************/
/* Routine:   write_till_target_full                                 */
/*                                                                   */
/* Function:  Find out how much space is left on the disk,           */
/*            and use it all up.                                     */
/*********************************************************************/

WORD write_till_target_full(WORD bytes_to_write, WORD begin_offset)
{
  WORD written;
  WORD bfree;

  bytes_to_write;                 /* kill warning msg */

  bfree = (unsigned) disk_free_space();
  written = handle_write(handle_target, bfree, far_ptr(selector, begin_offset));

  return (written);
}


/*********************************************************************/
/* Routine:   close_out_current_target                               */
/*                                                                   */
/* Function:  Update CONTROL.xxx file, close it, close BACKUP.xxx,   */
/*            make files READONLY, die if backing up to hardfile.    */
/*********************************************************************/

void close_out_current_target()
{
  BYTE last = LAST_TARGET;

  disk_full = TRUE;               /* the disk is full */

  if (part_size != 0)             /* if we wrote something...*/
  {
    file_spans_target = TRUE;     /* this file spans diskettes */
    files_backed_up++;            /* increment # files backed up on this target */
  }

  if (files_backed_up > 0)        /* if backed up something */
  {
    /* increment Num_Entries field in directory block and NextDB field */
    update_db_entries(files_backed_up);
  }

  update_fh_entries();            /* update the fields in file header */

  if (!target_removable)
  {
    /* Update DH_LastDisk == LAST_DISK */
    lseek(handle_control, BOFILE, (DWORD)(DHLENGTH - 1));
    handle_write(handle_control,1, (char far *)&last);
  }

  if (control_opened)             /* if the control file is open */
  {
    close_file(handle_control);   /* close it */
    control_opened = FALSE;       /* set flag to show it isn't open */
  }

  if (target_opened)
    close_file(handle_target);    /* close files */

  target_opened = FALSE;          /* indicate that target is not open */

  if (file_spans_target)          /* if file spans to another diskette */
    span_seq_num++;               /*   increment the sequence number */

  mark_files_read_only();         /* set ReadOnly Attr of BACKUP/CONTROL files */

  if (logfile_on_target)          /* if logfile resides on target drive */
  {
    close_file(handle_logfile);   /* close it */
    logfile_opened = FALSE;       /* and set flag to show it's not open */
  }

  if (!target_removable)          /* if target is a hardfile */
  {
    display_msg(LASTNOTBACKUP);   /* say "Last file not backed up" */
    error_exit(FDISKFULLMSG);     /* give error message and quit */
  }

  diskettes_complete++;		/* increment number of diskettes complete */
}


/*********************************************************************/
/* Routine:   mark_as_not_last_target                                */
/*                                                                   */
/* Function:  Sets the field in the disk header indicating           */
/*            this is not the last target.                           */
/*********************************************************************/

void mark_as_not_last_target()
{
  BYTE last = NOT_LAST_TARGET;
  DWORD	db_offset;
  DWORD	pointer;

  /* Update DH_LastDisk = NOT_LAST_TARGET */
  lseek(handle_control, BOFILE, (DWORD)(DHLENGTH - 1));
  handle_write(handle_control, 1, (char far *)&last);

  /* Get first DB_NextDB */
  pointer = lseek(handle_control, BOFILE, (DWORD)(DHLENGTH + 66));
  handle_read(handle_control, 4, (char far *)&db_offset);

  /* Get offset of last Dir Block */
  while (db_offset != (DWORD)LAST_DB)
  {
    pointer = lseek(handle_control, BOFILE, (DWORD)db_offset + 66);
    handle_read(handle_control, 4, (char far *)&db_offset);
  }

  /* Change DB_NextDB field to point to EOF */
  lseek(handle_control, BOFILE, (DWORD)pointer);
  handle_write(handle_control, 4, (char far *)&ctl_file_tot_len);

  lseek(handle_control, EOFILE, (DWORD)0);
}


/*********************************************************************/
/* Routine:   mark_as_last_target                                    */
/*                                                                   */
/* Function:  Sets the field in the disk header indicating           */
/*            this is the last target.  Also updates the             */
/*            directory block to indicate the number of              */
/*            files that are backed up.                              */
/*********************************************************************/

void mark_as_last_target()
{
  BYTE last = LAST_TARGET;

  /* Update DH_LastDisk == LAST_DISK */
  lseek(handle_control, BOFILE, (DWORD)(DHLENGTH - 1));
  handle_write(handle_control, 1, (char far *)&last);

  /* Update DB_NumEntries == FILES_BACKED_UP */
  lseek(handle_control, BOFILE,(DWORD)(curr_db_begin_offset + 64));
  handle_write(handle_control, 2, (char far *)&files_backed_up);

  /* Update FH Entries */
  update_fh_entries();
}


/*********************************************************************/
/* Routine:   update_db_entries                                      */
/*                                                                   */
/* Function:  Updates the DB entries.                                */
/*********************************************************************/

void update_db_entries(WORD entries)
{
  lseek(handle_control, BOFILE, (DWORD)(curr_db_begin_offset + 64));

  /* Update DB_num_entries */
  handle_write(handle_control, 2, (char far *)&entries);

  /* Update DB_NextDB only if we are not at the end of a disk */
  if (!disk_full)
    handle_write(handle_control, 4, (char far *)&ctl_file_tot_len);

  lseek(handle_control, EOFILE, (DWORD)0);
}


/*********************************************************************/
/* Routine:   update_fh_entries                                      */
/*                                                                   */
/* Function:  Update following fields in Current File Header:        */
/*                                                                   */
/*              FH_Flags: Indicate file successfully processed.      */
/*                        Indicate if this is last part or not.      */
/*                                                                   */
/*              FH_PartSize: Indicate number of bytes written.       */
/*********************************************************************/

void update_fh_entries()
{
  BYTE flag;

  if (!file_spans_target)
    flag = (BYTE)(LASTPART + SUCCESSFUL);
  else
    flag = (BYTE)(NOTLASTPART + SUCCESSFUL);

  if (!target_removable)
  {
    if (disk_full)
      flag = (BYTE)(LASTPART + NOTSUCCESSFUL);
  }

  /* Go to FLAG field */
  lseek(handle_control, BOFILE, (DWORD)(curr_fh_begin_offset + 13));

  /* write the FLAG field to control file */
  handle_write(handle_control, 1, (BYTE far *)&flag);

  /* go to PARTSIZE field */
  lseek(handle_control, CURRPOS, (DWORD)10);

  /* write the PARTSIZE field to control file */
  handle_write(handle_control, 4, (char far *)&part_size);

  lseek(handle_control, EOFILE, (DWORD)0);  /* go back to end-of-file */
}


/*********************************************************************/
/* Routine:   mark_files_read_only                                   */
/*                                                                   */
/* Function:  Set the READ-ONLY attribute on BACKUP.xxx and          */
/*            CONTROL.xxx.                                           */
/*********************************************************************/

void mark_files_read_only()
{
  char path[25];

  build_ext(diskettes_complete + 1);

  if (target_removable)
  {
    sprintf(path, "%c:\\CONTROL.%s", tgt_drive_letter, ext);
    set_attribute(path, (WORD)(ARCHIVE + READONLY));
    sprintf(path, "%c:\\BACKUP.%s", tgt_drive_letter, ext);
    set_attribute(path, (WORD)(ARCHIVE + READONLY));
  }
  else
  {
    sprintf(path, "%c:\\BACKUP\\CONTROL.%s", tgt_drive_letter, ext);
    set_attribute(path, (WORD)(ARCHIVE + READONLY));
    sprintf(path, "%c:\\BACKUP\\BACKUP.%s", tgt_drive_letter, ext);
    set_attribute(path, (WORD)(ARCHIVE + READONLY));
  }

  if (target_removable)
    label_target_drive();
}


/*********************************************************************/
/* Routine:   put_disk_header                                        */
/*                                                                   */
/* Function:  Fills in the disk header.                              */
/*********************************************************************/

void put_disk_header()
{
  struct Disk_Header dh;
  int i;

  dh.DH_Length = DHLENGTH;                  /* DH_Length */
  strcpy(dh.DH_Identifier, "BACKUP  ");     /* DH_Identifier */
  dh.DH_Sequence = diskettes_complete + 1;  /* DH_Sequence */
  for (i = 0; i <= 128; i++)
    dh.DH_reserved[i] = NUL;                /* DH_Reserved */
  dh.DH_LastDisk = NOT_LAST_TARGET;         /* DH_LastDisk - Assume NOT LAST TARGET */

  write_to_control_file((char far *)&dh, DHLENGTH);
  put_new_db();
}

/*********************************************************************/
/* Routine:   put_new_db                                             */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void put_new_db()
{
  struct Dir_Block db;
  int i;

  if (files_backed_up > 0)
    update_db_entries(files_backed_up);     /* update entries in previous db */

  curr_db_begin_offset = ctl_file_tot_len;  /* use for updating when done w/ cur dir */

  db.DB_Length = DBLENGTH;             /* length, in bytes, of dir block */
  for (i = 0; i <= 63; i++)
    db.DB_Path[i] = NUL;               /* ascii path of this dir, drive omitted */

  strcpy(db.DB_Path, &src_drive_path[3]);
  db.DB_NumEntries = 0;                     /* # filenames currently in list */
  db.DB_NextDB = (DWORD)LAST_DB;            /* offset of next directory block */

  write_to_control_file((char far *)&db, DBLENGTH);
  new_directory = FALSE;
  files_backed_up = 0;
}


/*********************************************************************/
/* Routine:   put_new_fh                                             */
/*                                                                   */
/* Function:  We are about to backup a file. Write the               */
/*            file header to the control file.                       */
/*********************************************************************/

void put_new_fh()
{
  struct File_Header fh;
  int i;

  /*
   *  If adding files, and it is the last diskette from previous backup,
   *  and we have not backed up ANY yet, then mark this diskette as NOT
   *  the last.
   */
  if (do_add)
  {
    if (doing_first_target)
      if (files_backed_up == 0)
        mark_as_not_last_target();
  }

  if (new_directory)              /* if file is in a different directory */
    put_new_db();                 /* create new directory block */

  curr_fh_begin_offset = ctl_file_tot_len;

  fh.FH_Length = FHLENGTH;                  /* length in bytes of file header */ 
  for (i = 0; i <= 11; i++)
    fh.FH_FName[i] = NUL;
  strcpy(fh.FH_FName, dta.file_name);       /* ascii file name */

  fh.FH_FLength	= (DWORD)dta.file_size;     /* length of file */
  fh.FH_FSequence = span_seq_num;           /* sequence # for files that span */
  fh.FH_BeginOffset = data_file_tot_len;    /* offset where segment begins */ 
  fh.FH_Attribute = dta.attributes;         /* file attribute from directory */    
  fh.FH_FTime = dta.write_time;             /* time when file was last modified */ 
  fh.FH_FDate = dta.write_date;             /* date when file was last modified */ 
  fh.FH_Flags = LASTPART + SUCCESSFUL;

  if (file_spans_target)
  {
    /* length of this part of file */ 
    fh.FH_PartSize  = (DWORD)(dta.file_size - cumul_part_size);
    file_spans_target = FALSE;
  }
  else
    fh.FH_PartSize = (DWORD)dta.file_size;  /* length of this part of file */ 

  write_to_control_file((char far *)&fh, FHLENGTH);
}


/*********************************************************************/
/* Routine:   write_to_control_file                                  */
/*                                                                   */
/* Function:  Write to the control file and update counters.         */
/*********************************************************************/

void write_to_control_file(char far *address, unsigned short len)
{
  WORD written;

  written = handle_write(handle_control, len, address);
  ctl_file_tot_len = ctl_file_tot_len + (DWORD)written;
}


/*********************************************************************/
/* Routine:   control_break_handler                                  */
/*                                                                   */
/* Function:  Set errorlevel and call routines to close files        */
/*            and terminate.                                         */
/*********************************************************************/

void control_break_handler()
{
  return_code = RETCODE_CTL_BREAK;
  clean_up_and_exit();
}


/*********************************************************************/
/* Routine:   display_it                                             */
/*                                                                   */
/* Function:  Display the requested message to the standard output   */
/*            device.                                                */
/*                                                                   */
/*   Input:                                                          */
/*	   1) (WORD) Number of the message to be displayed.          */
/*	   2) (WORD) Handle to be written to.                        */
/*	   3) (WORD) Substitution Count                              */
/*	   4) (WORD) Flag indicating user should "Strike any key..." */
/*	   5) (WORD) Num indicating message class                    */
/*                                                                   */
/*   Output:                                                         */
/*	   The message corresponding to the requested msg number     */
/*	   will be written to the requested handle.  If requested,   */
/*	   substitution text will be inserted as required.  The      */
/*         Substitution List is global and, if used, will be         */
/*         initialized by DISPLAY_MSG before calling this routine.   */
/*                                                                   */
/*   Normal Exit:                                                    */
/*	   Message will be successfully written to requested handle. */
/*                                                                   */
/*   Error Exit:                                                     */
/*	   None.                                                     */
/*********************************************************************/

void display_it(int msg_number, WORD handle, int subst_count, BYTE waitflag,
                BYTE class)            /* 1=DOSerror, 2=PARSE, -1=Utility */
{
  inregs.x.ax = msg_number;
  inregs.x.bx = handle;
  inregs.x.cx = subst_count;
  inregs.h.dh = class;
  inregs.h.dl = (BYTE)waitflag;
  inregs.x.si = (WORD)(char far *)&sublist;

  sysdispmsg(&inregs, &outregs);

  user_response[0] = outregs.h.al;     /* user input, if any  -  M011 */
}


/*********************************************************************/
/* Routine:   display_msg                                            */
/*                                                                   */
/* Function:  Display the messages referenced by variable            */
/*            MSG_NUM to either STDOUT or STDERR.  In some cases     */
/*            insert text into the body of the message.              */
/*********************************************************************/

void display_msg(int msg_num)
{
  switch (msg_num)
  {
    case NONEFNDMSG :
        {
          display_it (msg_num, STDOUT, 0, NOWAIT, (BYTE)UTIL_MSG);
          break;
        }
    case INSUFF_MEMORY     :
    case ERR_EXEC_FORMAT   :
    case INV_PATH          :
    case INV_DATE          :
    case INV_TIME          :
    case NO_SOURCE         :
    case NO_TARGET         :
    case SRC_AND_TGT_SAME  :
    case BAD_DOS_VER       :
    case INV_DRIVE         :
    case CANT_OPEN_LOGFILE :
    case INVTARGET         :
    case SRCISTGT          :
    case TGTISSRC          :
    case NOTLASTMSG        :
    case CONFLICTMSG       :
    case CRLF              :
    case CANT_FIND_FORMAT  :
    case LASTNOTBACKUP     :
    case DISK_UNFORMAT     :                     /* M011 */
        {
          display_it (msg_num, STDERR, 0, NOWAIT, (BYTE)UTIL_MSG);
          break;
        }
    case LOGFILE_TARGET_FULL :
    case INSERT_FORMAT       :                   /* M011 */
        {
          display_it (msg_num, STDERR, 0, NOWAIT, (BYTE)UTIL_MSG);
          display_it (PRESS_ANY_KEY, STDERR, 0, WAIT, (BYTE)UTIL_MSG);
          break;
        }
    case NO_FORMAT_FND     :                     /* M011 Start */
    case CONTINUE_NEW_DISK :
        {
          display_it (msg_num, STDERR, 0, YESNOWAIT, (BYTE)UTIL_MSG);
          break;  
        }                                        /* M011 End */
    case LOGGING :
        {
          sublist.value1 = (char far *)&logfile_path[0];
          sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
          sublist.pad_char1 = ' ';
          sublist.max_width1 = (BYTE)strlen(logfile_path);
          sublist.min_width1 = sublist.max_width1;
          display_it (msg_num, STDOUT, 1, NOWAIT, (BYTE)UTIL_MSG);
          break;
        }
    case CANT_FORMAT_HARDFILE :
        {
          sublist.value1 = (char far *)&tgt_drive_letter;
          sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
          sublist.pad_char1 = ' ';
          sublist.max_width1 = 1;
          sublist.min_width1 = 1;
          display_it (msg_num, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
          break;
        }
    case BUDISKMSG    :
    case FDISKFULLMSG :
        {
          sublist.value1 = (char far *)&tgt_drive_letter;
          sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
          sublist.pad_char1 = ' ';
          sublist.max_width1 = 1;
          sublist.min_width1 = 1;
          display_it (msg_num, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
          break;
        }
    case ERASEMSG    :
    case FERASEMSG   :
    case LASTDISKMSG :
        {
          sublist.value1 = (char far *)&tgt_drive_letter;
          sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
          sublist.pad_char1 = ' ';
          sublist.max_width1 = 1;
          sublist.min_width1 = 1;
          display_it (msg_num, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
          display_it (PRESS_ANY_KEY, STDERR, 0, WAIT, (BYTE)UTIL_MSG);
          break;
        }
    case INSERTSOURCE :
        {
       	  sublist.value1 = (char far *)&src_drive_letter;
       	  sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
       	  sublist.pad_char1 = ' ';
       	  sublist.max_width1 = 1;
       	  sublist.min_width1 = 1;
       	  display_it (msg_num, STDERR, 1, NOWAIT, (BYTE)UTIL_MSG);
       	  display_it (PRESS_ANY_KEY, STDERR, 0, WAIT, (BYTE)UTIL_MSG);
       	  break;
        }
    case SEQUENCEMSG :
        {
       	  build_ext(diskettes_complete + 1);
       	  if (diskettes_complete + 1 < 100)
       	  {
       	    sublist.value1 = (char far *)&ext[1];
       	    sublist.max_width1 = 2;
       	  }
       	  else
       	  {
       	    sublist.value1 = (char far *)&ext[0];
       	    sublist.max_width1 = 3;
       	  }
       	  sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
       	  sublist.pad_char1 = ' ';
       	  sublist.min_width1 = sublist.max_width1;
       	  display_it (msg_num, STDOUT, 1, NOWAIT, (BYTE)UTIL_MSG);
       	  break;
        }
    case INSERTTARGET :
        {
       	  build_ext(diskettes_complete + 1);
       	  if (diskettes_complete + 1 < 100)
       	  {
       	    sublist.value1 = (char far *)&ext[1];
       	    sublist.max_width1 = 2;
       	  }
       	  else
       	  {
       	    sublist.value1 = (char far *)&ext[0];
       	    sublist.max_width1 = 3;
       	  }

       	  sublist.flags1 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
       	  sublist.pad_char1 = ' ';
       	  sublist.min_width1 = sublist.max_width1;

       	  sublist.value2 = (char far *)&tgt_drive_letter;
       	  sublist.flags2 = LEFT_ALIGN + CHAR_FIELD_ASCIIZ;
       	  sublist.pad_char2 = ' ';
       	  sublist.max_width2 = 1;
       	  sublist.min_width2 = 1;

       	  display_it (msg_num, STDERR, 2, NOWAIT, (BYTE)UTIL_MSG);
       	  break;
        }
    case INVPARM :
        {
       	  display_it (INVPARM, STDERR, 1, NOWAIT, (BYTE)PARSEERROR);
       	  break;
        }
  }
}


/*********************************************************************/
/* Routine:   display_options_exit                                   */
/*                                                                   */
/* Function:  Display the options help message, and then exit        */
/*            so the user can retry the command.                     */
/*********************************************************************/

void display_options_exit()
{
  int MsgNbr;

  /*
   *  Display all the message lines in the
   *  options help message.
   */
  for (MsgNbr = MSG_OPTIONS_FIRST; MsgNbr <= MSG_OPTIONS_LAST; MsgNbr++)
  {
    display_it(MsgNbr, STDOUT, 0, NOWAIT, (BYTE)UTIL_MSG);
  }

  /*
   *  Set the return code to show no error,
   *  and exit so the user can retry the command.
   */
  return_code = 0;
  clean_up_and_exit();            /* does not return */
}


/*********************************************************************/
/* Routine:   error_exit                                             */
/*                                                                   */
/* Function:  Display appropriate error message, set                 */
/*            the return code, and call clean_up_and_exit.           */
/*********************************************************************/

void error_exit(int error_type)
{
  display_msg(error_type);
  return_code = RETCODE_ERROR;
  clean_up_and_exit();
}


/*********************************************************************/
/* Routine:   restore_default_directories                            */
/*                                                                   */
/* Function:  Restore the original current directory on the          */
/*            source drive.                                          */
/*********************************************************************/

void restore_default_directories()
{
  char path[PATHLEN + 20];

  sprintf(path, "%c:%s", src_drive_letter, src_def_dir);
  chdir(path);
}


/*********************************************************************/
/* Routine:   clean_up_and_exit                                      */
/*                                                                   */
/* Function:  Update BACKUP and CONTROL files.                       */
/*            Close open files.                                      */
/*            Mark BACKUP, CONTROL file read only                    */
/*            Restore default drive and directories                  */
/*            Deallocate buffers                                     */
/*********************************************************************/

void clean_up_and_exit()
{
  char name[15];

  if (source_opened)
  {
    close_file(handle_source);
    source_opened = FALSE;             /* indicate source is not open */
  }

  if (target_opened)
  {
    close_file(handle_target);
    target_opened  = FALSE;            /* indicate target is not open */
  }

  if (control_opened)
  {
    mark_as_last_target();
    close_file(handle_control);
    control_opened = FALSE;
    mark_files_read_only();
  }

  if (logfile_opened)
  {
    close_file(handle_logfile);
    logfile_opened = FALSE;
  }

  if ( (files_backed_up == 0) && (!checking_target) && (!do_add) && 
       (backup_started) && (!deleting_files) )        /* M009 */
  {
    deleting_files = TRUE;                            /* M009 */
    /*
     *  Note:  We do NOT want to reset "deleting_files" to FALSE, since
     *  we're exitting.                                  M009
     */
    if (target_removable)
    {
      build_ext(diskettes_complete + 1);
      sprintf(name, "%c:\\BACKUP.%s", tgt_drive_letter, ext);
      set_attribute(name,(WORD)0);
      delete(name);

      sprintf(name, "%c:\\CONTROL.%s", tgt_drive_letter, ext);
      set_attribute(name, (WORD)0);
      delete(name);
    }
    else
    {
      delete_files(BACKUPDIR);
    }
  }

  if (def_drive_set)
    set_default_drive(def_drive);

  if (curr_dir_set)
    restore_default_directories();

  if (buffers_allocated)
    free_seg(selector);

  terminate();
}


/*********************************************************************/
/* Routine:   GetYesNo                                               */
/*                                                                   */
/* Function:  Checks if the user input is Yes or No.                 */
/*            Returns 0 if No, 1 if Yes, 2 if neither yes or no.     */
/* M011                                                              */
/*********************************************************************/

int GetYesNo()
{
  inregs.x.ax = 0x6523;
  inregs.h.dl = user_response[0];
  intdos(&inregs, &outregs);
  return (outregs.x.ax);
}



/*********************************************************************/
/*                                                                   */
/*                     DOS FAMILY API CALLS                          */
/*                                                                   */
/*********************************************************************/


/*********************************************************************/
/* Routine:   handle_open                                            */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

WORD handle_open(char *path_addr, WORD mode)
{
  WORD handle;
  WORD action;

#if defined(DEBUG)
  printf("\nDOSOPEN FILE=%s, MODE=%04Xh...", path_addr, mode);
#endif

  rc = DOSOPEN((char far *)path_addr,   /* path address */
	    (unsigned far *)&handle,    /* return area for handle */
	    (unsigned far *)&action,    /* return area for action performed */
	    (DWORD)0,                   /* file Size */
	    (WORD)0,                    /* file attribute */
	    (WORD)1,                    /* flag: only open file if it exists */
	    (WORD)mode,                 /* mode */
	    (DWORD)0                    /* reserved */
	   );

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, HANDLE=%04Xh", handle);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (handle);
}


/*********************************************************************/
/* Routine:   lseek                                                  */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

DWORD lseek(WORD handle,
            BYTE method,     /* 0=BOF+Offset, 1=CurrPos+Offset, 2=EOF+Offset */
            DWORD distance)
{
  DWORD pointer;

#if defined(DEBUG)
  printf("\nDOSCHGFILEPTR HANDLE=%04Xh, METHOD=%02Xh, DIST=%08lXh...", handle,
           method, distance);
#endif

  rc = DOSCHGFILEPTR(handle, distance, method, (DWORD far *)&pointer);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, POINTER=%08lXh", pointer);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return ((DWORD)pointer);
}


/*********************************************************************/
/* Routine:   handle_read                                            */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

WORD handle_read(WORD handle, WORD length, char far *address)
{
  WORD num_read;

#if defined(DEBUG)
  printf("\nDOSREAD HANDLE=%04Xh, BYTES=%04Xh, ADDR(off:seg)=%04X:%04X...",
          handle, length, address);
#endif

  rc = _dos_read(handle, address, length, (unsigned *)&num_read);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("READ %04Xh", num_read);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (num_read);
}


/*********************************************************************/
/* Routine:   handle_write                                           */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

WORD handle_write(WORD handle, WORD length, char far *address)
{
  WORD written;

#if defined(DEBUG)
  printf("\nDOSWRITE HANDLE=%04Xh, BYTES=%04Xh, ADDR(off:seg)=%04X:%04X...",
           handle, length, address);
#endif

  if (length != 0)
    rc = DOSWRITE(handle, address, length, (unsigned far *)&written);
  else
  {
    written = 0;
    rc = NOERROR;
  }

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("WROTE %04Xh", written);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (written);
}

/*********************************************************************/
/* Routine:   close_file                                             */
/*                                                                   */
/* Function:  Close the file handle specified.                       */
/*********************************************************************/

void close_file(WORD handle)
{
#if defined(DEBUG)
  printf("\nDOSCLOSE HANDLE=%04Xh...", handle);
#endif

  rc = DOSCLOSE(handle);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}

/*********************************************************************/
/* Routine:   get_attribute                                          */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

WORD get_attribute(char *path_addr)
{
  WORD attribute;

#if defined(DEBUG)
  printf("\nDOSQFILEMODE %s...", path_addr);
#endif

  rc = DOSQFILEMODE((char far *)path_addr, (unsigned far *)&attribute, (DWORD)0);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, ATTRIB=%04Xh", attribute);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (attribute);
}


/*********************************************************************/
/* Routine:   set_attribute                                          */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void set_attribute(char *path_addr, WORD attribute)
{
#if defined(DEBUG)
  printf("\nDOSSETFILEMODE FILE=%s, ATTRIB=%04Xh...", path_addr, attribute);
#endif

  rc = DOSSETFILEMODE((char far *)path_addr, attribute, (DWORD)0);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   get_current_drive                                      */
/*                                                                   */
/* Function:  Returns the current drive (1=A, 2=B).                  */
/*********************************************************************/

WORD get_current_drive()
{
  WORD drive;                     /* 1 = a */
  DWORD drivemap;

#if defined(DEBUG)
  printf("\nDOSQCURDISK DRIVE (1=A)...");
#endif

  rc = DOSQCURDISK((unsigned far *)&drive, (DWORD far *)&drivemap);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, DRIVE=%04Xh", drive);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (drive);
}

/*********************************************************************/
/* Routine:   set_default_drive                                      */
/*                                                                   */
/* Function:  Changes the current drive (1=A, 2=B).                  */
/*********************************************************************/

void set_default_drive(WORD drive)
{
#if defined(DEBUG)
  printf("\nDOSSELECTDISK (1=A) TO %04Xh...", drive);
#endif

  rc = DOSSELECTDISK(drive);

  if (rc == NOERROR)
    def_drive_set = TRUE;

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   get_current_dir                                        */
/*                                                                   */
/* Function:  Gets the current directory.                            */
/*********************************************************************/

void get_current_dir(WORD drive,       /* 0=default, 1=a, ... */
                     char *path_addr)  /* pointer to path buffer */ 
{
  WORD path_buff_len = PATHLEN + 20;

#if defined(DEBUG)
  printf("\nDOSQCURDIR DRIVE (0=def) %04Xh...", drive);
#endif

  rc = DOSQCURDIR(drive, (char far *)path_addr, (unsigned far *)&path_buff_len);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, CURRENT DIR IS = \\%s", path_addr);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   find_first                                             */
/*                                                                   */
/* Function:  Finds the first file fitting the given path.           */
/*********************************************************************/

void find_first(char *path_addr, WORD *dirhandle_addr,
                struct FileFindBuf *dta_address, WORD attrib)
{
  WORD numentries = 1;
  WORD temprc;

  *dirhandle_addr = 0xffff;

#if defined(DEBUG)
  printf("\nDOSFINDFIRST DIRH=%04Xh, FILE=%s...", *dirhandle_addr, path_addr);
#endif

  rc = DOSFINDFIRST((char far *)path_addr, (unsigned far *)dirhandle_addr,
	            attrib, (struct FileFindBuf far *)dta_address,
	            (WORD)(sizeof(struct FileFindBuf)),
                    (unsigned far *)&numentries, (DWORD)0);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, NAME=%s, ATTR=%04Xh, SIZE=%08lXh, DIRH=%04Xh",
            (*dta_address).file_name, (*dta_address).attributes,
            (*dta_address).file_size, *dirhandle_addr);
  else
    printf("ERROR, DIRH=%04Xh, RC=%04Xh", *dirhandle_addr, rc);
#endif

  if (rc != NOERROR)
  {
    temprc = rc;
    findclose(*dirhandle_addr);
    rc = temprc;
  }
}


/*********************************************************************/
/* Routine:   find_next                                              */
/*                                                                   */
/* Function:  Finds the next file fitting the given path.            */
/*********************************************************************/

void find_next(WORD dirhandle, struct FileFindBuf *dta_address)
{
  WORD temprc;
  WORD numentries = 1;

#if defined(DEBUG)
  printf("\nDOSFINDNEXT, DIRH=%04Xh...", dirhandle);
#endif

  rc = DOSFINDNEXT(dirhandle, (struct FileFindBuf far *)dta_address,
                   (WORD)(sizeof(struct FileFindBuf)+12),
                   (unsigned far *)&numentries);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, NAME=%s, DIRH=%04Xh",
            (*dta_address).file_name, dirhandle);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  if (rc != NOERROR)
  {
    temprc = rc;
    findclose(dirhandle);
    rc = temprc;
  }
}


/*********************************************************************/
/* Routine:   find_close                                             */
/*                                                                   */
/* Function:  Closes the file opened by findfirst or findnext.       */
/*********************************************************************/

void findclose(WORD dirhandle)
{

#if defined(DEBUG)
  printf("\nDOSFINDCLOSE DIRH=%04Xh...", dirhandle);
#endif

  rc = DOSFINDCLOSE(dirhandle);
  dirhandles_open = FALSE;

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   delete                                                 */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void delete(char *path_addr)
{
#if defined(DEBUG)
  printf("\nDOSDELETE FILE %s...", path_addr);
#endif

  rc = DOSDELETE((char far *)path_addr, (DWORD)0);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   disk_free_space                                        */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

long disk_free_space()
{
  struct FSAllocate fsa;
  long odd_bytes, size;

#if defined(DEBUG)
  printf("\nDOSQFSINFO (0=def) DRIVE=%04Xh...", tgt_drive_letter - 'A' + 1);
#endif

  rc = DOSQFSINFO(
	     (WORD)tgt_drive_letter - 'A' + 1,   /* drive 0=def, 1=a... */
	     (WORD)1,                            /* level */
	     (char far *)&fsa,                   /* return info */
	     (WORD)(sizeof(struct FSAllocate))   /* size of return info buffer */
	   );

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, FREESPACE=%08lXh",
             fsa.sec_per_unit * fsa.avail_units * fsa.bytes_sec);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  if (rc == NOERROR)
  {
    odd_bytes = data_file_tot_len % (fsa.sec_per_unit * fsa.bytes_sec);
    if (odd_bytes)                     /* if file is not cluster aligned */
      size = fsa.sec_per_unit * (fsa.avail_units + 1) *
             fsa.bytes_sec - odd_bytes;
    else                               /* file is cluster aligned */
      size = fsa.sec_per_unit * fsa.avail_units * fsa.bytes_sec;
  }
  else                                 /* error occurred */
    size = 0;

  return (size);
}


/*********************************************************************/
/* Routine:   replace_volume_label                                   */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void replace_volume_label(char *label_addr)
{
#if defined(DEBUG)
  printf("\nDOSSETFSINFO (0=def) DRIVE=%04Xh, LEN=%04Xh...",
           tgt_drive_letter - 'A' + 1, label_addr[0]);
#endif

  rc = DOSSETFSINFO(
            (WORD)tgt_drive_letter - 'A' + 1,    /* drive 0=def, 1=a... */
            (WORD)2,                             /* level */
            (char far *)label_addr,              /* buffer */
            (WORD)LABELLEN + 1                   /* buffer size */
       );

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   terminate                                              */
/*                                                                   */
/* Function:  Terminates the process and returns the errorlevel to   */
/*            DOS.                                                   */
/*********************************************************************/

#define TERMINATE  0x4C00
void terminate()
{
  if (append_indicator == DOS_APPEND)  /* if append /x was reset */
  {

#if defined(DEBUG)
    printf("\nINT2Fh,(SET APPEND) AX=%04Xh TO %04Xh...",
            SET_STATE, original_append_func);
#endif
    inregs.x.ax = SET_STATE;
    inregs.x.bx = original_append_func;
    int86(0x2f, &inregs, &outregs);
  }

  exit(return_code);
}


/*********************************************************************/
/* Routine:   ioctl                                                  */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

WORD ioctl(WORD devhandle)
{

#define ISDEVREMOVABL  0x20
#define CATEGORY       8          /* 1=serial,3=display,5=printer,8=disk */
#define GET_DRIVE_ATTR 9          /* ioctl cat for get device drive attr */
#define NETWORK_DRIVE  0x1000     /* returned by cat 9 for net devices */

  union REGS reg;
  BYTE data_area;

#if defined(DEBUG)
  printf("\nDOSDEVIOCTL HANDLE=%04Xh...", devhandle);
#endif

  if (devhandle > 0xffe4)
  {
    devhandle = -(int)devhandle;
    devhandle--;
  }
  reg.h.ah = 0x44;
  reg.h.al = CATEGORY;
  reg.x.bx = devhandle;
  intdos(&reg, &reg);
  /* check for redirected drive */
  if (reg.x.cflag)                /* cat 8 failed; probably remote drv */
  {
    reg.h.ah = 0x44;
    reg.h.al = GET_DRIVE_ATTR;
    reg.x.bx = devhandle;
    intdos(&reg, &reg);
    if (reg.x.cflag)              /* error now also; impossible - since */
      error_exit(INV_DRIVE);      /* we have already checked the drive */
    data_area = (char) ((reg.x.dx & NETWORK_DRIVE) ? 1 : 0); 
    /* if remote drive assume non-remov */
  }
  else
  {
    data_area = reg.h.al;
    rc = NOERROR;
  }
	
#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, DATA_AREA(0=REMOVABLE) SET TO %02Xh", data_area);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  return (data_area);
}


/*********************************************************************/
/* Routine:   alloc_seg                                              */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void alloc_seg()
{
  union REGS iregs, oregs;

#if defined(DEBUG)
  printf("\nDOSALLOCSEG SIZE=%04Xh...", data_file_alloc_size);
#endif

  iregs.h.ah = 0x48;
  iregs.x.bx = data_file_alloc_size ? 
      ( data_file_alloc_size % 16 ? (data_file_alloc_size / 16) + 1 : 
        data_file_alloc_size / 16  ) : 0x4096;

  intdos(&iregs, &oregs);
  /* BUGBUG */
  if (oregs.x.cflag)
  {
    printf("COULD NOT ALLOCATE SEGMENT\n");
    exit(1);
  }
  rc = oregs.x.cflag;
  selector = (unsigned)oregs.x.ax;

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL, SELECTOR=%04Xh, SIZE=%04Xh",
             selector, data_file_alloc_size);
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   free_seg                                               */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void free_seg(unsigned selector)
{

#define	invalid_selector 6

#if defined(DEBUG)
  printf("\nDOSFREESEG (%04Xh)...", selector);
#endif

  if (_dos_freemem(selector))
    rc = invalid_selector;
  else
    rc = NOERROR;

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   setsignal                                              */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void setsignal(WORD action, WORD signum)
{
  DWORD old_sig_handler;
  WORD old_sig_action;

#if defined(DEBUG)
  printf("\nDOSSETSIGHANDLER ACTION=%04Xh,SIGNUM=%04Xh...", action, signum);
#endif

  rc = DOSSETSIGHANDLER(
             (void far *)control_break_handler,  /* signal handler address */
             (DWORD far *)&old_sig_handler,      /* addr of previous handler */
             (unsigned far *)&old_sig_action,    /* addr of previous action */
             action,                             /* request type (2=hook) */
             signum                              /* signal number */
       );

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   do_dos_error                                           */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void do_dos_error(WORD flag)
{
#if defined(DEBUG)
  printf("\nDOSERROR, FLAG=%04Xh...", flag);
#endif

  rc =  DOSERROR(flag);

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif
}


/*********************************************************************/
/* Routine:   get_country_info                                       */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void get_country_info()
{

#define USACOUNTRY 1
#define DEFAULT_COUNTRY 0
#define DEFAULT_CODEPAGE 0

  struct ctry_info_blk buff;
  struct countrycode ctrystuff;        /* added for CPDOS 1.1 */
  WORD data_len;

  ctrystuff.country = (WORD)DEFAULT_COUNTRY;
  ctrystuff.codepage = (WORD)DEFAULT_CODEPAGE;

#if defined(DEBUG)
  printf("\nDOSGETCTRYINFO COUNTRY=%04Xh...", ctrystuff.country);
#endif

  rc = DOSGETCTRYINFO(
            (unsigned)sizeof(struct ctry_info_blk),   /* length of return area */
            (struct countrycode far *)&ctrystuff,     /* country Code */
            (char far *)&buff,                        /* return area */
            (unsigned far *)&data_len                 /* len of returned area */
       );

#if defined(DEBUG)
  if (rc == NOERROR)
    printf("SUCCESSFUL");
  else
    printf("ERROR, RC=%04Xh", rc);
#endif

  if (rc == NOERROR)
  {
    ctry_date_fmt = buff.date_format;
    ctry_time_fmt = buff.time_format;
    ctry_date_sep = buff.date_separator;
    ctry_time_sep = buff.time_separator;

#if defined(DEBUG)
    printf("\nDATE SEPERATOR=%c", ctry_date_sep);
    printf("\nTIME SEPERATOR=%c", ctry_time_sep);
    printf("\nDATE FORMAT=%u", ctry_date_fmt);
    printf("\nTIME FORMAT=%u", ctry_time_fmt);
#endif

  }
}


/*********************************************************************/
/* Routine:   datetime                                               */
/*                                                                   */
/* Function:  Put date and time in logfile.                          */
/*********************************************************************/

void datetime()
{
  struct DateTime buff;
  char date[12];
  char time[12];
  char datetimestring[25];
  WORD written = 0;

#if defined(DEBUG)
  printf("\nDOSGETDATETIME...");
#endif

  _dos_getdate( (struct dosdate_t *) ((char *)&buff + 4) );
  _dos_gettime( (struct dostime_t *)&buff);
  *((char *)&buff + 10) = *((char *)&buff + 8);
  *((int *)&buff + 4) = 360;
  rc = NOERROR;

#if defined(DEBUG)
  if (rc == NOERROR)
     printf("SUCCESSFUL");
   else
     printf("ERROR, RC=%04Xh", rc);
#endif

  /* Build time string */
  sprintf(time, "%u%c%02u%c%02u", buff.hour, ctry_time_sep, buff.minutes,
                                  ctry_time_sep, buff.seconds);

  /* Build date string */
  switch (ctry_date_fmt)
  {
    case USA:
      sprintf(date, "%u%c%02u%c%04u", buff.month, ctry_date_sep, buff.day,
                                      ctry_date_sep, buff.year);
      break;

    case EUR:
      sprintf(date, "%u%c%02u%c%04u", buff.day, ctry_date_sep, buff.month,
                                      ctry_date_sep, buff.year);
      break;

    case JAP:
      sprintf(date, "%04u%c%02u%c%02u", buff.year, ctry_date_sep, buff.month,
                                        ctry_date_sep, buff.day);
      break;

    default:
      break;
  }

  datetimestring[0] = 0x0d;
  datetimestring[1] = 0x0a;
  sprintf(datetimestring + 2, "%s  %s", date, time);

  written = handle_write(handle_logfile, strlen(datetimestring),
                         (char far *)&datetimestring[0]);
  if ( written != strlen(datetimestring) || (rc != NOERROR) )
  {
    display_msg(LOGFILE_TARGET_FULL);
    do_logfile = FALSE;
  }
}



/*********************************************************************/
/* Routine:   extended_open                                          */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

#define EXTENDEDOPEN	0x6c00

WORD extended_open(WORD flag, WORD attr, char far *path_addr, WORD mode)
{
  union REGS inreg, outreg;

  ea_parmlist.ext_attr_addr = (DWORD)(char far *)&ext_attrib_buff[0];
  ea_parmlist.num_additional = 0;

#if defined(DEBUG)
  if (flag == CREATE_IT)
    printf("\nEXTENDED OPEN - CREATE, FILE %s...", path_addr);
  else
    printf("\nEXTENDED OPEN - OPEN, FILE %s...", path_addr);
#endif

  rc = NOERROR;
  inreg.x.ax = EXTENDEDOPEN;
  inreg.x.bx = mode;                             /* M010 */
  inreg.x.cx = attr;
  inreg.x.dx = flag + NO_CP_CHECK;
  inreg.x.si = (WORD)path_addr;

  inreg.x.di = (WORD)&ea_parmlist;

  intdos(&inreg, &outreg);
  if (outreg.x.cflag & CARRY)          /* if there was an error */
    rc = outreg.x.ax;                  /* set the return code */

#if defined(DEBUG)
  if (outreg.x.cflag & CARRY)
    printf("ERROR, RC=%04Xh", outreg.x.ax);
  else
    printf("SUCCESSFUL, HANDLE=%04Xh", outreg.x.ax);
#endif

  return (outreg.x.ax);
}


#ifdef DBCS
/*********************************************************************/
/* Routine:   IsDBCSLeadByte                                         */
/*                                                                   */
/* Function:  Test if the character is a DBCS lead byte.             */
/*                                                                   */
/*      input:  c = character to test                                */
/*      output: TRUE if leadbyte                                     */
/*********************************************************************/

int IsDBCSLeadByte(unsigned char c)
{
  static unsigned char far *DBCSLeadByteTable = NULL;
  union REGS inregs, outregs;
  struct SREGS segregs;
  unsigned char far *p;
  int stat;

  if (DBCSLeadByteTable == NULL)
  {
    inregs.x.ax = 0x6300;              /* get DBCS lead byte table */
    intdosx(&inregs, &outregs, &segregs);
    FP_OFF(DBCSLeadByteTable) = outregs.x.si;
    FP_SEG(DBCSLeadByteTable) = segregs.ds;
  }

  p = DBCSLeadByteTable;
  stat = FALSE;
  while (p[0] || p[1])
  {
    if (c >= p[0] && c <= p[1])
    {
      stat = TRUE;
      break;
    }
    p += 2;
  }

  /*
   *  Since the DOSCALL for 'xlat' & 'extended_open' needs
   *  to set ES & DS register, but they are using 'intdos'
   *  instead of 'intdosx', so we must set ES here.
   */
  p = (char far *)src_drive_path;      /* get DS value */
  if (*p) {}                           /* ES <- DS */

  return (stat);
}


/*********************************************************************/
/* Routine:   CheckDBCSTailByte                                      */
/*                                                                   */
/* Function:  Check if the character point is at the tail byte.      */
/*                                                                   */
/*      input:  *str = strart pointer of the string                  */
/*              *point = character pointer to check                  */
/*      output: TRUE if at the tail byte                             */
/*********************************************************************/

int CheckDBCSTailByte(unsigned char *str, unsigned char *point)
{
  unsigned char *p;

  p = point;
  while (p != str)
  {
    p--;
    if (!IsDBCSLeadByte(*p))
    {
      p++;
      break;
    }
  }
  return ((point - p) & 1 ? TRUE : FALSE);
}
#endif


/*********************************************************************/
/* Routine:   check_asj                                              */
/*                                                                   */
/* Function:                                                         */
/*********************************************************************/

void check_asj()
{
  struct SREGS sreg;
  union REGS reg;
  char buf1[128];
  char buf2[128];

  /*
   *  Make sure source is not Assigned, Substed, or Joined and 
   *  therefore equal to target
   */
  segread(&sreg);
  reg.x.si = (unsigned)buf1;
  reg.x.di = (unsigned)buf2;
  reg.x.ax = 0x6000;
  buf1[0] = src_drive_letter;
  strcpy(buf1 + 1, ":\\");
  intdosx(&reg, &reg, &sreg);
  if (*buf2 == tgt_drive_letter)  
    error_exit(SRCISTGT);

  /* Make sure target is not A/S/J and therefore equal to source */
  segread(&sreg);  
  reg.x.si = (unsigned)buf1; 
  reg.x.di = (unsigned)buf2; 
  reg.x.ax = 0x6000;
  buf1[0] = tgt_drive_letter; 
  intdosx(&reg, &reg, &sreg); 
  if (*buf2 == src_drive_letter)  
    error_exit(TGTISSRC); 
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;

; CHKDSK	Version 2.0
; Verifies and repairs MS-DOS disk directory.


;REV 1.1	ARR
;     05/21/82	Added rev number
;REV 1.5	NP ARR
;	Mod by NANCYP to report on extents
;	Mod by AARONR to report volume ID
;REV 2.0	ARR
;	Total rewrite for directories
;REV 2.1	ARR
;	Added ^C and INT 24H handlers
;REV 2.2	ARR
;	INTERNATIONAL support
;REV 2.3	NP
;	Mod by NANCYP to use 2.0 system calls
;	and accept pathnames as parameters
;REV 2.4	NP
;	PRINTF incorporated into CHKDSK
;	Modified to run as .EXE file
;REV 3.0	ARR	8/30/83
;	Update for vers 2.5 of DOS
;	16 bit FATS
;REV 3.05	RS     10/11/84
;	Split into CHKDSK2.ASM for on-machine assembly.
;REV 3.20	RS	9/26/85
;	Allow 0F0H as a valid DOS media descriptor byte - used for non-standard
;	media layouts.
;
;*****************************************************************************
;*									     *
;* Change list to CHKDSK  modules					     *
;*									     *
;* Lines are tagged ANxxx for new, ACxxx for changed			     *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*	   Date: 8/3/87    Developer: Mark Tyson			     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 PTM P265 - Give 'Can't chkdsk subst drive" when running   *
;*	  hardfile. Using 1 based drive insted of 0			     *
;*	  Date: 8/17/87    Developer: Mark T.				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  002 - DOS 4.00 PTM P251 - Hang when chkdsk default drive. Not setting up *
;*	  drive fields correctly on default drive			     *
;*	  Date: 8/14/87    Developer: Mark T.				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;*									     *
;*									     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 005 - DOS 4.00 DCR D166 - Enable 128k FAT				     *
;*	 Date: 8/21/87	   Developer: Bruce B.				     *
;* general modifications are: reserve the rest of the program segment for the*
;*	stack, put the fat-table next after the end of the program seg, then *
;*	put the fatmap area next after the end of the fat-table.	     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 006 - DOS 4.00 ptm p097 - change calculation of total disk space	     *
;*	 Date: 8/28/87	   Developer: Bruce B.				     *
;*	 modules - chkinit.sal, chkdsk2.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 007 - DOS 4.00 ptm p816 - files with length zero			     *
;*	 Date: 8/21/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 008 - DOS 4.00 ptm p872 - incorrect media size reported		     *
;*	 Date: 9/10/87	   Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 009 - DOS 4.00 ptm p1151- incorrect date and time			     *
;*	 Date: 9/10/87	   Developer: Bruce B.				     *
;*	 modules - chkdsk1.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 010 - DOS 4.00 ptm p1158- incorrect disk size when disk is full	     *
;*	 Date: 9/10/87	   Developer: Bruce B.				     *
;*	 modules - chkfat.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 011 - DOS 4.00 ptm p817 - cant check files				     *
;*	 Date: 9/24/87	   Developer: Bruce B.				     *
;*	 modules - chkdsk1.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 012 - DOS 4.00 ptm p1223- month and day reversed			     *
;*	 Date: 9/22/87	   Developer: Bruce B.				     *
;*	 modules - chkdsk1.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 013 - DOS 4.00 ptm p1238- not detect filesize <> number of clusters	     *
;*	 Date: 9/25/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal, chkdisk.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*     - DOS 4.00 ptm p1239- hangs when file has invalid ???		     *
;*	 Date: 9/25/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal, chkdisk.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 014 - DOS 4.00 ptm p1240- not detect crosslinked files		     *
;*	 Date: 9/25/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal, chkfat.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*     - DOS 4.00 ptm p1241- hangs when trying to fix lost subdir	     *
;*	 Date: 9/25/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal, chkfat.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*     - DOS 4.00 ptm p1242- hangs when lost subdir found		     *
;*	 Date: 9/25/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal, chkfat.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 015 - DOS 4.00 ptm p1176 - not working for vdisk drives		     *
;*	 Date: 10/1/87	   Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 016 - DOS 4.00 ptm p1436 - not working for full disk with system files    *
;*	 Date: 10/2/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*     - DOS 4.00 ptm p1437 - not working on vdisk			     *
;*	 Date: 10/2/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*     - DOS 4.00 ptm p1447 - chkdsk filenam --> invalid drive spec	     *
;*	 Date: 10/2/87	   Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 017 - DOS 4.00 ptm p1491 - invalid use of common msgs 		     *
;*	 Date: 10/5/87	   Developer: Bruce B.				     *
;*	 modules - chkdsk.skl chkmsg.inc				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 018 - DOS 4.00 ptm p1507 - 'non_dos' instead of 'non-dos'                 *
;*	 Date: 10/6/87	   Developer: Bruce B.				     *
;*	 modules - chkdsk.skl						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 019 - DOS 4.00 ptm p1506 - '0 bytes would be freed'                       *
;*	 Date: 10/6/87	   Developer: Bruce B.				     *
;*	 modules -							     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 020 - DOS 4.00 ptm p1556 - chkdsk allows 2 positional or keyword parms    *
;*	 Date: 10/8/87	   Developer: Bruce B.				     *
;*	 modules - chkparse.inc 					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 021 - DOS 4.00 ptm p1557 - displays invalid drive spec twice		     *
;*	 Date: 10/8/87	   Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 022 - DOS 4.00 ptm p1558 - divide overflow on invalid drive		     *
;*	 Date: 10/8/87	   Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 023 - DOS 4.00 ptm p1559 - abnormal results when int13 is bad 	     *
;*	 Date: 10/8/87	   Developer: Bruce B.				     *
;*	 modules -							     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 024 - DOS 4.00 ptm p1606 - no display of volume serial number 	     *
;*	 Date: 10/12/87    Developer: Bruce B.				     *
;*	 modules - chkdsk2.sal, chkmsg.inc				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 025 - DOS 4.00 ptm p1761 - doesnt work on zerod out cluster for dir	     *
;*	 Date: 10/17/87    Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 026 - DOS 4.00 ptm p1842 - chkdsk accepts 2 filespec parms		     *
;*	 Date: 10/20/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal, chkparse.inc				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 027 - DOS 4.00 ptm p2007 - test case 7 - chkdsk a: /v  (invalid subdirs)  *
;*	 Date: 10/24/87    Developer: Bruce B.				     *
;*	 modules - chkproc.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 028 - DOS 4.00 ptm p2029 - chkdsk cant exec for afs			     *
;*	 Date: 10/26/87    Developer: Bruce B.				     *
;*	 modules - chkexec.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 029 - DOS 4.00 ptm p2104 - chkdsk goes to drive a: on ctl-break	     *
;*	 Date: 10/29/87    Developer: Bruce B.				     *
;*	 modules - chkfat.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 030 - DOS 4.00 ptm p2323 - low memory check, correct free memory report   *
;*	 Date: 11/04/87    Developer: Bruce B.				     *
;*	 modules - chkfat.sal, chkdsk2.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 031 - DOS 4.00 ptm p2495 - incorrect message for drive not ready	     *
;*	 Date: 11/17/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 032 - DOS 4.00 ptm p2648 - unformatted disk displays "invalid device type" *
;*	 Date: 11/24/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 033 - DOS 4.00 ptm p2781 - divide overflow on unformatted diskette	     *
;*	 Date: 12/07/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 034 - DOS 4.00 ptm p2975 - get psp done three times			     *
;*	 Date: 12/20/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal, chkdsk1.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 035 - DOS 4.00 ptm p3007 - chkdsk reports incorrect memory		     *
;*	 Date: 12/28/87    Developer: Bruce B.				     *
;*	 modules - chkinit.sal, chkdsk1.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 036 - DOS 4.00 ptm p3028 - include pathgen into pgm			     *
;*	 Date: 01/12/88    Developer: Bruce B.				     *
;*	 modules - all							     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 037 - DOS 4.00 ptm p3129 - chkdsk fails to build			     *
;*	 Date: 01/14/88    Developer: Bruce B.				     *
;*	 modules - chkdisp.asm						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 038 - DOS 4.00 ptm p3130 - remove AFS from code			     *
;*	 Date: 01/14/88    Developer: Bruce B.				     *
;*	 modules - chkinit.sal, chkequ.inc, chkexec.sal 		     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 039 - DOS 4.00 ptm p3360 - correct addressing of ctl-break handling	     *
;*	 Date: 02/05/88    Developer: Bruce B.	 			     *
;*	 modules - chkproc2.sal 					     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 040 - DOS 4.00 ptm p3573 - pathgen parser and msg ret.		     *
;*	 Date: 02/19/88    Developer: Bruce B				     *
;*	 modules - chkdisp.asm, chkparse.inc				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 041 - DOS 4.00 dcr d490  - change get media id call for same as os/2 1.0   *
;*	 Date: 02/26/88    Developer: Bruce B				     *
;*	 modules - chkdata.inc, chkdsk1.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 042 - DOS 4.00 ptm p3735 - chkdsk prints files to stderr, not stdout	     *
;*	 Date: 03/04/88    Developer: Bruce B				     *
;*	 modules - chkmsg.inc						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 043 - DOS 4.00 ptm p3708 - chkdsk prints wrong message for network drive   *
;*	 Date: 03/07/88    Developer: Bruce B				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 044 - DOS 4.00 ptm p3840 - wrong message for newtork filename 	     *
;*	 Date: 03/14/88    Developer: Bruce B				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 045 - DOS 4.00 ptm p3876 - hang when .. entry erased and /f parameter      *
;*	 Date: 03/15/88    Developer: Bruce B				     *
;*	 modules - chkproc.sal, chkdsk2.sal, chkmsg.inc, chkfat.sal	     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 046 - DOS 4.00 ptm p3923?- display invalid parm names 		     *
;*	 Date: 03/21/88    Developer: Bruce B				     *
;*	 modules - chkinit.sal, chkmsg.inc				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 047 - private build only- display lost cluster number		     *
;*	 Date: 03/24/88    Developer: Bruce B				     *
;*	 modules - chkfat.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 048 - DOS 4.00 PTM p4050 - wont recover . and .. entries		     *
;*	 Date: 04/12/88    Developer: Bruce B				     *
;*	 modules - many 						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 049 - DOS 4.00 PTM p4125 - chkdsk prints incorrect user file bytes	     *
;*	 Date: 04/13/88    Developer: Bruce B.				     *
;*	 modules - many 						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 050 - DOS 4.00 PTM p4571 - chkdsk and mem report diff ram under Windows    *
;*	 Date: 05/02/88    Developer: Bruce B.				     *
;*	 modules - chkdsk1.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 051 - DOS 4.00 PTM p4571 - chkdsk does not recover lost clusters into files*
;*	 Date: 05/05/88    Developer: Bruce B.				     *
;*	 modules - chkfat.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 052 - DOS 4.00 PTM p4869 - handle MS ramdrive.sys			     *
;*	 Date: 05/16/88    Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 053 - DOS 4.00 PTM p4924 - oops! do it right this time....		     *
;*	 Date: 05/19/88    Developer: Bruce B.				     *
;*	 modules - chkinit.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 054 - DOS 4.00 PTM p4957 - both chkdsk & mem do avail mem incorrectly     *
;*	 Date: 05/24/88    Developer: Bruce B.				     *
;*	 modules - chkdsk1.sal						     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;* 055 - DOS 4.00 PTM p5007 - wont handle '\' as 2nd byte of dbcs pair       *
;*	 Date: 06/01/88    Developer: Bruce B				     *
;*	 modules - chkdsk1.sal, chkinit.sal				     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*									     *
;*****************************************************************************
;* Note: This is file CHKCHNG.INC for updating purposes 		     *
;*****************************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkdisp.asm ===
page	,132	;								;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*****************************************************************************	;
;*****************************************************************************	;
;UTILITY NAME: CHKDSK.EXE							;
;										;
;MODULE NAME: DISPLAY.ASM							;
;										;
;										;
; Designed:  Mark T.	 							;
;										;
; Change List: AN000 - New code DOS 3.3 spec additions				;
;	       AC000 - Changed code DOS 3.3 spec additions			;
;*****************************************************************************
								
	EXTRN	command_line_buffer:byte				
;*****************************************************************************
; Include Files 
;*****************************************************************************
.xlist		
include pathmac.inc		
include chkseg.inc	
INCLUDE CPMFCB.INC
INCLUDE CHKEQU.INC
.list			
INCLUDE CHKMSG.INC
.xlist		
INCLUDE SYSMSG.INC	
.list

;/*M002 Begin */
;/* BUGBUG */ nagara
; Note the size of stack- This is being used as the "secbuf" to read in dir
; entries one sector by sector. This will bomb if the sector size is more than
; 1k and the dir tree is deep (so that stack overwrites mem above this 1k on
; recursive calls) ; to be fixed later
;/* BUGBUG END */ nagara - 1/20/90

cstack	 segment para stack 'STACK'
	db	2048  dup( 0 )    ; (362-80h) is the additional IBM ROM  
cstack	 ends									;
;/*M003 END */
										;
										;
;*****************************************************************************	;
; Message Services								;
;*****************************************************************************	;
MSG_UTILNAME  <CHKDSK>
										;
;.xlist 			

data	segment public para 'DATA'
Msg_Services	<MSGDATA>
data	ends									;
										;
code	segment public para 'CODE'     

pathlabl	msgret			
Msg_Services	<NEARmsg>			
Msg_Services	<LOADmsg>				
Msg_Services	<DISPLAYmsg,GETmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg>   ;/* M002 */
pathlabl	msgret		
Msg_Services	<CHKDSK.CLA,CHKDSK.CLB,CHKDSK.CLC,CHKDSK.CLD,CHKDSK.CL1,CHKDSK.CL2,CHKDSK.CTL> 

code	ends									;
.list										;
										;
;										;
;*****************************************************************************	;
; Public Declarations								;
;*****************************************************************************	;
	Public	SysLoadMsg		
	Public	SysDispMsg			
	Public	SysGetMsg			; /* M002 */
										;
										;
;										;
;***************************************************************************	;
; Message Structures								;
;***************************************************************************	;
Message_Table struc				;
Entry1	dw	0				;
Entry2	dw	0				;
Entry3	dw	0				;
Entry4	dw	0				;
Entry5	db	0				;
Entry6	db	0				;
Entry7	dw	0				;
Message_Table ends				;	
	
code	segment public para 'CODE'              ;                               ;
;*****************************************************************************	;
;Routine name&gml Display_Interface						;
;*****************************************************************************	;
;										;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg	;
;	      routine. This information is contained in a message description	;
;	      table pointed to by the DX register. Call SysDispMsg, then	;
;	      restore registers. This routine assumes that the only time an	;
;	      error will be returned is if an extended error message was	;
;	      requested, so it will ignore error returns			;
;										;
;Called Procedures: Message (macro)						;
;										;
;Change History&gml Created	   4/22/87	   MT				;
;										;
;Input&gml ES&gmlDX = pointer to message description				;
;										;
;Output&gml None								;
;										;
;Psuedocode									;
;----------									;
;										;
;	Save all registers							;
;	Setup registers for SysDispMsg from Message Description Tables		;
;	CALL SysDispMsg 							;
;	Restore registers							;
;	ret									;
;*****************************************************************************	;
Public	Display_Interface	

Display_Interface   proc		
	push	bp				; /* M005 */
	push	ds				
	push	es				; /* M005 */
	push	ax	
	push	bx		
	push	cx			
	push	dx				
	push	si					
	push	di						
	mov	di,dx				;Change pointer to table
	mov	dx,dg				;Point to group 
	mov	ds,dx				;	
	mov	ax,[di].Entry1			;Message number 
	mov	bx,[di].Entry2			;Handle 
	mov	si,[di].Entry3			;Sublist
	mov	cx,[di].Entry4			;Count
	mov	dh,[di].Entry5			;Class	
	mov	dl,[di].Entry6			;Function
	mov	di,[di].Entry7			;Input		
	call	SysDispMsg			;Display the message
	pop	di
	pop	si
	pop	dx	
	pop	cx				
	pop	bx			
	pop	ax			
	pop	es				; /* M005 */
	pop	ds			
	pop	bp				; /* M005 */
	ret					;All done	
Display_Interface      endp			;	
						
include msgdcl.inc

code	ends									;
	end									;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkdsk1.asm ===
;==================================================================
; CHKDSK1.ASM
;
; CHANGE HISTORY:
; M003   NSM	1/30/91		 Initialise TOP_OF_MEM from DS:2 on load
; 
; M005	 NSM	2/24/91		 Commit STDOUT so that if Chkdsk's output
;				  is redirected, we won't get a lost alloc.
;				  chain error
;==================================================================

 TITLE   CHKDSK - MS-DOS Disk consistancy checker ;
page    ,132                                    ;

	.xlist
	include chkseg.inc                                                      ;an005;bgb
	INCLUDE CHKCHNG.INC
	INCLUDE DOSSYM.INC
	INCLUDE syscall.inc                                                     ;an041;bgb
	include bpb.inc       ; ioctl needs def of A_BPB
	INCLUDE ioctl.inc                                                       ;an041;bgb;an041;bgb
	INCLUDE CHKEQU.INC
	INCLUDE CHKMACRO.INC
	include curdir.inc    ; need dirstrlen def for chkdata.inc
	include intnat.inc    ; need various INTERNAT defs for chkdata.inc
	include chkdata.inc                                                     ;an005;bgb
	include pathmac.inc
	include dpb.inc       ; need all the DPB defs for this very module

CODE    SEGMENT PUBLIC PARA 'CODE'
ASSUME  CS:DG,DS:NOTHING,ES:DG,SS:dg
 EXTRN  INT_23:NEAR,   readft:near          ;an005;bgb
 EXTRN  FATAL:NEAR, PROMPTYN:NEAR, GET_CURRDIR:NEAR
 extrn  calc_fatmap_seg:near, FINDCHAIN:NEAR, CHECKERR:NEAR, DIRPROC:NEAR
 extrn  CHKMAP:NEAR, Main_Init:Near                                          ;an049;bgb
 EXTRN  CHKCROSS:NEAR, AMDONE:NEAR, UNPACK:NEAR, GET_THISEL2:NEAR
 EXTRN  PRINTF_CRLF:NEAR, DOCRLF:NEAR, REPORT:NEAR
 extrn  init_fatmap:near, CHKPRMT_END:near                                      ;an005;bgb
 extrn  hook_interrupts:near
 extrn  CHECK_DBCS_CHARACTER:NEAR                                               ;an055;bgb

public SETSTACK, OkDrive, DRVISOK, Root_CD_Ok, NOTVOLID, fat16b, SMALLFAT
public BAD_STACK, RDLOOP, NORETRY1, RDOK, IDOK, ALLDONE, CHECKFILES, GotPath
public IS_ROOT_DIR, NOT_ROOT_DIR, VALID_PATH, ParseName, ScanFile, FRAGCHK
public EACHCLUS, LASTCLUS, NXTCHK, GETNXT, MSGCHK, FILSPOK, CDONE, CDONE1
public PRINTID, FIGREC, Main_Routine, checkit
	.list


	pathlabl chkdsk1
CHKDSK:
; find out if we have enough memory to do the job
    mov     cs:save_drive,al            ;save drive validity
    DOS_Call GetCurrentPSP                  ;Get PSP segment address            
    mov     cs:psp_segment,bx                                                 
    mov     ds,bx                           ;ds points to the psp            

    Assume  DS:Nothing

    MOV     DX,DS:[2]                   ; High break
    mov     cs:[top_of_mem],dx		; M003 move it into data area


    MOV     BX,0FFFFH                   ;need at least 64k bytes
    MOV     CX,CS           		;get segment of where we are
    SUB     DX,CX           		;top-of-mem  -  pgm  = 
					;       # para left in alloc block
    CMP     DX,1000H        ; is the space available > 64K ?
;   $IF     B
    JNB $$IF1
	MOV     CX,4            ; NO, Set stack to top of mem
	SHL     DX,CL           ; Convert remaining memory to bytes
	MOV     BX,DX
	DEC     BX
;   $ENDIF
$$IF1:
SETSTACK:              ;***Set_Memory*********
    CLI
    PUSH    CS
    POP     SS
ASSUME  SS:DG
    MOV     SP,BX
    STI
; at this point, DS = PSP; and BX = FFFF if avail mem > 64k
	MOV     CX,4
	SHR     BX,CL
	INC     BX              ; no of paras we actually need
	PUSH    AX
	mov     ax,cs
	add     bx,ax
	mov     ax,es
	sub     bx,ax           ; bx = memory used by chkdsk + PSP-currentCS
	mov     ax,4a00h        ; release unwanted mem
	int     21h             ;

; see where we are loaded ; 
; if we are loaded in UMBs, then try allocating for 0FFFF paras of mem
; and store the max value we get as free mem size
; The reason this is done here is that we allocate mem later on for
; FAT tables and so if we execute this code later on at end of chkdsk
; we will get an incorrect figure.

	push	es
	mov	ax,5200h		; get DOS DATA AREA
	int	21h			; ES:0 -> DOS DATA AREA
	mov	di,UMB_PTR		; ES:di -> umb_head 
	mov	ax,es:[di]		; ax = umb_head	
	pop	es
	cmp	ax,cs:psp_segment	; where are we loaded ? conv. ?
	ja	end_mem_init		

; we are loaded in UMBs. try allocating  0ffff paras of mem and store the
; available free as the FREE mem.
; substract ENV.block size from this free mem

;	push	ax			; save umb_head for later use
	mov	ah,48h			; allocate mem
	mov	bx,0ffffh		; try to get all mem
	int	21h			; Always CY - we can never get 1M mem	
	mov	cs:[max_free],bx	;
;	pop	ax			;
;	cmp	ax,word ptr ds:[2ch]	; look at env.ptr
;	ja	end_mem_init		; if env in conv. no adj. necessary

;	push	ds			; env also in UMB
;	mov	ax,word ptr ds:[2ch]	; ax = env. seg. 
;	dec	ax			; get to the env. arena ptr
;	mov	ds,ax			
;	mov	ax,ds:[3]		; get the size of env.
;	pop	ds
;	sub	cs:[max_free],ax	; free mem = free block - env. block
;
end_mem_init:
; /* M003 END */

JMP     Main_Init                       ;Go to init routines


;**************************************************************************
; MAIN-ROUTINE
;
; called by - main-init
;
; LOGIC
; *****
;       - get the dpb addr
;       - set the default drive to here
;       - save the directory we are on
;       - set the directory to the root of the drive
;       - print the volume name
;       - get the dpb info
;       - get the addr of the fatmap area
;       - calculate the amount of stack space we have
;**************************************************************************
Main_Routine:
    set_data_segment
OkDrive:
;get the dpb addr  from this drive
    mov      dl,AllDrv                       ;Get drive number               ;AN000;
    DOS_Call Get_DPB             ;func 32    ;Get DPB pointer                ;AC000;
    ASSUME  DS:NOTHING,cs:DG
    CMP     AL,-1                          ;is this a good drive?
;   $IF  Z
    JNZ $$IF3
;;;;;;;;JNZ     DRVISOK                    ;Bad drive (should always be ok)
	LEA     DX,BADDRV_arg              ;This should never happen            ;AC000;
	push    cs
	pop     ds
	call    PRINTf_crlf                    ;                               ;AC000;
	mov     ExitStatus,Bad_Exit     ;Get return code                        ;AC000;
	ret                                     ;Go back to Main_Init           ;AC000;
;   $ENDIF
$$IF3:
    MOV     WORD PTR CS:[THISDPB+2],DS      ;get the dpb segment
    set_data_segment                        ;reset ds to the pgm
    MOV     WORD PTR [THISDPB],BX           ;get the dpb offset

;**Set_Drive_Info*************************************************************
DRVISOK:
    push    dx
    push    es
    call    hook_interrupts
    pop     es
    pop     dx
; make this drive the default drive
    DEC     DL                              ;A=0 b=1 c=2
    DOS_Call        Set_Default_Drive       ;func 0e - no return               ;AC000;

;get the name of the current directory
    INC     DL                              ;drive number a=1 b=2 c=3
    LEA     SI,USERDIR+1                    ;                               ;AC000;
    DOS_Call        Current_Dir             ;                               ;AC000;
;;;;PUSH    CS
;;;;POP     ES

;change the current directory to the root
    lea     DX,rootstr                  ;                                       ;an005;bgb
    DOS_Call        ChDir                   ;                               ;AC000;
;   $IF     C                           ;will this ever happen?
    JNC $$IF5
;;;;;;;;jnc     Root_CD_Ok                      ;                               ;AN000;
	MOV     DX,OFFSET DG:BADCD_arg
	call    display_interface                      ;                               ;AC000;
	mov     ExitStatus,Bad_Exit     ;Get return code                       ;AC000;
	ret                                     ;Go back to Main_Init          ;AC000;
;   $ENDIF
$$IF5:

;get the dpb info
    LDS     BX,[THISDPB]                ;ds:bx--> dpb area
    ASSUME  DS:NOTHING
    MOV     AX,[BX.dpb_sector_size]     ;Bytes/sector
    MOV     [SSIZE],AX                  ;Sector size in bytes
    MOV     AL,[BX.dpb_cluster_mask]
    INC     AL
    MOV     [CSIZE],AL                  ;Sectors per cluster
    MOV     AX,[BX.dpb_max_cluster]     ; number of clusters in the disk
    MOV     [MCLUS],AX                  ;Bound for FAT searching
    DEC     AX                      ;ax= max clusters - 1                       ;an005;bgb
    MOV     [DSIZE],AX              ;Total data clusters on disk                ;an005;bgb
    CMP     AX,4096-8                   ;Big or little FAT?
;   $IF     NB
    JB $$IF7
fat16b: INC     es:[BIGFAT]                ;set 16-bit fat flag to true
	MOV     es:[EOFVAL],0FFF8H         ;set 16-bit compare fields for fat
	MOV     es:[CHAIN_END],0FFFFh              ;Marker for end of chain        ;AC000;
	MOV     es:[BADVAL],0FFF7H         ;set 16-bit compare fields for fat
;   $ENDIF
$$IF7:
    mov     ax,[bx.dpb_FAT_size]    ;Sectors for one fat (DCR)                  ;an005;bgb
    mov     fatsiz,ax               ;Sectors for one fat (DCR)                  ;an005;bgb
    MOV     CL,[BX.dpb_FAT_count]          ;Number of FATs                      ;an005;bgb
    mov     fatcnt,cl                                                           ;an005;bgb
    MOV     DX,[BX.dpb_first_FAT]          ;First sector of FAT                 ;an005;bgb
    MOV     firstfat,dx                    ;First sector of FAT                 ;an005;bgb
    MOV     DX,[BX.dpb_first_sector]       ;First sector of data                ;ac048;bgb
    MOV     firstsec,dx                    ;First sector of data                ;ac048;bgb
    MOV     DX,[BX.dpb_dir_sector]       ;First sector of dir                   ;ac048;bgb
    MOV     dirsec,dx                    ;First sector of dir                   ;ac048;bgb
    MOV     DX,[BX.dpb_root_entries]     ;First sector of dir                   ;ac048;bgb
    MOV     root_entries,dx                      ;First sector of dir           ;ac048;bgb
    set_data_segment                    ;reset ds to point to data area

;calc fatmap area
SMALLFAT:           ;do this for both size fats
    ;old calculation
    ;;;;DEC     AX                      ;ax= max clusters - 1                       ;an005;bgb
    ;;;;MOV     [DSIZE],AX              ;Total data clusters on disk                ;an005;bgb
    ;;;;MOV     AX,[BX.dpb_FAT_size]    ;Sectors for one fat (DCR)                  ;an005;bgb
    ;;;;MOV     CX,AX                   ;CX = Sectors/Fat                           ;an005;bgb
    ;;;;MUL     [SSIZE]                 ;times bytes/sector = bytes per fat         ;an005;bgb
    ;;;;ADD     fatmap,AX             ;Allocate FAT space                           ;an005;bgb
    ;;;;MOV     AX,fatmap                ;  get seg of fatmap                       ;an005;bgb

Root_CD_Ok:                                      ;                              ;AN000;
;set dta area----do i need to do this since we are using int 25?
;set it to fat table
    call    calc_fatmap_seg         ;find the addr of where to put the fat map
				    ; CY if mem alloc failed
    jnc $$IF9
	MOV     DX,OFFSET DG:no_mem_arg
	invoke  printf_crlf
	jmp     alldone              ;finished with pgm
$$IF9:
    push    ds                          ;save ds
    mov     ds,fattbl_seg               ;get seg
    xor     dx,dx                       ;ds:dx--> dta area
    DOS_Call        Set_DMA             ;function 1a                        ;AC000;
    pop     ds                          ;restore ds

;look for volume entry in dir
    lea     DX,volid                        ;Look for VOL ID                    ;an005;bgb
    DOS_Call        Dir_Search_First        ;function 11                    ;AC000;
    CMP     AL,0                        ;did we find it?
;   $IF     Z                           ;yes
    JNZ $$IF11
;;;;;;;;JZ      NOTVOLID
	CALL    PRINTID                 ;print volume name, date, time
;   $ENDIF
$$IF11:
NOTVOLID:
    call    get_serial_num              ;print volume serial number             

;/* M005 -NSM----------------------------------------------------
; If Chkdsk's output is redirected, we will get a lost alloc.chain error
; TO avoid this, commit STDOUT so that the first cluster for the redir.file
; gets written to disk.
; Note that this should not cause any problem, when it is not redirected,
; this call will return success (but will not do anything) for char.devices

	mov	ah,68h			; commit STDOUT
	mov 	bx,1
	int	21h

; /* M005 END */

;*********************************************************
;/* commented out portion */
;;;;call    hook_interrupts
; calculate the place where we run out of ram space                             
;;;;ADD     AX,[MCLUS]      ;5000    ;fatmap seg + num of clusters?            
;;;;ADD     AX,2            ;5002   ;Insurance                                  
;;;;MOV     [SECBUF],AX             ;Allocate fatmap space                      

; BUGBUG - Nagara 1/21/91
; SecBuf actually points into the CSTACK segment (which is NOT USED at all)
; I declared a buf of 2k in CSTACK to avoid problems (possible hang,disk
; corruption). CSTACK seg can be removed totally and secbuf can be allocated
; through allocate calls (postponed to 5.1)

    mov     ax, offset dg:chkprmt_end 
			;this label must be the last thing in the code segment
    mov     [secbuf],AX          ;location of read/write buffer for dir entries 

;;;;ADD     AX,[SSIZE]      ;5202                                               
;;;;ADD     AX,20           ;5216   ;Insurance                                  
;
;/* M002 BEGIN */
    lea     ax,fattbl       	;get end of program
    MOV     [STACKLIM],AX       ;Limit on recursion
; see if we have already overrun the stack
    MOV     DI,SP                    ;where is the stack pointer now?           
    SUB     DI,100H                 ; Want AT LEAST this much stack from        
				       ;  our current location                  
    CMP     DI,AX
;   $IF     B
    JNB $$IF13
;;;;;;;;JB      BAD_STACK               ; Already in trouble
BAD_STACK:
	MOV     BX,StackMsgNo   ;Out of stack
	PUSH    CS
	POP     DS
	JMP     FATAL
;   $ENDIF
;/*M002 END */
$$IF13:

;
;**Read in FAT*****************************************************************
    mov     cx,fatsiz                   ;number of sectors to read              
    mov     dx,firstfat                 ;starting sector number                 
    mov     es,fattbl_seg   ;set up bx for read-disk                            
    xor     bx,bx                                                               
    MOV     AL,[ALLDRV]     ;set up al with drive letter for read-disk
    DEC     AL              ;zero based
;;;;MOV     AH,1
RDLOOP:
;;;;XCHG    CX,DI                           ;DI has # of Fats
    call    readft                  ;   readft ();                              
;   $IF     C                       ; could the fat be read from disk?          ;AN005;bgb
    JNC $$IF15
	inc     byte ptr [nul_arg]                                              ;an005;bgb
;;;;;;;;mov     [fatal_arg2],offset dg:baddrvm                                  ;an005;bgb
	mov     [fatmsg2],offset dg:baddrvm                                  ;an005;bgb
	mov     BX,BadRdMsg             ;/*M002 */ 
	JMP     FATAL                   ;Couldn't read any FAT, BARF            ;an005;bgb
;   $ENDIF                          ;fat could be read from disk                ;AN005;bgb
$$IF15:

;   savereg <dx,cx,di,ax>                                                       ;an005;bgb
;   mov     Read_Write_Relative.Start_Sector_High,0 ;                       ;AN000;
;   call     Read_Disk               ;Read in the FAT                        ;AC000;
;   $IF      C
;;;;;;;;JNC     RDOK
;;;;;;;;mov     [badrw_str],offset dg:reading
;       POP     AX                      ; Get fat# in ah
;       PUSH    AX                      ; Back on stack
;       xchg    al,ah                   ; Fat # to AL
;       xor     ah,ah                   ; Make it a word
;       mov     [badrw_num],ax
;       mov     dx,offset dg:badr_arg
;       invoke  printf_crlf
;       restorereg <ax,cx,di,dx>                                                ;an005;bgb
;       INC     AH
;       ADD     DX,DI
;       LOOP    RDLOOP                  ;Try next FAT
;;;;;;;;JMP     NORETRY1                ;Couldn't read either                   ;AC000;
NORETRY1:
;       inc     byte ptr [nul_arg]
;       mov     [fatal_arg2],offset dg:baddrvm
;       MOV     BX,OFFSET DG:BADRDMES
;       JMP     FATAL                   ;Couldn't read any FAT, BARF
;   $ENDIF
RDOK:   ;**Check_for_FAT_ID**********************************************
;;;;restorereg <ax,ax,ax,ax>        ;Clean up                                   ;an005;bgb
    mov     es,fattbl_seg            ;segment of fat-table                      ;an005;bgb
    xor     si,si                    ;offset of first byte in fat-table         ;an005;bgb
;;;;LODSB                           ;Check FAT ID byte
    mov     al,byte ptr es:[si]     ;get first byte of fat table
    CMP     AL,0F8H                 ;is it the correct id byte?
;   $IF     B,AND
    JNB $$IF17
;;;;;;;;JAE     IDOK
    CMP     AL,0F0H                 ;if not, Is it a "strange" medium?
;   $IF     NZ
    JZ $$IF17
;;;;;;;;jz      IDOK                ;neither fat nor strange
	MOV     DX,OFFSET DG:BADIDBYT   ;FAT ID bad
	CALL    PROMPTYN                ;Ask user to stop or not
;       $IF     NZ
	JZ $$IF18
;;;;;;;;;;;;JZ      IDOK
	    JMP     SHORT ALLDONE                   ;User said stop
;       $ENDIF
$$IF18:
;   $ENDIF
$$IF17:

;initialize the fatmap area to all zeros
IDOK:
    call    init_fatmap

;set the dta addr to here for all searches
    MOV     DX,OFFSET DG:DIRBUF     ;FOR ALL SEARCHING
    DOS_Call        Set_DMA         ;                                       ;AC000;
    XOR     AX,AX                   ;zero out ax
    PUSH    AX                      ;I am root
    PUSH    AX                      ;Parent is root
;
    set_data_segment
checkit:
    CALL    DIRPROC
    CALL    CHKMAP                  ;Look for badsectors, orphans
    CALL    CHKCROSS                ;Check for second pass
    INVOKE  DOCRLF                   ;display new line
    CALL    REPORT                   ;finished, display data to screen

;*****************************************************************************
ALLDONE:
    CALL    AMDONE
;;;;;MOV     AH,EXIT
;;;;;;;;XOR     AL,AL
;;;;;; ;mov     ExitStatus,Bad_Exit     ;Get return code                        ;AC000;
;;;;;;;;INT     21H
	ret                             ;Ret to Main_Init for common exit       ;AN000;

ASSUME  DS:DG
;**Extent_Check***************************************************************
Break   <Check for extents in specified files>
;
; Search the directory for the files specified on the command line and report
; the number of fragmented allocation units found in each one.  We examine the
; given path name for a directory.  If it is found, we CHDIR to it.  In any
; event, we move to the file name part and do a parseFCB call to convert it
; into an FCB for a dir_search_first.  If the parse did NOT advance the
; pointer to the null byte terminating the string, then we have a bogus anme
; and we should report it.
;

CHECKFILES:
	set_data_segment
; see if there is a '\' in the path name
	MOV     DI,OFFSET DG:PATH_NAME
	MOV     SI,DI
	MOV     CX, FNAME_LEN           ;                                       ;an011;bgb
	ADD     DI,CX                   ; ES:DI points to char AFTER last char
	DEC     DI                      ; Point to last char
doagain: MOV     AL,[DIRCHAR]            ;try to find '\' in path name
	STD
	REPNE   SCASB
	CLD
;       $IF     Z                       ;a '\' was found in path                ;an055;bgb
	JNZ $$IF21
	    mov     al,[di]             ;get byte preceding '\'                 ;an055;bgb
	    call    check_dbcs_character ;see if dbcs leading char              ;an055;bgb
;           $IF     C                   ;carry means dbcs leading char          ;an055;bgb
	    JNC $$IF22
		jmp     doagain         ;so ignore                              ;an055;bgb
;           $ELSE                                                               ;an055;bgb
	    JMP SHORT $$EN22
$$IF22:
		jmp     SHORT GotPath   ;found a '\' and not dbcs               ;an055;bgb
;           $ENDIF                                                              ;an055;bgb
$$EN22:
;       $ENDIF                                                                  ;an055;bgb
$$IF21:
;;;;;;;;;;;;;;;;;;;;;JZ      GotPath                 ; found path char.         ;an055;bgb
; No '\' was found.  set up pointers for parse FCB call.
	MOV     DI,OFFSET DG:PATH_NAME
	CMP     BYTE PTR [DI+1],':'  ;was a drive letter entered?
	JNZ     ParseName
	ADD     DI,2
	JMP     SHORT ParseName

;*****************************************************************************
; found a '\' in the path name
;Change directories and set up the appropriate FCB
GotPath:
	INC     DI                      ; DI points AT the path sep
	PUSH    WORD PTR [DI]           ; Save two chars here
	PUSH    DI                      ; Save location
	SUB     SI,DI
	JZ      IS_ROOT_DIR             ; SI=DI=First char which is a dirchar
	NEG     SI
	CMP     SI,2
	JNZ     NOT_ROOT_DIR
	CMP     BYTE PTR [DI-1],':'     ; d:\ root spec?
	JNZ     NOT_ROOT_DIR            ; Nope
IS_ROOT_DIR:
	INC     DI                      ; Don't zap the path sep, zap NEXT char
NOT_ROOT_DIR:
	MOV     BYTE PTR [DI],0
	MOV     DX,OFFSET DG:PATH_NAME
	DOS_Call        Chdir           ;                                       ;AC000;
	POP     DI                      ; Recall loc
	POP     WORD PTR [DI]           ; recall chars
	JNC     VALID_PATH
	INVOKE  DOCRLF
	MOV     DX,OFFSET DG:INVPATH_arg
	invoke  printf_crlf
	JMP     CDONE1

;*****************************************************************************
VALID_PATH:
	INC     [DIR_FIX]
	INC     DI              ; Point past path sep to first char of name
ParseName:
; parse the filename and get back a formatted fcb for it in es:di
	MOV     SI,DI                 ; DS:SI points to name
	MOV     DI,offset dg:FCB_copy ; ES:DI points to FCB
	MOV     AL,ALLDRV             ; drive number
	STOSB                         ; put it into fcb
	DEC     DI                    ; Back to start of FCB
	MOV     pFileName,SI          ; save end of file name
	MOV     AL,00000010B          ; tell parse to change drive letter if needed
	DOS_Call        Parse_File_Descriptor   ;                               ;AC000;
	CMP     BYTE PTR [SI],0       ;ds:si should point past filename
	JZ      ScanFile
;
; Twiddle the file name to be truly bogus.  Zorch the drive letter
;
	MOV     BYTE PTR es:[DI],-1
ScanFile:
	INVOKE  DOCRLF
;set dma pointer to here
	MOV     DX,OFFSET DG:DIRBUF     ;FOR ALL SEARCHING
	MOV     BP,DX
	ADD     BP,27                   ;bp points to clus in the dir entry
	DOS_Call        Set_DMA         ;set dma ptr here for dir search         ;AC000;
;try to find the file specified
	MOV     AH,DIR_SEARCH_FIRST              ;Look for the first file
FRAGCHK:
	MOV     DX,offset dg:FCB_copy
	INT     21H
	OR      AL,AL                   ;Did we find it?
	JNZ     MSGCHK                  ;No -- we're done
; we found the file
; look for fragmentation
	XOR     AX,AX                   ;Initialize the fragment counter
	MOV     SI,[BP]                 ;Get the first cluster               ;an005;bgb
	CALL    UNPACK                  ;see what that cluster points to
	CMP     DI,[EOFVAL]             ;End-of-file?
	JAE     NXTCHK                  ;Yes -- go report the results
	INC     SI
	CMP     SI,DI
	JZ      EACHCLUS
	INC     AX
EACHCLUS:
	MOV     [OLDCLUS],DI            ;Save the last cluster found
	MOV     SI,DI                   ;Get the next cluster
	CALL    UNPACK
	INC     [OLDCLUS]               ;Bump the old cluster
	CMP     DI,[OLDCLUS]            ;Are they the same?
	JNZ     LASTCLUS                ;No -- check for end-of-file
	JMP     SHORT EACHCLUS          ;Continue processing
LASTCLUS:
	CMP     DI,[EOFVAL]             ;End-of-file?
	JAE     NXTCHK                  ;Yes -- go report the results
	INC     AX                      ;No -- found a fragement
	JMP     SHORT EACHCLUS          ;Continue processing
NXTCHK:               ;reached the end of a file
	OR      AX,AX                   ;did we find any fragmentation?
	JZ      GETNXT
;we found fragmentation
	MOV     [FRAGMENT],2            ;Signal that we output at least one file
	inc     ax                      ;bump by one for ends
	mov     [block_num],ax
	mov     word ptr rarg1,ax                ;                                       ;an011;bgb
	mov     word ptr rarg1+2,0
	mov     si,offset dg:dirbuf     ;point to filename                      ;an011;bgb
	INC     SI                      ;move pointer past drive letter
; get the full path name for this file
	CALL    get_THISEL2
; print it out
	mov     dx,offset dg:extent_arg
	invoke  printf_crlf
GETNXT:
	MOV     AH,DIR_SEARCH_NEXT          ;Look for the next file
	JMP     FRAGCHK
MSGCHK:
	CMP     AH,DIR_SEARCH_FIRST     ;was this the first file searched for?
	JNZ     FILSPOK
;       MOV     SI,offset dg:FCB_copy + 1   ;File not found error
;       CALL    get_THISEL2
	MOV     SI,pFileName
	CALL    get_currdir
	mov     dx,offset dg:OPNERR_arg
	invoke  printf_crlf                 ;bad file spec
	jmp     short cdone
FILSPOK:
	CMP     BYTE PTR [FRAGMENT],2
	JZ      CDONE
; all files were ok
	mov     dx,offset dg:NOEXT_arg
	invoke  printf_crlf
CDONE:
	CMP     BYTE PTR [DIR_FIX],0
	JZ      CDONE1
	MOV     DX,OFFSET DG:USERDIR
	DOS_Call        ChDir                   ;                               ;AC000;
CDONE1:
	RET



; This is the old parameter passing scheme                                      ;ac048;bgb
; inputs: AH - the sector number within the cluster                             ;ac048;bgb
;         BX - cluster number                                                   ;ac048;bgb
; output: DX - absolute sector number                                           ;ac048;bgb
;*****************************************************************************  ;ac048;bgb
; FIGREC - This procedure calculates the absolute sector number of a logical    ;ac048;bgb
;          drive, given any cluster number and the sector within that cluster.  ;ac048;bgb
;          You can use this to find the sector number for a file.               ;ac048;bgb
;                                                                               ;ac048;bgb
;          This procedure was entirely re-written for dos 4.0, since the        ;ac048;bgb
;          sector number can now be a DOUBLE word value.                        ;ac048;bgb
;                                                                               ;ac048;bgb
; called by: getent in chkproc                                                  ;ac048;bgb
;                                                                               ;ac048;bgb
; inputs: BX - cluster number                                                   ;ac048;bgb
;         AH - sector number within cluster                                     ;ac048;bgb
;         csize - sectors per cluster (from dpb)                                ;ac048;bgb
;         firstsec - starting sector number of the data area (from dpb)         ;ac048;bgb
;                                                                               ;ac048;bgb
;outputs: DX - absolute sector number (low order)                               ;ac048;bgb
;         INT26.start_sector_high     (hi  order)                               ;ac048;bgb
;                                                                               ;ac048;bgb
;regs changed: DX only                                                          ;ac048;bgb
;                                                                               ;ac048;bgb
;formula: cluster (3-fff7) * secs/cluster (1-8) = (3-7ffb8)                     ;ac048;bgb
;         + sector-offset (0-8) + first-sector (1-ffff) = (7ffb9-8ffbf)         ;ac048;bgb
;                                                                               ;ac048;bgb
; logic: 1. adjust the cluster number, since the 1st two clusters in the fat    ;ac048;bgb
;           are not used. cluster number can be from 3-fff7.                    ;ac048;bgb
;        2. get the sectors-per-cluster, and multiply it times cluster number   ;ac048;bgb
;           in AX.  since this is a word multiply, the high order number goes   ;ac048;bgb
;           into DX.                                                            ;ac048;bgb
;        3. add in the sector-number-within-the-cluster.  Each cluster          ;ac048;bgb
;           (usually) contains several sectors within a cluster.  This sector   ;ac048;bgb
;           number is that number.  It may be from zero to the max number of    ;ac048;bgb
;           sectors/cluster (which can be up to 8 so far on IBM systems).       ;ac048;bgb
;           Do an ADC in case there is a overflow of the word register.         ;ac048;bgb
;        4. add in the starting cluster number of the data area.  This now      ;ac048;bgb
;           gives you the logical sector number within that drive.              ;ac048;bgb
;*****************************************************************************  ;ac048;bgb
procedure figrec,NEAR                                                           ;ac048;bgb
	push    ax                 ;save registers                              ;ac048;bgb
	push    bx                 ;save registers                              ;ac048;bgb
	push    cx                 ;save registers                              ;ac048;bgb
										;ac048;bgb
	xor     ch,ch            ;clear out hi byte of sector-offset            ;ac048;bgb
	mov     cl,ah            ;move sector-offset into cx                    ;ac048;bgb
	mov     ax,bx              ;move cluster number into ax for mult        ;ac048;bgb
										;ac048;bgb
	xor     bh,bh              ;zero out bh                                 ;ac048;bgb
	mov     bl,csize           ;get sectors per cluster                     ;ac048;bgb
	dec     ax                 ; sub 2 for the 1st 2 unused clus in the fat ;ac048;bgb
	dec     ax                      ;                                       ;ac048;bgb
	mul     bx                 ;ax=low word, dx=hi word                     ;ac048;bgb
										;ac048;bgb
	add     ax,cx              ;add sector offset                           ;ac048;bgb
	adc     dx,0               ;inc hi word if overflow                     ;ac048;bgb
	add     ax,[firstsec]      ;add first data sector                       ;ac048;bgb
	adc     dx,0               ;inc hi word if overflow                     ;ac048;bgb
										;ac048;bgb
	mov     Read_Write_Relative.Start_Sector_High,dx ;save hi value         ;ac048;bgb
	mov     dx,ax            ;convert to old format- dx=low                 ;ac048;bgb
										;ac048;bgb
	pop     cx                                                              ;ac048;bgb
	pop     bx                                                              ;ac048;bgb
	pop     ax                                                              ;ac048;bgb
	RET                                                                     ;ac048;bgb
endproc figrec                                                                  ;ac048;bgb


;*****************************************************************************
SUBTTL  PRINTID - Print Volume ID info
PAGE
PRINTID:
ASSUME  DS:DG
	call    docrlf                          ;                               ;AN000;
;get volume name                                                                ;an012;bgb
	xor     si,si                   ;Point at DTA where find first just done;;an005;bgb
	lea     DI,arg_buf              ;Where to put vol name for message      ;AC000;
	add     si,DirNam               ;Point at the vol label name            ;AN000;
;;;;;;;;lea     DI,arg_buf              ;Point at vol label location in arg_Buf ;AC000;
	MOV     CX,11                   ; Pack the name
	push    ds                                                              ;an005;bgb
	mov     ds,fattbl_seg                                                   ;an005;bgb
	REP     MOVSB                   ; Move all of it
;get the year                                                                   ;an012;bgb
	xor     si,si                   ;Get back pointer to FCB                ;an009;bgb
	mov     ax,ds:[si].DirDat          ;yyyyyyym mmmddddd Put in SysDisp form  ;AN009;bgb
	and     ax,Year_Mask            ;yyyyyyy0 00000000                      ;AN000;
	shr     ax,1                    ;0yyyyyyy 00000000                      ;AN000;
	xchg    al,ah                   ;00000000 0yyyyyyy                      ;AN000;
	add     ax,1980                 ;                                       ;AN000;
	mov     es:Sublist_msg_Idmes.Sublist_Offset+(size Sublist_Struc),ax ;      ;AN009;bgb
;get the month                                                                  ;an012;bgb
	mov     ax,ds:[si].DirDat          ;yyyyyyym mmmddddd                      ;AN009;bgb
	and     ax,Month_Mask           ;0000000m mmm00000                      ;AN000;
	mov     cl,5                    ;                                       ;AN000;
	shr     ax,cl                   ;00000000 0000mmmm                      ;AN000;
	mov     cl,al                   ;0000mmmm                               ;AN000;
;get the day                                                                    ;an012;bgb
	mov     ax,ds:[si].DirDat          ;yyyyyyym mmmddddd                      ;AN009;bgb
	and     ax,Day_Mask             ;00000000 000ddddd                      ;AN000;
	mov     ah,cl                   ;0000mmmm 000ddddd                      ;AN000;
	xchg    ah,al                   ;make it display correctly              ;an012;bgb
	mov     es:Sublist_msg_Idmes.Sublist_Segment+(size Sublist_Struc),ax ;     ;AN009;bgb
;get the time                                                                   ;an012;bgb
	mov     ax,ds:[si].DirTim          ;hhhhhmmm mmmsssss                      ;AN009;bgb
	and     ax,Hour_Mask            ;hhhhh000 00000000                      ;AN000;
	mov     cl,11                   ;                                       ;AN000;
	shr     ax,cl                   ;00000000 000hhhhh                      ;AN000;
	mov     ch,al                   ;000hhhhh                               ;AN000;
	mov     ax,ds:[si].DirTim          ;hhhhhmmm mmmsssss                      ;AN009;bgb
	and     ax,Minute_Mask          ;00000mmm mmm00000                      ;AN000;
	mov     cl,3                    ;                                       ;AN000;
	shl     ax,cl                   ;00mmmmmm 00000000                     ;AN000;
	mov     al,ch                   ;00mmmmmm 000hhhhh                      ;AN000;
	mov     es:Sublist_msg_Idmes.Sublist_Offset+(size Sublist_Struc)+(size Sublist_Struc),ax ;AN009;bgb
	mov     es:Sublist_msg_Idmes.Sublist_Segment+(size Sublist_Struc)+(size Sublist_Struc),0 ;AN009;bgb
	pop     ds                                                              ;an009;bgb
	Message Idmes_Arg               ; the parts out as needed               ;AC000'
;;;;;;;;call    doCRLF
	ret                             ;




;*****************************************************************************  ;an024;bgb
; Get the volume serial number                                                  ;an024;bgb
;*****************************************************************************  ;an024;bgb
; Input:  FCB_Drive                                                             ;an024;bgb
; Output: SerNum if no carry                                                    ;an024;bgb
; Notes:  Only DOS Version 3.4 and above will contain serial numbers            ;an024;bgb
;*****************************************************************************  ;an024;bgb
   PUBLIC GET_SERIAL_NUM                                                        ;an024;bgb
procedure Get_Serial_Num,NEAR           ;AN000;S                                     ;an024;bgb
   mov  al,GENERIC_IOCTL           ;AN000;S                                     ;an041;bgb;an024;bgb
   xor  bx,bx                      ;zero out bx                                 ;an041;bgb;an024;bgb
   mov  bl,alldrv                  ;AN000;S Which drive to check                ;an024;bgb
   mov  ch,rawio                   ;8 = disk io                                 ;an041;bgb;an024;bgb
   mov  cl,Get_Media_Id            ;66h = get media id                          ;an041;bgb;an024;bgb
   LEA  dx,SerNumBuf               ;AN000;S Pt to the buffer                    ;an024;bgb
   Dos_call ioctl                  ;AN000;S Make the call                       ;an041;bgb;an024;bgb
;  $IF  NC
   JC $$IF26
       message  msgserialnumber                                                     ;an024;bgb
;  $ENDIF
$$IF26:
   ret                             ;AN000;S                                     ;an024;bgb
endproc Get_Serial_Num                     ;AN000;S                                     ;an024;bgb
	pathlabl chkdsk1                                                        ;an024;bgb
CODE    ENDS
	END     CHKDSK
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkmacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM


;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

Message macro	Message_Name			;				;AN000;
						;
	mov	dx,offset dg:Message_Name	;				;AN000;
	call	Display_Interface		;				;AN000;
						;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Parse_Message macro				;				;AN000;

						;
	push	ds
	mov	dx,dg
	mov	ds,dx
	mov	word ptr Parse_Error_Msg,ax	;				;AN000;
	mov	dx,offset dg:Parse_Error_Msg	;				;AN000;
	call	Display_Interface		;				;AN000;
	pop	ds				;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Extended_Message macro				;				;AN000;
						;

	push	ds
	mov	dx,dg
	mov	ds,dx
	mov	word ptr Extended_Error_Msg,ax	  ;				  ;AN000;
	mov	dx,offset dg:Extended_Error_Msg    ;				   ;AN000;
	call	Display_Interface		;				;AN000;
	pop	ds
	endm					;				;AN000;
;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure	macro	Proc_Name,Seg_Name	;				;AN000;
						;
Public	Proc_Name				;				;AN000;
Proc_Name    proc				;				;AN000;

	endm					;				;AN000;
;-----------------------------------------------------------------------------

DOS_Call	macro	Function		;				;AN000;
						;
	mov	ah,Function			;				;AN000;
	int	21h				;				;AN000;
						;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Popff	macro

Assume	cs:DG

	jmp	$+3
	iret
	push	cs
	call	$-2

Assume	cs:code

	endm

;-----------------------------------------------------------------------------

Set_Data_Segment     macro

	push	ax
	mov	ax,dg				;Point to data segment
	mov	ds,ax				;
	push	ds
	pop	es
	pop	ax

	.LALL
	assume	ds:dg,es:dg
	.XALL
	endm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkfat.asm ===
TITLE   CHKFAT  - procedures that acces the fat and/or fatmap
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
page    ,132                                    ;

	.xlist
	include chkseg.inc                                                      ;an005;bgb
	INCLUDE CHKCHNG.inc
	INCLUDE DOSSYM.inc
	INCLUDE CHKEQU.inc
	INCLUDE CHKMACRO.inc
	include pathmac.inc
	include dpb.inc
	include syscall.inc


CONST   SEGMENT PUBLIC PARA  'DATA'
	EXTRN   CREATMES:byte,FIXMES_ARG:word
	EXTRN   FREEMES:byte
	EXTRN   BADW_ARG:word,FATAL_END:word
	EXTRN   badrw_num:word,BADRW_STR:WORD,HAVFIX:byte
	EXTRN   FREEBYMES1:byte,FREEBYMES2:byte
	EXTRN   FREE_ARG1:WORD,FREE_ARG2:WORD,FREE_ARG3:WORD,ORPHCNT:dword
	EXTRN   DIRTYFAT:byte,CROSSCNT:dword,DOFIX:byte,SECONDPASS:byte
	EXTRN   BADSIZ:word,ORPHSIZ:word,LCLUS:word,ORPHFCB:byte
	EXTRN   HECODE:byte,USERDIR:byte,FRAGMENT:byte
	EXTRN   ORPHEXT:byte,ALLDRV:byte,FIXMFLG:byte,DIRCHAR:byte
	EXTRN   BIGFAT:byte,EOFVAL:word,BADVAL:word
	extrn   fTrunc:BYTE, rarg1:word                                         ;an018;bgb
	extrn   temp_dd:dword                                                 ;an049;bgb
CONST   ENDS

DATA    SEGMENT PUBLIC PARA 'DATA'
	extrn   fatcnt:byte                                                     ;an005;bgb
	EXTRN   THISDPB:dword,NUL_ARG:byte
	EXTRN   NAMBUF:byte,SRFCBPT:word,FATMAP:word
	EXTRN   MCLUS:word,CSIZE:byte,SSIZE:word
	EXTRN   DSIZE:word,ARG1:word,ARG_BUF:byte,ERRCNT:byte
	EXTRN   USERDEV:byte,HARDCH:dword,CONTCH:dword
	EXTRN   ExitStatus:Byte,Read_Write_Relative:Byte
	extrn   bytes_per_sector:word, fattbl:word                              ;an005;bgb
	extrn   sec_count:word, secs_per_64k:word, paras_per_64k:word             ;an005;bgb
	extrn   fattbl_seg:word, fatsiz:word, paras_per_fat:word                    ;an005;bgb
	extrn   root_entries:word                                               ;ac048;bgb;an047;bgb
DATA    ENDS

CODE    SEGMENT PUBLIC PARA 'CODE'
ASSUME  CS:DG,DS:DG,ES:DG,SS:DG
	EXTRN   PRINTF_CRLF:NEAR,FCB_TO_ASCZ:NEAR, recover:near
	EXTRN   EPRINT:NEAR, makorphnam:near
	EXTRN   DOINT26:NEAR,PROMPTYN:NEAR,CHECKFILES:NEAR,DIRPROC:NEAR
	EXTRN   DOCRLF:NEAR, getfilsiz:near, fatal:near, write_disk:near
	EXTRN   GETENT:NEAR,CHECKNOFMES:NEAR, systime:near
	EXTRN   multiply_32_bits:near                                        ;an049;bgb

public calc_fatmap_seg, MARKMAP, CHKMAP, CHKMAPLP, ORPHAN, CONTLP, RET18
public PromptRecover, NOCHAINREC, CHKMAPLP2, NEXTCLUS
public DISPFRB, FINDCHAIN, CHKMAPLP3, CHAINLP, INSERTEOF, FAT12_4, CHKCHHEAD
public ADDCHAIN, CHGOON, NEXTCLUS2,
public CHAINREC, MAKFILLP, GOTENT, OPAGAIN, GOTORPHNAM, ENTMADE, NEXTENT
public NXTORP, RET100, nextorph
public AMDONE, REWRITE, WRTLOOP
public WRTOK, NOWRITE, DONE, CROSSCHK, calc_fat_addr, pack, unpack
	.list
PHONEY_STACK DW 5 DUP(0)                                                        ;ac048;bgb

	pathlabl chkfat
;*****************************************************************************  ;an005;bgb
;   CALC-FAT-ADDR - calculate the seg/off of the fat cell from the cell number  ;an005;bgb
;                                                                               ;an005;bgb
;   Inputs:   es - fat table segment
;             si - cluster number
;
;   Outputs:  es - fat table segment + cluster seg
;             di - cluster offset
;                                                                               ;an005;bgb
; LARGE FAT SUPPORT                                                             ;an005;bgb
;*******************                                                            ;an005;bgb
; the offset into the fat table is cluster number times 2 (2 bytes per fat entry) ;an005;bgb
; This will result not only in the segment boundary being passed, but also in   ;an005;bgb
; a single-word math overflow.    So, we calculate the the address as follows:  ;an005;bgb
; 0. start with cluster number (1-65535)                                        ;an005;bgb
; 1. divide by 8 to get the number of paragraphs per fat-cell  (0-8191)         ;an005;bgb
;    remainder =                                               (0-7)            ;an005;bgb
; 2. multiply the remainder by 2 to get offset in bytes        (0-15)           ;an005;bgb
; You now have a paragraph-offset number that you can use to calc the addr into ;an005;bgb
; the fat table.  To get the physical addr you must add it to the offset of the ;an005;bgb
; table in memory.                                                              ;an005;bgb
; 3. add the paras to the segment register                                      ;an005;bgb
; 4. add the offset to the offset register                                      ;an005;bgb
;****************************************************************************** ;an005;bgb
Procedure calc_fat_addr,near                                                    ;an005;bgb
    savereg <ax,bx,dx>              ;                                           ;an005;bgb
    mov     ax,si                    ;get cluster number from si
    mov     bx,0008h                ; div by para (* 2 bytes per clus)  ;an005;bgb
    xor     dx,dx                   ; zero dx for word divide                   ;an005;bgb
    div     bx                      ; do it                                 ;an022;bgb;bgb
    mov     bx,es                   ; get fat table segment                     ;an005;bgb
    add     bx,ax                   ; add number of paras to the cluster        ;an005;bgb
    mov     es,bx                   ; move it back                              ;an005;bgb
    shl     dx,1                    ; remainder times 2                         ;an005;bgb
    mov     di,dx                   ; offset = 00 + remainder                   ;an005;bgb
    restorereg <dx,bx,ax>                                                       ;an005;bgb
  return                                                                        ;an005;bgb
EndProc calc_fat_addr                                                           ;an005;bgb

;=========================================================================
; UNPACK        :       This routine calculates the position in the FAT
;                       where the cluster number resides and obtains
;                       its contents.
;
;       Inputs  :       SI - Cluster number
;       Outputs :       DI - Cluster contents
;                       zero flag is set if fat cell = zero
;
; LOGIC
;       - get addr of fat table
;       - if 16-bit fat,
;         then get the address of the cell (calc_fat_addr)
;              mov it into di
;              set the zero flag
;         else multiply the cluster-number by 1.5 to get the byte-offset
;              move the contents of the cluster into di
;              if the cluster-number is odd,
;              then shift it right by 1 nibble
;                   set the zero flag
;              else (its already shifted right)
;                   set the zero flag
;=========================================================================
UNPACK  proc    near                            ;ac005; dms;unpack FAT
	push    es                                                              ;an005;bgb
	mov     es,fattbl_seg                   ;point to FAT in memory         ;an005;bgb
	mov     DI,SI                           ;put cluster number in DI
	cmp     [BIGFAT],0                      ;big fat?
;       $IF     nz                              ;yes
	JZ $$IF1
		call    calc_fat_addr           ;calc addr of cluster           ;an005;bgb
		mov     di,word ptr es:[di]     ;es:bx points to fat cluster    ;an005;bgb
		or      DI,DI                   ; Set zero
;       $ELSE                                   ;small fat
	JMP SHORT $$EN1
$$IF1:
	       SHR     DI,1
	       ADD     DI,SI                    ; Mult by 1.5
	       mov     DI,word ptr es:[di]
	       TEST    SI,1                     ;is the cluster number odd?
;              $IF     nz            ;last bit is non-zero; means it is odd
	       JZ $$IF3
		       SHR     DI,1             ;shift by 1 nibble
		       SHR     DI,1
		       SHR     DI,1
		       SHR     DI,1
		       and     di,0fffh         ;ac005; dms;
;               $ELSE                           ;ac005; dms;even cluster bound.
		JMP SHORT $$EN3
$$IF3:
		       AND     DI,0FFFH
;               $ENDIF
$$EN3:
;       $ENDIF
$$EN1:
	pop     es
	return
UNPACK  endp                                    ;ac005; dms;

;=========================================================================
; PACK          : This routine puts data into the FAT.
;
;       Inputs  : SI - Cluster number to be packed
;                 dx - Data to be packed
;
;       Outputs : Altered FAT
; LOGIC
;       - set the fat-changed-flags
;       - get the seg of the fat-table
;       - if 16-bit fat,
;         then get the address of the cell (calc_fat_addr)
;              mov the new value into it
;         else multiply the cluster-number by 1.5 to get the byte-offset
;              move the contents of the cluster into di
;              if the cluster-number is odd,
;              then shift it right by 1 nibble
;                   set the zero flag
;              else (its already shifted right)
;                   set the zero flag
;=========================================================================
PACK    proc    near                            ;ac005; dms;
	savereg <si,di,es>                                                      ;ac048;bgb
	mov     [DIRTYFAT],1                    ;Set FAT dirty byte
	mov     [HAVFIX],1                      ;Indicate a fix
	mov     es,fattbl_seg                   ;                               ;an005;bgb
	mov     DI,SI
	cmp     [BIGFAT],0
;       $IF     nz                              ;ac005; dms;big fat?
	JZ $$IF7
		call    calc_fat_addr           ;calc addr of cluster           ;an005;bgb
		mov     es:[di],dx              ;move dx into cluster           ;an005;bgb
;       $ELSE
	JMP SHORT $$EN7
$$IF7:
		shr     di,1            ;offset = clus-num * 1.5
		add     di,si           ;offset = clus-num * 1.5
		push    di              ;save cluster offset
		mov     DI,es:[di]      ;get previous value, 4 nibbles
		test    si,1                    ;is the cluster number odd?
;               $IF     nz            ;last bit is non-zero; means it is odd
		JZ $$IF9
			SHL     dx,1            ;shift by 1 nibble
			SHL     dx,1
			SHL     dx,1
			SHL     dx,1
			AND     DI,0FH          ;zero out 1st 3 nibbles '000f'
;               $ELSE                           ;even cluster number
		JMP SHORT $$EN9
$$IF9:
			AND     DI,0F000H       ;zero out last 3 nibbles 'f000'
;               $ENDIF
$$EN9:
		or      DI,dx                   ;put new value in with old
		pop     si                      ;get cluster offset
		mov     es:[SI],DI
;       $ENDIF
$$EN7:
	restorereg <es,di,si>                                                   ;ac048;bgb
	ret
PACK    endp                                    ;ac005; dms;

;=========================================================================      ;an005;bgb
; CROSSCHK      : this proc gets the value of the fatmap entry that is pointed  ;an005;bgb
;                   to by an orphan                                             ;an005;bgb
;                                                                               ;an005;bgb
;       Inputs  : si - cluster number of the orphan                             ;an005;bgb
;                                                                               ;an005;bgb
;       Outputs : ah - contents of the fatmap pointed to by di                  ;an005;bgb
; LOGIC                                                                         ;an005;bgb
; *****                                                                         ;an005;bgb
;=========================================================================      ;an005;bgb
procedure       CROSSCHK                                                        ;an005;bgb
	push    es
	mov     es,fatmap                                                       ;an005;bgb
	xor     di,di                                                           ;an005;bgb
	ADD     DI,SI
	mov     ah,es:[di]                                                      ;an005;bgb
	TEST    AH,10H
	pop     es
	ret
EndProc CROSSCHK                                                                ;an005;bgb

;*****************************************************************************  ;an005;bgb
; INIT_FATMAP                                                                   ;an005;bgb
; description: initialize the fatmap area to all zeros                          ;an005;bgb
;                                                                               ;an005;bgb
; called from: main-routine                                                     ;an005;bgb
;                                                                               ;an005;bgb
;Change History: Created    8/31/87            bgb                              ;an005;bgb
;                                                                               ;an005;bgb
;Input: segment addr of the fatmap                                              ;an005;bgb
;       number of clusters in the fat (1-65535)                                 ;an005;bgb
;                                                                               ;an005;bgb
;Output: fatmap                                                                 ;an005;bgb
;                                                                               ;an005;bgb
; LOGIC                                                                         ;an005;bgb
;----------                                                                     ;an005;bgb
;*****************************************************************************  ;an005;bgb
Procedure init_fatmap,Near                 ;AN000;bgb                              ;an005;bgb
    savereg <es,di,ax,cx>
    mov     es,fatmap                   ;get seg of the fatmap                  ;an005;bgb
    xor     di,di                       ;get off of the fatmap                  ;an005;bgb
    mov     cx,[MCLUS]                  ;do once for each cluster
    xor     AL,AL                       ;zero means free
    REP     STOSB                   ;Initialize fatmap to all free
    mov     byte ptr es:[di],al                            ;                    ;an010;bgb
    restorereg <cx,ax,di,es>
    return
endproc init_fatmap                         ;                               ;AN000;
;
;*****************************************************************************  
; CALC_FATMAP_SEG                                                               
; description: calculate the segment of the fatmap for addressing purposes      
;                                                                               
; called from: main-routine                                                     
;                                                                               
;Change History: Created    8/31/87            bgb                              
;                                                                               
;Input: bytes-per-sector                                                        
;       fatsiz                                                                  
;                                                                               
;OUTPUT:
;       CY  ->  not enough memory/some other mem alloc failure
;               ax = error code
;       NC  ->  Mem alloc succesful
;        ram-based fat table                                                    
;        paras-per-fat       - number of paragraphs of mem in the fat
;        fattbl-seg          - segment number of fat table
;        fatmap              - segment number of the fat map table
;
;                                                                               
; LOGIC                                                                         
;----------                                                                     
;     - calc length fat-table (in paras)
;           = bytes-per-sector / 16 * sectors-per-fat                           
;       allocate mem for this size
;     - calculate length of fatmap area
;       allocate mem for this size
;
;*****************************************************************************  
Procedure calc_fatmap_seg,Near                 
; calc fat table length                                                         
	push    es
	mov     ax,bytes_per_sector     ; bytes per sector                      
	xor     dx,dx                                                           
	mov     bx,16                                                           
	div     bx                      ; paras per sector                  
	mov     cx,fatsiz               ;2         ; get sectors per fat        
	xor     dx,dx                                                           
	mul     cx                      ; paras per fat                         
	mov     paras_per_fat,ax                                                

; allocate mem for fat table
	mov     bx,ax
	mov     ax,4800h                ; allocate mem
	int     21h                     
	jc      cfs_100                  ; error on alloc ?

; alloc successful ; ax = seg of FAT TABLE

	mov     fattbl_seg,ax           ;starting segment of fattbl             

; calculate size of fat map
	mov     bx, [MCLUS]             ;P5000 INIT_FATMAP use [MCLUS]
	mov     cx, 4
	shr     bx, cl                   ;P5000 convert it to para.
	inc     bx                      ;P5000 ;size of fatmap
	mov     ax,4800h                ; allocate mem
	int     21h
	jc      cfs_100                  ; mem not avail ?

; alloc successful; ax = seg of fatmap

	mov     fatmap,ax
	clc
cfs_100: pop    es 
	ret                             ;                                     

endproc calc_fatmap_seg                     ;                               
;
										;ac048;bgb
;*****************************************************************************  ;ac048;bgb
; FIX_ENTRY - fill in the dir entry with the lost cluster information, give it  ;ac048;bgb
;             unique filename, and write it back to disk.                       ;ac048;bgb
;                                                                               ;ac048;bgb
; WARNING!! NOTE!! -->                                                          ;ac048;bgb
;                                                                               ;ac048;bgb
; called by - CHAINREC                                                          ;ac048;bgb
;                                                                               ;ac048;bgb
; inputs: AX - drive number                                                     ;ac048;bgb
;         BX - ram offset of beginning of sector                                ;ac048;bgb
;         CX -                                                                  ;ac048;bgb
;         DX - sector number low                                                ;ac048;bgb
;         SP -                                                                  ;ac048;bgb
;         BP -                                                                  ;ac048;bgb
;         SI - cluster number of first cluster in this lost chain               ;ac048;bgb
;         DI - points to entry in ram                                           ;ac048;bgb
;                                                                               ;ac048;bgb
; output: AX -                                                                  ;ac048;bgb
;         BX -                                                                  ;ac048;bgb
;         CX -                                                                  ;ac048;bgb
;         DX -                                                                  ;ac048;bgb
;         SP -                                                                  ;ac048;bgb
;         BP -                                                                  ;ac048;bgb
;         SI -                                                                  ;ac048;bgb
;         DI-                                                                   ;ac048;bgb
;                                                                               ;ac048;bgb
; Regs abused - di,si,cx                                                        ;ac048;bgb
;                                                                               ;ac048;bgb
;logic: 1. save the starting cluster number                                     ;ac048;bgb
;                                                                               ;ac048;bgb
;       2. if the recovered file name already exists, then use the next one.    ;ac048;bgb
;          do this until the name is unique.                                    ;ac048;bgb
;                                                                               ;ac048;bgb
;       3. move all the pertinant info into the dir entry.                      ;ac048;bgb
;                                                                               ;ac048;bgb
;       4. write the dir entry out to disk.                                     ;ac048;bgb
;*****************************************************************************  ;ac048;bgb
procedure fix_entry,near                                                        ;ac048;bgb
    mov     ds:[DI+26],SI               ;move 1st clus num into dir entry       ;ac048;bgb         
    savereg <ax,dx,bx>                  ;Save INT 26 data                       ;ac048;bgb
;make sure this name is unique                                                  ;ac048;bgb
    DOS_Call Disk_Reset                 ;func 0d - flush buffers          ;AC000;ac048;bgb;
    mov     dx,OFFSET DG:ORPHFCB        ;point to filename file0000.chk         ;ac048;bgb
    mov     AH,FCB_OPEN                 ;open the file just put into the dir    ;ac048;bgb
OPAGAIN:                                                                        ;ac048;bgb
;   $do                                                                         ;ac048;bgb
$$DO13:
	INT     21H                                                             ;ac048;bgb
	or      AL,AL                   ;did the open fail?                     ;ac048;bgb
;   $leave  nz                                                                  ;ac048;bgb
    JNZ $$EN13
	call    MAKORPHNAM              ;Try next name                          ;ac048;bgb
;   $enddo                                                                      ;ac048;bgb
    JMP SHORT $$DO13
$$EN13:
GOTORPHNAM:                              ;di still points to entry              ;ac048;bgb
	mov     SI,OFFSET DG:ORPHFCB + 1 ;ORPHFCB Now has good name             ;ac048;bgb
	mov     cx,11                    ;move filename, ext                    ;ac048;bgb
	REP     MOVSB                                                           ;ac048;bgb
	call    MAKORPHNAM               ;Make next name                        ;ac048;bgb
	xor     ax,ax                    ;fill dir entry with zeros             ;ac048;bgb
	mov     cx,11                                                           ;ac048;bgb
	REP     STOSB                                                           ;ac048;bgb
; Add in time for orphan file - BAS July 17/85                                  ;ac048;bgb
	push    dx                      ;save starting sector number            
	call    SYSTIME                                                         ;ac048;bgb
	STOSW                           ; Time                                  ;ac048;bgb
	mov     ax,dx                                                           ;ac048;bgb
	STOSW                           ; Date                                  ;ac048;bgb
	pop     dx                      ;restore starting sector number         
	mov     SI,ds:[DI]              ;get starting cluster number            ;ac048;bgb                           
	inc     DI                      ;skip firstclus in entry                ;ac048;bgb
	inc     DI                                                              ;ac048;bgb
	PUSH    DI                      ;save it from getfilsiz                 ;ac048;bgb
	call    GETFILSIZ               ;calc file size from number of clus     ;ac048;bgb
	POP     DI                      ;restore di                             ;ac048;bgb
	STOSW                           ;ax=file size low                       ;ac048;bgb
	mov     ax,dx                   ;dx=filesize high                       ;ac048;bgb
	STOSW                           ;                                       ;ac048;bgb
	restorereg <bx,dx,ax>   ;offset, sector num, drive num                  ;ac048;bgb
	mov     cx,1            ;number of sectors = 1                          ;ac048;bgb
	call    DOINT26         ;write it out to disk                           ;ac048;bgb
	ret                                                                     ;ac048;bgb
endproc fix_entry                                                               ;ac048;bgb
										;ac048;bgb
;*****************************************************************************  
; NEXTORPH - find the cluster number of the next orphan.  This assumes that     ;ac048;bgb;an047;bgb
;            there is at least one lost cluster available.                      ;ac048;bgb;an047;bgb
;                                                                               ;ac048;bgb;an047;bgb
; WARNING!! NOTE!! -->                                                          ;ac048;bgb;an047;bgb
;                                                                               ;ac048;bgb;an047;bgb
; called by - PROCEDURE NAME                                                    ;ac048;bgb;an047;bgb
;                                                                               ;ac048;bgb;an047;bgb
; inputs: AX -                                                                  ;ac048;bgb;an047;bgb
;         BX -                                                                  ;ac048;bgb;an047;bgb
;         CX -                                                                  ;ac048;bgb;an047;bgb
;         DX -                                                                ;a;ac048;bgbn047;bgb
;         SP -                                                                 ;;ac048;bgban047;bgb
;         BP -                                                                ;a;ac048;bgbn047;bgb
;         SI - cluster number of the previous orphan                          ;a;ac048;bgbn047;bgb
;         DI -                                                                ;a;ac048;bgbn047;bgb
;         DS -                                                                ;a;ac048;bgbn047;bgb
;         ES - points to one byte map of the fat                              ;a;ac048;bgbn047;bgb
;                                                                             ;a;ac048;bgbn047;bgb
; output: AX -                                                                 ;;ac048;bgban047;bgb
;         BX -                                                                ;a;ac048;bgbn047;bgb
;         CX -                                                                 ;;ac048;bgban047;bgb
;         DX -                                                                ;a;ac048;bgbn047;bgb
;         SP -                                                                ;a;ac048;bgbn047;bgb
;         BP -                                                                ;a;ac048;bgbn047;bgb
;         SI - cluster number of one past the orphan                            ;ac048;bgb;an047;bgb
;         DI - cluster number of the orphan                                   ;a;ac048;bgbn047;bgb
;         DS -                                                                ;a;ac048;bgbn047;bgb
;         ES -                                                                ;a;ac048;bgbn047;bgb
;                                                                             ;a;ac048;bgbn047;bgb
; Regs abused - none                                                            ;ac048;bgb;an047;bgb
;                                                                              ;;ac048;bgban047;bgb
;logic: 1. save ax & es, and point to fat map                                   ;ac048;bgb;an047;bgb
;                                                                             ;a;ac048;bgbn047;bgb
;       2. do until the head of a chain is found:                               ;ac048;bgb ;an047;bgb
;                                                                              ;;ac048;bgban047;bgb
;          3. get the next cell                                                 ;ac048;bgb    ;an047;bgb
;                                                                              ;;ac048;bgban047;bgb
;          4. bump pointers into fat map                                        ;ac048;bgb ;an047;bgb
;                                                                              ;;ac048;bgban047;bgb
;       5. restore ax & es                                                     ;;ac048;bgban047;bgb
;*****************************************************************************;a;ac048;bgbn047;bgb
procedure NEXTORPH,near                                                       ;a;ac048;bgbn047;bgb
    savereg <ax,es>                     ;save regs abused                       ;ac048;bgb
    mov     es,[FATMAP]                 ;point to fat map                       ;ac048;bgb
;   $do                                                                         ;ac048;bgb
$$DO16:
loopno: mov     al,byte ptr es:[si]     ;get the indicated fatmap entry         ;ac048;bgb   ;an005;bgb
	inc     si                      ;point to the next one                  ;ac048;bgb   ;an005;bgb
	inc     di                      ;point to the next one                  ;ac048;bgb   ;an005;bgb
	cmp     AL,89H                  ;stop when you find an  89              ;ac048;bgb
;   $leave    z                ;this means head(80), found(1), and orphan(8)    ;ac048;bgb
    JZ $$EN16
;   $enddo                                                                      ;ac048;bgb
    JMP SHORT $$DO16
$$EN16:
    restorereg <es,ax>                  ;restore regs                           ;ac048;bgb
return                                                                          ;ac048;bgb
endproc nextorph                                                                ;ac048;bgb
										;ac048;bgb
										;ac048;bgb

;****************************************************************************
; MARKMAP - make a mark in the fat map for every cluster encountered
;
; called by - markfat,
;
; inputs  - AL - the mark
;           DI - cluster number
;
; outputs - CY if crosslink found
;         - AH - previous mark
;         - crosscnt (count of number of crosslinks found)
;         - fatmap marked
;
; LOGIC
;******
;       - point to fatmap with es
;       - if that cell has been found before,
;           then mark it crossed x'10'
;           else mark it found   al
;****************************************************************************
markmap: savereg <si,es>                         ;Save registers                 ;AN000;
	xor     si,si                           ;Get addr of map                ;an005;bgb
	mov     es,[FATMAP]                     ;Get addr of map                ;an005;bgb
	mov     ah,es:[di]                         ;Get entry at that spot      ;an005;bgb
	or      ah,ah                           ;Is it zero?                    ;     ;
;       $IF     NZ ;already found - mark crossed;If not, we got crosslink       ;AC000;
	JZ $$IF19
	   add     word ptr crosscnt,1          ;Count the crosslink            ;     ;
	   adc     word ptr crosscnt+2,0        ;Count the crosslink            ;     ;
	   or      byte ptr es:[di],10H         ;Resets zero in map             ;An005;bgb
	   stc                                  ;Indicate crosslink on ret      ;     ;
;       $ELSE     ;not found - mark found       ;No crosslink                   ;     ;
	JMP SHORT $$EN19
$$IF19:
	   mov  es:[di],al                      ;Set mark in map                ;Ac005;bgb
	   clc                                  ;Indicate things okay           ;     ;
;       $ENDIF                                  ;                               ;AN000;
$$EN19:
	restorereg <es,si>                      ;                               ;AN005;bgb
	ret                                     ;                               ;     ;


;****************************************************************************
; CHKMAP - Compare FAT and FATMAP looking for badsectors and orphans
;
; called by -
;
; inputs  - fatmap
;         - dsize - number of clusters on the disk
;
; outputs - badsiz -
;         -
;         -
; LOGIC
;******
;       - get addr of fatmap
;       - get offset of 1st cluster in fatmap
;       - do for all the clusters on the disk:
;           - if the cluster has been found
;             then get the next cluster in its chain
;                  if the cell was never pointed to by anyone (0)
;                  then get the contents of that cell from the fat
;                       (the contents of the fat cell should be zero, too)
;                       if the fat-cell is not zero
;                       then (it should only be a bad sector)
;                            if it is a bad sector, inc the bad-sector-counter
;                            otherwise, we have found an orphan sector
;         end-of-loop
;       - if there are any orphans,
;         then recover them
;****************************************************************************
CHKMAP:
    push    es                                                                  ;an014;bgb
    mov     es,fatmap               ;get segment of the fatmap                  ;an005;bgb
    xor     si,si                       ;get the offset of the fatmap           ;an005;bgb
    mov     si,2                        ;go past the first two (invalid) entries;an005;bgb
;do for all the clusters on the disk
    mov     cx,[DSIZE]              ;loop for the number of clusters on the disk
CHKMAPLP:
    mov     al,es:[si]                  ;move a byte from the fatmap to al      ;an005;bgb
    or      al,al                       ;is the cluster found already?
;   $IF     Z                           ;fatmap cell is zero
    JNZ $$IF22
	call    unpack                  ;get the contents of it
;       $IF     NZ                      ;is there something in the cell?
	JZ $$IF23
	    cmp     di,[badval]         ;is the fat cell pointing to a bad sector? fff7
;           $IF     Z                   ; yes
	    JNZ $$IF24
		inc  [badsiz]             ;inc the bad sector counter
		mov  byte ptr es:[si],4               ;Flag the map             ;an005;bgb
;           $ELSE                       ; no, not a bad sector
	    JMP SHORT $$EN24
$$IF24:
orphan:         inc  [orphsiz]          ; then its an orphan
		mov  byte ptr es:[si],8               ;Flag it                  ;an005;bgb
;           $ENDIF
$$EN24:
;       $ENDIF
$$IF23:
;   $ENDIF
$$IF22:
CONTLP:
    inc     si                          ;point si to next cluster
    loop    chkmaplp
    cmp     [orphsiz],0                                                         ;an005;bgb
;   $IF     A            ;if there are any orphans, go recover them             ;an005;bgb
    JNA $$IF29
	call    recover
;   $ENDIF
$$IF29:
    pop  es                                                                     ;an014;bgb
RET18:  ret

;*****************************************************************************
; PROMPTRECOVER - do the actual recovering of files
;
; inputs:   es - points to fatmap
;           ax -
;           bx -
;           cx -
;           dx -
;
; outputs:
; LOGIC
;       - ask the user if he wants to convert the orphans to files
;       -
;       -
;***************************************************************************

PromptRecover:

    cmp     DoFix,ON                        ; Are we fixing errors?
    jne     NoChainRec                      ; Don't prompt if not
    mov     dx,OFFSET DG:FREEMES
    call    PROMPTYN                        ;Ask user
    jnz     NoChainRec                      ; User doesn't want files
    jmp     CHAINREC

NOCHAINREC:
    mov     es,[fatmap]                     ;Free all orphans
    mov     si,2
    mov     cx,[dsize]
    xor     dx,dx            ;dx is the new value (free)

CHKMAPLP2:
    mov     al,es:[si]       ;get next byte from fatmap into al
    TEST    AL,8             ; is it an orphan?
    jz      NextClus         ; yes
    call    PACK             ;si=cluster number dx=new value

NEXTCLUS:
    inc     si
    loop    CHKMAPLP2
    xor     ax,ax
    XCHG    ax,[ORPHSIZ]            ;number of orphans = zero
    mov     cx,OFFSET DG:FREEBYMES1 ;print msg
    cmp     [DOFIX],0
    jnz     DispFRB
    mov     cx,OFFSET DG:FREEBYMES2
    mov     [LCLUS],ax               ;move number of lost clust would be

DISPFRB:                             ;ax=lost clusters (1-fff6)
    push    bx                       ;save it
    push    cx                       ;save it
    mov     cl,[csize]               ;get sectors per cluster (1-32)
    xor     ch,ch                    ;zero out high byte
    xor     dx,dx                    ;zero out hi word for word mult
    mul     cx                       ;cx*ax=dx:ax  lost sectors (1-1ffec0)
    mov     bx,dx                    ;move high word for call
    mov     cx,ssize                 ;word to mult with
    call    multiply_32_bits         ;bx:ax is result
    mov     word ptr rarg1,ax        ;low word into low word
    mov     word ptr rarg1+2,bx      ;hi  word into hi  word
    mov     [free_arg1],ax
    mov     [free_arg2],bx
    mov     [free_arg3],cx
    pop     cx
    pop     bx
    mov     dx,cx                    ;Point to right message
    call    printf_crlf
    ret




;*****************************************************************************
; FINDCHAIN  -
;
; called by - recover
;
; inputs:
;
; outputs:
; LOGIC - search thru entire fatmap
;       -
;       -
;***************************************************************************
lostdeb  equ    0       ;set private build version on                               ;an047;bgb
lost_str db     '00000' ;max size of cluster number
FINDCHAIN:
;Do chain recovery on orphans
	mov     es,[FATMAP]             ; point to fatmap
	mov     SI,2                    ; point to fatmap
	mov     dx,si                   ; point to fatmap
	mov     cx,[DSIZE]              ;get total number of clusters on disk
CHKMAPLP3:
	mov     al,es:[si]              ;get next fatmap entry
	inc     si                      ;point to next fatmap entry
			;has to be an orphan(08)
	TEST    AL,8                            ;Orphan?
	jz      NEXTCLUS2                       ;Nope
			;make sure its not a regular file entry
	TEST    AL,1                            ;Seen before ?
	jnz     NEXTCLUS2                       ;Yup
;recover this chain
	savereg <si,cx,dx>                      ;Save search environment
	dec     SI
	or      byte ptr es:[si],81H            ;Mark as seen and head


	IF      LOSTDEB                 ;is this private build version?
	    call lostdisp               ;display lost cluster numbers
	 ENDIF

	add     word ptr orphcnt,1              ;Found a chain
	adc     word ptr orphcnt+2,0            ;Found a chain
	mov     SI,dx                   ;point to the next fatmap entry
CHAINLP:
	call    UNPACK                  ;si = fat cell
	XCHG    SI,DI                   ;si=contents, di=cell number
	cmp     SI,[EOFVAL]             ;is this the end of the file?
	JAE     CHGOON                  ;yes, then we are done
	PUSH    DI                      ;no, not eof
;dont do this next part if any of two conditions:
;   1. invalid cluster number
;   2. points to itself
	cmp     SI,2                    ;well, is it a valid cluster number?
	JB      INSERTEOF                       ;Bad cluster number
	cmp     SI,[dsize]
	JA      INSERTEOF                       ;Bad cluster number
	cmp     SI,DI                   ;how bout if it points to itself?
	jz      INSERTEOF                       ;Tight loop
; find out what it points TO
	    call    CROSSCHK
	    TEST    AH,8                            ;Points to a non-orphan?
	    jnz     CHKCHHEAD                       ;Nope
			      ;orphan points to nothing
INSERTEOF:
; you come here if:
;   1. invalid cluster number
;   2. points to itself
;   3. points to nothing
	POP     SI                      ;the previous cluster number
	mov     dx,0FFFH                ;get eof value (12-bit)
	cmp     [BIGFAT],0
	jz      FAT12_4
	mov     dx,0FFFFH               ;get eof value (16-bit)
FAT12_4:
	call    PACK                    ;stick it in!
	jmp     SHORT CHGOON            ;and we are done
; orphan point to a head entry
CHKCHHEAD:
	TEST    AH,80H                          ;Previosly marked head?
	jz      ADDCHAIN                        ;Nope
	AND     BYTE PTR es:[DI],NOT 80H           ;Turn off head bit
	sub     word ptr orphcnt,1              ;Wasn't really a head
	sbb     word ptr orphcnt+2,0            ;Wasn't really a head
	POP     DI                              ;Clean stack
	jmp     SHORT CHGOON
ADDCHAIN:
	TEST    AH,1                            ;Previosly seen?
	jnz     INSERTEOF                       ;Yup, don't make a cross link
	or      BYTE PTR es:[DI],1                 ;Mark as seen
	POP     DI                              ;Clean stack
	jmp     CHAINLP                         ;Follow chain
CHGOON:
	POP     dx                              ;Restore search
	POP     cx
	POP     SI
NEXTCLUS2:
	inc     dx
	loop    CHKMAPLP3
	ret



;*****************************************************************************  ;ac048;bgb
; CHAINREC - the user has requested us to recover the lost clusters             ;ac048;bgb
;                                                                               ;ac048;bgb
; inputs:                                                                       ;ac048;bgb
; note: although called from PROMPTRECOVER, this routine returns control to     ;ac048;bgb
;       recover via the ret instruction.                                        ;ac048;bgb
;*****************************************************************************  ;ac048;bgb
										;ac048;bgb
;*****************************************************************************  ;ac048;bgb
; CHAINREC - The user has requested us to recover the lost clusters             ;ac048;bgb
;                                                                               ;ac048;bgb
; WARNING!! NOTE!! --> the count of the number of lost cluster chains remains,
;                      for this proc, a single word.  More than 64k chains
;                      will cause this proc to fail.
;                                                                               ;ac048;bgb
; called by - PROCEDURE NAME                                                    ;ac048;bgb
;                                                                               ;ac048;bgb
; inputs: AX - N/A                                                              ;ac048;bgb
;         bx -                                                                  ;ac048;bgb
;         cx - N/A                                                              ;ac048;bgb
;         dx - N/A                                                              ;ac048;bgb
;         SP -                                                                  ;ac048;bgb
;         BP - N/A                                                              ;ac048;bgb
;         SI - N/A                                                              ;ac048;bgb
;         DI - N/A                                                              ;ac048;bgb
; data:   root_entries                                                          ;ac048;bgb
;         orphcnt                                                               ;ac048;bgb
;                                                                               ;ac048;bgb
; output: AX -                                                                  ;ac048;bgb
;         bx -                                                                  ;ac048;bgb
;         cx -                                                                  ;ac048;bgb
;         dx -                                                                  ;ac048;bgb
;         SP -                                                                  ;ac048;bgb
;         BP -                                                                  ;ac048;bgb
;         SI -                                                                  ;ac048;bgb
;         DI-                                                                   ;ac048;bgb
;                                                                               ;ac048;bgb
; Regs abused -                                                                 ;ac048;bgb
;                                                                               ;ac048;bgb
;logic: 1.                                                                      ;ac048;bgb
;*****************************************************************************  ;ac048;bgb
CHAINREC:                                                                      ;ac048;bgb
	push    es              ;save es if it is used for anything             ;ac048;bgb
	push    ds              ;make es point to data                          ;ac048;bgb
	pop     es                                                              ;ac048;bgb
;find the cluster number of the orphan                                          ;ac048;bgb
	mov     SI,2                    ;start at first cluster ;an005;bgb      ;ac048;bgb
	mov     DI,1                    ;point to previous cluster?             ;ac048;bgb
	call    NEXTORPH                ;di points to orphan                    ;ac048;bgb
;init for loop                                                                  ;ac048;bgb
	savereg <si,di>                 ;save orphan, orphan+1                  ;ac048;bgb
	mov     SI,DI                   ;si point to orphan                     ;ac048;bgb
	xor     ax,ax            ;set count of dir entries processed to zero;ac048;bgb
	mov     dx,word ptr orphcnt     ;get low word of lost clusters            ;ac048;bgb;an049;bgb
	mov     word ptr temp_dd,dx     ;get low word of lost clusters       ;an049;bgb
	mov     dx,word ptr orphcnt+2   ;get hi  word of lost clusters            ;an049;bgb
	mov     word ptr temp_dd+2,dx   ;get hi  word of lost clusters       ;an049;bgb
	mov     BP,OFFSET DG:PHONEY_STACK ;Set BP to point to "root"            ;ac048;bgb
;do for all dir entries:                                                        ;ac048;bgb
MAKFILLP:                                                                       ;ac048;bgb
;   $DO                                 ;do for all root entries                ;ac048;bgb
$$DO37:
	savereg <ax>              ;cnt of entries processed, num orphans  ;ac048;bgb;an049;bgb
	call    GETENT                  ;DI points to entry                     ;ac048;bgb
	cmp     BYTE PTR ds:[DI],0E5H   ;is this dir entry erased?           ;an;ac048;bgb005;bgb
;       $if     z,or                                                            ;ac048;bgb
	JZ $$LL38
	cmp     BYTE PTR ds:[DI],0      ;is this dir entry empty?            ;an;ac048;bgb005;bgb
;       $if     z                                                               ;ac048;bgb
	JNZ $$IF38
$$LL38:
GOTENT:     mov     [HAVFIX],1          ;Making a fix                           ;ac048;bgb
	    cmp     [DOFIX],0           ;/f parameter specified?                ;ac048;bgb
;           $if     NZ                  ;yes- do the fix                        ;ac048;bgb
	    JZ $$IF39
		call    fix_entry                                               ;ac048;bgb
;           $endif                                                              ;ac048;bgb
$$IF39:
ENTMADE:    restorereg <ax,di,si>                                            ;ac048;bgb;an049;bgb
	    sub     word ptr temp_dd,1   ;finished with one orphan               ;ac048;bgb;an049;bgb
	    sbb     word ptr temp_dd+2,0 ;finished with one orphan               ;ac048;bgb;an049;bgb
	    cmp     word ptr temp_dd,0  ;is that the last one?                  ;ac048;bgb;an049;bgb
;           $IF     Z,AND               ;no, check the hi word               ;an049;bgb
	    JNZ $$IF41
	    cmp     word ptr temp_dd+2,0;is that the last one?                  ;ac048;bgb;an049;bgb
;           $IF     Z                   ;neither are zero                    ;an049;bgb
	    JNZ $$IF41
		jmp     SHORT RET100                ; yes,we are done                       ;ac048;bgb;an049;bgb
;           $endif                                                           ;an049;bgb
$$IF41:
	    call    NEXTORPH            ;get the cluster of the next one        ;ac048;bgb
	    savereg <si,di>                                                     ;ac048;bgb
	    mov     SI,DI                                                       ;ac048;bgb
;       $else                           ;dir entry was not erased or zero       ;ac048;bgb
	JMP SHORT $$EN38
$$IF38:
NEXTENT:    restorereg <ax>                                                  ;ac048;bgb;an049;bgb
;       $endif                                                                  ;ac048;bgb
$$EN38:
NXTORP: inc     ax                                                              ;ac048;bgb
	cmp     ax,root_entries         ;do for 0 to (root_entries - 1)         ;ac048;bgb
;   $leave      z                                                               ;ac048;bgb
    JZ $$EN37
;   $ENDDO                                                                      ;ac048;bgb
    JMP SHORT $$DO37
$$EN37:
	restorereg <ax,ax>                      ;Clean Stack from si,di         ;ac048;bgb
	sub     word ptr orphcnt,dx             ;Couldn't make them all         ;ac048;bgb
	sbb     word ptr orphcnt+2,0            ;Couldn't make them all         ;ac048;bgb
	mov     dx,OFFSET DG:CREATMES                                           ;ac048;bgb
	mov     byte ptr [arg_buf],0                                            ;ac048;bgb
	call    EPRINT                                                          ;ac048;bgb
RET100: pop     es                      ;restore es                             ;ac048;bgb
	ret                                                                     ;ac048;bgb
										;ac048;bgb
									       ;ac048;bgb
										;ac048;bgb

;*****************************************************************************
;*****************************************************************************
SUBTTL  AMDONE  - Finish up routine
PAGE
Public  AmDone
AMDONE:
ASSUME  DS:NOTHING
	cmp     [DIRTYFAT],0
	jz      NOWRITE                         ;FAT not dirty
	cmp     [DOFIX],0
	jz      NOWRITE                         ;Not supposed to fix
REWRITE:
	LDS     bx,[THISDPB]
ASSUME  DS:NOTHING
	mov     di,[bx.dpb_FAT_size]            ;Sectors for one fat (DCR)      ;AC000;
	xor     ch,ch				; M106 Clear high byte #1594
	mov     CL,[bx.dpb_FAT_count]           ;Number of FATs
	mov     dx,[bx.dpb_first_FAT]           ;First sector of FAT
	PUSH    CS
	POP     DS
ASSUME  DS:DG
	mov     [ERRCNT],0
; set up to write to the disk
	xor     bx,bx                ;offset of the fat-table ;an005;bgb
	mov     es,fattbl_seg        ;segment of the fat-table ;an005;bgb
	mov     AL,[ALLDRV]
	dec     AL
	mov     AH,1
	PUSH    cx
WRTLOOP:
	XCHG    cx,DI
	PUSH    dx
	PUSH    cx
	PUSH    DI
	PUSH    ax

	call    Write_Disk                      ;Do relative sector write               ;AC000;

	JNC     WRTOK
	inc     [ERRCNT]
						;mov     [badrw_str],offset dg:writing
	POP     ax                              ; Get fat # in AH
	PUSH    ax                              ; Back on stack
	xchg    al,ah                           ; Fat # to AL
	xor     ah,ah                           ; Make it a word
	mov     [badrw_num],ax
	mov     dx,offset dg:badw_arg
	call    PRINTf_crlf
WRTOK:
	POP     ax
	POP     cx
	POP     DI
	POP     dx
	inc     AH
	ADD     dx,DI
	loop    WRTLOOP                         ;Next FAT
	POP     cx                              ;Number of FATs
	cmp     CL,[ERRCNT]                     ;Error on all?
;       $if     e
	JNE $$IF47
	    jmp fatal
;       $endif
$$IF47:
; make sure that the data fields are always adressable, because
;we can come here after a ctl - break has happened. so point to them w/ cs:
NOWRITE:
	DOS_Call Disk_Reset                     ;                               ;AC000;
	mov     dx,OFFSET DG:USERDIR            ;Recover users directory
	DOS_Call ChDir                          ;                               ;AC000;
	cmp     BYTE PTR cs:[FRAGMENT],1      ;Check for any fragmented files?  ;an029;bgb
	jnz     DONE                            ;No -- we're finished
	call    CHECKFILES                      ;Yes -- report any fragments
Public  Done
DONE:
ASSUME  DS:NOTHING
	mov     DL,cs:[USERDEV]                    ;Recover users drive         ;an029;bgb
	DOS_Call Set_Default_Drive              ;                               ;AC000;
	ret









	IF      LOSTDEB                 ;is this private build version?
Procedure lostdisp,near                                                    ;an005;bgb
    savereg <ax,bx,cx,dx,si,di>              ;                                           ;an005;bgb
	    mov  ax,dx  ;save orig value

	    mov  cl,12  ;shift 3 nibbles
	    shr  dx,cl  ;remove al but last nibble
	    and  dx,000fh
	    cmp  dx,0ah
;           $IF  B
	    JNB $$IF49
	       add  dx,30h ;make it char
;           $ELSE
	    JMP SHORT $$EN49
$$IF49:
	       add  dx,37h
;           $ENDIF
$$EN49:
	    push ax
	    mov  ah,2
	    int  21h
	    pop  ax

	    mov  dx,ax  ;get orig value
	    mov  cl,8
	    shr  dx,cl
	    and  dx,000fh
	    cmp  dx,0ah
;           $IF  B
	    JNB $$IF52
	       add  dx,30h ;make it char
;           $ELSE
	    JMP SHORT $$EN52
$$IF52:
	       add  dx,37h
;           $ENDIF
$$EN52:
	    push ax
	    mov  ah,2
	    int  21h
	    pop  ax

	    mov  dx,ax  ;get orig value
	    mov  cl,4
	    shr  dx,cl
	    and  dx,000fh
	    cmp  dx,0ah
;           $IF  B
	    JNB $$IF55
	       add  dx,30h ;make it char
;           $ELSE
	    JMP SHORT $$EN55
$$IF55:
	       add  dx,37h
;           $ENDIF
$$EN55:
	    push ax
	    mov  ah,2
	    int  21h
	    pop  ax

	    mov  dx,ax  ;get orig value
	    and  dx,000fh
	    cmp  dx,0ah
;           $IF  B
	    JNB $$IF58
	       add  dx,30h ;make it char
;           $ELSE
	    JMP SHORT $$EN58
$$IF58:
	       add  dx,37h
;           $ENDIF
$$EN58:
	    mov  ah,2
	    int  21h

	    mov  dl,' ' ;space after last number
	    mov  ah,2
	    int  21h

    restorereg <di,si,dx,bx,cx,ax>                                                       ;an005;bgb
  return                                                                        ;an005;bgb
EndProc lostdisp                                                                ;an005;bgb
ENDIF


	pathlabl chkfat


CODE    ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkmsg.inc ===
;******************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/21/90  EGH  C00  Cleaned up build by removing unused variables, declaring
;                      functions properly, changing long JMPs to short JMPs,
;                      etc.
;  03/21/90  EGH  C01  Problem fixed - if CHKDSK is performed on a disk with
;                      lost clusters and the output redirected to a file, the
;                      system appears to hang.  The fix is to display messages
;                      that require user input via STDERR.  STR #1921
;  03/21/90  EGH  C05  Problem fixed - CHKDSK was only displaying 64 characters
;                      for drive+paths and drive+path+filespecs.  The fix is to
;                      display 2+63+1=66 characters for drive+paths and
;                      2+63+1+8+1+3+1=79 characters for drive+path+filespecs.
;                      STR # 2067
;  03/23/90  EGH  C06  Problem fixed - if CHKDSK output was redirected to a
;                      file, the user response to a y/n prompt would appear
;                      in the file rather than on the screen.  Fix is to
;                      display user input via STDERR rather than STDOUT.
;
;******************************************************************************

                                                                                ;an000;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Macro's                                                                       ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
                                                                                ;an000;bgb
Define_Msg macro Message_Name                   ;                               ;AN000;
                                                ;                               ;an000;bgb
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
                                                ;                               ;an000;bgb
        endm                                    ;                               ;AN000;
                                                                                ;an000;bgb
;-----------------------------------------------------------------------------  ;an000;bgb
                                                                                ;an000;bgb
Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;               ;AN000;
                                                                                ;an000;bgb
Public  Parm1                                                                   ;an000;bgb
Parm1   label   word                            ;                               ;AN000;
        dw      Parm2                           ;                               ;AN000;
        dw      Parm3                           ;                               ;AN000;
        dw      Parm4                           ;                               ;AN000;
        dw      Parm5                           ;                               ;AN000;
        db      Parm6                           ;                               ;AN000;
        db      Parm7                           ;                               ;AN000;
        dw      Parm8                           ;                               ;AN000;
        endm                                    ;                               ;AN000;
                                                                                ;an000;bgb
                                                                                ;an000;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; External data declarations                                                    ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
        Extrn   Arg_Buf:Byte                                                    ;an000;bgb
ifdef fsexec                                                                    ;an038;bgb
        Extrn   Drive_Letter_Msg:Byte                                           ;an038;bgb;an000;bgb
endif                                                                           ;an038;bgb
        Extrn   TChar:Byte                                                      ;an000;bgb
        Extrn   Cross_Clus:Byte                                                 ;an000;bgb
        extrn   sernum:word                                                     ;an024;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Public Data                                                                   ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
        Public  Sublist_msg_Idmes                                               ;an000;bgb
        Public  BadDrvm                                                         ;an000;bgb
        Public  yn_arg                                                          ;an000;bgb
        Public  orphcnt                                                         ;an000;bgb
        Public  report_arg                                                      ;an000;bgb
        Public  rarg1                                                           ;an000;bgb
        Public  rarg3                                                           ;an000;bgb
        Public  badrw_str                                                       ;an000;bgb
        Public  badrw_num                                                       ;an000;bgb
        Public  block_num                                                       ;an000;bgb
        Public  fatal_arg1                                                      ;an000;bgb
        Public  fatal_arg2                                                      ;an000;bgb
        Public  file_arg1                                                       ;an000;bgb
        Public  file_arg2                                                       ;an000;bgb
        Public  free_arg1                                                       ;an000;bgb
        Public  free_arg2                                                       ;an000;bgb
        Public  free_arg3                                                       ;an000;bgb
        Public  Fatal_End                                                       ;an000;bgb
	Public	NullMsg
	public	fatmsg1
	public	fatmsg2
        Public	options1
	Public	options2
        extrn   orphsiz:word                                                    ;an049;bgb
                                                                                ;an000;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Message Retriever equates                                                     ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
                                                                                ;an000;bgb
Format_Msg              equ     'C'                                             ;an000;bgb
                                                                                ;an000;bgb
N_A                     equ     0                                               ;an000;bgb
None                    equ     0                                               ;an000;bgb
                                                                                ;an000;bgb
Blank                   equ     " "                                             ;an000;bgb
No_Function             equ     0                                               ;an000;bgb

	PUBLIC	MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST
MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     306
                                                                                ;an000;bgb
                                                                                ;an000;bgb
                                                                                ;an000;bgb
                                                                                ;an000;bgb
data    segment public para 'data'              ; AN000;                        ;an000;bgb
                                                                                ;an000;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Message Sublist Tables                                                        ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
;The  following  control  blocks  are   used   for   messages  with             ;an000;bgb
;replaceable  paramters.  These  control  blocks  are  used by  the             ;an000;bgb
;SysDispMsg routine.                                                            ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_Orphmes2    label dword             ;                               ;an000;bgb
Sublist_msg_Orphmes3    label dword             ;                               ;an000;bgb
Sublist_msg_HidMes      label dword             ;                               ;an000;bgb
Sublist_msg_DirMes      label dword             ;                               ;an000;bgb
Sublist_msg_FileMes     label dword             ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;0bh                            ;an000;bgb;an049;bgb
        db              Reserved                ;00h                            ;an000;bgb;an049;bgb
        dw              rarg1                   ;offset of value                ;an000;bgb;an049;bgb
        dw              dg                      ;segment of value               ;an000;bgb;an049;bgb
        db              1                       ;the first parm                 ;an000;bgb;an049;bgb
        db              Right_Align+Unsgn_Bin_DWord ;type of data               ;an000;bgb;an049;bgb
        db              10                      ;max length of data             ;an000;bgb;an049;bgb
        db              10                      ;min length of data             ;an000;bgb;an049;bgb
        db              Blank                   ;pad character                  ;an000;bgb;an049;bgb
        db              Sublist_Length          ;0bh                            ;an000;bgb;an049;bgb
        db              Reserved                ;00h                            ;an000;bgb;an049;bgb
        dw              rarg3                   ;offset of value                ;an000;bgb;an049;bgb
        dw              dg                      ;segment of value               ;an000;bgb;an049;bgb
        db              2                       ;the second parm                ;an000;bgb;an049;bgb
        db              Left_Align+Unsgn_Bin_DWord;type of data                 ;an000;bgb;an049;bgb
        db              10                      ;max length of data             ;an000;bgb;an049;bgb
        db              1                       ;min length of data             ;an000;bgb;an049;bgb
        db              Blank                   ;pad character                  ;an000;bgb;an049;bgb
;---------------------------                    ;                               ;an000;bgb;an049;bgb
Sublist_msg_dskspc      label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_badspc      label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_frespc      label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_totmem      label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_fremem      label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_Freebymes   label dword             ;                               ;an000;bgb;an049;bgb
Sublist_msg_alloc       label dword             ;                               ;an000;bgb;an049;bgb
                                                                                ;an000;bgb;an049;bgb
        db              Sublist_Length          ;0bh                            ;an000;bgb;an049;bgb
        db              Reserved                ;00h                            ;an000;bgb;an049;bgb
        dw              dg:rarg1                ;offset  of data                ;an000;bgb;an049;bgb
        dw              dg                      ;segment of data                ;an000;bgb;an049;bgb
        db              1                       ;1st parm                       ;an000;bgb;an049;bgb
        db              Right_Align+Unsgn_Bin_DWord ;type of data               ;an000;bgb;an049;bgb
        db              10                      ;max length of data             ;an000;bgb;an049;bgb
        db              10                      ;min length of data             ;an000;bgb;an049;bgb
        db              Blank                   ;pad character                  ;an000;bgb;an049;bgb
;---------------------------                    ;                               ;an000;bgb;an049;bgb
Sublist_msg_Extents     label   dword           ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb
        db              Reserved                ;                               ;an000;bgb
        dw              dg:arg_buf              ;                               ;an000;bgb
        dw              dg                      ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb
;C05    db              64                      ;                               ;an000;bgb
        db              79                      ;C05
        db              1                       ;                               ;an000;bgb
        db              Blank                   ;                               ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb
        db              Reserved                ;                               ;an000;bgb
        dw              dg:rarg1                ;                               ;an000;bgb
        dw              dg                      ;                               ;an000;bgb
        db              2                       ;                               ;an000;bgb
        db              Left_Align+Unsgn_Bin_Word ;                            ;;an000;bgb
        db              5                       ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Blank                   ;                               ;an000;bgb
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_Badr_arg    label   dword           ;                               ;an000;bgb
Sublist_msg_Badw_arg    label   dword           ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb
        db              Reserved                ;                               ;an000;bgb
        dw              dg:Badrw_Num            ;                               ;an000;bgb
        dw              dg                      ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Left_Align+Unsgn_Bin_Word ;                            ;;an000;bgb
        db              5                       ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Blank                   ;                               ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_Badrdmes    label   dword           ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              dg:Fatal_End            ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_Crossmes    label   dword           ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb
        db              Reserved                ;                               ;an000;bgb
        dw              dg:Cross_Clus           ;                               ;an000;bgb
        dw              dg                      ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Left_Align+Unsgn_Bin_Word  ;                            ;an000;bgb
        db              5                       ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Blank                   ;                               ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_BadTarg	label	dword		;				;an000;bgb
Sublist_msg_longpath2	label	dword
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb
        db              Reserved                ;                               ;an000;bgb
        dw              dg:arg_buf              ;                               ;an000;bgb
        dw              dg                      ;                               ;an000;bgb
        db              1                       ;                               ;an000;bgb
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb
;C05    db              64                      ;                               ;an000;bgb
	db		78			;
        db              1                       ;                               ;an000;bgb
        db              Blank                   ;                               ;an000;bgb;AN000;
;---------------------------                    ;                               ;an000;bgb
Sublist_msg_IDmes       label   dword           ;                               ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              dg:arg_buf              ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
        db              11                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              0                       ;Date will be entered           ;an000;bgb;AN000;
        dw              0                       ; by PrintID routine            ;an000;bgb;AN000;
        db              2                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Date_MDY_4   ;                               ;an000;bgb;AN000;
        db              10                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              0                       ;Time will be entered           ;an000;bgb;AN000;
        dw              0                       ; by PrintID routine            ;an000;bgb;AN000;
        db              3                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Time_HHMM_Cty;                               ;an000;bgb;AN000;
        db              6                       ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_Msg_File_Arg    label   dword           ;an000;dms                      ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              dg:arg_buf              ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
;C05    db              64                      ;                               ;an000;bgb;AN000;
        db              79                      ;C05                            ;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_Msg_Noisy       label   dword           ;an000;dms                      ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              dg:arg_buf              ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
;C05    db              64                      ;                               ;an000;bgb;AN000;
        db              79                      ;C05                            ;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_Msg_Orphmes     label   dword           ;an000;dms                      ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;0bh                            ;an000;bgb;AN000;
        db              Reserved                ;00h                            ;an000;bgb;AN000;
        dw              dg:orphsiz              ;offset of data                 ;an000;bgb;AN000;;an049;bgb
        dw              dg                      ;segment                        ;an000;bgb;AN000;
        db              1                       ;1st of 2 replaceable parms     ;an000;bgb;AN000;
        db              Left_Align+Unsgn_Bin_Word ;only 64k clusters            ;an000;bgb  ;AN000;
        db              05                      ;max length                     ;an000;bgb;AN000;;an049;bgb
        db              1                       ;min length                     ;an000;bgb;AN000;
        db              Blank                   ;pad                            ;an000;bgb;AN000;
                                                                                ;an000;bgb
        db              Sublist_Length          ;0b                             ;an000;bgb;AN000;
        db              Reserved                ;00                             ;an000;bgb;AN000;
        dw              dg:orphcnt              ;offset                         ;an000;bgb;AN000;
        dw              dg                      ;seg                            ;an000;bgb;AN000;
        db              2                       ;2nd replaceable parm           ;an000;bgb;AN000;
        db              Left_Align+Unsgn_Bin_dword ;double word                 ;an000;bgb;AN000;;an049;bgb
        db              10                      ;max len                        ;an000;bgb;AN000;;an049;bgb
        db              1                       ;min len                        ;an000;bgb;AN000;
        db              Blank                   ;pad char                       ;an000;bgb;AN000;
;---------------------------                    ;                               ;an000;bgb
Sublist_Msg_Direcmes    label   dword           ;an000;dms                      ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
        dw              dg:arg_buf              ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb;AN000;
;C05    db              64                      ;                               ;an000;bgb;AN000;
        db              66                      ;C05                            ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
                                                                                ;an000;bgb
Sublist_Msg_Fatalmes    label   dword           ;an000;dms                      ;an000;bgb
                                                                                ;an000;bgb
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
fatmsg1 dw              dg:fatal_arg1           ;                               ;an000;bgb;AN024;bgb
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
        db              64                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
        db              Sublist_Length          ;                               ;an000;bgb;AN000;
        db              Reserved                ;                               ;an000;bgb;AN000;
fatmsg2 dw              dg:fatal_arg2           ;                               ;an000;bgb;AN000;
        dw              dg                      ;                               ;an000;bgb;AN000;
        db              2                       ;number 2 of 2 subs             ;an000;bgb;AN022;bgb
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an000;bgb  ;AN000;
        db              64                      ;                               ;an000;bgb;AN000;
        db              1                       ;                               ;an000;bgb;AN000;
        db              Blank                   ;                               ;an000;bgb;AN000;
;---------------------------                    ;                               ;an000;bgb
ifdef   fsexec                                                                  ;an038;bgb
Sublist_msg_EXECFailure label   dword           ;                               ;an038;bgb;an000;bgb
        db              Sublist_Length          ;                               ;an038;bgb;an000;bgb;AN000;
        db              Reserved                ;                               ;an038;bgb;an000;bgb;AN000;
        dw              dg:Drive_Letter_Msg     ;                               ;an038;bgb;an000;bgb;AN000;
        dw              dg                      ;                               ;an038;bgb;an000;bgb;AN000;
        db              1                       ;                               ;an038;bgb;an000;bgb;AN000;
        db              Left_Align+Char_Field_ASCIIZ ;                          ;an038;bgb;an000;bgb  ;AN000;
        db              2                       ;                               ;an038;bgb;an000;bgb;AN000;
        db              2                       ;                               ;an038;bgb;an000;bgb;AN000;
        db              Blank                   ;                               ;an038;bgb;an000;bgb;AN000;
endif                                                                           ;an000;bgb
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an000;bgb
Sublist_msgSerialNumber label dword             ;                               ;an000;bgb;an024;bgb
        db              Sublist_Length          ;0b                             ;an000;bgb;an024;bgb
        db              Reserved                ;00                             ;an000;bgb;an024;bgb
;C00    dw              offset word ptr sernum+2 ;data field                    ;an000;bgb;an024;bgb
        dw              offset sernum+2         ;data field              :C00      ;an000;bgb;an024;bgb
        dw              data                    ;                               ;an000;bgb;an024;bgb
        db              1                       ;#1 of 2                        ;an000;bgb;an024;bgb
        db              Right_Align+Bin_Hex_Word ;format                        ;an000;bgb;an024;bgb
        db              4                       ;min len                        ;an000;bgb;an024;bgb
        db              4                       ;max len                        ;an000;bgb;an024;bgb
        db              '0'                     ;Display leading 0's            ;an000;bgb;an024;bgb
                                                                                ;an000;bgb;an024;bgb
        db              Sublist_Length          ;0b                             ;an000;bgb;an024;bgb
        db              Reserved                ;00                             ;an000;bgb;an024;bgb
        dw              offset sernum           ;data field                     ;an000;bgb;an024;bgb
        dw              data                    ;                               ;an000;bgb;an024;bgb
        db              2                       ;#2 of 2                        ;an000;bgb;an024;bgb
        db              Right_Align+Bin_hex_Word ;format                        ;an000;bgb;an024;bgb
        db              4                       ;min len                        ;an000;bgb;an024;bgb
        db              4                       ;max len                        ;an000;bgb;an024;bgb
        db              '0'                     ;pad char                       ;an000;bgb;an024;bgb
                                                                                ;an000;bgb
;---------------------------                    ;                               ;an046;bgb
Sublist_msg_parserr     label   dword           ;                               ;an046;bgb
                                                                                ;an046;bgb
        db              Sublist_Length          ;11                             ;an046;bgb
        db              Reserved                ;0                              ;an046;bgb
public movsi
movsi   dw              dg:command_line_buffer  ;off                            ;an046;bgb
        dw              dg                      ;seg                            ;an046;bgb
        db              0                       ;USE PERCENT ZERO               ;an046;bgb
        db              Left_Align+Char_Field_ASCIIZ ;type of data              ;an046;bgb
        db              128                     ;max width                      ;an046;bgb
        db              1                       ;min width                      ;an046;bgb
        db              Blank                   ;pad char                       ;an046;bgb
;---------------------------                    ;                               ;an046;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Message Description Tables                                                    ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 1                             ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = EXT_ERR_CLASS                 ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badver                     ; AN000;SM Incorrect DOS version;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 19                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = N_A                           ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badidbyt                   ; AN000;SM Probable non_DOS disk;an000;bgb (CRLF) Continue (Y/N)?
;----------------------                         ;                               ;an000;bgb
Message_Number  = 3                             ; AN000;SM                      ;an000;bgb
;C01 Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ;C01                            ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = N_A                           ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   freemes                    ; AN000;SM Convert lost chains t;an000;bgbo files (Y/N)?
;----------------------                         ;                               ;an000;bgb
Message_Number  = 4                             ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = N_A                           ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   ptrandir                   ; AN000;SM Unrecoverable error i;an000;bgbn directory
;----------------------                         ;                               ;an000;bgb
Message_Number  = 5                             ; AN000;SM                      ;an000;bgb
;C01 Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ;C01                            ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = N_A                           ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   ptrandir2                  ; AN000;SM Convert directory to ;an000;bgbfile (Y/N)?
;----------------------                         ;                               ;an000;bgb
Message_Number  = 7                             ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_dskspc         ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   dskspc                     ; AN000;SM %1 bytes total disk s;an000;bgbpace
;----------------------                         ;                               ;an000;bgb
Message_Number  = 8                             ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_badspc         ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badspc                     ; AN000;SM %1 bytes in bad secto;an000;bgbrs
;----------------------                         ;                               ;an000;bgb
Message_Number  =  9                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_hidmes         ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   hidmes                     ; AN000;SM %1 bytes in %2 hidden;an000;bgb files
;----------------------                         ;                               ;an000;bgb
Message_Number  = 10                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_dirmes         ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   dirmes                     ; AN000;SM %1 bytes in %2 direct;an000;bgbories
;----------------------                         ;                               ;an000;bgb
Message_Number  = 11                            ; message number 11             ;an000;bgb
Handle          = STDOUT                        ; crt                           ;an000;bgb
Sublist         = dg:Sublist_msg_filemes        ; location of sublist           ;an000;bgb
Count           = 2                             ; caontains 2 parameters        ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; type of msg                   ;an000;bgb
Function        = NO_INPUT                      ; no input from user            ;an000;bgb
Input           = N_A                           ; not applicable              ;an000;bgb
        Define_Msg   filemes                    ; AN000;SM %1 bytes in %2 user f;an000;bgbiles
;----------------------                         ;                               ;an000;bgb
Message_Number  = 12                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_orphmes2       ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   orphmes2                   ; AN000;SM %1 bytes in %2 recove;an000;bgbred files
;----------------------                         ;                               ;an000;bgb
Message_Number  = 13                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_orphmes3       ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   orphmes3                   ; AN000;SM %1 bytes would be in ;an000;bgb%2 recovered files
;----------------------                         ;                               ;an000;bgb
Message_Number  = 14                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_frespc         ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   frespc                     ; AN000;SM %1 bytes available on;an000;bgb disk
;----------------------                         ;                               ;an000;bgb
Message_Number  = 15                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_totmem         ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   totmem                     ; AN000;SM %1 bytes total memory;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 16                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_fremem         ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   fremem                     ; AN000;SM %1 bytes free        ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 17                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   no_net_arg                 ; AN000;SM Cannot CHKDSK a netwo;an000;bgbrk drive
;----------------------                         ;                               ;an000;bgb
Message_Number  = 18                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   SubstErr                   ; AN000;SM Cannot CHKDSK a SUBST;an000;bgbed or ASSIGNed drive
;----------------------                         ;                               ;an000;bgb
Message_Number  = 20                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_badr_arg       ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badr_arg                   ; AN000;SM Disk error reading FA;an000;bgbT %2
;----------------------                         ;                               ;an000;bgb
Message_Number  = 21                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_direcmes       ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   direc_arg                  ; AN000;SM Directory %1         ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 22                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_extents        ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   extent_arg                 ; AN000;SM %1 Contains %2 non-co;an000;bgbntiguous blocks
;----------------------                         ;                               ;an000;bgb
Message_Number  = 23                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   noext_arg                  ; AN000;SM All specified file(s);an000;bgb are contiguous
;----------------------                         ;                               ;an000;bgb
Message_Number  = 24                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   fixmes_arg                 ; AN000;SM Errors found, F param;an000;bgbeter not specified (CRLF)
;----------------------                         ;          Corrections will not ;an000;bgbbe written to disk
Message_Number  = 25                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_fatalmes       ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   fatal_arg                  ; AN000;SM Processing cannot con;an000;bgbtinue %1%2
;----------------------                         ;                               ;an000;bgb
Message_Number  = 26                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_badrdmes       ; AN000;SM                      ;an000;bgb
Count           = 2                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badrdmes                   ; AN000;SM File allocation table;an000;bgb bad, drive %1
;----------------------                         ;                               ;an000;bgb
Message_Number  = 2                             ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   stackmes                   ; AN000;SM Insufficient memory  ;an000;bgb
        Define_Msg   stackmes1                  ; AN000;SM Cannot make directory;an000;bgb entry %1 (CRLF)
;----------------------                         ;          Move files from root ;an000;bgbdirectory and repeat CHKDSK
Message_Number  = 29                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   cdddmes                    ; AN000;SM CHDIR .. failed, tryi;an000;bgbng alternate method
;----------------------                         ;                               ;an000;bgb
Message_Number  = 30                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badchain                   ; AN000;SM Has invalid cluster, ;an000;bgbfile truncated
;----------------------                         ;                               ;an000;bgb
Message_Number  = 31                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badsubdir                  ; AN000;SM Invalid sub-directory;an000;bgb entry
;----------------------                         ;                               ;an000;bgb
Message_Number  = 32                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   ndotmes                    ; AN000;SM Does not exist       ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 33                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   nulnz                      ; AN000;SM First cluster number ;an000;bgbis invalid, entry truncated
;----------------------                         ;                               ;an000;bgb
Message_Number  = 34                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badclus                    ; AN000;SM Allocation error, siz;an000;bgbe adjusted
;----------------------                         ;                               ;an000;bgb
Message_Number  = 35                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   norecdot                   ; AN000;SM Cannot recover .. ent;an000;bgbry, processing continued
;----------------------                         ;                               ;an000;bgb
Message_Number  = 36                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   nuldmes                    ; AN000;SM Directory is totally ;an000;bgbempty, no .. or ..
;----------------------                         ;                               ;an000;bgb
Message_Number  = 37                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   joinmes                    ; AN000;SM Directory is joined  ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 38                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   norecddot                  ; AN000;SM Cannot recover .. ent;an000;bgbry
;----------------------                         ;                               ;an000;bgb
Message_Number  = 39                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   norecddot1                 ; AN000;SM Entry has a bad link ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 40                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   norecddot2                 ; AN000;SM Entry has a bad attri;an000;bgbbute
;----------------------                         ;                               ;an000;bgb
Message_Number  = 41                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   norecddot3                 ; AN000;SM Entry has a bad size ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 42                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_crossmes       ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   cross_arg                  ; AN000;SM Is cross linked on cl;an000;bgbuster %2
;----------------------                         ;                               ;an000;bgb
Message_Number  = 43                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_badtarg        ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badtarg_ptr                ; AN000;SM Cannot CHDIR to %1, (;an000;bgbCRLF)
;----------------------                         ;          tree past this point ;an000;bgbnot processed
Message_Number  = 44                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
	Define_Msg   badtarg2			; AN000;SM tree past this point ;an000;bgbnot processed
;----------------------                         ;                               ;an000;bgb
Message_Number  = 45                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_freebymes      ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   freeBymes1                 ; AN000;SM %1 bytes disk space f;an000;bgbreed
;----------------------                         ;                               ;an000;bgb
Message_Number  = 46                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_freebymes      ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   freebymes2                 ; AN000;SM %1 bytes disk space w;an000;bgbould be freed
;----------------------                         ;                               ;an000;bgb
Message_Number  = 47                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_idmes          ; AN000;SM                      ;an000;bgb
Count           = 3                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   idmes_arg                  ; AN000;SM Volume %1 created %2 ;an000;bgb%3
;----------------------                         ;                               ;an000;bgb
Message_Number  = 48                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_alloc          ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   idmes1                     ; AN017;bgb %1 total allocation ;an000;bgbunits on disk
;----------------------                         ;                               ;an000;bgb
Message_Number  = 49                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:Sublist_msg_alloc          ; AN000;SM                      ;an000;bgb
Count           = 1                             ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   idmes2                     ; AN000;SM %1 bytes in each allo;an000;bgbcation unit
;----------------------                         ;                               ;an000;bgb
ifdef   fsexec                                                                  ;an038;bgb
Message_Number  = 50                            ; AN000;SM                      ;an038;bgb;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an038;bgb;an000;bgb
Sublist         = dg:Sublist_msg_ExecFailure    ; AN000;SM                      ;an038;bgb;an000;bgb
Count           = 1                             ; AN000;SM                      ;an038;bgb;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an038;bgb;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an038;bgb;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an038;bgb;an000;bgb
        Define_Msg   msgExecFailure             ; AN000;SM CHKDSK not available ;an038;bgb;an000;bgbon drive %1
        endif                                                                   ;an038;bgb
;----------------------                         ;                               ;an000;bgb

ifdef	XA_Support

Message_Number  = 51                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   Inv_XA_Msg                 ; AN000;SM Extended Attributes h;an000;bgbas invalid clusters,
;----------------------                         ;          attributes truncated ;an000;bgb
Message_Number  = 52                            ; AN000;SM                      ;an000;bgb
Handle          = STDOUT                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   Alloc_XA_Msg               ; AN000;SM Extended Attributes l;an000;bgbocation .. ,

endif	;XA_Support

;----------------------                         ;          attributes truncated ;an000;bgb
Message_Number  = 53                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = dg:sublist_msg_parserr        ; AN000;SM                      ;an046;bgb;an000;bgb
Count           = 1                             ; AN000;SM                      ;an046;bgb;an000;bgb
Class           = PARSE_ERR_CLASS               ; AN000;SM                      ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   badsw_arg                  ; AN000;SM Invalid parameter    ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 54                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = utility_msg_class             ; AN000;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   baddrv_arg                 ; AN000;SM Invalid drive specifi;an000;bgbcation
;----------------------                         ;                               ;an000;bgb
Message_Number  = 55                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = utility_msg_class             ; AN017;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   invpath_arg                ; AN000;SM Path not found       ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 56                            ; AN000;SM                      ;an000;bgb
Handle          = STDERR                        ; AN000;SM                      ;an000;bgb
Sublist         = None                          ; AN000;SM                      ;an000;bgb
Count           = None                          ; AN000;SM                      ;an000;bgb
Class           = utility_msg_class             ; AN017;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;SM                      ;an000;bgb
Input           = N_A                           ; AN000;SM                      ;an000;bgb
        Define_Msg   opnerr_arg                 ; AN000;SM File not found       ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 0                             ;                               ;an000;bgb;AN000;
Handle          = STDERR                        ;                               ;an000;bgb;AN000;
Sublist         = No_Replace                    ;                               ;AN;an000;bgb000;
Count           = N_A                           ;                               ;an000;bgb;AN000;
Class           = Ext_Err_Class                 ;                               ;an000;bgb;AN000;
Function        = No_Function                   ;                               ;an000;bgb;AN000;
Input           = N_A                           ;                               ;an000;bgb;AN000;
        Define_Msg      Extended_Error_Msg      ;                               ;an000;bgb;AN000;
;-----------------------                                                        ;an000;bgb
Message_Number  = 0                             ;                               ;an000;bgb
Handle          = STDERR                        ;                               ;an000;bgb;AN000;
Sublist         = dg:sublist_msg_parserr        ;                               ;an046;bgbbgb000;
Count           = 1                             ;                               ;an046;bgb;AN000;
Class           = Parse_Err_Class               ;                               ;an000;bgb;AN000;
Function        = No_Function                   ;                               ;an000;bgb;AN000;
Input           = N_A                           ;                               ;an000;bgb;AN000;
        Define_Msg      Parse_Error_Msg         ;                               ;an000;bgb;AN000;
;-----------------------                                                        ;an000;bgb
Message_Number  = 58                            ; AN000;dms                     ;an000;bgb
;C01 Handle          = STDERR                        ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ;C01                            ;an000;bgb
Sublist         = dg:Sublist_msg_orphmes           ; AN000;dms                  ;an000;bgb
Count           = 2                             ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   orph_arg                   ; AN000;dms "%1 lost clusters fo;an000;bgbund in %2 chains.",0
;----------------------                         ;                               ;an000;bgb
Message_Number  = 59                            ; AN000;dms                     ;an000;bgb
Handle          = STDout                        ; AN000;bgb                     ;an000;bgb
Sublist         = none                          ; AN000;dms                     ;an000;bgb
Count           = none                          ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   crlf_arg                   ; AN000;dms CR,LF               ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 60                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an000;bgb
Sublist         = none                          ; AN000;dms                     ;an000;bgb
Count           = none                          ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   badcd_arg                  ; AN000;dms "Cannot CHDIR to roo;an000;bgbt",cr,lf
;----------------------                         ;                               ;an000;bgb
Message_Number  = 61                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an000;bgb
Sublist         = dg:Sublist_Msg_Badw_arg          ; AN000;dms                  ;an000;bgb
Count           = 1                             ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   badw_arg                   ; AN000;dms "Disk error writing ;an000;bgbFAT %1"
;----------------------                         ;                               ;an000;bgb
Message_Number  = 62                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an042;bgb;an000;bgb
Sublist         = dg:Sublist_Msg_Noisy             ; AN000;dms                  ;an000;bgb
Count           = 1                             ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   noisy_arg                  ; AN000;dms "       %1"         ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 63                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an000;bgb
Sublist         = none                          ; AN000;dms                     ;an000;bgb
Count           = none                          ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   baddpbdir                  ; AN000;dms "Invalid current dir;an000;bgbectory"
;----------------------                         ;                               ;an000;bgb
Message_Number  = 64                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an000;bgb
Sublist         = dg:Sublist_Msg_File_Arg          ; AN000;dms                  ;an000;bgb
Count           = 1                             ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   file_arg                   ; AN000;dms "%1",cr,lf          ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 65                            ; AN000;dms                     ;an000;bgb
Handle          = STDOUT                        ; AN000;dms                     ;an000;bgb
Sublist         = none                          ; AN000;dms                     ;an000;bgb
Count           = none                          ; AN000;dms                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN000;dms                     ;an000;bgb
Function        = NO_INPUT                      ; AN000;dms                     ;an000;bgb
Input           = N_A                           ; AN000;dms                     ;an000;bgb
        Define_Msg   creatmes                   ; AN000;dms "Insufficient room i;an000;bgbn root directory"
;----------------------                         ;                               ;an000;bgb
Message_Number  = 70                            ; AN017;bgb                     ;an000;bgb
Handle          = STDOUT                        ; AN017;bgb                     ;an000;bgb
Sublist         = dg:Sublist_msg_alloc          ; AN017;bgb                     ;an000;bgb
Count           = 1                             ; AN017;bgb                     ;an000;bgb
Class           = UTILITY_MSG_CLASS             ; AN017;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN017;bgb                     ;an000;bgb
Input           = N_A                           ; AN017;bgb                     ;an000;bgb
        Define_Msg   idmes3                     ; AN017;bgb %1 allocation units ;an000;bgbavailable on disk
;----------------------                         ;                               ;an000;bgb
Message_Number  = 71                            ;                               ;an000;bgb;an024;bgb
Handle          = STDOUT                        ;                               ;an000;bgb;an024;bgb
Sublist         = Sublist_msgSerialNumber       ;                               ;an000;bgb;an024;bgb
Count           = 2                             ;                               ;an000;bgb;an024;bgb
Class           = Utility_Msg_Class             ;                               ;an000;bgb;an024;bgb
Function        = No_Function                   ;                               ;an000;bgb;an024;bgb
Input           = N_A                           ;                               ;an000;bgb;an024;bgb
        Define_Msg      msgSerialNumber         ;                               ;an000;bgb;an024;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 72                            ; AN030;bgb                     ;an000;bgb
Handle          = STDERR                        ; AN030;bgb                     ;an000;bgb
Sublist         = None                          ; AN030;bgb                     ;an000;bgb
Count           = None                          ; AN030;bgb                     ;an000;bgb
Class           = utility_msg_class             ; AN030;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN030;bgb                     ;an000;bgb
Input           = N_A                           ; AN030;bgb                     ;an000;bgb
        Define_Msg   no_mem_arg                 ; AN030;bgb insufficient memory ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 73                            ; AN033;bgb                     ;an000;bgb
Handle          = STDERR                        ; AN033;bgb                     ;an000;bgb
Sublist         = None                          ; AN033;bgb                     ;an000;bgb
Count           = None                          ; AN033;bgb                     ;an000;bgb
Class           = utility_msg_class             ; AN033;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN033;bgb                     ;an000;bgb
Input           = N_A                           ; AN033;bgb                     ;an000;bgb
        Define_Msg   inval_media                ; AN033;bgb invalid media type  ;an000;bgb
;----------------------                         ;                               ;an000;bgb
Message_Number  = 74                            ; AN045;bgb                     ;an000;bgb
Handle          = STDERR                        ; AN045;bgb                     ;an000;bgb
Sublist         = None                          ; AN045;bgb                     ;an000;bgb
Count           = None                          ; AN045;bgb                     ;an000;bgb
Class           = utility_msg_class             ; AN045;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN045;bgb                     ;an000;bgb
Input           = N_A                           ; AN045;bgb                     ;an000;bgb
        Define_Msg   write_fault                ; AN045;bgb write fault error   ;an000;bgb
;----------------------     
Message_Number  = 75                            
Handle          = STDERR                        
Sublist         = None                         
Count           = None                        
Class           = UTILITY_MSG_CLASS          
Function        = NO_INPUT                  
Input           = N_A                      
        Define_Msg   WinPrsErr                  ; Quit windows and try again
;----------------------     
Message_Number	= 78
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= UTILITY_MSG_CLASS
Function	= NO_INPUT
Input		= N_A
	Define_Msg   longpath1			; CHKDSK cannot check the validity of
;---------------------- 			; this drive because the ...
Message_Number	= 79
Handle		= STDOUT
Sublist 	= dg:Sublist_msg_longpath2
Count		= 1
Class		= UTILITY_MSG_CLASS
Function	= NO_INPUT
Input		= N_A
	Define_Msg   longpath2
;---------------------- 			; "%1"
Message_Number	= 80
Handle		= STDOUT
Sublist 	= None
Count		= None
Class		= UTILITY_MSG_CLASS
Function	= NO_INPUT
Input		= N_A
	Define_Msg   longpath3			; To run CHKDSK, the drive must not
;---------------------- 			; contain paths longer than 64 ...
Message_Number  = MSG_OPTIONS_FIRST
Handle          = STDOUT
Sublist         = None                          ; AN045;bgb                     ;an000;bgb
Count           = None                          ; AN045;bgb                     ;an000;bgb
Class           = utility_msg_class             ; AN045;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN045;bgb                     ;an000;bgb
Input           = N_A                           ; AN045;bgb                     ;an000;bgb
        Define_Msg   options1
;----------------------     
Message_Number  = MSG_OPTIONS_LAST
Handle          = STDOUT
Sublist         = None                          ; AN045;bgb                     ;an000;bgb
Count           = None                          ; AN045;bgb                     ;an000;bgb
Class           = utility_msg_class             ; AN045;bgb                     ;an000;bgb
Function        = NO_INPUT                      ; AN045;bgb                     ;an000;bgb
Input           = N_A                           ; AN045;bgb                     ;an000;bgb
        Define_Msg   options2
;----------------------                         ;                               ;an000;bgb
Message_Number  = 59                            ;                      ;C06
Handle          = STDERR                        ;                      ;C06
Sublist         = none                          ;                      ;C06
Count           = none                          ;                      ;C06
Class           = UTILITY_MSG_CLASS             ;                      ;C06
Function        = NO_INPUT                      ;                      ;C06
Input           = N_A                           ;                      ;C06
        Define_Msg   crlf2_arg                  ;  CR,LF               ;C06
                                                                                ;an000;bgb
;                                                                               ;an000;bgb
;*****************************************************************************  ;an000;bgb
; Message Data Area                                                             ;an000;bgb
;*****************************************************************************  ;an000;bgb
;                                                                               ;an000;bgb
                                                                                ;an000;bgb
yn_arg      dw      ?                                                           ;an000;bgb
                                                                                ;an000;bgb
;orph_num    dw      ?  ;from orphsiz; = number of lost clusters                 ;an000;bgb;an049;bgb
orphcnt     dd      ?  ;number of chains of lost clusters                       ;an000;bgb
                                                                                ;an000;bgb
report_arg  dw      ?                                                           ;an000;bgb
rarg1       dd      ? ;changed to dword                                         ;an000;bgb;an049;bgb
rarg3       dd      ? ;changed to dword                                         ;an000;bgb;an049;bgb
                                                                                ;an000;bgb
baddrvm     DB      " A.",0                                                     ;an000;bgb
badrw_str   dw      ?                                                           ;an000;bgb
badrw_num   dw      ?                                                           ;an000;bgb
block_num   dw      ?                                                           ;an000;bgb
fatal_arg1  dw      ?                                                           ;an000;bgb
fatal_arg2  dw      ?                                                           ;an000;bgb
file_arg1   dw      ?                                                           ;an000;bgb
file_arg2   dw      ?                                                           ;an000;bgb
free_arg1   dw      ?                                                           ;an000;bgb
free_arg2   dw      ?                                                           ;an000;bgb
free_arg3   dw      ?                                                           ;an000;bgb

;/M002 BEGIN */
;/* the following two SHD be together (so as to terminate fatal_end string */
fatal_end   db     "."  
NullMsg	    db	    0
;/*M002 END */
                                                                                ;an000;bgb
                                                                                ;an000;bgb
data ends                                       ; AN000;                        ;an000;bgb

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkdsk2.asm ===
;==================================================================
; CHKDSK2.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; CHANGE HISTORY:
; M003   NSM    1/30/91         Always report correct FREE mem at the end of 
;                               chkdsk inspite of where chkdsk was loaded
;==================================================================

TITLE   CHKDSK - MS-DOS Disk consistancy checker
page    ,132                                    ;

	.xlist
	include chkseg.inc
	INCLUDE CHKCHNG.INC
	INCLUDE DOSSYM.INC
	INCLUDE CHKEQU.INC
	INCLUDE CHKMACRO.INC
	include pathmac.inc
	include version.inc    ; needs to see MSVER on pass 1
	.list

SUBTTL  Initialized Data
PAGE
CONST   SEGMENT PUBLIC PARA 'DATA'
	EXTRN  BADVER:byte,BADDRV_ARG:word,INVPATH_ARG:word
	EXTRN  FILE_ARG:word
	EXTRN  BADCD_ARG:word,BADSUBDIR:byte
	EXTRN  BADDRVM:byte
	EXTRN  BADIDBYT:byte
	EXTRN  OPNERR_ARG:word,NOEXT_ARG:word,EXTENT_ARG:word
	EXTRN  IDMES_ARG:WORD
	EXTRN  FILE_ARG1:WORD,FILE_ARG2:WORD
	EXTRN  badrw_num:word,BADRW_STR:WORD,BLOCK_NUM:WORD
	EXTRN  BADSW_ARG:WORD,DSKSPC:WORD
	EXTRN  HIDMES:WORD,DIRMES:WORD,FILEMES:WORD,ORPHMES2:WORD
	EXTRN  ORPHMES3:WORD,BADSPC:WORD,FRESPC:WORD
	EXTRN  TOTMEM:WORD,FREMEM:WORD,REPORT_ARG:WORD,CRLF_ARG:WORD
	EXTRN  RARG1:dWORD,RARG3:dWORD,ORPHCNT:dWORD                ;an049;bgb
	EXTRN  SubstErr:BYTE
	extrn  tot_bytes_lo:word, tot_bytes_hi:word

	extrn   SWITCHAR:byte,TCHAR:byte,HECODE:byte,CONBUF:byte
	extrn   DOTMES:byte,NOISY:byte,HAVFIX:byte
	extrn   DOFIX:byte,DIRBUF:near,PARSTR:byte
	extrn   NUL:byte,ERRSUB:word,ALLFILE:byte
	extrn   ORPHFCB:byte,ORPHEXT:byte,HIDCNT:dword
	extrn   HIDSIZ:word,FILCNT:dword,FILSIZ:word,DIRCNT:dword                ;an049;bgb
	extrn   DIRSIZ:word,CROSSCNT:dword,BADSIZ:word                       ;an049;bgb
	extrn   ORPHSIZ:word                                                ;an049;bgb
	extrn   LCLUS:word                                                  ;an049;bgb
	extrn   USERDIR:byte,FRAGMENT:byte
	extrn   ALLDRV:byte,FIXMFLG:byte,DIRCHAR:byte
	extrn   EOFVAL:word                                                  ;an050;bgb
	extrn   Idmes2:Byte,Idmes1:Byte,idmes3:byte                             ;an017;bgb
CONST   ENDS

SUBTTL  Un-initialized Data
PAGE
DATA    SEGMENT PUBLIC PARA 'DATA'
	extrn   THISDPB:dword,DOTSNOGOOD:byte,NUL_ARG:byte
	extrn   NAMBUF:byte,SRFCBPT:word
	extrn   ISCROSS:byte,MCLUS:word,CSIZE:byte,SSIZE:word
	extrn   DSIZE:word,ARG1:word,ARG_BUF:byte,ERRCNT:byte
	extrn   USERDEV:byte,HARDCH:dword,CONTCH:dword
	extrn   mem_size:word                                                   ;an055;bgb
	extrn   top_of_mem:word         ; M003
	extrn   max_free:word           ; M003
	extrn   psp_segment:word                                                ;an030;bgb
	extrn   write_fault:byte                                                ;an045;bgb
DATA    ENDS

CODE    SEGMENT PUBLIC PARA 'CODE'
ASSUME  CS:DG,DS:DG,ES:DG,SS:DG
	EXTRN   INT_23:NEAR
	EXTRN   PROMPTYN:NEAR,GET_CURRDIRERR:NEAR,GET_CURRDIR:NEAR
	EXTRN   FINDCHAIN:NEAR,CHECKERR:NEAR
	EXTRN   Write_Disk:Near, multiply_32_bits:near

	PUBLIC  PRINTF_CRLF,DOCRLF,SUBERRP,FCB_TO_ASCZ,EPRINT
	PUBLIC  DOINT26,DOTCOMBMES,REPORT
	public  ramcarv


;EPRINT:
;        CALL    CHECKERR
;        JNZ     RET14
;        cmp     byte ptr [nul_arg],0
;        jnz     hav_eprint_arg
;        mov     [file_arg2],offset dg:nul
;hav_eprint_arg:
;        mov     [file_arg1],dx
;       ;mov     dx,offset dg:file_arg
;        mov     dx,file_arg                     ;Get offset of message          ;AC000;
;        call    printf_crlf
;        mov     byte ptr [nul_arg],0
;RET14:  ret


EPrint:
	call    CheckErr                        ;See if we should display msg
	pathlabl chkdsk2
;       $IF     Z                               ;Yes if Z set                   ;AC000;
	JNZ $$IF1
	push    dx                              ;Save message                   ;AC000;
	Message File_Arg                        ;Put out file in question       ;AC000;
	pop     dx                              ;Get back message               ;AC000;
	call    Printf_CRLF                     ;Print it
	cmp     byte ptr [nul_arg],0            ;Is there a second message?
;       $IF     NZ                              ;Yes if not nul                 ;AC000;
	JZ $$IF2
	mov     dx,File_Arg2                    ;Display it                     ;AN000;
	call    Printf_CRLF                     ;                               ;AN000;
;       $ENDIF                                  ;                               ;AC000;
$$IF2:
	mov     byte ptr [nul_arg],0            ;Re-init this field
;       $ENDIF
$$IF1:
	ret                                     ;

DOTCOMBMES:
	CMP     [NOISY],0
	JZ      SUBERRP
	mov     [file_arg2],dx
	CALL    get_currdirERR
       ;MOV     DX,OFFSET DG:CENTRY             ;Centry got split into 3 msg's
       ;inc     byte ptr [nul_arg]              ;
	CALL    EPRINT
	RET

SUBERRP:
	MOV     AL,1                    ;found a subdir error
	XCHG    AL,BYTE PTR [ERRSUB]    ;set error flag and get old flag
	CMP     AL,0                    ;were any errors found before?
;       $if     z                       ;no errors found yet
	JNZ $$IF5
					 ;JNZ     RET32
	    MOV     SI,OFFSET DG:NUL       ;display error msgs
	    CALL    get_currdirERR
	    MOV     DX,OFFSET DG:BADSUBdir
	    CALL    EPRINT
;       $endif
$$IF5:
RET32:  RET

;****************************************************************************
; called by:  get_thisel2
; inputs:   DS:SI - pointer to file name
;****************************************************************************
FCB_TO_ASCZ:                            ;Convert DS:SI to ASCIZ ES:DI
	PUSH    CX
;move filename from ds:si to es:di
	MOV     CX,8                    ; Pack the name
	REP     MOVSB                   ; Move all of it
main_kill_tail:
; delete trailing spaces in name
	CMP     BYTE PTR ES:[DI-1]," "  ;was the last char in name a space?
	JNZ     find_check_dot
	DEC     DI                      ; Back up over trailing space
	INC     CX
	CMP     CX,8
	JB      main_kill_tail
find_check_dot:
; ???
	CMP     WORD PTR [SI],(" " SHL 8) OR " "
	JNZ     got_ext                 ; Some chars in extension
	CMP     BYTE PTR [SI+2]," "
	JZ      find_done               ; No extension
got_ext:
; move period for extension
	MOV     AL,"."
	STOSB
; move 3 byte extension
	MOV     CX,3
	REP     MOVSB
ext_kill_tail:
;delete trailing blanks
	CMP     BYTE PTR ES:[DI-1]," "  ;
	JNZ     find_done               ;
	DEC     DI                      ; Back up over trailing space
	JMP     ext_kill_tail           ;
find_done:                              ;
; put hex zero at the end
	XOR     AL,AL                   ;
	STOSB                           ; NUL terminate
	POP     CX
	RET


DOINT26:
;       PUSH    CX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
;       PUSH    DX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
;       PUSH    BX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
	call    Write_Disk              ;                                       ;an045;bgb;AC000;
;       POP     BX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
;       POP     DX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
;       POP     CX                      ;reg saves are handled in write_disk    ;ac048;bgb;an045;bgb
;       JNC     RET23                                                           ;ac048;bgb;an045;bgb
       ;MOV     SI,OFFSET DG:WRITING                                            ;ac048;bgb;an045;bgb
       ;CALL    DSKERR                                                          ;ac048;bgb;an045;bgb
;      $IF      C                                                               ;ac048;bgb;an045;bgb
       JNC $$IF7
	   mov     dx,offset dg:write_fault                                     ;ac048;bgb;an045;bgb
	   invoke  printf_crlf                                                  ;ac048;bgb;an045;bgb
;      $ENDIF                                                                   ;ac048;bgb;an045;bgb
$$IF7:
;                                                                               ;ac048;bgb;ac048;bgb;an045;bgb
;Need to handle 'Fail' option of critical error here.                           ;ac048;bgb;an045;bgb
;                                                                               ;ac048;bgb;an045;bgb
										;ac048;bgb;an045;bgb
;       JZ      DOINT26                                                         ;ac048;bgb;an045;bgb
RET23:  RET                                                                     ;ac048;bgb;an045;bgb



;**************************************
; Prints all reporting data
;**************************************

REPORT:
;total disk space
    mov     bx,offset dg:dskspc
    mov     dx,tot_bytes_hi             ;total bytes   in disk          ;AN006;bgb
    mov     ax,tot_bytes_lo             ;total bytes   in disk          ;AN006;bgb
    xor     si,si                       ;no file count
    xor     di,di                       ;no file count
    call    Report_Mes_2                ;                               ;AN006;bgb
;hidden files
    mov     ax,hidsiz                   ;get cluster count              ;an049;bgb
    or      ax,ax                       ;are there any hidden files?
;   $IF     NZ                          ;yes                                   ;AC000;
    JZ $$IF9
	mov     si,word ptr hidcnt      ;si=low file count                  ;an049;bgb
	mov     di,word ptr hidcnt+2    ;di=hi file count                   ;an049;bgb
	mov     bx,offset dg:hidmes     ;bx=msg ;
	call    report_mes_1                    ;
;   $ENDIF                                  ;                               ;AC000;
$$IF9:
;space in subdirectories
    mov     ax,dirsiz                   ;get cluster count
    or      ax,ax                       ;Are there any directories?    ;an049;bgb
;   $IF     NZ                          ;yes                                   ;AC000;
    JZ $$IF11
	mov     si,word ptr dircnt      ;si=low file count                  ;an049;bgb
	mov     di,word ptr dircnt+2    ;di=hi file count                   ;an049;bgb
	mov     bx,offset dg:dirmes     ;bx=msg
	call    report_mes_1                                                ;an049;bgb
;   $ENDIF                                  ;                               ;AC000;
$$IF11:
;user files
    mov     ax,filsiz                   ;get cluster count
    or      ax,ax                       ;Are there any user files?    ;an049;bgb
;   $IF     NZ                          ;yes                                   ;AC000;
    JZ $$IF13
	mov     si,word ptr filcnt      ;si=lo file count                   ;an049;bgb
	mov     di,word ptr filcnt+2    ;di=hi file count                   ;an049;bgb
	mov     bx,offset dg:filemes    ;bx=msg
	call    report_mes_1
;   $ENDIF                                  ;                               ;AC000;
$$IF13:
;chains of lost clusters
    mov     ax,orphsiz                  ;get cluster count
    or      ax,ax                       ;Are there any lost clusters?   ;an049;bgb
;   $IF     NZ                          ;yes                                   ;AC000;
    JZ $$IF15
	mov     si,word ptr orphcnt     ;si=lo file count
	mov     di,word ptr orphcnt+2   ;di=hi file count
	cmp     dofix,0                 ;/F entered?
;       $IF     Z                       ;no                             ;AC000;
	JNZ $$IF16
	    mov     bx,offset dg:orphmes3 ;bytes would be recovered
;       $else
	JMP SHORT $$EN16
$$IF16:
	    mov     bx,offset dg:orphmes2 ;bytes were   recovered
;       $ENDIF                                  ;                               ;AC000;
$$EN16:
	call    report_mes_1
;   $ENDIF                                  ;                               ;AC000;
$$IF15:
;clusters of bad spots
    mov     ax,badsiz                   ;get cluster count
    or      ax,ax                       ;Are there any bad spots on disk?
;   $IF     NZ                          ;if low word > zero, then yes          ;AC000;
    JZ $$IF20
	xor     si,si                   ;no files to count
	xor     di,di                   ;no files to count
	mov     bx,offset dg:badspc             ;Issue report
	call    report_mes_1
;   $ENDIF                                  ;                               ;AC000;
$$IF20:
;bytes on disk left - free space

;;;BEGIN CHANGES FOR DOS 6 oct 22 Scottq
;;;
;;;instead of using the dos dpb value for total number of clusters,
;;;we take the total space (retrieved via int 21h function 36)
;;;and divide by cluster size.  If someone has hooked the size function,
;;;(dblspace) to return a different total space from the dpb, then
;;;the free space returned will still be correct.

	;;; get bytes per cluster into cx...
	xor     ah,ah                           ;                               
	mov     cx,SSize                        ;Bytes/sector *                 
	mov     al,CSize                        ; Sectors/cluster               
	mul     cx                              ; = Bytes/Cluster in AX         
	mov     cx,ax
	;;; get total bytes into dx:ax
	mov     dx,tot_bytes_hi             ;total bytes   in disk          
	mov     ax,tot_bytes_lo             ;total bytes   in disk          
	;;; get total clusters into ax 
	div     cx

	; replaced with above
	;;;mov     ax,[dsize]              ;get total disk clusters
;;;END CHANGES FOR DOS 6 oct 22 Scottq

	sub     ax,[dirsiz]             ; - dirs
	sub     ax,[filsiz]             ; - files
	sub     ax,[hidsiz]             ; - hidden files
	sub     ax,[badsiz]             ; - bad spots
	sub     ax,[orphsiz]            ; - lost clusters recovered
	sub     ax,[lclus]              ; - lost clusters not recovered
	xor     si,si
	xor     di,di
	mov     bx,offset dg:frespc
	call    report_mes_1            ;Free space is whats left
	call    docrlf                          ;                               ;AN000;
;size of each allocation unit
	xor     dx,dx                           ;Figure out cluster size        ;AN000;
	xor     ah,ah                           ;                               ;AN000;
	mov     cx,SSize                        ;Bytes/sector *                 ;AN000;
	mov     al,CSize                        ; Sectors/cluster               ;AN000;
	mul     cx                              ; = Bytes/Cluster in AX         ;AN000;
	mov     bx,offset dg:idmes2             ;Allocation size message        ;AN000;
	xor     si,si
	xor     di,di
	call    Report_Mes_2                    ;                               ;AN000;
;total clusters
	mov     ax,Mclus                        ;Allocation units available     ;AN000;
	dec     ax                              ;MCLUS is # clusters+1
	xor     dx,dx                           ;                               ;AN000;
	mov     bx,offset dg:idmes1             ;                               ;AN000;
	xor     si,si
	xor     di,di
	call    Report_Mes_2                    ;                               ;AN000;
;;;;;;;;call    docrlf                  ;                                       ;an017;bgb
;avail clusters                                                                 ;an017;bgb
public avail_clus
avail_clus:
	mov     ax,[dsize]              ;total clusters on disk                 ;an017;bgb
	sub     ax,[dirsiz]             ; - clusters in subdirs                 ;an017;bgb
	sub     ax,[filsiz]             ; - user files                          ;an017;bgb
	sub     ax,[hidsiz]             ; - hidden files                        ;an017;bgb
	sub     ax,[badsiz]             ; - bad spots                           ;an017;bgb
	sub     ax,[orphsiz]            ; - lost clusters recovered                                        ;an017;bgb
	sub     ax,[lclus]              ; - lost clusters not recovered         ;an017;bgb
	mov     bx,offset dg:idmes3             ;                               ;an017;bgb
	xor     dx,dx                           ;                               ;AN017;bgb
	xor     si,si
	xor     di,di
	call    Report_Mes_2            ;dont convert to bytes!                 ;an017;bgb
	call    docrlf                                                          ;an017;bgb

; get the size of conv mem  by calling INT 12

	int     12h                     ; query for total mem in system
	mov     dx,64                   ; convert to total no of paras
	mul     dx                      ; dx:ax =size of mem IN PARAS
	mov     [mem_size],ax           ;

;dcl Jan 8, 87 Compensate for RAM Carving - Start
;/* M001 BEGIN */
; Add size of XBDA only if it is located contig. to conv.mem reported by
; INT 12; else it is probably moved by EMM386 to somewhere within conv. mem
; and so it is already counted by INT 12 figure. 

ramcarv:
if      MSVER                           ; MSKK03 07/14/89
	xor     bx,bx
else
	push    es
	xor     bx,bx   
	mov     ah,0c1h                 ; return Ext'd Bios Data Seg Address    
	int     15h     
;       $IF     NC                      ; ram carving exists if no carry
	JC $$IF22
	   mov     ax,es                ; see whether XBDA is just at the end
	   cmp     ax,[mem_size]        ; of conv mem. reported by int 12
	   jne  $$IF22                  ; if not at end, don't add size of XBDA
	   xor     ax,ax                ; zero out ax
	   mov     al,byte ptr es:[0]   ; pointer to # of 1k blocks of RAM Carve
	   mov     dx,64                ; convert 1k blocks to paras    
	   mul     dx                                           
	   mov     bx,ax                   ; save value in BX
;       $ENDIF                                  ;       
$$IF22:
	pop     es                              
endif
;/* M001 END */

;dcl Jan 8, 87 Compensate for RAM Carving - End

	mov     ax,[mem_size]        ;Find out about memory
	add     ax,bx                   ; dcl Jan 8, 87 Compensate for RAM Carving
	mov     dx,16                   ;Mul to convert kbytes to bytes
	mul     dx
	mov     bx,offset dg:totmem
	call    report_mes_2

; /* M003 BEGIN */
; report free space
; see where we are loaded ; if we are loaded in conv. memory, then take the
; top_of_mem (from ds:2) and report (top_of_mem -our psp) as the free size.
; if we are loaded in UMBs,  report the max_free value as the FREE mem value
	mov     ax,[max_free]
	or      ax,ax                   ; are we loaded in UMB ?
	jnz     rep_free_mem            ; yes, and so we have the right figure
					; in ax

; we are loaded in conv. mem.
; calculate the free size as (top_of_mem - our psp_seg ptr + 1) 

	mov     ax,[top_of_mem]         
	sub     ax,psp_segment          
	push	ax			; Put amount free on TOS

;
; if our environment space is right above our PSP (just lower), then the
; actual largest-executable-size needs to encompass that space as well.  So
; check our environment pointer to see if CHKDSK's PSP is the next block--if
; so, add out environment space to max_free
;

	push	ds			; Store DS before we go change it...

	mov     ax,psp_segment          ; Now grab our PSP...
	push	ax			;    put it on the stack above AmtFree
	mov	ds,ax			; And stick it in DS for reference

	mov	dx,ds:[2ch]		; DX = pointer to our environment space
	dec	dx			; Back up one, to its MCB

	mov	ds,dx			; Now we want to work with what's here:
	mov	bx,ds:[3]		; BX = size of environment
	inc	bx			;      (add 1 paragraph for the header)
	mov	ax,bx			; AX = size of environment too
	add	ax,dx			; DX = location of environment,-1
	inc	ax			; +1 for MCB of next block

;
; At this point, AX is the address of CHKDSK's PSP if it is loaded in the
; adjacent MCB, and CHKDSK's actual PSP is at the top of the stack.  BX is
; the size of the environment, and will be added to the amount free--so if
; CHKDSK isn't in the next MCB, we have to zero it.
;

	pop	dx			; DX = CHKDSK's PSP, AX = calculated
	cmp	ax, dx			; Are they the same?
	jz	AddEnvSpace		; Yes--leave BX == size of environment

	xor	bx, bx			; No?  Then clear BX.

AddEnvSpace:
	pop	ds			; Restore DS as it was earlier...

	pop	ax			; Restore the amount free
	add	ax, bx			; Account for size of environment

; ax = free mem size in conv. mem

rep_free_mem:
; /* M003 END */
	mov     dx,16
	mul     dx
	mov     bx,offset dg:fremem
	call    report_mes_2
	ret

;*************************************************************
;
;  Print the message specified by the control string.
;
; REPORT_MES_1
; On entry:
;     BX contains the address of the control string.
;     AX contains a cluster count for the %ld argument in the control string.
;     CX contains a word count for the %d argument in the control string
;        or is meaningless.
;
; REPORT_MES_2
; On entry:
;     BX contains the address of the control string.
;     AX,DX contain a long integer.
;     CX contains a word count for the %d argument in the control string
;        or is meaningless.
;
;*************************************************************

;*****************************************************************************
; REPORT_MES_1 -  Print the report messages.  Display the file count and
;                translate the number of clusters into the number of bytes.
;
; WARNING!! NOTE!! -->
;
; called by - PROCEDURE NAME
;
; inputs: AX - cluster count (1-ffff)
;         BX - offset of control string
;         CX -
;         DX - high word of cluster count is zero'd out here.
;         SP -
;         BP -
;         SI - low word of file count
;         DI - hi  word of file count
;         DS - segment of control string
;         ES -
;
; output: DISPLAY OF DATA TO SCREEN
;
; Regs abused - ALL
;
;logic: 1. zero out hi word of cluster count, and multiply by sectors per
;          cluster.  This gives number of sectors, which is a double word.
;
;       2. multiply by bytes per sector to give number of bytes.
;
;       3. place values in diplay fields, and call the msg. retriever.
;
;*****************************************************************************
report_mes_1:
	push    bx                      ;save it
	xor     dx,dx                   ;zero out hi word for multiply
	mov     cl,csize                ;get sectors per cluster
	xor     ch,ch                   ;zero out hi byte of word
	mul     cx                      ;Convert cluster count to sector count ax/dx

	mov     bx,dx                   ;bx:ax is number to be mult;bgb
	mov     cx,ssize                ;cx is number to mult with  ;bgb
	call    multiply_32_bits                       ;bgb
	mov     dx,bx                   ;move hi value to dx
	pop     bx                      ;retore pointer;bgb

report_mes_2:
	mov     word ptr rarg1,ax       ;Lo word of bytes in ax
	mov     word ptr rarg1+2,dx     ;Hi word of bytes in dx
	mov     word ptr rarg3,si       ;lo word of file count in si
	mov     word ptr rarg3+2,di     ;hi word of file count in di
	mov     report_arg,bx           ;Store the offset of the ctrl string
	mov     dx,bx                   ;dx has ptr to msg for disp_interface  ;AC000;
	call    printf_crlf             ;print msg, then carraige return
	ret

PRINTF_CRLF:
	call    display_interface   ;                                       ;AC000;
DOCRLF: mov     dx,offset dg:crlf_arg
	call    Display_Interface       ;Replace old printf call with SysDispMsg;AN000;
	ret                             ;                                       ;AN000;


	pathlabl chkdsk2
CODE    ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkequ.inc ===
;==================================================================
; CHKEQU.INC
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; CHANGE HISTORY:
; M003   NSM	1/30/91		 Add a new equate for UMB_HEAD in DOS DATA
;==================================================================

;fsexec  equ	 true			     ;				     ;	 ;an038;bgb  ;
FCB	EQU	5CH

String_Done equ 0
No_Error equ	0
chk_Error   equ     1
Stderr	equ	2

FALSE	EQU	0
TRUE	EQU	NOT FALSE

; NOTE WARNING DANGER.
; THIS EQU DEFINES AN OFFSET INTO THE SEARCH FCB OF THE LASTENT VALUE.
; ITS LOCATION MAY CHANGE FROM DOS VERSION TO DOS VERSION.
;2.0/2.1 value
;THISENT EQU	 17H			 ;Relative entry number of current entry
;3.0 value
THISENT EQU	14H				;Relative entry number of current entry


;Attribute bits

RDONLY	EQU	1
HIDDN	EQU	2
SYSTM	EQU	4
VOLIDA	EQU	8
ISDIR	EQU	10H
DRVCHAR EQU	":"
;
;*****************************************************************************
; Equates
;*****************************************************************************
;

Multiplex equ	2Fh				;				;AN000;
Set_Append_X equ 0B707h 			;				;AN000;;
Append_X equ	0B706h				;				;AN000;;
Append_X_Set equ 1				;				;AN000;
Append_Off equ	0				;				;AN000;
Append_ON equ	1				;				;AN000;


Disk_Error	equ	80h			;INT 24h bit clear if disk error;AN000;

NO	equ	0								;AN000;
YES	equ	not NO								;AN000;

Year_Mask	equ	0FE00h
Month_Mask	equ	01E0h
Day_Mask	equ	001Fh
Hour_Mask	equ	0F800h
Minute_Mask	equ	07E0h

Not_Include	equ	0
Do_Include	equ	1


YES_Found equ	1
NO_Found equ	0

ON	equ	1
OFF	equ	0

No_Ext_Attrib	equ	0							;AN000;
No_Entry	equ	0
XA_Chain	equ	84h			;Mark head of XA chain		;AN000;

ifdef	fsexec									;an038;bgb
Len_FS_String_Buffer	equ	13						;an038;bgb
FAT12_File_System equ 01h							;an038;bgb;AN000;
FAT16_File_System equ 04h							;an038;bgb;AN000;
New_File_System equ 06h 							;an038;bgb;AN000;
endif

Bad_Exit	equ	0FFh			;Errorlevel = 0FFh		;AN000;

Net_Check equ	1200h								;AN000;
Assign_Check equ 8000h								;AN000;

Found_Yes equ	1								;AN000;
Found_No equ	0								;AN000;

Asciiz_End equ	0								;AN000;

Dir_Attribute	equ	10h
Vol_Attribute	equ	08h

Dir_Entries_Per_Sector	equ	512/32


Critical_Error_Fail	equ	3
Write_Protect	equ	0
Drive_Not_Ready equ	2

Blank	equ	" "                                                             ;AN000;

Head_Mask	equ	7Fh			;Mask to turn off head bit	;AN000;


;Limits
BIG_FAT_THRESHOLD equ 4086							;AN000;



;-------------------------------------------------------------------------------
; These are the data structures which we will need
;****************************************************************************
; Structures
;****************************************************************************
ifdef	fsexec									;an038;bgb
Exec_Block_Parms struc								;an038;bgb
Segment_Env dw	0								;an038;bgb
Offset_Command dw 0								;an038;bgb
Segment_Command dw 0								;an038;bgb
Offset_FCB1 dw	0								;an038;bgb
Segment_FCB1 dw 0								;an038;bgb
Offset_FCB2 dw	0								;an038;bgb
Segment_FCB2 dw 0								;an038;bgb
Exec_Block_Parms ends								;an038;bgb

Media_ID struc									;AN000;
Media_ID_Info_Level dw 0							;AN000;
Media_ID_Serial_Number dd 0							;AN000;
Media_ID_Volume_Label db 11 dup(" ")                                            ;AN000;
Media_ID_File_System db 8  dup(" ")                                             ;AN000;
Media_ID ends									;AN000;
endif										;an038;bgb

Sublist_Struc struc
Sublist_Size	db	?			;				;AN000;
Sublist_Rsv	db	?			;				;AN000;
Sublist_Offset	dw	?			;				;AN000;
Sublist_Segment dw	?			;				;AN000;
Sublist_Number	db	?			;				;AN000;
Sublist_Type	db	?			;				;AN000;
Sublist_Max	db	?			;				;AN000;
Sublist_Min	db	?			;				;AN000;
Sublist_Char	db	?			;				;AN000;
Sublist_Struc ends

A_DeviceParameters	struc

SpecialFunctions	db	?    ;1  0
DeviceType		db	?    ;1  1
DeviceAttributes	dw	?    ;2  2
NumberOfCylinders	dw	?    ;2  4
MediaType		db	?    ;1  6
BytePerSector		dw	?    ;2  7
SectorsPerCluster	db	?    ;
ReservedSectors 	dw	?
NumberOfFATs		db	?
RootEntries		dw	?
TotalSectors		dw	?
MediaDescriptor 	db	?
SectorsPerFAT		dw	?
SectorsPerTrack 	dw	?
Heads			dw	?
HiddenSectors		dd	?
Ext_Total_Sectors	dd	?
ReservedArea		db	6 dup(?)

A_DeviceParameters	ends




Relative_Sector_Buffer	struc			;				;AN000;

Start_Sector_Low	dw	?		;Low word of RBA sector 	;AN000;
Start_Sector_High	dw	?		;High word of RBA sector	;AN000;
Number_Sectors		dw	?		;Number of sectors		;AN000;
Buffer_Offset		dw	?		;Address of data buffer 	;AN000;
Buffer_Segment		dw	?		;				;AN000;

Relative_Sector_Buffer ends			;				;AN000;


XAL	struc									;AN000;

XAL_Tsize	dw	?							;AN000;
XAL_TCount	dw	?							;AN000;
XAL_LSize	dw	?							;AN000;
XAL_LCount	dw	?							;AN000;
XAL_Data	db	512-8 dup(?)						;AN000;

XAL	ends									;AN000;

DIRENT	STRUC
	DB	7 DUP (?)		;Ext FCB junk
	DB	?			;Drive
DIRNAM	DB	11 DUP (?)			;
DIRATT	DB	?				;
DIRCP	DW	?				;				;AN000;
DIR_XA	DW	?				;				;AN000;
DIRATT2 db	?				;				;AN000;
DIRRES	DB	5 DUP (?)			;				;AC000;
DIRTIM	DW	?				;
DIRDAT	DW	?				;
DIRCLUS DW	?				;
DIRESIZ DD	?				;
DIRENT	ENDS					;
ENTSIZ	EQU	SIZE DIRENT

;-------------------------------------------------------------------------------

; /* M002 BEGIN */
; Message no equates 

StackMsgNo	equ	76
BadRdMsg	equ	77
baddpbdirMsg	equ	63

; /* M002 END */

UMB_PTR		equ	08CH		; M003 - ptr to UMB_HEAD in dos data 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkinit.asm ===
;******************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/21/90  EGH  C03  Problem fixed - the error message generated by CHKDSK/Z
;		       contained garbage.  The fix is to check for a NUL as
;		       as well as a space when searching for the beginning of
;		       the parameter.  STR #2021
;  03/21/90  EGH  C04  Problem fixed - the command CHKDSK FILE /F does not
;		       check FILE for fragmentation.  The fix is to  clear
;		       critical data areas before calling the system parser.
;		       STR #2050
;
;  02/05/91  MD   M004 Removed obsolete references to IBMCOPYRIGHT
;
;******************************************************************************
page	,132					;
;*****************************************************************************
;*****************************************************************************
;UTILITY NAME: CHKOVER.COM
;
;MODULE NAME: CHKINIT.SAL
;
;
; Main_Init 
;
;  
;       
;  Init_Input_OutputPreload_Messages
;      
;  			   
;  			   Parse_Drive_Letter 
;  			   
;  			   
;  			   Parse_Command_Line 
;; 			   
;  			   
;  			   Interpret_Parse
;  			    
;   
;  Validate_Target_DriveCheck_Target_Drive
;  
;  			   
;  			   Check_For_Network
;  			   
;  			   
;  			   Check_Translate_Drive
;  			    
;  
;  Hook_Interrupts
;  
;  
;  Clear_Append_X
;  
;   
;  CHKDSK_IFSEXEC_FS_CHKDSK
;  
;  		
;  		Main_Routine
;  		 
;  
;  Reset_Append_X
;   
;*****************************************************************************
;
;*****************************************************************************

;
;*****************************************************************************
; Include files
;*****************************************************************************
.xlist										
include chkseg.inc					
include pathmac.inc								
INCLUDE CHKEQU.INC				;				
INCLUDE CHKCHNG.INC				;List of changes		
include dossym.inc								
INCLUDE SYSCALL.INC				;				
INCLUDE CHKMACRO.INC				;				
INCLUDE CHKPARSE.INC				;				
include bpb.inc 	   ; ioctl needs def of A_BPB from here
INCLUDE IOCTL.INC								
.list										
										
										
										
psp    segment public para 'DUMMY'						
	org	05Ch								
FCB1	label	byte								
	org	06Ch								
FCB2	label	byte								
psp    ends									
										
;										
DATA	segment public para 'DATA'						
;*****************************************************************************	
; Data	Area									
;*****************************************************************************	
old_drive db 0									

include version.inc

;M004 - all references to these are commented out, so they are too
;myramdisk db 'RDV 1.20'
;myvdisk   db 'VDISK'								
;end M004

bytes_per_sector     dw   0			
BPB_Buffer A_DeviceParameters <>		;				
										
Data_Start_Low dw ?				;				
Data_Start_High dw ?				;				
										
public command_line_buffer							
Command_Line_Buffer db 128 dup(0)		;				
Command_Line_Length equ $ - Command_Line_Buffer ;				
										
Fatal_Error db	0				;				
										
Command_Line db NO				;				
Append	db	0				;				
										
ifdef	fsexec									
 ;These should stay together			 ;				
 ; ---------------------------------------	 ;  ;				
 FS_String_Buffer db 13 dup(" ")		 ;				
 FS_String_End db "CHK.EXE",0			 ;				
 Len_FS_String_End equ $ - FS_String_End	 ;				
 ;----------------------------------------	 ;				
 FS_Not_Fat db	 0				 ;				
 FAT12_String db "FAT12   "			 ;				
 FAT16_String db "FAT16   "			 ;				
 Len_FS_ID_String equ $ - FAT16_String		 ;				
 Media_ID_Buffer Media_ID <>			 ;				
endif										

ExitStatus db	0				;

fUnderWindows	db	NO	; Yes if Windows or task switcher active

IFDEF DBLSPACE_HOOKS
fSpawnDblSpace	db	NO	; Yes if should attempt to spawn dblspace/chkdsk
ENDIF

PSP_Segment dw	0				;				
tot_bytes_lo  dw  0		     ; low word of number of sectors in disk	
tot_bytes_hi  dw  0		     ;high word of number of sectors in disk	
fat_dir_secs  dw  0		     ;sectors in fat, directory and resvd	

IFDEF DBLSPACE_HOOKS										
DblSpaceBase	db	"DBLSPACE.EXE",0	;base name used to srch PATH
ENDIF

DOS_BUFFER	db	45 dup (?)		; Find First/Next buffer

IFDEF DBLSPACE_HOOKS
; Make sure DblSpaceCmdTail to DblCmdSwitch is not larger than Exec_CmdTail!

DblSpaceCmdTail db	11,' /CHKDSK '	; **** Keep these together ****
DblCmdDrive	db	'X:'		; **** Keep these together ****
DblCmdSwitch	db	0dh,0,0,0dh	; **** Keep these together ****
ENDIF

;*****************************************************************************	
; Public Data Declarations							
;*****************************************************************************	
	public	bpb_buffer							
	public	tot_bytes_lo							
	public	tot_bytes_hi							
	public	fat_dir_secs							
	public	bytes_per_sector						
	Public	Data_Start_Low							
	Public	Data_Start_High 						
	Public	Fatal_Error							
	Public	ExitStatus							
	Public	PSP_Segment							
ifdef	fsexec									
	Public	FS_String_Buffer						
endif										
;										
;*****************************************************************************	
; External Data Declarations							
;*****************************************************************************	
	EXTRN	movsi:word  ;move si pointer here for display of invalid parm	
	EXTRN	fatcnt:Byte							
	EXTRN	AllDrv:Byte							
	EXTRN	VolNam:Byte							
	EXTRN	BadDrvM:Byte							
	EXTRN	OrphFCB:Byte							
	EXTRN	Arg_Buf:Byte							
	EXTRN	Noisy:Byte							
	EXTRN	DoFix:Byte							
	EXTRN	SubstErr:Byte							
	EXTRN	options1:Word
	EXTRN	MSG_OPTIONS_LAST:ABS
	EXTRN	No_Net_Arg:Byte 						
	EXTRN	UserDev:Byte							
	EXTRN	BadDrv_Arg:Byte 						
	EXTRN	TranSrc:Byte							
	EXTRN	ContCh:Word							
	EXTRN	HardCh:Word							
	EXTRN	Fragment:Byte							
	EXTRN	Parse_Error_Msg:Byte						
	EXTRN	Chkprmt_End:Byte						
	extrn	save_drive:byte 						
	EXTRN	Read_Write_Relative:Byte					
	EXTRN	inval_media:byte						
	EXTRN	WinPrsErr:byte
	extrn	lclus:word
	extrn	orphsiz:word
	extrn	crosscnt:dword
	extrn	SpawnAndExit:near
	extrn	Exec_Path:byte
	extrn	Exec_CmdTail:byte
data	ends									
										
;*****************************************************************************	
; External Routine Declarations 						
;*****************************************************************************

code	segment public para 'CODE'						
ifdef	fsexec									
	EXTRN	Exec_FS_CHKDSK:Near						
endif
	EXTRN	SysLoadMsg:Near 						
	EXTRN	SysDispMsg:Near 						
	EXTRN	Done:Near							
	EXTRN	Main_Routine:Near						
	EXTRN	INT_23:Near							
	EXTRN	INT_24:Near							
	EXTRN	Path_Name:Near							
	extrn	read_once:near
	extrn	Find_Path_In_Environment:near
	extrn	Search:near
	extrn	Path_Crunch:near

	public	p97, multiply_32_bits						
	public	func60								
	public	hook_interrupts 						
	public get_bpb
	public	ChkDskExit

   pathlabl chkinit							
;*****************************************************************************	
;Routine name:	Main_Init							
;*****************************************************************************	
;										
;Description: Main control routine for init section				
;										
;Called Procedures: Check_DOS_Version						
;		    Init_Input_Output						
;		    Validate_Target_Drive					
;		    Hook_Interrupts						
;		    Clear_Append_X						
;		    CHKDSK_IFS							
;		    Reset_Append_X						
;										
;Input: None									
;										
;Output: None									
;										
;Change History: Created	5/8/87	       MT				
;										
;Psuedocode									
;----------									
;										
;	Set segregs to DATA							
;	Get segment of PSP							
;	Fatal_Error = NO							
;	Flush all buffers (INT 21h AH=0Dh)					
;	Parse input and load messages (CALL Init_Input_Output)			
;	IF !Fatal_Error 							
;	   Check target drive letter (CALL Validate_Target_Drive)		
;	   IF !Fatal_Error							
;	      Set up Control Break (CALL Hook_Interrupts)			
;	      IF !Fatal_Error							
;		 CALL Clear_Append_X						
;		 CALL CHKDSK_IFS						
;		 CALL Reset_Append_X						
;	      ENDIF								
;	   ENDIF								
;	ENDIF									
;	Exit program								
;*****************************************************************************	
										
Procedure Main_Init				;				
	Set_Data_Segment			;Setup addressibility		
	call get_psp								
;;;;;;;;DOS_Call GetCurrentPSP			;Get PSP segment address	
;;;;;;;;mov	PSP_Segment,bx			;Save it for later		
	mov	Fatal_Error,No			;Init the error flag		
	Dos_Call	Disk_Reset		;Flush all buffers		
	call	Init_IO 			;Setup messages and parse	
	cmp	Fatal_Error,Yes 		;Error occur?			
;	$IF	NE				;Nope, keep going		
	JE $$IF1

	   call    Validate_Target_Drive	;Check drive letter		
	   cmp	   Fatal_Error,Yes		;Error occur?			
;	   $IF	   NE				;Nope, keep going		
	   JE $$IF2

; check for Windows. A chkdsk /F should not be allowed under Windows
; since there can be some other windows out there referring to
; this drive.
; Also check for DOSSHELL task switcher's presence.

	call	Check_Win_Shell
	jc	$$IF1				; quit if windows active

;;;;;;;;;;;;;;call    Hook_Interrupts		;Set CNTRL -Break hook		
	      call    Clear_Append_X		;				
	      call    CHKDSK_IFS		;Chkdsk correct file system	
	      call    Reset_Append_X		;

IFDEF DBLSPACE_HOOKS
	mov	fSpawnDblSpace, Yes		;didn't error out, attempt to
						;  spawn dblspace /chkdsk
ENDIF

;	   $ENDIF				;				
$$IF2:
;	$ENDIF					;				
$$IF1:
ChkDskExit:
	mov	al,ExitStatus			;Get Errorlevel
	or	al, al				;If errorlevel already != 0
	jnz	@f				;  just return whatever it is

	mov	cx, [orphsiz]			;errorlevel == 0 (so far),
	or	cx, word ptr [crosscnt] 	;  rtn 255 if any cross linked
	or	cx, word ptr [crosscnt+2]	;  files, lost clusters, or
	or	cx, [lclus]			;  orhpan files were found
	jcxz	@f
	mov	al, 0FFh			;errors! return errorlevel=255
@@:

IFDEF DBLSPACE_HOOKS
	call	TryDblSpaceChkDsk		;try to spawn dblspace/chkdsk
						;  didn't spawn if returns
ENDIF

	DOS_Call Exit				;Exit program			
	int	20h				;If other exit fails

Main_Init endp					;				
										
;*****************************************************************************	
;Routine name: get_psp								
;*****************************************************************************	
;Description: get info from the psp area					
;										
;Called Procedures: get_drive							
;										
;Change History: Created	8/7/87	       bgb				
;										
;Input: none									
;										
;Output: psp_segment								
;	 command_line_buffer							
;										
;Psuedocode									
;----------									
;	get addr of psp 							
;	move command line into data seg 					
;	get drive number of target						
;	get addr of data seg							
;	call get_drive								
;	ret									
;*****************************************************************************	
Procedure get_psp			;
;;;;;;;;DOS_Call GetCurrentPSP		;Get PSP segment address	:AN035;b
;;;;;;;;mov	PSP_Segment,bx		;Save it for later		
; get command line from psp							
	mov	cx,PSP_Segment		;point ds to data seg			
	mov	ds,cx			;  "   "   "   "    "
	assume	ds:NOTHING,es:dg	;  "   "   "   "    "
; get the drive number of the target from the psp (0=default, a=1, b=2, c=3) ;AN
	mov	bl,ds:[FCB1]	    ;Get target drive from FCB -74	
	Set_Data_Segment	    ;Set DS,ES to Data segment		
	call	get_drive							
	ret									
get_psp   endp				;				
										
										
;*****************************************************************************	
;Routine name: get_drive							
;*****************************************************************************	
;Description: get drive letter from reg bl					
;										
;Change History: Created	8/7/87	       bgb				
;										
;Input: bl = drive num (default=0)						
;										
;Output: driveletter								
;	 user_drive								
;										
;Psuedocode									
;----------									
;	IF drive-num = default							
;	   get default drive number (a=1)					
;	   convert to letter							
;	ELSE									
;	   convert to letter							
;	ENDIF									
;	move letter into data areas						
;	ret									
;*****************************************************************************	
Procedure get_drive			;
; convert drive number to drive letter						
	    cmp     bl,0  ;a=1 b=2 c=3	;Is it default drive? 0=default
;	    $IF     E			;Yes, turn it into drive letter
	    JNE $$IF5
; get default drive number							
		DOS_Call Get_Default_Drive ;Get default drive num in al
					;a=0, b=1, c=2				
;	    $ELSE			;Not default, A=1		
	    JMP SHORT $$EN5
$$IF5:
; bl already contains the correct drive number - save it			
		dec	bl		;make it zero based			
		mov	al,bl							
;	    $ENDIF			; 74+40=b4				
$$EN5:
	    mov     BadDrvm+1,al		 ; "  "    "  " 		
	    inc     al								
	    mov     byte ptr Buffer.drnum_stroff,al			     ;	
	    mov     AllDrv,al			 ;				
	    mov     VolNam,al			 ;				
	    mov     OrphFCB,al			 ;				
	    dec     al								
	    add     al,"A"		;convert it to letter		
	    mov     arg_buf,al	    ;set up prompt msg			
	ret									
get_drive endp				;				
										
;*****************************************************************************	
;Routine name: Init_Input_Output						
;*****************************************************************************	
;										
;description: Initialize messages, Parse command line if FAT file system	
;										
;Called Procedures: Preload_Messages						
;		   Parse_Command_Line						
;										
;Change History: Created	5/10/87 	MT				
;										
;Input: PSP command line at 81h and length at 80h				
;										
;Output: FS_Not_FAT = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	FS_Not_FAT = NO 							
;	Load messages (CALL Preload_Messages)					
;	IF !Fatal_Error 							
;	   Get file system type (INT 21h AX=440Dh, CX=084Eh GET MEDIA_ID)	
;	   IF CY (Old type diskette),OR 					
;	   IF "FAT_12  ",OR							
;	   IF "FAT_16  "							
;	      CALL Parse_Command_Line						
;	      IF !Fatal_Error							
;		 Interpret_Parse						
;	      ENDIF								
;	   ELSE 								
;	      Get drive letter only (CALL Parse_Drive_Letter)			
;	      FS_Not_FAT = YES							
;	   ENDIF								
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Init_IO		      ; 			
										
	call	Preload_Messages		;Load up message retriever	
ifdef	fsexec									
	mov	FS_Not_FAT,No							
	cmp	Fatal_Error,YES 		;Quit?				
;	$IF	NE				;Nope, keep going		
	JE $$IF8
	   mov	   al,GENERIC_IOCTL		;Generic IOCtl call		
	   push    ds				;				
	   mov	   bx,PSP_Segment		;				
	   mov	   ds,bx			;				
	   assume  ds:nothing			;				
										
	   mov	   bl,ds:FCB1			;Get drive (A=1)		
										
	   pop	   ds				;				
	   assume  ds:dg			;				
	   xor	   bh,bh			;Set bh=0			
	   mov	   ch,RawIO			;Get Media ID call		
	   mov	   cl,GET_MEDIA_ID		;				
	   lea	   dx,Media_ID_Buffer		;Point at buffer		
	   DOS_Call IOCtl			;Do function call		
;	   $IF	   C,OR 			;Old style diskette, OR 	
	   JC $$LL9
	   lea	   si,FAT12_String		;Check for FAT_12 string	
	   lea	   di,Media_ID_Buffer.Media_ID_File_System ;		
	   mov	   cx,Len_FS_ID_String		;Length of compare		
	   repe    cmpsb			;Find it?			
;	   $IF	   E,OR 			;Nope, keep going		
	   JE $$LL9
	   lea	   si,FAT16_String		;Check for FAT_16 string	
	   lea	   di,Media_ID_Buffer.Media_ID_File_System ;		
	   mov	   cx,Len_FS_ID_String		;Length of compare		
	   repe    cmpsb			;Do compare			
;	   $IF	   E				;Find it?			
	   JNE $$IF9
$$LL9:
endif										
	      call    Parse_Command_Line	;Parse in command line input	
ifdef	fsexec									
;	   $ELSE				;We got FS other than FAT	
	   JMP SHORT $$EN9
$$IF9:
;;;;;;;;;;;;;;call    Parse_Drive_Letter	;Only look for drive letter	
	      mov     FS_Not_FAT,Yes		;Indicate exec file system	
		mov	cx,8							
		lea	si,Media_ID_Buffer.Media_ID_File_System ;get file system
		lea	di,fs_string_buffer ;put it here			
		rep	movsb							
		lea	di,fs_string_buffer ;point to beginning again		
;		$DO	COMPLEX 	;search th string until eol found	
		JMP SHORT $$SD11
$$DO11:
		    inc     di		;next char				
;		$STRTDO 		;start loop here			
$$SD11:
		    cmp     byte ptr [di],' '	 ;end of string ?		
;		$ENDDO	E		;end loop when eol found		
		JNE $$DO11
		lea	si,fs_string_end ;get end of string - rec.exe		
		mov	cx,8		; 8 more chars				
		rep	movsb		;move it in				
;	   $ENDIF				;				
$$EN9:
;	$ENDIF					;				
$$IF8:
endif										
	ret					;				
										
Init_IO endp			      ; 			
										
;*****************************************************************************	
;Routine name: Preload_Messages 						
;*****************************************************************************	
;										
;Description: Preload messages using common message retriever routines. 	
;										
;Called Procedures: SysLoadMsg							
;										
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: Fatal_Error = NO							
;										
;Output: Fatal_Error = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	Preload All messages (Call SysLoadMsg)					
;	IF error								
;	   Display SysLoadMsg error message					
;	   Fatal_Error = YES							
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Preload_Messages			;				
						;				
	call	SysLoadMsg			;Preload the messages		
;	$IF	C				;Error? 			
	JNC $$IF16
	   call    SysDispMsg			;Display preload msg		
	   mov	   Fatal_Error, YES		;Indicate error exit		
;	$ENDIF					;				
$$IF16:
	ret					;				
										
Preload_Messages endp				;				
										
;*****************************************************************************	
;Routine name: Parse_Drive_Letter						
;*****************************************************************************	
;										
;Description: Copy the command line - then parse looking only for drive 	
;		 letter. Ignore errors, because this is only called to get	
;		 the drive letter for non-FAT chkdsk				
;										
;Called Procedures: SysParse							
;										
;Change History: Created	5/12/87 	MT				
;										
;Input: Command line input at 81h						
;										
;Output: None									
;										
;										
;Psuedocode									
;----------									
;	Copy command line to buffer						
;	DO									
;	   Parse buffer line (CALL SysParse) using drive letter only tables	
;	LEAVE end of parse							
;	ENDDO missing operand							
;	ret									
;*****************************************************************************	
										
;Procedure Parse_Drive_Letter			 ;				
;	Set_Data_Segment			;Set DS,ES to Data segment	
;	mov	cx,PSP_Segment			;Get segment of PSP		
;	mov	ds,cx				;  "  "    "  " 		
;	assume	ds:nothing			;				
;	mov	si,Command_Line_Parms		;Point to command line		
;	lea	di,Command_Line_Buffer		;Point to buffer to save to	
;	mov	cx,Command_Line_Length		;Number of bytes to move	
;	rep	movsb				;Copy the entire buffer 	
;	Set_Data_Segment			;				
;	lea	si,Command_Line_Buffer		;Pointer to parse line		
;	lea	di,input_table			;Pointer to control table	
;	$DO					;Parse for drive letter 	
;	   xor	   dx,dx			;Parse line @SI 		
;	   xor	   cx,cx			;Parse table @DI		
;	   call    SysParse			;Go parse			
;	   cmp	   ax,End_Of_Parse		;Check for end of parse 	
;	$LEAVE	E				;In other words, no drive letter
;	   cmp	   ax,Operand_Missing		; exit if positional missing	
;	$ENDDO	E				;Ignore errors!!!		
;	Set_Data_Segment			;				
;	ret					;				
;										
;Parse_Drive_Letter endp			 ;				
										
;*****************************************************************************	
;Routine name: Parse_Command_Line						
;*****************************************************************************	
;										
;Description: Parse the command line. Check for errors, and display error and	
;		 exit program if found. Use parse error messages except in case
;		 of no parameters, which has its own message			
;										
;Called Procedures: Message (macro)						
;		    SysParse							
;		    Interpret_Parse						
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: Fatal_Error = NO							
;	PSP_Segment								
;										
;Output: Fatal_Error = YES/NO							
;	 Parse output buffers set up						
;										
;										
;Psuedocode									
;----------									
;	SEARCH									
;	   Parse command line (CALL SysParse)					
;	EXITIF end of parsing command line					
;	   Figure out last thing parsed (Call Interpret_Parse)			
;	ORELSE									
;	   See if parse error							
;	ENDLOOP parse error							
;	   See what was parsed (Call Interpret_Parse)				
;	   Fatal_Error = YES							
;	ENDSRCH 								
;	ret									
;*****************************************************************************	
										
Procedure Parse_Command_Line			;				
										
	push	ds				;Save data segment		
	Set_Data_Segment			;				
	mov	cx,PSP_Segment			;Get segment of PSP		
	mov	ds,cx				;  "  "    "  " 		
										
	assume	ds:nothing,es:dg		;				
										
	mov	si,Command_Line_Parms		;Point at command line		
	lea	di,Command_Line_Buffer		;Where to put a copy of it	
	mov	cx,Command_Line_Length		;How long was input?		
	repnz	movsb				;Copy it			
	lea	Di,Command_Line_Buffer		;				
public nextdi									
nextdi: 									
	mov	al,0dh				;search for end of line 	
	cmp	al,ES:[Di]			   ;zero terminate string	
;	$IF	NZ								
	JZ $$IF18
	    inc    di								
	    jmp    nextdi							
;	$ELSE									
	JMP SHORT $$EN18
$$IF18:
	    mov    byte ptr ES:[di+1],00					
;	$ENDIF									
$$EN18:
										
	Set_Data_Segment			;Set DS,ES to Data segment	
	xor	cx,cx				;				
	xor    dx,dx			       ;Required for SysParse call     ;
	lea	si,Command_Line_Buffer		;Pointer to parse line		
	lea	di,input_table			;Pointer to control table	
;	$SEARCH 				;Loop until all parsed		
$$DO21:
	   cmp	   Fatal_Error,Yes		;Interpret something bad?	
;	$EXITIF E,OR				;If so, don't parse any more
	JE $$LL22
	   call    SysParse			;Go parse			
	   cmp	   ax,End_Of_Parse		;Check for end of parse 	
;	$EXITIF E				;Is it? 			
	JNE $$IF21
$$LL22:
						;All done			
;	$ORELSE 				;Not end			
	JMP SHORT $$SR21
$$IF21:
	   cmp	   ax,0 			;Check for parse error		
;	$LEAVE	NE				;Stop if there was one		
	JNE $$EN21
	   call    Interpret_Parse		;Go find what we parsed 	
;	$ENDLOOP				;Parse error, see what it was	
	JMP SHORT $$DO21
$$EN21:

	   dec	  si			;point to last byte of invalid parm
public decsi
decsi:	   cmp	   byte ptr [si],' '	;are we pointing to a space?		
;	   $IF	   E,OR 		;if so, we dont want to do that
	   JE $$LL26
	   cmp	   byte ptr [si],0dh	;are we pointing to CR? 		
;	   $IF	   E			;if so, we dont want to do that
	   JNE $$IF26
$$LL26:
	       dec   si 		;find the last byte of parm
	       jmp   decsi
;	   $ENDIF
$$IF26:
	   mov	   byte ptr [si+1],00	  ;zero terminate display string
nextsi:
public nextsi
	   dec	   si			;look at previous char			
	   cmp	   byte ptr [si],0	;beginning of parameter string?    ;C03
	   jz	   found		;got it 			   ;C03
	   cmp	   byte ptr [si],' '	;find parm separator			
	   jnz	   nextsi		;loop until begin of parm found
found:					;				   ;C03
	   inc	   si			;point to start of parameter	   ;C03
	   mov	   movsi,si		;mov si into display parms		
	   PARSE_MESSAGE			;Display parse error		
	   mov	   Fatal_Error,YES		;Indicate death!		
;	$ENDSRCH				;				
$$SR21:
	pop	ds				;				
	ret					;				
										
Parse_Command_Line endp 			;				
										
;*****************************************************************************	
;Routine name: Interpret_Parse							
;*****************************************************************************	
;										
;description: Get any switches entered, and dr					
;										
;										
;Called Procedures: Message (macro)						
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: DS:DrNum (FCB at 5Ch)							
;										
;Output: Noisy = ON/OFF 							
;	 DoFix = ON/OFF 							
;	 ALLDRV = Target drive, A=1						
;	 VOLNAM = Target drive, A=1						
;	 ORPHFCB = Target drive, A=1						
;	 BADDRVm+1 = Target drive, A=0						
;	 Arg_Buf = Target drive letter						
;	 Fragment > 1 if filespec entered					
;										
;Psuedocode									
;----------									
;										
;	Noisy = OFF								
;	DoFix = OFF								
;	IF /V									
;	   Noisy = ON								
;	ENDIF									
;	IF /F									
;	   DoFix = ON								
;	ENDIF									
;	IF file spec entered							
;	   Build filename							
;	   Fragment = 1 							
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Interpret_Parse			;				
										
	push	ds				;Save segment			
	push	si				;Restore SI for parser		
	push	cx				;				
	push	di				;				
	Set_Data_Segment			;				
	cmp	byte ptr Buffer.dfType,Type_Drive ;Have drive letter?	
;	$IF	E				;Yes, save info 		
	JNE $$IF29
	   mov	   buffer.dftype,0		;clear data area	   ;C04
	   and	   word ptr dfcontrol,filespec	;dont let another drive letter	
	   mov	   al,byte ptr Buffer.Drnum_stroff ;Get drive entered	       ;
	   mov	   AllDrv,al			;				
	   mov	   VolNam,al			;				
	   mov	   OrphFCB,al			;				
	   dec	   al				;Make it 0 based		
	   mov	   BadDrvm+1,al 		; "  "	  "  "			
	   add	   al,'A'			;Make it a drive letter 	
	   mov	   Arg_Buf,al			;Save it			
;	$ENDIF					;				
$$IF29:
	cmp	SwBuffer.Switch_Pointer,offset Sw_?
	jne	nxt
@@:
	Message options1
	cmp	[options1], MSG_OPTIONS_LAST	; last msg?
	je	@F				;  out of loop if so
	inc	[options1]			; else bump msg number
	jmp	short @B			;  and go do it
@@:

	mov	Fatal_error, Yes        	; cheap way to exit the prog
	mov	ExitStatus, 0                  ; success code
	jmp	SHORT $$if35
;DEBUG


nxt:
	cmp	SwBuffer.Switch_Pointer,offset Sw_v			
;	$IF	E				;				
	JNE $$IF31
	   mov	   Noisy,ON			;Set flag			
	   mov	   byte ptr sw_v,blank						
;	$ENDIF					;				
$$IF31:
	cmp	SwBuffer.Switch_Pointer,offset sw_f			
;	$IF	E				;				
	JNE $$IF33
	   mov	   DoFix,ON			;Set flag			
	   mov	   byte ptr sw_f,blank					       ;
;	$ENDIF					;				
$$IF33:
;;;;;;; cmp	FileSpec_Buffer.FileSpec_Pointer,offset FileSpec_Control.Keyword
	cmp	buffer.dftype, type_filespec					
;	$IF	E				;				
	JNE $$IF35
           mov     buffer.dftype,0              ;clear data area           ;C04
	   mov	   word ptr dfcontrol,0 ;dont let another drive letter or filesp
	   mov	   si,Buffer.drnum_StrOff ;			
	   lea	   di,Path_Name 		;Point to where to build path	
	   cld					;SI-DI dir is up		
;	   $DO					;Move string one char at a time
$$DO36:
	      cmp     byte ptr [si],Asciiz_End	;Is it the end? 		
;	   $LEAVE  E				;You got it			
	   JE $$EN36
	      movsb				;Nope, move the character	
;	   $ENDDO				;And keep crusin		
	   JMP SHORT $$DO36
$$EN36:
	   inc	   fragment			;To be compat with old code	
;	$ENDIF					;				
$$IF35:
	pop	di				;Restore parse regs		
	pop	cx				;				
	pop	si				;				
	pop	ds				;				
	ret					;				
										
										
Interpret_Parse endp				;				
										
										
										
;*****************************************************************************	
;Routine name: Validate_Target_Drive						
;*****************************************************************************	
;										
;Description: Control routine for validating the specified format target drive.
;	      If any of the called routines find an error, they will print	
;	      message and terminate program, without returning to this routine	
;										
;Called Procedures: Check_Target_Drive						
;		    Check_For_Network						
;		    Check_Translate_Drive					
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: Fatal_Error = NO							
;										
;Output: Fatal_Error = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	CALL Check_Target_Drive 						
;	IF !Fatal_Error 							
;	   CALL Check_For_Network						
;	   IF !Fatal_Error							
;	      CALL Check_Translate_Drive					
;	   ENDIF								
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Validate_Target_Drive 		;				
    call    Check_For_Network		 ;See if Network drive letter	
    cmp     Fatal_Error,YES		    ;Can we continue?		
;   $IF     NE				    ;Yep			
    JE $$IF40
	call	Check_Target_Drive		;See if valid drive letter	
	cmp	Fatal_Error,YES 		;Can we continue?		
;	$IF	NE				;Yep				
	JE $$IF41
	   call    Check_For_Network		;See if Network drive letter	
	   cmp	   Fatal_Error,YES		;Can we continue?		
;	   $IF	   NE				;Yep				
	   JE $$IF42
	      call    Check_Translate_Drive	;See if Subst, Assigned 	
;	   $ENDIF				;- Fatal_Error passed back	
$$IF42:
;	$ENDIF					;				
$$IF41:
;   $ENDIF									
$$IF40:
	ret					;				
										
Validate_Target_Drive endp			;				
										
;*****************************************************************************	
;Routine name: Check_Target_Drive						
;*****************************************************************************	
;										
;Description: Check to see if valid DOS drive by checking if drive is		
;	      removable. If error, the drive is invalid. Save default		
;	      drive info. Also get target drive BPB information, and compute	
;	      the start of the data area					
;										
;Called Procedures: Message (macro)						
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: Fatal_Error = NO							
;										
;Output: BIOSFile = default drive letter					
;	 DOSFile = default drive letter 					
;	 CommandFile = default drive letter					
;	 Fatal_Error = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	Get default drive (INT 21h, AH = 19h)					
;	Convert it to drive letter						
;	Save into BIOSFile,DOSFile,CommandFile					
;	See if drive removable (INT 21h, AX=4409h IOCtl)			
;	IF error - drive invalid						
;	   Display Invalid drive message					
;	   Fatal_Error= YES							
;	ENDIF									
;	Get BPB of target drive (Generic IOCtl Get Device parameters)		
;	Compute start of data area						
;	ret									
;*****************************************************************************	
Procedure Check_Target_Drive			;				
    call    func60				;				
    mov     al,save_drive							
    cmp     al,0ffh			;save drive spec			
;   $IF     E									
    JNE $$IF46
	   Message BadDrv_Arg			;Print message			
	   mov	   Fatal_Error,Yes		;Indicate error 		
	   jmp	   Exit_Baddrv			;dont do rest of proc		
;   $ENDIF									
$$IF46:
	DOS_Call Get_Default_Drive		;Find the current drive  19	
	mov	UserDev,al			;Save it			
	cmp	AllDrv,0			;Was drive entered?		
;	$IF	E				;No				
	JNE $$IF48
	   mov	   BadDrvm+1,al 		;Save 0 based number		
	   inc	   al				;Make 1 based			
	   mov	   byte ptr Buffer.Drnum_stroff,al			    ;	
	   mov	   AllDrv,al			;Use default drive for		
	   mov	   VolNam,al			;entries for drive fields	
	   mov	   OrphFCB,al			;				
	   add	   al,'A'-1			;Make it a drive letter 	
	   mov	   Arg_Buf,al			;Save it			
;	$ENDIF					;				
$$IF48:
	mov	bl,alldrv			;Get drive number (A=1)
	mov	al,09h				;See if drive is local		
	DOS_Call IOCtl				;-this will fail if bad drive	
;	$IF	C				;CY means invalid drive 	
	JNC $$IF50
	   Message BadDrv_Arg			;Print message			
	   mov	   Fatal_Error,Yes		;Indicate error 		
;	$ENDIF					;				
$$IF50:
	cmp	fatal_error,no							
;	$IF	E								
	JNE $$IF52
get_bpb:   mov	   al,GENERIC_IOCTL		   ;Get BPB information 	
	   mov	   ch,RawIO			   ; "  "   "  "		
	   mov	   cl,GET_DEVICE_PARAMETERS	   ;				
	   mov	   bl,AllDrv			   ; "  "   "  "		
	   lea	   dx,BPB_Buffer		   ; dx points to bpb area	
	   mov	   byte ptr bpb_buffer, 0ffh	   ;turn bit 0 on to get bpb inf
	   DOS_Call IOCtl			   ; "  "   "  "		
	   mov	   bx,dx			   ;use bx as the pointer to bpb
;	   $IF	   C			   ;is ioct not supported or bad?	
	   JNC $$IF53
	      mov     al,BadDrvm+1		   ; drive number a=0		
	      lea     bx,chkprmt_end		   ; transfer address es:bx	
	      ;warning! this label must be the last in the code segment 	
	      mov     cx,1			   ; 1 sector - boot record	
	      mov     dx,0			   ; logical sector 0		
	      mov     Read_Write_Relative.Start_Sector_High,0 ; 		
	      call    read_once 						
;	      $IF     C 		   ;couldnt read the boot?		
	      JNC $$IF54
		  Message BadDrv_Arg		       ;Print message		
		  mov	  Fatal_Error,Yes	       ;Indicate error		
;	      $ELSE			;ioctl not supported - is it vdisk	
	      JMP SHORT $$EN54

;M004 - spurious IBMCOPYRIGHT removed here
$$IF54:
;		  mov	di,bx							
;		  add	di,3		;es:di --> to vdisk area in boot rcd	
;		  lea	si,myvdisk	;ds:si --> proper vdisk string		
;		  mov	cx,5		; compare 5 bytes			
;		  repe	cmpsb		;compare both strings			
;		  $IF	NE

;--------------------------------------------------------------------HKN 10/23/89
; When the get BPB ioctl fails chkdsk reads the boot sector and looks for
; a RAMDISK signature. This causes chkdsk to fail on drives like the
; bernoulli box. Previous versions of chkdsk used the undocumented GET_DPB
; call to get the disk parameters. This section of code has been removed to
; facilitate chkdsk to run drives that do not support get bpb IOCTL. Note
; that the BPB is validated in the get_boot_info procedure anyway.

;;			mov   di,bx
;;			add   di,3
;;			lea   si,myramdisk
;;			mov   cx,8
;;			repe  cmpsb
;;
;;			$IF   NE
;;			jmp   baddrv
;;			$ENDIF
;---------------------------------------------------------------------------

;		  $ENDIF
;	      $ENDIF								
;M004 - end of changed section
$$EN54:
	      add     bx,4		   ;boot-record-offset - device-paramete
;	   $ENDIF								
$$IF53:
;	$ENDIF									
$$IF52:
	   cmp	   fatal_error,no						
;	   $IF	   E								
	   JNE $$IF59
	      call    get_boot_info						
	      call    calc_space						
;	   $ENDIF								
$$IF59:
	      cmp     bytes_per_sector,0					
;	      $IF     E 							
	      JNE $$IF61
baddrv: 	  mov  fatal_error,yes						
		  mov	  dx,offset dg:inval_media				
		  invoke  printf_crlf						
;	      $ENDIF								
$$IF61:
Exit_Baddrv:					
	     ret				;And we're outa here
Check_Target_Drive endp 			;				
										
										

;******************************************************************************
; get_boot_info 								
;										
;										
;	Inputs	: none								
;										
;	Outputs :								
;******************************************************************************
Procedure get_boot_info        ;						
	      mov     cx,[bx].BytePerSector	; usually 512			

;------------------------------------------------------------------------
; The following lines that check to see if the BytesPerSector are <=1024
; have been removed. HKN 10/20/89

if	BUGFIX					; MSKK02 07/14/89
;	      cmp     cx,1024
;	      $IF     NE,AND
endif
;	      cmp     cx,512 ;vdisk sizes					
;	      $IF     NE,AND ;vdisk sizes					
;	      cmp     cx,256 ;vdisk sizes					
;	      $IF     NE,AND ;vdisk sizes					
;	      cmp     cx,128 ;vdisk sizes					
;	      $IF     NE     ;vdisk sizes					
;		  jmp	 baddrv 						
;	      $ENDIF								

;------------------------------------------------------------------------
	      mov     bytes_per_sector,cx     ; 		 ;		
										
	      xor     cx,cx			      ;Find # sectors used by FA
	      mov     cl,[bx].NumberOfFats	; "  "	 "  "			
	      cmp     cx,2		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF63
	      cmp     cx,1		;make sure it is ok			
;	      $IF     NE							
	      JE $$IF63
		  jmp	  baddrv	    ;must be 2 fats			
;	      $ENDIF								
$$IF63:
	      mov     fatcnt,cl 						
										
										
	      xor     ax,ax							
	      mov     al,[bx].SectorsPerCluster   ;get total sectors		
	      cmp     ax,1		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,2		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,4		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,8		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,16		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,32		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,64		;make sure it is ok			
;	      $IF     NE,AND							
	      JE $$IF65
	      cmp     ax,128		;make sure it is ok			
;	      $IF     NE							
	      JE $$IF65
		  jmp	  baddrv	    ;this is not!			
;	      $ENDIF								
$$IF65:
										
	      mov     ax,[bx].SectorsPerFAT	; "  "	 "  "			
	      cmp     ax,0		;make sure it is ok			
	      jz      baddrv		;this is not!				
	      mul     cx			      ; "  "   "  "		
	      push    bx		      ;save bpb pointer 		
	      push    dx			      ;Save results		
	      push    ax			      ;     "  "		

	      ;       MSKK02 07/19/89
	      ;       calculate as directory_entry / (sector_size / 32)

	      mov     cl,5		      ;
	      mov     ax,[bx].BytePerSector   ;
	      shr     ax,cl		      ; sector_size / 32
	      mov     cl,al		      ;
	      mov     ax,[bx].RootEntries     ;
	      div     cl		      ; get number of ROOT DIRECTORY Sectors

;		      Code before MSKK02 bugfix:
;
;	      mov     ax,[bx].RootEntries	;Find number of sectors in root
;	      cmp     ax,2		;make sure it is ok			
;	      $IF     B,OR		;this is not!				
;	      cmp     ax,512		;make sure it is ok			
;	      $IF     A 		;this is not!				
;		jmp	baddrv							
;	      $ENDIF								
;										
;	      mov     cl,Dir_Entries_Per_Sector       ; by dividing RootEntries
;	      cmp     cl,0							
;	      $IF     NE							
;		  div	  cl				  ; by (512/32) 	
;	      $ENDIF								

	      pop     bx			      ;Get low sectors per FAT b
	      pop     dx			      ;Get high part		
	      add     ax,bx			      ;Add to get FAT+Dir sector
	      adc     dx,0			      ;High part		
	      mov     fat_dir_secs,ax		      ;save it			
	      inc     fat_dir_secs		      ; 1 for reserved sector	
	      pop     bx		      ;restore bpb pointer		
	      add     ax,[bx].ReservedSectors	;Add in Boot record sectors	
	      adc     dx,0			      ;to get start of data (DX:
	      mov     Data_Start_Low,ax 	      ;Save it			
	      mov     Data_Start_High,dx	      ; 			
	ret					 ;				
get_boot_info endp	       ;						







;******************************************************************************
; Calc_Space  : Calculate the total space that is				
;				  addressible on the the disk by DOS.		
;										
;	Inputs	: none								
;										
;	Outputs : Fdsksiz - Size in bytes of the disk				
;******************************************************************************
Procedure Calc_Space	       ;						
; get the total number of clusters on the disk					
p97:	xor	ax,ax				 ;clear ax			
	mov	ah,36h				 ;Get disk free space		
	mov	dl,alldrv		; 1 based drive number			
	push	bx			;save bpb pointer			
	int	21h				 ;bx = total space avail	
;multiply by sectors per cluster						
gtsecs: mov	ax,dx				 ;get total clusters		
	xor	cx,cx				 ;clear cx			
	pop	bx			;restore bpb pointer			
	mov	cl,[bx].SectorsPerCluster   ;get total sectors			
	push	bx			;save bpb pointer			
	xor	bx,bx				 ;clear bx			
	call	Multiply_32_Bits		 ;multiply			
;multiply by bytes per sector							
	mov	dx,bx			;save bx				
	pop	bx			;get bpb addr				
	mov	cx,[bx].BytePerSector	;get total bytes			
	mov	bx,dx			;restore bx				
	call	Multiply_32_Bits		 ; multiply			
;result is bytes on disk							
	mov	tot_bytes_lo,ax 	     ;save high word			
	mov	tot_bytes_hi,bx 	   ;save low word			
	ret					 ;				
Calc_Space    endp	       ;						


;*****************************************************************************	
;Routine name: Check_For_Network						
;*****************************************************************************	
;										
;Description: See if target drive isn't local, or if it is a shared drive. If
;	      so, exit with error message. The IOCtl call is not checked for	
;	      an error because it is called previously in another routine, and	
;	      invalid drive is the only error it can generate. That condition	
;	      would not get this far						
;										
;Called Procedures: Message (macro)						
;										
;Change History: Created	5/1/87	       MT				
;										
;Input:    Drive_Letter_Buffer.Drive_Number					
;	   Fatal_Error = NO							
;										
;Output: Fatal_Error = YES/NO							
;										
;Psuedocode									
;----------									
;	See if drive is local (INT 21h, AX=4409 IOCtl)				
;	IF not local								
;	   Display network message						
;	   Fatal_ERROR = YES							
;	ELSE									
;	   IF  8000h bit set on return						
;	      Display assign message						
;	      Fatal_Error = YES 						
;	   ENDIF								
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Check_For_Network			;				
						;				
	mov	bl,alldrv			;Drive is 1=A, 2=B		
	mov	al,09h				;See if drive is local or remote
	DOS_CALL IOCtl				;We will not check for error	
	test	dx,Net_Check			;if (x & 1200H)(redir or shared)
;	$IF	NZ				;Found a net drive		
	JZ $$IF67
	   Message No_Net_Arg			;Tell 'em
	   mov	   Fatal_Error,Yes		;Indicate bad stuff		
;	$ELSE					;Local drive, now check assign	
	JMP SHORT $$EN67
$$IF67:
	   test    dx,Assign_Check		;8000h bit is bad news		
;	   $IF	   NZ				;Found it			
	   JZ $$IF69
	      Message SubstErr			;Tell error			
	      mov     Fatal_Error,Yes		;Indicate bad stuff		
;	   $ENDIF				;				
$$IF69:
;	$ENDIF					;				
$$EN67:
	ret					;				
										
Check_For_Network endp				;				
										
;*****************************************************************************	
;Routine name: Check_Translate_Drive						
;*****************************************************************************	
;										
;Description: Do a name translate call on the drive letter to see if it is	
;	      assigned by SUBST or ASSIGN					
;										
;Called Procedures: Message (macro)						
;										
;Change History: Created	5/1/87	       MT				
;										
;Input: Drive_Letter_Buffer.Drive_Number					
;	   Fatal_Error = NO							
;										
;Output: Fatal_Error = YES/NO							
;										
;Psuedocode									
;----------									
;	Put drive letter in ASCIIZ string "d:\",0				
;	Do name translate call (INT 21) 					
;	IF drive not same							
;	   Display assigned message						
;	   Fatal_Error = YES							
;	ENDIF									
;	ret									
;*****************************************************************************	
Procedure Check_Translate_Drive 		;				
	call	func60				;				
	mov	bl,byte ptr [TranSrc]		;Get drive letter from path	
	cmp	bl,byte ptr [Chkprmt_End]	;Did drive letter change?	
;	$IF	NE				;If not the same, it be bad	
	JE $$IF72
	   Message SubstErr			;Tell user			
	   mov	   Fatal_Error,Yes		;Setup error flag		
;	$ENDIF					;				
$$IF72:
	ret					;				
Check_Translate_Drive endp			;				
										
										
Procedure func60				;				
;  PUSH    DS			   ;ICE 					
;  push    bx			   ;ICE 					
;  push    ax			   ;ICE 					
;										
;  mov	   bx,0140H		   ;ICE 					
;  xor	   ax,ax		   ;ICE 					
;  mov	   ds,ax		   ;ICE 					
;  mov	   ax,word ptr ds:[bx]	   ;ICE 					
;  mov	   word ptr ds:[bx],ax	   ;ICE 					
;										
;  pop	   ax			   ;ICE 					
;  pop	   bx			   ;ICE 					
;  POP	   DS			   ;ICE 					
										
	mov	byte ptr [transrc],'A'						
	mov	bl,alldrv			;Get drive		    ;	
	dec	bl				;Make it 0 based		
	add	byte ptr [TranSrc],bl		;Make string "d:\"		
	lea	si,TranSrc			;Point to translate string	
	push	ds				;Set ES=DS (Data segment)	
	pop	es				;     "  "	"  "		
	lea	di,Chkprmt_End			;Point at output buffer 	
	DOS_Call xNameTrans			;Get real path			
	ret					;				
func60 endp			 ;				
										
										
;*****************************************************************************	
;Routine name: Hook_Interrupts							
;*****************************************************************************	
;										
;Description: Change the interrupt handler for INT 13h to point to the		
;	      ControlC_Handler routine						
;										
;Called Procedures: None							
;										
;Change History: Created	4/21/87 	MT				
;										
;Input: None									
;										
;Output: None									
;										
;Psuedocode									
;----------									
;										
;	Point at ControlC_Handler routine					
;	Set interrupt handler (INT 21h, AX=2523h)				
;	ret									
;*****************************************************************************	
										
procedure Hook_Interrupts			;				
						;				
	mov	al,23h								
	DOS_Call Get_Interrupt_Vector		;Get the INT 23h handler	
	mov	word ptr [CONTCH],bx		;				
	mov	bx,es				;				
	mov	word ptr [CONTCH+2],bx		;				
	mov	al,23h				;Specify CNTRL handler		
	lea	dx, INT_23			;Point at it			
	push	ds				;Save data seg			
	push	cs				;Point to code segment		
	pop	ds				;				
	DOS_Call Set_Interrupt_Vector		;Set the INT 23h handler	
	pop	ds				;Get Data degment back		
	mov	al,24h				;				
	DOS_Call Get_Interrupt_Vector		;Get the INT 24h handler	
	mov	word ptr [HardCh],bx		;Save it			
	mov	bx,es				;				
	mov	word ptr [HardCh+2],bx		;				
	mov	al,24h				;Specify handler		
	lea	dx, INT_24			;Point at it			
	push	ds				;Save data seg			
	push	cs				;Point to code segment		
	pop	ds				;				
	DOS_Call Set_Interrupt_Vector		;Set the INT 23h handler	
	pop	ds				;Get Data degment back		
	ret					;				
										
hook_Interrupts endp				;				
										
;*****************************************************************************	
;Routine name: Clear_Append_X							
;*****************************************************************************	
;										
;Description: Determine if Append /XA is turned on thru INT 2Fh, and shut	
;	      off for life of CHKDSK if it is.					
;										
;Called Procedures: None							
;										
;										
;Change History: Created	5/13/87 	MT				
;										
;Input: None									
;										
;Output: APPEND = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	Append = NO								
;	See if APPEND /X is present (INT 2Fh, AX=0B706h)			
;	IF present								
;	   Turn append /X off (INT 2Fh, AX=B707h, BX = 0)			
;	   Append = YES 							
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Clear_Append_X			;				
										
	mov	Append,NO			;Init the Append /X flag	
	mov	ax,Append_X			;Is Append /X there?		
	int	Multiplex			; "  "	   "  " 		
	cmp	bx,Append_X_Set 		;Was it turned on?		
;	$IF	E				;Yep				
	JNE $$IF74
	   mov	   Append,YES			;Indicate that it was on	
	   mov	   ax,Set_Append_X		;Turn Append /X off		
	   mov	   bx,Append_Off		; "  "	  "  "			
	   int	   Multiplex			; "  "	  "  "			
;	$ENDIF					;				
$$IF74:
	ret					;				
										
Clear_Append_X endp				;				
										
										
;*****************************************************************************	
;Routine name: CHKDSK_IFS							
;*****************************************************************************	
;										
;Description:									
;										
;Called Procedures: Main_Routine						
;		   EXEC_FS_CHKDSK						
;		   Done 							
;										
;Change History: Created	5/8/87	       MT				
;										
;Input: FS_Not_FAT = Yes/No							
;										
;Output: None									
;										
;Psuedocode									
;----------									
;										
;	IF File system other than FAT						
;	   Go call file system specific CHKDSK (CALL Exec_FS_CHKDSK)		
;	ELSE									
;	   Do FAT based CHKDSK (CALL Main_Routine)				
;	ENDIF									
;	Restore current drive (CALL Done)					
;	ret									
;*****************************************************************************	
										
										
Procedure CHKDSK_IFS				;				
										
ifdef	fsexec									
	cmp	FS_Not_Fat,YES			;Is the target FS a FAT?	
;	$IF	E				;No, so need to exec the	
	JNE $$IF76
	   call    EXEC_FS_CHKDSK		; file system specific prog.	
;	$ELSE					;It's a FAT
	JMP SHORT $$EN76
$$IF76:
endif										
	   call    Main_Routine 		;Use canned code!		
ifdef	fsexec									
;	$ENDIF					;				
$$EN76:
endif										
	call	Done				;Restore current drive		
	ret					;				
										
CHKDSK_IFS endp 				;				
										
;*****************************************************************************	
;Routine name: Reset_Append_X							
;*****************************************************************************	
;										
;description: If APPEND /XA was on originally, turn it back on			
;										
;Called Procedures: None							
;										
;										
;Change History: Created	5/13/87 	MT				
;										
;Input: None									
;										
;Output: APPEND = YES/NO							
;										
;Psuedocode									
;----------									
;										
;	IF APPEND = YES 							
;	   Turn append /X on (INT 2Fh, AX=B707h, BX = 1)			
;	ENDIF									
;	ret									
;*****************************************************************************	
										
Procedure Reset_Append_X			;				
										
	cmp	Append,Yes			;Was Append /X on to start with?
;	$IF	E				;Yep				
	JNE $$IF79
	   mov	   ax,Set_Append_X		;Turn Append /X off		
	   mov	   bx,Append_On 		; "  "	  "  "			
	   int	   Multiplex			; "  "	  "  "			
;	$ENDIF					;				
$$IF79:
	ret					;				
										
Reset_Append_X endp				;				

;****************************************************************************
; Routine: Check_Win_Shell
; ENTRY: none
; EXIT:  fUnderWindows = Yes if Win/386 or DOSSHELL/switcher present.
;	 CY set if under Windows/switcher and /F switch used, and
;	 displays a message to warn the user to quit windows/shell and
;	 try again.
;****************************************************************************

Procedure	Check_Win_Shell

	push	es
	push	di
	mov	ax,1600h		; Check for Win/386
	int	2fh			;
	test	al,7fh			; AL & 7Fh != 0 => win/386
	jz	cwChkShell		; no Win; go check on WinOldAp

; Win/386 or WinOldAp (Win 3.0 real mode, Win 3.0/3.1 std mode,
; DOSSHELL switcher) present; display error message and return CY

cwerr:
	mov	fUnderWindows, Yes	; running under Windows or switcher

	cmp	DoFix,OFF		; don't care if user didn't specify
	je	cwpopexit		; /F switch

	Message WinPrsErr
	mov     Fatal_Error,Yes		
	stc				; Set CY to indicate windows

cwpopexit:
	pop	di
	pop	es
	ret

; also check for dosshell switcher being enabled

cwChkShell:
	mov	ax, 4680h		; WINOLDAP check
	int	2fh
	or	ax, ax			; is WinOldAp present?	also clears CY
	jz	cwerr			; Yes, can't use /F

; while we're at it, check for DesqView--DBLSPACE /CHKDSK will not run under
; it--note however that only the fUnderWindows flag is set, we will not
; fatal error exit even if /F is entered.

	mov	ch, 'D'
	mov	cl, 'E'
	mov	dh, 'S'
	mov	dl, 'Q'
	mov	ax, 2B01h	; detection is set date call with DESQ date
	int	21h

	cmp	al, 0FFh	; If AL is 0xFF, then it's not installed
	je	cwpopexit	;   (CY is clear)

	mov	fUnderWindows, Yes	; set this flag, but not Fatal_Error
	clc

	jmp	short cwpopexit ;   (CY is clear)

Check_Win_Shell	endp

										
;*****************************************************************************	
;Routine name: Multiply_32_Bits 						
;*****************************************************************************	
;										
;Description: A real sleazy 32 bit x 16 bit multiply routine. Works by adding	
;	      the 32 bit number to itself for each power of 2 contained in the	
;	      16 bit number. Whenever a bit that is set in the multiplier (CX)	
;	      gets shifted to the bit 0 spot, it means that that amount has	
;	      been multiplied so far, and it should be added into the total	
;	      value. Take the example CX = 12 (1100). Using the associative	
;	      rule, this is the same as CX = 8+4 (1000 + 0100). The		
;	      multiply is done on this principle - whenever a bit that is set	
;	      is shifted down to the bit 0 location, the value in BX:AX is	
;	      added to the running total in DI:SI. The multiply is continued	
;	      until CX = 0. The routine will exit with CY set if overflow	
;	      occurs.								
;										
;										
;Called Procedures: None							
;										
;Change History: Created	7/23/87 	MT				
;										
;Input: BX:AX = 32 bit number to be multiplied					
;	CX = 16 bit number to be multiplied. (Must be even number)		
;										
;Output: BX:AX = output.							
;	 CY set if overflow							
;										
;Psuedocode									
;----------									
;										
;	Point at ControlC_Handler routine					
;	Set interrupt handler (INT 21h, AX=2523h)				
;	ret									
;*****************************************************************************	
										
Public Multiply_32_Bits 							
Multiply_32_Bits proc				;				
										
	push	di				;				
	push	si				;				
	xor	di,di				;Init result to zero		
	xor	si,si				;				
	cmp	cx,0				;Multiply by 0? 		
;	$IF	NE				;Keep going if not		
	JE $$IF81
;	   $DO					;This works by adding the result
$$DO82:
	      test    cx,1			;Need to add in sum of this bit?
;	      $IF     NZ			;Yes				
	      JZ $$IF83
		 add	 si,ax			;Add in the total so far for	
		 adc	 di,bx			; this bit multiplier (CY oflow)
;	      $ELSE				;Don't split multiplier
	      JMP SHORT $$EN83
$$IF83:
		 clc				;Force non exit 		
;	      $ENDIF				;				
$$EN83:
;	   $LEAVE  C				;Leave on overflow		
	   JC $$EN82
	      shr     cx,1			;See if need to multiply value	
	      cmp     cx,0			;by 2				
;	   $LEAVE  E				;Done if cx shifted down to zero
	   JE $$EN82
	      add     ax,ax			;Each time cx is shifted, add	
	      adc     bx,bx			;value to itself (Multiply * 2)
;	   $ENDDO  C				;CY set on overflow		
	   JNC $$DO82
$$EN82:
;	   $IF	   NC				;If no overflow, add in DI:SI	
	   JC $$IF89
	      mov     ax,si			; which contains the original	
	      mov     bx,di			; value if odd, 0 if even. This
	      clc				;Set no overflow flag		
;	   $ENDIF				;				
$$IF89:
;	$ELSE					;				
	JMP SHORT $$EN81
$$IF81:
	   xor	   ax,ax			;				
	   xor	   bx,bx			;				
;	$ENDIF					;Multiply by 0			
$$EN81:
	pop	si				;				
	pop	di				;				
	ret					;				
										
Multiply_32_Bits endp


IFDEF DBLSPACE_HOOKS
;*****************************************************************************	
;Routine name: TryDblSpaceChkDsk
;*****************************************************************************	
;										
;Description: Sets up to spawn DBLSPACE.EXE /CHKDSK for the drive being
;	      checked.	If this routine decides not to spawn DblSpace
;	      (not checking a DblSpace drive, can't find DblSpace.exe, etc.),
;	      it returns to the caller.  Otherwise it sets up the necessary
;	      data and jmps to the SpawnAndExit routine to actually exec
;	      DblSpace.exe and then exit to MS-DOS.
;
;Input:  AL - Exit status, passed to SpawnAndExit or returned unchanged
;
;Output: Doesn't return if actually attempting to spawn DblSpace.exe
;										
;*****************************************************************************	

	assume	cs:DG, ds:NOTHING, es:NOTHING, ss:NOTHING

Procedure TryDblSpaceChkDsk

	Set_Data_Segment

	push	ax

	cmp	fSpawnDblSpace, Yes	;will == NO if CHKDSK couldn't complete
	jne	tdc_exit		;  in which case don't spawn DblSpace

	cmp	fUnderWindows, Yes	;DblSpace.exe doesn't run under Windows
	je	tdc_exit		;  so don't spawn it if we are

	call	Check_For_DblSpace	;is DblSpace installed, and if so, is
	jc	tdc_exit		;  target a compressed drive?

	call	Find_DblSpace_on_Path	;where oh where can DblSpace.exe be?
	jc	tdc_exit		;  CY set if not found

	; Setup DblSpace command line

	mov	al, AllDrv		;plug in target drive number
	add	al, 'A' - 1		;  1 based drive number to ascii
	mov	DblCmdDrive, al

	cmp	DoFix, ON		;was /F given on command line?
	jne	tdc_move_tail

	mov	word ptr DblCmdSwitch,	 '/ '	; Yes, add /F to
	mov	byte ptr DblCmdSwitch+2, 'F'	;   DblSpace cmd tail

	add	byte ptr DblSpaceCmdTail, 3	; len of ' /F'

tdc_move_tail:
	mov	cl, DblSpaceCmdTail
	inc	cl			;include trailing 0Dh
	inc	cl			;  and initial count byte in count
	xor	ch, ch
	mov	si, offset DG:DblSpaceCmdTail	;copy cmd tail for exec call
	mov	di, offset DG:Exec_CmdTail
	cld
	rep movsb

	pop	ax			;restore exit status in AL
	mov	es, PSP_Segment 	;SpawnAndExit want's this too
	assume	es:nothing

	jmp	SpawnAndExit		;all set, go do the spawn...

tdc_exit:
	pop	ax
	ret

TryDblSpaceChkDsk endp
ENDIF


IFDEF DBLSPACE_HOOKS
;***	Check_For_Dblspace -- see if target drive is compressed, error if so
;
;	entry:
;	   AllDrv == 1 based drive number
;
;	exit:
;	   CY set if DblSpace not installed, or AllDrv is not a compressed
;	      volume.

	assume	ds:DG, es:nothing

Check_For_Dblspace	proc	near

	mov	ax,4a11h		; See if DblSpace installed
	xor	bx,bx
	int	2fh
	or	ax,ax			; error?
	jnz	cfd_not_cvf		;  Dblspace will set ax == 0 if in
	cmp	bx,'DM'			;  and will set bx == 'DM'
	jnz	cfd_not_cvf

	mov	ax,4a11h
	mov	bx,1			; check drive map
	mov	dl,AllDrv
	dec	dl			; make drive 0 based
	int	2fh
	test	bl,80h			; compressed volume?
	jz	cfd_not_cvf		;   no...

	clc				;   yes!
	ret

cfd_not_cvf:
	stc				; DblSpace not installed, or drive
	ret				;   is not compressed

Check_For_Dblspace	endp
ENDIF


IFDEF DBLSPACE_HOOKS
;*****************************************************************************	
;Routine name: Find_DblSpace_on_Path
;*****************************************************************************	
;
;Description:	    Search Path for Dblspace.exe
;
;Output: no error - CF = 0	  Exec_Path filled in with
;				  full path to dblspace.exe
;	    error - CF = 1	  Dblspace.exe not found
;
; Cut and pasted from FORMAT command code
;
;*****************************************************************************	

	assume	ds:DG, es:nothing

Find_DblSpace_on_Path PROC NEAR

        push es
        push ds                         ; save our segments
        push si                         ; save DTA address

	mov	ax, PSP_Segment
	mov	es, ax			; get our PSP to ES

        call Find_Path_In_Environment   ; returns ptr to path string in ES:DI
        jc   fdp_exit                   ; no path, can't find dblspace.bin

        assume es:nothing
        mov  ax,ds                      ; swap DS and ES
        push es
        pop  ds
        assume ds:nothing
        mov  si,di                      ; DS:SI ==> Path string
        mov  es,ax
	assume es:DG

fdp_path_loop:
        mov  bh,';'                     ; path separator character
	mov  dx,offset DblSpaceBase	; base file name
	mov  di,offset DG:Exec_Path	; buffer to stick full path in
        call Path_Crunch                ; concatenate name and path
        pushf                           ; save result
        push ds                         ; save segment of Path
        push es
        pop  ds
	assume ds:DG
	mov  dx,offset DG:Exec_Path	; buffer with full path name
        mov  bx,offset DOS_BUFFER       ; DMA buffer for finds
        mov  al,1                       ; extension is specified
        call Search
        or   al,al                      ; found the file?
        pop  ds                         ; recover path segment
        assume ds:nothing
        pop  ax                         ; recover flags in AX
        jnz  fdp_exit                   ; found it!
        xchg ah,al
        sahf                            ; check Path_Crunch result
        jnc  fdp_path_loop

fdp_exit:
        pop  si
        pop  ds
        pop  es
	assume ds:DG
        ret

Find_DblSpace_on_Path ENDP
ENDIF


	pathlabl chkinit							
code	ends									
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkprmt.asm ===
;******************************************************************************
;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/21/90  EGH  C06  Problem fixed - if CHKDSK output was redirected to a
;		       file, the user response to a y/n prompt would appear
;		       in the file rather than on the screen.  Fix is to
;		       display user input via STDERR rather than STDOUT.
;  03/23/90  EGH  C07  Problem fixed - if the response to a y/n prompt was
;		       ENTER, the screen would scroll but the prompt would
;		       not be redisplayed.  Fix is to save the pointer to the
;		       message and restore it when needed.
;
;******************************************************************************
TITLE	CHKPRMT - Procedures called from chkdsk which prompt			;an000;bgb
page	,132					;				;an000;bgb
										;an000;bgb
	.xlist									;an000;bgb
	include chkseg.inc							;an000;bgb
	INCLUDE CHKCHNG.INC							;an000;bgb
	INCLUDE SYSCALL.INC							;an000;bgb
	INCLUDE CHKEQU.INC							;an000;bgb
	INCLUDE CHKMACRO.INC							;an000;bgb
	include pathmac.inc							;an000;bgb
	.list									;an000;bgb
										;an000;bgb
										;an000;bgb
CONST	SEGMENT PUBLIC PARA 'DATA'						;an000;bgb
	EXTRN	HECODE:byte,CONBUF:byte 					;an000;bgb
	EXTRN	crlf2_arg:word						   ;C06   ;an000;bgb
CONST	ENDS									;an000;bgb
										;an000;bgb
										;an000;bgb
CODE	SEGMENT PUBLIC PARA 'CODE'						;an000;bgb
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG 						;an000;bgb
	EXTRN	PRINTF_CRLF:NEAR,DOCRLF:NEAR					;an000;bgb
										;an000;bgb
	pathlabl chkprmt							;an000;bgb
;*****************************************************************************	;an000;bgb
;Routine name:PromptYN								;an000;bgb
;*****************************************************************************	;an000;bgb
;										;an000;bgb
;description: Validate that input is valid Y/N for the country dependent info	;an000;bgb
;	     Return Z flag if 'Y' entered					;an000;bgb
;Called Procedures: Message (macro)						;an000;bgb
;		    User_String 						;an000;bgb
;										;an000;bgb
;Change History: Created	5/10/87 	MT				;an000;bgb
;										;an000;bgb
;Input: DX = offset to message							;an000;bgb
;										;an000;bgb
;Output: Z flag if 'Y' entered							;an000;bgb
;										;an000;bgb
;Psuedocode									;an000;bgb
;----------									;an000;bgb
;										;an000;bgb
;	DO									;an000;bgb
;	   Display prompt and input character					;an000;bgb
;	   IF got character							;an000;bgb
;	      Check for country dependent Y/N (INT 21h, AX=6523h Get Ext Country;an000;bgb)
;	      IF NC (Yes or No) 						;an000;bgb
;		 Set Z if Yes, NZ if No 					;an000;bgb
;	      ENDIF								;an000;bgb
;	   ELSE  (nothing entered)						;an000;bgb
;	      stc								;an000;bgb
;	   ENDIF								;an000;bgb
;	ENDDO NC								;an000;bgb
;	ret									;an000;bgb
;*****************************************************************************	;an000;bgb
Procedure PromptYN				;				;an000;bgb;AN000;
	push	si				;Save reg			;an000;bgb
;	$DO					;				;an000;bgb;AC000;
$$DO1:
	   push    dx				;save ptr to message	   ;C07
	   Call    Display_Interface		;Display the message		;an000;bgb;AC000;
	   MOV	   DX,OFFSET DG:CONBUF		;Point at input buffer		;an000;bgb
;C06	   DOS_Call Std_Con_String_Input	;Get input			;an000;bgb;AC000;
;C06	   CALL    DOCRLF			;				;an000;bgb
	   call    get_input			;Get input		   ;C06
	   mov	   dx,offset dg:crlf2_arg	;Point at CR LF 	   ;C06
	   call    display_interface		;display it		   ;C06
	   MOV	   SI,OFFSET DG:CONBUF+2	;Point at contents of buffer	;an000;bgb
	   CMP	   BYTE PTR [SI-1],0		;Was there input?		;an000;bgb
;	   $IF	   NE				;Yep				;an000;bgb;AC000;
	   JE $$IF2
	      mov     al,23h			;See if it is Y/N		;an000;bgb;AN000;
	      mov     dl,[si]			;Get character			;an000;bgb;AN000;
	      DOS_Call GetExtCntry		;Get country info call		;an000;bgb;AN000;
;	      $IF     NC			;Yes or No entered		;an000;bgb;AN000;
	      JC $$IF3
		 cmp	 ax,Yes_Found		;Set Z if Yes, NZ if No 	;an000;bgb;AN000;
		 clc				;CY=0 means Y/N found		;an000;bgb
;	      $ENDIF				;CY set if neither		;an000;bgb;AN000;
$$IF3:
;	   $ELSE				;No characters input		;an000;bgb
	   JMP SHORT $$EN2
$$IF2:
	      stc				;CY means not Y/N		;an000;bgb
;	   $ENDIF				;				;an000;bgb
$$EN2:
	   pop	   dx				;restore ptr to message    ;C07
;	$ENDDO	NC				;				;an000;bgb;AN000;
	JC $$DO1
	pop	si				;				;an000;bgb
	ret					;				;an000;bgb
PromptYN endp					;				;an000;bgb;AN000;
	pathlabl chkprmt							;an000;bgb
										;an000;bgb
procedure get_input
	push	ax			;save ax
	push	bx			;save bx
	push	cx			;save cx
	push	dx			;save dx
	push	si			;save si
	push	di			;save di
	mov	si,dx			;si=ptr to start of buffer
	mov	byte ptr [si+1],0	;initialize # chars to zero
	cmp	byte ptr [si],0 	;Q: is buffer size = 0?
	je	return			; Y: then exit
	add	dx,2			;
	mov	di,dx			;di=ptr to first free buf entry
get_key:
	mov	ah,08h			;console input without echo
	int	21h			;get key
	mov	[di],al 		;save character
	cmp	al,0Dh			;Q: CR?
	je	return			; Y: exit loop
	cmp	al,00h			;Q: double byte character?
	je	get_second		; Y: get second byte
	cmp	al,08h			;Q: backspace character?
	je	backspace		; Y: handle backspace
	cmp	al,09h			;Q: tab character?
	je	get_key 		; Y: ignore it
	mov	ah,byte ptr [si]	;size of buffer
	dec	ah			;save room for CR
	cmp	ah,byte ptr [si+1]	;Q: room for character?
	je	no_room 		; N: ring bell
	mov	ah,40h			;write to file/device
	mov	bx,0002h		;use STDERR!
	mov	cx,1			;one character
	mov	dx,di			;ptr to character
	int	21h			;display character
	inc	di			;next free buf entry
	inc	byte ptr [si+1] 	;inc # of characters
	jmp	short get_key		;get next key
backspace:
	cmp	byte ptr [si+1],0	;Q: any characters?
	je	get_key 		; N: get next key
	mov	ah,40h			;write to file/device
	mov	bx,0002h		;use STDERR!
	mov	cx,1			;one character
	mov	dx,di			;ptr to character
	int	21h			;display character
	mov	ah,40h			;write to file/device
	mov	byte ptr [di],20h	;
	int	21h			;display character
	mov	ah,40h			;write to file/device
	mov	byte ptr [di],08h	;
	int	21h			;display character
	dec	di			;next free buf entry
	dec	byte ptr [si+1] 	;inc # of characters
	jmp	short get_key		;get next key
get_second:
	mov	ah,08h			;console input without echo
	int	21h			;get second byte
	jmp	short get_key		;get next key
no_room:
	mov	ah,02h			;display output
	mov	dl,07h			;bell character
	int	21h			;ring bell
	jmp	short get_key		;keep looking for CR
return:
	pop	di			;restore di
	pop	si			;restore si
	pop	dx			;restore dx
	pop	cx			;restore cx
	pop	bx			;restore bx
	pop	ax			;restore ax
	ret
get_input endp

CODE	ENDS									;an000;bgb
	END									;an000;bgb

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkproc.asm ===
;******************************************************************************
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/21/90  EGH  C00  Cleaned up build by removing unused variables, declaring
;		       functions properly, changing long JMPs to short JMPs,
;		       etc.
;  03/21/90  EGH  C02  Problem fixed - volume name was being displayed as a
;		       file if /V switch was used.  Fix is to not display file
;		       name if volume attribute set.  STR #2004
;
;******************************************************************************
TITLE	CHKPROC - PART1 Procedures called from chkdsk
page	,132					;

	.xlist
	include chkseg.inc
	INCLUDE CHKCHNG.INC
	INCLUDE DOSSYM.INC
	INCLUDE CHKEQU.INC
	INCLUDE CHKMACRO.INC
	include pathmac.inc
	include syscall.inc
	.list


DATA	SEGMENT PUBLIC PARA 'DATA'
	EXTRN	FIXMES_ARG:word,DIREC_ARG:word
	EXTRN	NULDMES:byte,NULNZ:byte,BADCLUS:byte,NORECDOT:byte
	EXTRN	NoRecDDot:Byte
	EXTRN	BADCHAIN:byte,NDOTMES:byte,CDDDMES:byte
	EXTRN	NORECDDOT1:byte,NORECDDOT2:byte,NORECDDOT3:byte
	EXTRN	STACKMES:byte
	EXTRN	BADDPBDIR:byte, BadSubDir:byte
	EXTRN	BADTARG_PTR:byte,BADTARG2:byte,JOINMES:byte
	EXTRN	PTRANDIR:byte,PTRANDIR2:byte
	EXTRN	CROSS_ARG:word,NOISY_ARG:word
	EXTRN	FILE_ARG1:WORD,FILE_ARG2:WORD,FILE_ARG:word
	EXTRN	DOTMES:byte,NOISY:byte,DOTENT:byte,HAVFIX:byte
	EXTRN	DOFIX:byte,DIRBUF:byte,PARSTR:byte,DDOTENT:byte
	EXTRN	NUL:byte,ERRSUB:word,SECONDPASS:byte,ALLFILE:byte
	EXTRN	HIDCNT:dword,HIDSIZ:word,FILCNT:dword,FILSIZ:word	   
	EXTRN	DIRCNT:dword							
	EXTRN	DIRSIZ:word							
	EXTRN	DIRTYFAT:byte,
	EXTRN	HECODE:byte
	EXTRN	ALLDRV:byte,FIXMFLG:byte,DIRCHAR:byte
	EXTRN	BIGFAT:byte,EOFVAL:word,BADVAL:word
	Extrn	fTrunc:BYTE							
	Extrn	dirsec:word							

	EXTRN	THISDPB:dword,DOTSNOGOOD:byte,NUL_ARG:byte,STACKLIM:word
	EXTRN	ZEROTRUNC:byte,NAMBUF:byte,SRFCBPT:word,FATMAP:word
	EXTRN	ISCROSS:byte,MCLUS:word,CSIZE:byte,SSIZE:word,fattbl:byte
	EXTRN	DSIZE:word,ARG1:word,ARG_BUF:byte,TMP_SPC:BYTE
	EXTRN	SECBUF:word
;;	EXTRN	Inv_XA_Msg:Byte,Alloc_XA_Msg:Byte
	Extrn	Data_Start_Low:Word,Data_Start_High:Word
	EXTRN	Read_Write_Relative:Byte
	EXTRN	MClus:Word,Chain_End:Word
	EXTRN	ExitStatus:byte
	EXTRN	longpath1:byte, longpath2:byte, longpath3:byte

XA_Buffer XAL	<>				;XA buffer space to read in 1st sector	
Head_Mark db	0				;Flag for MarkMap			
BClus	dw	0				;Bytes/Cluster
public cross_clus
Cross_Clus dw	0				;Cluster crosslink occurred on
Cluster_Count dw 0				;				
First_Cluster dw 0				;				
Previous_Cluster	dw	0		;				
XA_Pass db	0				;				
File_Size_High dw 0				;				
File_Size_Low dw 0				;				
Chain_Size_Low	dw	0			;				
Chain_Size_High dw	0			;				


public Head_Mark
public BClus
public Cluster_Count
public First_Cluster
public Previous_Cluster
public XA_Pass
public File_Size_High
public File_Size_Low
public Chain_Size_Low
public Chain_Size_High
DATA	ENDS


CODE	SEGMENT PUBLIC PARA 'CODE'
ASSUME	CS:DG,DS:DG,ES:DG,SS:DG
;Structures used by DIRPROC
SRCHFCB STRUC
	DB	44 DUP (?)
SRCHFCB ENDS
SFCBSIZ EQU	SIZE SRCHFCB
	EXTRN	PRINTF_CRLF:NEAR,SUBERRP:NEAR,FCB_TO_ASCZ:NEAR
	EXTRN	FIGREC:NEAR,EPRINT:NEAR
	EXTRN	DOINT26:NEAR,PROMPTYN:NEAR
	EXTRN	DOTCOMBMES:NEAR,FATAL:NEAR,MARKMAP:NEAR,GETFILSIZ:NEAR
	EXTRN	SYSTIME:NEAR, Read_Disk:Near,DoCRLF:Near
	extrn	crosschk:near
	extrn	UNPACK:near, PACK:near
	extrn	ChkDskExit:near

public DOTDOTHARDWAY, NODOT, DOEXTMES1, MESD1, CANTREC, DOTGOON, NODDOT
public DOEXTMES2, MESD2, NFIX, CANTREC2, NULLDIRERR, DOEXTMES3, DOTSBAD
public dotsbad2, DIRPROC, STACKISOK, NOPRINT, JOINERR
public NONULLDERr, DOTOK, DATTOK, DLINKOK, BADDSIZ, DSIZOK, CHKDOTDOT
public DOTDOTOK, DDATTOK, DDLINKOK, BADDDSIZ, DDSIZOK, ROOTDIR
public DODDH, DIRDONE, MOREDIR, FPROC1, NOPRINT2, HIDENFILE, NORMFILE, NEWDIR
public DPROC1, CONVDIR, DPROC2, CANTTARG, BogusDir, ASKCONV
public PRINTTRMES, CROSSLOOK, CHLP, CROSSLINK, CHAINDONE
public FIXENT2, RET20, FIXENT, GETENT, CLUSISOK
public SKIPLP, GOTCLUS, DOROOTDIR, RDRETRY, RDOK2, WANTROOT, CHECKNOFMES, ret14
public CHECKERR, get_currdirERR, ok_pri_dir, get_thiselERR, ok_pri_el
public get_THISEL, get_THISEL2, get_currdir, GET_END, ERRLOOP, LPDONE
public CHECK_SPLICE, NT_SPLC, MarkFAT, Bad_Cluster, Check_Chain_Sizes
public print_filename								
public NOTROOT									
public FIXDOT									


	pathlabl chkproc
SUBTTL	DIRPROC -- Recursive directory processing
PAGE
;**************************************************************************
; DOTDOTHARDWAY - change dir to the previous directory using '..'
;
; called by -
;
; inputs - parse string '..'
;
; outputs - new default directory
;
;NOTE
; On versions of DOS < 2.50 "cd .." would fail if there was no ".."
;    entry in the current directory. On versions >= 2.50 "cd .."
;    is handled as a string manipulation and therefore should always
;    work. On < 2.50 this routine didddled the current directory string
;    INSIDE THE DOS DATA STRUCTURES. This is no longer desirable, or
;    needed.
;**************************************************************************
procedure dotdothardway,near
	MOV	DX,OFFSET DG:PARSTR
	DOS_Call ChDir				;				
	RET
endproc dotdothardway


;**************************************************************************	
; NODOT - come here if there is no . entry in the first entry of the sub-	
;	  directory.  The . entry is a pointer to the subdirectory itself.	
;	  The entry from the search first did not find it, and the subdir is	
;	  not joined.  So, try to put a new . entry into the first slot.	
;										
; called by - nonullderr							
;										
; inputs -  SI - points to arg_buf, which is a filespec 			
;	    DI - points to tmp_spc, which is a filespec 			
;	    AX - return value from search first 				
;										
; outputs - if the /f parm was entered, tries to replace the . entry		
;	    AX - saves the return value from search first			
;										
; logic: 1. go display error messages.	Different messages are displayed,	
;	    depending on /f and /v parms.					
;										
;	2. go get the sector number and read it into ram			
;										
;	3. if the first entry is erased (begins with hex e5), then we can	
;	   fill it with the corrected . entry. Otherwise, go to #6.		
;										
;	4. So, fill entry with all the dir fields - name, ext, attr, date,	
;	   time, size, cluster #.						
;										
;	5. write it back to disk.						
;										
;	6. go check out the .. entry						
;**************************************************************************	
NODOT:						;No .				
	PUSH	AX			;save the return value from search 1st	
;display msgs				;;;;;;;;jnz	doextmes1		
	CMP	[NOISY],OFF		;was /v parm entered?			
;	$IF	Z			;display no /v msgs			
	JNZ $$IF1
	    call    suberrp							
					;;;;;;;;jmp	short mesd1		
;	$ELSE				;display /v msgs			
	JMP SHORT $$EN1
$$IF1:
DOEXTMES1:  mov     si,offset dg:dotmes ;first find out where we are		
	    call    get_currdirerr						
	    mov     dx,offset dg:ndotmes ;print dir, dot, and 'not found' msg	
	    call    eprint							
;	$ENDIF									
$$EN1:
										
;go find the sector								
MESD1:	XOR	AX,AX			;set entry number to zero		
	PUSH	BX			;save					
	PUSH	BP			;save					
	CALL	GETENT			;get the sector number			
	POP	BP			;restore bp				
	PUSH	BP			;put it back				
	CMP	BYTE PTR [DI],0E5H	;is this 1st entry erased/open? 	
;	$if	nz								
	JZ $$IF4
;cant fill . entry			 ;JNZ	  CANTREC			
CANTREC:    INC     [DOTSNOGOOD]						
	    CMP     [NOISY],OFF 		    ;				
;	    $if     nz								
	    JZ $$IF5
						 ;JZ	  DOTGOON		
		MOV	DX,OFFSET DG:NORECDOT					
		CALL	EPRINT							
;	    $endif								
$$IF5:
;C00	    jmp     dotgoon							
	    jmp     short dotgoon					   ;C00 	   
;	$endif									
$$IF4:

;get filename
fixdot: MOV	SI,OFFSET DG:DOTENT	;point to valid . entry
	MOV	CX,11			;move filename and ext
	REP	MOVSB				;Name
	PUSH	AX			;save disk number
;move attr byte
	MOV	AL,ISDIR		;hex 10
	STOSB					;Attribute
; Add in time for directory - BAS July 17/85
	ADD	DI,10
	push	dx			;save starting sector number		
	CALL	SYSTIME
	STOSW					; Time
	MOV	AX,DX
	STOSW					; Date
	MOV	AX,[BP+6]
	STOSW					;Alloc #
	XOR	AX,AX
	STOSW
	STOSW					;Size
	pop	dx			;restore starting sector number 	
	POP	AX			;
;write back to disk
	MOV	[HAVFIX],1			;Have a fix
	CMP	[DOFIX],0		; /f parm entered?
;	$if	nz								
	JZ $$IF8
					 ;JZ	  DOTGOON			
	    MOV     CX,1							
	    CALL    DOINT26							
					 ;JMP	  SHORT DOTGOON 		
;	$endif									
$$IF8:
;go check out .. entry
DOTGOON: POP	 BP
	POP	BX
	POP	AX
	MOV	SI,OFFSET DG:DIRBUF
	JMP	CHKDOTDOT			;Go look for ..
;*****************************************************************************




NODDOT	label	far				;No ..
	PUSH	AX				;Return from SRCH
	CMP	[NOISY],OFF			;				
	JNZ	DOEXTMES2
	CALL	SUBERRP
	JMP	SHORT MESD2
DOEXTMES2:
	MOV	SI,OFFSET DG:PARSTR
	CALL	get_currdirERR
	MOV	DX,OFFSET DG:NDOTMES
	CALL	EPRINT

MESD2:
	MOV	AX,1
	PUSH	BX
	PUSH	BP
	CALL	GETENT
	POP	BP
	PUSH	BP
	CMP	BYTE PTR [DI],0E5H		;Place to put it?
	JNZ	CANTREC2			;Nope
	MOV	SI,OFFSET DG:DDOTENT
	MOV	CX,11
	REP	MOVSB				;Name
	PUSH	AX
	MOV	AL,ISDIR
	STOSB					;Attribute
	ADD	DI,10
;
; Add in time for directory - BAS July 17/85
	push	dx			;save starting sector number		
	CALL	SYSTIME
	STOSW					; Time
	MOV	AX,DX
	STOSW					; Date
	MOV	AX,[BP+4]
	STOSW					;Alloc #
	XOR	AX,AX
	STOSW
	STOSW					;Size
	pop	dx			;restore starting sector number 	
	POP	AX
	MOV	[HAVFIX],1			;Got a fix
	CMP	[DOFIX],0
	JZ	NFIX				;No fix if no F, carry clear
	MOV	CX,1
	CALL	DOINT26
NFIX:
	restorereg <bp,bx,ax>							
	MOV	SI,OFFSET DG:DIRBUF
	JMP	far ptr ROOTDIR 			;Process files

CANTREC2:
	restorereg <bp,bx,ax>							
	CMP	[NOISY],OFF			;				
	JZ	DOTSBAD2
	MOV	DX,OFFSET DG:NORECDDOT
;C00	JMP	DOTSBAD
	JMP	SHORT DOTSBAD						   ;C00

NULLDIRERR label far	    ;dir is empty
	CMP	[NOISY],OFF			;				
	JNZ	DOEXTMES3
	CALL	SUBERRP
	JMP	SHORT DOTSBAD2
DOEXTMES3:
	MOV	SI,OFFSET DG:NUL
	CALL	get_currdirERR
	MOV	DX,OFFSET DG:NULDMES
DOTSBAD:					;Can't recover
	mov	[file_arg2],offset dg:badtarg2
	inc	byte ptr [nul_arg]
	MOV	fTrunc,TRUE
	CALL	EPRINT
dotsbad2:
	CALL	DOTDOTHARDWAY
	INC	[DOTSNOGOOD]
	MOV	SP,BP				;Pop local vars
	POP	BP				;Restore frame
	RET	4				;Pop args




PAGE
;***************************************************************************
; DIRPROC - recursive tree walker
;
; called by - main-routine in chkdsk1.sal
;
; inputs    - ax=0
;	    - two words of 0 on the stack
;
;Recursive tree walker
;dirproc(self,parent)
;****************************************************************************
DIRPROC:
    MOV     [DOTSNOGOOD],0   ;Init to dots OK - set . or .. error flag to false
    MOV     [ERRSUB],0			    ;No subdir errors yet
    PUSH    BP				    ;Save frame pointer - 0
    MOV     BP,SP			    ;ffe2 - 2c = ffb6
    SUB     SP,SFCBSIZ			    ;Only local var

; are we at stack overflow ?
    CMP     SP,[STACKLIM]		    ; ffb6 vs. 5943		    
;   $IF     NA
    JA $$IF10
;;;;;;;;JA	STACKISOK
	MOV	BX, StackMsgNo		;Out of stack /* M002 */
	JMP	FATAL
;   $ENDIF
$$IF10:

STACKISOK:
;print the files as they are found
    CMP     [NOISY],off 	    ; off= 0				    
;   $IF     NZ				;if not noisy, dont print filenames
    JZ $$IF12
;;;;;;;;JZ	NOPRINT
	CMP	[SECONDPASS],False		;				
;	$IF	Z		      ;only print on the first pass
	JNZ $$IF13
;;;;;;;;;;;;JNZ     NOPRINT			    ;Don't do it again on second pass
	    MOV     SI,OFFSET DG:NUL
	    CALL    get_CURRDIR
	    mov     dx,offset dg:DIREC_arg	    ;Tell user where we are
	    CALL    PRINTf_crlf
;	$ENDIF
$$IF13:
;   $ENDIF
$$IF12:

; initialize search fcb
NOPRINT:
    MOV     SI,OFFSET DG:ALLFILE    ;extended fcb
    MOV     DI,SP
    PUSH    DI
    MOV     CX,SFCBSIZ		    ;move 44dec bytes
    REP     MOVSB		    ;from allfile (ds:si) to es:di
; find this file
    POP     DX			    ; from push bp
    MOV     BX,DX			    ;BX points to SRCH FCB
    DOS_Call Dir_Search_First		;search for any file		    
;
    CMP     WORD PTR [BP+6],0	 ;attribute byte- root will = zero
;   $if     z
    JNZ $$IF16
	jmp  far ptr rootdir	 ;yes, we are at the root
;   $endif
$$IF16:
	OR	AL,AL		 ;check return code from search first
	JZ	NONULLDERR
	CALL	CHECK_SPLICE			; See if dir is spliced
;	$if	c
	JNC $$IF18
;;;;;;;;;;;;JC	    nulldirerr			    ; Not spliced, error
	    jmp     nulldirerr
;	$endif
$$IF18:
JOINERR:
	MOV	SI,OFFSET DG:NUL
	CALL	get_currdir
	mov	fTrunc,TRUE
	mov	dx,offset dg:joinmes		;				
	call	Printf_Crlf			;				
	mov	dx,offset dg:badtarg2		;				
	call	Printf_CRLF			;				
	CALL	DOTDOTHARDWAY
	MOV	SP,BP				;Pop local vars
	POP	BP				;Restore frame
	RET	4				;Pop args



NONULLDERR:
	MOV	SI,OFFSET DG:DIRBUF + DIRNAM
	MOV	DI,OFFSET DG:DOTENT
	MOV	CX,11
	REP	CMPSB
	JZ	DOTOK				;Got a . as first entry
	push	ax			;save return code from search first	
	CALL	CHECK_SPLICE			; See if dir is spliced
;	$IF	C			;carry means no join on this dir	
	JNC $$IF20
	    pop ax			;restore return code			 
	    jmp nodot			;goto no . entry code			
;	$ELSE				;no carry means dir is joined		
	JMP SHORT $$EN20
$$IF20:
	    pop ax			;restore return code			 
	    jmp joinerr 		;goto join error code			
;	$ENDIF				;no carry means dir is joined		
$$EN20:
;;;;;;;;JNC	JOINERR 			; spliced, stop 		
;;;;;;;;JMP	NODOT				;No .				

DOTOK:
	MOV	SI,OFFSET DG:DIRBUF
	MOV	AL,[SI.DIRATT]
	TEST	AL,ISDIR
	JNZ	DATTOK
	PUSH	SI				;. not a dir?
	MOV	SI,OFFSET DG:DOTMES
						;MOV	 DX,OFFSET DG:BADATT
	mov	dx,offset dg:norecddot2 	;				
	CALL	DOTCOMBMES
	POP	SI
	OR	[SI.DIRATT],ISDIR
	CALL	FIXENT				;Fix it
DATTOK:
	MOV	AX,[SI.DIRCLUS]
	CMP	AX,[BP+6]			;. link = MYSELF?
	JZ	DLINKOK
	PUSH	SI				;Link messed up
	MOV	SI,OFFSET DG:DOTMES
						;MOV	 DX,OFFSET DG:CLUSBAD
	mov	dx,offset dg:norecddot1 	;				
	CALL	DOTCOMBMES
	POP	SI
	MOV	AX,[BP+6]
	MOV	[SI.DIRCLUS],AX
	CALL	FIXENT				;Fix it
DLINKOK:
	MOV	AX,WORD PTR [SI.DIRESIZ]
	OR	AX,AX
	JNZ	BADDSIZ
	MOV	AX,WORD PTR [SI.DIRESIZ+2]
	OR	AX,AX
	JZ	DSIZOK
BADDSIZ:					;Size should be zero
	PUSH	SI
	MOV	SI,OFFSET DG:DOTMES
						;MOV	 DX,OFFSET DG:BADSIZM
	mov	dx,offset dg:norecddot3 	;				
	CALL	DOTCOMBMES
	POP	SI
	XOR	AX,AX
	MOV	WORD PTR [SI.DIRESIZ],AX
	MOV	WORD PTR [SI.DIRESIZ+2],AX
	CALL	FIXENT				;Fix it
DSIZOK: 					;Get next (should be ..)
	MOV	DX,BX
	DOS_Call Dir_Search_Next		;				
CHKDOTDOT:					;Come here after . failure
	OR	AL,AL
	JZ	DOTDOTOK
	 JMP	NODDOT				;No ..
DOTDOTOK:
	MOV	SI,OFFSET DG:DIRBUF + DIRNAM
	MOV	DI,OFFSET DG:DDOTENT
	MOV	CX,11
	REP	CMPSB
;	$if	nz
	JZ $$IF23
	    jmp     noddot
;;; ;;;;;;;;JNZ     NODDOT			    ;No ..
;	$endif
$$IF23:
	MOV	SI,OFFSET DG:DIRBUF
	MOV	AL,[SI.DIRATT]
	TEST	AL,ISDIR
	JNZ	DDATTOK 			;.. must be a dir
	PUSH	SI
	MOV	SI,OFFSET DG:PARSTR
						;MOV	 DX,OFFSET DG:BADATT
	mov	dx,offset dg:norecddot2 	;				
	CALL	DOTCOMBMES
	POP	SI
	OR	[SI.DIRATT],ISDIR
	CALL	FIXENT				;Fix it
DDATTOK:
	PUSH	SI
	MOV	AX,[SI.DIRCLUS]
	CMP	AX,[BP+4]			;.. link must be PARENT
	JZ	DDLINKOK
	MOV	SI,OFFSET DG:PARSTR
						;MOV	 DX,OFFSET DG:CLUSBAD
	mov	dx,offset dg:norecddot1 	;				
	CALL	DOTCOMBMES
	POP	SI
	MOV	AX,[BP+4]
	MOV	[SI.DIRCLUS],AX
	CALL	FIXENT				;Fix it
DDLINKOK:
	MOV	AX,WORD PTR [SI.DIRESIZ]
	OR	AX,AX
	JNZ	BADDDSIZ
	MOV	AX,WORD PTR [SI.DIRESIZ+2]
	OR	AX,AX
;	$if	z
	JNZ $$IF25
;C00	    jmp     DDSIZOK
	    jmp     short DDSIZOK					   ;C00
;	$endif
$$IF25:
BADDDSIZ:					;.. size should be 0
	PUSH	SI
	MOV	SI,OFFSET DG:PARSTR
						;MOV	 DX,OFFSET DG:BADSIZM
	mov	dx,offset dg:norecddot3 	;				
	CALL	DOTCOMBMES
	POP	SI
	XOR	AX,AX
	MOV	WORD PTR [SI.DIRESIZ],AX
	MOV	WORD PTR [SI.DIRESIZ+2],AX
	CALL	FIXENT				;Fix it


;***************************************************************************
; DDSIZOK - search for the next file in this directory
;***************************************************************************
DDSIZOK label far
	MOV	DX,BX				;search for Next entry
	DOS_Call Dir_Search_Next		;func=12			

ROOTDIR label far	;come here after search first .. failure also
	OR	AL,AL			; was a matching filename found?
	JZ	MOREDIR     ;zero = yes 	;More to go
	CMP	WORD PTR [BP+6],0 ;nz=no	;Am I the root?
	JZ	DIRDONE 			;Yes, no chdir
	MOV	DX,OFFSET DG:PARSTR
	DOS_Call ChDir				;				
	JNC	DIRDONE 			;Worked

; NOTE************************************************
;   On DOS >= 2.50 "cd .." should ALWAYS work since it is
;   a string manipulation. Should NEVER get to here.

	CMP	[NOISY],OFF			;				
	JZ	DODDH
	MOV	SI,OFFSET DG:NUL
	CALL	get_currdirERR
	MOV	DX,OFFSET DG:CDDDMES
	CALL	EPRINT
DODDH:
	CALL	DOTDOTHARDWAY			;Try again
DIRDONE:
	MOV	SP,BP				;Pop local vars
	POP	BP				;Restore frame
	RET	4				;Pop args



;*****************************************************************
; found at least one file in this subdir!
;*****************************************************************
MOREDIR:
	MOV	SI,OFFSET DG:DIRBUF  ;point to where ext fcb of found file is
	TEST	[SI.DIRATT],ISDIR    ;attr 010h = sub-directory
	JNZ	NEWDIR				;Is a new directory?
	CMP	[SECONDPASS],False		;no, same dir			
	JZ	FPROC1				;2nd pass here
	TEST	[SI.DIRATT],VOLIDA   		;attr=08
						;Don't chase chains on labels
	jnz	ddsizok
	CALL	CROSSLOOK			;Check for cross links
	JMP	DDSIZOK 			;Next

FPROC1:
	CMP	[NOISY],OFF			;				
	JZ	NoPrint2			;print filenames?
	TEST	[SI.DIRATT],VOLIDA		;Q: attr=08?			 ;C02
	JNZ	NoPrint2			; N: regular file		 ;C02
	call	print_filename

NOPRINT2:
	mov	Cluster_Count,0 		;No clusters for vol label	
	mov	cx,0				;setup cx for 0 size vol labels 
	TEST	[SI.DIRATT],VOLIDA   ;attr=08	;Don't chase chains on labels   
	jnz	ddsizok 			; continue if regular file
	MOV	AL,81H				;Head of file
	mov	di,word ptr [si].DIRESIZ+0	;Get file size
	mov	File_Size_Low,di		;
	mov	di,word ptr [si].DIRESIZ+2	;
	mov	File_Size_High,di		;
	mov	di,[si].DirClus 		;First cluster of file		
	CALL	MARKFAT
	MOV	CX,Cluster_Count		;Get number of clusters
;;;;;;;;PUSH	CX				;Save them
;;;;;;;;CALL	Check_Extended_Attributes	;See if XA exist, and handle	
;;;;;;;;POP	CX				;Get File length clusters
;;;;;;;;ADD	CX,Cluster_Count		;Add in XA clusters
	TEST	[SI.DIRATT],HIDDN		;
	JZ	NORMFILE			;
hidenfile:
	add	word ptr hidcnt,1	;found another hidden file	       
	adc	word ptr hidcnt+2,0	;add high word if > 64k files	     
	add	hidsiz,cx		;it was this many bytes 	     
	JMP	ddsizok 			;Next
NORMFILE:
	add	word ptr filcnt,1	;inc file counter		     
	adc	word ptr filcnt+2,0	;add high word if >64k files	     
	add	filsiz,cx		;add in size of file		     
	JMP	ddsizok 			;Next


;***************************************************************************
; NEWDIR - come here whenever you find another directory entry
; inputs: SI - points to directory entry
;***************************************************************************
NEWDIR:
	CMP	[SECONDPASS],False	;are we on 2nd pass?
	JZ	DPROC1			;zero means no - skip next part
	CALL	CROSSLOOK		;2nd pass - Check for cross links
	JMP	SHORT DPROC2		;goto dproc2
DPROC1: 				;1st pass
	MOV	AL,82H			;Head of dir
	mov	di,[si].DirClus 	;get 1st clus num from dir entry
	mov	File_Size_Low,0 	;Set to zero, shouldn't
	mov	File_Size_High,0	; be looked at for dir
	CALL	MARKFAT
	add	word ptr dircnt,1	;add 1 to the dir counter
	adc	word ptr dircnt+2,0	;add 1 to the high word if carry
	MOV	CX,Cluster_Count	;Add count of clusters in files
	CMP	[ZEROTRUNC],0		;did we modify the file size?
	JZ	DPROC2			;Dir not truncated
CONVDIR:				;yes, dir size truncated
	AND	[SI.DIRATT],NOT ISDIR	;Turn into file
	CALL	FIXENT
	JMP	ddsizok 		;Next
DPROC2:
	add	dirsiz,cx		;add in siz of clusters
; put 4 words on the stack - for next call to dirproc?
	PUSH	[ERRSUB]		;save the fcb ptr from prev dir
	PUSH	BX			;Save my srch FCB pointer
	MOV	AX,[SI].DirCLus 	;get 1st cluster number
	PUSH	AX			; Give him his own first clus pointer
	PUSH	[BP+6]			; His PARENT is me
;copy fcb name to msg string name
	ADD	SI,DIRNAM		;point to name, +08
	MOV	DI,OFFSET DG:NAMBUF
	savereg <di,ax> 		;copy to msg string
	CALL	FCB_TO_ASCZ
	restorereg <ax,di>
;check out validity of dir
	OR	AX,AX			;does the 1st clus in dir point to zero?
	JZ	BogusDir		; no, it is bogus
	mov	dx,di
	DOS_Call ChDir			; chdir to it
	JC	CANTTARG		; carry means bad dir
; go check out new dir
	CALL	DIRPROC
	POP	BX			;Get my SRCH FCB pointer back
	POP	[ERRSUB]		;restore from prev dir
	CMP	[DOTSNOGOOD],0
	JNZ	ASKCONV
	JMP	ddsizok 		;Next
;newdir error routines
CANTTARG:
;cant chdir
	ADD	SP,8			; Clean stack
	mov	SI,dx			; Pointer to bad DIR
	CALL	get_currdirERR		; returns with di pointing PAST end \0
	sub	di, offset dg:arg_buf
	cmp	di, 68			; 64 char len pathlen + C:\ + \0
	jae	PathTooLong
	MOV	DX,OFFSET DG:BADTarg_PTR
	mov	fTrunc,TRUE
	call	printf_crlf
	JMP	ddsizok 			;Next
BogusDir:
;bad dir entry
	ADD	SP,8				; clean off stack
	MOV	SI,DX				; pointer to bad dir
	CALL	get_currdirERR			; output message with dir
	MOV	DX,OFFSET DG:BadSubDir		; real error message
	CALL	EPRINT				; to stderr...
ASKCONV:
	CMP	[SECONDPASS],False		;
	jnz	ptm_0

	cmp	[NOISY],on			; /v entered ?
	jne	printtrmes

	MOV	DX,OFFSET DG:PTRANDIR		;unrecoverable error in directory
	call	printf_crlf			;display msg

PRINTTRMES:
	cmp	DoFix,ON			; are we fixing errors?
	jne	ptm_0				; jump if not

	MOV	DX,OFFSET DG:PTRANDIR2		;either case - "convert dir to file?"
	CALL	PROMPTYN			;Ask user what to do
	jz	ptm_1

ptm_0:
	jmp    ddsizok

ptm_1:
	PUSH	BP
	PUSH	BX
	MOV	AX,[BX+THISENT] 		;Entry number
	CALL	GETENT				;Get the entry
	MOV	SI,DI
	MOV	DI,OFFSET DG:DIRBUF
	PUSH	DI
	ADD	DI,DIRNAM
	MOV	CX,32
	REP	MOVSB				;Transfer entry to DIRBUF
	POP	SI
	PUSH	SI
	MOV	SI,[SI.DIRCLUS] 		;First cluster
	CALL	GETFILSIZ
	POP	SI
	POP	BX
	POP	BP
	MOV	WORD PTR [SI.DIRESIZ],AX	;Fix entry
	MOV	WORD PTR [SI.DIRESIZ+2],DX
	mov	[DOTSNOGOOD],0			; since this dir is converted
						; to a file, our work is over;
						; the parent dir is so far OK
	JMP	CONVDIR 			; convert directory

	; Come here if chdir fails and dir path > 64 characters long.  We don't
	; deal with these well (files down lower appear as lost clusters), so
	; tell the user what's wrong and bail out.  FYI, MS-DOS can't easily
	; create such long paths, but other systems (like Windows/NT) can.

PathTooLong:
	mov	dx, offset dg:longpath1 ; Display long friendly error msg
	call	printf_crlf
	mov	dx, offset dg:longpath2
	call	printf_crlf
	mov	dx, offset dg:longpath3
	call	printf_crlf
	jmp	ChkDskExit		; exit right now

;*****************************************************************************
;end of newdir
;*****************************************************************************



SUBTTL	fat-Look routines
PAGE
;*****************************************************************************
; CROSSLOOK - look at the fat, check for cross linked files
; called by -
;****************************************************************************
CROSSLOOK:
;Same as MRKFAT only simpler for pass 2
	MOV	[SRFCBPT],BX				   
	MOV	BX,SI					   
	MOV	SI,[BX.DIRCLUS] 			   
	CALL	CROSSCHK				   
	JNZ	CROSSLINK				   
;;;;;;;;mov	XA_Pass,False				   

CHLP:
	PUSH	BX					   
	CALL	UNPACK					   
	POP	BX					   
	XCHG	SI,DI					   
	CMP	SI,[EOFVAL]				   
	jae	chaindone				   
;;;;;;;;JAE	Check_XA_Cross				   
	CALL	CROSSCHK				   
	JZ	CHLP					   
	JMP SHORT CROSSLINK				   
							   
Check_XA_Cross: 			;					

;;;;;;;;mov	SI,[BX.DIR_XA]		;See if extended attribute 
;;;;;;;;cmp	si,0			;Is there?		   
;;;;;;;;je	ChainDoneJ		;No if zero		   
;	CALL	CROSSCHK		;Yes, see if crosslinked   
;	JNZ	CROSSLINKJ		;NZ means yes		   
;A_Cross_Loop:				;			   
;	PUSH	BX			;			   
;	CALL	UNPACK			;Get next cluster	   
;	POP	BX			;			   
;	XCHG	SI,DI			;			   
;	CMP	SI,[EOFVAL]		;Reach the end? 	   
;	JAE	ChainDoneJ	       ;Leave if so		   
;	CALL	CROSSCHK		;See if crosslink	   
;	JZ	XA_Cross_Loop		;Go check next cluster if not		
;	jmp	CrossLink		;Go handle crosslink	   
;

;NOCLUSTERSJ: JMP NOCLUSTERS


 CHASELOOP:							   
	 PUSH	 BX						   
	 CALL	 UNPACK 					   
	 POP	 BX						   
	 INC	 CX						   
	 XCHG	 SI,DI						   
	 CMP	 SI,[EOFVAL]					   
	 JAE	 CHAINDONE					   
	 CMP	 SI,2						   
	 JB	 MRKBAD 					   
	 CMP	 SI,[MCLUS]					   
	 JBE	 MRKOK						   
 MRKBAD:					 ;Bad cluster # in chain
	 PUSH	 CX						   
	 PUSH	 DI						   
	 CALL	 get_THISELERR					   
	 MOV	 DX,OFFSET dg:BADCHAIN				   
	 CALL	 EPRINT 					   
	 POP	 SI						   
	 MOV	 DX,0FFFH			 ;Insert EOF	   
	 CMP	 [BIGFAT],0					   
	 JZ	 FAT12_1					   
	 MOV	 DX,0FFFFH					   
 FAT12_1:							   
	 PUSH	 BX						   
	 CALL	 PACK						   
	 POP	 BX						   
	 POP	 CX						   
	 JMP SHORT CHAINDONE					   

 MRKOK:
	 CALL	 MARKMAP					   
	 JZ	 CHASELOOP					   
Public	CrossLink
CROSSLINK:					;File is cross linked
	INC	[ISCROSS]					       
	CMP	[SECONDPASS],False		;		       
	JZ	CHAINDONE			;Crosslinks only on second pass 
	mov	[cross_clus],si 		;Cluster number    
	CALL	get_THISEL					   
	Message File_Arg			;Print file out    
	MOV	DX,OFFSET DG:CROSS_arg		;Print message out 
	CALL	PRINTf_crlf					   
Public	ChainDone
CHAINDONE:
	 TEST	 [BX.DIRATT],ISDIR
	 JNZ	 NOSIZE 			 ;Don't size dirs
	 CMP	 [ISCROSS],0
	 JNZ	 NOSIZE 			 ;Don't size cross linked files
	 CMP	 [SECONDPASS],False		 ;
	 JNZ	 NOSIZE 			 ;Don't size on pass 2  (CX garbage)
	 MOV	 AL,[CSIZE]
	 XOR	 AH,AH
	 MUL	 [SSIZE]
	 PUSH	 AX				 ;Size in bytes of one alloc unit
	 MUL	 CX
	 MOV	 DI,DX				 ;Save allocation size
	 MOV	 SI,AX
	 SUB	 AX,WORD PTR [BX.DIRESIZ]
	 SBB	 DX,WORD PTR [BX.DIRESIZ+2]
	 JC	 BADFSIZ			 ;Size to big
	 OR	 DX,DX
	 JNZ	 BADFSIZ			 ;Size to small
	 POP	 DX
	 CMP	 AX,DX
	 JB	 NOSIZE 			 ;Size within one Alloc unit
	 PUSH	 DX				 ;Size too small
 PUBLIC  BadFSiz
 BADFSIZ:
	 POP	 DX
	 PUSH	 CX				 ;Save size of file
	 MOV	 WORD PTR [BX.DIRESIZ],SI
	 MOV	 WORD PTR [BX.DIRESIZ+2],DI
	 CALL	 FIXENT2			 ;Fix it
	 CALL	 get_THISELERR
	 MOV	 DX,OFFSET DG:BADCLUS
	 CALL	 EPRINT
	 POP	 CX				 ;Restore size of file
 NOSIZE:
	MOV	SI,BX
	MOV	BX,[SRFCBPT]
	RET

 NOCLUSTERS:
						 ;File is zero length
	 OR	 SI,SI
	 JZ	 CHKSIZ 			 ;Firclus is OK, Check size
	 MOV	 DX,OFFSET DG:NULNZ
 ADJUST:
	 PUSH	 DX
	 CALL	 get_THISELERR
	 POP	 DX
	 CALL	 EPRINT
	 XOR	 SI,SI
	 MOV	 [BX.DIRCLUS],SI		 ;Set it to 0
	 MOV	 WORD PTR [BX.DIRESIZ],SI	 ;Set size too
	 MOV	 WORD PTR [BX.DIRESIZ+2],SI
	 CALL	 FIXENT2			 ;Fix it
	 INC	 [ZEROTRUNC]			 ;Indicate truncation
	 JMP	 CHAINDONE

 PUBLIC  ChkSiz
 CHKSIZ:
	 MOV	 DX,OFFSET DG:BADCLUS
	 CMP	 WORD PTR [BX.DIRESIZ],0
	 JNZ	 ADJUST 			 ;Size wrong
	 CMP	 WORD PTR [BX.DIRESIZ+2],0
	 JNZ	 ADJUST 			 ;Size wrong
	 JMP	 CHAINDONE			 ;Size OK


SUBTTL	Routines for manipulating dir entries
PAGE

FIXENT2:
;Same as FIXENT only [SRFCBPT] points to the search FCB, BX points to the entry
	savereg <si,bx,cx>
	MOV	SI,BX
	MOV	BX,[SRFCBPT]
	CALL	FIXENT
	restorereg <cx,bx,si>
RET20:	RET

FIXENT:
;BX Points to search FCB
;SI Points to Entry to fix
	MOV	[HAVFIX],1			;Indicate a fix
	CMP	[DOFIX],0		;did the user enter /f flag?
	JZ	fixret			;zero means no - dont fix it
	savereg <bp,bx,si,si>
	MOV	AX,[BX+THISENT] 		;Entry number
	CALL	GETENT
	POP	SI				;Entry pointer
	ADD	SI,DIRNAM			;Point to start of entry
	MOV	CX,32
	REP	MOVSB
	INC	CL
	CALL	DOINT26
	restorereg <si,bx,bp>
fixret: RET



;*****************************************************************************	
; GETENT - calculate, and read into ram, the sector of the directory entry	
;	   that is invalid.  This entry can be in either the root directory,	
;	   or in a sub-directory.  If it is in the root, it can be in the first 
;	   sector of the root dir, or in a subsequent sector.  If it is in a	
;	   subdirectory, it can be in the first cluster of the subdir, or in	
;	   any subsequent cluster.  It can also be in the first sector of the	
;	   cluster, or in any of the following sectors within that cluster.	
;										
; WARNING!! NOTE!! --> this procedure has a limit on the input value of 64k	
;		       entries.  If the disk fails on an entry in a subdir	
;		       which has an invalid entry past this value, then the	
;		       calling procedure will probably wrap on this word value, 
;		       causing getent to calc the wrong sector, and then	
;		       corrupting the disk.  Not likely, but poss.		
;										
; called by - nodot/mesd1	 - no . entry found  (always subdir)		
;	    - noddot/mesd2	 - no .. entry found (always subdir)		
;	    - askconv/printtrmes - convert dir to file (can be in root) 	
;	    - makfillp		 - find root entry in which to place lost clus	
;										
; inputs - AX - desired entry num (in curr dir, reffed off BP)			
;		0=.   1=..   2=first entry					
;	   DX - number of lost clusters
;	   BP - ptr to extended fcb for this dir				
;	   BP+6 - 1st cluster number of this dir				
;										
; output - AX - contains number of the disk to use for int26			
;	   DI - points to entry in subdir in ram				
;	   DX - low sector number of the dir					
;	   BX - ram offset of the sector					
;	   Read_Write_Relative.Start_Sector_Hi - hi sector number of the dir	
;										
; Regs abused - all of 'em !! (ok, well, maybe not bp...)                       
;										
;logic: 1. make sure there will not be a problem with the cluster number. This	
;	   should not be a problem, since if the cluster number is invalid, it	
;	   should have been flagged by previous routines.			
;										
;	2. calc clus-num & offset						
;	   Entries * bytes/entry / BPS --> number of sectors from the beg of	
;	   the dir.  There are 16 entries per sector (starting at zero).  The	
;	   bytes/entry and bytes/sector are condensed, giving a div by 16,	
;	   instead of "* 32 / 512".  Now we have the first cluster (0-fff7),	
;	   the sector-offset (0-fff), and the entry-offset (0-f).		
;										
;	   forumla: entry (0-ffff)  /  16 = sector-offset (0-fff)  ax		
;					  = entry-offset  (0-f)    dx		
;										
;      3. if we are in the root directory, then we have the correct sector	
;	  number, so just add it to the starting sector number of the		
;	  directory.								
;										
;      4. otherwise, we are in a subdirectory.	Here, we need to get the	
;	  cluster-offset, since the sector-offset can be more than 1 cluster	
;	  in length.  So, divide the sectors by (secs/clus) to get cluster-	
;	  offset.  This value is now a power of 2, from 2 up to 16.		
;										
;	   / sectors/cluster (2-16)   = cluster offset AL			
;				      = sector	offset AH			
;										
;      5. If AL > 0, then we have to walk the fat chain to find the cluster	
;	  where this sector is.  Fortunately, we have the starting cluster	
;	  number (BX), UNPACK will find the next cluster number, and we have	
;	  the number of clusters to jump (AL).	So, move the appropriate	
;	  into the regs, and loop until completed.  Now BX has the correct	
;	  cluster number.							
;										
;      6. Now we need to translate the cluster and sector numbers into an	
;	  absolute, double word, sector number.  FIGREC will do this.		
;										
;      7. Now, from either root dir, or from subdir, we have the absolute	
;	  sector, so set up the regs, and call READ_DISK to read it into ram.	
;	  Now DX contains the sector number (low), and BX points to the 	
;	  sector in ram.							
;										
;      8. Finally, get the entry-offset that we had stored on the stack, and	
;	  translate it into a byte-offset by multpying it times the number of	
;	  bytes per entry (32).  Now DI points to the entry in ram.		
;*****************************************************************************	
GETENT: 									
	mov	bx,[bp+6]		;Get 1st cluster of subdir		
;double check for invalid cluster						
	cmp	bx,[eofval]		;Last entry in cluster? 		
;	$IF	NB								
	JB $$IF39
	    mov     bx,baddpbdirMsg    ;This should never happen /* M002 */	
	    jmp     fatal	    ;Danger, warning Phil Robins
;	$ENDIF									
$$IF39:
										
CLUSISOK:									
;calc cluster number and offset 						
	mov	cx,16			;32 bytes/entry  /  512 bytes/sec	
	xor	dx,dx			;zero out hi word for divide		
	div	cx    ;NOW- bx=first clus, ax=sec-offset, dx=entry-offset	
				    ;NOTE: ax can be > 1 cluster		
;are we at the root?								
	or	bx,bx			;cluster zero?				
;	$IF	Z			;yes, then we are in root dir		
	JNZ $$IF41
	    ;;;;;;;;jz	    wantroot		    ;Cluster 0 means root dir	
WANTROOT:   push    dx			;restored as di- ptr to invalid entry	
	    mov     dx,ax		;get sector offset			
	    add     dx,[dirsec] 	;add in first sector of dir		
	    mov     Read_Write_Relative.Start_Sector_High,0  ;save hi value	
	    ;;;;;;;;;;;JMP     DOROOTDIR ;now ready for int25			
										
;	$ELSE		;not in root dir					
	JMP SHORT $$EN41
$$IF41:
NOTROOT:    div     csize		;divide by sectors/cluster (2-16)	
			     ;AL=# cluster-offset (QUO), AH= sector-offset (REM)
	    mov     cl,al		;get cluster offset from al		
	    xor     ch,ch		;zero out hi byte to make word value	
	    or	    cx,cx    ;do we have more than one cluster worth to go yet? 
;	    $IF     NZ	     ;yes - we have to walk the chain to find it	
	    JZ $$IF43
	    ;;;;;;;;JCXZ    GOTCLUS		    ;jump if cx reg = zero	
		mov	si,bx		    ;move the cluster num for input	
SKIPLP: 	call	unpack		    ;find the next cluster number	
		xchg	si,di		    ;move it into input position	
		loop	skiplp		    ;do for number of cluster-offset	
		mov	bx,si		    ;now we have the cluster number	
;	    $ENDIF								
$$IF43:
										
;calculate the sector from the cluster & sec-offset				
GOTCLUS:    push    dx		     ;restored as di -> entry offset		
	    call    figrec	     ;Convert to sector # - ax=low, dx=hi	
;	$ENDIF	;are we in root dir?						
$$EN41:
										
DOROOTDIR:									
	mov	bx,[secbuf]		;get offset of ram area 		
	mov	al,[alldrv]		;get drive number			
	dec	al			;adjust for int25			
RDRETRY: mov	 cx,1			 ;read 1 sector 			
	call	Read_Disk		;do it					
	jnc	rdok2			;was it good?				
;Need to handle 'Fail' option of critical error here				
	JZ	RDRETRY 							
										
RDOK2:	pop	ax			;get byte-offset into sector		
	mov	cl,5		    ;value of 32= bytes per entry		
	shl	ax,cl		    ;mul entry offset to get byte offset	
	add	ax,bx			;add in offset of dir in ram		
	mov	di,ax								
	mov	al,[alldrv]		;get drive number			
	dec	al			;adjust for int26			
	RET				;di now points to offending entry	
;*****************************************************************************	




CHECKNOFMES:
	MOV	AL,1
	XCHG	AL,[FIXMFLG]
	OR	AL,AL
	JNZ	RET14				;Don't print it more than once
	CMP	[DOFIX],0
	JNZ	RET14				;Don't print it if F switch specified
	mov	dx,offset dg:FIXMES_arg
	CALL	PRINTf_crlf
	call	DoCRLF				;				
ret14:	RET

CHECKERR:
	mov	[ExitStatus], Bad_Exit		;Error, set exit errorlevel
	CALL	CHECKNOFMES
	CMP	[SECONDPASS],False		;				
	RET

get_currdirERR:
	CALL	CHECKERR
	jz	ok_pri_dir
	mov	byte ptr [arg_buf],0
	ret
ok_pri_dir:
	CALL	get_currdir
	ret

get_thiselERR:
	CALL	CHECKERR
	jz	ok_pri_el
	mov	byte ptr [arg_buf],0
ok_pri_el:
	CALL	get_thisel
	RET

get_THISEL:
	MOV	SI,BX
	ADD	SI,DIRNAM
;*****************************************************************************
; called by: checkfiles
; inputs:	AX - number of fragments
;		SI
;*****************************************************************************
get_THISEL2:
	MOV	DI,OFFSET DG:NAMBUF
	PUSH	DI
	CALL	FCB_TO_ASCZ
	POP	SI
get_currdir:
	PUSH	SI
; get drive letter prefix (c:\)
	mov	di,offset dg:arg_buf
	MOV	al,[ALLDRV]
	ADD	al,'@'
	stosb
	MOV	al,[DRVCHAR]
	stosb
	mov	al,[DIRCHAR]
	stosb
	MOV	SI,DI
; get the name of the current directory, and put it into es:di
	MOV	DL,[ALLDRV]
	DOS_Call Current_Dir			;				
GET_END:
;find the end of the string - it will be hex zero
	LODSB
	OR	AL,AL
	JNZ	GET_END
;
	DEC	SI				; Point at NUL
	MOV	DI,SI
	POP	SI			;point to begin of string
	CMP	BYTE PTR [SI],0
	JZ	LPDONE				;If tail string NUL, no '/'
; move '\' for between path and filename
	MOV	al,[DIRCHAR]
	CMP	BYTE PTR [DI - 1],AL
	JZ	ERRLOOP 			; Don't double '/' if root
	stosb
ERRLOOP:
; move filename from ds:si to es:di until find hex zero
	LODSB
	OR	AL,AL
	JZ	LPDONE
	stosb
	JMP	ERRLOOP
LPDONE:
; finish off string with hex zero for asciiz
	mov	al,0
	stosb
	RET

CHECK_SPLICE:
; Carry set if current directory is NOT spliced (joined) onto.
; Carry clear if current directory is spliced (joined) onto.

	MOV	SI,OFFSET DG:NUL
	CALL	get_currdir			; Build ASCIZ text of current dir
						;  at arg_buf
	mov	si,offset dg:arg_buf
	mov	di,offset dg:TMP_SPC
	DOS_Call xNameTrans			;				
	JC	NT_SPLC 			; Say NOT spliced if error
	CMP	WORD PTR [TMP_SPC+1],"\" SHL 8 OR ":"
	JNZ	NT_SPLC
	CMP	BYTE PTR [TMP_SPC+3],0
	JNZ	NT_SPLC
	MOV	AL,BYTE PTR [arg_buf]		; Source drive letter
	CMP	AL,BYTE PTR [TMP_SPC]		; Different from dest if spliced
	JZ	NT_SPLC 			; Drive letter didn't change
	CLC
	RET

NT_SPLC:
	STC
	RET


;*****************************************************************************
;Routine name: MarkFAT
;*****************************************************************************
;
;Description: Trace the fat chain for a single file, marking entries in FATMap,
;	      and handling errors -
;	      (crosslink, truncation, allocation error, invalid cluster entry)
;
; called by :	moredir
;		newdir
;
;Called Procedures: Unpack
;		    Bad_Cluster
;		    MarkMap
;		    Check_Chain_Sizes
;		    ThisEl
;		    Eprint
;
;Change History: Created	5/10/87 	MT
;
;Input: BX = pointer to search FCB
;	AL is head mark with app type =81h
;	SI = points to dir entry
;	DI = cluster entry of file or XA in directory
;	File_Size_Low/High = bytes length directory or XA structure says
;				the data area is
;	SecondPass = TRUE/FALSE
;	XA_Pass = TRUE/FALSE
;	EOFVal = 0FF8h/0FFF8h
;
;Output:
;	 ZEROTRUNC is non zero if the file was trimmed to zero length
;	 ISCROSS is non zero if the file is cross linked
;	 BX,SI preserved
;	 Cluster_Count = number of clusters in chain
;	 carry flag is set if the clusters are ok
;	 fatmap entries - 81h = head of file,
;			  01h = used cluster
;
;Psuedocode
;----------
;
;	ZeroTrunc,IsCross = FALSE, SRFCBPT = BX, Cluster_Count = 0
;	Get file cluster entry (CALL Unpack)
;	IF cluster < 2 or > maximum cluster (MClus)
;	   Go handle invalid cluster (CALL Bad_Cluster)
;	ELSE
;	   SEARCH
;	      Go mark cluster in FATMap (CALL MarkMAP)
;	      Turn off head bit on FATMap marker
;	   EXITIF Crosslink
;	      IsCross = TRUE
;	      IF SecondPass = FALSE
;		 Setup filename for message (CALL ThisEl)
;		 Display crosslink message (Call Eprint)
;	      ENDIF
;	   ORELSE (no crosslink)
;	      Get next cluster (CALL Unpack)
;	      IF Cluster >= EOFVAL [(0/F)FF8h]
;		 Verify file sizes (CALL Check_Chain_Sizes)
;		 clc  (Force loop to end)
;	      ELSE
;		 IF cluster < 2 or > maximum cluster (MClus)
;		    Go handle invalid cluster (CALL Bad_Cluster)
;		    clc  (Force loop to end)
;		 ELSE
;		     stc  (Force loop to keep goining
;		 ENDIF
;	      ENDIF
;	   ENDLOOP clc
;	   ENDSRCH
;	ENDIF
;	ret
;*****************************************************************************
Procedure MarkFAT				;			       
	push	si				
	push	bx				
	mov	Head_Mark,al			;Save flag to put in map	
	mov	ZeroTrunc,False 		;Init values			;     ;
	mov	IsCross,False			;				;     ;
	mov	Cluster_Count,0 		;Init count of clusters 	;     ;
	mov	SrFCBPt,bx			;Pointer to search FCB		;     ;
	mov	First_Cluster,di		;				
	mov	Previous_Cluster,di		;Init pointer
	cmp	di,2				;Cluster < 2?			
;	$IF	B,OR				;    or 			
	JB $$LL46
	cmp	di,MClus			;Cluster > total clusters?	
;	$IF	A				;				
	JNA $$IF46
$$LL46:
	    cmp word ptr [si].dirclus,0 ;if both cluster and size = 0,		
;	    $IF NE,OR			;then its not an error, 		
	    JNE $$LL47
	    cmp word ptr [si].diresiz,0 ;and dont print msg			
;	    $IF NE								
	    JE $$IF47
$$LL47:
		call	Bad_Cluster		     ;Yes, go indicate bad stuff     
;	    $ENDIF
$$IF47:
;	$ELSE					;Cluster in valid range 	
	JMP SHORT $$EN46
$$IF46:
;	   $SEARCH				;Chase the cluster chain	
$$DO50:
	      mov     al,Head_Mark		;Get flag for map 01		
	      call    MarkMap			;Mark the cluster (SI)		
	      push    ax			;Save head mark 		
	      lahf				;Save CY status
	      and     Head_Mark,Head_Mask	;Turn off head bit of map flag	
	      sahf				;Get CY flags back
	      pop     ax			;Get haed mark back		
;	   $EXITIF C				;Quit if crosslink		
	   JNC $$IF50
	      mov     IsCross,True		;Set crosslink flag		
	      cmp     SecondPass,True		;Handle crosslink 2nd pass only 
;	      $IF     E 			;This is first pass		
	      JNE $$IF52
		 mov	 Cross_Clus,di		;Put cluster in message 	
		 push	 bx			;Get dir pointer into bx	
		 push	 si			;				
		 mov	 bx,si			; for the call			
		 call	 Get_ThisELErr		;				
		 mov	 dx,offset DG:Cross_arg ;Specify error message		
		 call	 EPrint 		;Go print file and error	
		 pop	 si			;				
		 pop	 bx			;				
		 Message Cross_Arg		;				
;	      $ENDIF				;				
$$IF52:
;	   $ORELSE				;No crosslink found		
	   JMP SHORT $$SR50
$$IF50:
	      push    si			;Save dir pointer
	      mov     si,di			;Provide current cluster
	      mov     Previous_Cluster,di	;Save current cluster
	      call    UnPack			;Get next cluster entry (di)	
	      inc     Cluster_Count		;Got a cluster			
	      pop     si			;Get dir pointer back
	      cmp     di,EOFVal 		;Is it the last clus in file?	
;	      $IF     AE			;Yes - good chain so far	
	      JNAE $$IF55
		 call	 Check_Chain_Sizes	;Go verify file sizes		
		 clc				;Clear CY to force exit 	
;	      $ELSE				;Not end of chain
	      JMP SHORT $$EN55
$$IF55:
		 cmp	 di,2			;Cluster < 2?			
;		 $IF	 B,OR			;    or 			
		 JB $$LL57
		 cmp	 di,MClus		;Cluster > total clusters?	
;		 $IF	 A			;Yep				
		 JNA $$IF57
$$LL57:
		    call    Bad_Cluster 	;Yes, go indicate bad stuff	
		    clc 			;Clear CY to force loop exit	
;		 $ELSE				;No, more clusters to go	
		 JMP SHORT $$EN57
$$IF57:
		    stc 			;Set CY to keep going		
;		 $ENDIF 			;				
$$EN57:
;	      $ENDIF				;
$$EN55:
;	   $ENDLOOP NC				;Exit if done with chain	
	   JC $$DO50
;	   $ENDSRCH				;End of chain chase loop       
$$SR50:
;	$ENDIF					;
$$EN46:
	pop	bx				;Restore registers		
	pop	si				;				
	ret					;				
MarkFAT endp					;				

;*****************************************************************************
;Routine name: Bad_Cluster
;*****************************************************************************
;
;description: IF first cluster =0, truncate file or XA to zero length.
;	      If bad cluster elsewhere, put in EOFVal.
;
;Called Procedures: Get_ThisElErr
;		    Eprint
;		       FixENT2
;
;Change History: Created	5/10/87 	MT
;
;Input: First_Cluster
;	   Chain_End
;	   XA_PASS = TRUE/FALSE
;	   DI = Cluster entry
;	   SI = dir block pointer
;	   First_Cluster = first cluster or extended XA
;	   Previous_Cluster = last good cluster number
;
;Output: ZeroTrunc = TRUE/FALSE
;
;Psuedocode
;----------
;
;	Setup filename for any messages (Call Get_ThisELErr)
;	IF cluster = First_Cluster
;	   IF XA_PASS = FALSE
;		 Zero out file length in DIR
;		 Setup message (CALL Get_ThisElErr)
;		 Display message (Call Eprint)
;	   ELSE (XA pass)
;	      Zero out XA pointer
;	      Setup message (CALL Get_ThisElErr)
;	      Display message (Call Eprint)
;	   ENDIF
;	   Write out corrected directory (CALL FixENT2)
;	ELSE (cluster other than first in chain)
;	   IF XA_Pass = TRUE
;	     Display Bad XA cluster message
;	   ELSE (!XA_Pass)
;	     Display bad file chain message
;	   ENDIF
;	   Move EOF into bad cluster (CALL PACK - Chain_End)
;	ENDIF
;	ret
;*****************************************************************************
Procedure Bad_Cluster				;				
	savereg <si,di,dx,si,di,bx>		;Preserve registers		
	mov	bx,si				; for the call			
	call	Get_ThisElErr			;Setup message			
	restorereg <bx,di,si>
	cmp	di,First_Cluster	;does 1st clus point to itself? 	;Need to change the directory	
;	$IF	E,OR			;yes					; pointer if the dir cluster or 
	JE $$LL64
	push	di			;if not, try this next test		; XA is bad, or the last good	
	mov	di,Previous_Cluster	;get prev cluster			; entry was the dir cluster or	
	cmp	di,First_Cluster	;does prev clus = 1st clus?		; XA cluster.			
	pop	di			;means the 1st cluster is bad
;	$IF	E			;yes	       ;			       
	JNE $$IF64
$$LL64:
	    cmp word ptr [si].dirclus,0 ;is cluster num already 0?		
;	    $IF NE			;no, its bad				
	    JE $$IF65
		mov	dx,offset DG:NulNZ	  ;1st cluster number is invalid
		call	EPrint			  ;Go print file and error	
		mov	word ptr [si].dirclus,0   ;set cluster number to 0	
		mov	zerotrunc,true	;modified the file size 		
;	    $ENDIF			;already set to 0, dont print err msg	
$$IF65:
	    mov     word ptr [si].DIRESIZ,0   ;set file size to 0	      ;Kill the file size	      
	    mov     word ptr [si].DIRESIZ+2,0				      ;Kill the file size	    
	    mov  bx,si				 ;Get pointer to directory	 
	    call    FixEnt2			 ;Write out updated directory	 
;	$ELSE					;Not first cluster in chain	
	JMP SHORT $$EN64
$$IF64:
	      mov     dx,offset dg:Badchain	;Tell user file and error	
	      call    EPrint							
	   mov	   dx,Chain_End 		;Terminate chain at bad spot	
	   mov	   si,Previous_Cluster		;Change the last good cluster	
	   call    Pack 			;Go fix it			
;	$ENDIF					;				
$$EN64:
	restorereg <dx,di,si>
	ret					;
Bad_Cluster endp				;				

;*****************************************************************************
;Routine name: Check_Chain_Sizes
;*****************************************************************************
;
;description: See if length of chain as listed in dir or XA matches up
;	      with the number of clusters allocated. Don't check if crosslink
;	      error, or chasing directory chain.
;
;Called Procedures: FixEnt
;		    Bad_Chain_Size
;
;
;Change History: Created	5/10/87 	MT
;
;Input: CSIZE = sectors per cluster
;	SSIZE = bytes per sector
;	Cluster_Count = number of clusters in chain
;	File_Size_Low/High = bytes dir or XA says is in chain
;	SI = Pointer to Dir entry
;
;Output: Cluster_Count = Size of chain in clusters
;	 SI = Pointer to dir entry
;	 BX = SRFCBPT
;
;Psuedocode
;----------
;
;	IF !Directory attribute,AND
;	IF !Crosslinked (ISCROSS = FALSE),AND
;	IF !Second pass (SecondPass = FALSE)
;	   Compute bytes/cluster
;	   Compute bytes/chain
;	   IF size > File_Size_High/Low
;	      Fix the size (CALL Bad_Chain_Size)
;	      ELSE
;		 Subtract file size from chain length
;		 IF Difference in Chain_Length and Size >= bytes/cluster
;		    Fix the size (CALL Bad_Chain_Size)
;		 ENDIF
;	      ENDIF
;	   ENDIF
;	ENDIF
;	CX = Cluster_Count  (kept for compatibility with old code)
;	BX = SRFCPT (kept for compatibility with old code)
;	ret
;*****************************************************************************
Procedure Check_Chain_Sizes			
	push	si				;				
	push	ax				;				
	test	[si].DirAtt,Dir_Attribute	;Is this a directory?		
;	$IF	Z,AND				;No				
	JNZ $$IF69
	cmp	IsCross,False			; and,is it crosslinked?	
;	$IF	E,AND				;No				
	JNE $$IF69
	cmp	SecondPass,False		;and, is this the first pass?	
;	$IF	E				;Yes,				
	JNE $$IF69
	   xor	   ax,ax			;AX =0				
	   mov	   ax,SSize			;Get (bytes/sector) *		
	   mov	   cl,CSize			; (Sectors/cluster)		
	   mul	   cx				;AX=Bytes/cluster  (< 64k)	
	   mov	   BClus,ax			;Save Bytes/cluster		 
	   mov	   cx,Cluster_Count		;Number of clusters in chain	
	   mul	   cx				;DX:AX = bytes/chain		
	   mov	   Chain_Size_Low,ax		;Save allocation size in bytes	
	   mov	   Chain_Size_High,dx		;				
	   cmp	   dx,File_Size_High		;See if file size if greater	
;	   $IF	   E,AND			; than chain length - if	
	   JNE $$IF70
	   cmp	   ax,File_Size_Low		; so, than there is an		
;	   $IF	   B				; allocation error.		
	   JNB $$IF70
	      call    Bad_Chain_Size		;Fix it!			
;	   $ELSE				;Chain larger than file 	
	   JMP SHORT $$EN70
$$IF70:
	      cmp     dx,File_Size_High 	;See if high part lower 	
;	      $IF     B 			;Chain < filsize if so		
	      JNB $$IF72
		 call	 Bad_Chain_Size 	;Fix it!			
;	      $ELSE				;Chain > filesize		
	      JMP SHORT $$EN72
$$IF72:
		 mov	 cx,File_Size_Low	;See if within 1 cluster	
		 mov	 bx,File_Size_High	;				
		 sub	 ax,cx			;Subtract file size from	
		 sbb	 dx,bx			; the chain size		
		 cmp	 dx,0			;See if within 1 cluster	
;		 $IF	 NE,OR			;Not if high size set,or	
		 JNE $$LL74
		 cmp	 ax,BClus		;Within (bytes/cluster -1)?	
;		 $IF	 AE			;Nope, allocation error 	
		 JNAE $$IF74
$$LL74:
		    call    Bad_Chain_Size	;Go fix the chain		
;		 $ENDIF 			;				
$$IF74:
;	      $ENDIF				;				
$$EN72:
;	   $ENDIF				;				
$$EN70:
;	$ENDIF					;				
$$IF69:
	mov	bx,SrFCBPt			; Needed for compat		
	pop	ax				;Restore used regs		
	pop	si				;SI = Dir pointer		
	ret					;				;     ;
check_chain_sizes endp				;				



Procedure print_filename			
	    PUSH    BX
	    MOV     BX,SI
	    CALL    get_THISEL
	    mov     dx,offset dg:noisy_arg
	    call    printf_crlf
	    MOV     SI,BX
	    POP     BX
	    return
print_filename	  endp				;				

;these procedures were for the extended attribute support, which was removed	

;*****************************************************************************
;Routine name: Bad_Chain_Size
;*****************************************************************************
;
;Description: adjust
;	      filesize to allocation length.
;
;Called Procedures: Truncate_XA
;		    FixEnt2
;		    Get_ThisElErr
;		    Eprint
;
;Change History: Created	5/11/87 	MT
;
;Input: XA_Pass = TRUE/FALSE
;	Chain_Size_High/Low
;	SI = Dir pointer
;	Chain_Size_Low/High = length in bytes of allocation chain
;
;Output: None
;
;Psuedocode
;----------
;
;	IF XA_Pass
;	   Delete XA chain (CALL Truncate_XA)
;	ELSE
;	   Set directory entry to length = Total allocation size
;	   Go write out (CALL FixEnt2)
;	   Setup message (CALL Get_Thiselerr)
;	   Display it (Call Eprint)
;	ENDIF
;	ret
;*****************************************************************************
Procedure Bad_Chain_Size			;				
	push	es
	push	ax				;Save register			

	push	ds		 ;make es point to dg
	pop	es
;;;;;; cmp     XA_Pass,True		       ;Are we handling XA's?          
;;;;;;;;$IF	E				;Yes				
;;;;;;;;;;;call    Truncate_XA			;Go truncate the chain		
;;;;;;;;$ELSE					;Normal file chain		
	   mov	   ax,Chain_Size_Low		;Get length of allocation	
	   mov	   dx,Chain_Size_High		; chain for filesize		
	   mov	   word ptr [si].DirESiz,ax	;Put it in the directory	
	   mov	   word ptr [si+2].DirESiz,dx	;   "  "       "  "		
	   push    bx				;				
	   push    si				;				
	   mov	   bx,si			;Get pointer to directory	
	   call    FixENT2			;Write dir to disk		
	   call    Get_ThisElErr		;Setup message			
	   mov	   dx,offset DG:BadClus 	;Specify error message		
	   call    EPrint			;Go print file and error	
	   pop	   si				;				
	   pop	   bx				;				
;;;;;;;;$ENDIF					;				
	pop	ax				;Restore registers		
	pop	es
	ret					;

Bad_Chain_Size endp				;				

;*****************************************************************************
;Routine name: Truncate_XA
;*****************************************************************************
;
;Description: If /F entered, than truncate XA chain and remove pointer.
;	      If XA allocation error, than deallocate all of XA chain.
;
;Called Procedures: Get_ThisElErr
;		    Eprint
;		    MarkMap
;		    Unpack
;		    Pack
;
;Change History: Created	5/11/87 	MT
;
;Input: First_Cluster
;	   Chain_End
;	   SI = directory entry pointer
;
;
;Output: FATMap entries for XA chain zero'd out
;
;Psuedocode
;----------
;
;	Set XA pointer in dir to 0
;	Write it out (CALL FixEnt2)
;	Setup message (Call get_ThisElErr
;	Display message (Call Eprint)
;	Get first cluster number (First_Cluster)
;	DO
;	   Get first cluster entry (Call Unpack)
;	   Go mark cluster in FATMap with "Open" (CALL MarkMAP)
;	   Set cluster entry with 0000 (Call Pack)
;	ENDDO cluster value >= EOFVal
;	ret
;*****************************************************************************

;rocedure Truncate_XA				;				
;
;	push	si			     ;Save dir pointer			
;	push	bx			     ;					
;	push	si			     ;					
;	mov	bx,si			     ;Get directory pointer		
;	call	Get_ThisEl		     ;Setup message			
;	mov	dx,offset DG:Alloc_XA_Msg    ;Specify error message		
;	call	EPrint			     ;Go print file and error		
;	pop	si			     ;					
;	mov	word ptr [si].DIR_XA,No_Ext_Attrib ;Erase XA pointer		
;	call	FixENT2 		     ;Write dir entry out		
;	pop	bx			     ;					
;	mov	si,First_Cluster	     ;Get first cluster 		
;	$DO				     ;Chase and erase XA chain		
;	   call    Unpack		     ;Get next cluster			
;	   push    di			     ;Save it- DI next, SI current	
;	   mov	   al,No_Entry		     ;Free entry in map 		
;	   call    MarkMap		     ; "  "    "  "			
;	   mov	   dx,No_Entry		     ;Free up cluster in Fat		
;	   call    Pack 		     ; "  "    "  "			
;	   pop	   si			     ;Get back next cluster		
;	   cmp	   si,[EOFVal]		     ;Reached end of chain?		
;	$ENDDO	   AE			     ;Keep looping if not		
;	pop	si			     ;Restore Dir pointer		
;	ret				     ;					
;
;runcate_XA endp			     ;					

;*****************************************************************************
;Routine name: Check_Extended_Attributes
;*****************************************************************************
;
;Description: Get the first cluster of XA chain, if it is zero, than erase
;	      extended attribute pointer (/F only). Otherwise, map the
;	      cluster in the FATMAP. If crosslink found on first cluster,
;	      no more processing is done. If value other than EOF mark
;	      found in first cluster
;
;Called Procedures: Load_XA
;		    Fix_Bad_XA
;		    Check_XA_Structure
;		    MarkFAT
;
;Change History: Created	5/10/87 	MT
;
;Input: SI = pointer to directory entry
;
;Output: FATMap marked with XA_Cluster for each XA cluster found
;	    XA_PASS = NO
;
;Psuedocode
;----------
;
;	IF (XA exists for file)
;	   XA_PASS = YES
;	   DI = XA entry cluster in dir
;	   Load in first sector of XA (CALL Load_XA)
;	   IF !error
;	      File_Size_Low/High = length of XA's in bytes
;	      AL = chain head mark (XA_Chain)
;	      Trace chain and map it (CALL MarkFAT)
;	   ELSE
;	      call Bad_Cluster
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

;rocedure Check_Extended_Attributes		;				
;
;	push	ax				;Save register			
;	push	cx				;				
;	push	dx				;				
;	push	di				;				
;	mov	ax,[si].DIR_XA			;Get first cluster of XA's      
;	cmp	ax,No_Ext_Attrib		;Are there extended attrib's    
;	$IF	NE				;Quit if no			
;	   mov	   di,ax			;Pointer to current cluster	
;	   mov	   First_Cluster,di		;Remember first cluster 	
;	   mov	   XA_Pass,Yes			;Indicate processing XA's       
;	   call    Load_XA			;Go load sector 		
;	   $IF	   NC				;CY means load error		
;	      mov     ax,XA_Buffer.XAL_TSIZE	;Get bytes in XA chain		
;	      mov     File_Size_High,0		;Save it			
;	      mov     File_Size_Low,ax		;				
;	      mov     al,XA_Chain		;Set up mark for map		
;	      call    MarkFAT			;Go map out chain		
;	   $ELSE				;Error on read of XA		
;	      call    Bad_Cluster		;Delete extended attribs	
;;	   $ENDIF				;				
;	$ENDIF
;	pop	di				;Restore registers
;	pop	dx				;				
;	pop	cx				;				
;	pop	ax				;				
;	ret					;				
;
;heck_Extended_Attributes endp			;				


;*****************************************************************************
;Routine name: Load_XA
;*****************************************************************************
;
;description: Read in the first XA cluster
;
;Called Procedures: Read_Disk
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AX has start cluster of XA chain
;	SI = dir pointer
;Output: CY if read failed
;
;Psuedocode
;----------
;
;	Get start of data area
;	Get start cluster
;	Compute XA location from starting cluster
;	Read it in (CALL Read_Disk)
;	IF error
;	   stc
;	ENDIF  (NC if didn't take IF)
;	ret
;*****************************************************************************

;rocedure Load_XA				;				
;
;	push	si				;Save used registers		
;	push	cx				;				
;	push	dx				;				
;	push	bx				;				
;	sub	ax,2				;Make cluster 0 based		
;	mov	cl,CSize			;Get sectors/cluster		
;	mul	cl				;Offset sec in data area	
;	add	ax,Data_Start_Low		;Get actual sector in partition 
;	adc	dx,Data_Start_High		;   "  "    "  "		
;	mov	Read_Write_Relative.Start_Sector_High,dx ;Setup high sector addr
;	mov	bx,offset dg:XA_Buffer		;Read into buffer		
;	mov	cx,1				;Get just first sector		
;	mov	dx,ax				;Get logical sector low 	
;	mov	al,AllDrv			;Get drive number 1=A,2=B	
;	dec	al				;Make 0 based drive 0=A 	
;	call	Read_Disk			;Read in sector 		
;	$IF	C				;Problem?			
;	   stc					;				
;	$ENDIF					;				
;	pop	bx				;Restore registers		
;	pop	dx				;				
;	pop	cx				;				
;	pop	si				;				
;	ret					;				
;
;oad_XA endp					;				

;****************************************************************************
;WARNING!!! this must be the last label in the code section
;	    any changes to chkdsk.arf must take into account this area.
;	    it is used for reading things from disk into memory, such as dir
Public	CHKPRMT_End
Chkprmt_End label byte
;****************************************************************************
	pathlabl chkproc
CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\chkdsk\chkparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
										;an000;bgb
										;an000;bgb
										;an000;bgb
										;an000;bgb
data	segment public para 'DATA'                                              ;an000;bgb     ;AN000;
										;an000;bgb
										;an000;bgb
;										;an000;bgb
;*****************************************************************************	;an000;bgb
; Publics									;an000;bgb
;*****************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
;	Public	Drive_Letter_Buffer						;an000;bgb
	Public	SwBuffer							;an000;bgb
	Public	Switch_F_Buffer 						;an000;bgb
;	Public	FileSpec_Buffer 						;an000;bgb
	public	buffer								;an000;bgb
	public	sw_v, sw_f							;an000;bgb;an020;bgb
										;an000;bgb
;										;an000;bgb
;***************************************************************************	;an000;bgb
; Equates									;an000;bgb
;***************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
;Match Flags									;an000;bgb
										;an000;bgb
Numeric_Value		equ	8000h		;				;an000;bgb;AN000;
Signed_Numeric_Value	equ	4000h		;				;an000;bgb;AN000;
Simple_String		equ	2000h		;				;an000;bgb;AN000;
Date_String		equ	1000h		;				;an000;bgb;AN000;
Time_String		equ	0800h		;				;an000;bgb;AN000;
Complex_List		equ	0400h		;				;an000;bgb;AN000;
Quoted_String		equ	0080h		;				;an000;bgb;AN000;
Ignore_Colon		equ	0010h		;				;an000;bgb;AN000;
Repeats_Allowed 	equ	0002h		;				;an000;bgb;AN000;
Optional		equ	0001h		;				;an000;bgb;AN000;
Filespec		equ	0200h		;				;an000;bgb;AN000;
Drive_Only		equ	0100h		;				;an000;bgb;AN000;
										;an000;bgb
;Function_Flags 								;an000;bgb
										;an000;bgb
File_Table_Capitalize	equ	1		;				;an000;bgb;AN000;
Char_Table_Capitalize	equ	2		;				;an000;bgb;AN000;
Remove_Colon		equ	10h		;				;an000;bgb;AN000;
										;an000;bgb
;Extra delimeters and EOL							;an000;bgb
										;an000;bgb
Delimiters_Only 	equ	1		;				;an000;bgb;AN000;
EOL_Or_Delimiters	equ	2		;				;an000;bgb;AN000;
										;an000;bgb
Semi_Colon		equ	";"             ;                               ;an000;bgb;AN000;
Tab			equ	09h		;				;an000;bgb;AN000;
Colon			equ	":"             ;                               ;an000;bgb;AN000;
										;an000;bgb
										;an000;bgb
;Parse Errors									;an000;bgb
										;an000;bgb
No_Error		equ	0		;				;an000;bgb;AN000;
Too_Many_Operands	equ	1		;				;an000;bgb;AN000;
Operand_Missing 	equ	2		;				;an000;bgb;AN000;
Not_In_Switch_List	equ	3		;				;an000;bgb;AN000;
Not_In_Keyword_List	equ	4		;				;an000;bgb;AN000;
Out_Of_Range		equ	6		;				;an000;bgb;AN000;
Not_In_Value_List	equ	7		;				;an000;bgb;AN000;
Not_In_String_List	equ	8		;				;an000;bgb;AN000;
Syntax_Error		equ	9		;				;an000;bgb;AN000;
End_Of_Parse		equ	-1		;				;an000;bgb;AN000;
										;an000;bgb
;Return types									;an000;bgb
										;an000;bgb
Type_Reserved		equ	0		;				;an000;bgb;AN000;
Type_Number		equ	1		;				;an000;bgb;AN000;
Type_List_Index 	equ	2		;				;an000;bgb;AN000;
Type_String		equ	3		;				;an000;bgb;AN000;
Type_Complex		equ	4		;				;an000;bgb;AN000;
Type_Filespec		equ	5		;				;an000;bgb;AN000;
Type_Drive		equ	6		;				;an000;bgb;AN000;
Type_Date		equ	7		;				;an000;bgb;AN000;
Type_Time		equ	8		;				;an000;bgb;AN000;
Type_Quoted_String	equ	9		;				;an000;bgb;AN000;
										;an000;bgb
;Other										;an000;bgb
										;an000;bgb
None			equ	0		;				;an000;bgb;AN000;
No_Error		equ	0		;				;an000;bgb;AN000;
Switch_Found		equ	0FFFFh		;				;an000;bgb;AN000;
Range_Ok		equ	1		;				;an000;bgb;AN000;
Command_Line_Parms	equ	81h		;				;an000;bgb;AN000;
										;an000;bgb
;										;an000;bgb
;*****************************************************************************	;an000;bgb
; Parse Structures								;an000;bgb
;*****************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
Control 	 struc								;an000;bgb
										;an000;bgb
Match_Flags	dw	?							;an000;bgb
Function_Flags	dw	?							;an000;bgb
Result		dw	?							;an000;bgb
Values		dw	?							;an000;bgb
Num_Keywords	db	?							;an000;bgb
Keyword 	db	?							;an000;bgb
										;an000;bgb
Control 	ends								;an000;bgb
										;an000;bgb
;Drive_Letter_Return	 struc			 ;				;an000;bgb ;AN000;
;Drive_Type		 db	 0			 ;			;an000;bgb	   ;AN000;
;Drive_Item_Tag 	 db	 0			 ;			;an000;bgb	   ;AN000;
;Drive_Pointer		 dw	 0			 ;			;an000;bgb	   ;AN000;
;Drive_Number		 db	 0			 ;A=1, B=2, C=3 	;an000;bgb	   ;AN000;
;Drive_debug		 db	 8 dup(0)					;an000;bgb
;Drive_Letter_Return	 ends			 ;				;an000;bgb ;AN000;
;										;an000;bgb
;Filespec_Return struc				 ;AN000;SM			;an000;bgb
;Filespec_Type		 db	 0		 ;AN000;SM			;an000;bgb
;FileSpec_Item		 db	 0		 ;AN000;SM			;an000;bgb
;FileSpec_Pointer	 dw	 0		 ;AN000;SM			;an000;bgb
;Filespec_String_Off	 dw	 0		 ;AN000;SM			;an000;bgb
;FileSpec_String_Seg	 dw	 0						;an000;bgb
;FileSpec_Return ends								;an000;bgb
										;an000;bgb
single_Return struc			      ;AN000;SM 			;an000;bgb
dftype		  db	  0		  ;AN000;SM				;an000;bgb
Item		  db	  0		  ;AN000;SM				;an000;bgb
Pointer 	  dw	  0		  ;AN000;SM				;an000;bgb
drnum_stroff	  dw	  0		  ;AN000;SM				;an000;bgb
return_strseg		 dw	 0						;an000;bgb
single_return	ends								;an000;bgb
										;an000;bgb
										;an000;bgb
Switch_Return	 struc				;				;an000;bgb;AN000;
Switch_Type	db	0			;				;an000;bgb;AN000;
Switch_Item_Tag db	0			;				;an000;bgb;AN000;
Switch_Pointer	dw	0			;				;an000;bgb;AN000;
Switch_Debug	db	4 dup(0)						;an000;bgb
Switch_Return	 ends				;				;an000;bgb;AN000;
										;an000;bgb
Switch_Num_Return    struc			;				;an000;bgb;AN000;
Switch_Num_Type     db	    0			    ;				;an000;bgb    ;AN000;
Switch_Num_Item_Tag db	    0			    ;				;an000;bgb    ;AN000;
Switch_Num_Pointer  dw	    0			    ;				;an000;bgb    ;AN000;
Switch_Number_Low   dw	    0		    ;				    ;AN0;an000;bgb00;
Switch_Number_High  dw	    0		    ;				    ;AN0;an000;bgb00;
Switch_Num_Return    ends			;				;an000;bgb;AN000;
										;an000;bgb
Switch_String_Return   struc			;				;an000;bgb;AN000;
Switch_String_Type     db      0		       ;			;an000;bgb	 ;AN000;
Switch_String_Item_Tag db      0		       ;			;an000;bgb	 ;AN000;
Switch_String_Pointer  dw      0		       ;			;an000;bgb	 ;AN000;
Switch_String_Off	dw	0		;				;an000;bgb;AN000;
Switch_String_Seg	dw	0		;				;an000;bgb;AN000;
Switch_String_Return ends			;				;an000;bgb;AN000;
										;an000;bgb
										;an000;bgb
;										;an000;bgb
;**************************************************************************	;an000;bgb
; Parse tables									;an000;bgb
;**************************************************************************	;an000;bgb
;										;an000;bgb
Public	input_Table								;an000;bgb
input_Table	 label	 byte		 ;				 ;AN000;;an000;bgb
										;an000;bgb
	dw	offset dg:ext_table		;Point to next level	      ;A;an000;bgbN000;
	db	Delimiters_Only 		;				;an000;bgb;AN000;
	db	1				;				;an000;bgb;AN000;
	db	Semi_Colon			;				;an000;bgb;AN000;
										;an000;bgb
Drive_Table		label	byte						;an000;bgb;AN000;
						;				;an000;bgb
	dw	offset dg:Drive_Control_Definition ;Point to next level 	;an000;bgb   ;AN000;
	db	Delimiters_Only 		;				;an000;bgb;AN000;
	db	1				;				;an000;bgb;AN000;
	db	Semi_Colon			;				;an000;bgb;AN000;
										;an000;bgb
;										;an000;bgb
;**************************************************************************	;an000;bgb
;Define Positionals, Switches and Keywords					;an000;bgb
;**************************************************************************	;an000;bgb
;										;an000;bgb
										;an000;bgb
Public	ext_table								;an000;bgb
ext_table		   label   byte 	;				;an000;bgb;AN000;
						;				;an000;bgb
	db	0,1			;up to one parm, either drive or file	;an000;bgb;an026;bgb
	dw	dg:dfcontrol			     ;Pointer to control table	;an000;bgb     ;AN000;
	db	1				;1 switch  def			;an000;bgb;AN020;bgb
	dw	dg:SwControl		;switch control block			;an000;bgb;AN020;bgb
	db	None				;No Keywords (maxk)		;an000;bgb;AN000;
						;				;an000;bgb
Drive_Control_Definition  label   byte		;				;an000;bgb;AN000;
						;				;an000;bgb
	db	0,1				;Only drive letter positional	;an000;bgb;AN000;
	dw	dg:dfControl		    ;Pointer to control table	    ;AN0;an000;bgb00;
	db	None				;0 switches			;an000;bgb;AN000;
	db	None				;No Keywords